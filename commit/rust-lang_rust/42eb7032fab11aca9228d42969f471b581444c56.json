{"sha": "42eb7032fab11aca9228d42969f471b581444c56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyZWI3MDMyZmFiMTFhY2E5MjI4ZDQyOTY5ZjQ3MWI1ODE0NDRjNTY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T05:48:12Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T05:48:12Z"}, "message": "Fixup indentation after methodification.", "tree": {"sha": "e3f3ba04cfde555f63c5c76988f834020939d663", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3f3ba04cfde555f63c5c76988f834020939d663"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42eb7032fab11aca9228d42969f471b581444c56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42eb7032fab11aca9228d42969f471b581444c56", "html_url": "https://github.com/rust-lang/rust/commit/42eb7032fab11aca9228d42969f471b581444c56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42eb7032fab11aca9228d42969f471b581444c56/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1c170fc355947f54129a97aedcb8dea3d555f71", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1c170fc355947f54129a97aedcb8dea3d555f71", "html_url": "https://github.com/rust-lang/rust/commit/a1c170fc355947f54129a97aedcb8dea3d555f71"}], "stats": {"total": 16798, "additions": 8416, "deletions": 8382}, "files": [{"sha": "e2f27074dbfc9206a2fe466a0546ef53e9fa4b82", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -61,93 +61,93 @@ pub struct CombineFields<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-pub fn super_combine_tys<R>(&self,\n-                            relation: &mut R,\n-                            a: Ty<'tcx>,\n-                            b: Ty<'tcx>)\n-                            -> RelateResult<'tcx, Ty<'tcx>>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>\n-{\n-    let a_is_expected = relation.a_is_expected();\n-\n-    match (&a.sty, &b.sty) {\n-        // Relate integral variables to other types\n-        (&ty::TyInfer(ty::IntVar(a_id)), &ty::TyInfer(ty::IntVar(b_id))) => {\n-            self.int_unification_table\n-                .borrow_mut()\n-                .unify_var_var(a_id, b_id)\n-                .map_err(|e| int_unification_error(a_is_expected, e))?;\n-            Ok(a)\n-        }\n-        (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyInt(v)) => {\n-            self.unify_integral_variable(a_is_expected, v_id, IntType(v))\n-        }\n-        (&ty::TyInt(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n-            self.unify_integral_variable(!a_is_expected, v_id, IntType(v))\n-        }\n-        (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyUint(v)) => {\n-            self.unify_integral_variable(a_is_expected, v_id, UintType(v))\n-        }\n-        (&ty::TyUint(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n-            self.unify_integral_variable(!a_is_expected, v_id, UintType(v))\n-        }\n+    pub fn super_combine_tys<R>(&self,\n+                                relation: &mut R,\n+                                a: Ty<'tcx>,\n+                                b: Ty<'tcx>)\n+                                -> RelateResult<'tcx, Ty<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>\n+    {\n+        let a_is_expected = relation.a_is_expected();\n+\n+        match (&a.sty, &b.sty) {\n+            // Relate integral variables to other types\n+            (&ty::TyInfer(ty::IntVar(a_id)), &ty::TyInfer(ty::IntVar(b_id))) => {\n+                self.int_unification_table\n+                    .borrow_mut()\n+                    .unify_var_var(a_id, b_id)\n+                    .map_err(|e| int_unification_error(a_is_expected, e))?;\n+                Ok(a)\n+            }\n+            (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyInt(v)) => {\n+                self.unify_integral_variable(a_is_expected, v_id, IntType(v))\n+            }\n+            (&ty::TyInt(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n+                self.unify_integral_variable(!a_is_expected, v_id, IntType(v))\n+            }\n+            (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyUint(v)) => {\n+                self.unify_integral_variable(a_is_expected, v_id, UintType(v))\n+            }\n+            (&ty::TyUint(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n+                self.unify_integral_variable(!a_is_expected, v_id, UintType(v))\n+            }\n \n-        // Relate floating-point variables to other types\n-        (&ty::TyInfer(ty::FloatVar(a_id)), &ty::TyInfer(ty::FloatVar(b_id))) => {\n-            self.float_unification_table\n-                .borrow_mut()\n-                .unify_var_var(a_id, b_id)\n-                .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n-            Ok(a)\n-        }\n-        (&ty::TyInfer(ty::FloatVar(v_id)), &ty::TyFloat(v)) => {\n-            self.unify_float_variable(a_is_expected, v_id, v)\n-        }\n-        (&ty::TyFloat(v), &ty::TyInfer(ty::FloatVar(v_id))) => {\n-            self.unify_float_variable(!a_is_expected, v_id, v)\n-        }\n+            // Relate floating-point variables to other types\n+            (&ty::TyInfer(ty::FloatVar(a_id)), &ty::TyInfer(ty::FloatVar(b_id))) => {\n+                self.float_unification_table\n+                    .borrow_mut()\n+                    .unify_var_var(a_id, b_id)\n+                    .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n+                Ok(a)\n+            }\n+            (&ty::TyInfer(ty::FloatVar(v_id)), &ty::TyFloat(v)) => {\n+                self.unify_float_variable(a_is_expected, v_id, v)\n+            }\n+            (&ty::TyFloat(v), &ty::TyInfer(ty::FloatVar(v_id))) => {\n+                self.unify_float_variable(!a_is_expected, v_id, v)\n+            }\n \n-        // All other cases of inference are errors\n-        (&ty::TyInfer(_), _) |\n-        (_, &ty::TyInfer(_)) => {\n-            Err(TypeError::Sorts(ty::relate::expected_found(relation, &a, &b)))\n-        }\n+            // All other cases of inference are errors\n+            (&ty::TyInfer(_), _) |\n+            (_, &ty::TyInfer(_)) => {\n+                Err(TypeError::Sorts(ty::relate::expected_found(relation, &a, &b)))\n+            }\n \n \n-        _ => {\n-            ty::relate::super_relate_tys(relation, a, b)\n+            _ => {\n+                ty::relate::super_relate_tys(relation, a, b)\n+            }\n         }\n     }\n-}\n \n-fn unify_integral_variable(&self,\n-                           vid_is_expected: bool,\n-                           vid: ty::IntVid,\n-                           val: ty::IntVarValue)\n-                           -> RelateResult<'tcx, Ty<'tcx>>\n-{\n-    self.int_unification_table\n-        .borrow_mut()\n-        .unify_var_value(vid, val)\n-        .map_err(|e| int_unification_error(vid_is_expected, e))?;\n-    match val {\n-        IntType(v) => Ok(self.tcx.mk_mach_int(v)),\n-        UintType(v) => Ok(self.tcx.mk_mach_uint(v)),\n+    fn unify_integral_variable(&self,\n+                               vid_is_expected: bool,\n+                               vid: ty::IntVid,\n+                               val: ty::IntVarValue)\n+                               -> RelateResult<'tcx, Ty<'tcx>>\n+    {\n+        self.int_unification_table\n+            .borrow_mut()\n+            .unify_var_value(vid, val)\n+            .map_err(|e| int_unification_error(vid_is_expected, e))?;\n+        match val {\n+            IntType(v) => Ok(self.tcx.mk_mach_int(v)),\n+            UintType(v) => Ok(self.tcx.mk_mach_uint(v)),\n+        }\n     }\n-}\n \n-fn unify_float_variable(&self,\n-                        vid_is_expected: bool,\n-                        vid: ty::FloatVid,\n-                        val: ast::FloatTy)\n-                        -> RelateResult<'tcx, Ty<'tcx>>\n-{\n-    self.float_unification_table\n-        .borrow_mut()\n-        .unify_var_value(vid, val)\n-        .map_err(|e| float_unification_error(vid_is_expected, e))?;\n-    Ok(self.tcx.mk_mach_float(val))\n-}\n+    fn unify_float_variable(&self,\n+                            vid_is_expected: bool,\n+                            vid: ty::FloatVid,\n+                            val: ast::FloatTy)\n+                            -> RelateResult<'tcx, Ty<'tcx>>\n+    {\n+        self.float_unification_table\n+            .borrow_mut()\n+            .unify_var_value(vid, val)\n+            .map_err(|e| float_unification_error(vid_is_expected, e))?;\n+        Ok(self.tcx.mk_mach_float(val))\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {"}, {"sha": "6814d50107f6848fb95faab14abd786690698963", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 155, "deletions": 155, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -422,169 +422,169 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         region_vars\n     }\n \n-pub fn skolemize_late_bound_regions<T>(&self,\n-                                       binder: &ty::Binder<T>,\n-                                       snapshot: &CombinedSnapshot)\n-                                       -> (T, SkolemizationMap)\n-    where T : TypeFoldable<'tcx>\n-{\n-    /*!\n-     * Replace all regions bound by `binder` with skolemized regions and\n-     * return a map indicating which bound-region was replaced with what\n-     * skolemized region. This is the first step of checking subtyping\n-     * when higher-ranked things are involved. See `README.md` for more\n-     * details.\n-     */\n-\n-    let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n-        self.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n-    });\n-\n-    debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n-           binder,\n-           result,\n-           map);\n-\n-    (result, map)\n-}\n+    pub fn skolemize_late_bound_regions<T>(&self,\n+                                           binder: &ty::Binder<T>,\n+                                           snapshot: &CombinedSnapshot)\n+                                           -> (T, SkolemizationMap)\n+        where T : TypeFoldable<'tcx>\n+    {\n+        /*!\n+         * Replace all regions bound by `binder` with skolemized regions and\n+         * return a map indicating which bound-region was replaced with what\n+         * skolemized region. This is the first step of checking subtyping\n+         * when higher-ranked things are involved. See `README.md` for more\n+         * details.\n+         */\n \n-pub fn leak_check(&self,\n-                  overly_polymorphic: bool,\n-                  skol_map: &SkolemizationMap,\n-                  snapshot: &CombinedSnapshot)\n-                  -> RelateResult<'tcx, ()>\n-{\n-    /*!\n-     * Searches the region constriants created since `snapshot` was started\n-     * and checks to determine whether any of the skolemized regions created\n-     * in `skol_map` would \"escape\" -- meaning that they are related to\n-     * other regions in some way. If so, the higher-ranked subtyping doesn't\n-     * hold. See `README.md` for more details.\n-     */\n-\n-    debug!(\"leak_check: skol_map={:?}\",\n-           skol_map);\n-\n-    let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n-    for (&skol_br, &skol) in skol_map {\n-        let tainted = self.tainted_regions(snapshot, skol);\n-        for &tainted_region in &tainted {\n-            // Each skolemized should only be relatable to itself\n-            // or new variables:\n-            match tainted_region {\n-                ty::ReVar(vid) => {\n-                    if new_vars.iter().any(|&x| x == vid) { continue; }\n-                }\n-                _ => {\n-                    if tainted_region == skol { continue; }\n-                }\n-            };\n+        let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n+            self.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n+        });\n \n-            debug!(\"{:?} (which replaced {:?}) is tainted by {:?}\",\n-                   skol,\n-                   skol_br,\n-                   tainted_region);\n+        debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n+               binder,\n+               result,\n+               map);\n \n-            if overly_polymorphic {\n-                debug!(\"Overly polymorphic!\");\n-                return Err(TypeError::RegionsOverlyPolymorphic(skol_br,\n-                                                               tainted_region));\n-            } else {\n-                debug!(\"Not as polymorphic!\");\n-                return Err(TypeError::RegionsInsufficientlyPolymorphic(skol_br,\n-                                                                       tainted_region));\n+        (result, map)\n+    }\n+\n+    pub fn leak_check(&self,\n+                      overly_polymorphic: bool,\n+                      skol_map: &SkolemizationMap,\n+                      snapshot: &CombinedSnapshot)\n+                      -> RelateResult<'tcx, ()>\n+    {\n+        /*!\n+         * Searches the region constriants created since `snapshot` was started\n+         * and checks to determine whether any of the skolemized regions created\n+         * in `skol_map` would \"escape\" -- meaning that they are related to\n+         * other regions in some way. If so, the higher-ranked subtyping doesn't\n+         * hold. See `README.md` for more details.\n+         */\n+\n+        debug!(\"leak_check: skol_map={:?}\",\n+               skol_map);\n+\n+        let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n+        for (&skol_br, &skol) in skol_map {\n+            let tainted = self.tainted_regions(snapshot, skol);\n+            for &tainted_region in &tainted {\n+                // Each skolemized should only be relatable to itself\n+                // or new variables:\n+                match tainted_region {\n+                    ty::ReVar(vid) => {\n+                        if new_vars.iter().any(|&x| x == vid) { continue; }\n+                    }\n+                    _ => {\n+                        if tainted_region == skol { continue; }\n+                    }\n+                };\n+\n+                debug!(\"{:?} (which replaced {:?}) is tainted by {:?}\",\n+                       skol,\n+                       skol_br,\n+                       tainted_region);\n+\n+                if overly_polymorphic {\n+                    debug!(\"Overly polymorphic!\");\n+                    return Err(TypeError::RegionsOverlyPolymorphic(skol_br,\n+                                                                   tainted_region));\n+                } else {\n+                    debug!(\"Not as polymorphic!\");\n+                    return Err(TypeError::RegionsInsufficientlyPolymorphic(skol_br,\n+                                                                           tainted_region));\n+                }\n             }\n         }\n+        Ok(())\n     }\n-    Ok(())\n-}\n \n-/// This code converts from skolemized regions back to late-bound\n-/// regions. It works by replacing each region in the taint set of a\n-/// skolemized region with a bound-region. The bound region will be bound\n-/// by the outer-most binder in `value`; the caller must ensure that there is\n-/// such a binder and it is the right place.\n-///\n-/// This routine is only intended to be used when the leak-check has\n-/// passed; currently, it's used in the trait matching code to create\n-/// a set of nested obligations frmo an impl that matches against\n-/// something higher-ranked.  More details can be found in\n-/// `librustc/middle/traits/README.md`.\n-///\n-/// As a brief example, consider the obligation `for<'a> Fn(&'a int)\n-/// -> &'a int`, and the impl:\n-///\n-///     impl<A,R> Fn<A,R> for SomethingOrOther\n-///         where A : Clone\n-///     { ... }\n-///\n-/// Here we will have replaced `'a` with a skolemized region\n-/// `'0`. This means that our substitution will be `{A=>&'0\n-/// int, R=>&'0 int}`.\n-///\n-/// When we apply the substitution to the bounds, we will wind up with\n-/// `&'0 int : Clone` as a predicate. As a last step, we then go and\n-/// replace `'0` with a late-bound region `'a`.  The depth is matched\n-/// to the depth of the predicate, in this case 1, so that the final\n-/// predicate is `for<'a> &'a int : Clone`.\n-pub fn plug_leaks<T>(&self,\n-                     skol_map: SkolemizationMap,\n-                     snapshot: &CombinedSnapshot,\n-                     value: &T) -> T\n-    where T : TypeFoldable<'tcx>\n-{\n-    debug_assert!(self.leak_check(false, &skol_map, snapshot).is_ok());\n-\n-    debug!(\"plug_leaks(skol_map={:?}, value={:?})\",\n-           skol_map,\n-           value);\n-\n-    // Compute a mapping from the \"taint set\" of each skolemized\n-    // region back to the `ty::BoundRegion` that it originally\n-    // represented. Because `leak_check` passed, we know that\n-    // these taint sets are mutually disjoint.\n-    let inv_skol_map: FnvHashMap<ty::Region, ty::BoundRegion> =\n-        skol_map\n-        .into_iter()\n-        .flat_map(|(skol_br, skol)| {\n-            self.tainted_regions(snapshot, skol)\n-                .into_iter()\n-                .map(move |tainted_region| (tainted_region, skol_br))\n-        })\n-        .collect();\n-\n-    debug!(\"plug_leaks: inv_skol_map={:?}\",\n-           inv_skol_map);\n-\n-    // Remove any instantiated type variables from `value`; those can hide\n-    // references to regions from the `fold_regions` code below.\n-    let value = self.resolve_type_vars_if_possible(value);\n-\n-    // Map any skolemization byproducts back to a late-bound\n-    // region. Put that late-bound region at whatever the outermost\n-    // binder is that we encountered in `value`. The caller is\n-    // responsible for ensuring that (a) `value` contains at least one\n-    // binder and (b) that binder is the one we want to use.\n-    let result = self.tcx.fold_regions(&value, &mut false, |r, current_depth| {\n-        match inv_skol_map.get(&r) {\n-            None => r,\n-            Some(br) => {\n-                // It is the responsibility of the caller to ensure\n-                // that each skolemized region appears within a\n-                // binder. In practice, this routine is only used by\n-                // trait checking, and all of the skolemized regions\n-                // appear inside predicates, which always have\n-                // binders, so this assert is satisfied.\n-                assert!(current_depth > 1);\n-\n-                ty::ReLateBound(ty::DebruijnIndex::new(current_depth - 1), br.clone())\n+    /// This code converts from skolemized regions back to late-bound\n+    /// regions. It works by replacing each region in the taint set of a\n+    /// skolemized region with a bound-region. The bound region will be bound\n+    /// by the outer-most binder in `value`; the caller must ensure that there is\n+    /// such a binder and it is the right place.\n+    ///\n+    /// This routine is only intended to be used when the leak-check has\n+    /// passed; currently, it's used in the trait matching code to create\n+    /// a set of nested obligations frmo an impl that matches against\n+    /// something higher-ranked.  More details can be found in\n+    /// `librustc/middle/traits/README.md`.\n+    ///\n+    /// As a brief example, consider the obligation `for<'a> Fn(&'a int)\n+    /// -> &'a int`, and the impl:\n+    ///\n+    ///     impl<A,R> Fn<A,R> for SomethingOrOther\n+    ///         where A : Clone\n+    ///     { ... }\n+    ///\n+    /// Here we will have replaced `'a` with a skolemized region\n+    /// `'0`. This means that our substitution will be `{A=>&'0\n+    /// int, R=>&'0 int}`.\n+    ///\n+    /// When we apply the substitution to the bounds, we will wind up with\n+    /// `&'0 int : Clone` as a predicate. As a last step, we then go and\n+    /// replace `'0` with a late-bound region `'a`.  The depth is matched\n+    /// to the depth of the predicate, in this case 1, so that the final\n+    /// predicate is `for<'a> &'a int : Clone`.\n+    pub fn plug_leaks<T>(&self,\n+                         skol_map: SkolemizationMap,\n+                         snapshot: &CombinedSnapshot,\n+                         value: &T) -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        debug_assert!(self.leak_check(false, &skol_map, snapshot).is_ok());\n+\n+        debug!(\"plug_leaks(skol_map={:?}, value={:?})\",\n+               skol_map,\n+               value);\n+\n+        // Compute a mapping from the \"taint set\" of each skolemized\n+        // region back to the `ty::BoundRegion` that it originally\n+        // represented. Because `leak_check` passed, we know that\n+        // these taint sets are mutually disjoint.\n+        let inv_skol_map: FnvHashMap<ty::Region, ty::BoundRegion> =\n+            skol_map\n+            .into_iter()\n+            .flat_map(|(skol_br, skol)| {\n+                self.tainted_regions(snapshot, skol)\n+                    .into_iter()\n+                    .map(move |tainted_region| (tainted_region, skol_br))\n+            })\n+            .collect();\n+\n+        debug!(\"plug_leaks: inv_skol_map={:?}\",\n+               inv_skol_map);\n+\n+        // Remove any instantiated type variables from `value`; those can hide\n+        // references to regions from the `fold_regions` code below.\n+        let value = self.resolve_type_vars_if_possible(value);\n+\n+        // Map any skolemization byproducts back to a late-bound\n+        // region. Put that late-bound region at whatever the outermost\n+        // binder is that we encountered in `value`. The caller is\n+        // responsible for ensuring that (a) `value` contains at least one\n+        // binder and (b) that binder is the one we want to use.\n+        let result = self.tcx.fold_regions(&value, &mut false, |r, current_depth| {\n+            match inv_skol_map.get(&r) {\n+                None => r,\n+                Some(br) => {\n+                    // It is the responsibility of the caller to ensure\n+                    // that each skolemized region appears within a\n+                    // binder. In practice, this routine is only used by\n+                    // trait checking, and all of the skolemized regions\n+                    // appear inside predicates, which always have\n+                    // binders, so this assert is satisfied.\n+                    assert!(current_depth > 1);\n+\n+                    ty::ReLateBound(ty::DebruijnIndex::new(current_depth - 1), br.clone())\n+                }\n             }\n-        }\n-    });\n+        });\n \n-    debug!(\"plug_leaks: result={:?}\",\n-           result);\n+        debug!(\"plug_leaks: result={:?}\",\n+               result);\n \n-    result\n-}\n+        result\n+    }\n }"}, {"sha": "29d8a808de5f04f7924f2ac8aa03c9d8c1e102d9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -628,53 +628,53 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n     }\n \n-pub fn drain_fulfillment_cx_or_panic<T>(&self,\n-                                        span: Span,\n-                                        fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                        result: &T)\n-                                        -> T::Lifted\n-    where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n-{\n-    let when = \"resolving bounds after type-checking\";\n-    let v = match self.drain_fulfillment_cx(fulfill_cx, result) {\n-        Ok(v) => v,\n-        Err(errors) => {\n-            span_bug!(span, \"Encountered errors `{:?}` {}\", errors, when);\n-        }\n-    };\n+    pub fn drain_fulfillment_cx_or_panic<T>(&self,\n+                                            span: Span,\n+                                            fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                            result: &T)\n+                                            -> T::Lifted\n+        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+    {\n+        let when = \"resolving bounds after type-checking\";\n+        let v = match self.drain_fulfillment_cx(fulfill_cx, result) {\n+            Ok(v) => v,\n+            Err(errors) => {\n+                span_bug!(span, \"Encountered errors `{:?}` {}\", errors, when);\n+            }\n+        };\n \n-    match self.tcx.lift_to_global(&v) {\n-        Some(v) => v,\n-        None => {\n-            span_bug!(span, \"Uninferred types/regions in `{:?}` {}\", v, when);\n+        match self.tcx.lift_to_global(&v) {\n+            Some(v) => v,\n+            None => {\n+                span_bug!(span, \"Uninferred types/regions in `{:?}` {}\", v, when);\n+            }\n         }\n     }\n-}\n \n-/// Finishes processes any obligations that remain in the fulfillment\n-/// context, and then \"freshens\" and returns `result`. This is\n-/// primarily used during normalization and other cases where\n-/// processing the obligations in `fulfill_cx` may cause type\n-/// inference variables that appear in `result` to be unified, and\n-/// hence we need to process those obligations to get the complete\n-/// picture of the type.\n-pub fn drain_fulfillment_cx<T>(&self,\n-                               fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                               result: &T)\n-                               -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx>\n-{\n-    debug!(\"drain_fulfillment_cx(result={:?})\",\n-           result);\n-\n-    // In principle, we only need to do this so long as `result`\n-    // contains unbound type parameters. It could be a slight\n-    // optimization to stop iterating early.\n-    fulfill_cx.select_all_or_error(self)?;\n-\n-    let result = self.resolve_type_vars_if_possible(result);\n-    Ok(self.tcx.erase_regions(&result))\n-}\n+    /// Finishes processes any obligations that remain in the fulfillment\n+    /// context, and then \"freshens\" and returns `result`. This is\n+    /// primarily used during normalization and other cases where\n+    /// processing the obligations in `fulfill_cx` may cause type\n+    /// inference variables that appear in `result` to be unified, and\n+    /// hence we need to process those obligations to get the complete\n+    /// picture of the type.\n+    pub fn drain_fulfillment_cx<T>(&self,\n+                                   fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                   result: &T)\n+                                   -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        debug!(\"drain_fulfillment_cx(result={:?})\",\n+               result);\n+\n+        // In principle, we only need to do this so long as `result`\n+        // contains unbound type parameters. It could be a slight\n+        // optimization to stop iterating early.\n+        fulfill_cx.select_all_or_error(self)?;\n+\n+        let result = self.resolve_type_vars_if_possible(result);\n+        Ok(self.tcx.erase_regions(&result))\n+    }\n \n     pub fn projection_mode(&self) -> ProjectionMode {\n         self.projection_mode"}, {"sha": "8f97a89e6547e321cdccf347598a4219dae82dc4", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -21,63 +21,63 @@ use syntax::codemap::Span;\n use hir as ast;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-pub fn prohibit_type_params(self, segments: &[ast::PathSegment]) {\n-    for segment in segments {\n-        for typ in segment.parameters.types() {\n-            span_err!(self.sess, typ.span, E0109,\n-                      \"type parameters are not allowed on this type\");\n-            break;\n-        }\n-        for lifetime in segment.parameters.lifetimes() {\n-            span_err!(self.sess, lifetime.span, E0110,\n-                      \"lifetime parameters are not allowed on this type\");\n-            break;\n-        }\n-        for binding in segment.parameters.bindings() {\n-            self.prohibit_projection(binding.span);\n-            break;\n+    pub fn prohibit_type_params(self, segments: &[ast::PathSegment]) {\n+        for segment in segments {\n+            for typ in segment.parameters.types() {\n+                span_err!(self.sess, typ.span, E0109,\n+                          \"type parameters are not allowed on this type\");\n+                break;\n+            }\n+            for lifetime in segment.parameters.lifetimes() {\n+                span_err!(self.sess, lifetime.span, E0110,\n+                          \"lifetime parameters are not allowed on this type\");\n+                break;\n+            }\n+            for binding in segment.parameters.bindings() {\n+                self.prohibit_projection(binding.span);\n+                break;\n+            }\n         }\n     }\n-}\n \n-pub fn prohibit_projection(self, span: Span)\n-{\n-    span_err!(self.sess, span, E0229,\n-              \"associated type bindings are not allowed here\");\n-}\n+    pub fn prohibit_projection(self, span: Span)\n+    {\n+        span_err!(self.sess, span, E0229,\n+                  \"associated type bindings are not allowed here\");\n+    }\n \n-pub fn prim_ty_to_ty(self,\n-                     segments: &[ast::PathSegment],\n-                     nty: ast::PrimTy)\n-                     -> Ty<'tcx> {\n-    self.prohibit_type_params(segments);\n-    match nty {\n-        ast::TyBool => self.types.bool,\n-        ast::TyChar => self.types.char,\n-        ast::TyInt(it) => self.mk_mach_int(it),\n-        ast::TyUint(uit) => self.mk_mach_uint(uit),\n-        ast::TyFloat(ft) => self.mk_mach_float(ft),\n-        ast::TyStr => self.mk_str()\n+    pub fn prim_ty_to_ty(self,\n+                         segments: &[ast::PathSegment],\n+                         nty: ast::PrimTy)\n+                         -> Ty<'tcx> {\n+        self.prohibit_type_params(segments);\n+        match nty {\n+            ast::TyBool => self.types.bool,\n+            ast::TyChar => self.types.char,\n+            ast::TyInt(it) => self.mk_mach_int(it),\n+            ast::TyUint(uit) => self.mk_mach_uint(uit),\n+            ast::TyFloat(ft) => self.mk_mach_float(ft),\n+            ast::TyStr => self.mk_str()\n+        }\n     }\n-}\n \n-/// If a type in the AST is a primitive type, return the ty::Ty corresponding\n-/// to it.\n-pub fn ast_ty_to_prim_ty(self, ast_ty: &ast::Ty) -> Option<Ty<'tcx>> {\n-    if let ast::TyPath(None, ref path) = ast_ty.node {\n-        let def = match self.def_map.borrow().get(&ast_ty.id) {\n-            None => {\n-                span_bug!(ast_ty.span, \"unbound path {:?}\", path)\n+    /// If a type in the AST is a primitive type, return the ty::Ty corresponding\n+    /// to it.\n+    pub fn ast_ty_to_prim_ty(self, ast_ty: &ast::Ty) -> Option<Ty<'tcx>> {\n+        if let ast::TyPath(None, ref path) = ast_ty.node {\n+            let def = match self.def_map.borrow().get(&ast_ty.id) {\n+                None => {\n+                    span_bug!(ast_ty.span, \"unbound path {:?}\", path)\n+                }\n+                Some(d) => d.full_def()\n+            };\n+            if let Def::PrimTy(nty) = def {\n+                Some(self.prim_ty_to_ty(&path.segments, nty))\n+            } else {\n+                None\n             }\n-            Some(d) => d.full_def()\n-        };\n-        if let Def::PrimTy(nty) = def {\n-            Some(self.prim_ty_to_ty(&path.segments, nty))\n         } else {\n             None\n         }\n-    } else {\n-        None\n     }\n }\n-}"}, {"sha": "c2db6de03700e254c0a93d35b5093e3509030e2f", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -670,46 +670,46 @@ fn is_staged_api<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> bool {\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n-/// Lookup the stability for a node, loading external crate\n-/// metadata as necessary.\n-pub fn lookup_stability(self, id: DefId) -> Option<&'tcx Stability> {\n-    if let Some(st) = self.stability.borrow().stab_map.get(&id) {\n-        return *st;\n+    /// Lookup the stability for a node, loading external crate\n+    /// metadata as necessary.\n+    pub fn lookup_stability(self, id: DefId) -> Option<&'tcx Stability> {\n+        if let Some(st) = self.stability.borrow().stab_map.get(&id) {\n+            return *st;\n+        }\n+\n+        let st = self.lookup_stability_uncached(id);\n+        self.stability.borrow_mut().stab_map.insert(id, st);\n+        st\n     }\n \n-    let st = self.lookup_stability_uncached(id);\n-    self.stability.borrow_mut().stab_map.insert(id, st);\n-    st\n-}\n+    pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n+        if let Some(depr) = self.stability.borrow().depr_map.get(&id) {\n+            return depr.clone();\n+        }\n \n-pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n-    if let Some(depr) = self.stability.borrow().depr_map.get(&id) {\n-        return depr.clone();\n+        let depr = self.lookup_deprecation_uncached(id);\n+        self.stability.borrow_mut().depr_map.insert(id, depr.clone());\n+        depr\n     }\n \n-    let depr = self.lookup_deprecation_uncached(id);\n-    self.stability.borrow_mut().depr_map.insert(id, depr.clone());\n-    depr\n-}\n-\n-fn lookup_stability_uncached(self, id: DefId) -> Option<&'tcx Stability> {\n-    debug!(\"lookup(id={:?})\", id);\n-    if id.is_local() {\n-        None // The stability cache is filled partially lazily\n-    } else {\n-        self.sess.cstore.stability(id).map(|st| self.intern_stability(st))\n+    fn lookup_stability_uncached(self, id: DefId) -> Option<&'tcx Stability> {\n+        debug!(\"lookup(id={:?})\", id);\n+        if id.is_local() {\n+            None // The stability cache is filled partially lazily\n+        } else {\n+            self.sess.cstore.stability(id).map(|st| self.intern_stability(st))\n+        }\n     }\n-}\n \n-fn lookup_deprecation_uncached(self, id: DefId) -> Option<Deprecation> {\n-    debug!(\"lookup(id={:?})\", id);\n-    if id.is_local() {\n-        None // The stability cache is filled partially lazily\n-    } else {\n-        self.sess.cstore.deprecation(id)\n+    fn lookup_deprecation_uncached(self, id: DefId) -> Option<Deprecation> {\n+        debug!(\"lookup(id={:?})\", id);\n+        if id.is_local() {\n+            None // The stability cache is filled partially lazily\n+        } else {\n+            self.sess.cstore.deprecation(id)\n+        }\n     }\n }\n-}\n \n /// Given the list of enabled features that were not language features (i.e. that\n /// were expected to be library features), and the list of features used from"}, {"sha": "6c037ebd2bc73a78d7d4170d8d1eb5aa038ccec3", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 737, "deletions": 733, "changes": 1470, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -61,840 +61,844 @@ impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n-    for error in errors {\n-        self.report_fulfillment_error(error, None);\n+    pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n+        for error in errors {\n+            self.report_fulfillment_error(error, None);\n+        }\n     }\n-}\n \n-pub fn report_fulfillment_errors_as_warnings(&self,\n-                                             errors: &Vec<FulfillmentError<'tcx>>,\n-                                             node_id: ast::NodeId) {\n-    for error in errors {\n-        self.report_fulfillment_error(error, Some(node_id));\n+    pub fn report_fulfillment_errors_as_warnings(&self,\n+                                                 errors: &Vec<FulfillmentError<'tcx>>,\n+                                                 node_id: ast::NodeId) {\n+        for error in errors {\n+            self.report_fulfillment_error(error, Some(node_id));\n+        }\n     }\n-}\n \n-fn report_fulfillment_error(&self,\n-                            error: &FulfillmentError<'tcx>,\n-                            warning_node_id: Option<ast::NodeId>) {\n-    let error_key = TraitErrorKey::from_error(self, error, warning_node_id);\n-    debug!(\"report_fulfillment_errors({:?}) - key={:?}\",\n-           error, error_key);\n-    if !self.reported_trait_errors.borrow_mut().insert(error_key) {\n-        debug!(\"report_fulfillment_errors: skipping duplicate\");\n-        return;\n-    }\n-    match error.code {\n-        FulfillmentErrorCode::CodeSelectionError(ref e) => {\n-            self.report_selection_error(&error.obligation, e, warning_node_id);\n-        }\n-        FulfillmentErrorCode::CodeProjectionError(ref e) => {\n-            self.report_projection_error(&error.obligation, e, warning_node_id);\n-        }\n-        FulfillmentErrorCode::CodeAmbiguity => {\n-            self.maybe_report_ambiguity(&error.obligation);\n+    fn report_fulfillment_error(&self,\n+                                error: &FulfillmentError<'tcx>,\n+                                warning_node_id: Option<ast::NodeId>) {\n+        let error_key = TraitErrorKey::from_error(self, error, warning_node_id);\n+        debug!(\"report_fulfillment_errors({:?}) - key={:?}\",\n+               error, error_key);\n+        if !self.reported_trait_errors.borrow_mut().insert(error_key) {\n+            debug!(\"report_fulfillment_errors: skipping duplicate\");\n+            return;\n+        }\n+        match error.code {\n+            FulfillmentErrorCode::CodeSelectionError(ref e) => {\n+                self.report_selection_error(&error.obligation, e, warning_node_id);\n+            }\n+            FulfillmentErrorCode::CodeProjectionError(ref e) => {\n+                self.report_projection_error(&error.obligation, e, warning_node_id);\n+            }\n+            FulfillmentErrorCode::CodeAmbiguity => {\n+                self.maybe_report_ambiguity(&error.obligation);\n+            }\n         }\n     }\n-}\n \n-fn report_projection_error(&self,\n-                           obligation: &PredicateObligation<'tcx>,\n-                           error: &MismatchedProjectionTypes<'tcx>,\n-                           warning_node_id: Option<ast::NodeId>)\n-{\n-    let predicate =\n-        self.resolve_type_vars_if_possible(&obligation.predicate);\n-\n-    if !predicate.references_error() {\n-        if let Some(warning_node_id) = warning_node_id {\n-            self.tcx.sess.add_lint(\n-                ::lint::builtin::UNSIZED_IN_TUPLE,\n-                warning_node_id,\n-                obligation.cause.span,\n-                format!(\"type mismatch resolving `{}`: {}\",\n-                        predicate,\n-                        error.err));\n-        } else {\n-            let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0271,\n-                                           \"type mismatch resolving `{}`: {}\",\n-                                           predicate,\n-                                           error.err);\n-            self.note_obligation_cause(&mut err, obligation);\n-            err.emit();\n+    fn report_projection_error(&self,\n+                               obligation: &PredicateObligation<'tcx>,\n+                               error: &MismatchedProjectionTypes<'tcx>,\n+                               warning_node_id: Option<ast::NodeId>)\n+    {\n+        let predicate =\n+            self.resolve_type_vars_if_possible(&obligation.predicate);\n+\n+        if !predicate.references_error() {\n+            if let Some(warning_node_id) = warning_node_id {\n+                self.tcx.sess.add_lint(\n+                    ::lint::builtin::UNSIZED_IN_TUPLE,\n+                    warning_node_id,\n+                    obligation.cause.span,\n+                    format!(\"type mismatch resolving `{}`: {}\",\n+                            predicate,\n+                            error.err));\n+            } else {\n+                let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0271,\n+                                               \"type mismatch resolving `{}`: {}\",\n+                                               predicate,\n+                                               error.err);\n+                self.note_obligation_cause(&mut err, obligation);\n+                err.emit();\n+            }\n         }\n     }\n-}\n \n-fn on_unimplemented_note(&self,\n-                         trait_ref: ty::PolyTraitRef<'tcx>,\n-                         span: Span) -> Option<String> {\n-    let trait_ref = trait_ref.skip_binder();\n-    let def_id = trait_ref.def_id;\n-    let mut report = None;\n-    for item in self.tcx.get_attrs(def_id).iter() {\n-        if item.check_name(\"rustc_on_unimplemented\") {\n-            let err_sp = item.meta().span.substitute_dummy(span);\n-            let def = self.tcx.lookup_trait_def(def_id);\n-            let trait_str = def.trait_ref.to_string();\n-            if let Some(ref istring) = item.value_str() {\n-                let mut generic_map = def.generics.types.iter_enumerated()\n-                                         .map(|(param, i, gen)| {\n-                                               (gen.name.as_str().to_string(),\n-                                                trait_ref.substs.types.get(param, i)\n-                                                         .to_string())\n-                                              }).collect::<FnvHashMap<String, String>>();\n-                generic_map.insert(\"Self\".to_string(),\n-                                   trait_ref.self_ty().to_string());\n-                let parser = Parser::new(&istring);\n-                let mut errored = false;\n-                let err: String = parser.filter_map(|p| {\n-                    match p {\n-                        Piece::String(s) => Some(s),\n-                        Piece::NextArgument(a) => match a.position {\n-                            Position::ArgumentNamed(s) => match generic_map.get(s) {\n-                                Some(val) => Some(val),\n-                                None => {\n-                                    span_err!(self.tcx.sess, err_sp, E0272,\n-                                                   \"the #[rustc_on_unimplemented] \\\n-                                                            attribute on \\\n-                                                            trait definition for {} refers to \\\n-                                                            non-existent type parameter {}\",\n-                                                           trait_str, s);\n+    fn on_unimplemented_note(&self,\n+                             trait_ref: ty::PolyTraitRef<'tcx>,\n+                             span: Span) -> Option<String> {\n+        let trait_ref = trait_ref.skip_binder();\n+        let def_id = trait_ref.def_id;\n+        let mut report = None;\n+        for item in self.tcx.get_attrs(def_id).iter() {\n+            if item.check_name(\"rustc_on_unimplemented\") {\n+                let err_sp = item.meta().span.substitute_dummy(span);\n+                let def = self.tcx.lookup_trait_def(def_id);\n+                let trait_str = def.trait_ref.to_string();\n+                if let Some(ref istring) = item.value_str() {\n+                    let mut generic_map = def.generics.types.iter_enumerated()\n+                                             .map(|(param, i, gen)| {\n+                                                   (gen.name.as_str().to_string(),\n+                                                    trait_ref.substs.types.get(param, i)\n+                                                             .to_string())\n+                                                  }).collect::<FnvHashMap<String, String>>();\n+                    generic_map.insert(\"Self\".to_string(),\n+                                       trait_ref.self_ty().to_string());\n+                    let parser = Parser::new(&istring);\n+                    let mut errored = false;\n+                    let err: String = parser.filter_map(|p| {\n+                        match p {\n+                            Piece::String(s) => Some(s),\n+                            Piece::NextArgument(a) => match a.position {\n+                                Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                                    Some(val) => Some(val),\n+                                    None => {\n+                                        span_err!(self.tcx.sess, err_sp, E0272,\n+                                                       \"the #[rustc_on_unimplemented] \\\n+                                                                attribute on \\\n+                                                                trait definition for {} refers to \\\n+                                                                non-existent type parameter {}\",\n+                                                               trait_str, s);\n+                                        errored = true;\n+                                        None\n+                                    }\n+                                },\n+                                _ => {\n+                                    span_err!(self.tcx.sess, err_sp, E0273,\n+                                              \"the #[rustc_on_unimplemented] attribute \\\n+                                               on trait definition for {} must have \\\n+                                               named format arguments, eg \\\n+                                               `#[rustc_on_unimplemented = \\\n+                                                \\\"foo {{T}}\\\"]`\", trait_str);\n                                     errored = true;\n                                     None\n                                 }\n-                            },\n-                            _ => {\n-                                     span_err!(self.tcx.sess, err_sp, E0273,\n-                                               \"the #[rustc_on_unimplemented] \\\n-                                                        attribute on \\\n-                                                        trait definition for {} must have named \\\n-                                                        format arguments, \\\n-                                                        eg `#[rustc_on_unimplemented = \\\n-                                                        \\\"foo {{T}}\\\"]`\",\n-                                                       trait_str);\n-                                errored = true;\n-                                None\n                             }\n                         }\n+                    }).collect();\n+                    // Report only if the format string checks out\n+                    if !errored {\n+                        report = Some(err);\n                     }\n-                }).collect();\n-                // Report only if the format string checks out\n-                if !errored {\n-                    report = Some(err);\n+                } else {\n+                    span_err!(self.tcx.sess, err_sp, E0274,\n+                                            \"the #[rustc_on_unimplemented] attribute on \\\n+                                                     trait definition for {} must have a value, \\\n+                                                     eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n+                                                     trait_str);\n                 }\n-            } else {\n-                span_err!(self.tcx.sess, err_sp, E0274,\n-                                        \"the #[rustc_on_unimplemented] attribute on \\\n-                                                 trait definition for {} must have a value, \\\n-                                                 eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n-                                                 trait_str);\n+                break;\n             }\n-            break;\n         }\n+        report\n     }\n-    report\n-}\n \n-fn report_similar_impl_candidates(&self,\n-                                  trait_ref: ty::PolyTraitRef<'tcx>,\n-                                  err: &mut DiagnosticBuilder)\n-{\n-    let simp = fast_reject::simplify_type(self.tcx,\n-                                          trait_ref.skip_binder().self_ty(),\n-                                          true);\n-    let mut impl_candidates = Vec::new();\n-    let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id());\n-\n-    match simp {\n-        Some(simp) => trait_def.for_each_impl(self.tcx, |def_id| {\n-            let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n-            let imp_simp = fast_reject::simplify_type(self.tcx,\n-                                                      imp.self_ty(),\n-                                                      true);\n-            if let Some(imp_simp) = imp_simp {\n-                if simp != imp_simp {\n-                    return;\n+    fn report_similar_impl_candidates(&self,\n+                                      trait_ref: ty::PolyTraitRef<'tcx>,\n+                                      err: &mut DiagnosticBuilder)\n+    {\n+        let simp = fast_reject::simplify_type(self.tcx,\n+                                              trait_ref.skip_binder().self_ty(),\n+                                              true);\n+        let mut impl_candidates = Vec::new();\n+        let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id());\n+\n+        match simp {\n+            Some(simp) => trait_def.for_each_impl(self.tcx, |def_id| {\n+                let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                let imp_simp = fast_reject::simplify_type(self.tcx,\n+                                                          imp.self_ty(),\n+                                                          true);\n+                if let Some(imp_simp) = imp_simp {\n+                    if simp != imp_simp {\n+                        return;\n+                    }\n                 }\n-            }\n-            impl_candidates.push(imp);\n-        }),\n-        None => trait_def.for_each_impl(self.tcx, |def_id| {\n-            impl_candidates.push(\n-                self.tcx.impl_trait_ref(def_id).unwrap());\n-        })\n-    };\n+                impl_candidates.push(imp);\n+            }),\n+            None => trait_def.for_each_impl(self.tcx, |def_id| {\n+                impl_candidates.push(\n+                    self.tcx.impl_trait_ref(def_id).unwrap());\n+            })\n+        };\n \n-    if impl_candidates.is_empty() {\n-        return;\n-    }\n+        if impl_candidates.is_empty() {\n+            return;\n+        }\n \n-    err.help(&format!(\"the following implementations were found:\"));\n+        err.help(&format!(\"the following implementations were found:\"));\n \n-    let end = cmp::min(4, impl_candidates.len());\n-    for candidate in &impl_candidates[0..end] {\n-        err.help(&format!(\"  {:?}\", candidate));\n-    }\n-    if impl_candidates.len() > 4 {\n-        err.help(&format!(\"and {} others\", impl_candidates.len()-4));\n+        let end = cmp::min(4, impl_candidates.len());\n+        for candidate in &impl_candidates[0..end] {\n+            err.help(&format!(\"  {:?}\", candidate));\n+        }\n+        if impl_candidates.len() > 4 {\n+            err.help(&format!(\"and {} others\", impl_candidates.len()-4));\n+        }\n     }\n-}\n \n-/// Reports that an overflow has occurred and halts compilation. We\n-/// halt compilation unconditionally because it is important that\n-/// overflows never be masked -- they basically represent computations\n-/// whose result could not be truly determined and thus we can't say\n-/// if the program type checks or not -- and they are unusual\n-/// occurrences in any case.\n-pub fn report_overflow_error<T>(&self,\n-                                obligation: &Obligation<'tcx, T>,\n-                                suggest_increasing_limit: bool) -> !\n-    where T: fmt::Display + TypeFoldable<'tcx>\n-{\n-    let predicate =\n-        self.resolve_type_vars_if_possible(&obligation.predicate);\n-    let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0275,\n-                                   \"overflow evaluating the requirement `{}`\",\n-                                   predicate);\n-\n-    if suggest_increasing_limit {\n-        self.suggest_new_overflow_limit(&mut err);\n-    }\n+    /// Reports that an overflow has occurred and halts compilation. We\n+    /// halt compilation unconditionally because it is important that\n+    /// overflows never be masked -- they basically represent computations\n+    /// whose result could not be truly determined and thus we can't say\n+    /// if the program type checks or not -- and they are unusual\n+    /// occurrences in any case.\n+    pub fn report_overflow_error<T>(&self,\n+                                    obligation: &Obligation<'tcx, T>,\n+                                    suggest_increasing_limit: bool) -> !\n+        where T: fmt::Display + TypeFoldable<'tcx>\n+    {\n+        let predicate =\n+            self.resolve_type_vars_if_possible(&obligation.predicate);\n+        let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0275,\n+                                       \"overflow evaluating the requirement `{}`\",\n+                                       predicate);\n \n-    self.note_obligation_cause(&mut err, obligation);\n+        if suggest_increasing_limit {\n+            self.suggest_new_overflow_limit(&mut err);\n+        }\n \n-    err.emit();\n-    self.tcx.sess.abort_if_errors();\n-    bug!();\n-}\n+        self.note_obligation_cause(&mut err, obligation);\n \n-/// Reports that a cycle was detected which led to overflow and halts\n-/// compilation. This is equivalent to `report_overflow_error` except\n-/// that we can give a more helpful error message (and, in particular,\n-/// we do not suggest increasing the overflow limit, which is not\n-/// going to help).\n-pub fn report_overflow_error_cycle(&self, cycle: &Vec<PredicateObligation<'tcx>>) -> ! {\n-    assert!(cycle.len() > 1);\n+        err.emit();\n+        self.tcx.sess.abort_if_errors();\n+        bug!();\n+    }\n \n-    debug!(\"report_overflow_error_cycle(cycle length = {})\", cycle.len());\n+    /// Reports that a cycle was detected which led to overflow and halts\n+    /// compilation. This is equivalent to `report_overflow_error` except\n+    /// that we can give a more helpful error message (and, in particular,\n+    /// we do not suggest increasing the overflow limit, which is not\n+    /// going to help).\n+    pub fn report_overflow_error_cycle(&self, cycle: &Vec<PredicateObligation<'tcx>>) -> ! {\n+        assert!(cycle.len() > 1);\n \n-    let cycle = self.resolve_type_vars_if_possible(cycle);\n+        debug!(\"report_overflow_error_cycle(cycle length = {})\", cycle.len());\n \n-    debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n+        let cycle = self.resolve_type_vars_if_possible(cycle);\n \n-    assert_eq!(&cycle[0].predicate, &cycle.last().unwrap().predicate);\n+        debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n \n-    self.try_report_overflow_error_type_of_infinite_size(&cycle);\n-    self.report_overflow_error(&cycle[0], false);\n-}\n+        assert_eq!(&cycle[0].predicate, &cycle.last().unwrap().predicate);\n \n-/// If a cycle results from evaluated whether something is Sized, that\n-/// is a particular special case that always results from a struct or\n-/// enum definition that lacks indirection (e.g., `struct Foo { x: Foo\n-/// }`). We wish to report a targeted error for this case.\n-pub fn try_report_overflow_error_type_of_infinite_size(&self,\n-    cycle: &[PredicateObligation<'tcx>])\n-{\n-    let sized_trait = match self.tcx.lang_items.sized_trait() {\n-        Some(v) => v,\n-        None => return,\n-    };\n-    let top_is_sized = {\n-        match cycle[0].predicate {\n-            ty::Predicate::Trait(ref data) => data.def_id() == sized_trait,\n-            _ => false,\n-        }\n-    };\n-    if !top_is_sized {\n-        return;\n+        self.try_report_overflow_error_type_of_infinite_size(&cycle);\n+        self.report_overflow_error(&cycle[0], false);\n     }\n \n-    // The only way to have a type of infinite size is to have,\n-    // somewhere, a struct/enum type involved. Identify all such types\n-    // and report the cycle to the user.\n-\n-    let struct_enum_tys: Vec<_> =\n-        cycle.iter()\n-             .flat_map(|obligation| match obligation.predicate {\n-                 ty::Predicate::Trait(ref data) => {\n-                     assert_eq!(data.def_id(), sized_trait);\n-                     let self_ty = data.skip_binder().trait_ref.self_ty(); // (*)\n-                     // (*) ok to skip binder because this is just\n-                     // error reporting and regions don't really\n-                     // matter\n-                     match self_ty.sty {\n-                         ty::TyEnum(..) | ty::TyStruct(..) => Some(self_ty),\n-                         _ => None,\n+    /// If a cycle results from evaluated whether something is Sized, that\n+    /// is a particular special case that always results from a struct or\n+    /// enum definition that lacks indirection (e.g., `struct Foo { x: Foo\n+    /// }`). We wish to report a targeted error for this case.\n+    pub fn try_report_overflow_error_type_of_infinite_size(&self,\n+        cycle: &[PredicateObligation<'tcx>])\n+    {\n+        let sized_trait = match self.tcx.lang_items.sized_trait() {\n+            Some(v) => v,\n+            None => return,\n+        };\n+        let top_is_sized = {\n+            match cycle[0].predicate {\n+                ty::Predicate::Trait(ref data) => data.def_id() == sized_trait,\n+                _ => false,\n+            }\n+        };\n+        if !top_is_sized {\n+            return;\n+        }\n+\n+        // The only way to have a type of infinite size is to have,\n+        // somewhere, a struct/enum type involved. Identify all such types\n+        // and report the cycle to the user.\n+\n+        let struct_enum_tys: Vec<_> =\n+            cycle.iter()\n+                 .flat_map(|obligation| match obligation.predicate {\n+                     ty::Predicate::Trait(ref data) => {\n+                         assert_eq!(data.def_id(), sized_trait);\n+                         let self_ty = data.skip_binder().trait_ref.self_ty(); // (*)\n+                         // (*) ok to skip binder because this is just\n+                         // error reporting and regions don't really\n+                         // matter\n+                         match self_ty.sty {\n+                             ty::TyEnum(..) | ty::TyStruct(..) => Some(self_ty),\n+                             _ => None,\n+                         }\n                      }\n-                 }\n-                 _ => {\n-                     span_bug!(obligation.cause.span,\n-                               \"Sized cycle involving non-trait-ref: {:?}\",\n-                               obligation.predicate);\n-                 }\n-             })\n-             .collect();\n-\n-    assert!(!struct_enum_tys.is_empty());\n-\n-    // This is a bit tricky. We want to pick a \"main type\" in the\n-    // listing that is local to the current crate, so we can give a\n-    // good span to the user. But it might not be the first one in our\n-    // cycle list. So find the first one that is local and then\n-    // rotate.\n-    let (main_index, main_def_id) =\n-        struct_enum_tys.iter()\n-                       .enumerate()\n-                       .filter_map(|(index, ty)| match ty.sty {\n-                           ty::TyEnum(adt_def, _) | ty::TyStruct(adt_def, _)\n-                               if adt_def.did.is_local() =>\n-                               Some((index, adt_def.did)),\n-                           _ =>\n-                               None,\n-                       })\n-                       .next()\n-                       .unwrap(); // should always be SOME local type involved!\n-\n-    // Rotate so that the \"main\" type is at index 0.\n-    let struct_enum_tys: Vec<_> =\n-        struct_enum_tys.iter()\n-                       .cloned()\n-                       .skip(main_index)\n-                       .chain(struct_enum_tys.iter().cloned().take(main_index))\n-                       .collect();\n-\n-    let tcx = self.tcx;\n-    let mut err = tcx.recursive_type_with_infinite_size_error(main_def_id);\n-    let len = struct_enum_tys.len();\n-    if len > 2 {\n-        err.note(&format!(\"type `{}` is embedded within `{}`...\",\n-                 struct_enum_tys[0],\n-                 struct_enum_tys[1]));\n-        for &next_ty in &struct_enum_tys[1..len-1] {\n-            err.note(&format!(\"...which in turn is embedded within `{}`...\", next_ty));\n+                     _ => {\n+                         span_bug!(obligation.cause.span,\n+                                   \"Sized cycle involving non-trait-ref: {:?}\",\n+                                   obligation.predicate);\n+                     }\n+                 })\n+                 .collect();\n+\n+        assert!(!struct_enum_tys.is_empty());\n+\n+        // This is a bit tricky. We want to pick a \"main type\" in the\n+        // listing that is local to the current crate, so we can give a\n+        // good span to the user. But it might not be the first one in our\n+        // cycle list. So find the first one that is local and then\n+        // rotate.\n+        let (main_index, main_def_id) =\n+            struct_enum_tys.iter()\n+                           .enumerate()\n+                           .filter_map(|(index, ty)| match ty.sty {\n+                               ty::TyEnum(adt_def, _) | ty::TyStruct(adt_def, _)\n+                                   if adt_def.did.is_local() =>\n+                                   Some((index, adt_def.did)),\n+                               _ =>\n+                                   None,\n+                           })\n+                           .next()\n+                           .unwrap(); // should always be SOME local type involved!\n+\n+        // Rotate so that the \"main\" type is at index 0.\n+        let struct_enum_tys: Vec<_> =\n+            struct_enum_tys.iter()\n+                           .cloned()\n+                           .skip(main_index)\n+                           .chain(struct_enum_tys.iter().cloned().take(main_index))\n+                           .collect();\n+\n+        let tcx = self.tcx;\n+        let mut err = tcx.recursive_type_with_infinite_size_error(main_def_id);\n+        let len = struct_enum_tys.len();\n+        if len > 2 {\n+            err.note(&format!(\"type `{}` is embedded within `{}`...\",\n+                     struct_enum_tys[0],\n+                     struct_enum_tys[1]));\n+            for &next_ty in &struct_enum_tys[1..len-1] {\n+                err.note(&format!(\"...which in turn is embedded within `{}`...\", next_ty));\n+            }\n+            err.note(&format!(\"...which in turn is embedded within `{}`, \\\n+                               completing the cycle.\",\n+                              struct_enum_tys[len-1]));\n         }\n-        err.note(&format!(\"...which in turn is embedded within `{}`, \\\n-                           completing the cycle.\",\n-                          struct_enum_tys[len-1]));\n+        err.emit();\n+        self.tcx.sess.abort_if_errors();\n+        bug!();\n     }\n-    err.emit();\n-    self.tcx.sess.abort_if_errors();\n-    bug!();\n-}\n \n-pub fn report_selection_error(&self,\n-                              obligation: &PredicateObligation<'tcx>,\n-                              error: &SelectionError<'tcx>,\n-                              warning_node_id: Option<ast::NodeId>)\n-{\n-    let span = obligation.cause.span;\n-    let mut err = match *error {\n-        SelectionError::Unimplemented => {\n-            if let ObligationCauseCode::CompareImplMethodObligation = obligation.cause.code {\n-                span_err!(\n-                    self.tcx.sess, span, E0276,\n-                    \"the requirement `{}` appears on the impl \\\n-                     method but not on the corresponding trait method\",\n-                    obligation.predicate);\n-                return;\n-            } else {\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(ref trait_predicate) => {\n-                        let trait_predicate =\n-                            self.resolve_type_vars_if_possible(trait_predicate);\n+    pub fn report_selection_error(&self,\n+                                  obligation: &PredicateObligation<'tcx>,\n+                                  error: &SelectionError<'tcx>,\n+                                  warning_node_id: Option<ast::NodeId>)\n+    {\n+        let span = obligation.cause.span;\n+        let mut err = match *error {\n+            SelectionError::Unimplemented => {\n+                if let ObligationCauseCode::CompareImplMethodObligation = obligation.cause.code {\n+                    span_err!(\n+                        self.tcx.sess, span, E0276,\n+                        \"the requirement `{}` appears on the impl \\\n+                         method but not on the corresponding trait method\",\n+                        obligation.predicate);\n+                    return;\n+                } else {\n+                    match obligation.predicate {\n+                        ty::Predicate::Trait(ref trait_predicate) => {\n+                            let trait_predicate =\n+                                self.resolve_type_vars_if_possible(trait_predicate);\n \n-                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n-                            return;\n-                        } else {\n-                            let trait_ref = trait_predicate.to_poly_trait_ref();\n-\n-                            if let Some(warning_node_id) = warning_node_id {\n-                                self.tcx.sess.add_lint(\n-                                    ::lint::builtin::UNSIZED_IN_TUPLE,\n-                                    warning_node_id,\n-                                    obligation.cause.span,\n-                                    format!(\"the trait bound `{}` is not satisfied\",\n-                                            trait_ref.to_predicate()));\n+                            if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n                                 return;\n-                            }\n-\n-                            let mut err = struct_span_err!(\n-                                self.tcx.sess, span, E0277,\n-                                \"the trait bound `{}` is not satisfied\",\n-                                trait_ref.to_predicate());\n-\n-                            // Try to report a help message\n-\n-                            if !trait_ref.has_infer_types() &&\n-                                self.predicate_can_apply(trait_ref)\n-                            {\n-                                // If a where-clause may be useful, remind the\n-                                // user that they can add it.\n-                                //\n-                                // don't display an on-unimplemented note, as\n-                                // these notes will often be of the form\n-                                //     \"the type `T` can't be frobnicated\"\n-                                // which is somewhat confusing.\n-                                err.help(&format!(\"consider adding a `where {}` bound\",\n-                                    trait_ref.to_predicate()\n-                                    ));\n-                            } else if let Some(s) = self.on_unimplemented_note(trait_ref, span) {\n-                                // Otherwise, if there is an on-unimplemented note,\n-                                // display it.\n-                                err.note(&s);\n                             } else {\n-                                // If we can't show anything useful, try to find\n-                                // similar impls.\n+                                let trait_ref = trait_predicate.to_poly_trait_ref();\n+\n+                                if let Some(warning_node_id) = warning_node_id {\n+                                    self.tcx.sess.add_lint(\n+                                        ::lint::builtin::UNSIZED_IN_TUPLE,\n+                                        warning_node_id,\n+                                        obligation.cause.span,\n+                                        format!(\"the trait bound `{}` is not satisfied\",\n+                                                trait_ref.to_predicate()));\n+                                    return;\n+                                }\n \n-                                self.report_similar_impl_candidates(trait_ref, &mut err);\n+                                let mut err = struct_span_err!(\n+                                    self.tcx.sess, span, E0277,\n+                                    \"the trait bound `{}` is not satisfied\",\n+                                    trait_ref.to_predicate());\n+\n+                                // Try to report a help message\n+\n+                                if !trait_ref.has_infer_types() &&\n+                                    self.predicate_can_apply(trait_ref)\n+                                {\n+                                    // If a where-clause may be useful, remind the\n+                                    // user that they can add it.\n+                                    //\n+                                    // don't display an on-unimplemented note, as\n+                                    // these notes will often be of the form\n+                                    //     \"the type `T` can't be frobnicated\"\n+                                    // which is somewhat confusing.\n+                                    err.help(&format!(\"consider adding a `where {}` bound\",\n+                                        trait_ref.to_predicate()\n+                                        ));\n+                                } else if let Some(s) =\n+                                        self.on_unimplemented_note(trait_ref, span) {\n+                                    // Otherwise, if there is an on-unimplemented note,\n+                                    // display it.\n+                                    err.note(&s);\n+                                } else {\n+                                    // If we can't show anything useful, try to find\n+                                    // similar impls.\n+\n+                                    self.report_similar_impl_candidates(trait_ref, &mut err);\n+                                }\n+                                err\n                             }\n-                            err\n+                        },\n+                        ty::Predicate::Equate(ref predicate) => {\n+                            let predicate = self.resolve_type_vars_if_possible(predicate);\n+                            let err = self.equality_predicate(span,\n+                                                              &predicate).err().unwrap();\n+                            struct_span_err!(self.tcx.sess, span, E0278,\n+                                \"the requirement `{}` is not satisfied (`{}`)\",\n+                                predicate, err)\n                         }\n-                    },\n-                    ty::Predicate::Equate(ref predicate) => {\n-                        let predicate = self.resolve_type_vars_if_possible(predicate);\n-                        let err = self.equality_predicate(span,\n-                                                          &predicate).err().unwrap();\n-                        struct_span_err!(self.tcx.sess, span, E0278,\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate, err)\n-                    }\n \n-                    ty::Predicate::RegionOutlives(ref predicate) => {\n-                        let predicate = self.resolve_type_vars_if_possible(predicate);\n-                        let err = self.region_outlives_predicate(span,\n-                                                                 &predicate).err().unwrap();\n-                        struct_span_err!(self.tcx.sess, span, E0279,\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate, err)\n-                    }\n+                        ty::Predicate::RegionOutlives(ref predicate) => {\n+                            let predicate = self.resolve_type_vars_if_possible(predicate);\n+                            let err = self.region_outlives_predicate(span,\n+                                                                     &predicate).err().unwrap();\n+                            struct_span_err!(self.tcx.sess, span, E0279,\n+                                \"the requirement `{}` is not satisfied (`{}`)\",\n+                                predicate, err)\n+                        }\n \n-                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n-                        let predicate =\n-                            self.resolve_type_vars_if_possible(&obligation.predicate);\n-                        struct_span_err!(self.tcx.sess, span, E0280,\n-                            \"the requirement `{}` is not satisfied\",\n-                            predicate)\n-                    }\n+                        ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                            let predicate =\n+                                self.resolve_type_vars_if_possible(&obligation.predicate);\n+                            struct_span_err!(self.tcx.sess, span, E0280,\n+                                \"the requirement `{}` is not satisfied\",\n+                                predicate)\n+                        }\n \n-                    ty::Predicate::ObjectSafe(trait_def_id) => {\n-                        let violations = self.tcx.object_safety_violations(trait_def_id);\n-                        let err = self.tcx.report_object_safety_error(span,\n-                                                                      trait_def_id,\n-                                                                      warning_node_id,\n-                                                                      violations);\n-                        if let Some(err) = err {\n-                            err\n-                        } else {\n-                            return;\n+                        ty::Predicate::ObjectSafe(trait_def_id) => {\n+                            let violations = self.tcx.object_safety_violations(trait_def_id);\n+                            let err = self.tcx.report_object_safety_error(span,\n+                                                                          trait_def_id,\n+                                                                          warning_node_id,\n+                                                                          violations);\n+                            if let Some(err) = err {\n+                                err\n+                            } else {\n+                                return;\n+                            }\n                         }\n-                    }\n \n-                    ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                        let found_kind = self.closure_kind(closure_def_id).unwrap();\n-                        let closure_span = self.tcx.map.span_if_local(closure_def_id).unwrap();\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess, closure_span, E0525,\n-                            \"expected a closure that implements the `{}` trait, but this closure \\\n-                             only implements `{}`\",\n-                            kind,\n-                            found_kind);\n-                        err.span_note(\n-                            obligation.cause.span,\n-                            &format!(\"the requirement to implement `{}` derives from here\", kind));\n-                        err.emit();\n-                        return;\n-                    }\n+                        ty::Predicate::ClosureKind(closure_def_id, kind) => {\n+                            let found_kind = self.closure_kind(closure_def_id).unwrap();\n+                            let closure_span = self.tcx.map.span_if_local(closure_def_id).unwrap();\n+                            let mut err = struct_span_err!(\n+                                self.tcx.sess, closure_span, E0525,\n+                                \"expected a closure that implements the `{}` trait, \\\n+                                 but this closure only implements `{}`\",\n+                                kind,\n+                                found_kind);\n+                            err.span_note(\n+                                obligation.cause.span,\n+                                &format!(\"the requirement to implement \\\n+                                          `{}` derives from here\", kind));\n+                            err.emit();\n+                            return;\n+                        }\n \n-                    ty::Predicate::WellFormed(ty) => {\n-                        // WF predicates cannot themselves make\n-                        // errors. They can only block due to\n-                        // ambiguity; otherwise, they always\n-                        // degenerate into other obligations\n-                        // (which may fail).\n-                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n-                    }\n+                        ty::Predicate::WellFormed(ty) => {\n+                            // WF predicates cannot themselves make\n+                            // errors. They can only block due to\n+                            // ambiguity; otherwise, they always\n+                            // degenerate into other obligations\n+                            // (which may fail).\n+                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        }\n \n-                    ty::Predicate::Rfc1592(ref data) => {\n-                        span_bug!(\n-                            obligation.cause.span,\n-                            \"RFC1592 predicate not satisfied for {:?}\",\n-                            data);\n+                        ty::Predicate::Rfc1592(ref data) => {\n+                            span_bug!(\n+                                obligation.cause.span,\n+                                \"RFC1592 predicate not satisfied for {:?}\",\n+                                data);\n+                        }\n                     }\n                 }\n             }\n-        }\n \n-        OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n-            let expected_trait_ref = self.resolve_type_vars_if_possible(&*expected_trait_ref);\n-            let actual_trait_ref = self.resolve_type_vars_if_possible(&*actual_trait_ref);\n-            if actual_trait_ref.self_ty().references_error() {\n-                return;\n-            }\n-            struct_span_err!(self.tcx.sess, span, E0281,\n-                \"type mismatch: the type `{}` implements the trait `{}`, \\\n-                 but the trait `{}` is required ({})\",\n-                expected_trait_ref.self_ty(),\n-                expected_trait_ref,\n-                actual_trait_ref,\n-                e)\n-        }\n+            OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n+                let expected_trait_ref = self.resolve_type_vars_if_possible(&*expected_trait_ref);\n+                let actual_trait_ref = self.resolve_type_vars_if_possible(&*actual_trait_ref);\n+                if actual_trait_ref.self_ty().references_error() {\n+                    return;\n+                }\n+                struct_span_err!(self.tcx.sess, span, E0281,\n+                    \"type mismatch: the type `{}` implements the trait `{}`, \\\n+                     but the trait `{}` is required ({})\",\n+                    expected_trait_ref.self_ty(),\n+                    expected_trait_ref,\n+                    actual_trait_ref,\n+                    e)\n+            }\n \n-        TraitNotObjectSafe(did) => {\n-            let violations = self.tcx.object_safety_violations(did);\n-            let err = self.tcx.report_object_safety_error(span, did,\n-                                                          warning_node_id,\n-                                                          violations);\n-            if let Some(err) = err {\n-                err\n-            } else {\n-                return;\n+            TraitNotObjectSafe(did) => {\n+                let violations = self.tcx.object_safety_violations(did);\n+                let err = self.tcx.report_object_safety_error(span, did,\n+                                                              warning_node_id,\n+                                                              violations);\n+                if let Some(err) = err {\n+                    err\n+                } else {\n+                    return;\n+                }\n             }\n-        }\n-    };\n-    self.note_obligation_cause(&mut err, obligation);\n-    err.emit();\n-}\n+        };\n+        self.note_obligation_cause(&mut err, obligation);\n+        err.emit();\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-pub fn recursive_type_with_infinite_size_error(self,\n-                                               type_def_id: DefId)\n-                                               -> DiagnosticBuilder<'tcx>\n-{\n-    assert!(type_def_id.is_local());\n-    let span = self.map.span_if_local(type_def_id).unwrap();\n-    let mut err = struct_span_err!(self.sess, span, E0072, \"recursive type `{}` has infinite size\",\n-                                   self.item_path_str(type_def_id));\n-    err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n-                       at some point to make `{}` representable\",\n-                      self.item_path_str(type_def_id)));\n-    err\n-}\n-\n-pub fn report_object_safety_error(self,\n-                                  span: Span,\n-                                  trait_def_id: DefId,\n-                                  warning_node_id: Option<ast::NodeId>,\n-                                  violations: Vec<ObjectSafetyViolation>)\n-                                  -> Option<DiagnosticBuilder<'tcx>>\n-{\n-    let mut err = match warning_node_id {\n-        Some(_) => None,\n-        None => {\n-            Some(struct_span_err!(\n-                self.sess, span, E0038,\n-                \"the trait `{}` cannot be made into an object\",\n-                self.item_path_str(trait_def_id)))\n-        }\n-    };\n+    pub fn recursive_type_with_infinite_size_error(self,\n+                                                   type_def_id: DefId)\n+                                                   -> DiagnosticBuilder<'tcx>\n+    {\n+        assert!(type_def_id.is_local());\n+        let span = self.map.span_if_local(type_def_id).unwrap();\n+        let mut err = struct_span_err!(self.sess, span, E0072,\n+                                       \"recursive type `{}` has infinite size\",\n+                                       self.item_path_str(type_def_id));\n+        err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                           at some point to make `{}` representable\",\n+                          self.item_path_str(type_def_id)));\n+        err\n+    }\n \n-    let mut reported_violations = FnvHashSet();\n-    for violation in violations {\n-        if !reported_violations.insert(violation.clone()) {\n-            continue;\n-        }\n-        let buf;\n-        let note = match violation {\n-            ObjectSafetyViolation::SizedSelf => {\n-                \"the trait cannot require that `Self : Sized`\"\n+    pub fn report_object_safety_error(self,\n+                                      span: Span,\n+                                      trait_def_id: DefId,\n+                                      warning_node_id: Option<ast::NodeId>,\n+                                      violations: Vec<ObjectSafetyViolation>)\n+                                      -> Option<DiagnosticBuilder<'tcx>>\n+    {\n+        let mut err = match warning_node_id {\n+            Some(_) => None,\n+            None => {\n+                Some(struct_span_err!(\n+                    self.sess, span, E0038,\n+                    \"the trait `{}` cannot be made into an object\",\n+                    self.item_path_str(trait_def_id)))\n             }\n+        };\n \n-            ObjectSafetyViolation::SupertraitSelf => {\n-                \"the trait cannot use `Self` as a type parameter \\\n-                     in the supertrait listing\"\n+        let mut reported_violations = FnvHashSet();\n+        for violation in violations {\n+            if !reported_violations.insert(violation.clone()) {\n+                continue;\n             }\n+            let buf;\n+            let note = match violation {\n+                ObjectSafetyViolation::SizedSelf => {\n+                    \"the trait cannot require that `Self : Sized`\"\n+                }\n \n-            ObjectSafetyViolation::Method(method,\n-                                          MethodViolationCode::StaticMethod) => {\n-                buf = format!(\"method `{}` has no receiver\",\n-                              method.name);\n-                &buf\n-            }\n+                ObjectSafetyViolation::SupertraitSelf => {\n+                    \"the trait cannot use `Self` as a type parameter \\\n+                         in the supertrait listing\"\n+                }\n \n-            ObjectSafetyViolation::Method(method,\n-                                          MethodViolationCode::ReferencesSelf) => {\n-                buf = format!(\"method `{}` references the `Self` type \\\n-                                   in its arguments or return type\",\n-                              method.name);\n-                &buf\n-            }\n+                ObjectSafetyViolation::Method(method,\n+                                              MethodViolationCode::StaticMethod) => {\n+                    buf = format!(\"method `{}` has no receiver\",\n+                                  method.name);\n+                    &buf\n+                }\n \n-            ObjectSafetyViolation::Method(method,\n-                                          MethodViolationCode::Generic) => {\n-                buf = format!(\"method `{}` has generic type parameters\",\n-                              method.name);\n-                &buf\n+                ObjectSafetyViolation::Method(method,\n+                                              MethodViolationCode::ReferencesSelf) => {\n+                    buf = format!(\"method `{}` references the `Self` type \\\n+                                       in its arguments or return type\",\n+                                  method.name);\n+                    &buf\n+                }\n+\n+                ObjectSafetyViolation::Method(method,\n+                                              MethodViolationCode::Generic) => {\n+                    buf = format!(\"method `{}` has generic type parameters\",\n+                                  method.name);\n+                    &buf\n+                }\n+            };\n+            match (warning_node_id, &mut err) {\n+                (Some(node_id), &mut None) => {\n+                    self.sess.add_lint(\n+                        ::lint::builtin::OBJECT_UNSAFE_FRAGMENT,\n+                        node_id,\n+                        span,\n+                        note.to_string());\n+                }\n+                (None, &mut Some(ref mut err)) => {\n+                    err.note(note);\n+                }\n+                _ => unreachable!()\n             }\n-        };\n-        match (warning_node_id, &mut err) {\n-            (Some(node_id), &mut None) => {\n-                self.sess.add_lint(\n-                    ::lint::builtin::OBJECT_UNSAFE_FRAGMENT,\n-                    node_id,\n-                    span,\n-                    note.to_string());\n-            }\n-            (None, &mut Some(ref mut err)) => {\n-                err.note(note);\n-            }\n-            _ => unreachable!()\n         }\n+        err\n     }\n-    err\n-}\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>) {\n-    // Unable to successfully determine, probably means\n-    // insufficient type information, but could mean\n-    // ambiguous impls. The latter *ought* to be a\n-    // coherence violation, so we don't report it here.\n-\n-    let predicate = self.resolve_type_vars_if_possible(&obligation.predicate);\n-\n-    debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n-           predicate,\n-           obligation);\n-\n-    // Ambiguity errors are often caused as fallout from earlier\n-    // errors. So just ignore them if this infcx is tainted.\n-    if self.is_tainted_by_errors() {\n-        return;\n-    }\n-\n-    match predicate {\n-        ty::Predicate::Trait(ref data) => {\n-            let trait_ref = data.to_poly_trait_ref();\n-            let self_ty = trait_ref.self_ty();\n-            let all_types = &trait_ref.substs().types;\n-            if all_types.references_error() {\n-            } else {\n-                // Typically, this ambiguity should only happen if\n-                // there are unresolved type inference variables\n-                // (otherwise it would suggest a coherence\n-                // failure). But given #21974 that is not necessarily\n-                // the case -- we can have multiple where clauses that\n-                // are only distinguished by a region, which results\n-                // in an ambiguity even when all types are fully\n-                // known, since we don't dispatch based on region\n-                // relationships.\n-\n-                // This is kind of a hack: it frequently happens that some earlier\n-                // error prevents types from being fully inferred, and then we get\n-                // a bunch of uninteresting errors saying something like \"<generic\n-                // #0> doesn't implement Sized\".  It may even be true that we\n-                // could just skip over all checks where the self-ty is an\n-                // inference variable, but I was afraid that there might be an\n-                // inference variable created, registered as an obligation, and\n-                // then never forced by writeback, and hence by skipping here we'd\n-                // be ignoring the fact that we don't KNOW the type works\n-                // out. Though even that would probably be harmless, given that\n-                // we're only talking about builtin traits, which are known to be\n-                // inhabited. But in any case I just threw in this check for\n-                // has_errors() to be sure that compilation isn't happening\n-                // anyway. In that case, why inundate the user.\n-                if !self.tcx.sess.has_errors() {\n-                    if\n-                        self.tcx.lang_items.sized_trait()\n-                        .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n-                    {\n-                        self.need_type_info(obligation.cause.span, self_ty);\n-                    } else {\n-                        let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0283,\n-                                                       \"type annotations required: \\\n-                                                        cannot resolve `{}`\",\n-                                                       predicate);\n-                        self.note_obligation_cause(&mut err, obligation);\n-                        err.emit();\n+    fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>) {\n+        // Unable to successfully determine, probably means\n+        // insufficient type information, but could mean\n+        // ambiguous impls. The latter *ought* to be a\n+        // coherence violation, so we don't report it here.\n+\n+        let predicate = self.resolve_type_vars_if_possible(&obligation.predicate);\n+\n+        debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n+               predicate,\n+               obligation);\n+\n+        // Ambiguity errors are often caused as fallout from earlier\n+        // errors. So just ignore them if this infcx is tainted.\n+        if self.is_tainted_by_errors() {\n+            return;\n+        }\n+\n+        match predicate {\n+            ty::Predicate::Trait(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref();\n+                let self_ty = trait_ref.self_ty();\n+                let all_types = &trait_ref.substs().types;\n+                if all_types.references_error() {\n+                } else {\n+                    // Typically, this ambiguity should only happen if\n+                    // there are unresolved type inference variables\n+                    // (otherwise it would suggest a coherence\n+                    // failure). But given #21974 that is not necessarily\n+                    // the case -- we can have multiple where clauses that\n+                    // are only distinguished by a region, which results\n+                    // in an ambiguity even when all types are fully\n+                    // known, since we don't dispatch based on region\n+                    // relationships.\n+\n+                    // This is kind of a hack: it frequently happens that some earlier\n+                    // error prevents types from being fully inferred, and then we get\n+                    // a bunch of uninteresting errors saying something like \"<generic\n+                    // #0> doesn't implement Sized\".  It may even be true that we\n+                    // could just skip over all checks where the self-ty is an\n+                    // inference variable, but I was afraid that there might be an\n+                    // inference variable created, registered as an obligation, and\n+                    // then never forced by writeback, and hence by skipping here we'd\n+                    // be ignoring the fact that we don't KNOW the type works\n+                    // out. Though even that would probably be harmless, given that\n+                    // we're only talking about builtin traits, which are known to be\n+                    // inhabited. But in any case I just threw in this check for\n+                    // has_errors() to be sure that compilation isn't happening\n+                    // anyway. In that case, why inundate the user.\n+                    if !self.tcx.sess.has_errors() {\n+                        if\n+                            self.tcx.lang_items.sized_trait()\n+                            .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n+                        {\n+                            self.need_type_info(obligation.cause.span, self_ty);\n+                        } else {\n+                            let mut err = struct_span_err!(self.tcx.sess,\n+                                                           obligation.cause.span, E0283,\n+                                                           \"type annotations required: \\\n+                                                            cannot resolve `{}`\",\n+                                                           predicate);\n+                            self.note_obligation_cause(&mut err, obligation);\n+                            err.emit();\n+                        }\n                     }\n                 }\n             }\n-        }\n \n-        ty::Predicate::WellFormed(ty) => {\n-            // Same hacky approach as above to avoid deluging user\n-            // with error messages.\n-            if !ty.references_error() && !self.tcx.sess.has_errors() {\n-                self.need_type_info(obligation.cause.span, ty);\n+            ty::Predicate::WellFormed(ty) => {\n+                // Same hacky approach as above to avoid deluging user\n+                // with error messages.\n+                if !ty.references_error() && !self.tcx.sess.has_errors() {\n+                    self.need_type_info(obligation.cause.span, ty);\n+                }\n             }\n-        }\n \n-        _ => {\n-            if !self.tcx.sess.has_errors() {\n-                let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0284,\n-                                               \"type annotations required: cannot resolve `{}`\",\n-                                               predicate);\n-                self.note_obligation_cause(&mut err, obligation);\n-                err.emit();\n+            _ => {\n+                if !self.tcx.sess.has_errors() {\n+                    let mut err = struct_span_err!(self.tcx.sess,\n+                                                   obligation.cause.span, E0284,\n+                                                   \"type annotations required: \\\n+                                                    cannot resolve `{}`\",\n+                                                   predicate);\n+                    self.note_obligation_cause(&mut err, obligation);\n+                    err.emit();\n+                }\n             }\n         }\n     }\n-}\n \n-/// Returns whether the trait predicate may apply for *some* assignment\n-/// to the type parameters.\n-fn predicate_can_apply(&self, pred: ty::PolyTraitRef<'tcx>) -> bool {\n-    struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-        var_map: FnvHashMap<Ty<'tcx>, Ty<'tcx>>\n-    }\n+    /// Returns whether the trait predicate may apply for *some* assignment\n+    /// to the type parameters.\n+    fn predicate_can_apply(&self, pred: ty::PolyTraitRef<'tcx>) -> bool {\n+        struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+            infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+            var_map: FnvHashMap<Ty<'tcx>, Ty<'tcx>>\n+        }\n \n-    impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ParamToVarFolder<'a, 'gcx, 'tcx> {\n-        fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.infcx.tcx }\n+        impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ParamToVarFolder<'a, 'gcx, 'tcx> {\n+            fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.infcx.tcx }\n \n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            if let ty::TyParam(..) = ty.sty {\n-                let infcx = self.infcx;\n-                self.var_map.entry(ty).or_insert_with(|| infcx.next_ty_var())\n-            } else {\n-                ty.super_fold_with(self)\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+                if let ty::TyParam(..) = ty.sty {\n+                    let infcx = self.infcx;\n+                    self.var_map.entry(ty).or_insert_with(|| infcx.next_ty_var())\n+                } else {\n+                    ty.super_fold_with(self)\n+                }\n             }\n         }\n-    }\n \n-    self.probe(|_| {\n-        let mut selcx = SelectionContext::new(self);\n+        self.probe(|_| {\n+            let mut selcx = SelectionContext::new(self);\n \n-        let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n-            infcx: self,\n-            var_map: FnvHashMap()\n-        });\n+            let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n+                infcx: self,\n+                var_map: FnvHashMap()\n+            });\n \n-        let cleaned_pred = super::project::normalize(\n-            &mut selcx,\n-            ObligationCause::dummy(),\n-            &cleaned_pred\n-        ).value;\n+            let cleaned_pred = super::project::normalize(\n+                &mut selcx,\n+                ObligationCause::dummy(),\n+                &cleaned_pred\n+            ).value;\n \n-        let obligation = Obligation::new(\n-            ObligationCause::dummy(),\n-            cleaned_pred.to_predicate()\n-        );\n+            let obligation = Obligation::new(\n+                ObligationCause::dummy(),\n+                cleaned_pred.to_predicate()\n+            );\n \n-        selcx.evaluate_obligation(&obligation)\n-    })\n-}\n+            selcx.evaluate_obligation(&obligation)\n+        })\n+    }\n \n \n-fn need_type_info(&self, span: Span, ty: Ty<'tcx>) {\n-    span_err!(self.tcx.sess, span, E0282,\n-              \"unable to infer enough type information about `{}`; \\\n-               type annotations or generic parameter binding required\",\n-              ty);\n-}\n+    fn need_type_info(&self, span: Span, ty: Ty<'tcx>) {\n+        span_err!(self.tcx.sess, span, E0282,\n+                  \"unable to infer enough type information about `{}`; \\\n+                   type annotations or generic parameter binding required\",\n+                  ty);\n+    }\n \n-fn note_obligation_cause<T>(&self,\n-                            err: &mut DiagnosticBuilder,\n-                            obligation: &Obligation<'tcx, T>)\n-    where T: fmt::Display\n-{\n-    self.note_obligation_cause_code(err,\n-                                    &obligation.predicate,\n-                                    &obligation.cause.code);\n-}\n+    fn note_obligation_cause<T>(&self,\n+                                err: &mut DiagnosticBuilder,\n+                                obligation: &Obligation<'tcx, T>)\n+        where T: fmt::Display\n+    {\n+        self.note_obligation_cause_code(err,\n+                                        &obligation.predicate,\n+                                        &obligation.cause.code);\n+    }\n \n-fn note_obligation_cause_code<T>(&self,\n-                                 err: &mut DiagnosticBuilder,\n-                                 predicate: &T,\n-                                 cause_code: &ObligationCauseCode<'tcx>)\n-    where T: fmt::Display\n-{\n-    let tcx = self.tcx;\n-    match *cause_code {\n-        ObligationCauseCode::MiscObligation => { }\n-        ObligationCauseCode::SliceOrArrayElem => {\n-            err.note(\"slice and array elements must have `Sized` type\");\n-        }\n-        ObligationCauseCode::TupleElem => {\n-            err.note(\"tuple elements must have `Sized` type\");\n-        }\n-        ObligationCauseCode::ProjectionWf(data) => {\n-            err.note(&format!(\"required so that the projection `{}` is well-formed\",\n-                              data));\n-        }\n-        ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n-            err.note(&format!(\"required so that reference `{}` does not outlive its referent\",\n-                              ref_ty));\n-        }\n-        ObligationCauseCode::ItemObligation(item_def_id) => {\n-            let item_name = tcx.item_path_str(item_def_id);\n-            err.note(&format!(\"required by `{}`\", item_name));\n-        }\n-        ObligationCauseCode::ObjectCastObligation(object_ty) => {\n-            err.note(&format!(\"required for the cast to the object type `{}`\",\n-                              self.ty_to_string(object_ty)));\n-        }\n-        ObligationCauseCode::RepeatVec => {\n-            err.note(\"the `Copy` trait is required because the \\\n-                      repeated element will be copied\");\n-        }\n-        ObligationCauseCode::VariableType(_) => {\n-            err.note(\"all local variables must have a statically known size\");\n-        }\n-        ObligationCauseCode::ReturnType => {\n-            err.note(\"the return type of a function must have a \\\n-                      statically known size\");\n-        }\n-        ObligationCauseCode::AssignmentLhsSized => {\n-            err.note(\"the left-hand-side of an assignment must have a statically known size\");\n-        }\n-        ObligationCauseCode::StructInitializerSized => {\n-            err.note(\"structs must have a statically known size to be initialized\");\n-        }\n-        ObligationCauseCode::ClosureCapture(var_id, _, builtin_bound) => {\n-            let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n-            let trait_name = tcx.item_path_str(def_id);\n-            let name = tcx.local_var_name_str(var_id);\n-            err.note(\n-                &format!(\"the closure that captures `{}` requires that all captured variables \\\n-                          implement the trait `{}`\",\n-                         name,\n-                         trait_name));\n-        }\n-        ObligationCauseCode::FieldSized => {\n-            err.note(\"only the last field of a struct or enum variant \\\n-                      may have a dynamically sized type\");\n-        }\n-        ObligationCauseCode::SharedStatic => {\n-            err.note(\"shared static variables must have a type that implements `Sync`\");\n-        }\n-        ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-            let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            err.note(&format!(\"required because it appears within the type `{}`\",\n-                              parent_trait_ref.0.self_ty()));\n-            let parent_predicate = parent_trait_ref.to_predicate();\n-            self.note_obligation_cause_code(err,\n-                                            &parent_predicate,\n-                                            &data.parent_code);\n-        }\n-        ObligationCauseCode::ImplDerivedObligation(ref data) => {\n-            let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            err.note(\n-                &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n-                         parent_trait_ref,\n-                         parent_trait_ref.0.self_ty()));\n-            let parent_predicate = parent_trait_ref.to_predicate();\n-            self.note_obligation_cause_code(err,\n-                                            &parent_predicate,\n-                                            &data.parent_code);\n-        }\n-        ObligationCauseCode::CompareImplMethodObligation => {\n-            err.note(\n-                &format!(\"the requirement `{}` appears on the impl method \\\n-                          but not on the corresponding trait method\",\n-                         predicate));\n+    fn note_obligation_cause_code<T>(&self,\n+                                     err: &mut DiagnosticBuilder,\n+                                     predicate: &T,\n+                                     cause_code: &ObligationCauseCode<'tcx>)\n+        where T: fmt::Display\n+    {\n+        let tcx = self.tcx;\n+        match *cause_code {\n+            ObligationCauseCode::MiscObligation => { }\n+            ObligationCauseCode::SliceOrArrayElem => {\n+                err.note(\"slice and array elements must have `Sized` type\");\n+            }\n+            ObligationCauseCode::TupleElem => {\n+                err.note(\"tuple elements must have `Sized` type\");\n+            }\n+            ObligationCauseCode::ProjectionWf(data) => {\n+                err.note(&format!(\"required so that the projection `{}` is well-formed\",\n+                                  data));\n+            }\n+            ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n+                err.note(&format!(\"required so that reference `{}` does not outlive its referent\",\n+                                  ref_ty));\n+            }\n+            ObligationCauseCode::ItemObligation(item_def_id) => {\n+                let item_name = tcx.item_path_str(item_def_id);\n+                err.note(&format!(\"required by `{}`\", item_name));\n+            }\n+            ObligationCauseCode::ObjectCastObligation(object_ty) => {\n+                err.note(&format!(\"required for the cast to the object type `{}`\",\n+                                  self.ty_to_string(object_ty)));\n+            }\n+            ObligationCauseCode::RepeatVec => {\n+                err.note(\"the `Copy` trait is required because the \\\n+                          repeated element will be copied\");\n+            }\n+            ObligationCauseCode::VariableType(_) => {\n+                err.note(\"all local variables must have a statically known size\");\n+            }\n+            ObligationCauseCode::ReturnType => {\n+                err.note(\"the return type of a function must have a \\\n+                          statically known size\");\n+            }\n+            ObligationCauseCode::AssignmentLhsSized => {\n+                err.note(\"the left-hand-side of an assignment must have a statically known size\");\n+            }\n+            ObligationCauseCode::StructInitializerSized => {\n+                err.note(\"structs must have a statically known size to be initialized\");\n+            }\n+            ObligationCauseCode::ClosureCapture(var_id, _, builtin_bound) => {\n+                let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n+                let trait_name = tcx.item_path_str(def_id);\n+                let name = tcx.local_var_name_str(var_id);\n+                err.note(\n+                    &format!(\"the closure that captures `{}` requires that all captured variables \\\n+                              implement the trait `{}`\",\n+                             name,\n+                             trait_name));\n+            }\n+            ObligationCauseCode::FieldSized => {\n+                err.note(\"only the last field of a struct or enum variant \\\n+                          may have a dynamically sized type\");\n+            }\n+            ObligationCauseCode::SharedStatic => {\n+                err.note(\"shared static variables must have a type that implements `Sync`\");\n+            }\n+            ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+                err.note(&format!(\"required because it appears within the type `{}`\",\n+                                  parent_trait_ref.0.self_ty()));\n+                let parent_predicate = parent_trait_ref.to_predicate();\n+                self.note_obligation_cause_code(err,\n+                                                &parent_predicate,\n+                                                &data.parent_code);\n+            }\n+            ObligationCauseCode::ImplDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+                err.note(\n+                    &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n+                             parent_trait_ref,\n+                             parent_trait_ref.0.self_ty()));\n+                let parent_predicate = parent_trait_ref.to_predicate();\n+                self.note_obligation_cause_code(err,\n+                                                &parent_predicate,\n+                                                &data.parent_code);\n+            }\n+            ObligationCauseCode::CompareImplMethodObligation => {\n+                err.note(\n+                    &format!(\"the requirement `{}` appears on the impl method \\\n+                              but not on the corresponding trait method\",\n+                             predicate));\n+            }\n         }\n     }\n-}\n \n-fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder) {\n-    let current_limit = self.tcx.sess.recursion_limit.get();\n-    let suggested_limit = current_limit * 2;\n-    err.note(&format!(\n-                      \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-                      suggested_limit));\n-}\n+    fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder) {\n+        let current_limit = self.tcx.sess.recursion_limit.get();\n+        let suggested_limit = current_limit * 2;\n+        err.note(&format!(\n+                          \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+                          suggested_limit));\n+    }\n }"}, {"sha": "8cafa779739090236b47f55c97eae1aefb6af89e", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 278, "deletions": 278, "changes": 556, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -54,320 +54,320 @@ pub enum MethodViolationCode {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-pub fn is_object_safe(self, trait_def_id: DefId) -> bool {\n-    // Because we query yes/no results frequently, we keep a cache:\n-    let def = self.lookup_trait_def(trait_def_id);\n+    pub fn is_object_safe(self, trait_def_id: DefId) -> bool {\n+        // Because we query yes/no results frequently, we keep a cache:\n+        let def = self.lookup_trait_def(trait_def_id);\n \n-    let result = def.object_safety().unwrap_or_else(|| {\n-        let result = self.object_safety_violations(trait_def_id).is_empty();\n+        let result = def.object_safety().unwrap_or_else(|| {\n+            let result = self.object_safety_violations(trait_def_id).is_empty();\n \n-        // Record just a yes/no result in the cache; this is what is\n-        // queried most frequently. Note that this may overwrite a\n-        // previous result, but always with the same thing.\n-        def.set_object_safety(result);\n+            // Record just a yes/no result in the cache; this is what is\n+            // queried most frequently. Note that this may overwrite a\n+            // previous result, but always with the same thing.\n+            def.set_object_safety(result);\n \n-        result\n-    });\n-\n-    debug!(\"is_object_safe({:?}) = {}\", trait_def_id, result);\n+            result\n+        });\n \n-    result\n-}\n+        debug!(\"is_object_safe({:?}) = {}\", trait_def_id, result);\n \n-/// Returns the object safety violations that affect\n-/// astconv - currently, Self in supertraits. This is needed\n-/// because `object_safety_violations` can't be used during\n-/// type collection.\n-pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n-                                        -> Vec<ObjectSafetyViolation<'tcx>>\n-{\n-    let mut violations = vec![];\n-\n-    if self.supertraits_reference_self(trait_def_id) {\n-        violations.push(ObjectSafetyViolation::SupertraitSelf);\n+        result\n     }\n \n-    debug!(\"astconv_object_safety_violations(trait_def_id={:?}) = {:?}\",\n-           trait_def_id,\n-           violations);\n+    /// Returns the object safety violations that affect\n+    /// astconv - currently, Self in supertraits. This is needed\n+    /// because `object_safety_violations` can't be used during\n+    /// type collection.\n+    pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n+                                            -> Vec<ObjectSafetyViolation<'tcx>>\n+    {\n+        let mut violations = vec![];\n+\n+        if self.supertraits_reference_self(trait_def_id) {\n+            violations.push(ObjectSafetyViolation::SupertraitSelf);\n+        }\n \n-    violations\n-}\n+        debug!(\"astconv_object_safety_violations(trait_def_id={:?}) = {:?}\",\n+               trait_def_id,\n+               violations);\n \n-pub fn object_safety_violations(self, trait_def_id: DefId)\n-                                -> Vec<ObjectSafetyViolation<'tcx>>\n-{\n-    traits::supertrait_def_ids(self, trait_def_id)\n-        .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n-        .collect()\n-}\n+        violations\n+    }\n+\n+    pub fn object_safety_violations(self, trait_def_id: DefId)\n+                                    -> Vec<ObjectSafetyViolation<'tcx>>\n+    {\n+        traits::supertrait_def_ids(self, trait_def_id)\n+            .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n+            .collect()\n+    }\n \n-fn object_safety_violations_for_trait(self, trait_def_id: DefId)\n-                                      -> Vec<ObjectSafetyViolation<'tcx>>\n-{\n-    // Check methods for violations.\n-    let mut violations: Vec<_> =\n-        self.trait_items(trait_def_id).iter()\n-        .filter_map(|item| {\n-            match *item {\n-                ty::MethodTraitItem(ref m) => {\n-                    self.object_safety_violation_for_method(trait_def_id, &m)\n-                        .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n+    fn object_safety_violations_for_trait(self, trait_def_id: DefId)\n+                                          -> Vec<ObjectSafetyViolation<'tcx>>\n+    {\n+        // Check methods for violations.\n+        let mut violations: Vec<_> =\n+            self.trait_items(trait_def_id).iter()\n+            .filter_map(|item| {\n+                match *item {\n+                    ty::MethodTraitItem(ref m) => {\n+                        self.object_safety_violation_for_method(trait_def_id, &m)\n+                            .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n+                    }\n+                    _ => None,\n                 }\n-                _ => None,\n-            }\n-        })\n-        .collect();\n+            })\n+            .collect();\n \n-    // Check the trait itself.\n-    if self.trait_has_sized_self(trait_def_id) {\n-        violations.push(ObjectSafetyViolation::SizedSelf);\n-    }\n-    if self.supertraits_reference_self(trait_def_id) {\n-        violations.push(ObjectSafetyViolation::SupertraitSelf);\n-    }\n+        // Check the trait itself.\n+        if self.trait_has_sized_self(trait_def_id) {\n+            violations.push(ObjectSafetyViolation::SizedSelf);\n+        }\n+        if self.supertraits_reference_self(trait_def_id) {\n+            violations.push(ObjectSafetyViolation::SupertraitSelf);\n+        }\n \n-    debug!(\"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n-           trait_def_id,\n-           violations);\n+        debug!(\"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n+               trait_def_id,\n+               violations);\n \n-    violations\n-}\n+        violations\n+    }\n \n-fn supertraits_reference_self(self, trait_def_id: DefId) -> bool {\n-    let trait_def = self.lookup_trait_def(trait_def_id);\n-    let trait_ref = trait_def.trait_ref.clone();\n-    let trait_ref = trait_ref.to_poly_trait_ref();\n-    let predicates = self.lookup_super_predicates(trait_def_id);\n-    predicates\n-        .predicates\n-        .into_iter()\n-        .map(|predicate| predicate.subst_supertrait(self, &trait_ref))\n-        .any(|predicate| {\n-            match predicate {\n-                ty::Predicate::Trait(ref data) => {\n-                    // In the case of a trait predicate, we can skip the \"self\" type.\n-                    data.0.trait_ref.substs.types.get_slice(TypeSpace)\n-                                                 .iter()\n-                                                 .cloned()\n-                                                 .any(|t| t.has_self_ty())\n+    fn supertraits_reference_self(self, trait_def_id: DefId) -> bool {\n+        let trait_def = self.lookup_trait_def(trait_def_id);\n+        let trait_ref = trait_def.trait_ref.clone();\n+        let trait_ref = trait_ref.to_poly_trait_ref();\n+        let predicates = self.lookup_super_predicates(trait_def_id);\n+        predicates\n+            .predicates\n+            .into_iter()\n+            .map(|predicate| predicate.subst_supertrait(self, &trait_ref))\n+            .any(|predicate| {\n+                match predicate {\n+                    ty::Predicate::Trait(ref data) => {\n+                        // In the case of a trait predicate, we can skip the \"self\" type.\n+                        data.0.trait_ref.substs.types.get_slice(TypeSpace)\n+                                                     .iter()\n+                                                     .cloned()\n+                                                     .any(|t| t.has_self_ty())\n+                    }\n+                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::ClosureKind(..) |\n+                    ty::Predicate::Rfc1592(..) |\n+                    ty::Predicate::Equate(..) => {\n+                        false\n+                    }\n                 }\n-                ty::Predicate::Projection(..) |\n-                ty::Predicate::WellFormed(..) |\n-                ty::Predicate::ObjectSafe(..) |\n-                ty::Predicate::TypeOutlives(..) |\n-                ty::Predicate::RegionOutlives(..) |\n-                ty::Predicate::ClosureKind(..) |\n-                ty::Predicate::Rfc1592(..) |\n-                ty::Predicate::Equate(..) => {\n-                    false\n-                }\n-            }\n-        })\n-}\n+            })\n+    }\n \n-fn trait_has_sized_self(self, trait_def_id: DefId) -> bool {\n-    let trait_def = self.lookup_trait_def(trait_def_id);\n-    let trait_predicates = self.lookup_predicates(trait_def_id);\n-    self.generics_require_sized_self(&trait_def.generics, &trait_predicates)\n-}\n+    fn trait_has_sized_self(self, trait_def_id: DefId) -> bool {\n+        let trait_def = self.lookup_trait_def(trait_def_id);\n+        let trait_predicates = self.lookup_predicates(trait_def_id);\n+        self.generics_require_sized_self(&trait_def.generics, &trait_predicates)\n+    }\n \n-fn generics_require_sized_self(self,\n-                               generics: &ty::Generics<'gcx>,\n-                               predicates: &ty::GenericPredicates<'gcx>)\n-                               -> bool\n-{\n-    let sized_def_id = match self.lang_items.sized_trait() {\n-        Some(def_id) => def_id,\n-        None => { return false; /* No Sized trait, can't require it! */ }\n-    };\n-\n-    // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-    let free_substs = self.construct_free_substs(generics,\n-        self.region_maps.node_extent(ast::DUMMY_NODE_ID));\n-    let predicates = predicates.instantiate(self, &free_substs).predicates.into_vec();\n-    elaborate_predicates(self, predicates)\n-        .any(|predicate| {\n-            match predicate {\n-                ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n-                    trait_pred.0.self_ty().is_self()\n+    fn generics_require_sized_self(self,\n+                                   generics: &ty::Generics<'gcx>,\n+                                   predicates: &ty::GenericPredicates<'gcx>)\n+                                   -> bool\n+    {\n+        let sized_def_id = match self.lang_items.sized_trait() {\n+            Some(def_id) => def_id,\n+            None => { return false; /* No Sized trait, can't require it! */ }\n+        };\n+\n+        // Search for a predicate like `Self : Sized` amongst the trait bounds.\n+        let free_substs = self.construct_free_substs(generics,\n+            self.region_maps.node_extent(ast::DUMMY_NODE_ID));\n+        let predicates = predicates.instantiate(self, &free_substs).predicates.into_vec();\n+        elaborate_predicates(self, predicates)\n+            .any(|predicate| {\n+                match predicate {\n+                    ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n+                        trait_pred.0.self_ty().is_self()\n+                    }\n+                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::Trait(..) |\n+                    ty::Predicate::Rfc1592(..) |\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n+                    ty::Predicate::ClosureKind(..) |\n+                    ty::Predicate::TypeOutlives(..) => {\n+                        false\n+                    }\n                 }\n-                ty::Predicate::Projection(..) |\n-                ty::Predicate::Trait(..) |\n-                ty::Predicate::Rfc1592(..) |\n-                ty::Predicate::Equate(..) |\n-                ty::Predicate::RegionOutlives(..) |\n-                ty::Predicate::WellFormed(..) |\n-                ty::Predicate::ObjectSafe(..) |\n-                ty::Predicate::ClosureKind(..) |\n-                ty::Predicate::TypeOutlives(..) => {\n-                    false\n-                }\n-            }\n-        })\n-}\n+            })\n+    }\n+\n+    /// Returns `Some(_)` if this method makes the containing trait not object safe.\n+    fn object_safety_violation_for_method(self,\n+                                          trait_def_id: DefId,\n+                                          method: &ty::Method<'gcx>)\n+                                          -> Option<MethodViolationCode>\n+    {\n+        // Any method that has a `Self : Sized` requisite is otherwise\n+        // exempt from the regulations.\n+        if self.generics_require_sized_self(&method.generics, &method.predicates) {\n+            return None;\n+        }\n \n-/// Returns `Some(_)` if this method makes the containing trait not object safe.\n-fn object_safety_violation_for_method(self,\n-                                      trait_def_id: DefId,\n-                                      method: &ty::Method<'gcx>)\n-                                      -> Option<MethodViolationCode>\n-{\n-    // Any method that has a `Self : Sized` requisite is otherwise\n-    // exempt from the regulations.\n-    if self.generics_require_sized_self(&method.generics, &method.predicates) {\n-        return None;\n+        self.virtual_call_violation_for_method(trait_def_id, method)\n     }\n \n-    self.virtual_call_violation_for_method(trait_def_id, method)\n-}\n+    /// We say a method is *vtable safe* if it can be invoked on a trait\n+    /// object.  Note that object-safe traits can have some\n+    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n+    /// otherwise ensure that they cannot be used when `Self=Trait`.\n+    pub fn is_vtable_safe_method(self,\n+                                 trait_def_id: DefId,\n+                                 method: &ty::Method<'tcx>)\n+                                 -> bool\n+    {\n+        self.virtual_call_violation_for_method(trait_def_id, method).is_none()\n+    }\n \n-/// We say a method is *vtable safe* if it can be invoked on a trait\n-/// object.  Note that object-safe traits can have some\n-/// non-vtable-safe methods, so long as they require `Self:Sized` or\n-/// otherwise ensure that they cannot be used when `Self=Trait`.\n-pub fn is_vtable_safe_method(self,\n-                             trait_def_id: DefId,\n-                             method: &ty::Method<'tcx>)\n-                             -> bool\n-{\n-    self.virtual_call_violation_for_method(trait_def_id, method).is_none()\n-}\n+    /// Returns `Some(_)` if this method cannot be called on a trait\n+    /// object; this does not necessarily imply that the enclosing trait\n+    /// is not object safe, because the method might have a where clause\n+    /// `Self:Sized`.\n+    fn virtual_call_violation_for_method(self,\n+                                         trait_def_id: DefId,\n+                                         method: &ty::Method<'tcx>)\n+                                         -> Option<MethodViolationCode>\n+    {\n+        // The method's first parameter must be something that derefs (or\n+        // autorefs) to `&self`. For now, we only accept `self`, `&self`\n+        // and `Box<Self>`.\n+        match method.explicit_self {\n+            ty::ExplicitSelfCategory::Static => {\n+                return Some(MethodViolationCode::StaticMethod);\n+            }\n \n-/// Returns `Some(_)` if this method cannot be called on a trait\n-/// object; this does not necessarily imply that the enclosing trait\n-/// is not object safe, because the method might have a where clause\n-/// `Self:Sized`.\n-fn virtual_call_violation_for_method(self,\n-                                     trait_def_id: DefId,\n-                                     method: &ty::Method<'tcx>)\n-                                     -> Option<MethodViolationCode>\n-{\n-    // The method's first parameter must be something that derefs (or\n-    // autorefs) to `&self`. For now, we only accept `self`, `&self`\n-    // and `Box<Self>`.\n-    match method.explicit_self {\n-        ty::ExplicitSelfCategory::Static => {\n-            return Some(MethodViolationCode::StaticMethod);\n+            ty::ExplicitSelfCategory::ByValue |\n+            ty::ExplicitSelfCategory::ByReference(..) |\n+            ty::ExplicitSelfCategory::ByBox => {\n+            }\n         }\n \n-        ty::ExplicitSelfCategory::ByValue |\n-        ty::ExplicitSelfCategory::ByReference(..) |\n-        ty::ExplicitSelfCategory::ByBox => {\n+        // The `Self` type is erased, so it should not appear in list of\n+        // arguments or return type apart from the receiver.\n+        let ref sig = method.fty.sig;\n+        for &input_ty in &sig.0.inputs[1..] {\n+            if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n+                return Some(MethodViolationCode::ReferencesSelf);\n+            }\n         }\n-    }\n-\n-    // The `Self` type is erased, so it should not appear in list of\n-    // arguments or return type apart from the receiver.\n-    let ref sig = method.fty.sig;\n-    for &input_ty in &sig.0.inputs[1..] {\n-        if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n-            return Some(MethodViolationCode::ReferencesSelf);\n+        if let ty::FnConverging(result_type) = sig.0.output {\n+            if self.contains_illegal_self_type_reference(trait_def_id, result_type) {\n+                return Some(MethodViolationCode::ReferencesSelf);\n+            }\n         }\n-    }\n-    if let ty::FnConverging(result_type) = sig.0.output {\n-        if self.contains_illegal_self_type_reference(trait_def_id, result_type) {\n-            return Some(MethodViolationCode::ReferencesSelf);\n+\n+        // We can't monomorphize things like `fn foo<A>(...)`.\n+        if !method.generics.types.is_empty_in(subst::FnSpace) {\n+            return Some(MethodViolationCode::Generic);\n         }\n-    }\n \n-    // We can't monomorphize things like `fn foo<A>(...)`.\n-    if !method.generics.types.is_empty_in(subst::FnSpace) {\n-        return Some(MethodViolationCode::Generic);\n+        None\n     }\n \n-    None\n-}\n-\n-fn contains_illegal_self_type_reference(self,\n-                                        trait_def_id: DefId,\n-                                        ty: Ty<'tcx>)\n-                                        -> bool\n-{\n-    // This is somewhat subtle. In general, we want to forbid\n-    // references to `Self` in the argument and return types,\n-    // since the value of `Self` is erased. However, there is one\n-    // exception: it is ok to reference `Self` in order to access\n-    // an associated type of the current trait, since we retain\n-    // the value of those associated types in the object type\n-    // itself.\n-    //\n-    // ```rust\n-    // trait SuperTrait {\n-    //     type X;\n-    // }\n-    //\n-    // trait Trait : SuperTrait {\n-    //     type Y;\n-    //     fn foo(&self, x: Self) // bad\n-    //     fn foo(&self) -> Self // bad\n-    //     fn foo(&self) -> Option<Self> // bad\n-    //     fn foo(&self) -> Self::Y // OK, desugars to next example\n-    //     fn foo(&self) -> <Self as Trait>::Y // OK\n-    //     fn foo(&self) -> Self::X // OK, desugars to next example\n-    //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n-    // }\n-    // ```\n-    //\n-    // However, it is not as simple as allowing `Self` in a projected\n-    // type, because there are illegal ways to use `Self` as well:\n-    //\n-    // ```rust\n-    // trait Trait : SuperTrait {\n-    //     ...\n-    //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n-    // }\n-    // ```\n-    //\n-    // Here we will not have the type of `X` recorded in the\n-    // object type, and we cannot resolve `Self as SomeOtherTrait`\n-    // without knowing what `Self` is.\n-\n-    let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n-    let mut error = false;\n-    ty.maybe_walk(|ty| {\n-        match ty.sty {\n-            ty::TyParam(ref param_ty) => {\n-                if param_ty.space == SelfSpace {\n-                    error = true;\n+    fn contains_illegal_self_type_reference(self,\n+                                            trait_def_id: DefId,\n+                                            ty: Ty<'tcx>)\n+                                            -> bool\n+    {\n+        // This is somewhat subtle. In general, we want to forbid\n+        // references to `Self` in the argument and return types,\n+        // since the value of `Self` is erased. However, there is one\n+        // exception: it is ok to reference `Self` in order to access\n+        // an associated type of the current trait, since we retain\n+        // the value of those associated types in the object type\n+        // itself.\n+        //\n+        // ```rust\n+        // trait SuperTrait {\n+        //     type X;\n+        // }\n+        //\n+        // trait Trait : SuperTrait {\n+        //     type Y;\n+        //     fn foo(&self, x: Self) // bad\n+        //     fn foo(&self) -> Self // bad\n+        //     fn foo(&self) -> Option<Self> // bad\n+        //     fn foo(&self) -> Self::Y // OK, desugars to next example\n+        //     fn foo(&self) -> <Self as Trait>::Y // OK\n+        //     fn foo(&self) -> Self::X // OK, desugars to next example\n+        //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n+        // }\n+        // ```\n+        //\n+        // However, it is not as simple as allowing `Self` in a projected\n+        // type, because there are illegal ways to use `Self` as well:\n+        //\n+        // ```rust\n+        // trait Trait : SuperTrait {\n+        //     ...\n+        //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n+        // }\n+        // ```\n+        //\n+        // Here we will not have the type of `X` recorded in the\n+        // object type, and we cannot resolve `Self as SomeOtherTrait`\n+        // without knowing what `Self` is.\n+\n+        let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n+        let mut error = false;\n+        ty.maybe_walk(|ty| {\n+            match ty.sty {\n+                ty::TyParam(ref param_ty) => {\n+                    if param_ty.space == SelfSpace {\n+                        error = true;\n+                    }\n+\n+                    false // no contained types to walk\n                 }\n \n-                false // no contained types to walk\n-            }\n-\n-            ty::TyProjection(ref data) => {\n-                // This is a projected type `<Foo as SomeTrait>::X`.\n-\n-                // Compute supertraits of current trait lazily.\n-                if supertraits.is_none() {\n-                    let trait_def = self.lookup_trait_def(trait_def_id);\n-                    let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n-                    supertraits = Some(traits::supertraits(self, trait_ref).collect());\n+                ty::TyProjection(ref data) => {\n+                    // This is a projected type `<Foo as SomeTrait>::X`.\n+\n+                    // Compute supertraits of current trait lazily.\n+                    if supertraits.is_none() {\n+                        let trait_def = self.lookup_trait_def(trait_def_id);\n+                        let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n+                        supertraits = Some(traits::supertraits(self, trait_ref).collect());\n+                    }\n+\n+                    // Determine whether the trait reference `Foo as\n+                    // SomeTrait` is in fact a supertrait of the\n+                    // current trait. In that case, this type is\n+                    // legal, because the type `X` will be specified\n+                    // in the object type.  Note that we can just use\n+                    // direct equality here because all of these types\n+                    // are part of the formal parameter listing, and\n+                    // hence there should be no inference variables.\n+                    let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n+                    let is_supertrait_of_current_trait =\n+                        supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n+\n+                    if is_supertrait_of_current_trait {\n+                        false // do not walk contained types, do not report error, do collect $200\n+                    } else {\n+                        true // DO walk contained types, POSSIBLY reporting an error\n+                    }\n                 }\n \n-                // Determine whether the trait reference `Foo as\n-                // SomeTrait` is in fact a supertrait of the\n-                // current trait. In that case, this type is\n-                // legal, because the type `X` will be specified\n-                // in the object type.  Note that we can just use\n-                // direct equality here because all of these types\n-                // are part of the formal parameter listing, and\n-                // hence there should be no inference variables.\n-                let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n-                let is_supertrait_of_current_trait =\n-                    supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n-\n-                if is_supertrait_of_current_trait {\n-                    false // do not walk contained types, do not report error, do collect $200\n-                } else {\n-                    true // DO walk contained types, POSSIBLY reporting an error\n-                }\n+                _ => true, // walk contained types, if any\n             }\n+        });\n \n-            _ => true, // walk contained types, if any\n-        }\n-    });\n-\n-    error\n-}\n+        error\n+    }\n }"}, {"sha": "010add012379d8de17e009472549e6ed62b6aab2", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 111, "deletions": 111, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -393,130 +393,130 @@ pub fn predicate_for_trait_ref<'tcx>(\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-pub fn trait_ref_for_builtin_bound(self,\n-    builtin_bound: ty::BuiltinBound,\n-    param_ty: Ty<'tcx>)\n-    -> Result<ty::TraitRef<'tcx>, ErrorReported>\n-{\n-    match self.lang_items.from_builtin_kind(builtin_bound) {\n-        Ok(def_id) => {\n-            Ok(ty::TraitRef {\n-                def_id: def_id,\n-                substs: self.mk_substs(Substs::empty().with_self_ty(param_ty))\n-            })\n-        }\n-        Err(e) => {\n-            self.sess.err(&e);\n-            Err(ErrorReported)\n+    pub fn trait_ref_for_builtin_bound(self,\n+        builtin_bound: ty::BuiltinBound,\n+        param_ty: Ty<'tcx>)\n+        -> Result<ty::TraitRef<'tcx>, ErrorReported>\n+    {\n+        match self.lang_items.from_builtin_kind(builtin_bound) {\n+            Ok(def_id) => {\n+                Ok(ty::TraitRef {\n+                    def_id: def_id,\n+                    substs: self.mk_substs(Substs::empty().with_self_ty(param_ty))\n+                })\n+            }\n+            Err(e) => {\n+                self.sess.err(&e);\n+                Err(ErrorReported)\n+            }\n         }\n     }\n-}\n \n-pub fn predicate_for_trait_def(self,\n-    cause: ObligationCause<'tcx>,\n-    trait_def_id: DefId,\n-    recursion_depth: usize,\n-    param_ty: Ty<'tcx>,\n-    ty_params: Vec<Ty<'tcx>>)\n-    -> PredicateObligation<'tcx>\n-{\n-    let trait_ref = ty::TraitRef {\n-        def_id: trait_def_id,\n-        substs: self.mk_substs(Substs::new_trait(ty_params, vec![], param_ty))\n-    };\n-    predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n-}\n-\n-pub fn predicate_for_builtin_bound(self,\n-    cause: ObligationCause<'tcx>,\n-    builtin_bound: ty::BuiltinBound,\n-    recursion_depth: usize,\n-    param_ty: Ty<'tcx>)\n-    -> Result<PredicateObligation<'tcx>, ErrorReported>\n-{\n-    let trait_ref = self.trait_ref_for_builtin_bound(builtin_bound, param_ty)?;\n-    Ok(predicate_for_trait_ref(cause, trait_ref, recursion_depth))\n-}\n-\n-/// Cast a trait reference into a reference to one of its super\n-/// traits; returns `None` if `target_trait_def_id` is not a\n-/// supertrait.\n-pub fn upcast_choices(self,\n-                      source_trait_ref: ty::PolyTraitRef<'tcx>,\n-                      target_trait_def_id: DefId)\n-                      -> Vec<ty::PolyTraitRef<'tcx>>\n-{\n-    if source_trait_ref.def_id() == target_trait_def_id {\n-        return vec![source_trait_ref]; // shorcut the most common case\n+    pub fn predicate_for_trait_def(self,\n+        cause: ObligationCause<'tcx>,\n+        trait_def_id: DefId,\n+        recursion_depth: usize,\n+        param_ty: Ty<'tcx>,\n+        ty_params: Vec<Ty<'tcx>>)\n+        -> PredicateObligation<'tcx>\n+    {\n+        let trait_ref = ty::TraitRef {\n+            def_id: trait_def_id,\n+            substs: self.mk_substs(Substs::new_trait(ty_params, vec![], param_ty))\n+        };\n+        predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n     }\n \n-    supertraits(self, source_trait_ref)\n-        .filter(|r| r.def_id() == target_trait_def_id)\n-        .collect()\n-}\n+    pub fn predicate_for_builtin_bound(self,\n+        cause: ObligationCause<'tcx>,\n+        builtin_bound: ty::BuiltinBound,\n+        recursion_depth: usize,\n+        param_ty: Ty<'tcx>)\n+        -> Result<PredicateObligation<'tcx>, ErrorReported>\n+    {\n+        let trait_ref = self.trait_ref_for_builtin_bound(builtin_bound, param_ty)?;\n+        Ok(predicate_for_trait_ref(cause, trait_ref, recursion_depth))\n+    }\n \n-/// Given a trait `trait_ref`, returns the number of vtable entries\n-/// that come from `trait_ref`, excluding its supertraits. Used in\n-/// computing the vtable base for an upcast trait of a trait object.\n-pub fn count_own_vtable_entries(self, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n-    let mut entries = 0;\n-    // Count number of methods and add them to the total offset.\n-    // Skip over associated types and constants.\n-    for trait_item in &self.trait_items(trait_ref.def_id())[..] {\n-        if let ty::MethodTraitItem(_) = *trait_item {\n-            entries += 1;\n+    /// Cast a trait reference into a reference to one of its super\n+    /// traits; returns `None` if `target_trait_def_id` is not a\n+    /// supertrait.\n+    pub fn upcast_choices(self,\n+                          source_trait_ref: ty::PolyTraitRef<'tcx>,\n+                          target_trait_def_id: DefId)\n+                          -> Vec<ty::PolyTraitRef<'tcx>>\n+    {\n+        if source_trait_ref.def_id() == target_trait_def_id {\n+            return vec![source_trait_ref]; // shorcut the most common case\n         }\n+\n+        supertraits(self, source_trait_ref)\n+            .filter(|r| r.def_id() == target_trait_def_id)\n+            .collect()\n     }\n-    entries\n-}\n \n-/// Given an upcast trait object described by `object`, returns the\n-/// index of the method `method_def_id` (which should be part of\n-/// `object.upcast_trait_ref`) within the vtable for `object`.\n-pub fn get_vtable_index_of_object_method(self,\n-                                         object: &super::VtableObjectData<'tcx>,\n-                                         method_def_id: DefId) -> usize {\n-    // Count number of methods preceding the one we are selecting and\n-    // add them to the total offset.\n-    // Skip over associated types and constants.\n-    let mut entries = object.vtable_base;\n-    for trait_item in &self.trait_items(object.upcast_trait_ref.def_id())[..] {\n-        if trait_item.def_id() == method_def_id {\n-            // The item with the ID we were given really ought to be a method.\n-            assert!(match *trait_item {\n-                ty::MethodTraitItem(_) => true,\n-                _ => false\n-            });\n-\n-            return entries;\n-        }\n-        if let ty::MethodTraitItem(_) = *trait_item {\n-            entries += 1;\n+    /// Given a trait `trait_ref`, returns the number of vtable entries\n+    /// that come from `trait_ref`, excluding its supertraits. Used in\n+    /// computing the vtable base for an upcast trait of a trait object.\n+    pub fn count_own_vtable_entries(self, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n+        let mut entries = 0;\n+        // Count number of methods and add them to the total offset.\n+        // Skip over associated types and constants.\n+        for trait_item in &self.trait_items(trait_ref.def_id())[..] {\n+            if let ty::MethodTraitItem(_) = *trait_item {\n+                entries += 1;\n+            }\n         }\n+        entries\n     }\n \n-    bug!(\"get_vtable_index_of_object_method: {:?} was not found\",\n-         method_def_id);\n-}\n+    /// Given an upcast trait object described by `object`, returns the\n+    /// index of the method `method_def_id` (which should be part of\n+    /// `object.upcast_trait_ref`) within the vtable for `object`.\n+    pub fn get_vtable_index_of_object_method(self,\n+                                             object: &super::VtableObjectData<'tcx>,\n+                                             method_def_id: DefId) -> usize {\n+        // Count number of methods preceding the one we are selecting and\n+        // add them to the total offset.\n+        // Skip over associated types and constants.\n+        let mut entries = object.vtable_base;\n+        for trait_item in &self.trait_items(object.upcast_trait_ref.def_id())[..] {\n+            if trait_item.def_id() == method_def_id {\n+                // The item with the ID we were given really ought to be a method.\n+                assert!(match *trait_item {\n+                    ty::MethodTraitItem(_) => true,\n+                    _ => false\n+                });\n+\n+                return entries;\n+            }\n+            if let ty::MethodTraitItem(_) = *trait_item {\n+                entries += 1;\n+            }\n+        }\n \n-pub fn closure_trait_ref_and_return_type(self,\n-    fn_trait_def_id: DefId,\n-    self_ty: Ty<'tcx>,\n-    sig: &ty::PolyFnSig<'tcx>,\n-    tuple_arguments: TupleArgumentsFlag)\n-    -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)>\n-{\n-    let arguments_tuple = match tuple_arguments {\n-        TupleArgumentsFlag::No => sig.0.inputs[0],\n-        TupleArgumentsFlag::Yes => self.mk_tup(sig.0.inputs.to_vec()),\n-    };\n-    let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n-    let trait_ref = ty::TraitRef {\n-        def_id: fn_trait_def_id,\n-        substs: self.mk_substs(trait_substs),\n-    };\n-    ty::Binder((trait_ref, sig.0.output.unwrap_or(self.mk_nil())))\n-}\n+        bug!(\"get_vtable_index_of_object_method: {:?} was not found\",\n+             method_def_id);\n+    }\n+\n+    pub fn closure_trait_ref_and_return_type(self,\n+        fn_trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        sig: &ty::PolyFnSig<'tcx>,\n+        tuple_arguments: TupleArgumentsFlag)\n+        -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)>\n+    {\n+        let arguments_tuple = match tuple_arguments {\n+            TupleArgumentsFlag::No => sig.0.inputs[0],\n+            TupleArgumentsFlag::Yes => self.mk_tup(sig.0.inputs.to_vec()),\n+        };\n+        let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n+        let trait_ref = ty::TraitRef {\n+            def_id: fn_trait_def_id,\n+            substs: self.mk_substs(trait_substs),\n+        };\n+        ty::Binder((trait_ref, sig.0.output.unwrap_or(self.mk_nil())))\n+    }\n }\n \n pub enum TupleArgumentsFlag { Yes, No }"}, {"sha": "9ae3325c2588f5f7749206f780b1be0a72b609ed", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 135, "deletions": 135, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -56,156 +56,156 @@ pub enum Component<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-/// Returns all the things that must outlive `'a` for the condition\n-/// `ty0: 'a` to hold.\n-pub fn outlives_components(&self, ty0: Ty<'tcx>)\n-                           -> Vec<Component<'tcx>> {\n-    let mut components = vec![];\n-    self.compute_components(ty0, &mut components);\n-    debug!(\"components({:?}) = {:?}\", ty0, components);\n-    components\n-}\n+    /// Returns all the things that must outlive `'a` for the condition\n+    /// `ty0: 'a` to hold.\n+    pub fn outlives_components(&self, ty0: Ty<'tcx>)\n+                               -> Vec<Component<'tcx>> {\n+        let mut components = vec![];\n+        self.compute_components(ty0, &mut components);\n+        debug!(\"components({:?}) = {:?}\", ty0, components);\n+        components\n+    }\n \n-fn compute_components(&self, ty: Ty<'tcx>, out: &mut Vec<Component<'tcx>>) {\n-    // Descend through the types, looking for the various \"base\"\n-    // components and collecting them into `out`. This is not written\n-    // with `collect()` because of the need to sometimes skip subtrees\n-    // in the `subtys` iterator (e.g., when encountering a\n-    // projection).\n-    match ty.sty {\n-        ty::TyClosure(_, ref substs) => {\n-            // FIXME(#27086). We do not accumulate from substs, since they\n-            // don't represent reachable data. This means that, in\n-            // practice, some of the lifetime parameters might not\n-            // be in scope when the body runs, so long as there is\n-            // no reachable data with that lifetime. For better or\n-            // worse, this is consistent with fn types, however,\n-            // which can also encapsulate data in this fashion\n-            // (though it's somewhat harder, and typically\n-            // requires virtual dispatch).\n-            //\n-            // Note that changing this (in a naive way, at least)\n-            // causes regressions for what appears to be perfectly\n-            // reasonable code like this:\n-            //\n-            // ```\n-            // fn foo<'a>(p: &Data<'a>) {\n-            //    bar(|q: &mut Parser| q.read_addr())\n-            // }\n-            // fn bar(p: Box<FnMut(&mut Parser)+'static>) {\n-            // }\n-            // ```\n-            //\n-            // Note that `p` (and `'a`) are not used in the\n-            // closure at all, but to meet the requirement that\n-            // the closure type `C: 'static` (so it can be coerced\n-            // to the object type), we get the requirement that\n-            // `'a: 'static` since `'a` appears in the closure\n-            // type `C`.\n-            //\n-            // A smarter fix might \"prune\" unused `func_substs` --\n-            // this would avoid breaking simple examples like\n-            // this, but would still break others (which might\n-            // indeed be invalid, depending on your POV). Pruning\n-            // would be a subtle process, since we have to see\n-            // what func/type parameters are used and unused,\n-            // taking into consideration UFCS and so forth.\n+    fn compute_components(&self, ty: Ty<'tcx>, out: &mut Vec<Component<'tcx>>) {\n+        // Descend through the types, looking for the various \"base\"\n+        // components and collecting them into `out`. This is not written\n+        // with `collect()` because of the need to sometimes skip subtrees\n+        // in the `subtys` iterator (e.g., when encountering a\n+        // projection).\n+        match ty.sty {\n+            ty::TyClosure(_, ref substs) => {\n+                // FIXME(#27086). We do not accumulate from substs, since they\n+                // don't represent reachable data. This means that, in\n+                // practice, some of the lifetime parameters might not\n+                // be in scope when the body runs, so long as there is\n+                // no reachable data with that lifetime. For better or\n+                // worse, this is consistent with fn types, however,\n+                // which can also encapsulate data in this fashion\n+                // (though it's somewhat harder, and typically\n+                // requires virtual dispatch).\n+                //\n+                // Note that changing this (in a naive way, at least)\n+                // causes regressions for what appears to be perfectly\n+                // reasonable code like this:\n+                //\n+                // ```\n+                // fn foo<'a>(p: &Data<'a>) {\n+                //    bar(|q: &mut Parser| q.read_addr())\n+                // }\n+                // fn bar(p: Box<FnMut(&mut Parser)+'static>) {\n+                // }\n+                // ```\n+                //\n+                // Note that `p` (and `'a`) are not used in the\n+                // closure at all, but to meet the requirement that\n+                // the closure type `C: 'static` (so it can be coerced\n+                // to the object type), we get the requirement that\n+                // `'a: 'static` since `'a` appears in the closure\n+                // type `C`.\n+                //\n+                // A smarter fix might \"prune\" unused `func_substs` --\n+                // this would avoid breaking simple examples like\n+                // this, but would still break others (which might\n+                // indeed be invalid, depending on your POV). Pruning\n+                // would be a subtle process, since we have to see\n+                // what func/type parameters are used and unused,\n+                // taking into consideration UFCS and so forth.\n \n-            for &upvar_ty in substs.upvar_tys {\n-                self.compute_components(upvar_ty, out);\n+                for &upvar_ty in substs.upvar_tys {\n+                    self.compute_components(upvar_ty, out);\n+                }\n             }\n-        }\n \n-        // OutlivesTypeParameterEnv -- the actual checking that `X:'a`\n-        // is implied by the environment is done in regionck.\n-        ty::TyParam(p) => {\n-            out.push(Component::Param(p));\n-        }\n+            // OutlivesTypeParameterEnv -- the actual checking that `X:'a`\n+            // is implied by the environment is done in regionck.\n+            ty::TyParam(p) => {\n+                out.push(Component::Param(p));\n+            }\n \n-        // For projections, we prefer to generate an obligation like\n-        // `<P0 as Trait<P1...Pn>>::Foo: 'a`, because this gives the\n-        // regionck more ways to prove that it holds. However,\n-        // regionck is not (at least currently) prepared to deal with\n-        // higher-ranked regions that may appear in the\n-        // trait-ref. Therefore, if we see any higher-ranke regions,\n-        // we simply fallback to the most restrictive rule, which\n-        // requires that `Pi: 'a` for all `i`.\n-        ty::TyProjection(ref data) => {\n-            if !data.has_escaping_regions() {\n-                // best case: no escaping regions, so push the\n-                // projection and skip the subtree (thus generating no\n-                // constraints for Pi). This defers the choice between\n-                // the rules OutlivesProjectionEnv,\n-                // OutlivesProjectionTraitDef, and\n-                // OutlivesProjectionComponents to regionck.\n-                out.push(Component::Projection(*data));\n-            } else {\n-                // fallback case: hard code\n-                // OutlivesProjectionComponents.  Continue walking\n-                // through and constrain Pi.\n-                let subcomponents = self.capture_components(ty);\n-                out.push(Component::EscapingProjection(subcomponents));\n+            // For projections, we prefer to generate an obligation like\n+            // `<P0 as Trait<P1...Pn>>::Foo: 'a`, because this gives the\n+            // regionck more ways to prove that it holds. However,\n+            // regionck is not (at least currently) prepared to deal with\n+            // higher-ranked regions that may appear in the\n+            // trait-ref. Therefore, if we see any higher-ranke regions,\n+            // we simply fallback to the most restrictive rule, which\n+            // requires that `Pi: 'a` for all `i`.\n+            ty::TyProjection(ref data) => {\n+                if !data.has_escaping_regions() {\n+                    // best case: no escaping regions, so push the\n+                    // projection and skip the subtree (thus generating no\n+                    // constraints for Pi). This defers the choice between\n+                    // the rules OutlivesProjectionEnv,\n+                    // OutlivesProjectionTraitDef, and\n+                    // OutlivesProjectionComponents to regionck.\n+                    out.push(Component::Projection(*data));\n+                } else {\n+                    // fallback case: hard code\n+                    // OutlivesProjectionComponents.  Continue walking\n+                    // through and constrain Pi.\n+                    let subcomponents = self.capture_components(ty);\n+                    out.push(Component::EscapingProjection(subcomponents));\n+                }\n             }\n-        }\n \n-        // If we encounter an inference variable, try to resolve it\n-        // and proceed with resolved version. If we cannot resolve it,\n-        // then record the unresolved variable as a component.\n-        ty::TyInfer(_) => {\n-            let ty = self.resolve_type_vars_if_possible(&ty);\n-            if let ty::TyInfer(infer_ty) = ty.sty {\n-                out.push(Component::UnresolvedInferenceVariable(infer_ty));\n-            } else {\n-                self.compute_components(ty, out);\n+            // If we encounter an inference variable, try to resolve it\n+            // and proceed with resolved version. If we cannot resolve it,\n+            // then record the unresolved variable as a component.\n+            ty::TyInfer(_) => {\n+                let ty = self.resolve_type_vars_if_possible(&ty);\n+                if let ty::TyInfer(infer_ty) = ty.sty {\n+                    out.push(Component::UnresolvedInferenceVariable(infer_ty));\n+                } else {\n+                    self.compute_components(ty, out);\n+                }\n             }\n-        }\n \n-        // Most types do not introduce any region binders, nor\n-        // involve any other subtle cases, and so the WF relation\n-        // simply constraints any regions referenced directly by\n-        // the type and then visits the types that are lexically\n-        // contained within. (The comments refer to relevant rules\n-        // from RFC1214.)\n-        ty::TyBool |            // OutlivesScalar\n-        ty::TyChar |            // OutlivesScalar\n-        ty::TyInt(..) |         // OutlivesScalar\n-        ty::TyUint(..) |        // OutlivesScalar\n-        ty::TyFloat(..) |       // OutlivesScalar\n-        ty::TyEnum(..) |        // OutlivesNominalType\n-        ty::TyStruct(..) |      // OutlivesNominalType\n-        ty::TyBox(..) |         // OutlivesNominalType (ish)\n-        ty::TyStr |             // OutlivesScalar (ish)\n-        ty::TyArray(..) |       // ...\n-        ty::TySlice(..) |       // ...\n-        ty::TyRawPtr(..) |      // ...\n-        ty::TyRef(..) |         // OutlivesReference\n-        ty::TyTuple(..) |       // ...\n-        ty::TyFnDef(..) |       // OutlivesFunction (*)\n-        ty::TyFnPtr(_) |        // OutlivesFunction (*)\n-        ty::TyTrait(..) |       // OutlivesObject, OutlivesFragment (*)\n-        ty::TyError => {\n-            // (*) Bare functions and traits are both binders. In the\n-            // RFC, this means we would add the bound regions to the\n-            // \"bound regions list\".  In our representation, no such\n-            // list is maintained explicitly, because bound regions\n-            // themselves can be readily identified.\n+            // Most types do not introduce any region binders, nor\n+            // involve any other subtle cases, and so the WF relation\n+            // simply constraints any regions referenced directly by\n+            // the type and then visits the types that are lexically\n+            // contained within. (The comments refer to relevant rules\n+            // from RFC1214.)\n+            ty::TyBool |            // OutlivesScalar\n+            ty::TyChar |            // OutlivesScalar\n+            ty::TyInt(..) |         // OutlivesScalar\n+            ty::TyUint(..) |        // OutlivesScalar\n+            ty::TyFloat(..) |       // OutlivesScalar\n+            ty::TyEnum(..) |        // OutlivesNominalType\n+            ty::TyStruct(..) |      // OutlivesNominalType\n+            ty::TyBox(..) |         // OutlivesNominalType (ish)\n+            ty::TyStr |             // OutlivesScalar (ish)\n+            ty::TyArray(..) |       // ...\n+            ty::TySlice(..) |       // ...\n+            ty::TyRawPtr(..) |      // ...\n+            ty::TyRef(..) |         // OutlivesReference\n+            ty::TyTuple(..) |       // ...\n+            ty::TyFnDef(..) |       // OutlivesFunction (*)\n+            ty::TyFnPtr(_) |        // OutlivesFunction (*)\n+            ty::TyTrait(..) |       // OutlivesObject, OutlivesFragment (*)\n+            ty::TyError => {\n+                // (*) Bare functions and traits are both binders. In the\n+                // RFC, this means we would add the bound regions to the\n+                // \"bound regions list\".  In our representation, no such\n+                // list is maintained explicitly, because bound regions\n+                // themselves can be readily identified.\n \n-            push_region_constraints(out, ty.regions());\n-            for subty in ty.walk_shallow() {\n-                self.compute_components(subty, out);\n+                push_region_constraints(out, ty.regions());\n+                for subty in ty.walk_shallow() {\n+                    self.compute_components(subty, out);\n+                }\n             }\n         }\n     }\n-}\n \n-fn capture_components(&self, ty: Ty<'tcx>) -> Vec<Component<'tcx>> {\n-    let mut temp = vec![];\n-    push_region_constraints(&mut temp, ty.regions());\n-    for subty in ty.walk_shallow() {\n-        self.compute_components(subty, &mut temp);\n+    fn capture_components(&self, ty: Ty<'tcx>) -> Vec<Component<'tcx>> {\n+        let mut temp = vec![];\n+        push_region_constraints(&mut temp, ty.regions());\n+        for subty in ty.walk_shallow() {\n+            self.compute_components(subty, &mut temp);\n+        }\n+        temp\n     }\n-    temp\n-}\n }\n \n fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region>) {"}, {"sha": "725d40889ceecb3ba8dbaee4d044e1a3a62014a1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1622, "deletions": 1613, "changes": 3235, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=42eb7032fab11aca9228d42969f471b581444c56"}, {"sha": "d55ca803c64ca500faaae1bd9eb262a2536e9d0f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 669, "deletions": 667, "changes": 1336, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -56,765 +56,767 @@ fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: b\n }\n \n impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n-pub fn check_pat(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>) {\n-    let tcx = self.tcx;\n+    pub fn check_pat(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>) {\n+        let tcx = self.tcx;\n \n-    debug!(\"check_pat(pat={:?},expected={:?})\", pat, expected);\n+        debug!(\"check_pat(pat={:?},expected={:?})\", pat, expected);\n \n-    match pat.node {\n-        PatKind::Wild => {\n-            self.write_ty(pat.id, expected);\n-        }\n-        PatKind::Lit(ref lt) => {\n-            self.check_expr(&lt);\n-            let expr_ty = self.expr_ty(&lt);\n-\n-            // Byte string patterns behave the same way as array patterns\n-            // They can denote both statically and dynamically sized byte arrays\n-            let mut pat_ty = expr_ty;\n-            if let hir::ExprLit(ref lt) = lt.node {\n-                if let ast::LitKind::ByteStr(_) = lt.node {\n-                    let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                    if let ty::TyRef(_, mt) = expected_ty.sty {\n-                        if let ty::TySlice(_) = mt.ty.sty {\n-                            pat_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n-                                                     tcx.mk_slice(tcx.types.u8))\n+        match pat.node {\n+            PatKind::Wild => {\n+                self.write_ty(pat.id, expected);\n+            }\n+            PatKind::Lit(ref lt) => {\n+                self.check_expr(&lt);\n+                let expr_ty = self.expr_ty(&lt);\n+\n+                // Byte string patterns behave the same way as array patterns\n+                // They can denote both statically and dynamically sized byte arrays\n+                let mut pat_ty = expr_ty;\n+                if let hir::ExprLit(ref lt) = lt.node {\n+                    if let ast::LitKind::ByteStr(_) = lt.node {\n+                        let expected_ty = self.structurally_resolved_type(pat.span, expected);\n+                        if let ty::TyRef(_, mt) = expected_ty.sty {\n+                            if let ty::TySlice(_) = mt.ty.sty {\n+                                pat_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n+                                                         tcx.mk_slice(tcx.types.u8))\n+                            }\n                         }\n                     }\n                 }\n-            }\n-\n-            self.write_ty(pat.id, pat_ty);\n-\n-            // somewhat surprising: in this case, the subtyping\n-            // relation goes the opposite way as the other\n-            // cases. Actually what we really want is not a subtyping\n-            // relation at all but rather that there exists a LUB (so\n-            // that they can be compared). However, in practice,\n-            // constants are always scalars or strings.  For scalars\n-            // subtyping is irrelevant, and for strings `expr_ty` is\n-            // type is `&'static str`, so if we say that\n-            //\n-            //     &'static str <: expected\n-            //\n-            // that's equivalent to there existing a LUB.\n-            self.demand_suptype(pat.span, expected, pat_ty);\n-        }\n-        PatKind::Range(ref begin, ref end) => {\n-            self.check_expr(begin);\n-            self.check_expr(end);\n-\n-            let lhs_ty = self.expr_ty(begin);\n-            let rhs_ty = self.expr_ty(end);\n-\n-            // Check that both end-points are of numeric or char type.\n-            let numeric_or_char = |ty: Ty| ty.is_numeric() || ty.is_char();\n-            let lhs_compat = numeric_or_char(lhs_ty);\n-            let rhs_compat = numeric_or_char(rhs_ty);\n-\n-            if !lhs_compat || !rhs_compat {\n-                let span = if !lhs_compat && !rhs_compat {\n-                    pat.span\n-                } else if !lhs_compat {\n-                    begin.span\n-                } else {\n-                    end.span\n-                };\n \n-                // Note: spacing here is intentional, we want a space before \"start\" and \"end\".\n-                span_err!(tcx.sess, span, E0029,\n-                          \"only char and numeric types are allowed in range patterns\\n \\\n-                           start type: {}\\n end type: {}\",\n-                          self.ty_to_string(lhs_ty),\n-                          self.ty_to_string(rhs_ty)\n-                );\n-                return;\n+                self.write_ty(pat.id, pat_ty);\n+\n+                // somewhat surprising: in this case, the subtyping\n+                // relation goes the opposite way as the other\n+                // cases. Actually what we really want is not a subtyping\n+                // relation at all but rather that there exists a LUB (so\n+                // that they can be compared). However, in practice,\n+                // constants are always scalars or strings.  For scalars\n+                // subtyping is irrelevant, and for strings `expr_ty` is\n+                // type is `&'static str`, so if we say that\n+                //\n+                //     &'static str <: expected\n+                //\n+                // that's equivalent to there existing a LUB.\n+                self.demand_suptype(pat.span, expected, pat_ty);\n             }\n+            PatKind::Range(ref begin, ref end) => {\n+                self.check_expr(begin);\n+                self.check_expr(end);\n+\n+                let lhs_ty = self.expr_ty(begin);\n+                let rhs_ty = self.expr_ty(end);\n+\n+                // Check that both end-points are of numeric or char type.\n+                let numeric_or_char = |ty: Ty| ty.is_numeric() || ty.is_char();\n+                let lhs_compat = numeric_or_char(lhs_ty);\n+                let rhs_compat = numeric_or_char(rhs_ty);\n+\n+                if !lhs_compat || !rhs_compat {\n+                    let span = if !lhs_compat && !rhs_compat {\n+                        pat.span\n+                    } else if !lhs_compat {\n+                        begin.span\n+                    } else {\n+                        end.span\n+                    };\n+\n+                    // Note: spacing here is intentional, we want a space before \"start\" and \"end\".\n+                    span_err!(tcx.sess, span, E0029,\n+                              \"only char and numeric types are allowed in range patterns\\n \\\n+                               start type: {}\\n end type: {}\",\n+                              self.ty_to_string(lhs_ty),\n+                              self.ty_to_string(rhs_ty)\n+                    );\n+                    return;\n+                }\n \n-            // Check that the types of the end-points can be unified.\n-            let types_unify = self.require_same_types(pat.span, rhs_ty, lhs_ty,\n-                                                      \"mismatched types in range\");\n+                // Check that the types of the end-points can be unified.\n+                let types_unify = self.require_same_types(pat.span, rhs_ty, lhs_ty,\n+                                                          \"mismatched types in range\");\n \n-            // It's ok to return without a message as `require_same_types` prints an error.\n-            if !types_unify {\n-                return;\n-            }\n+                // It's ok to return without a message as `require_same_types` prints an error.\n+                if !types_unify {\n+                    return;\n+                }\n \n-            // Now that we know the types can be unified we find the unified type and use\n-            // it to type the entire expression.\n-            let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n+                // Now that we know the types can be unified we find the unified type and use\n+                // it to type the entire expression.\n+                let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n \n-            self.write_ty(pat.id, common_type);\n+                self.write_ty(pat.id, common_type);\n \n-            // subtyping doesn't matter here, as the value is some kind of scalar\n-            self.demand_eqtype(pat.span, expected, lhs_ty);\n-        }\n-        PatKind::Path(..) | PatKind::Ident(..)\n-                if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n-            if let Some(pat_def) = tcx.def_map.borrow().get(&pat.id) {\n-                let const_did = pat_def.def_id();\n-                let const_scheme = tcx.lookup_item_type(const_did);\n-                assert!(const_scheme.generics.is_empty());\n-                let const_ty = self.instantiate_type_scheme(pat.span,\n-                                                            &Substs::empty(),\n-                                                            &const_scheme.ty);\n-                self.write_ty(pat.id, const_ty);\n-\n-                // FIXME(#20489) -- we should limit the types here to scalars or something!\n-\n-                // As with PatKind::Lit, what we really want here is that there\n-                // exist a LUB, but for the cases that can occur, subtype\n-                // is good enough.\n-                self.demand_suptype(pat.span, expected, const_ty);\n-            } else {\n-                self.write_error(pat.id);\n+                // subtyping doesn't matter here, as the value is some kind of scalar\n+                self.demand_eqtype(pat.span, expected, lhs_ty);\n             }\n-        }\n-        PatKind::Ident(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map.borrow(), pat) => {\n-            let typ = self.local_ty(pat.span, pat.id);\n-            match bm {\n-                hir::BindByRef(mutbl) => {\n-                    // if the binding is like\n-                    //    ref x | ref const x | ref mut x\n-                    // then `x` is assigned a value of type `&M T` where M is the mutability\n-                    // and T is the expected type.\n-                    let region_var = self.next_region_var(infer::PatternRegion(pat.span));\n-                    let mt = ty::TypeAndMut { ty: expected, mutbl: mutbl };\n-                    let region_ty = tcx.mk_ref(tcx.mk_region(region_var), mt);\n-\n-                    // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n-                    // required. However, we use equality, which is stronger. See (*) for\n-                    // an explanation.\n-                    self.demand_eqtype(pat.span, region_ty, typ);\n-                }\n-                // otherwise the type of x is the expected type T\n-                hir::BindByValue(_) => {\n-                    // As above, `T <: typeof(x)` is required but we\n-                    // use equality, see (*) below.\n-                    self.demand_eqtype(pat.span, expected, typ);\n+            PatKind::Path(..) | PatKind::Ident(..)\n+                    if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n+                if let Some(pat_def) = tcx.def_map.borrow().get(&pat.id) {\n+                    let const_did = pat_def.def_id();\n+                    let const_scheme = tcx.lookup_item_type(const_did);\n+                    assert!(const_scheme.generics.is_empty());\n+                    let const_ty = self.instantiate_type_scheme(pat.span,\n+                                                                &Substs::empty(),\n+                                                                &const_scheme.ty);\n+                    self.write_ty(pat.id, const_ty);\n+\n+                    // FIXME(#20489) -- we should limit the types here to scalars or something!\n+\n+                    // As with PatKind::Lit, what we really want here is that there\n+                    // exist a LUB, but for the cases that can occur, subtype\n+                    // is good enough.\n+                    self.demand_suptype(pat.span, expected, const_ty);\n+                } else {\n+                    self.write_error(pat.id);\n                 }\n             }\n+            PatKind::Ident(bm, ref path, ref sub)\n+                    if pat_is_binding(&tcx.def_map.borrow(), pat) => {\n+                let typ = self.local_ty(pat.span, pat.id);\n+                match bm {\n+                    hir::BindByRef(mutbl) => {\n+                        // if the binding is like\n+                        //    ref x | ref const x | ref mut x\n+                        // then `x` is assigned a value of type `&M T` where M is the mutability\n+                        // and T is the expected type.\n+                        let region_var = self.next_region_var(infer::PatternRegion(pat.span));\n+                        let mt = ty::TypeAndMut { ty: expected, mutbl: mutbl };\n+                        let region_ty = tcx.mk_ref(tcx.mk_region(region_var), mt);\n+\n+                        // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n+                        // required. However, we use equality, which is stronger. See (*) for\n+                        // an explanation.\n+                        self.demand_eqtype(pat.span, region_ty, typ);\n+                    }\n+                    // otherwise the type of x is the expected type T\n+                    hir::BindByValue(_) => {\n+                        // As above, `T <: typeof(x)` is required but we\n+                        // use equality, see (*) below.\n+                        self.demand_eqtype(pat.span, expected, typ);\n+                    }\n+                }\n \n-            self.write_ty(pat.id, typ);\n+                self.write_ty(pat.id, typ);\n \n-            // if there are multiple arms, make sure they all agree on\n-            // what the type of the binding `x` ought to be\n-            if let Some(&canon_id) = self.map.get(&path.node.name) {\n-                if canon_id != pat.id {\n-                    let ct = self.local_ty(pat.span, canon_id);\n-                    self.demand_eqtype(pat.span, ct, typ);\n-                }\n+                // if there are multiple arms, make sure they all agree on\n+                // what the type of the binding `x` ought to be\n+                if let Some(&canon_id) = self.map.get(&path.node.name) {\n+                    if canon_id != pat.id {\n+                        let ct = self.local_ty(pat.span, canon_id);\n+                        self.demand_eqtype(pat.span, ct, typ);\n+                    }\n \n-                if let Some(ref p) = *sub {\n-                    self.check_pat(&p, expected);\n+                    if let Some(ref p) = *sub {\n+                        self.check_pat(&p, expected);\n+                    }\n                 }\n             }\n-        }\n-        PatKind::Ident(_, ref path, _) => {\n-            let path = hir::Path::from_ident(path.span, path.node);\n-            self.check_pat_enum(pat, &path, Some(&[]), expected, false);\n-        }\n-        PatKind::TupleStruct(ref path, ref subpats) => {\n-            self.check_pat_enum(pat, path, subpats.as_ref().map(|v| &v[..]), expected, true);\n-        }\n-        PatKind::Path(ref path) => {\n-            self.check_pat_enum(pat, path, Some(&[]), expected, false);\n-        }\n-        PatKind::QPath(ref qself, ref path) => {\n-            let self_ty = self.to_ty(&qself.ty);\n-            let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n-                if d.base_def == Def::Err {\n-                    self.set_tainted_by_errors();\n+            PatKind::Ident(_, ref path, _) => {\n+                let path = hir::Path::from_ident(path.span, path.node);\n+                self.check_pat_enum(pat, &path, Some(&[]), expected, false);\n+            }\n+            PatKind::TupleStruct(ref path, ref subpats) => {\n+                self.check_pat_enum(pat, path, subpats.as_ref().map(|v| &v[..]), expected, true);\n+            }\n+            PatKind::Path(ref path) => {\n+                self.check_pat_enum(pat, path, Some(&[]), expected, false);\n+            }\n+            PatKind::QPath(ref qself, ref path) => {\n+                let self_ty = self.to_ty(&qself.ty);\n+                let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n+                    if d.base_def == Def::Err {\n+                        self.set_tainted_by_errors();\n+                        self.write_error(pat.id);\n+                        return;\n+                    }\n+                    d\n+                } else if qself.position == 0 {\n+                    // This is just a sentinel for finish_resolving_def_to_ty.\n+                    let sentinel = self.tcx.map.local_def_id(ast::CRATE_NODE_ID);\n+                    def::PathResolution {\n+                        base_def: Def::Mod(sentinel),\n+                        depth: path.segments.len()\n+                    }\n+                } else {\n+                    debug!(\"unbound path {:?}\", pat);\n                     self.write_error(pat.id);\n                     return;\n+                };\n+                if let Some((opt_ty, segments, def)) =\n+                        self.resolve_ty_and_def_ufcs(path_res, Some(self_ty),\n+                                                     path, pat.span, pat.id) {\n+                    if self.check_assoc_item_is_const(def, pat.span) {\n+                        let scheme = tcx.lookup_item_type(def.def_id());\n+                        let predicates = tcx.lookup_predicates(def.def_id());\n+                        self.instantiate_path(segments, scheme, &predicates,\n+                                              opt_ty, def, pat.span, pat.id);\n+                        let const_ty = self.node_ty(pat.id);\n+                        self.demand_suptype(pat.span, expected, const_ty);\n+                    } else {\n+                        self.write_error(pat.id)\n+                    }\n                 }\n-                d\n-            } else if qself.position == 0 {\n-                // This is just a sentinel for finish_resolving_def_to_ty.\n-                let sentinel = self.tcx.map.local_def_id(ast::CRATE_NODE_ID);\n-                def::PathResolution {\n-                    base_def: Def::Mod(sentinel),\n-                    depth: path.segments.len()\n+            }\n+            PatKind::Struct(ref path, ref fields, etc) => {\n+                self.check_pat_struct(pat, path, fields, etc, expected);\n+            }\n+            PatKind::Tup(ref elements) => {\n+                let element_tys: Vec<_> =\n+                    (0..elements.len()).map(|_| self.next_ty_var()).collect();\n+                let pat_ty = tcx.mk_tup(element_tys.clone());\n+                self.write_ty(pat.id, pat_ty);\n+                self.demand_eqtype(pat.span, expected, pat_ty);\n+                for (element_pat, element_ty) in elements.iter().zip(element_tys) {\n+                    self.check_pat(&element_pat, element_ty);\n                 }\n-            } else {\n-                debug!(\"unbound path {:?}\", pat);\n-                self.write_error(pat.id);\n-                return;\n-            };\n-            if let Some((opt_ty, segments, def)) =\n-                    self.resolve_ty_and_def_ufcs(path_res, Some(self_ty),\n-                                                 path, pat.span, pat.id) {\n-                if self.check_assoc_item_is_const(def, pat.span) {\n-                    let scheme = tcx.lookup_item_type(def.def_id());\n-                    let predicates = tcx.lookup_predicates(def.def_id());\n-                    self.instantiate_path(segments, scheme, &predicates,\n-                                          opt_ty, def, pat.span, pat.id);\n-                    let const_ty = self.node_ty(pat.id);\n-                    self.demand_suptype(pat.span, expected, const_ty);\n+            }\n+            PatKind::Box(ref inner) => {\n+                let inner_ty = self.next_ty_var();\n+                let uniq_ty = tcx.mk_box(inner_ty);\n+\n+                if self.check_dereferencable(pat.span, expected, &inner) {\n+                    // Here, `demand::subtype` is good enough, but I don't\n+                    // think any errors can be introduced by using\n+                    // `demand::eqtype`.\n+                    self.demand_eqtype(pat.span, expected, uniq_ty);\n+                    self.write_ty(pat.id, uniq_ty);\n+                    self.check_pat(&inner, inner_ty);\n                 } else {\n-                    self.write_error(pat.id)\n+                    self.write_error(pat.id);\n+                    self.check_pat(&inner, tcx.types.err);\n                 }\n             }\n-        }\n-        PatKind::Struct(ref path, ref fields, etc) => {\n-            self.check_pat_struct(pat, path, fields, etc, expected);\n-        }\n-        PatKind::Tup(ref elements) => {\n-            let element_tys: Vec<_> =\n-                (0..elements.len()).map(|_| self.next_ty_var()).collect();\n-            let pat_ty = tcx.mk_tup(element_tys.clone());\n-            self.write_ty(pat.id, pat_ty);\n-            self.demand_eqtype(pat.span, expected, pat_ty);\n-            for (element_pat, element_ty) in elements.iter().zip(element_tys) {\n-                self.check_pat(&element_pat, element_ty);\n-            }\n-        }\n-        PatKind::Box(ref inner) => {\n-            let inner_ty = self.next_ty_var();\n-            let uniq_ty = tcx.mk_box(inner_ty);\n-\n-            if self.check_dereferencable(pat.span, expected, &inner) {\n-                // Here, `demand::subtype` is good enough, but I don't\n-                // think any errors can be introduced by using\n-                // `demand::eqtype`.\n-                self.demand_eqtype(pat.span, expected, uniq_ty);\n-                self.write_ty(pat.id, uniq_ty);\n-                self.check_pat(&inner, inner_ty);\n-            } else {\n-                self.write_error(pat.id);\n-                self.check_pat(&inner, tcx.types.err);\n-            }\n-        }\n-        PatKind::Ref(ref inner, mutbl) => {\n-            let expected = self.shallow_resolve(expected);\n-            if self.check_dereferencable(pat.span, expected, &inner) {\n-                // `demand::subtype` would be good enough, but using\n-                // `eqtype` turns out to be equally general. See (*)\n-                // below for details.\n+            PatKind::Ref(ref inner, mutbl) => {\n+                let expected = self.shallow_resolve(expected);\n+                if self.check_dereferencable(pat.span, expected, &inner) {\n+                    // `demand::subtype` would be good enough, but using\n+                    // `eqtype` turns out to be equally general. See (*)\n+                    // below for details.\n+\n+                    // Take region, inner-type from expected type if we\n+                    // can, to avoid creating needless variables.  This\n+                    // also helps with the bad interactions of the given\n+                    // hack detailed in (*) below.\n+                    let (rptr_ty, inner_ty) = match expected.sty {\n+                        ty::TyRef(_, mt) if mt.mutbl == mutbl => {\n+                            (expected, mt.ty)\n+                        }\n+                        _ => {\n+                            let inner_ty = self.next_ty_var();\n+                            let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n+                            let region = self.next_region_var(infer::PatternRegion(pat.span));\n+                            let rptr_ty = tcx.mk_ref(tcx.mk_region(region), mt);\n+                            self.demand_eqtype(pat.span, expected, rptr_ty);\n+                            (rptr_ty, inner_ty)\n+                        }\n+                    };\n \n-                // Take region, inner-type from expected type if we\n-                // can, to avoid creating needless variables.  This\n-                // also helps with the bad interactions of the given\n-                // hack detailed in (*) below.\n-                let (rptr_ty, inner_ty) = match expected.sty {\n-                    ty::TyRef(_, mt) if mt.mutbl == mutbl => {\n-                        (expected, mt.ty)\n-                    }\n+                    self.write_ty(pat.id, rptr_ty);\n+                    self.check_pat(&inner, inner_ty);\n+                } else {\n+                    self.write_error(pat.id);\n+                    self.check_pat(&inner, tcx.types.err);\n+                }\n+            }\n+            PatKind::Vec(ref before, ref slice, ref after) => {\n+                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n+                let inner_ty = self.next_ty_var();\n+                let pat_ty = match expected_ty.sty {\n+                    ty::TyArray(_, size) => tcx.mk_array(inner_ty, {\n+                        let min_len = before.len() + after.len();\n+                        match *slice {\n+                            Some(_) => cmp::max(min_len, size),\n+                            None => min_len\n+                        }\n+                    }),\n                     _ => {\n-                        let inner_ty = self.next_ty_var();\n-                        let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n                         let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                        let rptr_ty = tcx.mk_ref(tcx.mk_region(region), mt);\n-                        self.demand_eqtype(pat.span, expected, rptr_ty);\n-                        (rptr_ty, inner_ty)\n+                        tcx.mk_ref(tcx.mk_region(region), ty::TypeAndMut {\n+                            ty: tcx.mk_slice(inner_ty),\n+                            mutbl: expected_ty.builtin_deref(true, ty::NoPreference)\n+                                              .map_or(hir::MutImmutable, |mt| mt.mutbl)\n+                        })\n                     }\n                 };\n \n-                self.write_ty(pat.id, rptr_ty);\n-                self.check_pat(&inner, inner_ty);\n-            } else {\n-                self.write_error(pat.id);\n-                self.check_pat(&inner, tcx.types.err);\n-            }\n-        }\n-        PatKind::Vec(ref before, ref slice, ref after) => {\n-            let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-            let inner_ty = self.next_ty_var();\n-            let pat_ty = match expected_ty.sty {\n-                ty::TyArray(_, size) => tcx.mk_array(inner_ty, {\n-                    let min_len = before.len() + after.len();\n-                    match *slice {\n-                        Some(_) => cmp::max(min_len, size),\n-                        None => min_len\n-                    }\n-                }),\n-                _ => {\n+                self.write_ty(pat.id, pat_ty);\n+\n+                // `demand::subtype` would be good enough, but using\n+                // `eqtype` turns out to be equally general. See (*)\n+                // below for details.\n+                self.demand_eqtype(pat.span, expected, pat_ty);\n+\n+                for elt in before {\n+                    self.check_pat(&elt, inner_ty);\n+                }\n+                if let Some(ref slice) = *slice {\n                     let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                    tcx.mk_ref(tcx.mk_region(region), ty::TypeAndMut {\n+                    let mutbl = expected_ty.builtin_deref(true, ty::NoPreference)\n+                        .map_or(hir::MutImmutable, |mt| mt.mutbl);\n+\n+                    let slice_ty = tcx.mk_ref(tcx.mk_region(region), ty::TypeAndMut {\n                         ty: tcx.mk_slice(inner_ty),\n-                        mutbl: expected_ty.builtin_deref(true, ty::NoPreference).map(|mt| mt.mutbl)\n-                                                              .unwrap_or(hir::MutImmutable)\n-                    })\n+                        mutbl: mutbl\n+                    });\n+                    self.check_pat(&slice, slice_ty);\n                 }\n-            };\n-\n-            self.write_ty(pat.id, pat_ty);\n+                for elt in after {\n+                    self.check_pat(&elt, inner_ty);\n+                }\n+            }\n+        }\n \n-            // `demand::subtype` would be good enough, but using\n-            // `eqtype` turns out to be equally general. See (*)\n-            // below for details.\n-            self.demand_eqtype(pat.span, expected, pat_ty);\n \n-            for elt in before {\n-                self.check_pat(&elt, inner_ty);\n-            }\n-            if let Some(ref slice) = *slice {\n-                let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                let mutbl = expected_ty.builtin_deref(true, ty::NoPreference)\n-                    .map_or(hir::MutImmutable, |mt| mt.mutbl);\n+        // (*) In most of the cases above (literals and constants being\n+        // the exception), we relate types using strict equality, evewn\n+        // though subtyping would be sufficient. There are a few reasons\n+        // for this, some of which are fairly subtle and which cost me\n+        // (nmatsakis) an hour or two debugging to remember, so I thought\n+        // I'd write them down this time.\n+        //\n+        // 1. There is no loss of expressiveness here, though it does\n+        // cause some inconvenience. What we are saying is that the type\n+        // of `x` becomes *exactly* what is expected. This can cause unnecessary\n+        // errors in some cases, such as this one:\n+        // it will cause errors in a case like this:\n+        //\n+        // ```\n+        // fn foo<'x>(x: &'x int) {\n+        //    let a = 1;\n+        //    let mut z = x;\n+        //    z = &a;\n+        // }\n+        // ```\n+        //\n+        // The reason we might get an error is that `z` might be\n+        // assigned a type like `&'x int`, and then we would have\n+        // a problem when we try to assign `&a` to `z`, because\n+        // the lifetime of `&a` (i.e., the enclosing block) is\n+        // shorter than `'x`.\n+        //\n+        // HOWEVER, this code works fine. The reason is that the\n+        // expected type here is whatever type the user wrote, not\n+        // the initializer's type. In this case the user wrote\n+        // nothing, so we are going to create a type variable `Z`.\n+        // Then we will assign the type of the initializer (`&'x\n+        // int`) as a subtype of `Z`: `&'x int <: Z`. And hence we\n+        // will instantiate `Z` as a type `&'0 int` where `'0` is\n+        // a fresh region variable, with the constraint that `'x :\n+        // '0`.  So basically we're all set.\n+        //\n+        // Note that there are two tests to check that this remains true\n+        // (`regions-reassign-{match,let}-bound-pointer.rs`).\n+        //\n+        // 2. Things go horribly wrong if we use subtype. The reason for\n+        // THIS is a fairly subtle case involving bound regions. See the\n+        // `givens` field in `region_inference`, as well as the test\n+        // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n+        // for details. Short version is that we must sometimes detect\n+        // relationships between specific region variables and regions\n+        // bound in a closure signature, and that detection gets thrown\n+        // off when we substitute fresh region variables here to enable\n+        // subtyping.\n+    }\n \n-                let slice_ty = tcx.mk_ref(tcx.mk_region(region), ty::TypeAndMut {\n-                    ty: tcx.mk_slice(inner_ty),\n-                    mutbl: mutbl\n-                });\n-                self.check_pat(&slice, slice_ty);\n+    fn check_assoc_item_is_const(&self, def: Def, span: Span) -> bool {\n+        match def {\n+            Def::AssociatedConst(..) => true,\n+            Def::Method(..) => {\n+                span_err!(self.tcx.sess, span, E0327,\n+                          \"associated items in match patterns must be constants\");\n+                false\n             }\n-            for elt in after {\n-                self.check_pat(&elt, inner_ty);\n+            _ => {\n+                span_bug!(span, \"non-associated item in check_assoc_item_is_const\");\n             }\n         }\n     }\n \n-\n-    // (*) In most of the cases above (literals and constants being\n-    // the exception), we relate types using strict equality, evewn\n-    // though subtyping would be sufficient. There are a few reasons\n-    // for this, some of which are fairly subtle and which cost me\n-    // (nmatsakis) an hour or two debugging to remember, so I thought\n-    // I'd write them down this time.\n-    //\n-    // 1. There is no loss of expressiveness here, though it does\n-    // cause some inconvenience. What we are saying is that the type\n-    // of `x` becomes *exactly* what is expected. This can cause unnecessary\n-    // errors in some cases, such as this one:\n-    // it will cause errors in a case like this:\n-    //\n-    // ```\n-    // fn foo<'x>(x: &'x int) {\n-    //    let a = 1;\n-    //    let mut z = x;\n-    //    z = &a;\n-    // }\n-    // ```\n-    //\n-    // The reason we might get an error is that `z` might be\n-    // assigned a type like `&'x int`, and then we would have\n-    // a problem when we try to assign `&a` to `z`, because\n-    // the lifetime of `&a` (i.e., the enclosing block) is\n-    // shorter than `'x`.\n-    //\n-    // HOWEVER, this code works fine. The reason is that the\n-    // expected type here is whatever type the user wrote, not\n-    // the initializer's type. In this case the user wrote\n-    // nothing, so we are going to create a type variable `Z`.\n-    // Then we will assign the type of the initializer (`&'x\n-    // int`) as a subtype of `Z`: `&'x int <: Z`. And hence we\n-    // will instantiate `Z` as a type `&'0 int` where `'0` is\n-    // a fresh region variable, with the constraint that `'x :\n-    // '0`.  So basically we're all set.\n-    //\n-    // Note that there are two tests to check that this remains true\n-    // (`regions-reassign-{match,let}-bound-pointer.rs`).\n-    //\n-    // 2. Things go horribly wrong if we use subtype. The reason for\n-    // THIS is a fairly subtle case involving bound regions. See the\n-    // `givens` field in `region_inference`, as well as the test\n-    // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n-    // for details. Short version is that we must sometimes detect\n-    // relationships between specific region variables and regions\n-    // bound in a closure signature, and that detection gets thrown\n-    // off when we substitute fresh region variables here to enable\n-    // subtyping.\n-}\n-\n-fn check_assoc_item_is_const(&self, def: Def, span: Span) -> bool {\n-    match def {\n-        Def::AssociatedConst(..) => true,\n-        Def::Method(..) => {\n-            span_err!(self.tcx.sess, span, E0327,\n-                      \"associated items in match patterns must be constants\");\n-            false\n-        }\n-        _ => {\n-            span_bug!(span, \"non-associated item in check_assoc_item_is_const\");\n+    pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n+        let tcx = self.tcx;\n+        if pat_is_binding(&tcx.def_map.borrow(), inner) {\n+            let expected = self.shallow_resolve(expected);\n+            expected.builtin_deref(true, ty::NoPreference).map_or(true, |mt| match mt.ty.sty {\n+                ty::TyTrait(_) => {\n+                    // This is \"x = SomeTrait\" being reduced from\n+                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n+                    span_err!(tcx.sess, span, E0033,\n+                              \"type `{}` cannot be dereferenced\",\n+                              self.ty_to_string(expected));\n+                    false\n+                }\n+                _ => true\n+            })\n+        } else {\n+            true\n         }\n     }\n }\n \n-pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n-    let tcx = self.tcx;\n-    if pat_is_binding(&tcx.def_map.borrow(), inner) {\n-        let expected = self.shallow_resolve(expected);\n-        expected.builtin_deref(true, ty::NoPreference).map_or(true, |mt| match mt.ty.sty {\n-            ty::TyTrait(_) => {\n-                // This is \"x = SomeTrait\" being reduced from\n-                // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n-                span_err!(tcx.sess, span, E0033,\n-                          \"type `{}` cannot be dereferenced\",\n-                          self.ty_to_string(expected));\n-                false\n-            }\n-            _ => true\n-        })\n-    } else {\n-        true\n-    }\n-}\n-}\n-\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-pub fn check_match(&self,\n-                   expr: &'gcx hir::Expr,\n-                   discrim: &'gcx hir::Expr,\n-                   arms: &'gcx [hir::Arm],\n-                   expected: Expectation<'tcx>,\n-                   match_src: hir::MatchSource) {\n-    let tcx = self.tcx;\n-\n-    // Not entirely obvious: if matches may create ref bindings, we\n-    // want to use the *precise* type of the discriminant, *not* some\n-    // supertype, as the \"discriminant type\" (issue #23116).\n-    let contains_ref_bindings = arms.iter()\n-                                    .filter_map(|a| tcx.arm_contains_ref_binding(a))\n-                                    .max_by_key(|m| match *m {\n-                                        hir::MutMutable => 1,\n-                                        hir::MutImmutable => 0,\n-                                    });\n-    let discrim_ty;\n-    if let Some(m) = contains_ref_bindings {\n-        self.check_expr_with_lvalue_pref(discrim, LvaluePreference::from_mutbl(m));\n-        discrim_ty = self.expr_ty(discrim);\n-    } else {\n-        // ...but otherwise we want to use any supertype of the\n-        // discriminant. This is sort of a workaround, see note (*) in\n-        // `check_pat` for some details.\n-        discrim_ty = self.next_ty_var();\n-        self.check_expr_has_type(discrim, discrim_ty);\n-    };\n-\n-    // Typecheck the patterns first, so that we get types for all the\n-    // bindings.\n-    for arm in arms {\n-        let pcx = PatCtxt {\n-            fcx: self,\n-            map: pat_id_map(&tcx.def_map, &arm.pats[0]),\n+    pub fn check_match(&self,\n+                       expr: &'gcx hir::Expr,\n+                       discrim: &'gcx hir::Expr,\n+                       arms: &'gcx [hir::Arm],\n+                       expected: Expectation<'tcx>,\n+                       match_src: hir::MatchSource) {\n+        let tcx = self.tcx;\n+\n+        // Not entirely obvious: if matches may create ref bindings, we\n+        // want to use the *precise* type of the discriminant, *not* some\n+        // supertype, as the \"discriminant type\" (issue #23116).\n+        let contains_ref_bindings = arms.iter()\n+                                        .filter_map(|a| tcx.arm_contains_ref_binding(a))\n+                                        .max_by_key(|m| match *m {\n+                                            hir::MutMutable => 1,\n+                                            hir::MutImmutable => 0,\n+                                        });\n+        let discrim_ty;\n+        if let Some(m) = contains_ref_bindings {\n+            self.check_expr_with_lvalue_pref(discrim, LvaluePreference::from_mutbl(m));\n+            discrim_ty = self.expr_ty(discrim);\n+        } else {\n+            // ...but otherwise we want to use any supertype of the\n+            // discriminant. This is sort of a workaround, see note (*) in\n+            // `check_pat` for some details.\n+            discrim_ty = self.next_ty_var();\n+            self.check_expr_has_type(discrim, discrim_ty);\n         };\n-        for p in &arm.pats {\n-            pcx.check_pat(&p, discrim_ty);\n-        }\n-    }\n \n-    // Now typecheck the blocks.\n-    //\n-    // The result of the match is the common supertype of all the\n-    // arms. Start out the value as bottom, since it's the, well,\n-    // bottom the type lattice, and we'll be moving up the lattice as\n-    // we process each arm. (Note that any match with 0 arms is matching\n-    // on any empty type and is therefore unreachable; should the flow\n-    // of execution reach it, we will panic, so bottom is an appropriate\n-    // type in that case)\n-    let expected = expected.adjust_for_branches(self);\n-    let mut result_ty = self.next_diverging_ty_var();\n-    let coerce_first = match expected {\n-        // We don't coerce to `()` so that if the match expression is a\n-        // statement it's branches can have any consistent type. That allows\n-        // us to give better error messages (pointing to a usually better\n-        // arm for inconsistent arms or to the whole match when a `()` type\n-        // is required).\n-        Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => {\n-            ety\n-        }\n-        _ => result_ty\n-    };\n-    for (i, arm) in arms.iter().enumerate() {\n-        if let Some(ref e) = arm.guard {\n-            self.check_expr_has_type(e, tcx.types.bool);\n+        // Typecheck the patterns first, so that we get types for all the\n+        // bindings.\n+        for arm in arms {\n+            let pcx = PatCtxt {\n+                fcx: self,\n+                map: pat_id_map(&tcx.def_map, &arm.pats[0]),\n+            };\n+            for p in &arm.pats {\n+                pcx.check_pat(&p, discrim_ty);\n+            }\n         }\n-        self.check_expr_with_expectation(&arm.body, expected);\n-        let arm_ty = self.expr_ty(&arm.body);\n \n-        if result_ty.references_error() || arm_ty.references_error() {\n-            result_ty = tcx.types.err;\n-            continue;\n+        // Now typecheck the blocks.\n+        //\n+        // The result of the match is the common supertype of all the\n+        // arms. Start out the value as bottom, since it's the, well,\n+        // bottom the type lattice, and we'll be moving up the lattice as\n+        // we process each arm. (Note that any match with 0 arms is matching\n+        // on any empty type and is therefore unreachable; should the flow\n+        // of execution reach it, we will panic, so bottom is an appropriate\n+        // type in that case)\n+        let expected = expected.adjust_for_branches(self);\n+        let mut result_ty = self.next_diverging_ty_var();\n+        let coerce_first = match expected {\n+            // We don't coerce to `()` so that if the match expression is a\n+            // statement it's branches can have any consistent type. That allows\n+            // us to give better error messages (pointing to a usually better\n+            // arm for inconsistent arms or to the whole match when a `()` type\n+            // is required).\n+            Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => {\n+                ety\n+            }\n+            _ => result_ty\n+        };\n+        for (i, arm) in arms.iter().enumerate() {\n+            if let Some(ref e) = arm.guard {\n+                self.check_expr_has_type(e, tcx.types.bool);\n+            }\n+            self.check_expr_with_expectation(&arm.body, expected);\n+            let arm_ty = self.expr_ty(&arm.body);\n+\n+            if result_ty.references_error() || arm_ty.references_error() {\n+                result_ty = tcx.types.err;\n+                continue;\n+            }\n+\n+            // Handle the fallback arm of a desugared if-let like a missing else.\n+            let is_if_let_fallback = match match_src {\n+                hir::MatchSource::IfLetDesugar { contains_else_clause: false } => {\n+                    i == arms.len() - 1 && arm_ty.is_nil()\n+                }\n+                _ => false\n+            };\n+\n+            let origin = if is_if_let_fallback {\n+                TypeOrigin::IfExpressionWithNoElse(expr.span)\n+            } else {\n+                TypeOrigin::MatchExpressionArm(expr.span, arm.body.span, match_src)\n+            };\n+\n+            let result = if is_if_let_fallback {\n+                self.eq_types(true, origin, arm_ty, result_ty)\n+                    .map(|InferOk { obligations, .. }| {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        arm_ty\n+                    })\n+            } else if i == 0 {\n+                // Special-case the first arm, as it has no \"previous expressions\".\n+                self.try_coerce(&arm.body, coerce_first)\n+            } else {\n+                let prev_arms = || arms[..i].iter().map(|arm| &*arm.body);\n+                self.try_find_coercion_lub(origin, prev_arms, result_ty, &arm.body)\n+            };\n+\n+            result_ty = match result {\n+                Ok(ty) => ty,\n+                Err(e) => {\n+                    let (expected, found) = if is_if_let_fallback {\n+                        (arm_ty, result_ty)\n+                    } else {\n+                        (result_ty, arm_ty)\n+                    };\n+                    self.report_mismatched_types(origin, expected, found, e);\n+                    self.tcx.types.err\n+                }\n+            };\n         }\n \n-        // Handle the fallback arm of a desugared if-let like a missing else.\n-        let is_if_let_fallback = match match_src {\n-            hir::MatchSource::IfLetDesugar { contains_else_clause: false } => {\n-                i == arms.len() - 1 && arm_ty.is_nil()\n+        self.write_ty(expr.id, result_ty);\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n+    pub fn check_pat_struct(&self, pat: &'gcx hir::Pat,\n+                            path: &hir::Path, fields: &'gcx [Spanned<hir::FieldPat>],\n+                            etc: bool, expected: Ty<'tcx>) {\n+        let tcx = self.tcx;\n+\n+        let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n+        let variant = match self.def_struct_variant(def, path.span) {\n+            Some((_, variant)) => variant,\n+            None => {\n+                let name = pprust::path_to_string(path);\n+                span_err!(tcx.sess, pat.span, E0163,\n+                          \"`{}` does not name a struct or a struct variant\", name);\n+                self.write_error(pat.id);\n+\n+                for field in fields {\n+                    self.check_pat(&field.node.pat, tcx.types.err);\n+                }\n+                return;\n             }\n-            _ => false\n         };\n \n-        let origin = if is_if_let_fallback {\n-            TypeOrigin::IfExpressionWithNoElse(expr.span)\n-        } else {\n-            TypeOrigin::MatchExpressionArm(expr.span, arm.body.span, match_src)\n+        let pat_ty = self.instantiate_type(def.def_id(), path);\n+        let item_substs = match pat_ty.sty {\n+            ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n+            _ => span_bug!(pat.span, \"struct variant is not an ADT\")\n         };\n+        self.demand_eqtype(pat.span, expected, pat_ty);\n+        self.check_struct_pat_fields(pat.span, fields, variant, &item_substs, etc);\n \n-        let result = if is_if_let_fallback {\n-            self.eq_types(true, origin, arm_ty, result_ty)\n-                .map(|InferOk { obligations, .. }| {\n-                    // FIXME(#32730) propagate obligations\n-                    assert!(obligations.is_empty());\n-                    arm_ty\n-                })\n-        } else if i == 0 {\n-            // Special-case the first arm, as it has no \"previous expressions\".\n-            self.try_coerce(&arm.body, coerce_first)\n-        } else {\n-            let prev_arms = || arms[..i].iter().map(|arm| &*arm.body);\n-            self.try_find_coercion_lub(origin, prev_arms, result_ty, &arm.body)\n-        };\n+        self.write_ty(pat.id, pat_ty);\n+        self.write_substs(pat.id, ty::ItemSubsts {\n+            substs: item_substs\n+        });\n+    }\n \n-        result_ty = match result {\n-            Ok(ty) => ty,\n-            Err(e) => {\n-                let (expected, found) = if is_if_let_fallback {\n-                    (arm_ty, result_ty)\n-                } else {\n-                    (result_ty, arm_ty)\n-                };\n-                self.report_mismatched_types(origin, expected, found, e);\n-                self.tcx.types.err\n+    fn check_pat_enum(&self,\n+                      pat: &hir::Pat,\n+                      path: &hir::Path,\n+                      subpats: Option<&'gcx [P<hir::Pat>]>,\n+                      expected: Ty<'tcx>,\n+                      is_tuple_struct_pat: bool)\n+    {\n+        // Typecheck the path.\n+        let tcx = self.tcx;\n+\n+        let path_res = match tcx.def_map.borrow().get(&pat.id) {\n+            Some(&path_res) if path_res.base_def != Def::Err => path_res,\n+            _ => {\n+                self.set_tainted_by_errors();\n+                self.write_error(pat.id);\n+\n+                if let Some(subpats) = subpats {\n+                    for pat in subpats {\n+                        self.check_pat(&pat, tcx.types.err);\n+                    }\n+                }\n+\n+                return;\n             }\n         };\n-    }\n \n-    self.write_ty(expr.id, result_ty);\n-}\n-}\n+        let (opt_ty, segments, def) = match self.resolve_ty_and_def_ufcs(path_res,\n+                                                                         None, path,\n+                                                                         pat.span, pat.id) {\n+            Some(resolution) => resolution,\n+            // Error handling done inside resolve_ty_and_def_ufcs, so if\n+            // resolution fails just return.\n+            None => {return;}\n+        };\n \n-impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n-pub fn check_pat_struct(&self, pat: &'gcx hir::Pat,\n-                        path: &hir::Path, fields: &'gcx [Spanned<hir::FieldPat>],\n-                        etc: bool, expected: Ty<'tcx>) {\n-    let tcx = self.tcx;\n-\n-    let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-    let variant = match self.def_struct_variant(def, path.span) {\n-        Some((_, variant)) => variant,\n-        None => {\n-            let name = pprust::path_to_string(path);\n-            span_err!(tcx.sess, pat.span, E0163,\n-                      \"`{}` does not name a struct or a struct variant\", name);\n+        // Items that were partially resolved before should have been resolved to\n+        // associated constants (i.e. not methods).\n+        if path_res.depth != 0 && !self.check_assoc_item_is_const(def, pat.span) {\n             self.write_error(pat.id);\n-\n-            for field in fields {\n-                self.check_pat(&field.node.pat, tcx.types.err);\n-            }\n             return;\n         }\n-    };\n-\n-    let pat_ty = self.instantiate_type(def.def_id(), path);\n-    let item_substs = match pat_ty.sty {\n-        ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n-        _ => span_bug!(pat.span, \"struct variant is not an ADT\")\n-    };\n-    self.demand_eqtype(pat.span, expected, pat_ty);\n-    self.check_struct_pat_fields(pat.span, fields, variant, &item_substs, etc);\n-\n-    self.write_ty(pat.id, pat_ty);\n-    self.write_substs(pat.id, ty::ItemSubsts {\n-        substs: item_substs\n-    });\n-}\n \n-fn check_pat_enum(&self,\n-                  pat: &hir::Pat,\n-                  path: &hir::Path,\n-                  subpats: Option<&'gcx [P<hir::Pat>]>,\n-                  expected: Ty<'tcx>,\n-                  is_tuple_struct_pat: bool)\n-{\n-    // Typecheck the path.\n-    let tcx = self.tcx;\n-\n-    let path_res = match tcx.def_map.borrow().get(&pat.id) {\n-        Some(&path_res) if path_res.base_def != Def::Err => path_res,\n-        _ => {\n-            self.set_tainted_by_errors();\n-            self.write_error(pat.id);\n+        let enum_def = def.variant_def_ids()\n+            .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n+\n+        let ctor_scheme = tcx.lookup_item_type(enum_def);\n+        let ctor_predicates = tcx.lookup_predicates(enum_def);\n+        let path_scheme = if ctor_scheme.ty.is_fn() {\n+            let fn_ret = tcx.no_late_bound_regions(&ctor_scheme.ty.fn_ret()).unwrap();\n+            ty::TypeScheme {\n+                ty: fn_ret.unwrap(),\n+                generics: ctor_scheme.generics,\n+            }\n+        } else {\n+            ctor_scheme\n+        };\n+        self.instantiate_path(segments, path_scheme, &ctor_predicates,\n+                              opt_ty, def, pat.span, pat.id);\n \n+        let report_bad_struct_kind = |is_warning| {\n+            bad_struct_kind_err(tcx.sess, pat, path, is_warning);\n+            if is_warning { return; }\n+            self.write_error(pat.id);\n             if let Some(subpats) = subpats {\n                 for pat in subpats {\n                     self.check_pat(&pat, tcx.types.err);\n                 }\n             }\n+        };\n \n+        // If we didn't have a fully resolved path to start with, we had an\n+        // associated const, and we should quit now, since the rest of this\n+        // function uses checks specific to structs and enums.\n+        if path_res.depth != 0 {\n+            if is_tuple_struct_pat {\n+                report_bad_struct_kind(false);\n+            } else {\n+                let pat_ty = self.node_ty(pat.id);\n+                self.demand_suptype(pat.span, expected, pat_ty);\n+            }\n             return;\n         }\n-    };\n-\n-    let (opt_ty, segments, def) = match self.resolve_ty_and_def_ufcs(path_res,\n-                                                                     None, path,\n-                                                                     pat.span, pat.id) {\n-        Some(resolution) => resolution,\n-        // Error handling done inside resolve_ty_and_def_ufcs, so if\n-        // resolution fails just return.\n-        None => {return;}\n-    };\n-\n-    // Items that were partially resolved before should have been resolved to\n-    // associated constants (i.e. not methods).\n-    if path_res.depth != 0 && !self.check_assoc_item_is_const(def, pat.span) {\n-        self.write_error(pat.id);\n-        return;\n-    }\n \n-    let enum_def = def.variant_def_ids()\n-        .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n+        let pat_ty = self.node_ty(pat.id);\n+        self.demand_eqtype(pat.span, expected, pat_ty);\n \n-    let ctor_scheme = tcx.lookup_item_type(enum_def);\n-    let ctor_predicates = tcx.lookup_predicates(enum_def);\n-    let path_scheme = if ctor_scheme.ty.is_fn() {\n-        let fn_ret = tcx.no_late_bound_regions(&ctor_scheme.ty.fn_ret()).unwrap();\n-        ty::TypeScheme {\n-            ty: fn_ret.unwrap(),\n-            generics: ctor_scheme.generics,\n-        }\n-    } else {\n-        ctor_scheme\n-    };\n-    self.instantiate_path(segments, path_scheme, &ctor_predicates,\n-                          opt_ty, def, pat.span, pat.id);\n-\n-    let report_bad_struct_kind = |is_warning| {\n-        bad_struct_kind_err(tcx.sess, pat, path, is_warning);\n-        if is_warning { return; }\n-        self.write_error(pat.id);\n-        if let Some(subpats) = subpats {\n-            for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err);\n+        let real_path_ty = self.node_ty(pat.id);\n+        let (kind_name, variant, expected_substs) = match real_path_ty.sty {\n+            ty::TyEnum(enum_def, expected_substs) => {\n+                let variant = enum_def.variant_of_def(def);\n+                (\"variant\", variant, expected_substs)\n             }\n-        }\n-    };\n-\n-    // If we didn't have a fully resolved path to start with, we had an\n-    // associated const, and we should quit now, since the rest of this\n-    // function uses checks specific to structs and enums.\n-    if path_res.depth != 0 {\n-        if is_tuple_struct_pat {\n-            report_bad_struct_kind(false);\n-        } else {\n-            let pat_ty = self.node_ty(pat.id);\n-            self.demand_suptype(pat.span, expected, pat_ty);\n-        }\n-        return;\n-    }\n-\n-    let pat_ty = self.node_ty(pat.id);\n-    self.demand_eqtype(pat.span, expected, pat_ty);\n+            ty::TyStruct(struct_def, expected_substs) => {\n+                let variant = struct_def.struct_variant();\n+                (\"struct\", variant, expected_substs)\n+            }\n+            _ => {\n+                report_bad_struct_kind(false);\n+                return;\n+            }\n+        };\n \n-    let real_path_ty = self.node_ty(pat.id);\n-    let (kind_name, variant, expected_substs) = match real_path_ty.sty {\n-        ty::TyEnum(enum_def, expected_substs) => {\n-            let variant = enum_def.variant_of_def(def);\n-            (\"variant\", variant, expected_substs)\n-        }\n-        ty::TyStruct(struct_def, expected_substs) => {\n-            let variant = struct_def.struct_variant();\n-            (\"struct\", variant, expected_substs)\n-        }\n-        _ => {\n-            report_bad_struct_kind(false);\n-            return;\n+        match (is_tuple_struct_pat, variant.kind()) {\n+            (true, ty::VariantKind::Unit) => {\n+                // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n+                // is allowed for backward compatibility.\n+                report_bad_struct_kind(true);\n+            }\n+            (_, ty::VariantKind::Struct) => {\n+                report_bad_struct_kind(false);\n+                return\n+            }\n+            _ => {}\n         }\n-    };\n \n-    match (is_tuple_struct_pat, variant.kind()) {\n-        (true, ty::VariantKind::Unit) => {\n-            // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n-            // is allowed for backward compatibility.\n-            report_bad_struct_kind(true);\n-        }\n-        (_, ty::VariantKind::Struct) => {\n-            report_bad_struct_kind(false);\n-            return\n-        }\n-        _ => {}\n-    }\n-\n-    if let Some(subpats) = subpats {\n-        if subpats.len() == variant.fields.len() {\n-            for (subpat, field) in subpats.iter().zip(&variant.fields) {\n-                let field_ty = self.field_ty(subpat.span, field, expected_substs);\n-                self.check_pat(&subpat, field_ty);\n-            }\n-        } else if variant.fields.is_empty() {\n-            span_err!(tcx.sess, pat.span, E0024,\n-                      \"this pattern has {} field{}, but the corresponding {} has no fields\",\n-                      subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);\n+        if let Some(subpats) = subpats {\n+            if subpats.len() == variant.fields.len() {\n+                for (subpat, field) in subpats.iter().zip(&variant.fields) {\n+                    let field_ty = self.field_ty(subpat.span, field, expected_substs);\n+                    self.check_pat(&subpat, field_ty);\n+                }\n+            } else if variant.fields.is_empty() {\n+                span_err!(tcx.sess, pat.span, E0024,\n+                          \"this pattern has {} field{}, but the corresponding {} has no fields\",\n+                          subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);\n \n-            for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err);\n-            }\n-        } else {\n-            span_err!(tcx.sess, pat.span, E0023,\n-                      \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                      subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"},\n-                      kind_name,\n-                      variant.fields.len(), if variant.fields.len() == 1 {\"\"} else {\"s\"});\n+                for pat in subpats {\n+                    self.check_pat(&pat, tcx.types.err);\n+                }\n+            } else {\n+                span_err!(tcx.sess, pat.span, E0023,\n+                          \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n+                          subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"},\n+                          kind_name,\n+                          variant.fields.len(), if variant.fields.len() == 1 {\"\"} else {\"s\"});\n \n-            for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err);\n+                for pat in subpats {\n+                    self.check_pat(&pat, tcx.types.err);\n+                }\n             }\n         }\n     }\n-}\n \n-/// `path` is the AST path item naming the type of this struct.\n-/// `fields` is the field patterns of the struct pattern.\n-/// `struct_fields` describes the type of each field of the struct.\n-/// `struct_id` is the ID of the struct.\n-/// `etc` is true if the pattern said '...' and false otherwise.\n-pub fn check_struct_pat_fields(&self,\n-                               span: Span,\n-                               fields: &'gcx [Spanned<hir::FieldPat>],\n-                               variant: ty::VariantDef<'tcx>,\n-                               substs: &Substs<'tcx>,\n-                               etc: bool) {\n-    let tcx = self.tcx;\n-\n-    // Index the struct fields' types.\n-    let field_map = variant.fields\n-        .iter()\n-        .map(|field| (field.name, field))\n-        .collect::<FnvHashMap<_, _>>();\n-\n-    // Keep track of which fields have already appeared in the pattern.\n-    let mut used_fields = FnvHashMap();\n-\n-    // Typecheck each field.\n-    for &Spanned { node: ref field, span } in fields {\n-        let field_ty = match used_fields.entry(field.name) {\n-            Occupied(occupied) => {\n-                let mut err = struct_span_err!(tcx.sess, span, E0025,\n-                                               \"field `{}` bound multiple times in the pattern\",\n-                                               field.name);\n-                span_note!(&mut err, *occupied.get(),\n-                           \"field `{}` previously bound here\",\n-                           field.name);\n-                err.emit();\n-                tcx.types.err\n-            }\n-            Vacant(vacant) => {\n-                vacant.insert(span);\n-                field_map.get(&field.name)\n-                    .map(|f| self.field_ty(span, f, substs))\n-                    .unwrap_or_else(|| {\n-                        span_err!(tcx.sess, span, E0026,\n-                            \"struct `{}` does not have a field named `{}`\",\n-                            tcx.item_path_str(variant.did),\n-                            field.name);\n-                        tcx.types.err\n-                    })\n-            }\n-        };\n+    /// `path` is the AST path item naming the type of this struct.\n+    /// `fields` is the field patterns of the struct pattern.\n+    /// `struct_fields` describes the type of each field of the struct.\n+    /// `struct_id` is the ID of the struct.\n+    /// `etc` is true if the pattern said '...' and false otherwise.\n+    pub fn check_struct_pat_fields(&self,\n+                                   span: Span,\n+                                   fields: &'gcx [Spanned<hir::FieldPat>],\n+                                   variant: ty::VariantDef<'tcx>,\n+                                   substs: &Substs<'tcx>,\n+                                   etc: bool) {\n+        let tcx = self.tcx;\n+\n+        // Index the struct fields' types.\n+        let field_map = variant.fields\n+            .iter()\n+            .map(|field| (field.name, field))\n+            .collect::<FnvHashMap<_, _>>();\n+\n+        // Keep track of which fields have already appeared in the pattern.\n+        let mut used_fields = FnvHashMap();\n+\n+        // Typecheck each field.\n+        for &Spanned { node: ref field, span } in fields {\n+            let field_ty = match used_fields.entry(field.name) {\n+                Occupied(occupied) => {\n+                    let mut err = struct_span_err!(tcx.sess, span, E0025,\n+                                                   \"field `{}` bound multiple times \\\n+                                                    in the pattern\",\n+                                                   field.name);\n+                    span_note!(&mut err, *occupied.get(),\n+                               \"field `{}` previously bound here\",\n+                               field.name);\n+                    err.emit();\n+                    tcx.types.err\n+                }\n+                Vacant(vacant) => {\n+                    vacant.insert(span);\n+                    field_map.get(&field.name)\n+                        .map(|f| self.field_ty(span, f, substs))\n+                        .unwrap_or_else(|| {\n+                            span_err!(tcx.sess, span, E0026,\n+                                \"struct `{}` does not have a field named `{}`\",\n+                                tcx.item_path_str(variant.did),\n+                                field.name);\n+                            tcx.types.err\n+                        })\n+                }\n+            };\n \n-        self.check_pat(&field.pat, field_ty);\n-    }\n+            self.check_pat(&field.pat, field_ty);\n+        }\n \n-    // Report an error if not all the fields were specified.\n-    if !etc {\n-        for field in variant.fields\n-            .iter()\n-            .filter(|field| !used_fields.contains_key(&field.name)) {\n-            span_err!(tcx.sess, span, E0027,\n-                \"pattern does not mention field `{}`\",\n-                field.name);\n+        // Report an error if not all the fields were specified.\n+        if !etc {\n+            for field in variant.fields\n+                .iter()\n+                .filter(|field| !used_fields.contains_key(&field.name)) {\n+                span_err!(tcx.sess, span, E0027,\n+                    \"pattern does not mention field `{}`\",\n+                    field.name);\n+            }\n         }\n     }\n }\n-}"}, {"sha": "7493ca70f556711dda8017735426446b71f91fed", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 235, "deletions": 235, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -64,267 +64,267 @@ enum CallStep<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-pub fn check_call(&self,\n-                  call_expr: &'gcx hir::Expr,\n-                  callee_expr: &'gcx hir::Expr,\n-                  arg_exprs: &'gcx [P<hir::Expr>],\n-                  expected: Expectation<'tcx>)\n-{\n-    self.check_expr(callee_expr);\n-    let original_callee_ty = self.expr_ty(callee_expr);\n-    let (callee_ty, _, result) =\n-        self.autoderef(callee_expr.span,\n-                       original_callee_ty,\n-                       || Some(callee_expr),\n-                       UnresolvedTypeAction::Error,\n-                       LvaluePreference::NoPreference,\n-                       |adj_ty, idx| {\n-            self.try_overloaded_call_step(call_expr, callee_expr, adj_ty, idx)\n-    });\n-\n-    match result {\n-        None => {\n-            // this will report an error since original_callee_ty is not a fn\n-            self.confirm_builtin_call(call_expr, original_callee_ty, arg_exprs, expected);\n-        }\n+    pub fn check_call(&self,\n+                      call_expr: &'gcx hir::Expr,\n+                      callee_expr: &'gcx hir::Expr,\n+                      arg_exprs: &'gcx [P<hir::Expr>],\n+                      expected: Expectation<'tcx>)\n+    {\n+        self.check_expr(callee_expr);\n+        let original_callee_ty = self.expr_ty(callee_expr);\n+        let (callee_ty, _, result) =\n+            self.autoderef(callee_expr.span,\n+                           original_callee_ty,\n+                           || Some(callee_expr),\n+                           UnresolvedTypeAction::Error,\n+                           LvaluePreference::NoPreference,\n+                           |adj_ty, idx| {\n+                self.try_overloaded_call_step(call_expr, callee_expr, adj_ty, idx)\n+        });\n+\n+        match result {\n+            None => {\n+                // this will report an error since original_callee_ty is not a fn\n+                self.confirm_builtin_call(call_expr, original_callee_ty, arg_exprs, expected);\n+            }\n \n-        Some(CallStep::Builtin) => {\n-            self.confirm_builtin_call(call_expr, callee_ty, arg_exprs, expected);\n-        }\n+            Some(CallStep::Builtin) => {\n+                self.confirm_builtin_call(call_expr, callee_ty, arg_exprs, expected);\n+            }\n \n-        Some(CallStep::DeferredClosure(fn_sig)) => {\n-            self.confirm_deferred_closure_call(call_expr, arg_exprs, expected, fn_sig);\n-        }\n+            Some(CallStep::DeferredClosure(fn_sig)) => {\n+                self.confirm_deferred_closure_call(call_expr, arg_exprs, expected, fn_sig);\n+            }\n \n-        Some(CallStep::Overloaded(method_callee)) => {\n-            self.confirm_overloaded_call(call_expr, callee_expr,\n-                                         arg_exprs, expected, method_callee);\n+            Some(CallStep::Overloaded(method_callee)) => {\n+                self.confirm_overloaded_call(call_expr, callee_expr,\n+                                             arg_exprs, expected, method_callee);\n+            }\n         }\n     }\n-}\n \n-fn try_overloaded_call_step(&self,\n-                            call_expr: &'gcx hir::Expr,\n-                            callee_expr: &'gcx hir::Expr,\n-                            adjusted_ty: Ty<'tcx>,\n-                            autoderefs: usize)\n-                            -> Option<CallStep<'tcx>>\n-{\n-    debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?}, autoderefs={})\",\n-           call_expr,\n-           adjusted_ty,\n-           autoderefs);\n-\n-    // If the callee is a bare function or a closure, then we're all set.\n-    match self.structurally_resolved_type(callee_expr.span, adjusted_ty).sty {\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-            self.write_autoderef_adjustment(callee_expr.id, autoderefs);\n-            return Some(CallStep::Builtin);\n-        }\n+    fn try_overloaded_call_step(&self,\n+                                call_expr: &'gcx hir::Expr,\n+                                callee_expr: &'gcx hir::Expr,\n+                                adjusted_ty: Ty<'tcx>,\n+                                autoderefs: usize)\n+                                -> Option<CallStep<'tcx>>\n+    {\n+        debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?}, autoderefs={})\",\n+               call_expr,\n+               adjusted_ty,\n+               autoderefs);\n+\n+        // If the callee is a bare function or a closure, then we're all set.\n+        match self.structurally_resolved_type(callee_expr.span, adjusted_ty).sty {\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                self.write_autoderef_adjustment(callee_expr.id, autoderefs);\n+                return Some(CallStep::Builtin);\n+            }\n \n-        ty::TyClosure(def_id, substs) => {\n-            assert_eq!(def_id.krate, LOCAL_CRATE);\n-\n-            // Check whether this is a call to a closure where we\n-            // haven't yet decided on whether the closure is fn vs\n-            // fnmut vs fnonce. If so, we have to defer further processing.\n-            if self.closure_kind(def_id).is_none() {\n-                let closure_ty =\n-                    self.closure_type(def_id, substs);\n-                let fn_sig =\n-                    self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n-                                                                   infer::FnCall,\n-                                                                   &closure_ty.sig).0;\n-                self.record_deferred_call_resolution(def_id, Box::new(CallResolution {\n-                    call_expr: call_expr,\n-                    callee_expr: callee_expr,\n-                    adjusted_ty: adjusted_ty,\n-                    autoderefs: autoderefs,\n-                    fn_sig: fn_sig.clone(),\n-                    closure_def_id: def_id\n-                }));\n-                return Some(CallStep::DeferredClosure(fn_sig));\n+            ty::TyClosure(def_id, substs) => {\n+                assert_eq!(def_id.krate, LOCAL_CRATE);\n+\n+                // Check whether this is a call to a closure where we\n+                // haven't yet decided on whether the closure is fn vs\n+                // fnmut vs fnonce. If so, we have to defer further processing.\n+                if self.closure_kind(def_id).is_none() {\n+                    let closure_ty =\n+                        self.closure_type(def_id, substs);\n+                    let fn_sig =\n+                        self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n+                                                                       infer::FnCall,\n+                                                                       &closure_ty.sig).0;\n+                    self.record_deferred_call_resolution(def_id, Box::new(CallResolution {\n+                        call_expr: call_expr,\n+                        callee_expr: callee_expr,\n+                        adjusted_ty: adjusted_ty,\n+                        autoderefs: autoderefs,\n+                        fn_sig: fn_sig.clone(),\n+                        closure_def_id: def_id\n+                    }));\n+                    return Some(CallStep::DeferredClosure(fn_sig));\n+                }\n+            }\n+\n+            // Hack: we know that there are traits implementing Fn for &F\n+            // where F:Fn and so forth. In the particular case of types\n+            // like `x: &mut FnMut()`, if there is a call `x()`, we would\n+            // normally translate to `FnMut::call_mut(&mut x, ())`, but\n+            // that winds up requiring `mut x: &mut FnMut()`. A little\n+            // over the top. The simplest fix by far is to just ignore\n+            // this case and deref again, so we wind up with\n+            // `FnMut::call_mut(&mut *x, ())`.\n+            ty::TyRef(..) if autoderefs == 0 => {\n+                return None;\n             }\n-        }\n \n-        // Hack: we know that there are traits implementing Fn for &F\n-        // where F:Fn and so forth. In the particular case of types\n-        // like `x: &mut FnMut()`, if there is a call `x()`, we would\n-        // normally translate to `FnMut::call_mut(&mut x, ())`, but\n-        // that winds up requiring `mut x: &mut FnMut()`. A little\n-        // over the top. The simplest fix by far is to just ignore\n-        // this case and deref again, so we wind up with\n-        // `FnMut::call_mut(&mut *x, ())`.\n-        ty::TyRef(..) if autoderefs == 0 => {\n-            return None;\n+            _ => {}\n         }\n \n-        _ => {}\n+        self.try_overloaded_call_traits(call_expr, callee_expr, adjusted_ty, autoderefs)\n+            .map(|method_callee| CallStep::Overloaded(method_callee))\n     }\n \n-    self.try_overloaded_call_traits(call_expr, callee_expr, adjusted_ty, autoderefs)\n-        .map(|method_callee| CallStep::Overloaded(method_callee))\n-}\n-\n-fn try_overloaded_call_traits(&self,\n-                              call_expr: &hir::Expr,\n-                              callee_expr: &hir::Expr,\n-                              adjusted_ty: Ty<'tcx>,\n-                              autoderefs: usize)\n-                              -> Option<ty::MethodCallee<'tcx>>\n-{\n-    // Try the options that are least restrictive on the caller first.\n-    for &(opt_trait_def_id, method_name) in &[\n-        (self.tcx.lang_items.fn_trait(), token::intern(\"call\")),\n-        (self.tcx.lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n-        (self.tcx.lang_items.fn_once_trait(), token::intern(\"call_once\")),\n-    ] {\n-        let trait_def_id = match opt_trait_def_id {\n-            Some(def_id) => def_id,\n-            None => continue,\n-        };\n-\n-        match self.lookup_method_in_trait_adjusted(call_expr.span,\n-                                                   Some(&callee_expr),\n-                                                   method_name,\n-                                                   trait_def_id,\n-                                                   autoderefs,\n-                                                   false,\n-                                                   adjusted_ty,\n-                                                   None) {\n-            None => continue,\n-            Some(method_callee) => {\n-                return Some(method_callee);\n+    fn try_overloaded_call_traits(&self,\n+                                  call_expr: &hir::Expr,\n+                                  callee_expr: &hir::Expr,\n+                                  adjusted_ty: Ty<'tcx>,\n+                                  autoderefs: usize)\n+                                  -> Option<ty::MethodCallee<'tcx>>\n+    {\n+        // Try the options that are least restrictive on the caller first.\n+        for &(opt_trait_def_id, method_name) in &[\n+            (self.tcx.lang_items.fn_trait(), token::intern(\"call\")),\n+            (self.tcx.lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n+            (self.tcx.lang_items.fn_once_trait(), token::intern(\"call_once\")),\n+        ] {\n+            let trait_def_id = match opt_trait_def_id {\n+                Some(def_id) => def_id,\n+                None => continue,\n+            };\n+\n+            match self.lookup_method_in_trait_adjusted(call_expr.span,\n+                                                       Some(&callee_expr),\n+                                                       method_name,\n+                                                       trait_def_id,\n+                                                       autoderefs,\n+                                                       false,\n+                                                       adjusted_ty,\n+                                                       None) {\n+                None => continue,\n+                Some(method_callee) => {\n+                    return Some(method_callee);\n+                }\n             }\n         }\n-    }\n \n-    None\n-}\n+        None\n+    }\n \n-fn confirm_builtin_call(&self,\n-                        call_expr: &hir::Expr,\n-                        callee_ty: Ty<'tcx>,\n-                        arg_exprs: &'gcx [P<hir::Expr>],\n-                        expected: Expectation<'tcx>)\n-{\n-    let error_fn_sig;\n-\n-    let fn_sig = match callee_ty.sty {\n-        ty::TyFnDef(_, _, &ty::BareFnTy {ref sig, ..}) |\n-        ty::TyFnPtr(&ty::BareFnTy {ref sig, ..}) => {\n-            sig\n-        }\n-        _ => {\n-            let mut err = self.type_error_struct(call_expr.span, |actual| {\n-                format!(\"expected function, found `{}`\", actual)\n-            }, callee_ty, None);\n-\n-            if let hir::ExprCall(ref expr, _) = call_expr.node {\n-                let tcx = self.tcx;\n-                if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n-                    if pr.depth == 0 && pr.base_def != Def::Err {\n-                        if let Some(span) = tcx.map.span_if_local(pr.def_id()) {\n-                            err.span_note(span, \"defined here\");\n+    fn confirm_builtin_call(&self,\n+                            call_expr: &hir::Expr,\n+                            callee_ty: Ty<'tcx>,\n+                            arg_exprs: &'gcx [P<hir::Expr>],\n+                            expected: Expectation<'tcx>)\n+    {\n+        let error_fn_sig;\n+\n+        let fn_sig = match callee_ty.sty {\n+            ty::TyFnDef(_, _, &ty::BareFnTy {ref sig, ..}) |\n+            ty::TyFnPtr(&ty::BareFnTy {ref sig, ..}) => {\n+                sig\n+            }\n+            _ => {\n+                let mut err = self.type_error_struct(call_expr.span, |actual| {\n+                    format!(\"expected function, found `{}`\", actual)\n+                }, callee_ty, None);\n+\n+                if let hir::ExprCall(ref expr, _) = call_expr.node {\n+                    let tcx = self.tcx;\n+                    if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n+                        if pr.depth == 0 && pr.base_def != Def::Err {\n+                            if let Some(span) = tcx.map.span_if_local(pr.def_id()) {\n+                                err.span_note(span, \"defined here\");\n+                            }\n                         }\n                     }\n                 }\n-            }\n \n-            err.emit();\n+                err.emit();\n \n-            // This is the \"default\" function signature, used in case of error.\n-            // In that case, we check each argument against \"error\" in order to\n-            // set up all the node type bindings.\n-            error_fn_sig = ty::Binder(ty::FnSig {\n-                inputs: self.err_args(arg_exprs.len()),\n-                output: ty::FnConverging(self.tcx.types.err),\n-                variadic: false\n-            });\n+                // This is the \"default\" function signature, used in case of error.\n+                // In that case, we check each argument against \"error\" in order to\n+                // set up all the node type bindings.\n+                error_fn_sig = ty::Binder(ty::FnSig {\n+                    inputs: self.err_args(arg_exprs.len()),\n+                    output: ty::FnConverging(self.tcx.types.err),\n+                    variadic: false\n+                });\n \n-            &error_fn_sig\n-        }\n-    };\n-\n-    // Replace any late-bound regions that appear in the function\n-    // signature with region variables. We also have to\n-    // renormalize the associated types at this point, since they\n-    // previously appeared within a `Binder<>` and hence would not\n-    // have been normalized before.\n-    let fn_sig =\n-        self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n-                                                       infer::FnCall,\n-                                                       fn_sig).0;\n-    let fn_sig =\n-        self.normalize_associated_types_in(call_expr.span, &fn_sig);\n-\n-    // Call the generic checker.\n-    let expected_arg_tys = self.expected_types_for_fn_args(call_expr.span,\n-                                                           expected,\n-                                                           fn_sig.output,\n-                                                           &fn_sig.inputs);\n-    self.check_argument_types(call_expr.span,\n-                              &fn_sig.inputs,\n-                              &expected_arg_tys[..],\n-                              arg_exprs,\n-                              fn_sig.variadic,\n-                              TupleArgumentsFlag::DontTupleArguments);\n-\n-    self.write_call(call_expr, fn_sig.output);\n-}\n+                &error_fn_sig\n+            }\n+        };\n \n-fn confirm_deferred_closure_call(&self,\n-                                 call_expr: &hir::Expr,\n-                                 arg_exprs: &'gcx [P<hir::Expr>],\n-                                 expected: Expectation<'tcx>,\n-                                 fn_sig: ty::FnSig<'tcx>)\n-{\n-    // `fn_sig` is the *signature* of the cosure being called. We\n-    // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n-    // do know the types expected for each argument and the return\n-    // type.\n-\n-    let expected_arg_tys =\n-        self.expected_types_for_fn_args(call_expr.span,\n-                                        expected,\n-                                        fn_sig.output.clone(),\n-                                        &fn_sig.inputs);\n-\n-    self.check_argument_types(call_expr.span,\n-                              &fn_sig.inputs,\n-                              &expected_arg_tys,\n-                              arg_exprs,\n-                              fn_sig.variadic,\n-                              TupleArgumentsFlag::TupleArguments);\n-\n-    self.write_call(call_expr, fn_sig.output);\n-}\n+        // Replace any late-bound regions that appear in the function\n+        // signature with region variables. We also have to\n+        // renormalize the associated types at this point, since they\n+        // previously appeared within a `Binder<>` and hence would not\n+        // have been normalized before.\n+        let fn_sig =\n+            self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n+                                                           infer::FnCall,\n+                                                           fn_sig).0;\n+        let fn_sig =\n+            self.normalize_associated_types_in(call_expr.span, &fn_sig);\n+\n+        // Call the generic checker.\n+        let expected_arg_tys = self.expected_types_for_fn_args(call_expr.span,\n+                                                               expected,\n+                                                               fn_sig.output,\n+                                                               &fn_sig.inputs);\n+        self.check_argument_types(call_expr.span,\n+                                  &fn_sig.inputs,\n+                                  &expected_arg_tys[..],\n+                                  arg_exprs,\n+                                  fn_sig.variadic,\n+                                  TupleArgumentsFlag::DontTupleArguments);\n+\n+        self.write_call(call_expr, fn_sig.output);\n+    }\n \n-fn confirm_overloaded_call(&self,\n-                           call_expr: &hir::Expr,\n-                           callee_expr: &'gcx hir::Expr,\n-                           arg_exprs: &'gcx [P<hir::Expr>],\n-                           expected: Expectation<'tcx>,\n-                           method_callee: ty::MethodCallee<'tcx>)\n-{\n-    let output_type =\n-        self.check_method_argument_types(call_expr.span,\n-                                         method_callee.ty,\n-                                         callee_expr,\n-                                         arg_exprs,\n-                                         TupleArgumentsFlag::TupleArguments,\n-                                         expected);\n-    self.write_call(call_expr, output_type);\n-\n-    self.write_overloaded_call_method_map(call_expr, method_callee);\n-}\n+    fn confirm_deferred_closure_call(&self,\n+                                     call_expr: &hir::Expr,\n+                                     arg_exprs: &'gcx [P<hir::Expr>],\n+                                     expected: Expectation<'tcx>,\n+                                     fn_sig: ty::FnSig<'tcx>)\n+    {\n+        // `fn_sig` is the *signature* of the cosure being called. We\n+        // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n+        // do know the types expected for each argument and the return\n+        // type.\n+\n+        let expected_arg_tys =\n+            self.expected_types_for_fn_args(call_expr.span,\n+                                            expected,\n+                                            fn_sig.output.clone(),\n+                                            &fn_sig.inputs);\n+\n+        self.check_argument_types(call_expr.span,\n+                                  &fn_sig.inputs,\n+                                  &expected_arg_tys,\n+                                  arg_exprs,\n+                                  fn_sig.variadic,\n+                                  TupleArgumentsFlag::TupleArguments);\n+\n+        self.write_call(call_expr, fn_sig.output);\n+    }\n \n-fn write_overloaded_call_method_map(&self,\n-                                    call_expr: &hir::Expr,\n-                                    method_callee: ty::MethodCallee<'tcx>) {\n-    let method_call = ty::MethodCall::expr(call_expr.id);\n-    self.tables.borrow_mut().method_map.insert(method_call, method_callee);\n-}\n+    fn confirm_overloaded_call(&self,\n+                               call_expr: &hir::Expr,\n+                               callee_expr: &'gcx hir::Expr,\n+                               arg_exprs: &'gcx [P<hir::Expr>],\n+                               expected: Expectation<'tcx>,\n+                               method_callee: ty::MethodCallee<'tcx>)\n+    {\n+        let output_type =\n+            self.check_method_argument_types(call_expr.span,\n+                                             method_callee.ty,\n+                                             callee_expr,\n+                                             arg_exprs,\n+                                             TupleArgumentsFlag::TupleArguments,\n+                                             expected);\n+        self.write_call(call_expr, output_type);\n+\n+        self.write_overloaded_call_method_map(call_expr, method_callee);\n+    }\n+\n+    fn write_overloaded_call_method_map(&self,\n+                                        call_expr: &hir::Expr,\n+                                        method_callee: ty::MethodCallee<'tcx>) {\n+        let method_call = ty::MethodCall::expr(call_expr.id);\n+        self.tables.borrow_mut().method_map.insert(method_call, method_callee);\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "690250edb8cb457ea76f30ac66e56b0ae90437a1", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -73,26 +73,26 @@ enum UnsizeKind<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-/// Returns the kind of unsize information of t, or None\n-/// if t is sized or it is unknown.\n-fn unsize_kind(&self, t: Ty<'tcx>) -> Option<UnsizeKind<'tcx>> {\n-    match t.sty {\n-        ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n-        ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal_def_id())),\n-        ty::TyStruct(def, substs) => {\n-            // FIXME(arielb1): do some kind of normalization\n-            match def.struct_variant().fields.last() {\n-                None => None,\n-                Some(f) => self.unsize_kind(f.ty(self.tcx, substs))\n+    /// Returns the kind of unsize information of t, or None\n+    /// if t is sized or it is unknown.\n+    fn unsize_kind(&self, t: Ty<'tcx>) -> Option<UnsizeKind<'tcx>> {\n+        match t.sty {\n+            ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n+            ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal_def_id())),\n+            ty::TyStruct(def, substs) => {\n+                // FIXME(arielb1): do some kind of normalization\n+                match def.struct_variant().fields.last() {\n+                    None => None,\n+                    Some(f) => self.unsize_kind(f.ty(self.tcx, substs))\n+                }\n             }\n+            // We should really try to normalize here.\n+            ty::TyProjection(ref pi) => Some(UnsizeKind::OfProjection(pi)),\n+            ty::TyParam(ref p) => Some(UnsizeKind::OfParam(p)),\n+            _ => None\n         }\n-        // We should really try to normalize here.\n-        ty::TyProjection(ref pi) => Some(UnsizeKind::OfProjection(pi)),\n-        ty::TyParam(ref p) => Some(UnsizeKind::OfParam(p)),\n-        _ => None\n     }\n }\n-}\n \n #[derive(Copy, Clone)]\n enum CastError {"}, {"sha": "d3396eb4c1baf480236e9298302cda45101628ac", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 205, "deletions": 205, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -20,227 +20,227 @@ use syntax::abi::Abi;\n use rustc::hir;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-pub fn check_expr_closure(&self,\n-                          expr: &hir::Expr,\n-                          _capture: hir::CaptureClause,\n-                          decl: &'gcx hir::FnDecl,\n-                          body: &'gcx hir::Block,\n-                          expected: Expectation<'tcx>) {\n-    debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n-           expr,\n-           expected);\n-\n-    // It's always helpful for inference if we know the kind of\n-    // closure sooner rather than later, so first examine the expected\n-    // type, and see if can glean a closure kind from there.\n-    let (expected_sig,expected_kind) = match expected.to_option(self) {\n-        Some(ty) => self.deduce_expectations_from_expected_type(ty),\n-        None => (None, None)\n-    };\n-    self.check_closure(expr, expected_kind, decl, body, expected_sig)\n-}\n-\n-fn check_closure(&self,\n-                 expr: &hir::Expr,\n-                 opt_kind: Option<ty::ClosureKind>,\n-                 decl: &'gcx hir::FnDecl,\n-                 body: &'gcx hir::Block,\n-                 expected_sig: Option<ty::FnSig<'tcx>>) {\n-    let expr_def_id = self.tcx.map.local_def_id(expr.id);\n-\n-    debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n-           opt_kind,\n-           expected_sig);\n-\n-    let mut fn_ty = AstConv::ty_of_closure(self,\n-                                           hir::Unsafety::Normal,\n-                                           decl,\n-                                           Abi::RustCall,\n-                                           expected_sig);\n-\n-    // Create type variables (for now) to represent the transformed\n-    // types of upvars. These will be unified during the upvar\n-    // inference phase (`upvar.rs`).\n-    let num_upvars = self.tcx.with_freevars(expr.id, |fv| fv.len());\n-    let upvar_tys = self.next_ty_vars(num_upvars);\n-\n-    debug!(\"check_closure: expr.id={:?} upvar_tys={:?}\",\n-           expr.id, upvar_tys);\n-\n-    let closure_type = self.tcx.mk_closure(expr_def_id,\n-        self.parameter_environment.free_substs,\n-        upvar_tys);\n-\n-    self.write_ty(expr.id, closure_type);\n-\n-    let fn_sig = self.tcx.liberate_late_bound_regions(\n-        self.tcx.region_maps.call_site_extent(expr.id, body.id), &fn_ty.sig);\n-\n-    check_fn(self, hir::Unsafety::Normal, expr.id, &fn_sig, decl, expr.id, &body);\n-\n-    // Tuple up the arguments and insert the resulting function type into\n-    // the `closures` table.\n-    fn_ty.sig.0.inputs = vec![self.tcx.mk_tup(fn_ty.sig.0.inputs)];\n-\n-    debug!(\"closure for {:?} --> sig={:?} opt_kind={:?}\",\n-           expr_def_id,\n-           fn_ty.sig,\n-           opt_kind);\n-\n-    self.tables.borrow_mut().closure_tys.insert(expr_def_id, fn_ty);\n-    match opt_kind {\n-        Some(kind) => { self.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind); }\n-        None => { }\n+    pub fn check_expr_closure(&self,\n+                              expr: &hir::Expr,\n+                              _capture: hir::CaptureClause,\n+                              decl: &'gcx hir::FnDecl,\n+                              body: &'gcx hir::Block,\n+                              expected: Expectation<'tcx>) {\n+        debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n+               expr,\n+               expected);\n+\n+        // It's always helpful for inference if we know the kind of\n+        // closure sooner rather than later, so first examine the expected\n+        // type, and see if can glean a closure kind from there.\n+        let (expected_sig,expected_kind) = match expected.to_option(self) {\n+            Some(ty) => self.deduce_expectations_from_expected_type(ty),\n+            None => (None, None)\n+        };\n+        self.check_closure(expr, expected_kind, decl, body, expected_sig)\n     }\n-}\n \n-fn deduce_expectations_from_expected_type(&self, expected_ty: Ty<'tcx>)\n-    -> (Option<ty::FnSig<'tcx>>,Option<ty::ClosureKind>)\n-{\n-    debug!(\"deduce_expectations_from_expected_type(expected_ty={:?})\",\n-           expected_ty);\n-\n-    match expected_ty.sty {\n-        ty::TyTrait(ref object_type) => {\n-            let proj_bounds = object_type.projection_bounds_with_self_ty(self.tcx,\n-                                                                         self.tcx.types.err);\n-            let sig = proj_bounds.iter()\n-                                 .filter_map(|pb| self.deduce_sig_from_projection(pb))\n-                                 .next();\n-            let kind = self.tcx.lang_items.fn_trait_kind(object_type.principal_def_id());\n-            (sig, kind)\n+    fn check_closure(&self,\n+                     expr: &hir::Expr,\n+                     opt_kind: Option<ty::ClosureKind>,\n+                     decl: &'gcx hir::FnDecl,\n+                     body: &'gcx hir::Block,\n+                     expected_sig: Option<ty::FnSig<'tcx>>) {\n+        let expr_def_id = self.tcx.map.local_def_id(expr.id);\n+\n+        debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n+               opt_kind,\n+               expected_sig);\n+\n+        let mut fn_ty = AstConv::ty_of_closure(self,\n+                                               hir::Unsafety::Normal,\n+                                               decl,\n+                                               Abi::RustCall,\n+                                               expected_sig);\n+\n+        // Create type variables (for now) to represent the transformed\n+        // types of upvars. These will be unified during the upvar\n+        // inference phase (`upvar.rs`).\n+        let num_upvars = self.tcx.with_freevars(expr.id, |fv| fv.len());\n+        let upvar_tys = self.next_ty_vars(num_upvars);\n+\n+        debug!(\"check_closure: expr.id={:?} upvar_tys={:?}\",\n+               expr.id, upvar_tys);\n+\n+        let closure_type = self.tcx.mk_closure(expr_def_id,\n+            self.parameter_environment.free_substs,\n+            upvar_tys);\n+\n+        self.write_ty(expr.id, closure_type);\n+\n+        let fn_sig = self.tcx.liberate_late_bound_regions(\n+            self.tcx.region_maps.call_site_extent(expr.id, body.id), &fn_ty.sig);\n+\n+        check_fn(self, hir::Unsafety::Normal, expr.id, &fn_sig, decl, expr.id, &body);\n+\n+        // Tuple up the arguments and insert the resulting function type into\n+        // the `closures` table.\n+        fn_ty.sig.0.inputs = vec![self.tcx.mk_tup(fn_ty.sig.0.inputs)];\n+\n+        debug!(\"closure for {:?} --> sig={:?} opt_kind={:?}\",\n+               expr_def_id,\n+               fn_ty.sig,\n+               opt_kind);\n+\n+        self.tables.borrow_mut().closure_tys.insert(expr_def_id, fn_ty);\n+        match opt_kind {\n+            Some(kind) => { self.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind); }\n+            None => { }\n         }\n-        ty::TyInfer(ty::TyVar(vid)) => {\n-            self.deduce_expectations_from_obligations(vid)\n-        }\n-        _ => {\n-            (None, None)\n+    }\n+\n+    fn deduce_expectations_from_expected_type(&self, expected_ty: Ty<'tcx>)\n+        -> (Option<ty::FnSig<'tcx>>,Option<ty::ClosureKind>)\n+    {\n+        debug!(\"deduce_expectations_from_expected_type(expected_ty={:?})\",\n+               expected_ty);\n+\n+        match expected_ty.sty {\n+            ty::TyTrait(ref object_type) => {\n+                let proj_bounds = object_type.projection_bounds_with_self_ty(self.tcx,\n+                                                                             self.tcx.types.err);\n+                let sig = proj_bounds.iter()\n+                                     .filter_map(|pb| self.deduce_sig_from_projection(pb))\n+                                     .next();\n+                let kind = self.tcx.lang_items.fn_trait_kind(object_type.principal_def_id());\n+                (sig, kind)\n+            }\n+            ty::TyInfer(ty::TyVar(vid)) => {\n+                self.deduce_expectations_from_obligations(vid)\n+            }\n+            _ => {\n+                (None, None)\n+            }\n         }\n     }\n-}\n \n-fn deduce_expectations_from_obligations(&self, expected_vid: ty::TyVid)\n-    -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>)\n-{\n-    let fulfillment_cx = self.fulfillment_cx.borrow();\n-    // Here `expected_ty` is known to be a type inference variable.\n-\n-    let expected_sig =\n-        fulfillment_cx\n-        .pending_obligations()\n-        .iter()\n-        .map(|obligation| &obligation.obligation)\n-        .filter_map(|obligation| {\n-            debug!(\"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n-                   obligation.predicate);\n-\n-            match obligation.predicate {\n-                // Given a Projection predicate, we can potentially infer\n-                // the complete signature.\n-                ty::Predicate::Projection(ref proj_predicate) => {\n-                    let trait_ref = proj_predicate.to_poly_trait_ref();\n-                    self.self_type_matches_expected_vid(trait_ref, expected_vid)\n-                        .and_then(|_| self.deduce_sig_from_projection(proj_predicate))\n+    fn deduce_expectations_from_obligations(&self, expected_vid: ty::TyVid)\n+        -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>)\n+    {\n+        let fulfillment_cx = self.fulfillment_cx.borrow();\n+        // Here `expected_ty` is known to be a type inference variable.\n+\n+        let expected_sig =\n+            fulfillment_cx\n+            .pending_obligations()\n+            .iter()\n+            .map(|obligation| &obligation.obligation)\n+            .filter_map(|obligation| {\n+                debug!(\"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n+                       obligation.predicate);\n+\n+                match obligation.predicate {\n+                    // Given a Projection predicate, we can potentially infer\n+                    // the complete signature.\n+                    ty::Predicate::Projection(ref proj_predicate) => {\n+                        let trait_ref = proj_predicate.to_poly_trait_ref();\n+                        self.self_type_matches_expected_vid(trait_ref, expected_vid)\n+                            .and_then(|_| self.deduce_sig_from_projection(proj_predicate))\n+                    }\n+                    _ => {\n+                        None\n+                    }\n                 }\n-                _ => {\n-                    None\n-                }\n-            }\n-        })\n-        .next();\n-\n-    // Even if we can't infer the full signature, we may be able to\n-    // infer the kind. This can occur if there is a trait-reference\n-    // like `F : Fn<A>`. Note that due to subtyping we could encounter\n-    // many viable options, so pick the most restrictive.\n-    let expected_kind =\n-        fulfillment_cx\n-        .pending_obligations()\n-        .iter()\n-        .map(|obligation| &obligation.obligation)\n-        .filter_map(|obligation| {\n-            let opt_trait_ref = match obligation.predicate {\n-                ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref()),\n-                ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n-                ty::Predicate::Equate(..) => None,\n-                ty::Predicate::RegionOutlives(..) => None,\n-                ty::Predicate::TypeOutlives(..) => None,\n-                ty::Predicate::WellFormed(..) => None,\n-                ty::Predicate::ObjectSafe(..) => None,\n-                ty::Predicate::Rfc1592(..) => None,\n-\n-                // NB: This predicate is created by breaking down a\n-                // `ClosureType: FnFoo()` predicate, where\n-                // `ClosureType` represents some `TyClosure`. It can't\n-                // possibly be referring to the current closure,\n-                // because we haven't produced the `TyClosure` for\n-                // this closure yet; this is exactly why the other\n-                // code is looking for a self type of a unresolved\n-                // inference variable.\n-                ty::Predicate::ClosureKind(..) => None,\n-            };\n-            opt_trait_ref\n-                .and_then(|trait_ref| self.self_type_matches_expected_vid(trait_ref, expected_vid))\n-                .and_then(|trait_ref| self.tcx.lang_items.fn_trait_kind(trait_ref.def_id()))\n-        })\n-        .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n-\n-    (expected_sig, expected_kind)\n-}\n+            })\n+            .next();\n+\n+        // Even if we can't infer the full signature, we may be able to\n+        // infer the kind. This can occur if there is a trait-reference\n+        // like `F : Fn<A>`. Note that due to subtyping we could encounter\n+        // many viable options, so pick the most restrictive.\n+        let expected_kind =\n+            fulfillment_cx\n+            .pending_obligations()\n+            .iter()\n+            .map(|obligation| &obligation.obligation)\n+            .filter_map(|obligation| {\n+                let opt_trait_ref = match obligation.predicate {\n+                    ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref()),\n+                    ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n+                    ty::Predicate::Equate(..) => None,\n+                    ty::Predicate::RegionOutlives(..) => None,\n+                    ty::Predicate::TypeOutlives(..) => None,\n+                    ty::Predicate::WellFormed(..) => None,\n+                    ty::Predicate::ObjectSafe(..) => None,\n+                    ty::Predicate::Rfc1592(..) => None,\n+\n+                    // NB: This predicate is created by breaking down a\n+                    // `ClosureType: FnFoo()` predicate, where\n+                    // `ClosureType` represents some `TyClosure`. It can't\n+                    // possibly be referring to the current closure,\n+                    // because we haven't produced the `TyClosure` for\n+                    // this closure yet; this is exactly why the other\n+                    // code is looking for a self type of a unresolved\n+                    // inference variable.\n+                    ty::Predicate::ClosureKind(..) => None,\n+                };\n+                opt_trait_ref\n+                    .and_then(|tr| self.self_type_matches_expected_vid(tr, expected_vid))\n+                    .and_then(|tr| self.tcx.lang_items.fn_trait_kind(tr.def_id()))\n+            })\n+            .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n+\n+        (expected_sig, expected_kind)\n+    }\n \n-/// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n-/// everything we need to know about a closure.\n-fn deduce_sig_from_projection(&self,\n-    projection: &ty::PolyProjectionPredicate<'tcx>)\n-    -> Option<ty::FnSig<'tcx>>\n-{\n-    let tcx = self.tcx;\n+    /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n+    /// everything we need to know about a closure.\n+    fn deduce_sig_from_projection(&self,\n+        projection: &ty::PolyProjectionPredicate<'tcx>)\n+        -> Option<ty::FnSig<'tcx>>\n+    {\n+        let tcx = self.tcx;\n \n-    debug!(\"deduce_sig_from_projection({:?})\",\n-           projection);\n+        debug!(\"deduce_sig_from_projection({:?})\",\n+               projection);\n \n-    let trait_ref = projection.to_poly_trait_ref();\n+        let trait_ref = projection.to_poly_trait_ref();\n \n-    if tcx.lang_items.fn_trait_kind(trait_ref.def_id()).is_none() {\n-        return None;\n-    }\n+        if tcx.lang_items.fn_trait_kind(trait_ref.def_id()).is_none() {\n+            return None;\n+        }\n \n-    let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n-    let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n-    debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n+        let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n+        let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n+        debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n \n-    let input_tys = match arg_param_ty.sty {\n-        ty::TyTuple(tys) => tys.to_vec(),\n-        _ => { return None; }\n-    };\n-    debug!(\"deduce_sig_from_projection: input_tys {:?}\", input_tys);\n+        let input_tys = match arg_param_ty.sty {\n+            ty::TyTuple(tys) => tys.to_vec(),\n+            _ => { return None; }\n+        };\n+        debug!(\"deduce_sig_from_projection: input_tys {:?}\", input_tys);\n \n-    let ret_param_ty = projection.0.ty;\n-    let ret_param_ty = self.resolve_type_vars_if_possible(&ret_param_ty);\n-    debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\", ret_param_ty);\n+        let ret_param_ty = projection.0.ty;\n+        let ret_param_ty = self.resolve_type_vars_if_possible(&ret_param_ty);\n+        debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\", ret_param_ty);\n \n-    let fn_sig = ty::FnSig {\n-        inputs: input_tys,\n-        output: ty::FnConverging(ret_param_ty),\n-        variadic: false\n-    };\n-    debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);\n+        let fn_sig = ty::FnSig {\n+            inputs: input_tys,\n+            output: ty::FnConverging(ret_param_ty),\n+            variadic: false\n+        };\n+        debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);\n \n-    Some(fn_sig)\n-}\n+        Some(fn_sig)\n+    }\n \n-fn self_type_matches_expected_vid(&self,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-    expected_vid: ty::TyVid)\n-    -> Option<ty::PolyTraitRef<'tcx>>\n-{\n-    let self_ty = self.shallow_resolve(trait_ref.self_ty());\n-    debug!(\"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n-           trait_ref,\n-           self_ty);\n-    match self_ty.sty {\n-        ty::TyInfer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n-        _ => None,\n+    fn self_type_matches_expected_vid(&self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        expected_vid: ty::TyVid)\n+        -> Option<ty::PolyTraitRef<'tcx>>\n+    {\n+        let self_ty = self.shallow_resolve(trait_ref.self_ty());\n+        debug!(\"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n+               trait_ref,\n+               self_ty);\n+        match self_ty.sty {\n+            ty::TyInfer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n+            _ => None,\n+        }\n     }\n }\n-}"}, {"sha": "4861ab15e2c0147f1b39ccb9fdab5fb3ed38b6d8", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 137, "deletions": 137, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -618,167 +618,167 @@ fn apply<'a, 'b, 'gcx, 'tcx, E, I>(coerce: &mut Coerce<'a, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-/// Attempt to coerce an expression to a type, and return the\n-/// adjusted type of the expression, if successful.\n-/// Adjustments are only recorded if the coercion succeeded.\n-/// The expressions *must not* have any pre-existing adjustments.\n-pub fn try_coerce(&self,\n-                  expr: &hir::Expr,\n-                  target: Ty<'tcx>)\n-                  -> RelateResult<'tcx, Ty<'tcx>> {\n-    let source = self.resolve_type_vars_with_obligations(self.expr_ty(expr));\n-    debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n-\n-    let mut coerce = Coerce::new(self, TypeOrigin::ExprAssignable(expr.span));\n-    self.commit_if_ok(|_| {\n-        let (ty, adjustment) =\n-            apply(&mut coerce, &|| Some(expr), source, target)?;\n-        if !adjustment.is_identity() {\n-            debug!(\"Success, coerced with {:?}\", adjustment);\n-            assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n-            self.write_adjustment(expr.id, adjustment);\n-        }\n-        Ok(ty)\n-    })\n-}\n-\n-/// Given some expressions, their known unified type and another expression,\n-/// tries to unify the types, potentially inserting coercions on any of the\n-/// provided expressions and returns their LUB (aka \"common supertype\").\n-pub fn try_find_coercion_lub<'b, E, I>(&self,\n-                                       origin: TypeOrigin,\n-                                       exprs: E,\n-                                       prev_ty: Ty<'tcx>,\n-                                       new: &'b hir::Expr)\n-                                       -> RelateResult<'tcx, Ty<'tcx>>\n-    // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n-    where E: Fn() -> I,\n-          I: IntoIterator<Item=&'b hir::Expr> {\n-\n-    let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n-    let new_ty = self.resolve_type_vars_with_obligations(self.expr_ty(new));\n-    debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n-\n-    let trace = TypeTrace::types(origin, true, prev_ty, new_ty);\n-\n-    // Special-case that coercion alone cannot handle:\n-    // Two function item types of differing IDs or Substs.\n-    match (&prev_ty.sty, &new_ty.sty) {\n-        (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n-         &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n-            // The signature must always match.\n-            let fty = self.lub(true, trace.clone(), &a_fty, &b_fty)\n-                .map(|InferOk { value, obligations }| {\n-                    // FIXME(#32730) propagate obligations\n-                    assert!(obligations.is_empty());\n-                    value\n-                })?;\n-\n-            if a_def_id == b_def_id {\n-                // Same function, maybe the parameters match.\n-                let substs = self.commit_if_ok(|_| {\n-                    self.lub(true, trace.clone(), &a_substs, &b_substs)\n-                        .map(|InferOk { value, obligations }| {\n-                            // FIXME(#32730) propagate obligations\n-                            assert!(obligations.is_empty());\n-                            value\n-                        })\n-                });\n-\n-                if let Ok(substs) = substs {\n-                    // We have a LUB of prev_ty and new_ty, just return it.\n-                    return Ok(self.tcx.mk_fn_def(a_def_id, substs, fty));\n-                }\n-            }\n+    /// Attempt to coerce an expression to a type, and return the\n+    /// adjusted type of the expression, if successful.\n+    /// Adjustments are only recorded if the coercion succeeded.\n+    /// The expressions *must not* have any pre-existing adjustments.\n+    pub fn try_coerce(&self,\n+                      expr: &hir::Expr,\n+                      target: Ty<'tcx>)\n+                      -> RelateResult<'tcx, Ty<'tcx>> {\n+        let source = self.resolve_type_vars_with_obligations(self.expr_ty(expr));\n+        debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n-            // Reify both sides and return the reified fn pointer type.\n-            for expr in exprs().into_iter().chain(Some(new)) {\n-                // No adjustments can produce a fn item, so this should never trip.\n+        let mut coerce = Coerce::new(self, TypeOrigin::ExprAssignable(expr.span));\n+        self.commit_if_ok(|_| {\n+            let (ty, adjustment) =\n+                apply(&mut coerce, &|| Some(expr), source, target)?;\n+            if !adjustment.is_identity() {\n+                debug!(\"Success, coerced with {:?}\", adjustment);\n                 assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n-                self.write_adjustment(expr.id, AdjustReifyFnPointer);\n+                self.write_adjustment(expr.id, adjustment);\n             }\n-            return Ok(self.tcx.mk_fn_ptr(fty));\n-        }\n-        _ => {}\n+            Ok(ty)\n+        })\n     }\n \n-    let mut coerce = Coerce::new(self, origin);\n-    coerce.use_lub = true;\n+    /// Given some expressions, their known unified type and another expression,\n+    /// tries to unify the types, potentially inserting coercions on any of the\n+    /// provided expressions and returns their LUB (aka \"common supertype\").\n+    pub fn try_find_coercion_lub<'b, E, I>(&self,\n+                                           origin: TypeOrigin,\n+                                           exprs: E,\n+                                           prev_ty: Ty<'tcx>,\n+                                           new: &'b hir::Expr)\n+                                           -> RelateResult<'tcx, Ty<'tcx>>\n+        // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n+        where E: Fn() -> I,\n+              I: IntoIterator<Item=&'b hir::Expr> {\n \n-    // First try to coerce the new expression to the type of the previous ones,\n-    // but only if the new expression has no coercion already applied to it.\n-    let mut first_error = None;\n-    if !self.tables.borrow().adjustments.contains_key(&new.id) {\n-        let result = self.commit_if_ok(|_| {\n-            apply(&mut coerce, &|| Some(new), new_ty, prev_ty)\n-        });\n-        match result {\n-            Ok((ty, adjustment)) => {\n-                if !adjustment.is_identity() {\n-                    self.write_adjustment(new.id, adjustment);\n-                }\n-                return Ok(ty);\n-            }\n-            Err(e) => first_error = Some(e)\n-        }\n-    }\n+        let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n+        let new_ty = self.resolve_type_vars_with_obligations(self.expr_ty(new));\n+        debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n \n-    // Then try to coerce the previous expressions to the type of the new one.\n-    // This requires ensuring there are no coercions applied to *any* of the\n-    // previous expressions, other than noop reborrows (ignoring lifetimes).\n-    for expr in exprs() {\n-        let noop = match self.tables.borrow().adjustments.get(&expr.id) {\n-            Some(&AdjustDerefRef(AutoDerefRef {\n-                autoderefs: 1,\n-                autoref: Some(AutoPtr(_, mutbl_adj)),\n-                unsize: None\n-            })) => match self.expr_ty(expr).sty {\n-                ty::TyRef(_, mt_orig) => {\n-                    // Reborrow that we can safely ignore.\n-                    mutbl_adj == mt_orig.mutbl\n-                }\n-                _ => false\n-            },\n-            Some(_) => false,\n-            None => true\n-        };\n+        let trace = TypeTrace::types(origin, true, prev_ty, new_ty);\n \n-        if !noop {\n-            return self.commit_if_ok(|_| {\n-                self.lub(true, trace.clone(), &prev_ty, &new_ty)\n+        // Special-case that coercion alone cannot handle:\n+        // Two function item types of differing IDs or Substs.\n+        match (&prev_ty.sty, &new_ty.sty) {\n+            (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n+             &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n+                // The signature must always match.\n+                let fty = self.lub(true, trace.clone(), &a_fty, &b_fty)\n                     .map(|InferOk { value, obligations }| {\n                         // FIXME(#32730) propagate obligations\n                         assert!(obligations.is_empty());\n                         value\n-                    })\n+                    })?;\n+\n+                if a_def_id == b_def_id {\n+                    // Same function, maybe the parameters match.\n+                    let substs = self.commit_if_ok(|_| {\n+                        self.lub(true, trace.clone(), &a_substs, &b_substs)\n+                            .map(|InferOk { value, obligations }| {\n+                                // FIXME(#32730) propagate obligations\n+                                assert!(obligations.is_empty());\n+                                value\n+                            })\n+                    });\n+\n+                    if let Ok(substs) = substs {\n+                        // We have a LUB of prev_ty and new_ty, just return it.\n+                        return Ok(self.tcx.mk_fn_def(a_def_id, substs, fty));\n+                    }\n+                }\n+\n+                // Reify both sides and return the reified fn pointer type.\n+                for expr in exprs().into_iter().chain(Some(new)) {\n+                    // No adjustments can produce a fn item, so this should never trip.\n+                    assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n+                    self.write_adjustment(expr.id, AdjustReifyFnPointer);\n+                }\n+                return Ok(self.tcx.mk_fn_ptr(fty));\n+            }\n+            _ => {}\n+        }\n+\n+        let mut coerce = Coerce::new(self, origin);\n+        coerce.use_lub = true;\n+\n+        // First try to coerce the new expression to the type of the previous ones,\n+        // but only if the new expression has no coercion already applied to it.\n+        let mut first_error = None;\n+        if !self.tables.borrow().adjustments.contains_key(&new.id) {\n+            let result = self.commit_if_ok(|_| {\n+                apply(&mut coerce, &|| Some(new), new_ty, prev_ty)\n             });\n+            match result {\n+                Ok((ty, adjustment)) => {\n+                    if !adjustment.is_identity() {\n+                        self.write_adjustment(new.id, adjustment);\n+                    }\n+                    return Ok(ty);\n+                }\n+                Err(e) => first_error = Some(e)\n+            }\n         }\n-    }\n \n-    match self.commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n-        Err(_) => {\n-            // Avoid giving strange errors on failed attempts.\n-            if let Some(e) = first_error {\n-                Err(e)\n-            } else {\n-                self.commit_if_ok(|_| {\n-                    self.lub(true, trace, &prev_ty, &new_ty)\n+        // Then try to coerce the previous expressions to the type of the new one.\n+        // This requires ensuring there are no coercions applied to *any* of the\n+        // previous expressions, other than noop reborrows (ignoring lifetimes).\n+        for expr in exprs() {\n+            let noop = match self.tables.borrow().adjustments.get(&expr.id) {\n+                Some(&AdjustDerefRef(AutoDerefRef {\n+                    autoderefs: 1,\n+                    autoref: Some(AutoPtr(_, mutbl_adj)),\n+                    unsize: None\n+                })) => match self.expr_ty(expr).sty {\n+                    ty::TyRef(_, mt_orig) => {\n+                        // Reborrow that we can safely ignore.\n+                        mutbl_adj == mt_orig.mutbl\n+                    }\n+                    _ => false\n+                },\n+                Some(_) => false,\n+                None => true\n+            };\n+\n+            if !noop {\n+                return self.commit_if_ok(|_| {\n+                    self.lub(true, trace.clone(), &prev_ty, &new_ty)\n                         .map(|InferOk { value, obligations }| {\n                             // FIXME(#32730) propagate obligations\n                             assert!(obligations.is_empty());\n                             value\n                         })\n-                })\n+                });\n             }\n         }\n-        Ok((ty, adjustment)) => {\n-            if !adjustment.is_identity() {\n-                for expr in exprs() {\n-                    self.write_adjustment(expr.id, adjustment);\n+\n+        match self.commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n+            Err(_) => {\n+                // Avoid giving strange errors on failed attempts.\n+                if let Some(e) = first_error {\n+                    Err(e)\n+                } else {\n+                    self.commit_if_ok(|_| {\n+                        self.lub(true, trace, &prev_ty, &new_ty)\n+                            .map(|InferOk { value, obligations }| {\n+                                // FIXME(#32730) propagate obligations\n+                                assert!(obligations.is_empty());\n+                                value\n+                            })\n+                    })\n                 }\n             }\n-            Ok(ty)\n+            Ok((ty, adjustment)) => {\n+                if !adjustment.is_identity() {\n+                    for expr in exprs() {\n+                        self.write_adjustment(expr.id, adjustment);\n+                    }\n+                }\n+                Ok(ty)\n+            }\n         }\n     }\n }\n-}"}, {"sha": "7c8eb62b0e749e8998b3360492fe6b6509298a64", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -17,53 +17,53 @@ use syntax::codemap::Span;\n use rustc::hir;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-// Requires that the two types unify, and prints an error message if\n-// they don't.\n-pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-    let origin = TypeOrigin::Misc(sp);\n-    match self.sub_types(false, origin, actual, expected) {\n-        Ok(InferOk { obligations, .. }) => {\n-            // FIXME(#32730) propagate obligations\n-            assert!(obligations.is_empty());\n-        },\n-        Err(e) => {\n-            self.report_mismatched_types(origin, expected, actual, e);\n+    // Requires that the two types unify, and prints an error message if\n+    // they don't.\n+    pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n+        let origin = TypeOrigin::Misc(sp);\n+        match self.sub_types(false, origin, actual, expected) {\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            },\n+            Err(e) => {\n+                self.report_mismatched_types(origin, expected, actual, e);\n+            }\n         }\n     }\n-}\n \n-pub fn demand_eqtype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-    let origin = TypeOrigin::Misc(sp);\n-    match self.eq_types(false, origin, actual, expected) {\n-        Ok(InferOk { obligations, .. }) => {\n-            // FIXME(#32730) propagate obligations\n-            assert!(obligations.is_empty());\n-        },\n-        Err(e) => {\n-            self.report_mismatched_types(origin, expected, actual, e);\n+    pub fn demand_eqtype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n+        let origin = TypeOrigin::Misc(sp);\n+        match self.eq_types(false, origin, actual, expected) {\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            },\n+            Err(e) => {\n+                self.report_mismatched_types(origin, expected, actual, e);\n+            }\n         }\n     }\n-}\n \n-// Checks that the type of `expr` can be coerced to `expected`.\n-pub fn demand_coerce(&self, expr: &hir::Expr, expected: Ty<'tcx>) {\n-    let expected = self.resolve_type_vars_with_obligations(expected);\n-    if let Err(e) = self.try_coerce(expr, expected) {\n-        let origin = TypeOrigin::Misc(expr.span);\n-        let expr_ty = self.resolve_type_vars_with_obligations(self.expr_ty(expr));\n-        self.report_mismatched_types(origin, expected, expr_ty, e);\n+    // Checks that the type of `expr` can be coerced to `expected`.\n+    pub fn demand_coerce(&self, expr: &hir::Expr, expected: Ty<'tcx>) {\n+        let expected = self.resolve_type_vars_with_obligations(expected);\n+        if let Err(e) = self.try_coerce(expr, expected) {\n+            let origin = TypeOrigin::Misc(expr.span);\n+            let expr_ty = self.resolve_type_vars_with_obligations(self.expr_ty(expr));\n+            self.report_mismatched_types(origin, expected, expr_ty, e);\n+        }\n     }\n-}\n \n-pub fn require_same_types(&self, span: Span, t1: Ty<'tcx>, t2: Ty<'tcx>, msg: &str)\n-                          -> bool {\n-    if let Err(err) = self.eq_types(false, TypeOrigin::Misc(span), t1, t2) {\n-        let found_ty = self.resolve_type_vars_if_possible(&t1);\n-        let expected_ty = self.resolve_type_vars_if_possible(&t2);\n-        ::emit_type_err(self.tcx, span, found_ty, expected_ty, &err, msg);\n-        false\n-    } else {\n-        true\n+    pub fn require_same_types(&self, span: Span, t1: Ty<'tcx>, t2: Ty<'tcx>, msg: &str)\n+                              -> bool {\n+        if let Err(err) = self.eq_types(false, TypeOrigin::Misc(span), t1, t2) {\n+            let found_ty = self.resolve_type_vars_if_possible(&t1);\n+            let expected_ty = self.resolve_type_vars_if_possible(&t2);\n+            ::emit_type_err(self.tcx, span, found_ty, expected_ty, &err, msg);\n+            false\n+        } else {\n+            true\n+        }\n     }\n }\n-}"}, {"sha": "6faf6f415c266b5eff11705f0dbbcf5a17af3bde", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -53,23 +53,23 @@ struct InstantiatedMethodSig<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-pub fn confirm_method(&self,\n-                      span: Span,\n-                      self_expr: &'gcx hir::Expr,\n-                      call_expr: &'gcx hir::Expr,\n-                      unadjusted_self_ty: Ty<'tcx>,\n-                      pick: probe::Pick<'tcx>,\n-                      supplied_method_types: Vec<Ty<'tcx>>)\n-                      -> ty::MethodCallee<'tcx>\n-{\n-    debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, supplied_method_types={:?})\",\n-           unadjusted_self_ty,\n-           pick,\n-           supplied_method_types);\n-\n-    let mut confirm_cx = ConfirmContext::new(self, span, self_expr, call_expr);\n-    confirm_cx.confirm(unadjusted_self_ty, pick, supplied_method_types)\n-}\n+    pub fn confirm_method(&self,\n+                          span: Span,\n+                          self_expr: &'gcx hir::Expr,\n+                          call_expr: &'gcx hir::Expr,\n+                          unadjusted_self_ty: Ty<'tcx>,\n+                          pick: probe::Pick<'tcx>,\n+                          supplied_method_types: Vec<Ty<'tcx>>)\n+                          -> ty::MethodCallee<'tcx>\n+    {\n+        debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, supplied_method_types={:?})\",\n+               unadjusted_self_ty,\n+               pick,\n+               supplied_method_types);\n+\n+        let mut confirm_cx = ConfirmContext::new(self, span, self_expr, call_expr);\n+        confirm_cx.confirm(unadjusted_self_ty, pick, supplied_method_types)\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {"}, {"sha": "f27ae181f77e33cd9d23b19a46691e060beb989e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 283, "deletions": 280, "changes": 563, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -79,311 +79,314 @@ pub enum CandidateSource {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-/// Determines whether the type `self_ty` supports a method name `method_name` or not.\n-pub fn method_exists(&self,\n-                     span: Span,\n-                     method_name: ast::Name,\n-                     self_ty: ty::Ty<'tcx>,\n-                     call_expr_id: ast::NodeId)\n-                     -> bool\n-{\n-    let mode = probe::Mode::MethodCall;\n-    match self.probe_method(span, mode, method_name, self_ty, call_expr_id) {\n-        Ok(..) => true,\n-        Err(NoMatch(..)) => false,\n-        Err(Ambiguity(..)) => true,\n-        Err(ClosureAmbiguity(..)) => true,\n-        Err(PrivateMatch(..)) => true,\n+    /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n+    pub fn method_exists(&self,\n+                         span: Span,\n+                         method_name: ast::Name,\n+                         self_ty: ty::Ty<'tcx>,\n+                         call_expr_id: ast::NodeId)\n+                         -> bool\n+    {\n+        let mode = probe::Mode::MethodCall;\n+        match self.probe_method(span, mode, method_name, self_ty, call_expr_id) {\n+            Ok(..) => true,\n+            Err(NoMatch(..)) => false,\n+            Err(Ambiguity(..)) => true,\n+            Err(ClosureAmbiguity(..)) => true,\n+            Err(PrivateMatch(..)) => true,\n+        }\n     }\n-}\n \n-/// Performs method lookup. If lookup is successful, it will return the callee and store an\n-/// appropriate adjustment for the self-expr. In some cases it may report an error (e.g., invoking\n-/// the `drop` method).\n-///\n-/// # Arguments\n-///\n-/// Given a method call like `foo.bar::<T1,...Tn>(...)`:\n-///\n-/// * `fcx`:                   the surrounding `FnCtxt` (!)\n-/// * `span`:                  the span for the method call\n-/// * `method_name`:           the name of the method being called (`bar`)\n-/// * `self_ty`:               the (unadjusted) type of the self expression (`foo`)\n-/// * `supplied_method_types`: the explicit method type parameters, if any (`T1..Tn`)\n-/// * `self_expr`:             the self expression (`foo`)\n-pub fn lookup_method(&self,\n-                     span: Span,\n-                     method_name: ast::Name,\n-                     self_ty: ty::Ty<'tcx>,\n-                     supplied_method_types: Vec<ty::Ty<'tcx>>,\n-                     call_expr: &'gcx hir::Expr,\n-                     self_expr: &'gcx hir::Expr)\n-                     -> Result<ty::MethodCallee<'tcx>, MethodError<'tcx>>\n-{\n-    debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n-           method_name,\n-           self_ty,\n-           call_expr,\n-           self_expr);\n-\n-    let mode = probe::Mode::MethodCall;\n-    let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n-    let pick = self.probe_method(span, mode, method_name, self_ty, call_expr.id)?;\n-\n-    if let Some(import_id) = pick.import_id {\n-        self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n-    }\n+    /// Performs method lookup. If lookup is successful, it will return the callee\n+    /// and store an appropriate adjustment for the self-expr. In some cases it may\n+    /// report an error (e.g., invoking the `drop` method).\n+    ///\n+    /// # Arguments\n+    ///\n+    /// Given a method call like `foo.bar::<T1,...Tn>(...)`:\n+    ///\n+    /// * `fcx`:                   the surrounding `FnCtxt` (!)\n+    /// * `span`:                  the span for the method call\n+    /// * `method_name`:           the name of the method being called (`bar`)\n+    /// * `self_ty`:               the (unadjusted) type of the self expression (`foo`)\n+    /// * `supplied_method_types`: the explicit method type parameters, if any (`T1..Tn`)\n+    /// * `self_expr`:             the self expression (`foo`)\n+    pub fn lookup_method(&self,\n+                         span: Span,\n+                         method_name: ast::Name,\n+                         self_ty: ty::Ty<'tcx>,\n+                         supplied_method_types: Vec<ty::Ty<'tcx>>,\n+                         call_expr: &'gcx hir::Expr,\n+                         self_expr: &'gcx hir::Expr)\n+                         -> Result<ty::MethodCallee<'tcx>, MethodError<'tcx>>\n+    {\n+        debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n+               method_name,\n+               self_ty,\n+               call_expr,\n+               self_expr);\n+\n+        let mode = probe::Mode::MethodCall;\n+        let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n+        let pick = self.probe_method(span, mode, method_name, self_ty, call_expr.id)?;\n+\n+        if let Some(import_id) = pick.import_id {\n+            self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n+        }\n \n-    Ok(self.confirm_method(span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n-}\n+        Ok(self.confirm_method(span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n+    }\n \n-pub fn lookup_method_in_trait(&self,\n-                              span: Span,\n-                              self_expr: Option<&hir::Expr>,\n-                              m_name: ast::Name,\n-                              trait_def_id: DefId,\n-                              self_ty: ty::Ty<'tcx>,\n-                              opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                              -> Option<ty::MethodCallee<'tcx>>\n-{\n-    self.lookup_method_in_trait_adjusted(span, self_expr, m_name, trait_def_id,\n-                                         0, false, self_ty, opt_input_types)\n-}\n+    pub fn lookup_method_in_trait(&self,\n+                                  span: Span,\n+                                  self_expr: Option<&hir::Expr>,\n+                                  m_name: ast::Name,\n+                                  trait_def_id: DefId,\n+                                  self_ty: ty::Ty<'tcx>,\n+                                  opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n+                                  -> Option<ty::MethodCallee<'tcx>>\n+    {\n+        self.lookup_method_in_trait_adjusted(span, self_expr, m_name, trait_def_id,\n+                                             0, false, self_ty, opt_input_types)\n+    }\n \n-/// `lookup_in_trait_adjusted` is used for overloaded operators. It does a very narrow slice of\n-/// what the normal probe/confirm path does. In particular, it doesn't really do any probing: it\n-/// simply constructs an obligation for a particular trait with the given self-type and checks\n-/// whether that trait is implemented.\n-///\n-/// FIXME(#18741) -- It seems likely that we can consolidate some of this code with the other\n-/// method-lookup code. In particular, autoderef on index is basically identical to autoderef with\n-/// normal probes, except that the test also looks for built-in indexing. Also, the second half of\n-/// this method is basically the same as confirmation.\n-pub fn lookup_method_in_trait_adjusted(&self,\n-                                       span: Span,\n-                                       self_expr: Option<&hir::Expr>,\n-                                       m_name: ast::Name,\n-                                       trait_def_id: DefId,\n-                                       autoderefs: usize,\n-                                       unsize: bool,\n-                                       self_ty: ty::Ty<'tcx>,\n-                                       opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                                       -> Option<ty::MethodCallee<'tcx>>\n-{\n-    debug!(\"lookup_in_trait_adjusted(self_ty={:?}, self_expr={:?}, m_name={}, trait_def_id={:?})\",\n-           self_ty,\n-           self_expr,\n-           m_name,\n-           trait_def_id);\n-\n-    let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n-\n-    let type_parameter_defs = trait_def.generics.types.get_slice(subst::TypeSpace);\n-    let expected_number_of_input_types = type_parameter_defs.len();\n-\n-    assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n-    assert!(trait_def.generics.regions.is_empty());\n-\n-    // Construct a trait-reference `self_ty : Trait<input_tys>`\n-    let mut substs = subst::Substs::new_trait(Vec::new(), Vec::new(), self_ty);\n-\n-    match opt_input_types {\n-        Some(input_types) => {\n-            assert_eq!(expected_number_of_input_types, input_types.len());\n-            substs.types.replace(subst::ParamSpace::TypeSpace, input_types);\n-        }\n+    /// `lookup_in_trait_adjusted` is used for overloaded operators.\n+    /// It does a very narrow slice of what the normal probe/confirm path does.\n+    /// In particular, it doesn't really do any probing: it simply constructs\n+    /// an obligation for aparticular trait with the given self-type and checks\n+    /// whether that trait is implemented.\n+    ///\n+    /// FIXME(#18741) -- It seems likely that we can consolidate some of this\n+    /// code with the other method-lookup code. In particular, autoderef on\n+    /// index is basically identical to autoderef with normal probes, except\n+    /// that the test also looks for built-in indexing. Also, the second half of\n+    /// this method is basically the same as confirmation.\n+    pub fn lookup_method_in_trait_adjusted(&self,\n+                                           span: Span,\n+                                           self_expr: Option<&hir::Expr>,\n+                                           m_name: ast::Name,\n+                                           trait_def_id: DefId,\n+                                           autoderefs: usize,\n+                                           unsize: bool,\n+                                           self_ty: ty::Ty<'tcx>,\n+                                           opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n+                                           -> Option<ty::MethodCallee<'tcx>>\n+    {\n+        debug!(\"lookup_in_trait_adjusted(self_ty={:?}, self_expr={:?}, \\\n+                m_name={}, trait_def_id={:?})\",\n+               self_ty,\n+               self_expr,\n+               m_name,\n+               trait_def_id);\n+\n+        let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n+\n+        let type_parameter_defs = trait_def.generics.types.get_slice(subst::TypeSpace);\n+        let expected_number_of_input_types = type_parameter_defs.len();\n+\n+        assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n+        assert!(trait_def.generics.regions.is_empty());\n+\n+        // Construct a trait-reference `self_ty : Trait<input_tys>`\n+        let mut substs = subst::Substs::new_trait(Vec::new(), Vec::new(), self_ty);\n+\n+        match opt_input_types {\n+            Some(input_types) => {\n+                assert_eq!(expected_number_of_input_types, input_types.len());\n+                substs.types.replace(subst::ParamSpace::TypeSpace, input_types);\n+            }\n \n-        None => {\n-            self.type_vars_for_defs(\n-                span,\n-                subst::ParamSpace::TypeSpace,\n-                &mut substs,\n-                type_parameter_defs);\n+            None => {\n+                self.type_vars_for_defs(\n+                    span,\n+                    subst::ParamSpace::TypeSpace,\n+                    &mut substs,\n+                    type_parameter_defs);\n+            }\n         }\n-    }\n \n-    let trait_ref = ty::TraitRef::new(trait_def_id, self.tcx.mk_substs(substs));\n+        let trait_ref = ty::TraitRef::new(trait_def_id, self.tcx.mk_substs(substs));\n \n-    // Construct an obligation\n-    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-    let obligation = traits::Obligation::misc(span,\n-                                              self.body_id,\n-                                              poly_trait_ref.to_predicate());\n+        // Construct an obligation\n+        let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+        let obligation = traits::Obligation::misc(span,\n+                                                  self.body_id,\n+                                                  poly_trait_ref.to_predicate());\n \n-    // Now we want to know if this can be matched\n-    let mut selcx = traits::SelectionContext::new(self);\n-    if !selcx.evaluate_obligation(&obligation) {\n-        debug!(\"--> Cannot match obligation\");\n-        return None; // Cannot be matched, no such method resolution is possible.\n-    }\n-\n-    // Trait must have a method named `m_name` and it should not have\n-    // type parameters or early-bound regions.\n-    let tcx = self.tcx;\n-    let method_item = self.trait_item(trait_def_id, m_name).unwrap();\n-    let method_ty = method_item.as_opt_method().unwrap();\n-    assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n-    assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n-\n-    debug!(\"lookup_in_trait_adjusted: method_item={:?} method_ty={:?}\",\n-           method_item, method_ty);\n-\n-    // Instantiate late-bound regions and substitute the trait\n-    // parameters into the method type to get the actual method type.\n-    //\n-    // NB: Instantiate late-bound regions first so that\n-    // `instantiate_type_scheme` can normalize associated types that\n-    // may reference those regions.\n-    let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n-                                                                infer::FnCall,\n-                                                                &method_ty.fty.sig).0;\n-    let fn_sig = self.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n-    let transformed_self_ty = fn_sig.inputs[0];\n-    let def_id = method_item.def_id();\n-    let fty = tcx.mk_fn_def(def_id, trait_ref.substs,\n-                            tcx.mk_bare_fn(ty::BareFnTy {\n-        sig: ty::Binder(fn_sig),\n-        unsafety: method_ty.fty.unsafety,\n-        abi: method_ty.fty.abi.clone(),\n-    }));\n-\n-    debug!(\"lookup_in_trait_adjusted: matched method fty={:?} obligation={:?}\",\n-           fty,\n-           obligation);\n-\n-    // Register obligations for the parameters.  This will include the\n-    // `Self` parameter, which in turn has a bound of the main trait,\n-    // so this also effectively registers `obligation` as well.  (We\n-    // used to register `obligation` explicitly, but that resulted in\n-    // double error messages being reported.)\n-    //\n-    // Note that as the method comes from a trait, it should not have\n-    // any late-bound regions appearing in its bounds.\n-    let method_bounds = self.instantiate_bounds(span, trait_ref.substs, &method_ty.predicates);\n-    assert!(!method_bounds.has_escaping_regions());\n-    self.add_obligations_for_parameters(\n-        traits::ObligationCause::misc(span, self.body_id),\n-        &method_bounds);\n-\n-    // Also register an obligation for the method type being well-formed.\n-    self.register_wf_obligation(fty, span, traits::MiscObligation);\n-\n-    // FIXME(#18653) -- Try to resolve obligations, giving us more\n-    // typing information, which can sometimes be needed to avoid\n-    // pathological region inference failures.\n-    self.select_obligations_where_possible();\n-\n-    // Insert any adjustments needed (always an autoref of some mutability).\n-    match self_expr {\n-        None => { }\n-\n-        Some(self_expr) => {\n-            debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n-                   (self-id={}, autoderefs={}, unsize={}, explicit_self={:?})\",\n-                   self_expr.id, autoderefs, unsize,\n-                   method_ty.explicit_self);\n-\n-            match method_ty.explicit_self {\n-                ty::ExplicitSelfCategory::ByValue => {\n-                    // Trait method is fn(self), no transformation needed.\n-                    assert!(!unsize);\n-                    self.write_autoderef_adjustment(self_expr.id, autoderefs);\n-                }\n+        // Now we want to know if this can be matched\n+        let mut selcx = traits::SelectionContext::new(self);\n+        if !selcx.evaluate_obligation(&obligation) {\n+            debug!(\"--> Cannot match obligation\");\n+            return None; // Cannot be matched, no such method resolution is possible.\n+        }\n \n-                ty::ExplicitSelfCategory::ByReference(..) => {\n-                    // Trait method is fn(&self) or fn(&mut self), need an\n-                    // autoref. Pull the region etc out of the type of first argument.\n-                    match transformed_self_ty.sty {\n-                        ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ }) => {\n-                            self.write_adjustment(self_expr.id,\n-                                AdjustDerefRef(AutoDerefRef {\n-                                    autoderefs: autoderefs,\n-                                    autoref: Some(AutoPtr(region, mutbl)),\n-                                    unsize: if unsize {\n-                                        Some(transformed_self_ty)\n-                                    } else {\n-                                        None\n-                                    }\n-                                }));\n-                        }\n+        // Trait must have a method named `m_name` and it should not have\n+        // type parameters or early-bound regions.\n+        let tcx = self.tcx;\n+        let method_item = self.trait_item(trait_def_id, m_name).unwrap();\n+        let method_ty = method_item.as_opt_method().unwrap();\n+        assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n+        assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n+\n+        debug!(\"lookup_in_trait_adjusted: method_item={:?} method_ty={:?}\",\n+               method_item, method_ty);\n+\n+        // Instantiate late-bound regions and substitute the trait\n+        // parameters into the method type to get the actual method type.\n+        //\n+        // NB: Instantiate late-bound regions first so that\n+        // `instantiate_type_scheme` can normalize associated types that\n+        // may reference those regions.\n+        let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n+                                                                    infer::FnCall,\n+                                                                    &method_ty.fty.sig).0;\n+        let fn_sig = self.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n+        let transformed_self_ty = fn_sig.inputs[0];\n+        let def_id = method_item.def_id();\n+        let fty = tcx.mk_fn_def(def_id, trait_ref.substs,\n+                                tcx.mk_bare_fn(ty::BareFnTy {\n+            sig: ty::Binder(fn_sig),\n+            unsafety: method_ty.fty.unsafety,\n+            abi: method_ty.fty.abi.clone(),\n+        }));\n+\n+        debug!(\"lookup_in_trait_adjusted: matched method fty={:?} obligation={:?}\",\n+               fty,\n+               obligation);\n+\n+        // Register obligations for the parameters.  This will include the\n+        // `Self` parameter, which in turn has a bound of the main trait,\n+        // so this also effectively registers `obligation` as well.  (We\n+        // used to register `obligation` explicitly, but that resulted in\n+        // double error messages being reported.)\n+        //\n+        // Note that as the method comes from a trait, it should not have\n+        // any late-bound regions appearing in its bounds.\n+        let method_bounds = self.instantiate_bounds(span, trait_ref.substs, &method_ty.predicates);\n+        assert!(!method_bounds.has_escaping_regions());\n+        self.add_obligations_for_parameters(\n+            traits::ObligationCause::misc(span, self.body_id),\n+            &method_bounds);\n+\n+        // Also register an obligation for the method type being well-formed.\n+        self.register_wf_obligation(fty, span, traits::MiscObligation);\n+\n+        // FIXME(#18653) -- Try to resolve obligations, giving us more\n+        // typing information, which can sometimes be needed to avoid\n+        // pathological region inference failures.\n+        self.select_obligations_where_possible();\n+\n+        // Insert any adjustments needed (always an autoref of some mutability).\n+        match self_expr {\n+            None => { }\n+\n+            Some(self_expr) => {\n+                debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n+                       (self-id={}, autoderefs={}, unsize={}, explicit_self={:?})\",\n+                       self_expr.id, autoderefs, unsize,\n+                       method_ty.explicit_self);\n+\n+                match method_ty.explicit_self {\n+                    ty::ExplicitSelfCategory::ByValue => {\n+                        // Trait method is fn(self), no transformation needed.\n+                        assert!(!unsize);\n+                        self.write_autoderef_adjustment(self_expr.id, autoderefs);\n+                    }\n \n-                        _ => {\n-                            span_bug!(\n-                                span,\n-                                \"trait method is &self but first arg is: {}\",\n-                                transformed_self_ty);\n+                    ty::ExplicitSelfCategory::ByReference(..) => {\n+                        // Trait method is fn(&self) or fn(&mut self), need an\n+                        // autoref. Pull the region etc out of the type of first argument.\n+                        match transformed_self_ty.sty {\n+                            ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ }) => {\n+                                self.write_adjustment(self_expr.id,\n+                                    AdjustDerefRef(AutoDerefRef {\n+                                        autoderefs: autoderefs,\n+                                        autoref: Some(AutoPtr(region, mutbl)),\n+                                        unsize: if unsize {\n+                                            Some(transformed_self_ty)\n+                                        } else {\n+                                            None\n+                                        }\n+                                    }));\n+                            }\n+\n+                            _ => {\n+                                span_bug!(\n+                                    span,\n+                                    \"trait method is &self but first arg is: {}\",\n+                                    transformed_self_ty);\n+                            }\n                         }\n                     }\n-                }\n \n-                _ => {\n-                    span_bug!(\n-                        span,\n-                        \"unexpected explicit self type in operator method: {:?}\",\n-                        method_ty.explicit_self);\n+                    _ => {\n+                        span_bug!(\n+                            span,\n+                            \"unexpected explicit self type in operator method: {:?}\",\n+                            method_ty.explicit_self);\n+                    }\n                 }\n             }\n         }\n-    }\n-\n-    let callee = ty::MethodCallee {\n-        def_id: def_id,\n-        ty: fty,\n-        substs: trait_ref.substs\n-    };\n \n-    debug!(\"callee = {:?}\", callee);\n+        let callee = ty::MethodCallee {\n+            def_id: def_id,\n+            ty: fty,\n+            substs: trait_ref.substs\n+        };\n \n-    Some(callee)\n-}\n+        debug!(\"callee = {:?}\", callee);\n \n-pub fn resolve_ufcs(&self,\n-                    span: Span,\n-                    method_name: ast::Name,\n-                    self_ty: ty::Ty<'tcx>,\n-                    expr_id: ast::NodeId)\n-                    -> Result<Def, MethodError<'tcx>>\n-{\n-    let mode = probe::Mode::Path;\n-    let pick = self.probe_method(span, mode, method_name, self_ty, expr_id)?;\n-\n-    if let Some(import_id) = pick.import_id {\n-        self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n+        Some(callee)\n     }\n \n-    let def = pick.item.def();\n-    if let probe::InherentImplPick = pick.kind {\n-        if !pick.item.vis().is_accessible_from(self.body_id, &self.tcx.map) {\n-            let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n-            self.tcx.sess.span_err(span, &msg);\n+    pub fn resolve_ufcs(&self,\n+                        span: Span,\n+                        method_name: ast::Name,\n+                        self_ty: ty::Ty<'tcx>,\n+                        expr_id: ast::NodeId)\n+                        -> Result<Def, MethodError<'tcx>>\n+    {\n+        let mode = probe::Mode::Path;\n+        let pick = self.probe_method(span, mode, method_name, self_ty, expr_id)?;\n+\n+        if let Some(import_id) = pick.import_id {\n+            self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n         }\n+\n+        let def = pick.item.def();\n+        if let probe::InherentImplPick = pick.kind {\n+            if !pick.item.vis().is_accessible_from(self.body_id, &self.tcx.map) {\n+                let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n+                self.tcx.sess.span_err(span, &msg);\n+            }\n+        }\n+        Ok(def)\n     }\n-    Ok(def)\n-}\n \n-/// Find item with name `item_name` defined in `trait_def_id`\n-/// and return it, or `None`, if no such item.\n-pub fn trait_item(&self,\n-                  trait_def_id: DefId,\n-                  item_name: ast::Name)\n-                  -> Option<ty::ImplOrTraitItem<'tcx>>\n-{\n-    let trait_items = self.tcx.trait_items(trait_def_id);\n-    trait_items.iter()\n-               .find(|item| item.name() == item_name)\n-               .cloned()\n-}\n+    /// Find item with name `item_name` defined in `trait_def_id`\n+    /// and return it, or `None`, if no such item.\n+    pub fn trait_item(&self,\n+                      trait_def_id: DefId,\n+                      item_name: ast::Name)\n+                      -> Option<ty::ImplOrTraitItem<'tcx>>\n+    {\n+        let trait_items = self.tcx.trait_items(trait_def_id);\n+        trait_items.iter()\n+                   .find(|item| item.name() == item_name)\n+                   .cloned()\n+    }\n \n-pub fn impl_item(&self,\n-                 impl_def_id: DefId,\n-                 item_name: ast::Name)\n-                 -> Option<ty::ImplOrTraitItem<'tcx>>\n-{\n-    let impl_items = self.tcx.impl_items.borrow();\n-    let impl_items = impl_items.get(&impl_def_id).unwrap();\n-    impl_items\n-        .iter()\n-        .map(|&did| self.tcx.impl_or_trait_item(did.def_id()))\n-        .find(|m| m.name() == item_name)\n-}\n+    pub fn impl_item(&self,\n+                     impl_def_id: DefId,\n+                     item_name: ast::Name)\n+                     -> Option<ty::ImplOrTraitItem<'tcx>>\n+    {\n+        let impl_items = self.tcx.impl_items.borrow();\n+        let impl_items = impl_items.get(&impl_def_id).unwrap();\n+        impl_items\n+            .iter()\n+            .map(|&did| self.tcx.impl_or_trait_item(did.def_id()))\n+            .find(|m| m.name() == item_name)\n+    }\n }"}, {"sha": "08c041225171ab36166d0def0da199874131f9c3", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -137,108 +137,108 @@ pub enum Mode {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-pub fn probe_method(&self,\n-                    span: Span,\n-                    mode: Mode,\n-                    item_name: ast::Name,\n-                    self_ty: Ty<'tcx>,\n-                    scope_expr_id: ast::NodeId)\n-                    -> PickResult<'tcx>\n-{\n-    debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n-           self_ty,\n-           item_name,\n-           scope_expr_id);\n-\n-    // FIXME(#18741) -- right now, creating the steps involves evaluating the\n-    // `*` operator, which registers obligations that then escape into\n-    // the global fulfillment context and thus has global\n-    // side-effects. This is a bit of a pain to refactor. So just let\n-    // it ride, although it's really not great, and in fact could I\n-    // think cause spurious errors. Really though this part should\n-    // take place in the `self.probe` below.\n-    let steps = if mode == Mode::MethodCall {\n-        match self.create_steps(span, self_ty) {\n-            Some(steps) => steps,\n-            None =>return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(), Vec::new(),\n-                                                                    Vec::new(), mode))),\n-        }\n-    } else {\n-        vec![CandidateStep {\n-            self_ty: self_ty,\n-            autoderefs: 0,\n-            unsize: false\n-        }]\n-    };\n-\n-    // Create a list of simplified self types, if we can.\n-    let mut simplified_steps = Vec::new();\n-    for step in &steps {\n-        match ty::fast_reject::simplify_type(self.tcx, step.self_ty, true) {\n-            None => { break; }\n-            Some(simplified_type) => { simplified_steps.push(simplified_type); }\n-        }\n-    }\n-    let opt_simplified_steps =\n-        if simplified_steps.len() < steps.len() {\n-            None // failed to convert at least one of the steps\n+    pub fn probe_method(&self,\n+                        span: Span,\n+                        mode: Mode,\n+                        item_name: ast::Name,\n+                        self_ty: Ty<'tcx>,\n+                        scope_expr_id: ast::NodeId)\n+                        -> PickResult<'tcx>\n+    {\n+        debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n+               self_ty,\n+               item_name,\n+               scope_expr_id);\n+\n+        // FIXME(#18741) -- right now, creating the steps involves evaluating the\n+        // `*` operator, which registers obligations that then escape into\n+        // the global fulfillment context and thus has global\n+        // side-effects. This is a bit of a pain to refactor. So just let\n+        // it ride, although it's really not great, and in fact could I\n+        // think cause spurious errors. Really though this part should\n+        // take place in the `self.probe` below.\n+        let steps = if mode == Mode::MethodCall {\n+            match self.create_steps(span, self_ty) {\n+                Some(steps) => steps,\n+                None =>return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(), Vec::new(),\n+                                                                        Vec::new(), mode))),\n+            }\n         } else {\n-            Some(simplified_steps)\n+            vec![CandidateStep {\n+                self_ty: self_ty,\n+                autoderefs: 0,\n+                unsize: false\n+            }]\n         };\n \n-    debug!(\"ProbeContext: steps for self_ty={:?} are {:?}\",\n-           self_ty,\n-           steps);\n-\n-    // this creates one big transaction so that all type variables etc\n-    // that we create during the probe process are removed later\n-    self.probe(|_| {\n-        let mut probe_cx = ProbeContext::new(self,\n-                                             span,\n-                                             mode,\n-                                             item_name,\n-                                             steps,\n-                                             opt_simplified_steps);\n-        probe_cx.assemble_inherent_candidates();\n-        probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?;\n-        probe_cx.pick()\n-    })\n-}\n+        // Create a list of simplified self types, if we can.\n+        let mut simplified_steps = Vec::new();\n+        for step in &steps {\n+            match ty::fast_reject::simplify_type(self.tcx, step.self_ty, true) {\n+                None => { break; }\n+                Some(simplified_type) => { simplified_steps.push(simplified_type); }\n+            }\n+        }\n+        let opt_simplified_steps =\n+            if simplified_steps.len() < steps.len() {\n+                None // failed to convert at least one of the steps\n+            } else {\n+                Some(simplified_steps)\n+            };\n \n-fn create_steps(&self,\n-                span: Span,\n-                self_ty: Ty<'tcx>)\n-                -> Option<Vec<CandidateStep<'tcx>>> {\n-    let mut steps = Vec::new();\n-\n-    let (final_ty, dereferences, _) = self.autoderef(span,\n-                                                     self_ty,\n-                                                     || None,\n-                                                     UnresolvedTypeAction::Error,\n-                                                     NoPreference,\n-                                                     |t, d| {\n-        steps.push(CandidateStep {\n-            self_ty: t,\n-            autoderefs: d,\n-            unsize: false\n-        });\n-        None::<()> // keep iterating until we can't anymore\n-    });\n+        debug!(\"ProbeContext: steps for self_ty={:?} are {:?}\",\n+               self_ty,\n+               steps);\n \n-    match final_ty.sty {\n-        ty::TyArray(elem_ty, _) => {\n+        // this creates one big transaction so that all type variables etc\n+        // that we create during the probe process are removed later\n+        self.probe(|_| {\n+            let mut probe_cx = ProbeContext::new(self,\n+                                                 span,\n+                                                 mode,\n+                                                 item_name,\n+                                                 steps,\n+                                                 opt_simplified_steps);\n+            probe_cx.assemble_inherent_candidates();\n+            probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?;\n+            probe_cx.pick()\n+        })\n+    }\n+\n+    fn create_steps(&self,\n+                    span: Span,\n+                    self_ty: Ty<'tcx>)\n+                    -> Option<Vec<CandidateStep<'tcx>>> {\n+        let mut steps = Vec::new();\n+\n+        let (final_ty, dereferences, _) = self.autoderef(span,\n+                                                         self_ty,\n+                                                         || None,\n+                                                         UnresolvedTypeAction::Error,\n+                                                         NoPreference,\n+                                                         |t, d| {\n             steps.push(CandidateStep {\n-                self_ty: self.tcx.mk_slice(elem_ty),\n-                autoderefs: dereferences,\n-                unsize: true\n+                self_ty: t,\n+                autoderefs: d,\n+                unsize: false\n             });\n+            None::<()> // keep iterating until we can't anymore\n+        });\n+\n+        match final_ty.sty {\n+            ty::TyArray(elem_ty, _) => {\n+                steps.push(CandidateStep {\n+                    self_ty: self.tcx.mk_slice(elem_ty),\n+                    autoderefs: dereferences,\n+                    unsize: true\n+                });\n+            }\n+            ty::TyError => return None,\n+            _ => (),\n         }\n-        ty::TyError => return None,\n-        _ => (),\n-    }\n \n-    Some(steps)\n-}\n+        Some(steps)\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {"}, {"sha": "540af8b04bf0ee8802de926e07c7f75c850877f4", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 305, "deletions": 305, "changes": 610, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -40,351 +40,351 @@ use super::{MethodError, NoMatchData, CandidateSource};\n use super::probe::Mode;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-fn is_fn_ty(&self, ty: &Ty<'tcx>, span: Span) -> bool {\n-    let tcx = self.tcx;\n-    match ty.sty {\n-        // Not all of these (e.g. unsafe fns) implement FnOnce\n-        // so we look for these beforehand\n-        ty::TyClosure(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) => true,\n-        // If it's not a simple function, look for things which implement FnOnce\n-        _ => {\n-            if let Ok(fn_once_trait_did) =\n-                    tcx.lang_items.require(FnOnceTraitLangItem) {\n-                let (_, _, opt_is_fn) = self.autoderef(span,\n-                                                       ty,\n-                                                       || None,\n-                                                       UnresolvedTypeAction::Ignore,\n-                                                       LvaluePreference::NoPreference,\n-                                                       |ty, _| {\n-                    self.probe(|_| {\n-                        let fn_once_substs =\n-                            Substs::new_trait(vec![self.next_ty_var()], vec![], ty);\n-                        let trait_ref =\n-                            ty::TraitRef::new(fn_once_trait_did,\n-                                              tcx.mk_substs(fn_once_substs));\n-                        let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-                        let obligation = Obligation::misc(span,\n-                                                          self.body_id,\n-                                                          poly_trait_ref\n-                                                             .to_predicate());\n-                        let mut selcx = SelectionContext::new(self);\n-\n-                        if selcx.evaluate_obligation(&obligation) {\n-                            Some(())\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                });\n+    fn is_fn_ty(&self, ty: &Ty<'tcx>, span: Span) -> bool {\n+        let tcx = self.tcx;\n+        match ty.sty {\n+            // Not all of these (e.g. unsafe fns) implement FnOnce\n+            // so we look for these beforehand\n+            ty::TyClosure(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) => true,\n+            // If it's not a simple function, look for things which implement FnOnce\n+            _ => {\n+                if let Ok(fn_once_trait_did) =\n+                        tcx.lang_items.require(FnOnceTraitLangItem) {\n+                    let (_, _, opt_is_fn) = self.autoderef(span,\n+                                                           ty,\n+                                                           || None,\n+                                                           UnresolvedTypeAction::Ignore,\n+                                                           LvaluePreference::NoPreference,\n+                                                           |ty, _| {\n+                        self.probe(|_| {\n+                            let fn_once_substs =\n+                                Substs::new_trait(vec![self.next_ty_var()], vec![], ty);\n+                            let trait_ref =\n+                                ty::TraitRef::new(fn_once_trait_did,\n+                                                  tcx.mk_substs(fn_once_substs));\n+                            let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                            let obligation = Obligation::misc(span,\n+                                                              self.body_id,\n+                                                              poly_trait_ref\n+                                                                 .to_predicate());\n+                            let mut selcx = SelectionContext::new(self);\n+\n+                            if selcx.evaluate_obligation(&obligation) {\n+                                Some(())\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                    });\n \n-                opt_is_fn.is_some()\n-            } else {\n-                false\n+                    opt_is_fn.is_some()\n+                } else {\n+                    false\n+                }\n             }\n         }\n     }\n-}\n-pub fn report_method_error(&self,\n-                           span: Span,\n-                           rcvr_ty: Ty<'tcx>,\n-                           item_name: ast::Name,\n-                           rcvr_expr: Option<&hir::Expr>,\n-                           error: MethodError<'tcx>)\n-{\n-    // avoid suggestions when we don't know what's going on.\n-    if rcvr_ty.references_error() {\n-        return\n-    }\n-\n-    let report_candidates = |err: &mut DiagnosticBuilder,\n-                             mut sources: Vec<CandidateSource>| {\n-\n-        sources.sort();\n-        sources.dedup();\n-\n-        for (idx, source) in sources.iter().enumerate() {\n-            match *source {\n-                CandidateSource::ImplSource(impl_did) => {\n-                    // Provide the best span we can. Use the item, if local to crate, else\n-                    // the impl, if local to crate (item may be defaulted), else nothing.\n-                    let item = self.impl_item(impl_did, item_name)\n-                        .or_else(|| {\n-                            self.trait_item(\n-                                self.tcx.impl_trait_ref(impl_did).unwrap().def_id,\n-\n-                                item_name\n-                            )\n-                        }).unwrap();\n-                    let note_span = self.tcx.map.span_if_local(item.def_id()).or_else(|| {\n-                        self.tcx.map.span_if_local(impl_did)\n-                    });\n-\n-                    let impl_ty = self.impl_self_ty(span, impl_did).ty;\n+    pub fn report_method_error(&self,\n+                               span: Span,\n+                               rcvr_ty: Ty<'tcx>,\n+                               item_name: ast::Name,\n+                               rcvr_expr: Option<&hir::Expr>,\n+                               error: MethodError<'tcx>)\n+    {\n+        // avoid suggestions when we don't know what's going on.\n+        if rcvr_ty.references_error() {\n+            return\n+        }\n \n-                    let insertion = match self.tcx.impl_trait_ref(impl_did) {\n-                        None => format!(\"\"),\n-                        Some(trait_ref) => {\n-                            format!(\" of the trait `{}`\",\n-                                    self.tcx.item_path_str(trait_ref.def_id))\n+        let report_candidates = |err: &mut DiagnosticBuilder,\n+                                 mut sources: Vec<CandidateSource>| {\n+\n+            sources.sort();\n+            sources.dedup();\n+\n+            for (idx, source) in sources.iter().enumerate() {\n+                match *source {\n+                    CandidateSource::ImplSource(impl_did) => {\n+                        // Provide the best span we can. Use the item, if local to crate, else\n+                        // the impl, if local to crate (item may be defaulted), else nothing.\n+                        let item = self.impl_item(impl_did, item_name)\n+                            .or_else(|| {\n+                                self.trait_item(\n+                                    self.tcx.impl_trait_ref(impl_did).unwrap().def_id,\n+\n+                                    item_name\n+                                )\n+                            }).unwrap();\n+                        let note_span = self.tcx.map.span_if_local(item.def_id()).or_else(|| {\n+                            self.tcx.map.span_if_local(impl_did)\n+                        });\n+\n+                        let impl_ty = self.impl_self_ty(span, impl_did).ty;\n+\n+                        let insertion = match self.tcx.impl_trait_ref(impl_did) {\n+                            None => format!(\"\"),\n+                            Some(trait_ref) => {\n+                                format!(\" of the trait `{}`\",\n+                                        self.tcx.item_path_str(trait_ref.def_id))\n+                            }\n+                        };\n+\n+                        let note_str = format!(\"candidate #{} is defined in an impl{} \\\n+                                                for the type `{}`\",\n+                                               idx + 1,\n+                                               insertion,\n+                                               impl_ty);\n+                        if let Some(note_span) = note_span {\n+                            // We have a span pointing to the method. Show note with snippet.\n+                            err.span_note(note_span, &note_str);\n+                        } else {\n+                            err.note(&note_str);\n                         }\n-                    };\n-\n-                    let note_str = format!(\"candidate #{} is defined in an impl{} \\\n-                                            for the type `{}`\",\n-                                           idx + 1,\n-                                           insertion,\n-                                           impl_ty);\n-                    if let Some(note_span) = note_span {\n-                        // We have a span pointing to the method. Show note with snippet.\n-                        err.span_note(note_span, &note_str);\n-                    } else {\n-                        err.note(&note_str);\n                     }\n-                }\n-                CandidateSource::TraitSource(trait_did) => {\n-                    let item = self.trait_item(trait_did, item_name).unwrap();\n-                    let item_span = self.tcx.map.def_id_span(item.def_id(), span);\n-                    span_note!(err, item_span,\n-                               \"candidate #{} is defined in the trait `{}`\",\n-                               idx + 1,\n-                               self.tcx.item_path_str(trait_did));\n-                }\n-            }\n-        }\n-    };\n-\n-    match error {\n-        MethodError::NoMatch(NoMatchData { static_candidates: static_sources,\n-                                           unsatisfied_predicates,\n-                                           out_of_scope_traits,\n-                                           mode, .. }) => {\n-            let tcx = self.tcx;\n-\n-            let mut err = self.type_error_struct(\n-                span,\n-                |actual| {\n-                    format!(\"no {} named `{}` found for type `{}` \\\n-                             in the current scope\",\n-                            if mode == Mode::MethodCall { \"method\" }\n-                            else { \"associated item\" },\n-                            item_name,\n-                            actual)\n-                },\n-                rcvr_ty,\n-                None);\n-\n-            // If the item has the name of a field, give a help note\n-            if let (&ty::TyStruct(def, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n-                if let Some(field) = def.struct_variant().find_field_named(item_name) {\n-                    let expr_string = match tcx.sess.codemap().span_to_snippet(expr.span) {\n-                        Ok(expr_string) => expr_string,\n-                        _ => \"s\".into() // Default to a generic placeholder for the\n-                                        // expression when we can't generate a string\n-                                        // snippet\n-                    };\n-\n-                    let field_ty = field.ty(tcx, substs);\n-\n-                    if self.is_fn_ty(&field_ty, span) {\n-                        err.span_note(span,\n-                                      &format!(\"use `({0}.{1})(...)` if you meant to call \\\n-                                               the function stored in the `{1}` field\",\n-                                               expr_string, item_name));\n-                    } else {\n-                        err.span_note(span, &format!(\"did you mean to write `{0}.{1}`?\",\n-                                                     expr_string, item_name));\n+                    CandidateSource::TraitSource(trait_did) => {\n+                        let item = self.trait_item(trait_did, item_name).unwrap();\n+                        let item_span = self.tcx.map.def_id_span(item.def_id(), span);\n+                        span_note!(err, item_span,\n+                                   \"candidate #{} is defined in the trait `{}`\",\n+                                   idx + 1,\n+                                   self.tcx.item_path_str(trait_did));\n                     }\n                 }\n             }\n-\n-            if self.is_fn_ty(&rcvr_ty, span) {\n-                macro_rules! report_function {\n-                    ($span:expr, $name:expr) => {\n-                        err.note(&format!(\"{} is a function, perhaps you wish to call it\",\n-                                     $name));\n+        };\n+\n+        match error {\n+            MethodError::NoMatch(NoMatchData { static_candidates: static_sources,\n+                                               unsatisfied_predicates,\n+                                               out_of_scope_traits,\n+                                               mode, .. }) => {\n+                let tcx = self.tcx;\n+\n+                let mut err = self.type_error_struct(\n+                    span,\n+                    |actual| {\n+                        format!(\"no {} named `{}` found for type `{}` \\\n+                                 in the current scope\",\n+                                if mode == Mode::MethodCall { \"method\" }\n+                                else { \"associated item\" },\n+                                item_name,\n+                                actual)\n+                    },\n+                    rcvr_ty,\n+                    None);\n+\n+                // If the item has the name of a field, give a help note\n+                if let (&ty::TyStruct(def, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n+                    if let Some(field) = def.struct_variant().find_field_named(item_name) {\n+                        let expr_string = match tcx.sess.codemap().span_to_snippet(expr.span) {\n+                            Ok(expr_string) => expr_string,\n+                            _ => \"s\".into() // Default to a generic placeholder for the\n+                                            // expression when we can't generate a string\n+                                            // snippet\n+                        };\n+\n+                        let field_ty = field.ty(tcx, substs);\n+\n+                        if self.is_fn_ty(&field_ty, span) {\n+                            err.span_note(span,\n+                                          &format!(\"use `({0}.{1})(...)` if you meant to call \\\n+                                                   the function stored in the `{1}` field\",\n+                                                   expr_string, item_name));\n+                        } else {\n+                            err.span_note(span, &format!(\"did you mean to write `{0}.{1}`?\",\n+                                                         expr_string, item_name));\n+                        }\n                     }\n                 }\n \n-                if let Some(expr) = rcvr_expr {\n-                    if let Ok (expr_string) = tcx.sess.codemap().span_to_snippet(expr.span) {\n-                        report_function!(expr.span, expr_string);\n+                if self.is_fn_ty(&rcvr_ty, span) {\n+                    macro_rules! report_function {\n+                        ($span:expr, $name:expr) => {\n+                            err.note(&format!(\"{} is a function, perhaps you wish to call it\",\n+                                         $name));\n+                        }\n                     }\n-                    else if let Expr_::ExprPath(_, path) = expr.node.clone() {\n-                        if let Some(segment) = path.segments.last() {\n-                            report_function!(expr.span, segment.identifier.name);\n+\n+                    if let Some(expr) = rcvr_expr {\n+                        if let Ok (expr_string) = tcx.sess.codemap().span_to_snippet(expr.span) {\n+                            report_function!(expr.span, expr_string);\n+                        }\n+                        else if let Expr_::ExprPath(_, path) = expr.node.clone() {\n+                            if let Some(segment) = path.segments.last() {\n+                                report_function!(expr.span, segment.identifier.name);\n+                            }\n                         }\n                     }\n                 }\n-            }\n \n-            if !static_sources.is_empty() {\n-                err.note(\n-                    \"found the following associated functions; to be used as \\\n-                     methods, functions must have a `self` parameter\");\n+                if !static_sources.is_empty() {\n+                    err.note(\n+                        \"found the following associated functions; to be used as \\\n+                         methods, functions must have a `self` parameter\");\n \n-                report_candidates(&mut err, static_sources);\n-            }\n+                    report_candidates(&mut err, static_sources);\n+                }\n+\n+                if !unsatisfied_predicates.is_empty() {\n+                    let bound_list = unsatisfied_predicates.iter()\n+                        .map(|p| format!(\"`{} : {}`\",\n+                                         p.self_ty(),\n+                                         p))\n+                        .collect::<Vec<_>>()\n+                        .join(\", \");\n+                    err.note(\n+                        &format!(\"the method `{}` exists but the \\\n+                                 following trait bounds were not satisfied: {}\",\n+                                 item_name,\n+                                 bound_list));\n+                }\n \n-            if !unsatisfied_predicates.is_empty() {\n-                let bound_list = unsatisfied_predicates.iter()\n-                    .map(|p| format!(\"`{} : {}`\",\n-                                     p.self_ty(),\n-                                     p))\n-                    .collect::<Vec<_>>()\n-                    .join(\", \");\n-                err.note(\n-                    &format!(\"the method `{}` exists but the \\\n-                             following trait bounds were not satisfied: {}\",\n-                             item_name,\n-                             bound_list));\n+                self.suggest_traits_to_import(&mut err, span, rcvr_ty, item_name,\n+                                              rcvr_expr, out_of_scope_traits);\n+                err.emit();\n             }\n \n-            self.suggest_traits_to_import(&mut err, span, rcvr_ty, item_name,\n-                                          rcvr_expr, out_of_scope_traits);\n-            err.emit();\n-        }\n+            MethodError::Ambiguity(sources) => {\n+                let mut err = struct_span_err!(self.sess(), span, E0034,\n+                                               \"multiple applicable items in scope\");\n \n-        MethodError::Ambiguity(sources) => {\n-            let mut err = struct_span_err!(self.sess(), span, E0034,\n-                                           \"multiple applicable items in scope\");\n+                report_candidates(&mut err, sources);\n+                err.emit();\n+            }\n \n-            report_candidates(&mut err, sources);\n-            err.emit();\n+            MethodError::ClosureAmbiguity(trait_def_id) => {\n+                let msg = format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n+                                   invoked on this closure as we have not yet inferred what \\\n+                                   kind of closure it is\",\n+                                   item_name,\n+                                   self.tcx.item_path_str(trait_def_id));\n+                let msg = if let Some(callee) = rcvr_expr {\n+                    format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n+                            msg, pprust::expr_to_string(callee))\n+                } else {\n+                    msg\n+                };\n+                self.sess().span_err(span, &msg);\n+            }\n+\n+            MethodError::PrivateMatch(def) => {\n+                let msg = format!(\"{} `{}` is private\", def.kind_name(), item_name);\n+                self.tcx.sess.span_err(span, &msg);\n+            }\n         }\n+    }\n \n-        MethodError::ClosureAmbiguity(trait_def_id) => {\n-            let msg = format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n-                               invoked on this closure as we have not yet inferred what \\\n-                               kind of closure it is\",\n-                               item_name,\n-                               self.tcx.item_path_str(trait_def_id));\n-            let msg = if let Some(callee) = rcvr_expr {\n-                format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n-                        msg, pprust::expr_to_string(callee))\n-            } else {\n-                msg\n-            };\n-            self.sess().span_err(span, &msg);\n+    fn suggest_traits_to_import(&self,\n+                                err: &mut DiagnosticBuilder,\n+                                span: Span,\n+                                rcvr_ty: Ty<'tcx>,\n+                                item_name: ast::Name,\n+                                rcvr_expr: Option<&hir::Expr>,\n+                                valid_out_of_scope_traits: Vec<DefId>)\n+    {\n+        if !valid_out_of_scope_traits.is_empty() {\n+            let mut candidates = valid_out_of_scope_traits;\n+            candidates.sort();\n+            candidates.dedup();\n+            let msg = format!(\n+                \"items from traits can only be used if the trait is in scope; \\\n+                 the following {traits_are} implemented but not in scope, \\\n+                 perhaps add a `use` for {one_of_them}:\",\n+                traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n+                one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"});\n+\n+            err.help(&msg[..]);\n+\n+            for (i, trait_did) in candidates.iter().enumerate() {\n+                err.help(&format!(\"candidate #{}: `use {}`\",\n+                                  i + 1,\n+                                  self.tcx.item_path_str(*trait_did)));\n+            }\n+            return\n         }\n \n-        MethodError::PrivateMatch(def) => {\n-            let msg = format!(\"{} `{}` is private\", def.kind_name(), item_name);\n-            self.tcx.sess.span_err(span, &msg);\n+        let type_is_local = self.type_derefs_to_local(span, rcvr_ty, rcvr_expr);\n+\n+        // there's no implemented traits, so lets suggest some traits to\n+        // implement, by finding ones that have the item name, and are\n+        // legal to implement.\n+        let mut candidates = all_traits(self.ccx)\n+            .filter(|info| {\n+                // we approximate the coherence rules to only suggest\n+                // traits that are legal to implement by requiring that\n+                // either the type or trait is local. Multidispatch means\n+                // this isn't perfect (that is, there are cases when\n+                // implementing a trait would be legal but is rejected\n+                // here).\n+                (type_is_local || info.def_id.is_local())\n+                    && self.trait_item(info.def_id, item_name).is_some()\n+            })\n+            .collect::<Vec<_>>();\n+\n+        if !candidates.is_empty() {\n+            // sort from most relevant to least relevant\n+            candidates.sort_by(|a, b| a.cmp(b).reverse());\n+            candidates.dedup();\n+\n+            // FIXME #21673 this help message could be tuned to the case\n+            // of a type parameter: suggest adding a trait bound rather\n+            // than implementing.\n+            let msg = format!(\n+                \"items from traits can only be used if the trait is implemented and in scope; \\\n+                 the following {traits_define} an item `{name}`, \\\n+                 perhaps you need to implement {one_of_them}:\",\n+                traits_define = if candidates.len() == 1 {\"trait defines\"} else {\"traits define\"},\n+                one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n+                name = item_name);\n+\n+            err.help(&msg[..]);\n+\n+            for (i, trait_info) in candidates.iter().enumerate() {\n+                err.help(&format!(\"candidate #{}: `{}`\",\n+                                  i + 1,\n+                                  self.tcx.item_path_str(trait_info.def_id)));\n+            }\n         }\n     }\n-}\n \n-fn suggest_traits_to_import(&self,\n-                            err: &mut DiagnosticBuilder,\n+    /// Checks whether there is a local type somewhere in the chain of\n+    /// autoderefs of `rcvr_ty`.\n+    fn type_derefs_to_local(&self,\n                             span: Span,\n                             rcvr_ty: Ty<'tcx>,\n-                            item_name: ast::Name,\n-                            rcvr_expr: Option<&hir::Expr>,\n-                            valid_out_of_scope_traits: Vec<DefId>)\n-{\n-    if !valid_out_of_scope_traits.is_empty() {\n-        let mut candidates = valid_out_of_scope_traits;\n-        candidates.sort();\n-        candidates.dedup();\n-        let msg = format!(\n-            \"items from traits can only be used if the trait is in scope; \\\n-             the following {traits_are} implemented but not in scope, \\\n-             perhaps add a `use` for {one_of_them}:\",\n-            traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n-            one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"});\n-\n-        err.help(&msg[..]);\n-\n-        for (i, trait_did) in candidates.iter().enumerate() {\n-            err.help(&format!(\"candidate #{}: `use {}`\",\n-                              i + 1,\n-                              self.tcx.item_path_str(*trait_did)));\n-        }\n-        return\n-    }\n+                            rcvr_expr: Option<&hir::Expr>) -> bool {\n+        fn is_local(ty: Ty) -> bool {\n+            match ty.sty {\n+                ty::TyEnum(def, _) | ty::TyStruct(def, _) => def.did.is_local(),\n \n-    let type_is_local = self.type_derefs_to_local(span, rcvr_ty, rcvr_expr);\n-\n-    // there's no implemented traits, so lets suggest some traits to\n-    // implement, by finding ones that have the item name, and are\n-    // legal to implement.\n-    let mut candidates = all_traits(self.ccx)\n-        .filter(|info| {\n-            // we approximate the coherence rules to only suggest\n-            // traits that are legal to implement by requiring that\n-            // either the type or trait is local. Multidispatch means\n-            // this isn't perfect (that is, there are cases when\n-            // implementing a trait would be legal but is rejected\n-            // here).\n-            (type_is_local || info.def_id.is_local())\n-                && self.trait_item(info.def_id, item_name).is_some()\n-        })\n-        .collect::<Vec<_>>();\n-\n-    if !candidates.is_empty() {\n-        // sort from most relevant to least relevant\n-        candidates.sort_by(|a, b| a.cmp(b).reverse());\n-        candidates.dedup();\n-\n-        // FIXME #21673 this help message could be tuned to the case\n-        // of a type parameter: suggest adding a trait bound rather\n-        // than implementing.\n-        let msg = format!(\n-            \"items from traits can only be used if the trait is implemented and in scope; \\\n-             the following {traits_define} an item `{name}`, \\\n-             perhaps you need to implement {one_of_them}:\",\n-            traits_define = if candidates.len() == 1 {\"trait defines\"} else {\"traits define\"},\n-            one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n-            name = item_name);\n-\n-        err.help(&msg[..]);\n-\n-        for (i, trait_info) in candidates.iter().enumerate() {\n-            err.help(&format!(\"candidate #{}: `{}`\",\n-                              i + 1,\n-                              self.tcx.item_path_str(trait_info.def_id)));\n-        }\n-    }\n-}\n+                ty::TyTrait(ref tr) => tr.principal_def_id().is_local(),\n \n-/// Checks whether there is a local type somewhere in the chain of\n-/// autoderefs of `rcvr_ty`.\n-fn type_derefs_to_local(&self,\n-                        span: Span,\n-                        rcvr_ty: Ty<'tcx>,\n-                        rcvr_expr: Option<&hir::Expr>) -> bool {\n-    fn is_local(ty: Ty) -> bool {\n-        match ty.sty {\n-            ty::TyEnum(def, _) | ty::TyStruct(def, _) => def.did.is_local(),\n+                ty::TyParam(_) => true,\n \n-            ty::TyTrait(ref tr) => tr.principal_def_id().is_local(),\n-\n-            ty::TyParam(_) => true,\n+                // everything else (primitive types etc.) is effectively\n+                // non-local (there are \"edge\" cases, e.g. (LocalType,), but\n+                // the noise from these sort of types is usually just really\n+                // annoying, rather than any sort of help).\n+                _ => false\n+            }\n+        }\n \n-            // everything else (primitive types etc.) is effectively\n-            // non-local (there are \"edge\" cases, e.g. (LocalType,), but\n-            // the noise from these sort of types is usually just really\n-            // annoying, rather than any sort of help).\n-            _ => false\n+        // This occurs for UFCS desugaring of `T::method`, where there is no\n+        // receiver expression for the method call, and thus no autoderef.\n+        if rcvr_expr.is_none() {\n+            return is_local(self.resolve_type_vars_with_obligations(rcvr_ty));\n         }\n-    }\n \n-    // This occurs for UFCS desugaring of `T::method`, where there is no\n-    // receiver expression for the method call, and thus no autoderef.\n-    if rcvr_expr.is_none() {\n-        return is_local(self.resolve_type_vars_with_obligations(rcvr_ty));\n+        self.autoderef(span, rcvr_ty, || None,\n+                       check::UnresolvedTypeAction::Ignore, ty::NoPreference,\n+                       |ty, _| {\n+            if is_local(ty) {\n+                Some(())\n+            } else {\n+                None\n+            }\n+        }).2.is_some()\n     }\n-\n-    self.autoderef(span, rcvr_ty, || None,\n-                   check::UnresolvedTypeAction::Ignore, ty::NoPreference,\n-                   |ty, _| {\n-        if is_local(ty) {\n-            Some(())\n-        } else {\n-            None\n-        }\n-    }).2.is_some()\n-}\n }\n \n pub type AllTraitsVec = Vec<TraitInfo>;"}, {"sha": "f428023da9b8248628146e9220e6f5a3b25433be", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1599, "deletions": 1593, "changes": 3192, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=42eb7032fab11aca9228d42969f471b581444c56"}, {"sha": "8604dadf46dff2f4011aa22f67fb948f0a634ea0", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 295, "deletions": 290, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -18,330 +18,335 @@ use syntax::parse::token;\n use rustc::hir;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-/// Check a `a <op>= b`\n-pub fn check_binop_assign(&self,\n-                          expr: &'gcx hir::Expr,\n-                          op: hir::BinOp,\n-                          lhs_expr: &'gcx hir::Expr,\n-                          rhs_expr: &'gcx hir::Expr)\n-{\n-    self.check_expr_with_lvalue_pref(lhs_expr, PreferMutLvalue);\n-\n-    let lhs_ty = self.resolve_type_vars_with_obligations(self.expr_ty(lhs_expr));\n-    let (rhs_ty, return_ty) =\n-        self.check_overloaded_binop(expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::Yes);\n-    let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n-\n-    if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n-        self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n-        self.write_nil(expr.id);\n-    } else {\n-        self.write_ty(expr.id, return_ty);\n-    }\n+    /// Check a `a <op>= b`\n+    pub fn check_binop_assign(&self,\n+                              expr: &'gcx hir::Expr,\n+                              op: hir::BinOp,\n+                              lhs_expr: &'gcx hir::Expr,\n+                              rhs_expr: &'gcx hir::Expr)\n+    {\n+        self.check_expr_with_lvalue_pref(lhs_expr, PreferMutLvalue);\n+\n+        let lhs_ty = self.resolve_type_vars_with_obligations(self.expr_ty(lhs_expr));\n+        let (rhs_ty, return_ty) =\n+            self.check_overloaded_binop(expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::Yes);\n+        let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n+\n+        if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n+            self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n+            self.write_nil(expr.id);\n+        } else {\n+            self.write_ty(expr.id, return_ty);\n+        }\n \n-    let tcx = self.tcx;\n-    if !tcx.expr_is_lval(lhs_expr) {\n-        span_err!(tcx.sess, lhs_expr.span, E0067, \"invalid left-hand side expression\");\n+        let tcx = self.tcx;\n+        if !tcx.expr_is_lval(lhs_expr) {\n+            span_err!(tcx.sess, lhs_expr.span, E0067, \"invalid left-hand side expression\");\n+        }\n     }\n-}\n-\n-/// Check a potentially overloaded binary operator.\n-pub fn check_binop(&self,\n-                   expr: &'gcx hir::Expr,\n-                   op: hir::BinOp,\n-                   lhs_expr: &'gcx hir::Expr,\n-                   rhs_expr: &'gcx hir::Expr)\n-{\n-    let tcx = self.tcx;\n-\n-    debug!(\"check_binop(expr.id={}, expr={:?}, op={:?}, lhs_expr={:?}, rhs_expr={:?})\",\n-           expr.id,\n-           expr,\n-           op,\n-           lhs_expr,\n-           rhs_expr);\n-\n-    self.check_expr(lhs_expr);\n-    let lhs_ty = self.resolve_type_vars_with_obligations(self.expr_ty(lhs_expr));\n \n-    match BinOpCategory::from(op) {\n-        BinOpCategory::Shortcircuit => {\n-            // && and || are a simple case.\n-            self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n-            self.check_expr_coercable_to_type(rhs_expr, tcx.mk_bool());\n-            self.write_ty(expr.id, tcx.mk_bool());\n-        }\n-        _ => {\n-            // Otherwise, we always treat operators as if they are\n-            // overloaded. This is the way to be most flexible w/r/t\n-            // types that get inferred.\n-            let (rhs_ty, return_ty) =\n-                self.check_overloaded_binop(expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::No);\n-\n-            // Supply type inference hints if relevant. Probably these\n-            // hints should be enforced during select as part of the\n-            // `consider_unification_despite_ambiguity` routine, but this\n-            // more convenient for now.\n-            //\n-            // The basic idea is to help type inference by taking\n-            // advantage of things we know about how the impls for\n-            // scalar types are arranged. This is important in a\n-            // scenario like `1_u32 << 2`, because it lets us quickly\n-            // deduce that the result type should be `u32`, even\n-            // though we don't know yet what type 2 has and hence\n-            // can't pin this down to a specific impl.\n-            let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n-            if\n-                !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() &&\n-                is_builtin_binop(lhs_ty, rhs_ty, op)\n-            {\n-                let builtin_return_ty =\n-                    self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n-                self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n+    /// Check a potentially overloaded binary operator.\n+    pub fn check_binop(&self,\n+                       expr: &'gcx hir::Expr,\n+                       op: hir::BinOp,\n+                       lhs_expr: &'gcx hir::Expr,\n+                       rhs_expr: &'gcx hir::Expr)\n+    {\n+        let tcx = self.tcx;\n+\n+        debug!(\"check_binop(expr.id={}, expr={:?}, op={:?}, lhs_expr={:?}, rhs_expr={:?})\",\n+               expr.id,\n+               expr,\n+               op,\n+               lhs_expr,\n+               rhs_expr);\n+\n+        self.check_expr(lhs_expr);\n+        let lhs_ty = self.resolve_type_vars_with_obligations(self.expr_ty(lhs_expr));\n+\n+        match BinOpCategory::from(op) {\n+            BinOpCategory::Shortcircuit => {\n+                // && and || are a simple case.\n+                self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n+                self.check_expr_coercable_to_type(rhs_expr, tcx.mk_bool());\n+                self.write_ty(expr.id, tcx.mk_bool());\n             }\n+            _ => {\n+                // Otherwise, we always treat operators as if they are\n+                // overloaded. This is the way to be most flexible w/r/t\n+                // types that get inferred.\n+                let (rhs_ty, return_ty) =\n+                    self.check_overloaded_binop(expr, lhs_expr, lhs_ty,\n+                                                rhs_expr, op, IsAssign::No);\n+\n+                // Supply type inference hints if relevant. Probably these\n+                // hints should be enforced during select as part of the\n+                // `consider_unification_despite_ambiguity` routine, but this\n+                // more convenient for now.\n+                //\n+                // The basic idea is to help type inference by taking\n+                // advantage of things we know about how the impls for\n+                // scalar types are arranged. This is important in a\n+                // scenario like `1_u32 << 2`, because it lets us quickly\n+                // deduce that the result type should be `u32`, even\n+                // though we don't know yet what type 2 has and hence\n+                // can't pin this down to a specific impl.\n+                let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n+                if\n+                    !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() &&\n+                    is_builtin_binop(lhs_ty, rhs_ty, op)\n+                {\n+                    let builtin_return_ty =\n+                        self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n+                    self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n+                }\n \n-            self.write_ty(expr.id, return_ty);\n+                self.write_ty(expr.id, return_ty);\n+            }\n         }\n     }\n-}\n \n-fn enforce_builtin_binop_types(&self,\n-                               lhs_expr: &'gcx hir::Expr,\n-                               lhs_ty: Ty<'tcx>,\n-                               rhs_expr: &'gcx hir::Expr,\n-                               rhs_ty: Ty<'tcx>,\n-                               op: hir::BinOp)\n-                               -> Ty<'tcx>\n-{\n-    debug_assert!(is_builtin_binop(lhs_ty, rhs_ty, op));\n-\n-    let tcx = self.tcx;\n-    match BinOpCategory::from(op) {\n-        BinOpCategory::Shortcircuit => {\n-            self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n-            self.demand_suptype(rhs_expr.span, tcx.mk_bool(), rhs_ty);\n-            tcx.mk_bool()\n-        }\n+    fn enforce_builtin_binop_types(&self,\n+                                   lhs_expr: &'gcx hir::Expr,\n+                                   lhs_ty: Ty<'tcx>,\n+                                   rhs_expr: &'gcx hir::Expr,\n+                                   rhs_ty: Ty<'tcx>,\n+                                   op: hir::BinOp)\n+                                   -> Ty<'tcx>\n+    {\n+        debug_assert!(is_builtin_binop(lhs_ty, rhs_ty, op));\n+\n+        let tcx = self.tcx;\n+        match BinOpCategory::from(op) {\n+            BinOpCategory::Shortcircuit => {\n+                self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n+                self.demand_suptype(rhs_expr.span, tcx.mk_bool(), rhs_ty);\n+                tcx.mk_bool()\n+            }\n \n-        BinOpCategory::Shift => {\n-            // result type is same as LHS always\n-            lhs_ty\n-        }\n+            BinOpCategory::Shift => {\n+                // result type is same as LHS always\n+                lhs_ty\n+            }\n \n-        BinOpCategory::Math |\n-        BinOpCategory::Bitwise => {\n-            // both LHS and RHS and result will have the same type\n-            self.demand_suptype(rhs_expr.span, lhs_ty, rhs_ty);\n-            lhs_ty\n-        }\n+            BinOpCategory::Math |\n+            BinOpCategory::Bitwise => {\n+                // both LHS and RHS and result will have the same type\n+                self.demand_suptype(rhs_expr.span, lhs_ty, rhs_ty);\n+                lhs_ty\n+            }\n \n-        BinOpCategory::Comparison => {\n-            // both LHS and RHS and result will have the same type\n-            self.demand_suptype(rhs_expr.span, lhs_ty, rhs_ty);\n-            tcx.mk_bool()\n+            BinOpCategory::Comparison => {\n+                // both LHS and RHS and result will have the same type\n+                self.demand_suptype(rhs_expr.span, lhs_ty, rhs_ty);\n+                tcx.mk_bool()\n+            }\n         }\n     }\n-}\n \n-fn check_overloaded_binop(&self,\n-                          expr: &'gcx hir::Expr,\n-                          lhs_expr: &'gcx hir::Expr,\n-                          lhs_ty: Ty<'tcx>,\n-                          rhs_expr: &'gcx hir::Expr,\n-                          op: hir::BinOp,\n-                          is_assign: IsAssign)\n-                          -> (Ty<'tcx>, Ty<'tcx>)\n-{\n-    debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={:?}, is_assign={:?})\",\n-           expr.id,\n-           lhs_ty,\n-           is_assign);\n-\n-    let (name, trait_def_id) = self.name_and_trait_def_id(op, is_assign);\n-\n-    // NB: As we have not yet type-checked the RHS, we don't have the\n-    // type at hand. Make a variable to represent it. The whole reason\n-    // for this indirection is so that, below, we can check the expr\n-    // using this variable as the expected type, which sometimes lets\n-    // us do better coercions than we would be able to do otherwise,\n-    // particularly for things like `String + &String`.\n-    let rhs_ty_var = self.next_ty_var();\n-\n-    let return_ty = match self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n-                                                token::intern(name), trait_def_id,\n-                                                lhs_expr) {\n-        Ok(return_ty) => return_ty,\n-        Err(()) => {\n-            // error types are considered \"builtin\"\n-            if !lhs_ty.references_error() {\n-                if let IsAssign::Yes = is_assign {\n-                    span_err!(self.tcx.sess, lhs_expr.span, E0368,\n-                              \"binary assignment operation `{}=` cannot be applied to type `{}`\",\n-                              op.node.as_str(),\n-                              lhs_ty);\n-                } else {\n-                    let mut err = struct_span_err!(self.tcx.sess, lhs_expr.span, E0369,\n-                        \"binary operation `{}` cannot be applied to type `{}`\",\n-                        op.node.as_str(),\n-                        lhs_ty);\n-                    let missing_trait = match op.node {\n-                        hir::BiAdd    => Some(\"std::ops::Add\"),\n-                        hir::BiSub    => Some(\"std::ops::Sub\"),\n-                        hir::BiMul    => Some(\"std::ops::Mul\"),\n-                        hir::BiDiv    => Some(\"std::ops::Div\"),\n-                        hir::BiRem    => Some(\"std::ops::Rem\"),\n-                        hir::BiBitAnd => Some(\"std::ops::BitAnd\"),\n-                        hir::BiBitOr  => Some(\"std::ops::BitOr\"),\n-                        hir::BiShl    => Some(\"std::ops::Shl\"),\n-                        hir::BiShr    => Some(\"std::ops::Shr\"),\n-                        hir::BiEq | hir::BiNe => Some(\"std::cmp::PartialEq\"),\n-                        hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe =>\n-                            Some(\"std::cmp::PartialOrd\"),\n-                        _             => None\n-                    };\n-\n-                    if let Some(missing_trait) = missing_trait {\n-                        span_note!(&mut err, lhs_expr.span,\n-                                   \"an implementation of `{}` might be missing for `{}`\",\n-                                    missing_trait, lhs_ty);\n+    fn check_overloaded_binop(&self,\n+                              expr: &'gcx hir::Expr,\n+                              lhs_expr: &'gcx hir::Expr,\n+                              lhs_ty: Ty<'tcx>,\n+                              rhs_expr: &'gcx hir::Expr,\n+                              op: hir::BinOp,\n+                              is_assign: IsAssign)\n+                              -> (Ty<'tcx>, Ty<'tcx>)\n+    {\n+        debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={:?}, is_assign={:?})\",\n+               expr.id,\n+               lhs_ty,\n+               is_assign);\n+\n+        let (name, trait_def_id) = self.name_and_trait_def_id(op, is_assign);\n+\n+        // NB: As we have not yet type-checked the RHS, we don't have the\n+        // type at hand. Make a variable to represent it. The whole reason\n+        // for this indirection is so that, below, we can check the expr\n+        // using this variable as the expected type, which sometimes lets\n+        // us do better coercions than we would be able to do otherwise,\n+        // particularly for things like `String + &String`.\n+        let rhs_ty_var = self.next_ty_var();\n+\n+        let return_ty = match self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n+                                                    token::intern(name), trait_def_id,\n+                                                    lhs_expr) {\n+            Ok(return_ty) => return_ty,\n+            Err(()) => {\n+                // error types are considered \"builtin\"\n+                if !lhs_ty.references_error() {\n+                    if let IsAssign::Yes = is_assign {\n+                        span_err!(self.tcx.sess, lhs_expr.span, E0368,\n+                                  \"binary assignment operation `{}=` \\\n+                                   cannot be applied to type `{}`\",\n+                                  op.node.as_str(),\n+                                  lhs_ty);\n+                    } else {\n+                        let mut err = struct_span_err!(self.tcx.sess, lhs_expr.span, E0369,\n+                            \"binary operation `{}` cannot be applied to type `{}`\",\n+                            op.node.as_str(),\n+                            lhs_ty);\n+                        let missing_trait = match op.node {\n+                            hir::BiAdd    => Some(\"std::ops::Add\"),\n+                            hir::BiSub    => Some(\"std::ops::Sub\"),\n+                            hir::BiMul    => Some(\"std::ops::Mul\"),\n+                            hir::BiDiv    => Some(\"std::ops::Div\"),\n+                            hir::BiRem    => Some(\"std::ops::Rem\"),\n+                            hir::BiBitAnd => Some(\"std::ops::BitAnd\"),\n+                            hir::BiBitOr  => Some(\"std::ops::BitOr\"),\n+                            hir::BiShl    => Some(\"std::ops::Shl\"),\n+                            hir::BiShr    => Some(\"std::ops::Shr\"),\n+                            hir::BiEq | hir::BiNe => Some(\"std::cmp::PartialEq\"),\n+                            hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe =>\n+                                Some(\"std::cmp::PartialOrd\"),\n+                            _             => None\n+                        };\n+\n+                        if let Some(missing_trait) = missing_trait {\n+                            span_note!(&mut err, lhs_expr.span,\n+                                       \"an implementation of `{}` might be missing for `{}`\",\n+                                        missing_trait, lhs_ty);\n+                        }\n+                        err.emit();\n                     }\n-                    err.emit();\n                 }\n+                self.tcx.types.err\n             }\n-            self.tcx.types.err\n-        }\n-    };\n+        };\n \n-    // see `NB` above\n-    self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n+        // see `NB` above\n+        self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n \n-    (rhs_ty_var, return_ty)\n-}\n+        (rhs_ty_var, return_ty)\n+    }\n \n-pub fn check_user_unop(&self,\n-                       op_str: &str,\n-                       mname: &str,\n-                       trait_did: Option<DefId>,\n-                       ex: &'gcx hir::Expr,\n-                       operand_expr: &'gcx hir::Expr,\n-                       operand_ty: Ty<'tcx>,\n-                       op: hir::UnOp)\n-                       -> Ty<'tcx>\n-{\n-    assert!(op.is_by_value());\n-    match self.lookup_op_method(ex, operand_ty, vec![],\n-                                token::intern(mname), trait_did,\n-                                operand_expr) {\n-        Ok(t) => t,\n-        Err(()) => {\n-            self.type_error_message(ex.span, |actual| {\n-                format!(\"cannot apply unary operator `{}` to type `{}`\",\n-                        op_str, actual)\n-            }, operand_ty, None);\n-            self.tcx.types.err\n+    pub fn check_user_unop(&self,\n+                           op_str: &str,\n+                           mname: &str,\n+                           trait_did: Option<DefId>,\n+                           ex: &'gcx hir::Expr,\n+                           operand_expr: &'gcx hir::Expr,\n+                           operand_ty: Ty<'tcx>,\n+                           op: hir::UnOp)\n+                           -> Ty<'tcx>\n+    {\n+        assert!(op.is_by_value());\n+        match self.lookup_op_method(ex, operand_ty, vec![],\n+                                    token::intern(mname), trait_did,\n+                                    operand_expr) {\n+            Ok(t) => t,\n+            Err(()) => {\n+                self.type_error_message(ex.span, |actual| {\n+                    format!(\"cannot apply unary operator `{}` to type `{}`\",\n+                            op_str, actual)\n+                }, operand_ty, None);\n+                self.tcx.types.err\n+            }\n         }\n     }\n-}\n \n-fn name_and_trait_def_id(&self,\n-                         op: hir::BinOp,\n-                         is_assign: IsAssign)\n-                         -> (&'static str, Option<DefId>) {\n-    let lang = &self.tcx.lang_items;\n-\n-    if let IsAssign::Yes = is_assign {\n-        match op.node {\n-            hir::BiAdd => (\"add_assign\", lang.add_assign_trait()),\n-            hir::BiSub => (\"sub_assign\", lang.sub_assign_trait()),\n-            hir::BiMul => (\"mul_assign\", lang.mul_assign_trait()),\n-            hir::BiDiv => (\"div_assign\", lang.div_assign_trait()),\n-            hir::BiRem => (\"rem_assign\", lang.rem_assign_trait()),\n-            hir::BiBitXor => (\"bitxor_assign\", lang.bitxor_assign_trait()),\n-            hir::BiBitAnd => (\"bitand_assign\", lang.bitand_assign_trait()),\n-            hir::BiBitOr => (\"bitor_assign\", lang.bitor_assign_trait()),\n-            hir::BiShl => (\"shl_assign\", lang.shl_assign_trait()),\n-            hir::BiShr => (\"shr_assign\", lang.shr_assign_trait()),\n-            hir::BiLt | hir::BiLe | hir::BiGe | hir::BiGt | hir::BiEq | hir::BiNe | hir::BiAnd |\n-            hir::BiOr => {\n-                span_bug!(op.span,\n-                          \"impossible assignment operation: {}=\",\n-                          op.node.as_str())\n+    fn name_and_trait_def_id(&self,\n+                             op: hir::BinOp,\n+                             is_assign: IsAssign)\n+                             -> (&'static str, Option<DefId>) {\n+        let lang = &self.tcx.lang_items;\n+\n+        if let IsAssign::Yes = is_assign {\n+            match op.node {\n+                hir::BiAdd => (\"add_assign\", lang.add_assign_trait()),\n+                hir::BiSub => (\"sub_assign\", lang.sub_assign_trait()),\n+                hir::BiMul => (\"mul_assign\", lang.mul_assign_trait()),\n+                hir::BiDiv => (\"div_assign\", lang.div_assign_trait()),\n+                hir::BiRem => (\"rem_assign\", lang.rem_assign_trait()),\n+                hir::BiBitXor => (\"bitxor_assign\", lang.bitxor_assign_trait()),\n+                hir::BiBitAnd => (\"bitand_assign\", lang.bitand_assign_trait()),\n+                hir::BiBitOr => (\"bitor_assign\", lang.bitor_assign_trait()),\n+                hir::BiShl => (\"shl_assign\", lang.shl_assign_trait()),\n+                hir::BiShr => (\"shr_assign\", lang.shr_assign_trait()),\n+                hir::BiLt | hir::BiLe |\n+                hir::BiGe | hir::BiGt |\n+                hir::BiEq | hir::BiNe |\n+                hir::BiAnd | hir::BiOr => {\n+                    span_bug!(op.span,\n+                              \"impossible assignment operation: {}=\",\n+                              op.node.as_str())\n+                }\n             }\n-        }\n-    } else {\n-        match op.node {\n-            hir::BiAdd => (\"add\", lang.add_trait()),\n-            hir::BiSub => (\"sub\", lang.sub_trait()),\n-            hir::BiMul => (\"mul\", lang.mul_trait()),\n-            hir::BiDiv => (\"div\", lang.div_trait()),\n-            hir::BiRem => (\"rem\", lang.rem_trait()),\n-            hir::BiBitXor => (\"bitxor\", lang.bitxor_trait()),\n-            hir::BiBitAnd => (\"bitand\", lang.bitand_trait()),\n-            hir::BiBitOr => (\"bitor\", lang.bitor_trait()),\n-            hir::BiShl => (\"shl\", lang.shl_trait()),\n-            hir::BiShr => (\"shr\", lang.shr_trait()),\n-            hir::BiLt => (\"lt\", lang.ord_trait()),\n-            hir::BiLe => (\"le\", lang.ord_trait()),\n-            hir::BiGe => (\"ge\", lang.ord_trait()),\n-            hir::BiGt => (\"gt\", lang.ord_trait()),\n-            hir::BiEq => (\"eq\", lang.eq_trait()),\n-            hir::BiNe => (\"ne\", lang.eq_trait()),\n-            hir::BiAnd | hir::BiOr => {\n-                span_bug!(op.span, \"&& and || are not overloadable\")\n+        } else {\n+            match op.node {\n+                hir::BiAdd => (\"add\", lang.add_trait()),\n+                hir::BiSub => (\"sub\", lang.sub_trait()),\n+                hir::BiMul => (\"mul\", lang.mul_trait()),\n+                hir::BiDiv => (\"div\", lang.div_trait()),\n+                hir::BiRem => (\"rem\", lang.rem_trait()),\n+                hir::BiBitXor => (\"bitxor\", lang.bitxor_trait()),\n+                hir::BiBitAnd => (\"bitand\", lang.bitand_trait()),\n+                hir::BiBitOr => (\"bitor\", lang.bitor_trait()),\n+                hir::BiShl => (\"shl\", lang.shl_trait()),\n+                hir::BiShr => (\"shr\", lang.shr_trait()),\n+                hir::BiLt => (\"lt\", lang.ord_trait()),\n+                hir::BiLe => (\"le\", lang.ord_trait()),\n+                hir::BiGe => (\"ge\", lang.ord_trait()),\n+                hir::BiGt => (\"gt\", lang.ord_trait()),\n+                hir::BiEq => (\"eq\", lang.eq_trait()),\n+                hir::BiNe => (\"ne\", lang.eq_trait()),\n+                hir::BiAnd | hir::BiOr => {\n+                    span_bug!(op.span, \"&& and || are not overloadable\")\n+                }\n             }\n         }\n     }\n-}\n \n-fn lookup_op_method(&self,\n-                    expr: &'gcx hir::Expr,\n-                    lhs_ty: Ty<'tcx>,\n-                    other_tys: Vec<Ty<'tcx>>,\n-                    opname: ast::Name,\n-                    trait_did: Option<DefId>,\n-                    lhs_expr: &'a hir::Expr)\n-                    -> Result<Ty<'tcx>,()>\n-{\n-    debug!(\"lookup_op_method(expr={:?}, lhs_ty={:?}, opname={:?}, trait_did={:?}, lhs_expr={:?})\",\n-           expr,\n-           lhs_ty,\n-           opname,\n-           trait_did,\n-           lhs_expr);\n-\n-    let method = match trait_did {\n-        Some(trait_did) => {\n-            self.lookup_method_in_trait_adjusted(expr.span,\n-                                                 Some(lhs_expr),\n-                                                 opname,\n-                                                 trait_did,\n-                                                 0,\n-                                                 false,\n-                                                 lhs_ty,\n-                                                 Some(other_tys))\n-        }\n-        None => None\n-    };\n+    fn lookup_op_method(&self,\n+                        expr: &'gcx hir::Expr,\n+                        lhs_ty: Ty<'tcx>,\n+                        other_tys: Vec<Ty<'tcx>>,\n+                        opname: ast::Name,\n+                        trait_did: Option<DefId>,\n+                        lhs_expr: &'a hir::Expr)\n+                        -> Result<Ty<'tcx>,()>\n+    {\n+        debug!(\"lookup_op_method(expr={:?}, lhs_ty={:?}, opname={:?}, \\\n+                                 trait_did={:?}, lhs_expr={:?})\",\n+               expr,\n+               lhs_ty,\n+               opname,\n+               trait_did,\n+               lhs_expr);\n+\n+        let method = match trait_did {\n+            Some(trait_did) => {\n+                self.lookup_method_in_trait_adjusted(expr.span,\n+                                                     Some(lhs_expr),\n+                                                     opname,\n+                                                     trait_did,\n+                                                     0,\n+                                                     false,\n+                                                     lhs_ty,\n+                                                     Some(other_tys))\n+            }\n+            None => None\n+        };\n \n-    match method {\n-        Some(method) => {\n-            let method_ty = method.ty;\n+        match method {\n+            Some(method) => {\n+                let method_ty = method.ty;\n \n-            // HACK(eddyb) Fully qualified path to work around a resolve bug.\n-            let method_call = ::rustc::ty::MethodCall::expr(expr.id);\n-            self.tables.borrow_mut().method_map.insert(method_call, method);\n+                // HACK(eddyb) Fully qualified path to work around a resolve bug.\n+                let method_call = ::rustc::ty::MethodCall::expr(expr.id);\n+                self.tables.borrow_mut().method_map.insert(method_call, method);\n \n-            // extract return type for method; all late bound regions\n-            // should have been instantiated by now\n-            let ret_ty = method_ty.fn_ret();\n-            Ok(self.tcx.no_late_bound_regions(&ret_ty).unwrap().unwrap())\n-        }\n-        None => {\n-            Err(())\n+                // extract return type for method; all late bound regions\n+                // should have been instantiated by now\n+                let ret_ty = method_ty.fn_ret();\n+                Ok(self.tcx.no_late_bound_regions(&ret_ty).unwrap().unwrap())\n+            }\n+            None => {\n+                Err(())\n+            }\n         }\n     }\n }\n-}\n \n // Binary operator categories. These categories summarize the behavior\n // with respect to the builtin operationrs supported."}, {"sha": "7b79f2ec9bfe62a176159c9356ad6dd36ee78a81", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1171, "deletions": 1169, "changes": 2340, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=42eb7032fab11aca9228d42969f471b581444c56"}, {"sha": "19964d736f5925763e0a29d3b3730d20809bae75", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -57,29 +57,29 @@ use rustc::hir::intravisit::{self, Visitor};\n // PUBLIC ENTRY POINTS\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-pub fn closure_analyze_fn(&self, body: &hir::Block) {\n-    let mut seed = SeedBorrowKind::new(self);\n-    seed.visit_block(body);\n-    let closures_with_inferred_kinds = seed.closures_with_inferred_kinds;\n+    pub fn closure_analyze_fn(&self, body: &hir::Block) {\n+        let mut seed = SeedBorrowKind::new(self);\n+        seed.visit_block(body);\n+        let closures_with_inferred_kinds = seed.closures_with_inferred_kinds;\n \n-    let mut adjust = AdjustBorrowKind::new(self, &closures_with_inferred_kinds);\n-    adjust.visit_block(body);\n+        let mut adjust = AdjustBorrowKind::new(self, &closures_with_inferred_kinds);\n+        adjust.visit_block(body);\n \n-    // it's our job to process these.\n-    assert!(self.deferred_call_resolutions.borrow().is_empty());\n-}\n+        // it's our job to process these.\n+        assert!(self.deferred_call_resolutions.borrow().is_empty());\n+    }\n \n-pub fn closure_analyze_const(&self, body: &hir::Expr) {\n-    let mut seed = SeedBorrowKind::new(self);\n-    seed.visit_expr(body);\n-    let closures_with_inferred_kinds = seed.closures_with_inferred_kinds;\n+    pub fn closure_analyze_const(&self, body: &hir::Expr) {\n+        let mut seed = SeedBorrowKind::new(self);\n+        seed.visit_expr(body);\n+        let closures_with_inferred_kinds = seed.closures_with_inferred_kinds;\n \n-    let mut adjust = AdjustBorrowKind::new(self, &closures_with_inferred_kinds);\n-    adjust.visit_expr(body);\n+        let mut adjust = AdjustBorrowKind::new(self, &closures_with_inferred_kinds);\n+        adjust.visit_expr(body);\n \n-    // it's our job to process these.\n-    assert!(self.deferred_call_resolutions.borrow().is_empty());\n-}\n+        // it's our job to process these.\n+        assert!(self.deferred_call_resolutions.borrow().is_empty());\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -288,7 +288,8 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                                upvar_id);\n \n                         // to move out of an upvar, this must be a FnOnce closure\n-                        self.adjust_closure_kind(upvar_id.closure_expr_id, ty::ClosureKind::FnOnce);\n+                        self.adjust_closure_kind(upvar_id.closure_expr_id,\n+                                                 ty::ClosureKind::FnOnce);\n \n                         let upvar_capture_map =\n                             &mut self.fcx.tables.borrow_mut().upvar_capture_map;\n@@ -301,7 +302,8 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                         // must still adjust the kind of the closure\n                         // to be a FnOnce closure to permit moves out\n                         // of the environment.\n-                        self.adjust_closure_kind(upvar_id.closure_expr_id, ty::ClosureKind::FnOnce);\n+                        self.adjust_closure_kind(upvar_id.closure_expr_id,\n+                                                 ty::ClosureKind::FnOnce);\n                     }\n                     mc::NoteNone => {\n                     }\n@@ -423,9 +425,10 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// We infer the borrow_kind with which to borrow upvars in a stack closure. The borrow_kind\n-    /// basically follows a lattice of `imm < unique-imm < mut`, moving from left to right as needed\n-    /// (but never right to left). Here the argument `mutbl` is the borrow_kind that is required by\n+    /// We infer the borrow_kind with which to borrow upvars in a stack closure.\n+    /// The borrow_kind basically follows a lattice of `imm < unique-imm < mut`,\n+    /// moving from left to right as needed (but never right to left).\n+    /// Here the argument `mutbl` is the borrow_kind that is required by\n     /// some particular use.\n     fn adjust_upvar_borrow_kind(&self,\n                                 upvar_id: ty::UpvarId,"}, {"sha": "e0a34189773b13d87eafd3b604590220ae76492a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -576,46 +576,46 @@ struct AdtField<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-fn struct_variant(&self, struct_def: &hir::VariantData) -> AdtVariant<'tcx> {\n-    let fields =\n-        struct_def.fields().iter()\n-        .map(|field| {\n-            let field_ty = self.tcx.node_id_to_type(field.id);\n-            let field_ty = self.instantiate_type_scheme(field.span,\n-                                                        &self.parameter_environment\n-                                                             .free_substs,\n-                                                        &field_ty);\n-            AdtField { ty: field_ty, span: field.span }\n-        })\n-        .collect();\n-    AdtVariant { fields: fields }\n-}\n+    fn struct_variant(&self, struct_def: &hir::VariantData) -> AdtVariant<'tcx> {\n+        let fields =\n+            struct_def.fields().iter()\n+            .map(|field| {\n+                let field_ty = self.tcx.node_id_to_type(field.id);\n+                let field_ty = self.instantiate_type_scheme(field.span,\n+                                                            &self.parameter_environment\n+                                                                 .free_substs,\n+                                                            &field_ty);\n+                AdtField { ty: field_ty, span: field.span }\n+            })\n+            .collect();\n+        AdtVariant { fields: fields }\n+    }\n \n-fn enum_variants(&self, enum_def: &hir::EnumDef) -> Vec<AdtVariant<'tcx>> {\n-    enum_def.variants.iter()\n-        .map(|variant| self.struct_variant(&variant.node.data))\n-        .collect()\n-}\n+    fn enum_variants(&self, enum_def: &hir::EnumDef) -> Vec<AdtVariant<'tcx>> {\n+        enum_def.variants.iter()\n+            .map(|variant| self.struct_variant(&variant.node.data))\n+            .collect()\n+    }\n \n-fn impl_implied_bounds(&self, impl_def_id: DefId, span: Span) -> Vec<Ty<'tcx>> {\n-    let free_substs = &self.parameter_environment.free_substs;\n-    match self.tcx.impl_trait_ref(impl_def_id) {\n-        Some(ref trait_ref) => {\n-            // Trait impl: take implied bounds from all types that\n-            // appear in the trait reference.\n-            let trait_ref = self.instantiate_type_scheme(span, free_substs, trait_ref);\n-            trait_ref.substs.types.as_slice().to_vec()\n-        }\n+    fn impl_implied_bounds(&self, impl_def_id: DefId, span: Span) -> Vec<Ty<'tcx>> {\n+        let free_substs = &self.parameter_environment.free_substs;\n+        match self.tcx.impl_trait_ref(impl_def_id) {\n+            Some(ref trait_ref) => {\n+                // Trait impl: take implied bounds from all types that\n+                // appear in the trait reference.\n+                let trait_ref = self.instantiate_type_scheme(span, free_substs, trait_ref);\n+                trait_ref.substs.types.as_slice().to_vec()\n+            }\n \n-        None => {\n-            // Inherent impl: take implied bounds from the self type.\n-            let self_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n-            let self_ty = self.instantiate_type_scheme(span, free_substs, &self_ty);\n-            vec![self_ty]\n+            None => {\n+                // Inherent impl: take implied bounds from the self type.\n+                let self_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n+                let self_ty = self.instantiate_type_scheme(span, free_substs, &self_ty);\n+                vec![self_ty]\n+            }\n         }\n     }\n }\n-}\n \n fn error_192(ccx: &CrateCtxt, span: Span) {\n     span_err!(ccx.tcx.sess, span, E0192,"}, {"sha": "e6500747c05b3e775a2c86de0c6dd2555e2b0a7a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -35,35 +35,35 @@ use rustc::hir;\n // Entry point functions\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-pub fn resolve_type_vars_in_expr(&self, e: &hir::Expr) {\n-    assert_eq!(self.writeback_errors.get(), false);\n-    let mut wbcx = WritebackCx::new(self);\n-    wbcx.visit_expr(e);\n-    wbcx.visit_upvar_borrow_map();\n-    wbcx.visit_closures();\n-    wbcx.visit_liberated_fn_sigs();\n-    wbcx.visit_fru_field_types();\n-}\n+    pub fn resolve_type_vars_in_expr(&self, e: &hir::Expr) {\n+        assert_eq!(self.writeback_errors.get(), false);\n+        let mut wbcx = WritebackCx::new(self);\n+        wbcx.visit_expr(e);\n+        wbcx.visit_upvar_borrow_map();\n+        wbcx.visit_closures();\n+        wbcx.visit_liberated_fn_sigs();\n+        wbcx.visit_fru_field_types();\n+    }\n \n-pub fn resolve_type_vars_in_fn(&self, decl: &hir::FnDecl, blk: &hir::Block) {\n-    assert_eq!(self.writeback_errors.get(), false);\n-    let mut wbcx = WritebackCx::new(self);\n-    wbcx.visit_block(blk);\n-    for arg in &decl.inputs {\n-        wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n-        wbcx.visit_pat(&arg.pat);\n-\n-        // Privacy needs the type for the whole pattern, not just each binding\n-        if !pat_util::pat_is_binding(&self.tcx.def_map.borrow(), &arg.pat) {\n-            wbcx.visit_node_id(ResolvingPattern(arg.pat.span),\n-                               arg.pat.id);\n+    pub fn resolve_type_vars_in_fn(&self, decl: &hir::FnDecl, blk: &hir::Block) {\n+        assert_eq!(self.writeback_errors.get(), false);\n+        let mut wbcx = WritebackCx::new(self);\n+        wbcx.visit_block(blk);\n+        for arg in &decl.inputs {\n+            wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n+            wbcx.visit_pat(&arg.pat);\n+\n+            // Privacy needs the type for the whole pattern, not just each binding\n+            if !pat_util::pat_is_binding(&self.tcx.def_map.borrow(), &arg.pat) {\n+                wbcx.visit_node_id(ResolvingPattern(arg.pat.span),\n+                                   arg.pat.id);\n+            }\n         }\n+        wbcx.visit_upvar_borrow_map();\n+        wbcx.visit_closures();\n+        wbcx.visit_liberated_fn_sigs();\n+        wbcx.visit_fru_field_types();\n     }\n-    wbcx.visit_upvar_borrow_map();\n-    wbcx.visit_closures();\n-    wbcx.visit_liberated_fn_sigs();\n-    wbcx.visit_fru_field_types();\n-}\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "8bee0467f11b3cd7f3688d42f2e59ea1e3f28b16", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42eb7032fab11aca9228d42969f471b581444c56/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=42eb7032fab11aca9228d42969f471b581444c56", "patch": "@@ -66,39 +66,39 @@ impl<'a, 'gcx, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, '\n \n impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n-// Returns the def ID of the base type, if there is one.\n-fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n-    match ty.sty {\n-        TyEnum(def, _) |\n-        TyStruct(def, _) => {\n-            Some(def.did)\n-        }\n+    // Returns the def ID of the base type, if there is one.\n+    fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n+        match ty.sty {\n+            TyEnum(def, _) |\n+            TyStruct(def, _) => {\n+                Some(def.did)\n+            }\n \n-        TyTrait(ref t) => {\n-            Some(t.principal_def_id())\n-        }\n+            TyTrait(ref t) => {\n+                Some(t.principal_def_id())\n+            }\n \n-        TyBox(_) => {\n-            self.inference_context.tcx.lang_items.owned_box()\n-        }\n+            TyBox(_) => {\n+                self.inference_context.tcx.lang_items.owned_box()\n+            }\n \n-        TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-        TyStr | TyArray(..) | TySlice(..) | TyFnDef(..) | TyFnPtr(_) |\n-        TyTuple(..) | TyParam(..) | TyError |\n-        TyRawPtr(_) | TyRef(_, _) | TyProjection(..) => {\n-            None\n-        }\n+            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n+            TyStr | TyArray(..) | TySlice(..) | TyFnDef(..) | TyFnPtr(_) |\n+            TyTuple(..) | TyParam(..) | TyError |\n+            TyRawPtr(_) | TyRef(_, _) | TyProjection(..) => {\n+                None\n+            }\n \n-        TyInfer(..) | TyClosure(..) => {\n-            // `ty` comes from a user declaration so we should only expect types\n-            // that the user can type\n-            span_bug!(\n-                span,\n-                \"coherence encountered unexpected type searching for base type: {}\",\n-                ty);\n+            TyInfer(..) | TyClosure(..) => {\n+                // `ty` comes from a user declaration so we should only expect types\n+                // that the user can type\n+                span_bug!(\n+                    span,\n+                    \"coherence encountered unexpected type searching for base type: {}\",\n+                    ty);\n+            }\n         }\n     }\n-}\n \n     fn check(&self) {\n         // Check implementations and traits. This populates the tables"}]}