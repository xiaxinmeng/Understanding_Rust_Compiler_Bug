{"sha": "56be2afec56c6c958b3185a4ce8307d13fb8bf2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2YmUyYWZlYzU2YzZjOTU4YjMxODVhNGNlODMwN2QxM2ZiOGJmMmY=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-13T22:06:52Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-13T22:51:31Z"}, "message": "Remove `Iter` and `SparseIter` in indexed_set.rs.\n\nBecause they're just thin wrappers around `BitIter` and `slice::Iter`.", "tree": {"sha": "cc51c0061edcb803b230cc97ba9d8cb1059aaac1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc51c0061edcb803b230cc97ba9d8cb1059aaac1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56be2afec56c6c958b3185a4ce8307d13fb8bf2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56be2afec56c6c958b3185a4ce8307d13fb8bf2f", "html_url": "https://github.com/rust-lang/rust/commit/56be2afec56c6c958b3185a4ce8307d13fb8bf2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56be2afec56c6c958b3185a4ce8307d13fb8bf2f/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b697409f10e70558ef72d39eee4a5f7af60cf16b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b697409f10e70558ef72d39eee4a5f7af60cf16b", "html_url": "https://github.com/rust-lang/rust/commit/b697409f10e70558ef72d39eee4a5f7af60cf16b"}], "stats": {"total": 53, "additions": 13, "deletions": 40}, "files": [{"sha": "5ba8c150e1fcb7a30a9793bca5b3b9b1cfd41c53", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/56be2afec56c6c958b3185a4ce8307d13fb8bf2f/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56be2afec56c6c958b3185a4ce8307d13fb8bf2f/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=56be2afec56c6c958b3185a4ce8307d13fb8bf2f", "patch": "@@ -138,10 +138,8 @@ impl<T: Idx> IdxSet<T> {\n         bitwise(self.words_mut(), other.words(), &Intersect)\n     }\n \n-    pub fn iter(&self) -> Iter<T> {\n-        Iter {\n-            iter: self.0.iter()\n-        }\n+    pub fn iter(&self) -> BitIter<T> {\n+        self.0.iter()\n     }\n }\n \n@@ -157,18 +155,6 @@ impl<T: Idx> SubtractFromIdxSet<T> for IdxSet<T> {\n     }\n }\n \n-pub struct Iter<'a, T: Idx> {\n-    iter: BitIter<'a, T>\n-}\n-\n-impl<'a, T: Idx> Iterator for Iter<'a, T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.iter.next()\n-    }\n-}\n-\n const SPARSE_MAX: usize = 8;\n \n /// A sparse index set with a maximum of SPARSE_MAX elements. Used by\n@@ -221,10 +207,8 @@ impl<T: Idx> SparseIdxSet<T> {\n         dense\n     }\n \n-    fn iter(&self) -> SparseIter<T> {\n-        SparseIter {\n-            iter: self.0.iter(),\n-        }\n+    fn iter(&self) -> slice::Iter<T> {\n+        self.0.iter()\n     }\n }\n \n@@ -248,18 +232,6 @@ impl<T: Idx> SubtractFromIdxSet<T> for SparseIdxSet<T> {\n     }\n }\n \n-pub struct SparseIter<'a, T: Idx> {\n-    iter: slice::Iter<'a, T>,\n-}\n-\n-impl<'a, T: Idx> Iterator for SparseIter<'a, T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.iter.next().map(|e| *e)\n-    }\n-}\n-\n /// Like IdxSet, but with a hybrid representation: sparse when there are few\n /// elements in the set, but dense when there are many. It's especially\n /// efficient for sets that typically have a small number of elements, but a\n@@ -370,16 +342,16 @@ impl<T: Idx> SubtractFromIdxSet<T> for HybridIdxSet<T> {\n }\n \n pub enum HybridIter<'a, T: Idx> {\n-    Sparse(SparseIter<'a, T>),\n-    Dense(Iter<'a, T>),\n+    Sparse(slice::Iter<'a, T>),\n+    Dense(BitIter<'a, T>),\n }\n \n impl<'a, T: Idx> Iterator for HybridIter<'a, T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> {\n         match self {\n-            HybridIter::Sparse(sparse) => sparse.next(),\n+            HybridIter::Sparse(sparse) => sparse.next().map(|e| *e),\n             HybridIter::Dense(dense) => dense.next(),\n         }\n     }"}, {"sha": "a4900ab57f58861d37043996794cd322e66e2b0d", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56be2afec56c6c958b3185a4ce8307d13fb8bf2f/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56be2afec56c6c958b3185a4ce8307d13fb8bf2f/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=56be2afec56c6c958b3185a4ce8307d13fb8bf2f", "patch": "@@ -15,7 +15,7 @@\n \n use rustc::mir::{BasicBlock, Location};\n use rustc::ty::RegionVid;\n-use rustc_data_structures::indexed_set::Iter;\n+use rustc_data_structures::bitvec::BitIter;\n \n use borrow_check::location::LocationIndex;\n \n@@ -67,7 +67,7 @@ impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    crate fn with_outgoing_borrows(&self, op: impl FnOnce(Iter<BorrowIndex>)) {\n+    crate fn with_outgoing_borrows(&self, op: impl FnOnce(BitIter<BorrowIndex>)) {\n         self.borrows.with_iter_outgoing(op)\n     }\n }"}, {"sha": "39643af77a17845306d25780004dabddb36221f8", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/56be2afec56c6c958b3185a4ce8307d13fb8bf2f/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56be2afec56c6c958b3185a4ce8307d13fb8bf2f/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=56be2afec56c6c958b3185a4ce8307d13fb8bf2f", "patch": "@@ -12,7 +12,8 @@\n //! locations.\n \n use rustc::mir::{BasicBlock, Location};\n-use rustc_data_structures::indexed_set::{HybridIdxSet, IdxSet, Iter};\n+use rustc_data_structures::bitvec::BitIter;\n+use rustc_data_structures::indexed_set::{HybridIdxSet, IdxSet};\n \n use dataflow::{BitDenotation, BlockSets, DataflowResults};\n use dataflow::move_paths::{HasMoveData, MovePathIndex};\n@@ -125,7 +126,7 @@ where\n     }\n \n     /// Returns an iterator over the elements present in the current state.\n-    pub fn iter_incoming(&self) -> iter::Peekable<Iter<BD::Idx>> {\n+    pub fn iter_incoming(&self) -> iter::Peekable<BitIter<BD::Idx>> {\n         self.curr_state.iter().peekable()\n     }\n \n@@ -134,7 +135,7 @@ where\n     /// Invokes `f` with an iterator over the resulting state.\n     pub fn with_iter_outgoing<F>(&self, f: F)\n     where\n-        F: FnOnce(Iter<BD::Idx>),\n+        F: FnOnce(BitIter<BD::Idx>),\n     {\n         let mut curr_state = self.curr_state.clone();\n         curr_state.union(&self.stmt_gen);"}]}