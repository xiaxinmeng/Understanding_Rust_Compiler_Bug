{"sha": "09de34c10760d31e0781cb506b5b41c649b53e69", "node_id": "C_kwDOAAsO6NoAKDA5ZGUzNGMxMDc2MGQzMWUwNzgxY2I1MDZiNWI0MWM2NDliNTNlNjk", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-10-21T05:11:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-21T05:11:01Z"}, "message": "Rollup merge of #86984 - Smittyvb:ipv4-octal-zero, r=m-ou-se\n\nReject octal zeros in IPv4 addresses\n\nThis fixes #86964 by rejecting octal zeros in IP addresses, such that `192.168.00.00000000` is rejected with a parse error, since having leading zeros in front of another zero indicates it is a zero written in octal notation, which is not allowed in the strict mode specified by RFC 6943 3.1.1. Octal rejection was implemented in #83652, but due to the way it was implemented octal zeros were still allowed.", "tree": {"sha": "d12ccdd84741ef6a768f04529f1144915d571b04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d12ccdd84741ef6a768f04529f1144915d571b04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09de34c10760d31e0781cb506b5b41c649b53e69", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhcPZlCRBK7hj4Ov3rIwAAz0kIAF3hSFgJpaOUHBfHde/FpVHe\nxIQY+kbA/8ujZIyZup/8l8GklcnxOuR2DLsCxs2q6JPOVIEtZwh9jfHhgjNCi4N7\nEV9gCCV0VSIIbUQ4JFQf0G9xdd2XMAFlQ20aF89vpZh20EMiHBSNvEa9E8JQOcvV\nG+xfafmOXty6GXaeyYE4mMVtulIZyI4FuxYsUZdy8ncoWDKEShKHFZz6BQ6qoSuC\nDuMI0RaM+61edNQ+hbSAtHs6XKCas2FcC1K9NhPivRs6fT2oVVgb3p3x+37IfLmC\nwSq1XfuJw4HocdFyxOXNdJS3XwlH7r8pN0Udv3tKQi6ZQ1nXJpW0IMuFVGe8MOI=\n=W0Dj\n-----END PGP SIGNATURE-----\n", "payload": "tree d12ccdd84741ef6a768f04529f1144915d571b04\nparent 4626184cafa827e13cc7a71b183a704ee0ec5930\nparent 403d269f20c9b1d71efccf1e95ef76470dd7ebe5\nauthor Yuki Okushi <jtitor@2k36.org> 1634793061 +0900\ncommitter GitHub <noreply@github.com> 1634793061 +0900\n\nRollup merge of #86984 - Smittyvb:ipv4-octal-zero, r=m-ou-se\n\nReject octal zeros in IPv4 addresses\n\nThis fixes #86964 by rejecting octal zeros in IP addresses, such that `192.168.00.00000000` is rejected with a parse error, since having leading zeros in front of another zero indicates it is a zero written in octal notation, which is not allowed in the strict mode specified by RFC 6943 3.1.1. Octal rejection was implemented in #83652, but due to the way it was implemented octal zeros were still allowed.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09de34c10760d31e0781cb506b5b41c649b53e69", "html_url": "https://github.com/rust-lang/rust/commit/09de34c10760d31e0781cb506b5b41c649b53e69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09de34c10760d31e0781cb506b5b41c649b53e69/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4626184cafa827e13cc7a71b183a704ee0ec5930", "url": "https://api.github.com/repos/rust-lang/rust/commits/4626184cafa827e13cc7a71b183a704ee0ec5930", "html_url": "https://github.com/rust-lang/rust/commit/4626184cafa827e13cc7a71b183a704ee0ec5930"}, {"sha": "403d269f20c9b1d71efccf1e95ef76470dd7ebe5", "url": "https://api.github.com/repos/rust-lang/rust/commits/403d269f20c9b1d71efccf1e95ef76470dd7ebe5", "html_url": "https://github.com/rust-lang/rust/commit/403d269f20c9b1d71efccf1e95ef76470dd7ebe5"}], "stats": {"total": 42, "additions": 32, "deletions": 10}, "files": [{"sha": "c080f783cbb36d76abfbb96eedacf446b44ff9eb", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09de34c10760d31e0781cb506b5b41c649b53e69/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09de34c10760d31e0781cb506b5b41c649b53e69/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=09de34c10760d31e0781cb506b5b41c649b53e69", "patch": "@@ -59,7 +59,8 @@ pub enum IpAddr {\n ///\n /// `Ipv4Addr` provides a [`FromStr`] implementation. The four octets are in decimal\n /// notation, divided by `.` (this is called \"dot-decimal notation\").\n-/// Notably, octal numbers and hexadecimal numbers are not allowed per [IETF RFC 6943].\n+/// Notably, octal numbers (which are indicated with a leading `0`) and hexadecimal numbers (which\n+/// are indicated with a leading `0x`) are not allowed per [IETF RFC 6943].\n ///\n /// [IETF RFC 6943]: https://tools.ietf.org/html/rfc6943#section-3.1.1\n /// [`FromStr`]: crate::str::FromStr\n@@ -72,6 +73,9 @@ pub enum IpAddr {\n /// let localhost = Ipv4Addr::new(127, 0, 0, 1);\n /// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost));\n /// assert_eq!(localhost.is_loopback(), true);\n+/// assert!(\"012.004.002.000\".parse::<Ipv4Addr>().is_err()); // all octets are in octal\n+/// assert!(\"0000000.0.0.0\".parse::<Ipv4Addr>().is_err()); // first octet is a zero in octal\n+/// assert!(\"0xcb.0x0.0x71.0x00\".parse::<Ipv4Addr>().is_err()); // all octets are in hex\n /// ```\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "17581f330266dc7394f8b3c42138becb861816a6", "filename": "library/std/src/net/ip/tests.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09de34c10760d31e0781cb506b5b41c649b53e69/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09de34c10760d31e0781cb506b5b41c649b53e69/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs?ref=09de34c10760d31e0781cb506b5b41c649b53e69", "patch": "@@ -20,6 +20,14 @@ fn test_from_str_ipv4() {\n     // no number between dots\n     let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n     assert_eq!(None, none);\n+    // octal\n+    let none: Option<Ipv4Addr> = \"255.0.0.01\".parse().ok();\n+    assert_eq!(None, none);\n+    // octal zero\n+    let none: Option<Ipv4Addr> = \"255.0.0.00\".parse().ok();\n+    assert_eq!(None, none);\n+    let none: Option<Ipv4Addr> = \"255.0.00.0\".parse().ok();\n+    assert_eq!(None, none);\n }\n \n #[test]"}, {"sha": "4e16a55edece26a1b71d9acf7578d712d8efa0ca", "filename": "library/std/src/net/parser.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/09de34c10760d31e0781cb506b5b41c649b53e69/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09de34c10760d31e0781cb506b5b41c649b53e69/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs?ref=09de34c10760d31e0781cb506b5b41c649b53e69", "patch": "@@ -111,10 +111,12 @@ impl<'a> Parser<'a> {\n         &mut self,\n         radix: u32,\n         max_digits: Option<usize>,\n+        allow_zero_prefix: bool,\n     ) -> Option<T> {\n         self.read_atomically(move |p| {\n             let mut result = T::ZERO;\n             let mut digit_count = 0;\n+            let has_leading_zero = p.peek_char() == Some('0');\n \n             while let Some(digit) = p.read_atomically(|p| p.read_char()?.to_digit(radix)) {\n                 result = result.checked_mul(radix)?;\n@@ -127,7 +129,13 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n-            if digit_count == 0 { None } else { Some(result) }\n+            if digit_count == 0 {\n+                None\n+            } else if !allow_zero_prefix && has_leading_zero && digit_count > 1 {\n+                None\n+            } else {\n+                Some(result)\n+            }\n         })\n     }\n \n@@ -140,10 +148,7 @@ impl<'a> Parser<'a> {\n                 *slot = p.read_separator('.', i, |p| {\n                     // Disallow octal number in IP string.\n                     // https://tools.ietf.org/html/rfc6943#section-3.1.1\n-                    match (p.peek_char(), p.read_number(10, None)) {\n-                        (Some('0'), Some(number)) if number != 0 => None,\n-                        (_, number) => number,\n-                    }\n+                    p.read_number(10, Some(3), false)\n                 })?;\n             }\n \n@@ -175,7 +180,7 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n \n-                let group = p.read_separator(':', i, |p| p.read_number(16, Some(4)));\n+                let group = p.read_separator(':', i, |p| p.read_number(16, Some(4), true));\n \n                 match group {\n                     Some(g) => *slot = g,\n@@ -227,15 +232,15 @@ impl<'a> Parser<'a> {\n     fn read_port(&mut self) -> Option<u16> {\n         self.read_atomically(|p| {\n             p.read_given_char(':')?;\n-            p.read_number(10, None)\n+            p.read_number(10, None, true)\n         })\n     }\n \n     /// Read a `%` followed by a scope ID in base 10.\n     fn read_scope_id(&mut self) -> Option<u32> {\n         self.read_atomically(|p| {\n             p.read_given_char('%')?;\n-            p.read_number(10, None)\n+            p.read_number(10, None, true)\n         })\n     }\n \n@@ -281,7 +286,12 @@ impl FromStr for IpAddr {\n impl FromStr for Ipv4Addr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_ipv4_addr())\n+        // don't try to parse if too long\n+        if s.len() > 15 {\n+            Err(AddrParseError(()))\n+        } else {\n+            Parser::new(s).parse_with(|p| p.read_ipv4_addr())\n+        }\n     }\n }\n "}]}