{"sha": "7bc9dec7cf195bc73a88d7c740f9d0bed1019e98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYzlkZWM3Y2YxOTViYzczYTg4ZDdjNzQwZjlkMGJlZDEwMTllOTg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-19T15:33:19Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-19T15:33:19Z"}, "message": "Merge #1553\n\n1553: cleanup casts r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "12e2301c22b893d8f25abd7ded41f8b163e82efa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12e2301c22b893d8f25abd7ded41f8b163e82efa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98", "html_url": "https://github.com/rust-lang/rust/commit/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "8718a47088585bdb411f37d1b7cd1244d7528eaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/8718a47088585bdb411f37d1b7cd1244d7528eaa", "html_url": "https://github.com/rust-lang/rust/commit/8718a47088585bdb411f37d1b7cd1244d7528eaa"}, {"sha": "a6df224f7d3893f5a742b58818eac6c5a953721d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6df224f7d3893f5a742b58818eac6c5a953721d", "html_url": "https://github.com/rust-lang/rust/commit/a6df224f7d3893f5a742b58818eac6c5a953721d"}], "stats": {"total": 1831, "additions": 976, "deletions": 855}, "files": [{"sha": "439e6ec87295af1d669bf49cd44e933503c79c97", "filename": "crates/ra_hir/src/either.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_hir%2Fsrc%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_hir%2Fsrc%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Feither.rs?ref=7bc9dec7cf195bc73a88d7c740f9d0bed1019e98", "patch": "@@ -25,6 +25,12 @@ impl<A, B> Either<A, B> {\n             Either::B(b) => Either::B(f2(b)),\n         }\n     }\n+    pub fn map_a<U, F>(self, f: F) -> Either<U, B>\n+    where\n+        F: FnOnce(A) -> U,\n+    {\n+        self.map(f, |it| it)\n+    }\n     pub fn a(self) -> Option<A> {\n         match self {\n             Either::A(it) => Some(it),"}, {"sha": "66cb9633bbba08e72631e206f8a182c20ef9a947", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=7bc9dec7cf195bc73a88d7c740f9d0bed1019e98", "patch": "@@ -564,11 +564,7 @@ where\n                         .else_branch()\n                         .map(|b| match b {\n                             ast::ElseBranch::Block(it) => self.collect_block(it),\n-                            ast::ElseBranch::IfExpr(elif) => {\n-                                let expr: ast::Expr =\n-                                    ast::Expr::cast(elif.syntax().clone()).unwrap();\n-                                self.collect_expr(expr)\n-                            }\n+                            ast::ElseBranch::IfExpr(elif) => self.collect_expr(elif.into()),\n                         })\n                         .unwrap_or_else(|| self.empty_block());\n                     let placeholder_pat = self.pats.alloc(Pat::Missing);"}, {"sha": "df67d2c393894392a30cd33ee8c245f09f88bc84", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=7bc9dec7cf195bc73a88d7c740f9d0bed1019e98", "patch": "@@ -309,15 +309,11 @@ impl SourceAnalyzer {\n             crate::Resolution::LocalBinding(it) => {\n                 // We get a `PatId` from resolver, but it actually can only\n                 // point at `BindPat`, and not at the arbitrary pattern.\n-                let pat_ptr = self.body_source_map.as_ref()?.pat_syntax(it)?;\n-                let pat_ptr = match pat_ptr {\n-                    Either::A(pat) => {\n-                        let pat: AstPtr<ast::BindPat> =\n-                            pat.cast_checking_kind(|kind| kind == BIND_PAT).unwrap();\n-                        Either::A(pat)\n-                    }\n-                    Either::B(self_param) => Either::B(self_param),\n-                };\n+                let pat_ptr = self\n+                    .body_source_map\n+                    .as_ref()?\n+                    .pat_syntax(it)?\n+                    .map_a(|ptr| ptr.cast::<ast::BindPat>().unwrap());\n                 PathResolution::LocalBinding(pat_ptr)\n             }\n             crate::Resolution::GenericParam(it) => PathResolution::GenericParam(it),"}, {"sha": "4a38197f6ff49073682b58c53da52412bbdaad2f", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=7bc9dec7cf195bc73a88d7c740f9d0bed1019e98", "patch": "@@ -10,7 +10,7 @@ use std::marker::PhantomData;\n \n use crate::{\n     syntax_node::{SyntaxNode, SyntaxNodeChildren, SyntaxToken},\n-    SmolStr,\n+    SmolStr, SyntaxKind,\n };\n \n pub use self::{\n@@ -26,6 +26,8 @@ pub use self::{\n /// the same representation: a pointer to the tree root and a pointer to the\n /// node itself.\n pub trait AstNode: Clone {\n+    fn can_cast(kind: SyntaxKind) -> bool;\n+\n     fn cast(syntax: SyntaxNode) -> Option<Self>\n     where\n         Self: Sized;"}, {"sha": "99fcdbd9ac8d4893461af4963c506ac4038d8ef2", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 939, "deletions": 798, "changes": 1737, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=7bc9dec7cf195bc73a88d7c740f9d0bed1019e98", "patch": "@@ -10,7 +10,7 @@\n #![cfg_attr(rustfmt, rustfmt_skip)]\n \n use crate::{\n-    SyntaxNode, SyntaxKind::*,\n+    SyntaxNode, SyntaxKind::{self, *},\n     ast::{self, AstNode},\n };\n \n@@ -21,12 +21,15 @@ pub struct Alias {\n }\n \n impl AstNode for Alias {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            ALIAS => Some(Alias { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ALIAS => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Alias { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -41,12 +44,15 @@ pub struct ArgList {\n }\n \n impl AstNode for ArgList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            ARG_LIST => Some(ArgList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ARG_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ArgList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -64,12 +70,15 @@ pub struct ArrayExpr {\n }\n \n impl AstNode for ArrayExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            ARRAY_EXPR => Some(ArrayExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ARRAY_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ArrayExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -87,12 +96,15 @@ pub struct ArrayType {\n }\n \n impl AstNode for ArrayType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            ARRAY_TYPE => Some(ArrayType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ARRAY_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ArrayType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -114,12 +126,15 @@ pub struct AssocTypeArg {\n }\n \n impl AstNode for AssocTypeArg {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            ASSOC_TYPE_ARG => Some(AssocTypeArg { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ASSOC_TYPE_ARG => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(AssocTypeArg { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -141,12 +156,15 @@ pub struct Attr {\n }\n \n impl AstNode for Attr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            ATTR => Some(Attr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ATTR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Attr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -164,12 +182,15 @@ pub struct BinExpr {\n }\n \n impl AstNode for BinExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            BIN_EXPR => Some(BinExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            BIN_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(BinExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -183,12 +204,15 @@ pub struct BindPat {\n }\n \n impl AstNode for BindPat {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            BIND_PAT => Some(BindPat { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            BIND_PAT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(BindPat { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -207,12 +231,15 @@ pub struct Block {\n }\n \n impl AstNode for Block {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            BLOCK => Some(Block { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            BLOCK => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Block { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -235,12 +262,15 @@ pub struct BlockExpr {\n }\n \n impl AstNode for BlockExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            BLOCK_EXPR => Some(BlockExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            BLOCK_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(BlockExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -258,12 +288,15 @@ pub struct BreakExpr {\n }\n \n impl AstNode for BreakExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            BREAK_EXPR => Some(BreakExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            BREAK_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(BreakExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -281,12 +314,15 @@ pub struct CallExpr {\n }\n \n impl AstNode for CallExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            CALL_EXPR => Some(CallExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            CALL_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(CallExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -305,12 +341,15 @@ pub struct CastExpr {\n }\n \n impl AstNode for CastExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            CAST_EXPR => Some(CastExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            CAST_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(CastExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -332,12 +371,15 @@ pub struct Condition {\n }\n \n impl AstNode for Condition {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            CONDITION => Some(Condition { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            CONDITION => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Condition { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -359,12 +401,15 @@ pub struct ConstDef {\n }\n \n impl AstNode for ConstDef {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            CONST_DEF => Some(ConstDef { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            CONST_DEF => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ConstDef { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -388,12 +433,15 @@ pub struct ContinueExpr {\n }\n \n impl AstNode for ContinueExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            CONTINUE_EXPR => Some(ContinueExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            CONTINUE_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ContinueExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -407,12 +455,15 @@ pub struct DynTraitType {\n }\n \n impl AstNode for DynTraitType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            DYN_TRAIT_TYPE => Some(DynTraitType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            DYN_TRAIT_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(DynTraitType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -427,12 +478,15 @@ pub struct EnumDef {\n }\n \n impl AstNode for EnumDef {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            ENUM_DEF => Some(EnumDef { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ENUM_DEF => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(EnumDef { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -455,12 +509,15 @@ pub struct EnumVariant {\n }\n \n impl AstNode for EnumVariant {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            ENUM_VARIANT => Some(EnumVariant { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ENUM_VARIANT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(EnumVariant { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -481,12 +538,15 @@ pub struct EnumVariantList {\n }\n \n impl AstNode for EnumVariantList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            ENUM_VARIANT_LIST => Some(EnumVariantList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ENUM_VARIANT_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(EnumVariantList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -503,6 +563,20 @@ pub struct Expr {\n     pub(crate) syntax: SyntaxNode,\n }\n \n+impl AstNode for Expr {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+             | TUPLE_EXPR | ARRAY_EXPR | PAREN_EXPR | PATH_EXPR | LAMBDA_EXPR | IF_EXPR | LOOP_EXPR | FOR_EXPR | WHILE_EXPR | CONTINUE_EXPR | BREAK_EXPR | LABEL | BLOCK_EXPR | RETURN_EXPR | MATCH_EXPR | STRUCT_LIT | CALL_EXPR | INDEX_EXPR | METHOD_CALL_EXPR | FIELD_EXPR | TRY_EXPR | TRY_BLOCK_EXPR | CAST_EXPR | REF_EXPR | PREFIX_EXPR | RANGE_EXPR | BIN_EXPR | LITERAL | MACRO_CALL => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Expr { syntax }) } else { None }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ExprKind {\n     TupleExpr(TupleExpr),\n@@ -536,190 +610,92 @@ pub enum ExprKind {\n     MacroCall(MacroCall),\n }\n impl From<TupleExpr> for Expr {\n-    fn from(n: TupleExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: TupleExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<ArrayExpr> for Expr {\n-    fn from(n: ArrayExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ArrayExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<ParenExpr> for Expr {\n-    fn from(n: ParenExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ParenExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<PathExpr> for Expr {\n-    fn from(n: PathExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: PathExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<LambdaExpr> for Expr {\n-    fn from(n: LambdaExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: LambdaExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<IfExpr> for Expr {\n-    fn from(n: IfExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: IfExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<LoopExpr> for Expr {\n-    fn from(n: LoopExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: LoopExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<ForExpr> for Expr {\n-    fn from(n: ForExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ForExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<WhileExpr> for Expr {\n-    fn from(n: WhileExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: WhileExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<ContinueExpr> for Expr {\n-    fn from(n: ContinueExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ContinueExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<BreakExpr> for Expr {\n-    fn from(n: BreakExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: BreakExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<Label> for Expr {\n-    fn from(n: Label) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: Label) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<BlockExpr> for Expr {\n-    fn from(n: BlockExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: BlockExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<ReturnExpr> for Expr {\n-    fn from(n: ReturnExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ReturnExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<MatchExpr> for Expr {\n-    fn from(n: MatchExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: MatchExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<StructLit> for Expr {\n-    fn from(n: StructLit) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: StructLit) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<CallExpr> for Expr {\n-    fn from(n: CallExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: CallExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<IndexExpr> for Expr {\n-    fn from(n: IndexExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: IndexExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<MethodCallExpr> for Expr {\n-    fn from(n: MethodCallExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: MethodCallExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<FieldExpr> for Expr {\n-    fn from(n: FieldExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: FieldExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<TryExpr> for Expr {\n-    fn from(n: TryExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: TryExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<TryBlockExpr> for Expr {\n-    fn from(n: TryBlockExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: TryBlockExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<CastExpr> for Expr {\n-    fn from(n: CastExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: CastExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<RefExpr> for Expr {\n-    fn from(n: RefExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: RefExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<PrefixExpr> for Expr {\n-    fn from(n: PrefixExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: PrefixExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<RangeExpr> for Expr {\n-    fn from(n: RangeExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: RangeExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<BinExpr> for Expr {\n-    fn from(n: BinExpr) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: BinExpr) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<Literal> for Expr {\n-    fn from(n: Literal) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: Literal) -> Expr { Expr { syntax: n.syntax } }\n }\n impl From<MacroCall> for Expr {\n-    fn from(n: MacroCall) -> Expr {\n-        Expr::cast(n.syntax).unwrap()\n-    }\n-}\n-\n-\n-impl AstNode for Expr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            | TUPLE_EXPR\n-            | ARRAY_EXPR\n-            | PAREN_EXPR\n-            | PATH_EXPR\n-            | LAMBDA_EXPR\n-            | IF_EXPR\n-            | LOOP_EXPR\n-            | FOR_EXPR\n-            | WHILE_EXPR\n-            | CONTINUE_EXPR\n-            | BREAK_EXPR\n-            | LABEL\n-            | BLOCK_EXPR\n-            | RETURN_EXPR\n-            | MATCH_EXPR\n-            | STRUCT_LIT\n-            | CALL_EXPR\n-            | INDEX_EXPR\n-            | METHOD_CALL_EXPR\n-            | FIELD_EXPR\n-            | TRY_EXPR\n-            | TRY_BLOCK_EXPR\n-            | CAST_EXPR\n-            | REF_EXPR\n-            | PREFIX_EXPR\n-            | RANGE_EXPR\n-            | BIN_EXPR\n-            | LITERAL\n-            | MACRO_CALL => Some(Expr { syntax }),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn from(n: MacroCall) -> Expr { Expr { syntax: n.syntax } }\n }\n-\n impl Expr {\n     pub fn kind(&self) -> ExprKind {\n         match self.syntax.kind() {\n@@ -766,12 +742,15 @@ pub struct ExprStmt {\n }\n \n impl AstNode for ExprStmt {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            EXPR_STMT => Some(ExprStmt { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            EXPR_STMT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ExprStmt { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -789,12 +768,15 @@ pub struct ExternCrateItem {\n }\n \n impl AstNode for ExternCrateItem {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            EXTERN_CRATE_ITEM => Some(ExternCrateItem { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            EXTERN_CRATE_ITEM => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ExternCrateItem { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -816,12 +798,15 @@ pub struct FieldExpr {\n }\n \n impl AstNode for FieldExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            FIELD_EXPR => Some(FieldExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            FIELD_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(FieldExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -843,12 +828,15 @@ pub struct FieldPat {\n }\n \n impl AstNode for FieldPat {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            FIELD_PAT => Some(FieldPat { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            FIELD_PAT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(FieldPat { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -867,12 +855,15 @@ pub struct FieldPatList {\n }\n \n impl AstNode for FieldPatList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            FIELD_PAT_LIST => Some(FieldPatList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            FIELD_PAT_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(FieldPatList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -894,12 +885,15 @@ pub struct FnDef {\n }\n \n impl AstNode for FnDef {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            FN_DEF => Some(FnDef { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            FN_DEF => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(FnDef { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -930,12 +924,15 @@ pub struct FnPointerType {\n }\n \n impl AstNode for FnPointerType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            FN_POINTER_TYPE => Some(FnPointerType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            FN_POINTER_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(FnPointerType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -957,12 +954,15 @@ pub struct ForExpr {\n }\n \n impl AstNode for ForExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            FOR_EXPR => Some(ForExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            FOR_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ForExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -985,12 +985,15 @@ pub struct ForType {\n }\n \n impl AstNode for ForType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            FOR_TYPE => Some(ForType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            FOR_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ForType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1008,12 +1011,15 @@ pub struct IfExpr {\n }\n \n impl AstNode for IfExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            IF_EXPR => Some(IfExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            IF_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(IfExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1031,12 +1037,15 @@ pub struct ImplBlock {\n }\n \n impl AstNode for ImplBlock {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            IMPL_BLOCK => Some(ImplBlock { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            IMPL_BLOCK => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ImplBlock { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1055,41 +1064,35 @@ pub struct ImplItem {\n     pub(crate) syntax: SyntaxNode,\n }\n \n+impl AstNode for ImplItem {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+             | FN_DEF | TYPE_ALIAS_DEF | CONST_DEF => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ImplItem { syntax }) } else { None }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ImplItemKind {\n     FnDef(FnDef),\n     TypeAliasDef(TypeAliasDef),\n     ConstDef(ConstDef),\n }\n impl From<FnDef> for ImplItem {\n-    fn from(n: FnDef) -> ImplItem {\n-        ImplItem::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: FnDef) -> ImplItem { ImplItem { syntax: n.syntax } }\n }\n impl From<TypeAliasDef> for ImplItem {\n-    fn from(n: TypeAliasDef) -> ImplItem {\n-        ImplItem::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: TypeAliasDef) -> ImplItem { ImplItem { syntax: n.syntax } }\n }\n impl From<ConstDef> for ImplItem {\n-    fn from(n: ConstDef) -> ImplItem {\n-        ImplItem::cast(n.syntax).unwrap()\n-    }\n-}\n-\n-\n-impl AstNode for ImplItem {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            | FN_DEF\n-            | TYPE_ALIAS_DEF\n-            | CONST_DEF => Some(ImplItem { syntax }),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn from(n: ConstDef) -> ImplItem { ImplItem { syntax: n.syntax } }\n }\n-\n impl ImplItem {\n     pub fn kind(&self) -> ImplItemKind {\n         match self.syntax.kind() {\n@@ -1110,12 +1113,15 @@ pub struct ImplTraitType {\n }\n \n impl AstNode for ImplTraitType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            IMPL_TRAIT_TYPE => Some(ImplTraitType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            IMPL_TRAIT_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ImplTraitType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1130,12 +1136,15 @@ pub struct IndexExpr {\n }\n \n impl AstNode for IndexExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            INDEX_EXPR => Some(IndexExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            INDEX_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(IndexExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1149,12 +1158,15 @@ pub struct ItemList {\n }\n \n impl AstNode for ItemList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            ITEM_LIST => Some(ItemList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ITEM_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ItemList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1174,12 +1186,15 @@ pub struct Label {\n }\n \n impl AstNode for Label {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            LABEL => Some(Label { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            LABEL => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Label { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1193,12 +1208,15 @@ pub struct LambdaExpr {\n }\n \n impl AstNode for LambdaExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            LAMBDA_EXPR => Some(LambdaExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            LAMBDA_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(LambdaExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1220,12 +1238,15 @@ pub struct LetStmt {\n }\n \n impl AstNode for LetStmt {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            LET_STMT => Some(LetStmt { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            LET_STMT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(LetStmt { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1248,12 +1269,15 @@ pub struct LifetimeArg {\n }\n \n impl AstNode for LifetimeArg {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            LIFETIME_ARG => Some(LifetimeArg { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            LIFETIME_ARG => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(LifetimeArg { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1267,12 +1291,15 @@ pub struct LifetimeParam {\n }\n \n impl AstNode for LifetimeParam {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            LIFETIME_PARAM => Some(LifetimeParam { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            LIFETIME_PARAM => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(LifetimeParam { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1287,12 +1314,15 @@ pub struct Literal {\n }\n \n impl AstNode for Literal {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            LITERAL => Some(Literal { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            LITERAL => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Literal { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1306,12 +1336,15 @@ pub struct LiteralPat {\n }\n \n impl AstNode for LiteralPat {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            LITERAL_PAT => Some(LiteralPat { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            LITERAL_PAT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(LiteralPat { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1329,12 +1362,15 @@ pub struct LoopExpr {\n }\n \n impl AstNode for LoopExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            LOOP_EXPR => Some(LoopExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            LOOP_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(LoopExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1349,12 +1385,15 @@ pub struct MacroCall {\n }\n \n impl AstNode for MacroCall {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            MACRO_CALL => Some(MacroCall { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MACRO_CALL => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(MacroCall { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1379,12 +1418,15 @@ pub struct MacroItems {\n }\n \n impl AstNode for MacroItems {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            MACRO_ITEMS => Some(MacroItems { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MACRO_ITEMS => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(MacroItems { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1400,12 +1442,15 @@ pub struct MacroStmts {\n }\n \n impl AstNode for MacroStmts {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            MACRO_STMTS => Some(MacroStmts { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MACRO_STMTS => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(MacroStmts { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1427,12 +1472,15 @@ pub struct MatchArm {\n }\n \n impl AstNode for MatchArm {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            MATCH_ARM => Some(MatchArm { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MATCH_ARM => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(MatchArm { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1459,12 +1507,15 @@ pub struct MatchArmList {\n }\n \n impl AstNode for MatchArmList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            MATCH_ARM_LIST => Some(MatchArmList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MATCH_ARM_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(MatchArmList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1483,12 +1534,15 @@ pub struct MatchExpr {\n }\n \n impl AstNode for MatchExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            MATCH_EXPR => Some(MatchExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MATCH_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(MatchExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1510,12 +1564,15 @@ pub struct MatchGuard {\n }\n \n impl AstNode for MatchGuard {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            MATCH_GUARD => Some(MatchGuard { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MATCH_GUARD => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(MatchGuard { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1533,12 +1590,15 @@ pub struct MethodCallExpr {\n }\n \n impl AstNode for MethodCallExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            METHOD_CALL_EXPR => Some(MethodCallExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            METHOD_CALL_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(MethodCallExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1565,12 +1625,15 @@ pub struct Module {\n }\n \n impl AstNode for Module {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            MODULE => Some(Module { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MODULE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Module { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1591,6 +1654,20 @@ pub struct ModuleItem {\n     pub(crate) syntax: SyntaxNode,\n }\n \n+impl AstNode for ModuleItem {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+             | STRUCT_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | TYPE_ALIAS_DEF | IMPL_BLOCK | USE_ITEM | EXTERN_CRATE_ITEM | CONST_DEF | STATIC_DEF | MODULE => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ModuleItem { syntax }) } else { None }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ModuleItemKind {\n     StructDef(StructDef),\n@@ -1606,82 +1683,38 @@ pub enum ModuleItemKind {\n     Module(Module),\n }\n impl From<StructDef> for ModuleItem {\n-    fn from(n: StructDef) -> ModuleItem {\n-        ModuleItem::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: StructDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }\n }\n impl From<EnumDef> for ModuleItem {\n-    fn from(n: EnumDef) -> ModuleItem {\n-        ModuleItem::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: EnumDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }\n }\n impl From<FnDef> for ModuleItem {\n-    fn from(n: FnDef) -> ModuleItem {\n-        ModuleItem::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: FnDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }\n }\n impl From<TraitDef> for ModuleItem {\n-    fn from(n: TraitDef) -> ModuleItem {\n-        ModuleItem::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: TraitDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }\n }\n impl From<TypeAliasDef> for ModuleItem {\n-    fn from(n: TypeAliasDef) -> ModuleItem {\n-        ModuleItem::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: TypeAliasDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }\n }\n impl From<ImplBlock> for ModuleItem {\n-    fn from(n: ImplBlock) -> ModuleItem {\n-        ModuleItem::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ImplBlock) -> ModuleItem { ModuleItem { syntax: n.syntax } }\n }\n impl From<UseItem> for ModuleItem {\n-    fn from(n: UseItem) -> ModuleItem {\n-        ModuleItem::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: UseItem) -> ModuleItem { ModuleItem { syntax: n.syntax } }\n }\n impl From<ExternCrateItem> for ModuleItem {\n-    fn from(n: ExternCrateItem) -> ModuleItem {\n-        ModuleItem::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ExternCrateItem) -> ModuleItem { ModuleItem { syntax: n.syntax } }\n }\n impl From<ConstDef> for ModuleItem {\n-    fn from(n: ConstDef) -> ModuleItem {\n-        ModuleItem::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ConstDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }\n }\n impl From<StaticDef> for ModuleItem {\n-    fn from(n: StaticDef) -> ModuleItem {\n-        ModuleItem::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: StaticDef) -> ModuleItem { ModuleItem { syntax: n.syntax } }\n }\n impl From<Module> for ModuleItem {\n-    fn from(n: Module) -> ModuleItem {\n-        ModuleItem::cast(n.syntax).unwrap()\n-    }\n-}\n-\n-\n-impl AstNode for ModuleItem {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            | STRUCT_DEF\n-            | ENUM_DEF\n-            | FN_DEF\n-            | TRAIT_DEF\n-            | TYPE_ALIAS_DEF\n-            | IMPL_BLOCK\n-            | USE_ITEM\n-            | EXTERN_CRATE_ITEM\n-            | CONST_DEF\n-            | STATIC_DEF\n-            | MODULE => Some(ModuleItem { syntax }),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn from(n: Module) -> ModuleItem { ModuleItem { syntax: n.syntax } }\n }\n-\n impl ModuleItem {\n     pub fn kind(&self) -> ModuleItemKind {\n         match self.syntax.kind() {\n@@ -1710,12 +1743,15 @@ pub struct Name {\n }\n \n impl AstNode for Name {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            NAME => Some(Name { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            NAME => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Name { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1729,12 +1765,15 @@ pub struct NameRef {\n }\n \n impl AstNode for NameRef {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            NAME_REF => Some(NameRef { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            NAME_REF => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(NameRef { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1748,12 +1787,15 @@ pub struct NamedField {\n }\n \n impl AstNode for NamedField {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            NAMED_FIELD => Some(NamedField { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            NAMED_FIELD => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(NamedField { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1775,12 +1817,15 @@ pub struct NamedFieldDef {\n }\n \n impl AstNode for NamedFieldDef {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            NAMED_FIELD_DEF => Some(NamedFieldDef { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            NAMED_FIELD_DEF => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(NamedFieldDef { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1799,12 +1844,15 @@ pub struct NamedFieldDefList {\n }\n \n impl AstNode for NamedFieldDefList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            NAMED_FIELD_DEF_LIST => Some(NamedFieldDefList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            NAMED_FIELD_DEF_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(NamedFieldDefList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1822,12 +1870,15 @@ pub struct NamedFieldList {\n }\n \n impl AstNode for NamedFieldList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            NAMED_FIELD_LIST => Some(NamedFieldList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            NAMED_FIELD_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(NamedFieldList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1849,12 +1900,15 @@ pub struct NeverType {\n }\n \n impl AstNode for NeverType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            NEVER_TYPE => Some(NeverType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            NEVER_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(NeverType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1867,34 +1921,31 @@ pub struct NominalDef {\n     pub(crate) syntax: SyntaxNode,\n }\n \n+impl AstNode for NominalDef {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+             | STRUCT_DEF | ENUM_DEF => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(NominalDef { syntax }) } else { None }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum NominalDefKind {\n     StructDef(StructDef),\n     EnumDef(EnumDef),\n }\n impl From<StructDef> for NominalDef {\n-    fn from(n: StructDef) -> NominalDef {\n-        NominalDef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: StructDef) -> NominalDef { NominalDef { syntax: n.syntax } }\n }\n impl From<EnumDef> for NominalDef {\n-    fn from(n: EnumDef) -> NominalDef {\n-        NominalDef::cast(n.syntax).unwrap()\n-    }\n-}\n-\n-\n-impl AstNode for NominalDef {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            | STRUCT_DEF\n-            | ENUM_DEF => Some(NominalDef { syntax }),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn from(n: EnumDef) -> NominalDef { NominalDef { syntax: n.syntax } }\n }\n-\n impl NominalDef {\n     pub fn kind(&self) -> NominalDefKind {\n         match self.syntax.kind() {\n@@ -1917,12 +1968,15 @@ pub struct Param {\n }\n \n impl AstNode for Param {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            PARAM => Some(Param { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PARAM => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Param { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1941,12 +1995,15 @@ pub struct ParamList {\n }\n \n impl AstNode for ParamList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            PARAM_LIST => Some(ParamList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PARAM_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ParamList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1968,12 +2025,15 @@ pub struct ParenExpr {\n }\n \n impl AstNode for ParenExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            PAREN_EXPR => Some(ParenExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PAREN_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ParenExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -1991,12 +2051,15 @@ pub struct ParenType {\n }\n \n impl AstNode for ParenType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            PAREN_TYPE => Some(ParenType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PAREN_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ParenType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2013,6 +2076,20 @@ pub struct Pat {\n     pub(crate) syntax: SyntaxNode,\n }\n \n+impl AstNode for Pat {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+             | REF_PAT | BIND_PAT | PLACEHOLDER_PAT | PATH_PAT | STRUCT_PAT | TUPLE_STRUCT_PAT | TUPLE_PAT | SLICE_PAT | RANGE_PAT | LITERAL_PAT => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Pat { syntax }) } else { None }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum PatKind {\n     RefPat(RefPat),\n@@ -2027,76 +2104,35 @@ pub enum PatKind {\n     LiteralPat(LiteralPat),\n }\n impl From<RefPat> for Pat {\n-    fn from(n: RefPat) -> Pat {\n-        Pat::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: RefPat) -> Pat { Pat { syntax: n.syntax } }\n }\n impl From<BindPat> for Pat {\n-    fn from(n: BindPat) -> Pat {\n-        Pat::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: BindPat) -> Pat { Pat { syntax: n.syntax } }\n }\n impl From<PlaceholderPat> for Pat {\n-    fn from(n: PlaceholderPat) -> Pat {\n-        Pat::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: PlaceholderPat) -> Pat { Pat { syntax: n.syntax } }\n }\n impl From<PathPat> for Pat {\n-    fn from(n: PathPat) -> Pat {\n-        Pat::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: PathPat) -> Pat { Pat { syntax: n.syntax } }\n }\n impl From<StructPat> for Pat {\n-    fn from(n: StructPat) -> Pat {\n-        Pat::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: StructPat) -> Pat { Pat { syntax: n.syntax } }\n }\n impl From<TupleStructPat> for Pat {\n-    fn from(n: TupleStructPat) -> Pat {\n-        Pat::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: TupleStructPat) -> Pat { Pat { syntax: n.syntax } }\n }\n impl From<TuplePat> for Pat {\n-    fn from(n: TuplePat) -> Pat {\n-        Pat::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: TuplePat) -> Pat { Pat { syntax: n.syntax } }\n }\n impl From<SlicePat> for Pat {\n-    fn from(n: SlicePat) -> Pat {\n-        Pat::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: SlicePat) -> Pat { Pat { syntax: n.syntax } }\n }\n impl From<RangePat> for Pat {\n-    fn from(n: RangePat) -> Pat {\n-        Pat::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: RangePat) -> Pat { Pat { syntax: n.syntax } }\n }\n impl From<LiteralPat> for Pat {\n-    fn from(n: LiteralPat) -> Pat {\n-        Pat::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: LiteralPat) -> Pat { Pat { syntax: n.syntax } }\n }\n-\n-\n-impl AstNode for Pat {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            | REF_PAT\n-            | BIND_PAT\n-            | PLACEHOLDER_PAT\n-            | PATH_PAT\n-            | STRUCT_PAT\n-            | TUPLE_STRUCT_PAT\n-            | TUPLE_PAT\n-            | SLICE_PAT\n-            | RANGE_PAT\n-            | LITERAL_PAT => Some(Pat { syntax }),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n-\n impl Pat {\n     pub fn kind(&self) -> PatKind {\n         match self.syntax.kind() {\n@@ -2124,12 +2160,15 @@ pub struct Path {\n }\n \n impl AstNode for Path {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            PATH => Some(Path { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PATH => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Path { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2151,12 +2190,15 @@ pub struct PathExpr {\n }\n \n impl AstNode for PathExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            PATH_EXPR => Some(PathExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PATH_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(PathExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2174,12 +2216,15 @@ pub struct PathPat {\n }\n \n impl AstNode for PathPat {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            PATH_PAT => Some(PathPat { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PATH_PAT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(PathPat { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2197,12 +2242,15 @@ pub struct PathSegment {\n }\n \n impl AstNode for PathSegment {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            PATH_SEGMENT => Some(PathSegment { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PATH_SEGMENT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(PathSegment { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2224,12 +2272,15 @@ pub struct PathType {\n }\n \n impl AstNode for PathType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            PATH_TYPE => Some(PathType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PATH_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(PathType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2247,12 +2298,15 @@ pub struct PlaceholderPat {\n }\n \n impl AstNode for PlaceholderPat {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            PLACEHOLDER_PAT => Some(PlaceholderPat { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PLACEHOLDER_PAT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(PlaceholderPat { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2266,12 +2320,15 @@ pub struct PlaceholderType {\n }\n \n impl AstNode for PlaceholderType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            PLACEHOLDER_TYPE => Some(PlaceholderType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PLACEHOLDER_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(PlaceholderType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2285,12 +2342,15 @@ pub struct PointerType {\n }\n \n impl AstNode for PointerType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            POINTER_TYPE => Some(PointerType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            POINTER_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(PointerType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2308,12 +2368,15 @@ pub struct PosFieldDef {\n }\n \n impl AstNode for PosFieldDef {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            POS_FIELD_DEF => Some(PosFieldDef { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            POS_FIELD_DEF => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(PosFieldDef { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2333,12 +2396,15 @@ pub struct PosFieldDefList {\n }\n \n impl AstNode for PosFieldDefList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            POS_FIELD_DEF_LIST => Some(PosFieldDefList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            POS_FIELD_DEF_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(PosFieldDefList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2356,12 +2422,15 @@ pub struct PrefixExpr {\n }\n \n impl AstNode for PrefixExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            PREFIX_EXPR => Some(PrefixExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PREFIX_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(PrefixExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2379,12 +2448,15 @@ pub struct RangeExpr {\n }\n \n impl AstNode for RangeExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            RANGE_EXPR => Some(RangeExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            RANGE_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(RangeExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2398,12 +2470,15 @@ pub struct RangePat {\n }\n \n impl AstNode for RangePat {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            RANGE_PAT => Some(RangePat { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            RANGE_PAT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(RangePat { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2417,12 +2492,15 @@ pub struct RefExpr {\n }\n \n impl AstNode for RefExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            REF_EXPR => Some(RefExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            REF_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(RefExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2440,12 +2518,15 @@ pub struct RefPat {\n }\n \n impl AstNode for RefPat {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            REF_PAT => Some(RefPat { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            REF_PAT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(RefPat { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2463,12 +2544,15 @@ pub struct ReferenceType {\n }\n \n impl AstNode for ReferenceType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            REFERENCE_TYPE => Some(ReferenceType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            REFERENCE_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ReferenceType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2486,12 +2570,15 @@ pub struct RetType {\n }\n \n impl AstNode for RetType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            RET_TYPE => Some(RetType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            RET_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(RetType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2509,12 +2596,15 @@ pub struct ReturnExpr {\n }\n \n impl AstNode for ReturnExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            RETURN_EXPR => Some(ReturnExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            RETURN_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(ReturnExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2532,12 +2622,15 @@ pub struct SelfParam {\n }\n \n impl AstNode for SelfParam {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            SELF_PARAM => Some(SelfParam { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            SELF_PARAM => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(SelfParam { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2552,12 +2645,15 @@ pub struct SlicePat {\n }\n \n impl AstNode for SlicePat {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            SLICE_PAT => Some(SlicePat { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            SLICE_PAT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(SlicePat { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2571,12 +2667,15 @@ pub struct SliceType {\n }\n \n impl AstNode for SliceType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            SLICE_TYPE => Some(SliceType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            SLICE_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(SliceType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2594,12 +2693,15 @@ pub struct SourceFile {\n }\n \n impl AstNode for SourceFile {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            SOURCE_FILE => Some(SourceFile { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            SOURCE_FILE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(SourceFile { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2619,12 +2721,15 @@ pub struct StaticDef {\n }\n \n impl AstNode for StaticDef {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            STATIC_DEF => Some(StaticDef { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            STATIC_DEF => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(StaticDef { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2647,34 +2752,31 @@ pub struct Stmt {\n     pub(crate) syntax: SyntaxNode,\n }\n \n+impl AstNode for Stmt {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+             | EXPR_STMT | LET_STMT => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Stmt { syntax }) } else { None }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum StmtKind {\n     ExprStmt(ExprStmt),\n     LetStmt(LetStmt),\n }\n impl From<ExprStmt> for Stmt {\n-    fn from(n: ExprStmt) -> Stmt {\n-        Stmt::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ExprStmt) -> Stmt { Stmt { syntax: n.syntax } }\n }\n impl From<LetStmt> for Stmt {\n-    fn from(n: LetStmt) -> Stmt {\n-        Stmt::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: LetStmt) -> Stmt { Stmt { syntax: n.syntax } }\n }\n-\n-\n-impl AstNode for Stmt {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            | EXPR_STMT\n-            | LET_STMT => Some(Stmt { syntax }),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n-\n impl Stmt {\n     pub fn kind(&self) -> StmtKind {\n         match self.syntax.kind() {\n@@ -2694,12 +2796,15 @@ pub struct StructDef {\n }\n \n impl AstNode for StructDef {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            STRUCT_DEF => Some(StructDef { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            STRUCT_DEF => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(StructDef { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2718,12 +2823,15 @@ pub struct StructLit {\n }\n \n impl AstNode for StructLit {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            STRUCT_LIT => Some(StructLit { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            STRUCT_LIT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(StructLit { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2745,12 +2853,15 @@ pub struct StructPat {\n }\n \n impl AstNode for StructPat {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            STRUCT_PAT => Some(StructPat { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            STRUCT_PAT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(StructPat { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2772,12 +2883,15 @@ pub struct TokenTree {\n }\n \n impl AstNode for TokenTree {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TOKEN_TREE => Some(TokenTree { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TOKEN_TREE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TokenTree { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2791,12 +2905,15 @@ pub struct TraitDef {\n }\n \n impl AstNode for TraitDef {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TRAIT_DEF => Some(TraitDef { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TRAIT_DEF => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TraitDef { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2820,12 +2937,15 @@ pub struct TryBlockExpr {\n }\n \n impl AstNode for TryBlockExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TRY_BLOCK_EXPR => Some(TryBlockExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TRY_BLOCK_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TryBlockExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2840,12 +2960,15 @@ pub struct TryExpr {\n }\n \n impl AstNode for TryExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TRY_EXPR => Some(TryExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TRY_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TryExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2863,12 +2986,15 @@ pub struct TupleExpr {\n }\n \n impl AstNode for TupleExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TUPLE_EXPR => Some(TupleExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TUPLE_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TupleExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2886,12 +3012,15 @@ pub struct TuplePat {\n }\n \n impl AstNode for TuplePat {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TUPLE_PAT => Some(TuplePat { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TUPLE_PAT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TuplePat { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2909,12 +3038,15 @@ pub struct TupleStructPat {\n }\n \n impl AstNode for TupleStructPat {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TUPLE_STRUCT_PAT => Some(TupleStructPat { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TUPLE_STRUCT_PAT => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TupleStructPat { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2936,12 +3068,15 @@ pub struct TupleType {\n }\n \n impl AstNode for TupleType {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TUPLE_TYPE => Some(TupleType { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TUPLE_TYPE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TupleType { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2959,12 +3094,15 @@ pub struct TypeAliasDef {\n }\n \n impl AstNode for TypeAliasDef {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TYPE_ALIAS_DEF => Some(TypeAliasDef { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TYPE_ALIAS_DEF => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TypeAliasDef { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -2988,12 +3126,15 @@ pub struct TypeArg {\n }\n \n impl AstNode for TypeArg {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TYPE_ARG => Some(TypeArg { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TYPE_ARG => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TypeArg { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -3011,12 +3152,15 @@ pub struct TypeArgList {\n }\n \n impl AstNode for TypeArgList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TYPE_ARG_LIST => Some(TypeArgList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TYPE_ARG_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TypeArgList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -3042,12 +3186,15 @@ pub struct TypeBound {\n }\n \n impl AstNode for TypeBound {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TYPE_BOUND => Some(TypeBound { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TYPE_BOUND => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TypeBound { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -3065,12 +3212,15 @@ pub struct TypeBoundList {\n }\n \n impl AstNode for TypeBoundList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TYPE_BOUND_LIST => Some(TypeBoundList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TYPE_BOUND_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TypeBoundList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -3088,12 +3238,15 @@ pub struct TypeParam {\n }\n \n impl AstNode for TypeParam {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TYPE_PARAM => Some(TypeParam { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TYPE_PARAM => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TypeParam { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -3111,12 +3264,15 @@ pub struct TypeParamList {\n }\n \n impl AstNode for TypeParamList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            TYPE_PARAM_LIST => Some(TypeParamList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            TYPE_PARAM_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TypeParamList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -3137,6 +3293,20 @@ pub struct TypeRef {\n     pub(crate) syntax: SyntaxNode,\n }\n \n+impl AstNode for TypeRef {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+             | PAREN_TYPE | TUPLE_TYPE | NEVER_TYPE | PATH_TYPE | POINTER_TYPE | ARRAY_TYPE | SLICE_TYPE | REFERENCE_TYPE | PLACEHOLDER_TYPE | FN_POINTER_TYPE | FOR_TYPE | IMPL_TRAIT_TYPE | DYN_TRAIT_TYPE => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(TypeRef { syntax }) } else { None }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum TypeRefKind {\n     ParenType(ParenType),\n@@ -3154,94 +3324,44 @@ pub enum TypeRefKind {\n     DynTraitType(DynTraitType),\n }\n impl From<ParenType> for TypeRef {\n-    fn from(n: ParenType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ParenType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n impl From<TupleType> for TypeRef {\n-    fn from(n: TupleType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: TupleType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n impl From<NeverType> for TypeRef {\n-    fn from(n: NeverType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: NeverType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n impl From<PathType> for TypeRef {\n-    fn from(n: PathType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: PathType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n impl From<PointerType> for TypeRef {\n-    fn from(n: PointerType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: PointerType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n impl From<ArrayType> for TypeRef {\n-    fn from(n: ArrayType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ArrayType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n impl From<SliceType> for TypeRef {\n-    fn from(n: SliceType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: SliceType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n impl From<ReferenceType> for TypeRef {\n-    fn from(n: ReferenceType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ReferenceType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n impl From<PlaceholderType> for TypeRef {\n-    fn from(n: PlaceholderType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: PlaceholderType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n impl From<FnPointerType> for TypeRef {\n-    fn from(n: FnPointerType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: FnPointerType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n impl From<ForType> for TypeRef {\n-    fn from(n: ForType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ForType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n impl From<ImplTraitType> for TypeRef {\n-    fn from(n: ImplTraitType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: ImplTraitType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n impl From<DynTraitType> for TypeRef {\n-    fn from(n: DynTraitType) -> TypeRef {\n-        TypeRef::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: DynTraitType) -> TypeRef { TypeRef { syntax: n.syntax } }\n }\n-\n-\n-impl AstNode for TypeRef {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            | PAREN_TYPE\n-            | TUPLE_TYPE\n-            | NEVER_TYPE\n-            | PATH_TYPE\n-            | POINTER_TYPE\n-            | ARRAY_TYPE\n-            | SLICE_TYPE\n-            | REFERENCE_TYPE\n-            | PLACEHOLDER_TYPE\n-            | FN_POINTER_TYPE\n-            | FOR_TYPE\n-            | IMPL_TRAIT_TYPE\n-            | DYN_TRAIT_TYPE => Some(TypeRef { syntax }),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n-\n impl TypeRef {\n     pub fn kind(&self) -> TypeRefKind {\n         match self.syntax.kind() {\n@@ -3272,12 +3392,15 @@ pub struct UseItem {\n }\n \n impl AstNode for UseItem {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            USE_ITEM => Some(UseItem { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            USE_ITEM => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(UseItem { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -3296,12 +3419,15 @@ pub struct UseTree {\n }\n \n impl AstNode for UseTree {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            USE_TREE => Some(UseTree { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            USE_TREE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(UseTree { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -3327,12 +3453,15 @@ pub struct UseTreeList {\n }\n \n impl AstNode for UseTreeList {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            USE_TREE_LIST => Some(UseTreeList { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            USE_TREE_LIST => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(UseTreeList { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -3350,12 +3479,15 @@ pub struct Visibility {\n }\n \n impl AstNode for Visibility {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            VISIBILITY => Some(Visibility { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            VISIBILITY => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(Visibility { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -3369,12 +3501,15 @@ pub struct WhereClause {\n }\n \n impl AstNode for WhereClause {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            WHERE_CLAUSE => Some(WhereClause { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            WHERE_CLAUSE => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(WhereClause { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -3392,12 +3527,15 @@ pub struct WherePred {\n }\n \n impl AstNode for WherePred {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            WHERE_PRED => Some(WherePred { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            WHERE_PRED => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(WherePred { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n@@ -3416,12 +3554,15 @@ pub struct WhileExpr {\n }\n \n impl AstNode for WhileExpr {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            WHILE_EXPR => Some(WhileExpr { syntax }),\n-            _ => None,\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            WHILE_EXPR => true,\n+            _ => false,\n         }\n     }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some(WhileExpr { syntax }) } else { None }\n+    }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n "}, {"sha": "03b4bf3a1e3f39250b2cb905d35dcc76116e4bc7", "filename": "crates/ra_syntax/src/ast/generated.rs.tera", "status": "modified", "additions": 20, "deletions": 36, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=7bc9dec7cf195bc73a88d7c740f9d0bed1019e98", "patch": "@@ -12,18 +12,34 @@ the below applies to the result of this template\n #![cfg_attr(rustfmt, rustfmt_skip)]\n \n use crate::{\n-    SyntaxNode, SyntaxKind::*,\n+    SyntaxNode, SyntaxKind::{self, *},\n     ast::{self, AstNode},\n };\n {% for node, methods in ast %}\n // {{ node }}\n-\n-{%- if methods.enum %}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct {{ node }} {\n     pub(crate) syntax: SyntaxNode,\n }\n \n+impl AstNode for {{ node }} {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            {%- if methods.enum %}\n+            {% for kind in methods.enum %} | {{ kind | SCREAM }} {%- endfor -%}\n+            {% else %}\n+            {{ node | SCREAM }}\n+            {%- endif %} => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) { Some({{ node }} { syntax }) } else { None }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+\n+{% if methods.enum %}\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum {{ node }}Kind {\n {%- for kind in methods.enum %}\n@@ -33,25 +49,9 @@ pub enum {{ node }}Kind {\n \n {%- for kind in methods.enum %}\n impl From<{{ kind }}> for {{ node }} {\n-    fn from(n: {{ kind }}) -> {{ node }} {\n-        {{ node }}::cast(n.syntax).unwrap()\n-    }\n+    fn from(n: {{ kind }}) -> {{ node }} { {{ node }} { syntax: n.syntax } }\n }\n {%- endfor %}\n-\n-\n-impl AstNode for {{ node }} {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            {%- for kind in methods.enum %}\n-            | {{ kind | SCREAM }}\n-            {%- endfor %} => Some({{ node }} { syntax }),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n-\n impl {{ node }} {\n     pub fn kind(&self) -> {{ node }}Kind {\n         match self.syntax.kind() {\n@@ -62,22 +62,6 @@ impl {{ node }} {\n         }\n     }\n }\n-{% else %}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct {{ node }} {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-\n-impl AstNode for {{ node }} {\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        match syntax.kind() {\n-            {{ node | SCREAM }} => Some({{ node }} { syntax }),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n-\n {% endif %}\n {% if methods.traits -%}\n "}, {"sha": "d1b30a2c927133a7e328c55fb180cff3abed0373", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc9dec7cf195bc73a88d7c740f9d0bed1019e98/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=7bc9dec7cf195bc73a88d7c740f9d0bed1019e98", "patch": "@@ -61,12 +61,8 @@ impl<N: AstNode> AstPtr<N> {\n         self.raw\n     }\n \n-    // FIXME: extend AstNode to do this safely\n-    pub fn cast_checking_kind<U: AstNode>(\n-        self,\n-        cond: impl FnOnce(SyntaxKind) -> bool,\n-    ) -> Option<AstPtr<U>> {\n-        if !cond(self.raw.kind()) {\n+    pub fn cast<U: AstNode>(self) -> Option<AstPtr<U>> {\n+        if !U::can_cast(self.raw.kind()) {\n             return None;\n         }\n         Some(AstPtr { raw: self.raw, _ty: PhantomData })"}]}