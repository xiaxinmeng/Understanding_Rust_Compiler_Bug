{"sha": "1894db49b1e4c3200e9f561feb7f9891e54e1453", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4OTRkYjQ5YjFlNGMzMjAwZTlmNTYxZmViN2Y5ODkxZTU0ZTE0NTM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-28T01:20:55Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-28T01:20:55Z"}, "message": "Complete keywords in (Assoc)ItemList with leading attribute", "tree": {"sha": "8c5bab7e516a4cd1f326faac127240d0678ad624", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c5bab7e516a4cd1f326faac127240d0678ad624"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1894db49b1e4c3200e9f561feb7f9891e54e1453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1894db49b1e4c3200e9f561feb7f9891e54e1453", "html_url": "https://github.com/rust-lang/rust/commit/1894db49b1e4c3200e9f561feb7f9891e54e1453", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1894db49b1e4c3200e9f561feb7f9891e54e1453/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e71dd9799879fc9070f8717f8711fba5dae490a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e71dd9799879fc9070f8717f8711fba5dae490a", "html_url": "https://github.com/rust-lang/rust/commit/9e71dd9799879fc9070f8717f8711fba5dae490a"}], "stats": {"total": 37, "additions": 33, "deletions": 4}, "files": [{"sha": "c9673df85d2d8ee7aaf4d8ea56f41dc86311a637", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1894db49b1e4c3200e9f561feb7f9891e54e1453/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1894db49b1e4c3200e9f561feb7f9891e54e1453/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=1894db49b1e4c3200e9f561feb7f9891e54e1453", "patch": "@@ -394,6 +394,21 @@ fn quux() -> i32 {\n         );\n     }\n \n+    #[test]\n+    fn test_keywords_in_impl_def_with_attr() {\n+        check(\n+            r\"impl My { #[foo] $0 }\",\n+            expect![[r#\"\n+                kw fn\n+                kw const\n+                kw type\n+                kw unsafe\n+                kw pub(crate)\n+                kw pub\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_keywords_in_loop() {\n         check("}, {"sha": "c8a88367d784fab96b2f1afc762661b0acb6fd26", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1894db49b1e4c3200e9f561feb7f9891e54e1453/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1894db49b1e4c3200e9f561feb7f9891e54e1453/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=1894db49b1e4c3200e9f561feb7f9891e54e1453", "patch": "@@ -25,9 +25,10 @@ pub(crate) enum ImmediateLocation {\n }\n \n pub(crate) fn determine_location(tok: SyntaxToken) -> Option<ImmediateLocation> {\n-    // First \"expand\" the element we are completing to its maximum so that we can check in what\n-    // context it immediately lies. This for example means if the token is a NameRef at the end of\n-    // a path, we want to look at where the path is in the tree.\n+    // First walk the element we are completing up to its highest node that has the same text range\n+    // as the element so that we can check in what context it immediately lies. We only do this for\n+    // NameRef -> Path as that's the only thing that makes sense to being \"expanded\" semantically.\n+    // We only wanna do this if the NameRef is the last segment of the path.\n     let node = match tok.parent().and_then(ast::NameLike::cast)? {\n         ast::NameLike::NameRef(name_ref) => {\n             if let Some(segment) = name_ref.syntax().parent().and_then(ast::PathSegment::cast) {\n@@ -47,7 +48,20 @@ pub(crate) fn determine_location(tok: SyntaxToken) -> Option<ImmediateLocation>\n         it @ ast::NameLike::Name(_) | it @ ast::NameLike::Lifetime(_) => it.syntax().clone(),\n     };\n     let parent = match node.parent() {\n-        Some(parent) => parent,\n+        Some(parent) => match ast::MacroCall::cast(parent.clone()) {\n+            // When a path is being typed in an (Assoc)ItemList the parser will always emit a macro_call.\n+            // This is usually fine as the node expansion code above already accounts for that with\n+            // the ancestors call, but there is one exception to this which is that when an attribute\n+            // precedes it the code above will not walk the Path to the parent MacroCall as their ranges differ.\n+            Some(call)\n+                if call.excl_token().is_none()\n+                    && call.token_tree().is_none()\n+                    && call.semicolon_token().is_none() =>\n+            {\n+                call.syntax().parent()?\n+            }\n+            _ => parent,\n+        },\n         // SourceFile\n         None => {\n             return match node.kind() {"}]}