{"sha": "ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZjBkODM5OWUxZWYzZWQ2YmY3MDA1NjUwY2U0MmFhNjQ2YjVjYzc=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-10-07T14:36:28Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-01-23T04:10:38Z"}, "message": "Adds support for immovable generators. Move checking of invalid borrows across suspension points to borrowck. Fixes #44197, #45259 and #45093.", "tree": {"sha": "78166bd01ee1a24b9251e6cdf16dd631d3cf65e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78166bd01ee1a24b9251e6cdf16dd631d3cf65e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "html_url": "https://github.com/rust-lang/rust/commit/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47a8eb7c4e24b61a8a9ab4eaff60ef65291aaa56", "url": "https://api.github.com/repos/rust-lang/rust/commits/47a8eb7c4e24b61a8a9ab4eaff60ef65291aaa56", "html_url": "https://github.com/rust-lang/rust/commit/47a8eb7c4e24b61a8a9ab4eaff60ef65291aaa56"}], "stats": {"total": 1084, "additions": 867, "deletions": 217}, "files": [{"sha": "8bd89b834d6b6ce3d03da35280edb5530bc0f186", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -2118,4 +2118,6 @@ register_diagnostics! {\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n+\n+    E0906, // closures cannot be static\n }"}, {"sha": "919c69e2abb0057c92b2c7e55c7683bd207cae6e", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -2768,7 +2768,7 @@ impl<'a> LoweringContext<'a> {\n                                arms.iter().map(|x| self.lower_arm(x)).collect(),\n                                hir::MatchSource::Normal)\n             }\n-            ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n+            ExprKind::Closure(capture_clause, movability, ref decl, ref body, fn_decl_span) => {\n                 self.with_new_scopes(|this| {\n                     this.with_parent_def(e.id, |this| {\n                         let mut is_generator = false;\n@@ -2777,16 +2777,28 @@ impl<'a> LoweringContext<'a> {\n                             is_generator = this.is_generator;\n                             e\n                         });\n-                        if is_generator && !decl.inputs.is_empty() {\n-                            span_err!(this.sess, fn_decl_span, E0628,\n-                                      \"generators cannot have explicit arguments\");\n-                            this.sess.abort_if_errors();\n-                        }\n+                        let generator_option = if is_generator {\n+                            if !decl.inputs.is_empty() {\n+                                span_err!(this.sess, fn_decl_span, E0628,\n+                                        \"generators cannot have explicit arguments\");\n+                                this.sess.abort_if_errors();\n+                            }\n+                            Some(match movability {\n+                                Movability::Movable => hir::GeneratorMovability::Movable,\n+                                Movability::Static => hir::GeneratorMovability::Static,\n+                            })\n+                        } else {\n+                            if movability == Movability::Static {\n+                                span_err!(this.sess, fn_decl_span, E0906,\n+                                        \"closures cannot be static\");\n+                            }\n+                            None\n+                        };\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl, None, false),\n                                          body_id,\n                                          fn_decl_span,\n-                                         is_generator)\n+                                         generator_option)\n                     })\n                 })\n             }"}, {"sha": "8921fecf1b886f1f5f73474fd67989c77dd9af48", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -1290,7 +1290,7 @@ pub enum Expr_ {\n     ///\n     /// This may also be a generator literal, indicated by the final boolean,\n     /// in that case there is an GeneratorClause.\n-    ExprClosure(CaptureClause, P<FnDecl>, BodyId, Span, bool),\n+    ExprClosure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n     /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n@@ -1466,6 +1466,12 @@ pub struct Destination {\n     pub target_id: ScopeTarget,\n }\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum GeneratorMovability {\n+    Static,\n+    Movable,\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum CaptureClause {\n     CaptureByValue,"}, {"sha": "59d9db48bdc634ef4bb79c9fc9e2f2c5c623e15c", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -606,6 +606,11 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::MatchSource {\n     }\n }\n \n+impl_stable_hash_for!(enum hir::GeneratorMovability {\n+    Static,\n+    Movable\n+});\n+\n impl_stable_hash_for!(enum hir::CaptureClause {\n     CaptureByValue,\n     CaptureByRef"}, {"sha": "107779ec3fa155cfc588b36c71aca00842c25196", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -431,7 +431,7 @@ for ::middle::const_val::ErrKind<'gcx> {\n \n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n \n-impl_stable_hash_for!(struct ty::GeneratorInterior<'tcx> { witness });\n+impl_stable_hash_for!(struct ty::GeneratorInterior<'tcx> { witness, movable });\n \n impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     parent,\n@@ -656,6 +656,9 @@ for ty::TypeVariants<'gcx>\n                 closure_substs.hash_stable(hcx, hasher);\n                 interior.hash_stable(hcx, hasher);\n             }\n+            TyGeneratorWitness(types) => {\n+                types.hash_stable(hcx, hasher)\n+            }\n             TyTuple(inner_tys, from_diverging_type_var) => {\n                 inner_tys.hash_stable(hcx, hasher);\n                 from_diverging_type_var.hash_stable(hcx, hasher);"}, {"sha": "18b8c70c3ef79d6e03dbfbfca34a21cb9e0338c8", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                 if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n                     match hir.get(node_id) {\n                         NodeExpr(Expr {\n-                            node: ExprClosure(_, _, _, closure_span, false),\n+                            node: ExprClosure(_, _, _, closure_span, None),\n                             ..\n                         }) => {\n                             let sup_sp = sup_origin.span();"}, {"sha": "8b61fcff2335e18f463a1a550089b898f0f239cf", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -192,6 +192,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyForeign(..) |\n             ty::TyParam(..) |\n             ty::TyClosure(..) |\n+            ty::TyGeneratorWitness(..) |\n             ty::TyAnon(..) => {\n                 t.super_fold_with(self)\n             }"}, {"sha": "66b3adb83c160a8a3f9b2da16c27e49cdce7f366", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 84, "deletions": 4, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -453,6 +453,43 @@ struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     terminating_scopes: FxHashSet<hir::ItemLocalId>,\n }\n \n+struct ExprLocatorVisitor {\n+    id: ast::NodeId,\n+    result: Option<usize>,\n+    expr_and_pat_count: usize,\n+}\n+\n+// This visitor has to have the same visit_expr calls as RegionResolutionVisitor\n+// since `expr_count` is compared against the results there.\n+impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx Pat) {\n+        self.expr_and_pat_count += 1;\n+\n+        intravisit::walk_pat(self, pat);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        debug!(\"ExprLocatorVisitor - pre-increment {} expr = {:?}\",\n+               self.expr_and_pat_count,\n+               expr);\n+\n+        intravisit::walk_expr(self, expr);\n+\n+        self.expr_and_pat_count += 1;\n+\n+        debug!(\"ExprLocatorVisitor - post-increment {} expr = {:?}\",\n+               self.expr_and_pat_count,\n+               expr);\n+\n+        if expr.id == self.id {\n+            self.result = Some(self.expr_and_pat_count);\n+        }\n+    }\n+}\n \n impl<'tcx> ScopeTree {\n     pub fn record_scope_parent(&mut self, child: Scope, parent: Option<Scope>) {\n@@ -612,6 +649,20 @@ impl<'tcx> ScopeTree {\n         return true;\n     }\n \n+    /// Returns the id of the innermost containing body\n+    pub fn containing_body(&self, mut scope: Scope)-> Option<hir::ItemLocalId> {\n+        loop {\n+            if let ScopeData::CallSite(id) = scope.data() {\n+                return Some(id);\n+            }\n+\n+            match self.opt_encl_scope(scope) {\n+                None => return None,\n+                Some(parent) => scope = parent,\n+            }\n+        }\n+    }\n+\n     /// Finds the nearest common ancestor (if any) of two scopes.  That is, finds the smallest\n     /// scope which is greater than or equal to both `scope_a` and `scope_b`.\n     pub fn nearest_common_ancestor(&self,\n@@ -768,6 +819,28 @@ impl<'tcx> ScopeTree {\n         self.yield_in_scope.get(&scope).cloned()\n     }\n \n+    /// Checks whether the given scope contains a `yield` and if that yield could execute\n+    /// after `expr`. If so, it returns the span of that `yield`.\n+    /// `scope` must be inside the body.\n+    pub fn yield_in_scope_for_expr(&self,\n+                                   scope: Scope,\n+                                   expr: ast::NodeId,\n+                                   body: &'tcx hir::Body) -> Option<Span> {\n+        self.yield_in_scope(scope).and_then(|(span, count)| {\n+            let mut visitor = ExprLocatorVisitor {\n+                id: expr,\n+                result: None,\n+                expr_and_pat_count: 0,\n+            };\n+            visitor.visit_body(body);\n+            if count >= visitor.result.unwrap() {\n+                Some(span)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n     /// Gives the number of expressions visited in a body.\n     /// Used to sanity check visit_expr call count when\n     /// calculating generator interiors.\n@@ -872,9 +945,13 @@ fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &\n         record_var_lifetime(visitor, pat.hir_id.local_id, pat.span);\n     }\n \n+    debug!(\"resolve_pat - pre-increment {} pat = {:?}\", visitor.expr_and_pat_count, pat);\n+\n     intravisit::walk_pat(visitor, pat);\n \n     visitor.expr_and_pat_count += 1;\n+\n+    debug!(\"resolve_pat - post-increment {} pat = {:?}\", visitor.expr_and_pat_count, pat);\n }\n \n fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n@@ -897,7 +974,7 @@ fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt:\n }\n \n fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-    debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n+    debug!(\"resolve_expr - pre-increment {} expr = {:?}\", visitor.expr_and_pat_count, expr);\n \n     let prev_cx = visitor.cx;\n     visitor.enter_node_scope_with_dtor(expr.hir_id.local_id);\n@@ -982,6 +1059,8 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n \n     visitor.expr_and_pat_count += 1;\n \n+    debug!(\"resolve_expr post-increment {}, expr = {:?}\", visitor.expr_and_pat_count, expr);\n+\n     if let hir::ExprYield(..) = expr.node {\n         // Mark this expr's scope and all parent scopes as containing `yield`.\n         let mut scope = Scope::Node(expr.hir_id.local_id);\n@@ -1077,12 +1156,13 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         }\n     }\n \n-    if let Some(pat) = pat {\n-        visitor.visit_pat(pat);\n-    }\n+    // Make sure we visit the initializer first, so expr_and_pat_count remains correct\n     if let Some(expr) = init {\n         visitor.visit_expr(expr);\n     }\n+    if let Some(pat) = pat {\n+        visitor.visit_pat(pat);\n+    }\n \n     /// True if `pat` match the `P&` nonterminal:\n     ///"}, {"sha": "ae68e3fe8d01f065c2954ff6465fcccceecca21b", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -451,7 +451,10 @@ fn ty_is_local_constructor(ty: Ty, in_crate: InCrate) -> bool {\n             true\n         }\n \n-        ty::TyClosure(..) | ty::TyGenerator(..) | ty::TyAnon(..) => {\n+        ty::TyClosure(..) |\n+        ty::TyGenerator(..) |\n+        ty::TyGeneratorWitness(..) |\n+        ty::TyAnon(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n         }\n     }"}, {"sha": "067340ecacc00ecd34aa05af5d4b71f74043ccb8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -262,6 +262,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 },\n                 ty::TyGenerator(..) => Some(18),\n                 ty::TyForeign(..) => Some(19),\n+                ty::TyGeneratorWitness(..) => Some(20),\n                 ty::TyInfer(..) | ty::TyError => None\n             }\n         }"}, {"sha": "55cbc890e1e91de2c39b45c9975ccb686fee9305", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -2044,8 +2044,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n             ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyRawPtr(..) |\n             ty::TyChar | ty::TyRef(..) | ty::TyGenerator(..) |\n-            ty::TyArray(..) | ty::TyClosure(..) | ty::TyNever |\n-            ty::TyError => {\n+            ty::TyGeneratorWitness(..) | ty::TyArray(..) | ty::TyClosure(..) |\n+            ty::TyNever | ty::TyError => {\n                 // safe for everything\n                 Where(ty::Binder(Vec::new()))\n             }\n@@ -2095,7 +2095,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n-            ty::TyGenerator(..) | ty::TyForeign(..) |\n+            ty::TyGenerator(..) | ty::TyGeneratorWitness(..) | ty::TyForeign(..) |\n             ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 Never\n             }\n@@ -2206,8 +2206,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::TyGenerator(def_id, ref substs, interior) => {\n-                let witness = iter::once(interior.witness);\n-                substs.upvar_tys(def_id, self.tcx()).chain(witness).collect()\n+                substs.upvar_tys(def_id, self.tcx()).chain(iter::once(interior.witness)).collect()\n+            }\n+\n+            ty::TyGeneratorWitness(types) => {\n+                // This is sound because no regions in the witness can refer to\n+                // the binder outside the witness. So we'll effectivly reuse\n+                // the implicit binder around the witness.\n+                types.skip_binder().to_vec()\n             }\n \n             // for `PhantomData<T>`, we pass `T`"}, {"sha": "e4e07454c97acbc538a7f1363eef3cdd7983f83a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -1672,8 +1672,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n-            TyAdt, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr, TyGenerator, TyForeign,\n-            TyDynamic, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n+            TyAdt, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n+            TyGenerator, TyGeneratorWitness, TyDynamic, TyClosure, TyTuple,\n+            TyParam, TyInfer, TyProjection, TyAnon, TyForeign);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n@@ -2079,6 +2080,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyGenerator(id, closure_substs, interior))\n     }\n \n+    pub fn mk_generator_witness(self, types: ty::Binder<&'tcx Slice<Ty<'tcx>>>) -> Ty<'tcx> {\n+        self.mk_ty(TyGeneratorWitness(types))\n+    }\n+\n     pub fn mk_var(self, v: TyVid) -> Ty<'tcx> {\n         self.mk_infer(TyVar(v))\n     }"}, {"sha": "583612f9590f14f3183ff690b77607e94fb7384d", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -227,6 +227,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             }\n             ty::TyClosure(..) => \"closure\".to_string(),\n             ty::TyGenerator(..) => \"generator\".to_string(),\n+            ty::TyGeneratorWitness(..) => \"generator witness\".to_string(),\n             ty::TyTuple(..) => \"tuple\".to_string(),\n             ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),\n             ty::TyInfer(ty::IntVar(_)) => \"integral variable\".to_string(),"}, {"sha": "97c259e6bf38342bc81267b4ff14537796eec9d9", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -46,6 +46,7 @@ pub enum SimplifiedTypeGen<D>\n     TraitSimplifiedType(D),\n     ClosureSimplifiedType(D),\n     GeneratorSimplifiedType(D),\n+    GeneratorWitnessSimplifiedType(usize),\n     AnonSimplifiedType(D),\n     FunctionSimplifiedType(usize),\n     ParameterSimplifiedType,\n@@ -92,6 +93,9 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyGenerator(def_id, _, _) => {\n             Some(GeneratorSimplifiedType(def_id))\n         }\n+        ty::TyGeneratorWitness(ref tys) => {\n+            Some(GeneratorWitnessSimplifiedType(tys.skip_binder().len()))\n+        }\n         ty::TyNever => Some(NeverSimplifiedType),\n         ty::TyTuple(ref tys, _) => {\n             Some(TupleSimplifiedType(tys.len()))\n@@ -141,6 +145,7 @@ impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n             TraitSimplifiedType(d) => TraitSimplifiedType(map(d)),\n             ClosureSimplifiedType(d) => ClosureSimplifiedType(map(d)),\n             GeneratorSimplifiedType(d) => GeneratorSimplifiedType(map(d)),\n+            GeneratorWitnessSimplifiedType(n) => GeneratorWitnessSimplifiedType(n),\n             AnonSimplifiedType(d) => AnonSimplifiedType(map(d)),\n             FunctionSimplifiedType(n) => FunctionSimplifiedType(n),\n             ParameterSimplifiedType => ParameterSimplifiedType,\n@@ -175,6 +180,7 @@ impl<'gcx, D> HashStable<StableHashingContext<'gcx>> for SimplifiedTypeGen<D>\n             TraitSimplifiedType(d) => d.hash_stable(hcx, hasher),\n             ClosureSimplifiedType(d) => d.hash_stable(hcx, hasher),\n             GeneratorSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            GeneratorWitnessSimplifiedType(n) => n.hash_stable(hcx, hasher),\n             AnonSimplifiedType(d) => d.hash_stable(hcx, hasher),\n             FunctionSimplifiedType(n) => n.hash_stable(hcx, hasher),\n             ForeignSimplifiedType(d) => d.hash_stable(hcx, hasher),"}, {"sha": "2889322a1ce77541eb5bfc426cf45d2e202690cd", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -94,6 +94,12 @@ impl FlagComputation {\n                 self.add_ty(interior.witness);\n             }\n \n+            &ty::TyGeneratorWitness(ref ts) => {\n+                let mut computation = FlagComputation::new();\n+                computation.add_tys(&ts.skip_binder()[..]);\n+                self.add_bound_computation(&computation);\n+            }\n+\n             &ty::TyClosure(_, ref substs) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES);"}, {"sha": "fefd11eecf4fa9ca6ededb50f9f9f4effdd041f1", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -375,6 +375,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n         ty::TyAnon(..) |\n         ty::TyInfer(_) |\n         ty::TyError |\n+        ty::TyGeneratorWitness(..) |\n         ty::TyNever |\n         ty::TyFloat(_) => None,\n     }"}, {"sha": "69d07eafdca7a3481a8e03d4f3826d41a354be4b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -1678,7 +1678,7 @@ impl<'a, 'tcx> LayoutDetails {\n             ty::TyParam(_) => {\n                 return Err(LayoutError::Unknown(ty));\n             }\n-            ty::TyInfer(_) | ty::TyError => {\n+            ty::TyGeneratorWitness(..) | ty::TyInfer(_) | ty::TyError => {\n                 bug!(\"LayoutDetails::compute: unexpected type `{}`\", ty)\n             }\n         })\n@@ -2151,8 +2151,9 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n             ty::TyFnPtr(_) |\n             ty::TyNever |\n             ty::TyFnDef(..) |\n-            ty::TyDynamic(..) |\n-            ty::TyForeign(..) => {\n+            ty::TyGeneratorWitness(..) |\n+            ty::TyForeign(..) |\n+            ty::TyDynamic(..) => {\n                 bug!(\"TyLayout::field_type({:?}): not applicable\", self)\n             }\n "}, {"sha": "b3acfb7fac8a39f7f46c885cd7210651b7870ec6", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -1880,7 +1880,12 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 vec![]\n             }\n \n-            TyStr | TyDynamic(..) | TySlice(_) | TyForeign(..) | TyError => {\n+            TyStr |\n+            TyDynamic(..) |\n+            TySlice(_) |\n+            TyForeign(..) |\n+            TyError |\n+            TyGeneratorWitness(..) => {\n                 // these are never sized - return the target type\n                 vec![ty]\n             }"}, {"sha": "ff99a4b7ff63828a17b5fd2d44cd4144e63b7428", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -79,16 +79,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            ty::TyGenerator(def_id, ref substs, ref interior) => {\n+            ty::TyGenerator(def_id, ref substs, _) => {\n                 // Same as the closure case\n                 for upvar_ty in substs.upvar_tys(def_id, *self) {\n                     self.compute_components(upvar_ty, out);\n                 }\n \n-                // But generators can have additional interior types\n-                self.compute_components(interior.witness, out);\n+                // We ignore regions in the generator interior as we don't\n+                // want these to affect region inference\n             }\n \n+            // All regions are bound inside a witness\n+            ty::TyGeneratorWitness(..) => (),\n+\n             // OutlivesTypeParameterEnv -- the actual checking that `X:'a`\n             // is implied by the environment is done in regionck.\n             ty::TyParam(p) => {"}, {"sha": "a6c72728a51252f1f50a8b1941a607f071b15131", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -18,6 +18,7 @@ use middle::const_val::ConstVal;\n use traits::Reveal;\n use ty::subst::{Kind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::fold::{TypeVisitor, TypeFolder};\n use ty::error::{ExpectedFound, TypeError};\n use util::common::ErrorReported;\n use std::rc::Rc;\n@@ -319,6 +320,33 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n     }\n }\n \n+#[derive(Debug, Clone)]\n+struct GeneratorWitness<'tcx>(&'tcx ty::Slice<Ty<'tcx>>);\n+\n+impl<'tcx> TypeFoldable<'tcx> for GeneratorWitness<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        GeneratorWitness(self.0.fold_with(folder))\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.0.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &GeneratorWitness<'tcx>,\n+                           b: &GeneratorWitness<'tcx>)\n+                           -> RelateResult<'tcx, GeneratorWitness<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    {\n+        assert!(a.0.len() == b.0.len());\n+        let tcx = relation.tcx();\n+        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(a, b)))?;\n+        Ok(GeneratorWitness(types))\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &Ty<'tcx>,\n@@ -410,6 +438,17 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_generator(a_id, substs, interior))\n         }\n \n+        (&ty::TyGeneratorWitness(a_types), &ty::TyGeneratorWitness(b_types)) =>\n+        {\n+            // Wrap our types with a temporary GeneratorWitness struct\n+            // inside the binder so we can related them\n+            let a_types = ty::Binder(GeneratorWitness(*a_types.skip_binder()));\n+            let b_types = ty::Binder(GeneratorWitness(*b_types.skip_binder()));\n+            // Then remove the GeneratorWitness for the result\n+            let types = ty::Binder(relation.relate(&a_types, &b_types)?.skip_binder().0);\n+            Ok(tcx.mk_generator_witness(types))\n+        }\n+\n         (&ty::TyClosure(a_id, a_substs),\n          &ty::TyClosure(b_id, b_substs))\n             if a_id == b_id =>\n@@ -575,8 +614,9 @@ impl<'tcx> Relate<'tcx> for ty::GeneratorInterior<'tcx> {\n                            -> RelateResult<'tcx, ty::GeneratorInterior<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n-        let interior = relation.relate(&a.witness, &b.witness)?;\n-        Ok(ty::GeneratorInterior::new(interior))\n+        assert_eq!(a.movable, b.movable);\n+        let witness = relation.relate(&a.witness, &b.witness)?;\n+        Ok(ty::GeneratorInterior { witness, movable: a.movable })\n     }\n }\n "}, {"sha": "0dc1338fff8600c0782a8f83e5ad1b6c877350e5", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -438,7 +438,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorInterior<'a> {\n     type Lifted = ty::GeneratorInterior<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.witness).map(|witness| {\n-            ty::GeneratorInterior { witness }\n+            ty::GeneratorInterior { witness, movable: self.movable }\n         })\n     }\n }\n@@ -798,6 +798,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyGenerator(did, substs, interior) => {\n                 ty::TyGenerator(did, substs.fold_with(folder), interior.fold_with(folder))\n             }\n+            ty::TyGeneratorWitness(types) => ty::TyGeneratorWitness(types.fold_with(folder)),\n             ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n             ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n             ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n@@ -832,6 +833,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyGenerator(_did, ref substs, ref interior) => {\n                 substs.visit_with(visitor) || interior.visit_with(visitor)\n             }\n+            ty::TyGeneratorWitness(ref types) => types.visit_with(visitor),\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyProjection(ref data) => data.visit_with(visitor),\n             ty::TyAnon(_, ref substs) => substs.visit_with(visitor),\n@@ -928,7 +930,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ty::GeneratorInterior<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::GeneratorInterior::new(self.witness.fold_with(folder))\n+        ty::GeneratorInterior {\n+           witness: self.witness.fold_with(folder),\n+           movable: self.movable,\n+        }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {"}, {"sha": "b6ba7896497b43f3de31e7ad1db22a002feb91db", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -141,6 +141,10 @@ pub enum TypeVariants<'tcx> {\n     /// `|a| yield a`.\n     TyGenerator(DefId, ClosureSubsts<'tcx>, GeneratorInterior<'tcx>),\n \n+    /// A type representin the types stored inside a generator.\n+    /// This should only appear in GeneratorInteriors.\n+    TyGeneratorWitness(Binder<&'tcx Slice<Ty<'tcx>>>),\n+\n     /// The never type `!`\n     TyNever,\n \n@@ -405,19 +409,7 @@ impl<'a, 'gcx, 'tcx> ClosureSubsts<'tcx> {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct GeneratorInterior<'tcx> {\n     pub witness: Ty<'tcx>,\n-}\n-\n-impl<'tcx> GeneratorInterior<'tcx> {\n-    pub fn new(witness: Ty<'tcx>) -> GeneratorInterior<'tcx> {\n-        GeneratorInterior { witness }\n-    }\n-\n-    pub fn as_slice(&self) -> &'tcx Slice<Ty<'tcx>> {\n-        match self.witness.sty {\n-            ty::TyTuple(s, _) => s,\n-            _ => bug!(),\n-        }\n-    }\n+    pub movable: bool,\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n@@ -1611,6 +1603,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             }\n             TyFnDef(..) |\n             TyFnPtr(_) |\n+            TyGeneratorWitness(..) |\n             TyBool |\n             TyChar |\n             TyInt(_) |"}, {"sha": "34f05232adcab06d21587ce106a9bdce24015cbd", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -29,7 +29,6 @@ use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n use rustc_data_structures::fx::FxHashMap;\n use std::cmp;\n-use std::iter;\n use std::hash::Hash;\n use std::intrinsics;\n use syntax::ast::{self, Name};\n@@ -550,7 +549,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let result = match ty.sty {\n             ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n             ty::TyFloat(_) | ty::TyStr | ty::TyNever | ty::TyForeign(..) |\n-            ty::TyRawPtr(..) | ty::TyRef(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+            ty::TyRawPtr(..) | ty::TyRef(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) |\n+            ty::TyGeneratorWitness(..) => {\n                 // these types never have a destructor\n                 Ok(ty::DtorckConstraint::empty())\n             }\n@@ -572,8 +572,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }).collect()\n             }\n \n-            ty::TyGenerator(def_id, substs, interior) => {\n-                substs.upvar_tys(def_id, self).chain(iter::once(interior.witness)).map(|ty| {\n+            ty::TyGenerator(def_id, substs, _) => {\n+                // Note that the interior types are ignored here.\n+                // Any type reachable inside the interior must also be reachable\n+                // through the upvars.\n+                substs.upvar_tys(def_id, self).map(|ty| {\n                     self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n                 }).collect()\n             }\n@@ -783,6 +786,9 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n                     self.def_id(d);\n                 }\n             }\n+            TyGeneratorWitness(tys) => {\n+                self.hash(tys.skip_binder().len());\n+            }\n             TyTuple(tys, defaulted) => {\n                 self.hash(tys.len());\n                 self.hash(defaulted);\n@@ -1139,7 +1145,7 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Fast-path for primitive types\n         ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n         ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar | ty::TyGeneratorWitness(..) |\n         ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyStr => false,\n \n         // Foreign types can never have destructors"}, {"sha": "45f0ad1cf1a5f61ab7a31a9b6a0d18a795693e62", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -119,8 +119,11 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n             stack.extend(substs.substs.types().rev());\n         }\n         ty::TyGenerator(_, ref substs, ref interior) => {\n-            stack.extend(substs.substs.types().rev());\n             stack.push(interior.witness);\n+            stack.extend(substs.substs.types().rev());\n+        }\n+        ty::TyGeneratorWitness(ts) => {\n+            stack.extend(ts.skip_binder().iter().cloned().rev());\n         }\n         ty::TyTuple(ts, _) => {\n             stack.extend(ts.iter().cloned().rev());"}, {"sha": "ce44448ef794eebfdeb87ba116f30954bd8ace6f", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -283,6 +283,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                 ty::TyFloat(..) |\n                 ty::TyError |\n                 ty::TyStr |\n+                ty::TyGeneratorWitness(..) |\n                 ty::TyNever |\n                 ty::TyParam(_) |\n                 ty::TyForeign(..) => {"}, {"sha": "37d1c568515b546e82bfb848300bc57e2c411df3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -17,7 +17,7 @@ use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{TyBool, TyChar, TyAdt};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n-use ty::{TyClosure, TyGenerator, TyForeign, TyProjection, TyAnon};\n+use ty::{TyClosure, TyGenerator, TyGeneratorWitness, TyForeign, TyProjection, TyAnon};\n use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use util::nodemap::FxHashSet;\n@@ -631,6 +631,22 @@ impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n     }\n }\n \n+define_print! {\n+    ('tcx) &'tcx ty::Slice<Ty<'tcx>>, (self, f, cx) {\n+        display {\n+            write!(f, \"{{\")?;\n+            let mut tys = self.iter();\n+            if let Some(&ty) = tys.next() {\n+                print!(f, cx, print(ty))?;\n+                for &ty in tys {\n+                    print!(f, cx, write(\", \"), print(ty))?;\n+                }\n+            }\n+            write!(f, \"}}\")\n+        }\n+    }\n+}\n+\n define_print! {\n     ('tcx) ty::TypeAndMut<'tcx>, (self, f, cx) {\n         display {\n@@ -1066,7 +1082,11 @@ define_print! {\n                 TyStr => write!(f, \"str\"),\n                 TyGenerator(did, substs, interior) => ty::tls::with(|tcx| {\n                     let upvar_tys = substs.upvar_tys(did, tcx);\n-                    write!(f, \"[generator\")?;\n+                    if interior.movable {\n+                        write!(f, \"[generator\")?;\n+                    } else {\n+                        write!(f, \"[static generator\")?;\n+                    }\n \n                     if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n                         write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n@@ -1097,6 +1117,9 @@ define_print! {\n \n                     print!(f, cx, write(\" \"), print(interior), write(\"]\"))\n                 }),\n+                TyGeneratorWitness(types) => {\n+                    ty::tls::with(|tcx| cx.in_binder(f, tcx, &types, tcx.lift(&types)))\n+                }\n                 TyClosure(did, substs) => ty::tls::with(|tcx| {\n                     let upvar_tys = substs.upvar_tys(did, tcx);\n                     write!(f, \"[closure\")?;"}, {"sha": "7252a1795395b30a8e1f8a94c33bc72cf20f6790", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 100, "deletions": 1, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -25,7 +25,7 @@ use rustc::middle::expr_use_visitor::MutateMode;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, RegionKind};\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n@@ -92,6 +92,7 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     move_data: &'a move_data::FlowedMoveData<'a, 'tcx>,\n     all_loans: &'a [Loan<'tcx>],\n     param_env: ty::ParamEnv<'tcx>,\n+    movable_generator: bool,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n@@ -147,6 +148,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         }\n \n         self.check_for_conflicting_loans(hir_id.local_id);\n+\n+        self.check_for_loans_across_yields(cmt, loan_region, borrow_span);\n     }\n \n     fn mutate(&mut self,\n@@ -198,13 +201,24 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     debug!(\"check_loans(body id={})\", body.value.id);\n \n     let def_id = bccx.tcx.hir.body_owner_def_id(body.id());\n+\n+    let node_id = bccx.tcx.hir.as_local_node_id(def_id).unwrap();\n+    let movable_generator = !match bccx.tcx.hir.get(node_id) {\n+        hir::map::Node::NodeExpr(&hir::Expr {\n+            node: hir::ExprClosure(.., Some(hir::GeneratorMovability::Static)),\n+            ..\n+        }) => true,\n+        _ => false,\n+    };\n+\n     let param_env = bccx.tcx.param_env(def_id);\n     let mut clcx = CheckLoanCtxt {\n         bccx,\n         dfcx_loans,\n         move_data,\n         all_loans,\n         param_env,\n+        movable_generator,\n     };\n     let rvalue_promotable_map = bccx.tcx.rvalue_promotable_map(def_id);\n     euv::ExprUseVisitor::new(&mut clcx,\n@@ -348,6 +362,91 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         return result;\n     }\n \n+    pub fn check_for_loans_across_yields(&self,\n+                                         cmt: mc::cmt<'tcx>,\n+                                         loan_region: ty::Region<'tcx>,\n+                                         borrow_span: Span) {\n+        pub fn borrow_of_local_data<'tcx>(cmt: &mc::cmt<'tcx>) -> bool {\n+            match cmt.cat {\n+                // Borrows of static items is allowed\n+                Categorization::StaticItem => false,\n+                // Reborrow of already borrowed data is ignored\n+                // Any errors will be caught on the initial borrow\n+                Categorization::Deref(..) => false,\n+\n+                // By-ref upvars has Derefs so they will get ignored.\n+                // Generators counts as FnOnce so this leaves only\n+                // by-move upvars, which is local data for generators\n+                Categorization::Upvar(..) => true,\n+\n+                Categorization::Rvalue(region) => {\n+                    // Rvalues promoted to 'static are no longer local\n+                    if let RegionKind::ReStatic = *region {\n+                        false\n+                    } else {\n+                        true\n+                    }\n+                }\n+\n+                // Borrow of local data must be checked\n+                Categorization::Local(..) => true,\n+\n+                // For interior references and downcasts, find out if the base is local\n+                Categorization::Downcast(ref cmt_base, _) |\n+                Categorization::Interior(ref cmt_base, _) => borrow_of_local_data(&cmt_base),\n+            }\n+        }\n+\n+        if !self.movable_generator {\n+            return;\n+        }\n+\n+        if !borrow_of_local_data(&cmt) {\n+            return;\n+        }\n+\n+        let scope = match *loan_region {\n+            // A concrete region in which we will look for a yield expression\n+            RegionKind::ReScope(scope) => scope,\n+\n+            // There cannot be yields inside an empty region\n+            RegionKind::ReEmpty => return,\n+\n+            // Local data cannot have these lifetimes\n+            RegionKind::ReEarlyBound(..) |\n+            RegionKind::ReLateBound(..) |\n+            RegionKind::ReFree(..) |\n+            RegionKind::ReStatic => return,\n+\n+            // These cannot exist in borrowck\n+            RegionKind::ReVar(..) |\n+            RegionKind::ReSkolemized(..) |\n+            RegionKind::ReClosureBound(..) |\n+            RegionKind::ReErased => span_bug!(borrow_span,\n+                                              \"unexpected region in borrowck {:?}\",\n+                                              loan_region),\n+        };\n+\n+        let body_id = self.bccx.body.value.hir_id.local_id;\n+\n+        if self.bccx.region_scope_tree.containing_body(scope) != Some(body_id) {\n+            // We are borrowing a local data longer than it's storage.\n+            // This should result in other borrowck errors.\n+            // FIXME: Ensure an error is generated\n+            return;\n+        }\n+\n+        if let Some(yield_span) = self.bccx\n+                                      .region_scope_tree\n+                                      .yield_in_scope_for_expr(scope,\n+                                                               cmt.id,\n+                                                               self.bccx.body) {\n+            self.bccx.cannot_borrow_across_generator_yield(borrow_span,\n+                                                           yield_span,\n+                                                           Origin::Ast).emit();\n+        }\n+    }\n+\n     pub fn check_for_conflicting_loans(&self, node: hir::ItemLocalId) {\n         //! Checks to see whether any of the loans that are issued\n         //! on entrance to `node` conflict with loans that have already been"}, {"sha": "f755efc89a58ed1925807a912161a4fa40f1ada5", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -906,73 +906,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                 };\n \n-                // When you have a borrow that lives across a yield,\n-                // that reference winds up captured in the generator\n-                // type. Regionck then constraints it to live as long\n-                // as the generator itself. If that borrow is borrowing\n-                // data owned by the generator, this winds up resulting in\n-                // an `err_out_of_scope` error:\n-                //\n-                // ```\n-                // {\n-                //     let g = || {\n-                //         let a = &3; // this borrow is forced to ... -+\n-                //         yield ();          //                        |\n-                //         println!(\"{}\", a); //                        |\n-                //     };                     //                        |\n-                // } <----------------------... live until here --------+\n-                // ```\n-                //\n-                // To detect this case, we look for cases where the\n-                // `super_scope` (lifetime of the value) is within the\n-                // body, but the `sub_scope` is not.\n-                debug!(\"err_out_of_scope: self.body.is_generator = {:?}\",\n-                       self.body.is_generator);\n-                let maybe_borrow_across_yield = if self.body.is_generator {\n-                    let body_scope = region::Scope::Node(self.body.value.hir_id.local_id);\n-                    debug!(\"err_out_of_scope: body_scope = {:?}\", body_scope);\n-                    debug!(\"err_out_of_scope: super_scope = {:?}\", super_scope);\n-                    debug!(\"err_out_of_scope: sub_scope = {:?}\", sub_scope);\n-                    match (super_scope, sub_scope) {\n-                        (&ty::RegionKind::ReScope(value_scope),\n-                         &ty::RegionKind::ReScope(loan_scope)) => {\n-                            if {\n-                                // value_scope <= body_scope &&\n-                                self.region_scope_tree.is_subscope_of(value_scope, body_scope) &&\n-                                    // body_scope <= loan_scope\n-                                    self.region_scope_tree.is_subscope_of(body_scope, loan_scope)\n-                            } {\n-                                // We now know that this is a case\n-                                // that fits the bill described above:\n-                                // a borrow of something whose scope\n-                                // is within the generator, but the\n-                                // borrow is for a scope outside the\n-                                // generator.\n-                                //\n-                                // Now look within the scope of the of\n-                                // the value being borrowed (in the\n-                                // example above, that would be the\n-                                // block remainder that starts with\n-                                // `let a`) for a yield. We can cite\n-                                // that for the user.\n-                                self.region_scope_tree.yield_in_scope(value_scope)\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                        _ => None,\n-                    }\n-                } else {\n-                    None\n-                };\n-\n-                if let Some((yield_span, _)) = maybe_borrow_across_yield {\n-                    debug!(\"err_out_of_scope: opt_yield_span = {:?}\", yield_span);\n-                    self.cannot_borrow_across_generator_yield(error_span, yield_span, Origin::Ast)\n-                        .emit();\n-                    return;\n-                }\n-\n                 let mut db = self.path_does_not_live_long_enough(error_span, &msg, Origin::Ast);\n                 let value_kind = match err.cmt.cat {\n                     mc::Categorization::Rvalue(..) => \"temporary value\","}, {"sha": "e0999db6e3e66d3930e9c6ac6ffd4470023aedfd", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -639,6 +639,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::TyError |\n             ty::TyClosure(..) |\n             ty::TyGenerator(..) |\n+            ty::TyGeneratorWitness(..) |\n             ty::TyProjection(..) |\n             ty::TyAnon(..) |\n             ty::TyFnDef(..) => bug!(\"Unexpected type in foreign function\"),"}, {"sha": "2913f72460e3e7a520e77f6320d87fc31098a2ed", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -514,6 +514,7 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n         TyDynamic(..) => bug!(\"miri produced a trait object\"),\n         TyClosure(..) => bug!(\"miri produced a closure\"),\n         TyGenerator(..) => bug!(\"miri produced a generator\"),\n+        TyGeneratorWitness(..) => bug!(\"miri produced a generator witness\"),\n         TyNever => bug!(\"miri produced a value of the never type\"),\n         TyProjection(_) => bug!(\"miri produced a projection\"),\n         TyAnon(..) => bug!(\"miri produced an impl Trait type\"),"}, {"sha": "86a4dd4a31f8c0c48c44fa8c2821d6b9c3c73988", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -424,6 +424,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::TyInfer(_) |\n             ty::TyProjection(..) |\n             ty::TyParam(_) |\n+            ty::TyGeneratorWitness(_) |\n             ty::TyAnon(..) => {\n                 bug!(\"DefPathBasedNames: Trying to create type name for \\\n                                          unexpected type: {:?}\", t);"}, {"sha": "ebd34f81deb2958dce2985446d95a89b23170d8f", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 61, "deletions": 16, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -332,9 +332,39 @@ impl<'tcx> Visitor<'tcx> for StorageIgnored {\n     }\n }\n \n+struct BorrowedLocals(liveness::LocalSet);\n+\n+fn mark_as_borrowed<'tcx>(place: &Place<'tcx>, locals: &mut BorrowedLocals) {\n+    match *place {\n+        Place::Local(l) => { locals.0.add(&l); },\n+        Place::Static(..) => (),\n+        Place::Projection(ref proj) => {\n+            match proj.elem {\n+                // For derefs we don't look any further.\n+                // If it pointed to a Local, it would already be borrowed elsewhere\n+                ProjectionElem::Deref => (),\n+                _ => mark_as_borrowed(&proj.base, locals)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for BorrowedLocals {\n+    fn visit_rvalue(&mut self,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location) {\n+        if let Rvalue::Ref(_, _, ref place) = *rvalue {\n+            mark_as_borrowed(place, self);\n+        }\n+\n+        self.super_rvalue(rvalue, location)\n+    }\n+}\n+\n fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                mir: &Mir<'tcx>,\n-                                               source: MirSource) ->\n+                                               source: MirSource,\n+                                               movable: bool) ->\n                                                (liveness::LocalSet,\n                                                 HashMap<BasicBlock, liveness::LocalSet>) {\n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n@@ -347,8 +377,11 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut ignored = StorageIgnored(IdxSetBuf::new_filled(mir.local_decls.len()));\n     ignored.visit_mir(mir);\n \n+    let mut borrowed_locals = BorrowedLocals(IdxSetBuf::new_empty(mir.local_decls.len()));\n+    borrowed_locals.visit_mir(mir);\n+\n     let mut set = liveness::LocalSet::new_empty(mir.local_decls.len());\n-    let liveness = liveness::liveness_of_locals(mir, LivenessMode {\n+    let mut liveness = liveness::liveness_of_locals(mir, LivenessMode {\n         include_regular_use: true,\n         include_drops: true,\n     });\n@@ -372,6 +405,12 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // Mark locals without storage statements as always having live storage\n             live_locals.union(&ignored.0);\n \n+            if !movable {\n+                // For immovable generators we consider borrowed locals to always be live.\n+                // This effectively makes those locals use just the storage liveness.\n+                liveness.outs[block].union(&borrowed_locals.0);\n+            }\n+\n             // Locals live are live at this point only if they are used across suspension points\n             // and their storage is live\n             live_locals.intersect(&liveness.outs[block]);\n@@ -390,18 +429,25 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             source: MirSource,\n+                            upvars: Vec<Ty<'tcx>>,\n                             interior: GeneratorInterior<'tcx>,\n                             mir: &mut Mir<'tcx>)\n     -> (HashMap<Local, (Ty<'tcx>, usize)>,\n         GeneratorLayout<'tcx>,\n         HashMap<BasicBlock, liveness::LocalSet>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n-    let (live_locals, storage_liveness) = locals_live_across_suspend_points(tcx, mir, source);\n-\n+    let (live_locals, storage_liveness) = locals_live_across_suspend_points(tcx,\n+                                                                            mir,\n+                                                                            source,\n+                                                                            interior.movable);\n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n-    let allowed = tcx.erase_regions(&interior.as_slice());\n+    let allowed_upvars = tcx.erase_regions(&upvars);\n+    let allowed = match interior.witness.sty {\n+        ty::TyGeneratorWitness(s) => tcx.erase_late_bound_regions(&s),\n+        _ => bug!(),\n+    };\n \n     for (local, decl) in mir.local_decls.iter_enumerated() {\n         // Ignore locals which are internal or not live\n@@ -411,7 +457,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Sanity check that typeck knows about the type of locals which are\n         // live across a suspension point\n-        if !allowed.contains(&decl.ty) {\n+        if !allowed.contains(&decl.ty) && !allowed_upvars.contains(&decl.ty) {\n             span_bug!(mir.span,\n                       \"Broken MIR: generator contains type {} in MIR, \\\n                        but typeck only knows about {}\",\n@@ -763,19 +809,18 @@ impl MirPass for StateTransform {\n         assert!(mir.generator_drop.is_none());\n \n         let def_id = source.def_id;\n-        let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        let hir_id = tcx.hir.node_to_hir_id(node_id);\n-\n-        // Get the interior types which typeck computed\n-        let tables = tcx.typeck_tables_of(def_id);\n-        let interior = match tables.node_id_to_type(hir_id).sty {\n-            ty::TyGenerator(_, _, interior) => interior,\n-            ref t => bug!(\"type of generator not a generator: {:?}\", t),\n-        };\n \n         // The first argument is the generator type passed by value\n         let gen_ty = mir.local_decls.raw[1].ty;\n \n+        // Get the interior types and substs which typeck computed\n+        let (upvars, interior) = match gen_ty.sty {\n+            ty::TyGenerator(_, substs, interior) => {\n+                (substs.upvar_tys(def_id, tcx).collect(), interior)\n+            }\n+            _ => bug!(),\n+        };\n+\n         // Compute GeneratorState<yield_ty, return_ty>\n         let state_did = tcx.lang_items().gen_state().unwrap();\n         let state_adt_ref = tcx.adt_def(state_did);\n@@ -790,7 +835,7 @@ impl MirPass for StateTransform {\n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n         // `storage_liveness` tells us which locals have live storage at suspension points\n-        let (remap, layout, storage_liveness) = compute_layout(tcx, source, interior, mir);\n+        let (remap, layout, storage_liveness) = compute_layout(tcx, source, upvars, interior, mir);\n \n         let state_field = mir.upvar_decls.len();\n "}, {"sha": "f326b6e9274fc002a08122d2ff84ed5b2916ccbf", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -397,17 +397,17 @@ impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n         self.super_constant(constant, location);\n         let Constant { span, ty, literal } = constant;\n         self.push(&format!(\"mir::Constant\"));\n-        self.push(&format!(\"\u2514 span: {:?}\", span));\n-        self.push(&format!(\"\u2514 ty: {:?}\", ty));\n-        self.push(&format!(\"\u2514 literal: {:?}\", literal));\n+        self.push(&format!(\"+ span: {:?}\", span));\n+        self.push(&format!(\"+ ty: {:?}\", ty));\n+        self.push(&format!(\"+ literal: {:?}\", literal));\n     }\n \n     fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n         self.super_const(constant);\n         let ty::Const { ty, val } = constant;\n         self.push(&format!(\"ty::Const\"));\n-        self.push(&format!(\"\u2514 ty: {:?}\", ty));\n-        self.push(&format!(\"\u2514 val: {:?}\", val));\n+        self.push(&format!(\"+ ty: {:?}\", ty));\n+        self.push(&format!(\"+ val: {:?}\", val));\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n@@ -416,15 +416,15 @@ impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n             Rvalue::Aggregate(kind, _) => match **kind {\n                 AggregateKind::Closure(def_id, substs) => {\n                     self.push(&format!(\"closure\"));\n-                    self.push(&format!(\"\u2514 def_id: {:?}\", def_id));\n-                    self.push(&format!(\"\u2514 substs: {:#?}\", substs));\n+                    self.push(&format!(\"+ def_id: {:?}\", def_id));\n+                    self.push(&format!(\"+ substs: {:#?}\", substs));\n                 }\n \n                 AggregateKind::Generator(def_id, substs, interior) => {\n                     self.push(&format!(\"generator\"));\n-                    self.push(&format!(\"\u2514 def_id: {:?}\", def_id));\n-                    self.push(&format!(\"\u2514 substs: {:#?}\", substs));\n-                    self.push(&format!(\"\u2514 interior: {:?}\", interior));\n+                    self.push(&format!(\"+ def_id: {:?}\", def_id));\n+                    self.push(&format!(\"+ substs: {:#?}\", substs));\n+                    self.push(&format!(\"+ interior: {:?}\", interior));\n                 }\n \n                 _ => {}"}, {"sha": "69cef20622b1e82697b85f54a960309f54962605", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -1602,7 +1602,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     _ => span_bug!(ex.span, \"Expected struct or tuple type, found {:?}\", ty),\n                 }\n             }\n-            ast::ExprKind::Closure(_, ref decl, ref body, _fn_decl_span) => {\n+            ast::ExprKind::Closure(_, _, ref decl, ref body, _fn_decl_span) => {\n                 let mut id = String::from(\"$\");\n                 id.push_str(&ex.id.to_string());\n "}, {"sha": "6490d109f2936454601a4639857280c5a0eef375", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -173,6 +173,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::TyInfer(_) |\n         ty::TyProjection(..) |\n         ty::TyAnon(..) |\n+        ty::TyGeneratorWitness(..) |\n         ty::TyParam(_) => {\n             bug!(\"debuginfo: Trying to create type name for \\\n                 unexpected type: {:?}\", t);"}, {"sha": "992a510f71311250f531dce9226b900b2606af57", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty::TyInfer(_) => None,\n \n             ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n-            ty::TyFloat(_) | ty::TyArray(..) |\n+            ty::TyFloat(_) | ty::TyArray(..) | ty::TyGeneratorWitness(..) |\n             ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyFnDef(..) |\n             ty::TyFnPtr(..) | ty::TyClosure(..) | ty::TyGenerator(..) |\n             ty::TyAdt(..) | ty::TyNever | ty::TyError => {"}, {"sha": "df15f781ae8c98494c599b34148dd7a89f3b35e9", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -37,6 +37,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         _capture: hir::CaptureClause,\n         decl: &'gcx hir::FnDecl,\n         body_id: hir::BodyId,\n+        gen: Option<hir::GeneratorMovability>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         debug!(\n@@ -53,7 +54,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             None => (None, None),\n         };\n         let body = self.tcx.hir.body(body_id);\n-        self.check_closure(expr, expected_kind, decl, body, expected_sig)\n+        self.check_closure(expr, expected_kind, decl, body, gen, expected_sig)\n     }\n \n     fn check_closure(\n@@ -62,6 +63,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         opt_kind: Option<ty::ClosureKind>,\n         decl: &'gcx hir::FnDecl,\n         body: &'gcx hir::Body,\n+        gen: Option<hir::GeneratorMovability>,\n         expected_sig: Option<ty::FnSig<'tcx>>,\n     ) -> Ty<'tcx> {\n         debug!(\n@@ -86,7 +88,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             decl,\n             expr.id,\n             body,\n-            true,\n+            gen,\n         ).1;\n \n         // Create type variables (for now) to represent the transformed"}, {"sha": "781eeaef2482cca189ca56db038b243f01a1f666", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 65, "deletions": 24, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -17,8 +17,9 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Pat, PatKind, Expr};\n use rustc::middle::region;\n-use rustc::ty::Ty;\n+use rustc::ty::{self, Ty, GeneratorInterior};\n use std::rc::Rc;\n+use syntax_pos::Span;\n use super::FnCtxt;\n use util::nodemap::FxHashMap;\n \n@@ -30,44 +31,61 @@ struct InteriorVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n-    fn record(&mut self, ty: Ty<'tcx>, scope: Option<region::Scope>, expr: Option<&'tcx Expr>) {\n+    fn record(&mut self,\n+              ty: Ty<'tcx>,\n+              scope: Option<region::Scope>,\n+              expr: Option<&'tcx Expr>,\n+              source_span: Span) {\n         use syntax_pos::DUMMY_SP;\n \n         let live_across_yield = scope.map_or(Some(DUMMY_SP), |s| {\n-            self.region_scope_tree.yield_in_scope(s).and_then(|(span, expr_count)| {\n+            self.region_scope_tree.yield_in_scope(s).and_then(|(yield_span, expr_count)| {\n                 // If we are recording an expression that is the last yield\n                 // in the scope, or that has a postorder CFG index larger\n                 // than the one of all of the yields, then its value can't\n                 // be storage-live (and therefore live) at any of the yields.\n                 //\n                 // See the mega-comment at `yield_in_scope` for a proof.\n+\n+                debug!(\"comparing counts yield: {} self: {}, source_span = {:?}\",\n+                    expr_count, self.expr_count, source_span);\n+\n                 if expr_count >= self.expr_count {\n-                    Some(span)\n+                    Some(yield_span)\n                 } else {\n                     None\n                 }\n             })\n         });\n \n-        if let Some(span) = live_across_yield {\n+        if let Some(yield_span) = live_across_yield {\n             let ty = self.fcx.resolve_type_vars_if_possible(&ty);\n \n-            debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, span = {:?}\",\n-                   expr, scope, ty, span);\n-\n-            // Map the type to the number of types added before it\n-            let entries = self.types.len();\n-            self.types.entry(&ty).or_insert(entries);\n+            debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, count = {}, yield_span = {:?}\",\n+                   expr, scope, ty, self.expr_count, yield_span);\n+\n+            if self.fcx.any_unresolved_type_vars(&ty) {\n+                let mut err = struct_span_err!(self.fcx.tcx.sess, source_span, E0907,\n+                    \"type inside generator must be known in this context\");\n+                err.span_note(yield_span,\n+                              \"the type is part of the generator because of this `yield`\");\n+                err.emit();\n+            } else {\n+                // Map the type to the number of types added before it\n+                let entries = self.types.len();\n+                self.types.entry(&ty).or_insert(entries);\n+            }\n         } else {\n-            debug!(\"no type in expr = {:?}, span = {:?}\", expr, expr.map(|e| e.span));\n+            debug!(\"no type in expr = {:?}, count = {:?}, span = {:?}\",\n+                   expr, self.expr_count, expr.map(|e| e.span));\n         }\n     }\n }\n \n pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n                                         def_id: DefId,\n                                         body_id: hir::BodyId,\n-                                        witness: Ty<'tcx>) {\n+                                        interior: GeneratorInterior<'tcx>) {\n     let body = fcx.tcx.hir.body(body_id);\n     let mut visitor = InteriorVisitor {\n         fcx,\n@@ -87,17 +105,40 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     types.sort_by_key(|t| t.1);\n \n     // Extract type components\n-    let types: Vec<_> = types.into_iter().map(|t| t.0).collect();\n-\n-    let tuple = fcx.tcx.intern_tup(&types, false);\n-\n-    debug!(\"Types in generator {:?}, span = {:?}\", tuple, body.value.span);\n-\n-    // Unify the tuple with the witness\n-    match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(witness, tuple) {\n+    let type_list = fcx.tcx.mk_type_list(types.into_iter().map(|t| t.0));\n+\n+    // The types in the generator interior contain lifetimes local to the generator itself,\n+    // which should not be exposed outside of the generator. Therefore, we replace these\n+    // lifetimes with existentially-bound lifetimes, which reflect the exact value of the\n+    // lifetimes not being known by users.\n+    //\n+    // These lifetimes are used in auto trait impl checking (for example,\n+    // if a Sync generator contains an &'\u03b1 T, we need to check whether &'\u03b1 T: Sync),\n+    // so knowledge of the exact relationships between them isn't particularly important.\n+\n+    debug!(\"Types in generator {:?}, span = {:?}\", type_list, body.value.span);\n+\n+    // Replace all regions inside the generator interior with late bound regions\n+    // Note that each region slot in the types gets a new fresh late bound region,\n+    // which means that none of the regions inside relate to any other, even if\n+    // typeck had previously found contraints that would cause them to be related.\n+    let mut counter = 0;\n+    let type_list = fcx.tcx.fold_regions(&type_list, &mut false, |_, current_depth| {\n+        counter += 1;\n+        fcx.tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(current_depth),\n+                                        ty::BrAnon(counter)))\n+    });\n+\n+    let witness = fcx.tcx.mk_generator_witness(ty::Binder(type_list));\n+\n+    debug!(\"Types in generator after region replacement {:?}, span = {:?}\",\n+            witness, body.value.span);\n+\n+    // Unify the type variable inside the generator with the new witness\n+    match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(interior.witness, witness) {\n         Ok(ok) => fcx.register_infer_ok_obligations(ok),\n         _ => bug!(),\n-   }\n+    }\n }\n \n // This visitor has to have the same visit_expr calls as RegionResolutionVisitor in\n@@ -112,7 +153,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n         if let PatKind::Binding(..) = pat.node {\n             let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id);\n             let ty = self.fcx.tables.borrow().pat_ty(pat);\n-            self.record(ty, Some(scope), None);\n+            self.record(ty, Some(scope), None, pat.span);\n         }\n \n         self.expr_count += 1;\n@@ -128,6 +169,6 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n         let scope = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n         let ty = self.fcx.tables.borrow().expr_ty_adjusted(expr);\n-        self.record(ty, scope, Some(expr));\n+        self.record(ty, scope, Some(expr), expr.span);\n     }\n }"}, {"sha": "5b7eca7a301138f04f3e6aef4a124cd70582ab42", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -209,7 +209,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n \n-    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, Ty<'tcx>)>>,\n+    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, ty::GeneratorInterior<'tcx>)>>,\n \n     // Anonymized types found in explicit return types and their\n     // associated fresh inference variable. Writeback resolves these\n@@ -838,7 +838,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   param_env,\n                                                   &fn_sig);\n \n-            let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, false).0;\n+            let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, None).0;\n             fcx\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.id);\n@@ -973,7 +973,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             decl: &'gcx hir::FnDecl,\n                             fn_id: ast::NodeId,\n                             body: &'gcx hir::Body,\n-                            can_be_generator: bool)\n+                            can_be_generator: Option<hir::GeneratorMovability>)\n                             -> (FnCtxt<'a, 'gcx, 'tcx>, Option<GeneratorTypes<'tcx>>)\n {\n     let mut fn_sig = fn_sig.clone();\n@@ -999,7 +999,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     let span = body.value.span;\n \n-    if body.is_generator && can_be_generator {\n+    if body.is_generator && can_be_generator.is_some() {\n         fcx.yield_ty = Some(fcx.next_ty_var(TypeVariableOrigin::TypeInference(span)));\n     }\n \n@@ -1023,17 +1023,24 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     }\n \n     let fn_hir_id = fcx.tcx.hir.node_to_hir_id(fn_id);\n-    let gen_ty = if can_be_generator && body.is_generator {\n+    inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_hir_id, fn_sig);\n+\n+    fcx.check_return_expr(&body.value);\n+\n+    // We insert the deferred_generator_interiors entry after visiting the body.\n+    // This ensures that all nested generators appear before the entry of this generator.\n+    // resolve_generator_interiors relies on this property.\n+    let gen_ty = if can_be_generator.is_some() && body.is_generator {\n         let witness = fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n-        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), witness));\n-        let interior = ty::GeneratorInterior::new(witness);\n+        let interior = ty::GeneratorInterior {\n+            witness,\n+            movable: can_be_generator.unwrap() == hir::GeneratorMovability::Movable,\n+        };\n+        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior));\n         Some(GeneratorTypes { yield_ty: fcx.yield_ty.unwrap(), interior: interior })\n     } else {\n         None\n     };\n-    inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_hir_id, fn_sig);\n-\n-    fcx.check_return_expr(&body.value);\n \n     // Finalize the return check by taking the LUB of the return types\n     // we saw and assigning it to the expected return type. This isn't\n@@ -2113,9 +2120,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn resolve_generator_interiors(&self, def_id: DefId) {\n-        let mut deferred_generator_interiors = self.deferred_generator_interiors.borrow_mut();\n-        for (body_id, witness) in deferred_generator_interiors.drain(..) {\n-            generator_interior::resolve_interior(self, def_id, body_id, witness);\n+        let mut generators = self.deferred_generator_interiors.borrow_mut();\n+        for (body_id, interior) in generators.drain(..) {\n+            self.select_obligations_where_possible();\n+            generator_interior::resolve_interior(self, def_id, body_id, interior);\n         }\n     }\n \n@@ -3854,8 +3862,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n             self.check_match(expr, &discrim, arms, expected, match_src)\n           }\n-          hir::ExprClosure(capture, ref decl, body_id, _, _) => {\n-              self.check_expr_closure(expr, capture, &decl, body_id, expected)\n+          hir::ExprClosure(capture, ref decl, body_id, _, gen) => {\n+              self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n           }\n           hir::ExprBlock(ref body) => {\n             self.check_block_with_expected(&body, expected)"}, {"sha": "ab148afafbe0909c300f0cbbcab5a773b3bfeb00", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -74,11 +74,11 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         match expr.node {\n-            hir::ExprClosure(cc, _, body_id, _, is_generator) => {\n+            hir::ExprClosure(cc, _, body_id, _, gen) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n                 self.fcx\n-                    .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc, is_generator);\n+                    .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc, gen);\n             }\n \n             _ => {}\n@@ -96,7 +96,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         body: &hir::Body,\n         capture_clause: hir::CaptureClause,\n-        is_generator: bool,\n+        gen: Option<hir::GeneratorMovability>,\n     ) {\n         /*!\n          * Analysis starting point.\n@@ -121,7 +121,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let infer_kind = if is_generator {\n+        let infer_kind = if gen.is_some() {\n             false\n         } else {\n             self.closure_kind(closure_def_id, closure_substs).is_none()"}, {"sha": "8d428c860c50af08a5463ea677ac868f3b32485b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -1141,8 +1141,8 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeField(field) => icx.to_ty(&field.ty),\n \n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(.., is_generator), .. }) => {\n-            if is_generator {\n+        NodeExpr(&hir::Expr { node: hir::ExprClosure(.., gen), .. }) => {\n+            if gen.is_some() {\n                 let hir_id = tcx.hir.node_to_hir_id(node_id);\n                 return tcx.typeck_tables_of(def_id).node_id_to_type(hir_id);\n             }"}, {"sha": "18d573bd581ebf93cbdf4453bea133f955d9848e", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -4776,4 +4776,5 @@ register_diagnostics! {\n            // argument position.\n     E0641, // cannot cast to/from a pointer with an unknown kind\n     E0645, // trait aliases not finished\n+    E0907, // type inside generator must be known in this context\n }"}, {"sha": "0ed9b14b9d1d49b360ceb27da6297b1d1343b731", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -377,6 +377,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // types, where we use TyError as the Self type\n             }\n \n+            ty::TyGeneratorWitness(..) |\n             ty::TyInfer(..) => {\n                 bug!(\"unexpected type encountered in \\\n                       variance inference: {}\","}, {"sha": "22acf365e8557ba797b02074eae63efd81354691", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -2314,6 +2314,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n             ty::TyClosure(..) | ty::TyGenerator(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n+            ty::TyGeneratorWitness(..) => panic!(\"TyGeneratorWitness\"),\n             ty::TyInfer(..) => panic!(\"TyInfer\"),\n             ty::TyError => panic!(\"TyError\"),\n         }"}, {"sha": "d6e26057ea81cbf2fc6fb7c8f8531f3c40beb574", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -1100,7 +1100,7 @@ pub enum ExprKind {\n     /// A closure (for example, `move |a, b, c| a + b + c`)\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    Closure(CaptureBy, P<FnDecl>, P<Expr>, Span),\n+    Closure(CaptureBy, Movability, P<FnDecl>, P<Expr>, Span),\n     /// A block (`{ ... }`)\n     Block(P<Block>),\n     /// A catch block (`catch { ... }`)\n@@ -1194,6 +1194,13 @@ pub enum CaptureBy {\n     Ref,\n }\n \n+/// The movability of a generator / closure literal\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum Movability {\n+    Static,\n+    Movable,\n+}\n+\n pub type Mac = Spanned<Mac_>;\n \n /// Represents a macro invocation. The Path indicates which macro"}, {"sha": "cf63592c2ece2191448c20119e747676d1c00aad", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -912,6 +912,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                       fn_decl_span: Span) // span of the `|...|` part\n                       -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref,\n+                                               ast::Movability::Movable,\n                                                fn_decl,\n                                                body,\n                                                fn_decl_span))\n@@ -930,7 +931,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         // part of the lambda, but it probably (maybe?) corresponds to\n         // the entire lambda body. Probably we should extend the API\n         // here, but that's not entirely clear.\n-        self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref, fn_decl, body, span))\n+        self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref,\n+                                               ast::Movability::Movable,\n+                                               fn_decl,\n+                                               body,\n+                                               span))\n     }\n \n     fn lambda0(&self, span: Span, body: P<ast::Expr>) -> P<ast::Expr> {"}, {"sha": "1e605ba3ecdfb0578b9d9b9f92b891ece6b42ded", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -1235,8 +1235,9 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 ExprKind::Match(folder.fold_expr(expr),\n                           arms.move_map(|x| folder.fold_arm(x)))\n             }\n-            ExprKind::Closure(capture_clause, decl, body, span) => {\n+            ExprKind::Closure(capture_clause, movability, decl, body, span) => {\n                 ExprKind::Closure(capture_clause,\n+                                  movability,\n                                   folder.fold_fn_decl(decl),\n                                   folder.fold_expr(body),\n                                   folder.new_span(span))"}, {"sha": "8213d604b91b252d96b307ddb0912a01bc774065", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -14,7 +14,7 @@ use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Unsafety;\n use ast::{Mod, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n use ast::Block;\n-use ast::{BlockCheckMode, CaptureBy};\n+use ast::{BlockCheckMode, CaptureBy, Movability};\n use ast::{Constness, Crate};\n use ast::Defaultness;\n use ast::EnumDef;\n@@ -2258,8 +2258,7 @@ impl<'a> Parser<'a> {\n                 return self.parse_block_expr(lo, BlockCheckMode::Default, attrs);\n             }\n             token::BinOp(token::Or) | token::OrOr => {\n-                let lo = self.span;\n-                return self.parse_lambda_expr(lo, CaptureBy::Ref, attrs);\n+                return self.parse_lambda_expr(attrs);\n             }\n             token::OpenDelim(token::Bracket) => {\n                 self.bump();\n@@ -2304,9 +2303,8 @@ impl<'a> Parser<'a> {\n                     hi = path.span;\n                     return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n                 }\n-                if self.eat_keyword(keywords::Move) {\n-                    let lo = self.prev_span;\n-                    return self.parse_lambda_expr(lo, CaptureBy::Value, attrs);\n+                if self.check_keyword(keywords::Move) || self.check_keyword(keywords::Static) {\n+                    return self.parse_lambda_expr(attrs);\n                 }\n                 if self.eat_keyword(keywords::If) {\n                     return self.parse_if_expr(attrs);\n@@ -3247,11 +3245,20 @@ impl<'a> Parser<'a> {\n \n     // `move |args| expr`\n     pub fn parse_lambda_expr(&mut self,\n-                             lo: Span,\n-                             capture_clause: CaptureBy,\n                              attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>>\n     {\n+        let lo = self.span;\n+        let movability = if self.eat_keyword(keywords::Static) {\n+            Movability::Static\n+        } else {\n+            Movability::Movable\n+        };\n+        let capture_clause = if self.eat_keyword(keywords::Move) {\n+            CaptureBy::Value\n+        } else {\n+            CaptureBy::Ref\n+        };\n         let decl = self.parse_fn_block_decl()?;\n         let decl_hi = self.prev_span;\n         let body = match decl.output {\n@@ -3269,7 +3276,7 @@ impl<'a> Parser<'a> {\n \n         Ok(self.mk_expr(\n             lo.to(body.span),\n-            ExprKind::Closure(capture_clause, decl, body, lo.to(decl_hi)),\n+            ExprKind::Closure(capture_clause, movability, decl, body, lo.to(decl_hi)),\n             attrs))\n     }\n \n@@ -6271,6 +6278,23 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn is_static_global(&mut self) -> bool {\n+        if self.check_keyword(keywords::Static) {\n+            // Check if this could be a closure\n+            !self.look_ahead(1, |token| {\n+                if token.is_keyword(keywords::Move) {\n+                    return true;\n+                }\n+                match *token {\n+                    token::BinOp(token::Or) | token::OrOr => true,\n+                    _ => false,\n+                }\n+            })\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// Parse one of the items allowed by the flags.\n     /// NB: this function no longer parses the items inside an\n     /// extern crate.\n@@ -6329,7 +6353,8 @@ impl<'a> Parser<'a> {\n             self.unexpected()?;\n         }\n \n-        if self.eat_keyword(keywords::Static) {\n+        if self.is_static_global() {\n+            self.bump();\n             // STATIC ITEM\n             let m = if self.eat_keyword(keywords::Mut) {\n                 Mutability::Mutable"}, {"sha": "345c592a01100327543d926f39854c6da166c465", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -2162,7 +2162,8 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose_(expr.span, INDENT_UNIT)?;\n             }\n-            ast::ExprKind::Closure(capture_clause, ref decl, ref body, _) => {\n+            ast::ExprKind::Closure(capture_clause, movability, ref decl, ref body, _) => {\n+                self.print_movability(movability)?;\n                 self.print_capture_clause(capture_clause)?;\n \n                 self.print_fn_block_args(decl)?;\n@@ -2777,6 +2778,14 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    pub fn print_movability(&mut self, movability: ast::Movability)\n+                                -> io::Result<()> {\n+        match movability {\n+            ast::Movability::Static => self.word_space(\"static\"),\n+            ast::Movability::Movable => Ok(()),\n+        }\n+    }\n+\n     pub fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy)\n                                 -> io::Result<()> {\n         match capture_clause {"}, {"sha": "8aeacf79cee7d718b5dfde56534150802a4ab8bf", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -739,7 +739,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprKind::Closure(_, ref function_declaration, ref body, _decl_span) => {\n+        ExprKind::Closure(_, _, ref function_declaration, ref body, _decl_span) => {\n             visitor.visit_fn(FnKind::Closure(body),\n                              function_declaration,\n                              expression.span,"}, {"sha": "8593eb5333e392d6611d989a589a51c817344477", "filename": "src/test/compile-fail/static-closures.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Fcompile-fail%2Fstatic-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Fcompile-fail%2Fstatic-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-closures.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    static || {};\n+    //~^ ERROR closures cannot be static\n+}"}, {"sha": "10c44c8044b4164fc384a58c927185c1a04e0951", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -142,7 +142,11 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n                     variadic: false,\n                 });\n                 iter_exprs(depth - 1, &mut |e| g(\n-                        ExprKind::Closure(CaptureBy::Value, decl.clone(), e, DUMMY_SP)));\n+                        ExprKind::Closure(CaptureBy::Value,\n+                                          Movability::Movable,\n+                                          decl.clone(),\n+                                          e,\n+                                          DUMMY_SP)));\n             },\n             10 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(e, make_x())));"}, {"sha": "7cb80ea8b21b7403766a67d16c912278529fabf5", "filename": "src/test/run-pass/generator/issue-44197.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Frun-pass%2Fgenerator%2Fissue-44197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Frun-pass%2Fgenerator%2Fissue-44197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fissue-44197.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait, generators, generator_trait)]\n+\n+use std::ops::{ Generator, GeneratorState };\n+\n+fn foo(_: &str) -> String {\n+    String::new()\n+}\n+\n+fn bar(baz: String) -> impl Generator<Yield = String, Return = ()> {\n+    move || {\n+        yield foo(&baz);\n+    }\n+}\n+\n+fn foo2(_: &str) -> Result<String, ()> {\n+    Err(())\n+}\n+\n+fn bar2(baz: String) -> impl Generator<Yield = String, Return = ()> {\n+    move || {\n+        if let Ok(quux) = foo2(&baz) {\n+            yield quux;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(bar(String::new()).resume(), GeneratorState::Yielded(String::new()));\n+    assert_eq!(bar2(String::new()).resume(), GeneratorState::Complete(()));\n+}"}, {"sha": "e34b0b3100c32983f865abd22f15561a8de12769", "filename": "src/test/run-pass/generator/live-upvar-across-yield.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Frun-pass%2Fgenerator%2Flive-upvar-across-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Frun-pass%2Fgenerator%2Flive-upvar-across-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Flive-upvar-across-yield.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+fn main() {\n+    let b = |_| 3;\n+    let mut a = || {\n+        b(yield);\n+    };\n+    a.resume();\n+}"}, {"sha": "f70d4144a3c9ef4276899c9e31cb912007232df0", "filename": "src/test/run-pass/generator/nested_generators.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Frun-pass%2Fgenerator%2Fnested_generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Frun-pass%2Fgenerator%2Fnested_generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fnested_generators.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+#![feature(generator_trait)]\n+\n+use std::ops::Generator;\n+use std::ops::GeneratorState;\n+\n+fn main() {\n+    let _generator = || {\n+        let mut sub_generator = || {\n+            yield 2;\n+        };\n+\n+        match sub_generator.resume() {\n+            GeneratorState::Yielded(x) => {\n+                yield x;\n+            }\n+            _ => panic!(),\n+        };\n+    };\n+}"}, {"sha": "8353066bfbe8e6a14cfbdc1f1ce8801f75caf2c1", "filename": "src/test/run-pass/generator/reborrow-mut-upvar.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Frun-pass%2Fgenerator%2Freborrow-mut-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Frun-pass%2Fgenerator%2Freborrow-mut-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Freborrow-mut-upvar.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+fn _run(bar: &mut i32) {\n+    || {\n+        {\n+            let _baz = &*bar;\n+            yield;\n+        }\n+\n+        *bar = 2;\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "daf672942467c7762bf246d4f3d5b4ae8936df49", "filename": "src/test/run-pass/generator/static-generators.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Frun-pass%2Fgenerator%2Fstatic-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Frun-pass%2Fgenerator%2Fstatic-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fstatic-generators.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{Generator, GeneratorState};\n+\n+fn main() {\n+    let mut generator = static || {\n+        let a = true;\n+        let b = &a;\n+        yield;\n+        assert_eq!(b as *const _, &a as *const _);\n+    };\n+    assert_eq!(generator.resume(), GeneratorState::Yielded(()));\n+    assert_eq!(generator.resume(), GeneratorState::Complete(()));\n+}\n\\ No newline at end of file"}, {"sha": "ac2a414b742c6009b3f7b7f3c25fb71f9f1383f1", "filename": "src/test/ui/generator/auto-trait-regions.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.rs?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+#![feature(optin_builtin_traits)]\n+\n+auto trait Foo {}\n+\n+struct No;\n+\n+impl !Foo for No {}\n+\n+struct A<'a, 'b>(&'a mut bool, &'b mut bool, No);\n+\n+impl<'a, 'b: 'a> Foo for A<'a, 'b> {}\n+\n+struct OnlyFooIfStaticRef(No);\n+impl Foo for &'static OnlyFooIfStaticRef {}\n+\n+struct OnlyFooIfRef(No);\n+impl<'a> Foo for &'a OnlyFooIfRef {}\n+\n+fn assert_foo<T: Foo>(f: T) {}\n+\n+fn main() {\n+    // Make sure 'static is erased for generator interiors so we can't match it in trait selection\n+    let x: &'static _ = &OnlyFooIfStaticRef(No);\n+    let gen = || {\n+        let x = x;\n+        yield;\n+        assert_foo(x);\n+    };\n+    assert_foo(gen); //~ ERROR the trait bound `No: Foo` is not satisfied\n+\n+    // Allow impls which matches any lifetime\n+    let x = &OnlyFooIfRef(No);\n+    let gen = || {\n+        let x = x;\n+        yield;\n+        assert_foo(x);\n+    };\n+    assert_foo(gen); // ok\n+\n+    // Disallow impls which relates lifetimes in the generator interior\n+    let gen = || {\n+        let a = A(&mut true, &mut true, No);\n+        yield;\n+        assert_foo(a);\n+    };\n+    assert_foo(gen); //~ ERROR the requirement `for<'r, 's> 'r : 's` is not satisfied\n+}"}, {"sha": "37241e615101d23b1f45f787da35071518769423", "filename": "src/test/ui/generator/auto-trait-regions.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -0,0 +1,35 @@\n+error[E0277]: the trait bound `No: Foo` is not satisfied in `[generator@$DIR/auto-trait-regions.rs:35:15: 39:6 x:&&'static OnlyFooIfStaticRef for<'r> {&'r OnlyFooIfStaticRef, ()}]`\n+  --> $DIR/auto-trait-regions.rs:40:5\n+   |\n+40 |     assert_foo(gen); //~ ERROR the trait bound `No: Foo` is not satisfied\n+   |     ^^^^^^^^^^ within `[generator@$DIR/auto-trait-regions.rs:35:15: 39:6 x:&&'static OnlyFooIfStaticRef for<'r> {&'r OnlyFooIfStaticRef, ()}]`, the trait `Foo` is not implemented for `No`\n+   |\n+   = help: the following implementations were found:\n+             <No as Foo>\n+   = note: required because it appears within the type `OnlyFooIfStaticRef`\n+   = note: required because it appears within the type `&OnlyFooIfStaticRef`\n+   = note: required because it appears within the type `for<'r> {&'r OnlyFooIfStaticRef, ()}`\n+   = note: required because it appears within the type `[generator@$DIR/auto-trait-regions.rs:35:15: 39:6 x:&&'static OnlyFooIfStaticRef for<'r> {&'r OnlyFooIfStaticRef, ()}]`\n+note: required by `assert_foo`\n+  --> $DIR/auto-trait-regions.rs:30:1\n+   |\n+30 | fn assert_foo<T: Foo>(f: T) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0279]: the requirement `for<'r, 's> 'r : 's` is not satisfied (`expected bound lifetime parameter, found concrete lifetime`)\n+  --> $DIR/auto-trait-regions.rs:57:5\n+   |\n+57 |     assert_foo(gen); //~ ERROR the requirement `for<'r, 's> 'r : 's` is not satisfied\n+   |     ^^^^^^^^^^\n+   |\n+   = note: required because of the requirements on the impl of `for<'r, 's> Foo` for `A<'_, '_>`\n+   = note: required because it appears within the type `for<'r, 's> {A<'r, 's>, ()}`\n+   = note: required because it appears within the type `[generator@$DIR/auto-trait-regions.rs:52:15: 56:6 for<'r, 's> {A<'r, 's>, ()}]`\n+note: required by `assert_foo`\n+  --> $DIR/auto-trait-regions.rs:30:1\n+   |\n+30 | fn assert_foo<T: Foo>(f: T) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "e65c8f1546e82d46a2aac8b0ef829fd7201262a3", "filename": "src/test/ui/generator/not-send-sync.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fnot-send-sync.stderr?ref=ccf0d8399e1ef3ed6bf7005650ce42aa646b5cc7", "patch": "@@ -13,15 +13,15 @@ note: required by `main::assert_send`\n 17 |     fn assert_send<T: Send>(_: T) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0277]: the trait bound `std::cell::Cell<i32>: std::marker::Sync` is not satisfied in `[generator@$DIR/not-send-sync.rs:19:17: 23:6 (std::cell::Cell<i32>, ())]`\n+error[E0277]: the trait bound `std::cell::Cell<i32>: std::marker::Sync` is not satisfied in `[generator@$DIR/not-send-sync.rs:19:17: 23:6 {std::cell::Cell<i32>, ()}]`\n   --> $DIR/not-send-sync.rs:19:5\n    |\n 19 |     assert_sync(|| {\n    |     ^^^^^^^^^^^ `std::cell::Cell<i32>` cannot be shared between threads safely\n    |\n-   = help: within `[generator@$DIR/not-send-sync.rs:19:17: 23:6 (std::cell::Cell<i32>, ())]`, the trait `std::marker::Sync` is not implemented for `std::cell::Cell<i32>`\n-   = note: required because it appears within the type `(std::cell::Cell<i32>, ())`\n-   = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:19:17: 23:6 (std::cell::Cell<i32>, ())]`\n+   = help: within `[generator@$DIR/not-send-sync.rs:19:17: 23:6 {std::cell::Cell<i32>, ()}]`, the trait `std::marker::Sync` is not implemented for `std::cell::Cell<i32>`\n+   = note: required because it appears within the type `{std::cell::Cell<i32>, ()}`\n+   = note: required because it appears within the type `[generator@$DIR/not-send-sync.rs:19:17: 23:6 {std::cell::Cell<i32>, ()}]`\n note: required by `main::assert_sync`\n   --> $DIR/not-send-sync.rs:16:5\n    |"}]}