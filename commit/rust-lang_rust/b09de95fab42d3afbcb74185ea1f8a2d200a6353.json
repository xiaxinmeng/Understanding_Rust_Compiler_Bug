{"sha": "b09de95fab42d3afbcb74185ea1f8a2d200a6353", "node_id": "C_kwDOAAsO6NoAKGIwOWRlOTVmYWI0MmQzYWZiY2I3NDE4NWVhMWY4YTJkMjAwYTYzNTM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-16T18:10:23Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-20T16:29:27Z"}, "message": "Merge two query callbacks arrays.", "tree": {"sha": "bf19aa90ec14f99125d260b98505f1bc4e737b1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf19aa90ec14f99125d260b98505f1bc4e737b1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b09de95fab42d3afbcb74185ea1f8a2d200a6353", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b09de95fab42d3afbcb74185ea1f8a2d200a6353", "html_url": "https://github.com/rust-lang/rust/commit/b09de95fab42d3afbcb74185ea1f8a2d200a6353", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b09de95fab42d3afbcb74185ea1f8a2d200a6353/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc7143367c85f3f498d072ef4a2b8befdf1f75c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc7143367c85f3f498d072ef4a2b8befdf1f75c0", "html_url": "https://github.com/rust-lang/rust/commit/dc7143367c85f3f498d072ef4a2b8befdf1f75c0"}], "stats": {"total": 427, "additions": 180, "deletions": 247}, "files": [{"sha": "571337a8dcbc6a3e2ec3ad13acdb56cfac8996f4", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=b09de95fab42d3afbcb74185ea1f8a2d200a6353", "patch": "@@ -126,30 +126,36 @@ impl IfThisChanged<'tcx> {\n             if attr.has_name(sym::rustc_if_this_changed) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n-                    None => DepNode::from_def_path_hash(def_path_hash, DepKind::hir_owner),\n-                    Some(n) => match DepNode::from_label_string(&n.as_str(), def_path_hash) {\n-                        Ok(n) => n,\n-                        Err(()) => {\n-                            self.tcx.sess.span_fatal(\n-                                attr.span,\n-                                &format!(\"unrecognized DepNode variant {:?}\", n),\n-                            );\n+                    None => {\n+                        DepNode::from_def_path_hash(self.tcx, def_path_hash, DepKind::hir_owner)\n+                    }\n+                    Some(n) => {\n+                        match DepNode::from_label_string(self.tcx, &n.as_str(), def_path_hash) {\n+                            Ok(n) => n,\n+                            Err(()) => {\n+                                self.tcx.sess.span_fatal(\n+                                    attr.span,\n+                                    &format!(\"unrecognized DepNode variant {:?}\", n),\n+                                );\n+                            }\n                         }\n-                    },\n+                    }\n                 };\n                 self.if_this_changed.push((attr.span, def_id.to_def_id(), dep_node));\n             } else if attr.has_name(sym::rustc_then_this_would_need) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n-                    Some(n) => match DepNode::from_label_string(&n.as_str(), def_path_hash) {\n-                        Ok(n) => n,\n-                        Err(()) => {\n-                            self.tcx.sess.span_fatal(\n-                                attr.span,\n-                                &format!(\"unrecognized DepNode variant {:?}\", n),\n-                            );\n+                    Some(n) => {\n+                        match DepNode::from_label_string(self.tcx, &n.as_str(), def_path_hash) {\n+                            Ok(n) => n,\n+                            Err(()) => {\n+                                self.tcx.sess.span_fatal(\n+                                    attr.span,\n+                                    &format!(\"unrecognized DepNode variant {:?}\", n),\n+                                );\n+                            }\n                         }\n-                    },\n+                    }\n                     None => {\n                         self.tcx.sess.span_fatal(attr.span, \"missing DepNode variant\");\n                     }"}, {"sha": "b2eaf61b7d14560912011fcea60ed46f8723e739", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=b09de95fab42d3afbcb74185ea1f8a2d200a6353", "patch": "@@ -15,7 +15,7 @@\n use rustc_ast::{self as ast, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::Node as HirNode;\n@@ -302,18 +302,6 @@ impl DirtyCleanVisitor<'tcx> {\n         out\n     }\n \n-    fn dep_nodes<'l>(\n-        &self,\n-        labels: &'l Labels,\n-        def_id: DefId,\n-    ) -> impl Iterator<Item = DepNode> + 'l {\n-        let def_path_hash = self.tcx.def_path_hash(def_id);\n-        labels.iter().map(move |label| match DepNode::from_label_string(label, def_path_hash) {\n-            Ok(dep_node) => dep_node,\n-            Err(()) => unreachable!(\"label: {}\", label),\n-        })\n-    }\n-\n     fn dep_node_str(&self, dep_node: &DepNode) -> String {\n         if let Some(def_id) = dep_node.extract_def_id(self.tcx) {\n             format!(\"{:?}({})\", dep_node.kind, self.tcx.def_path_str(def_id))\n@@ -345,16 +333,19 @@ impl DirtyCleanVisitor<'tcx> {\n     }\n \n     fn check_item(&mut self, item_id: LocalDefId, item_span: Span) {\n+        let def_path_hash = self.tcx.def_path_hash(item_id.to_def_id());\n         for attr in self.tcx.get_attrs(item_id.to_def_id()).iter() {\n             let assertion = match self.assertion_maybe(item_id, attr) {\n                 Some(a) => a,\n                 None => continue,\n             };\n             self.checked_attrs.insert(attr.id);\n-            for dep_node in self.dep_nodes(&assertion.clean, item_id.to_def_id()) {\n+            for label in assertion.clean {\n+                let dep_node = DepNode::from_label_string(self.tcx, &label, def_path_hash).unwrap();\n                 self.assert_clean(item_span, dep_node);\n             }\n-            for dep_node in self.dep_nodes(&assertion.dirty, item_id.to_def_id()) {\n+            for label in assertion.dirty {\n+                let dep_node = DepNode::from_label_string(self.tcx, &label, def_path_hash).unwrap();\n                 self.assert_dirty(item_span, dep_node);\n             }\n         }"}, {"sha": "8bd6ed989739f5ca67db4eddd8285e4ebb66f99a", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=b09de95fab42d3afbcb74185ea1f8a2d200a6353", "patch": "@@ -838,6 +838,7 @@ pub fn create_global_ctxt<'tcx>(\n                 dep_graph,\n                 queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),\n                 queries.as_dyn(),\n+                &rustc_query_impl::QUERY_CALLBACKS,\n                 crate_name,\n                 outputs,\n             )"}, {"sha": "ee0b4ec7a60726a5fc4480de2fcc7ae89ddeb176", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 72, "deletions": 114, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=b09de95fab42d3afbcb74185ea1f8a2d200a6353", "patch": "@@ -78,32 +78,70 @@ pub struct DepKindStruct {\n     /// Anonymous queries cannot be replayed from one compiler invocation to the next.\n     /// When their result is needed, it is recomputed. They are useful for fine-grained\n     /// dependency tracking, and caching within one compiler invocation.\n-    pub(super) is_anon: bool,\n+    pub is_anon: bool,\n \n     /// Eval-always queries do not track their dependencies, and are always recomputed, even if\n     /// their inputs have not changed since the last compiler invocation. The result is still\n     /// cached within one compiler invocation.\n-    pub(super) is_eval_always: bool,\n+    pub is_eval_always: bool,\n \n     /// Whether the query key can be recovered from the hashed fingerprint.\n     /// See [DepNodeParams] trait for the behaviour of each key type.\n-    // FIXME: Make this a simple boolean once DepNodeParams::fingerprint_style\n-    // can be made a specialized associated const.\n-    fingerprint_style: fn() -> FingerprintStyle,\n-}\n-\n-impl std::ops::Deref for DepKind {\n-    type Target = DepKindStruct;\n-    fn deref(&self) -> &DepKindStruct {\n-        &DEP_KINDS[*self as usize]\n-    }\n+    pub fingerprint_style: fn() -> FingerprintStyle,\n+\n+    /// The red/green evaluation system will try to mark a specific DepNode in the\n+    /// dependency graph as green by recursively trying to mark the dependencies of\n+    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n+    /// where we don't know if it is red or green and we therefore actually have\n+    /// to recompute its value in order to find out. Since the only piece of\n+    /// information that we have at that point is the `DepNode` we are trying to\n+    /// re-evaluate, we need some way to re-run a query from just that. This is what\n+    /// `force_from_dep_node()` implements.\n+    ///\n+    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n+    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+    /// is usually constructed by computing a stable hash of the query-key that the\n+    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n+    /// back from hash to query-key (since hash functions are not reversible). For\n+    /// this reason `force_from_dep_node()` is expected to fail from time to time\n+    /// because we just cannot find out, from the `DepNode` alone, what the\n+    /// corresponding query-key is and therefore cannot re-run the query.\n+    ///\n+    /// The system deals with this case letting `try_mark_green` fail which forces\n+    /// the root query to be re-evaluated.\n+    ///\n+    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n+    /// Fortunately, we can use some contextual information that will allow us to\n+    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n+    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n+    /// everything we need to re-run the query.\n+    ///\n+    /// Take the `mir_promoted` query as an example. Like many other queries, it\n+    /// just has a single parameter: the `DefId` of the item it will compute the\n+    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n+    ///\n+    /// When you implement a new query, it will likely have a corresponding new\n+    /// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n+    /// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n+    /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n+    /// add it to the \"We don't have enough information to reconstruct...\" group in\n+    /// the match below.\n+    pub force_from_dep_node: fn(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool,\n+\n+    /// Invoke a query to put the on-disk cached value in memory.\n+    pub try_load_from_on_disk_cache: fn(TyCtxt<'_>, &DepNode),\n }\n \n impl DepKind {\n     #[inline(always)]\n-    pub fn fingerprint_style(&self) -> FingerprintStyle {\n+    pub fn fingerprint_style(self, tcx: TyCtxt<'_>) -> FingerprintStyle {\n         // Only fetch the DepKindStruct once.\n-        let data: &DepKindStruct = &**self;\n+        let data = tcx.query_kind(self);\n         if data.is_anon {\n             return FingerprintStyle::Opaque;\n         }\n@@ -112,94 +150,6 @@ impl DepKind {\n     }\n }\n \n-macro_rules! is_anon_attr {\n-    (anon) => {\n-        true\n-    };\n-    ($attr:ident) => {\n-        false\n-    };\n-}\n-\n-macro_rules! is_eval_always_attr {\n-    (eval_always) => {\n-        true\n-    };\n-    ($attr:ident) => {\n-        false\n-    };\n-}\n-\n-macro_rules! contains_anon_attr {\n-    ($(($attr:ident $($attr_args:tt)* )),*) => ({$(is_anon_attr!($attr) | )* false});\n-}\n-\n-macro_rules! contains_eval_always_attr {\n-    ($(($attr:ident $($attr_args:tt)* )),*) => ({$(is_eval_always_attr!($attr) | )* false});\n-}\n-\n-#[allow(non_upper_case_globals)]\n-pub mod dep_kind {\n-    use super::*;\n-    use crate::ty::query::query_keys;\n-    use rustc_query_system::dep_graph::FingerprintStyle;\n-\n-    // We use this for most things when incr. comp. is turned off.\n-    pub const Null: DepKindStruct = DepKindStruct {\n-        is_anon: false,\n-        is_eval_always: false,\n-\n-        fingerprint_style: || FingerprintStyle::Unit,\n-    };\n-\n-    pub const TraitSelect: DepKindStruct = DepKindStruct {\n-        is_anon: true,\n-        is_eval_always: false,\n-\n-        fingerprint_style: || FingerprintStyle::Unit,\n-    };\n-\n-    pub const CompileCodegenUnit: DepKindStruct = DepKindStruct {\n-        is_anon: false,\n-        is_eval_always: false,\n-\n-        fingerprint_style: || FingerprintStyle::Opaque,\n-    };\n-\n-    pub const CompileMonoItem: DepKindStruct = DepKindStruct {\n-        is_anon: false,\n-        is_eval_always: false,\n-\n-        fingerprint_style: || FingerprintStyle::Opaque,\n-    };\n-\n-    macro_rules! define_query_dep_kinds {\n-        ($(\n-            [$($attrs:tt)*]\n-            $variant:ident $(( $tuple_arg_ty:ty $(,)? ))*\n-        ,)*) => (\n-            $(pub const $variant: DepKindStruct = {\n-                const is_anon: bool = contains_anon_attr!($($attrs)*);\n-                const is_eval_always: bool = contains_eval_always_attr!($($attrs)*);\n-\n-                #[inline(always)]\n-                fn fingerprint_style() -> rustc_query_system::dep_graph::FingerprintStyle {\n-                    <query_keys::$variant<'_> as DepNodeParams<TyCtxt<'_>>>\n-                        ::fingerprint_style()\n-                }\n-\n-                DepKindStruct {\n-                    is_anon,\n-                    is_eval_always,\n-                    fingerprint_style,\n-                }\n-            };)*\n-        );\n-    }\n-\n-    rustc_dep_node_append!([define_query_dep_kinds!][]);\n-}\n-\n macro_rules! define_dep_nodes {\n     (<$tcx:tt>\n     $(\n@@ -212,9 +162,7 @@ macro_rules! define_dep_nodes {\n             ($mod:ident) => {[ $(($mod::$variant),)* ]};\n         }\n \n-        static DEP_KINDS: &[DepKindStruct] = &make_dep_kind_array!(dep_kind);\n-\n-        /// This enum serves as an index into the `DEP_KINDS` array.\n+        /// This enum serves as an index into arrays built by `make_dep_kind_array`.\n         #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n         #[allow(non_camel_case_types)]\n         pub enum DepKind {\n@@ -280,7 +228,7 @@ pub trait DepNodeExt: Sized {\n     /// Construct a DepNode from the given DepKind and DefPathHash. This\n     /// method will assert that the given DepKind actually requires a\n     /// single DefId/DefPathHash parameter.\n-    fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> Self;\n+    fn from_def_path_hash(tcx: TyCtxt<'_>, def_path_hash: DefPathHash, kind: DepKind) -> Self;\n \n     /// Extracts the DefId corresponding to this DepNode. This will work\n     /// if two conditions are met:\n@@ -295,7 +243,11 @@ pub trait DepNodeExt: Sized {\n     fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId>;\n \n     /// Used in testing\n-    fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<Self, ()>;\n+    fn from_label_string(\n+        tcx: TyCtxt<'_>,\n+        label: &str,\n+        def_path_hash: DefPathHash,\n+    ) -> Result<Self, ()>;\n \n     /// Used in testing\n     fn has_label_string(label: &str) -> bool;\n@@ -305,8 +257,8 @@ impl DepNodeExt for DepNode {\n     /// Construct a DepNode from the given DepKind and DefPathHash. This\n     /// method will assert that the given DepKind actually requires a\n     /// single DefId/DefPathHash parameter.\n-    fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n-        debug_assert!(kind.fingerprint_style() == FingerprintStyle::DefPathHash);\n+    fn from_def_path_hash(tcx: TyCtxt<'_>, def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n+        debug_assert!(kind.fingerprint_style(tcx) == FingerprintStyle::DefPathHash);\n         DepNode { kind, hash: def_path_hash.0.into() }\n     }\n \n@@ -321,21 +273,27 @@ impl DepNodeExt for DepNode {\n     /// refers to something from the previous compilation session that\n     /// has been removed.\n     fn extract_def_id(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n-        if self.kind.fingerprint_style() == FingerprintStyle::DefPathHash {\n+        if self.kind.fingerprint_style(tcx) == FingerprintStyle::DefPathHash {\n             Some(tcx.def_path_hash_to_def_id(DefPathHash(self.hash.into())))\n         } else {\n             None\n         }\n     }\n \n     /// Used in testing\n-    fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<DepNode, ()> {\n+    fn from_label_string(\n+        tcx: TyCtxt<'_>,\n+        label: &str,\n+        def_path_hash: DefPathHash,\n+    ) -> Result<DepNode, ()> {\n         let kind = dep_kind_from_label_string(label)?;\n \n-        match kind.fingerprint_style() {\n+        match kind.fingerprint_style(tcx) {\n             FingerprintStyle::Opaque => Err(()),\n-            FingerprintStyle::Unit => Ok(DepNode::new_no_params(kind)),\n-            FingerprintStyle::DefPathHash => Ok(DepNode::from_def_path_hash(def_path_hash, kind)),\n+            FingerprintStyle::Unit => Ok(DepNode::new_no_params(tcx, kind)),\n+            FingerprintStyle::DefPathHash => {\n+                Ok(DepNode::from_def_path_hash(tcx, def_path_hash, kind))\n+            }\n         }\n     }\n "}, {"sha": "7ace3a10158a5594538ac439ad610720022c470c", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=b09de95fab42d3afbcb74185ea1f8a2d200a6353", "patch": "@@ -12,7 +12,7 @@ pub use rustc_query_system::dep_graph::{\n     SerializedDepNodeIndex, WorkProduct, WorkProductId,\n };\n \n-pub use dep_node::{label_strs, DepKind, DepNode, DepNodeExt};\n+pub use dep_node::{label_strs, DepKind, DepKindStruct, DepNode, DepNodeExt};\n crate use dep_node::{make_compile_codegen_unit, make_compile_mono_item};\n \n pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n@@ -24,16 +24,6 @@ pub type EdgeFilter = rustc_query_system::dep_graph::debug::EdgeFilter<DepKind>;\n impl rustc_query_system::dep_graph::DepKind for DepKind {\n     const NULL: Self = DepKind::Null;\n \n-    #[inline(always)]\n-    fn fingerprint_style(&self) -> rustc_query_system::dep_graph::FingerprintStyle {\n-        DepKind::fingerprint_style(self)\n-    }\n-\n-    #[inline(always)]\n-    fn is_eval_always(&self) -> bool {\n-        self.is_eval_always\n-    }\n-\n     fn debug_node(node: &DepNode, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         write!(f, \"{:?}(\", node.kind)?;\n \n@@ -99,4 +89,14 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     fn sess(&self) -> &Session {\n         self.sess\n     }\n+\n+    #[inline(always)]\n+    fn fingerprint_style(&self, kind: DepKind) -> rustc_query_system::dep_graph::FingerprintStyle {\n+        kind.fingerprint_style(*self)\n+    }\n+\n+    #[inline(always)]\n+    fn is_eval_always(&self, kind: DepKind) -> bool {\n+        self.query_kind(kind).is_eval_always\n+    }\n }"}, {"sha": "b00a2c65575f39df961d113a17b8f25780ab5dc9", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=b09de95fab42d3afbcb74185ea1f8a2d200a6353", "patch": "@@ -1,7 +1,7 @@\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n-use crate::dep_graph::DepGraph;\n+use crate::dep_graph::{DepGraph, DepKind, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n@@ -1011,6 +1011,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n     pub query_caches: query::QueryCaches<'tcx>,\n+    query_kinds: &'tcx [DepKindStruct],\n \n     // Internal caches for metadata decoding. No need to track deps on this.\n     pub ty_rcache: Lock<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n@@ -1144,6 +1145,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         dep_graph: DepGraph,\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n         queries: &'tcx dyn query::QueryEngine<'tcx>,\n+        query_kinds: &'tcx [DepKindStruct],\n         crate_name: &str,\n         output_filenames: OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {\n@@ -1170,6 +1172,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             on_disk_cache,\n             queries,\n             query_caches: query::QueryCaches::default(),\n+            query_kinds,\n             ty_rcache: Default::default(),\n             pred_rcache: Default::default(),\n             selection_cache: Default::default(),\n@@ -1183,6 +1186,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    pub fn query_kind(self, k: DepKind) -> &'tcx DepKindStruct {\n+        &self.query_kinds[k as usize]\n+    }\n+\n     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` to ensure it gets used.\n     #[track_caller]\n     pub fn ty_error(self) -> Ty<'tcx> {"}, {"sha": "aa9c5bc5aba5cb925fd65c23bd74ce1fd9aa702c", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=b09de95fab42d3afbcb74185ea1f8a2d200a6353", "patch": "@@ -19,7 +19,7 @@ extern crate tracing;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::DiagnosticBuilder;\n-use rustc_middle::dep_graph;\n+use rustc_middle::dep_graph::{self, DepKindStruct};\n use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};\n use rustc_middle::ty::query::{Providers, QueryEngine};\n use rustc_middle::ty::{self, TyCtxt};\n@@ -29,7 +29,6 @@ use rustc_span::Span;\n #[macro_use]\n mod plumbing;\n pub use plumbing::QueryCtxt;\n-use plumbing::QueryStruct;\n use rustc_query_system::query::*;\n \n mod stats;"}, {"sha": "043e6b1c1513906f136fbfd419360c9a6d14f710", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 33, "deletions": 65, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=b09de95fab42d3afbcb74185ea1f8a2d200a6353", "patch": "@@ -55,7 +55,7 @@ impl QueryContext for QueryCtxt<'tcx> {\n \n     fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n         let cb = &super::QUERY_CALLBACKS[dep_node.kind as usize];\n-        (cb.try_load_from_on_disk_cache)(*self, dep_node)\n+        (cb.try_load_from_on_disk_cache)(**self, dep_node)\n     }\n \n     fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n@@ -80,7 +80,7 @@ impl QueryContext for QueryCtxt<'tcx> {\n         );\n \n         let cb = &super::QUERY_CALLBACKS[dep_node.kind as usize];\n-        (cb.force_from_dep_node)(*self, dep_node)\n+        (cb.force_from_dep_node)(**self, dep_node)\n     }\n \n     // Interactions with on_disk_cache\n@@ -193,60 +193,6 @@ impl<'tcx> QueryCtxt<'tcx> {\n     }\n }\n \n-/// This struct stores metadata about each Query.\n-///\n-/// Information is retrieved by indexing the `QUERIES` array using the integer value\n-/// of the `DepKind`. Overall, this allows to implement `QueryContext` using this manual\n-/// jump table instead of large matches.\n-pub struct QueryStruct {\n-    /// The red/green evaluation system will try to mark a specific DepNode in the\n-    /// dependency graph as green by recursively trying to mark the dependencies of\n-    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n-    /// where we don't know if it is red or green and we therefore actually have\n-    /// to recompute its value in order to find out. Since the only piece of\n-    /// information that we have at that point is the `DepNode` we are trying to\n-    /// re-evaluate, we need some way to re-run a query from just that. This is what\n-    /// `force_from_dep_node()` implements.\n-    ///\n-    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n-    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n-    /// is usually constructed by computing a stable hash of the query-key that the\n-    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n-    /// back from hash to query-key (since hash functions are not reversible). For\n-    /// this reason `force_from_dep_node()` is expected to fail from time to time\n-    /// because we just cannot find out, from the `DepNode` alone, what the\n-    /// corresponding query-key is and therefore cannot re-run the query.\n-    ///\n-    /// The system deals with this case letting `try_mark_green` fail which forces\n-    /// the root query to be re-evaluated.\n-    ///\n-    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n-    /// Fortunately, we can use some contextual information that will allow us to\n-    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n-    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n-    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n-    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n-    /// everything we need to re-run the query.\n-    ///\n-    /// Take the `mir_promoted` query as an example. Like many other queries, it\n-    /// just has a single parameter: the `DefId` of the item it will compute the\n-    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n-    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n-    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n-    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n-    ///\n-    /// When you implement a new query, it will likely have a corresponding new\n-    /// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n-    /// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n-    /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n-    /// add it to the \"We don't have enough information to reconstruct...\" group in\n-    /// the match below.\n-    pub(crate) force_from_dep_node: fn(tcx: QueryCtxt<'_>, dep_node: &DepNode) -> bool,\n-\n-    /// Invoke a query to put the on-disk cached value in memory.\n-    pub(crate) try_load_from_on_disk_cache: fn(QueryCtxt<'_>, &DepNode),\n-}\n-\n macro_rules! handle_cycle_error {\n     ([][$tcx: expr, $error:expr]) => {{\n         $error.emit();\n@@ -425,28 +371,45 @@ macro_rules! define_queries {\n             use rustc_query_system::dep_graph::FingerprintStyle;\n \n             // We use this for most things when incr. comp. is turned off.\n-            pub const Null: QueryStruct = QueryStruct {\n+            pub const Null: DepKindStruct = DepKindStruct {\n+                is_anon: false,\n+                is_eval_always: false,\n+\n+                fingerprint_style: || FingerprintStyle::Unit,\n                 force_from_dep_node: |_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node),\n                 try_load_from_on_disk_cache: |_, _| {},\n             };\n \n-            pub const TraitSelect: QueryStruct = QueryStruct {\n+            pub const TraitSelect: DepKindStruct = DepKindStruct {\n+                is_anon: true,\n+                is_eval_always: false,\n+\n+                fingerprint_style: || FingerprintStyle::Unit,\n                 force_from_dep_node: |_, _| false,\n                 try_load_from_on_disk_cache: |_, _| {},\n             };\n \n-            pub const CompileCodegenUnit: QueryStruct = QueryStruct {\n+            pub const CompileCodegenUnit: DepKindStruct = DepKindStruct {\n+                is_anon: false,\n+                is_eval_always: false,\n+\n+                fingerprint_style: || FingerprintStyle::Opaque,\n                 force_from_dep_node: |_, _| false,\n                 try_load_from_on_disk_cache: |_, _| {},\n             };\n \n-            pub const CompileMonoItem: QueryStruct = QueryStruct {\n+            pub const CompileMonoItem: DepKindStruct = DepKindStruct {\n+                is_anon: false,\n+                is_eval_always: false,\n+\n+                fingerprint_style: || FingerprintStyle::Opaque,\n                 force_from_dep_node: |_, _| false,\n                 try_load_from_on_disk_cache: |_, _| {},\n             };\n \n-            $(pub const $name: QueryStruct = {\n+            $(pub const $name: DepKindStruct = {\n                 const is_anon: bool = is_anon!([$($modifiers)*]);\n+                const is_eval_always: bool = is_eval_always!([$($modifiers)*]);\n \n                 #[inline(always)]\n                 fn fingerprint_style() -> FingerprintStyle {\n@@ -458,11 +421,13 @@ macro_rules! define_queries {\n                     <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node)\n                 }\n \n-                fn force_from_dep_node(tcx: QueryCtxt<'_>, dep_node: &DepNode) -> bool {\n+                fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n+                    let tcx = QueryCtxt::from_tcx(tcx);\n                     force_query::<queries::$name<'_>, _>(tcx, dep_node)\n                 }\n \n-                fn try_load_from_on_disk_cache(tcx: QueryCtxt<'_>, dep_node: &DepNode) {\n+                fn try_load_from_on_disk_cache(tcx: TyCtxt<'_>, dep_node: &DepNode) {\n+                    let tcx = QueryCtxt::from_tcx(tcx);\n                     if is_anon {\n                         return\n                     }\n@@ -479,14 +444,17 @@ macro_rules! define_queries {\n                     }\n                 }\n \n-                QueryStruct {\n+                DepKindStruct {\n+                    is_anon,\n+                    is_eval_always,\n+                    fingerprint_style,\n                     force_from_dep_node,\n                     try_load_from_on_disk_cache,\n                 }\n             };)*\n         }\n \n-        static QUERY_CALLBACKS: &[QueryStruct] = &make_dep_kind_array!(query_callbacks);\n+        pub static QUERY_CALLBACKS: &[DepKindStruct] = &make_dep_kind_array!(query_callbacks);\n     }\n }\n "}, {"sha": "19000badf75b496bbc21a302af095b01e07e2958", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=b09de95fab42d3afbcb74185ea1f8a2d200a6353", "patch": "@@ -60,8 +60,11 @@ impl<K: DepKind> DepNode<K> {\n     /// Creates a new, parameterless DepNode. This method will assert\n     /// that the DepNode corresponding to the given DepKind actually\n     /// does not require any parameters.\n-    pub fn new_no_params(kind: K) -> DepNode<K> {\n-        debug_assert_eq!(kind.fingerprint_style(), FingerprintStyle::Unit);\n+    pub fn new_no_params<Ctxt>(tcx: Ctxt, kind: K) -> DepNode<K>\n+    where\n+        Ctxt: super::DepContext<DepKind = K>,\n+    {\n+        debug_assert_eq!(tcx.fingerprint_style(kind), FingerprintStyle::Unit);\n         DepNode { kind, hash: Fingerprint::ZERO.into() }\n     }\n \n@@ -75,7 +78,7 @@ impl<K: DepKind> DepNode<K> {\n \n         #[cfg(debug_assertions)]\n         {\n-            if !kind.fingerprint_style().reconstructible()\n+            if !tcx.fingerprint_style(kind).reconstructible()\n                 && (tcx.sess().opts.debugging_opts.incremental_info\n                     || tcx.sess().opts.debugging_opts.query_dep_graph)\n             {"}, {"sha": "5822370388b380f8563b9cbdab80fec535d0729f", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=b09de95fab42d3afbcb74185ea1f8a2d200a6353", "patch": "@@ -252,7 +252,7 @@ impl<K: DepKind> DepGraph<K> {\n             key\n         );\n \n-        let task_deps = if key.kind.is_eval_always() {\n+        let task_deps = if cx.dep_context().is_eval_always(key.kind) {\n             None\n         } else {\n             Some(Lock::new(TaskDeps {\n@@ -316,7 +316,7 @@ impl<K: DepKind> DepGraph<K> {\n     where\n         OP: FnOnce() -> R,\n     {\n-        debug_assert!(!dep_kind.is_eval_always());\n+        debug_assert!(!cx.is_eval_always(dep_kind));\n \n         if let Some(ref data) = self.data {\n             let task_deps = Lock::new(TaskDeps::default());\n@@ -493,7 +493,7 @@ impl<K: DepKind> DepGraph<K> {\n         tcx: Ctxt,\n         dep_node: &DepNode<K>,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n-        debug_assert!(!dep_node.kind.is_eval_always());\n+        debug_assert!(!tcx.dep_context().is_eval_always(dep_node.kind));\n \n         // Return None if the dep graph is disabled\n         let data = self.data.as_ref()?;\n@@ -553,7 +553,7 @@ impl<K: DepKind> DepGraph<K> {\n \n         // We don't know the state of this dependency. If it isn't\n         // an eval_always node, let's try to mark it green recursively.\n-        if !dep_dep_node.kind.is_eval_always() {\n+        if !tcx.dep_context().is_eval_always(dep_dep_node.kind) {\n             debug!(\n                 \"try_mark_previous_green({:?}) --- state of dependency {:?} ({}) \\\n                                  is unknown, trying to mark it green\",\n@@ -643,7 +643,7 @@ impl<K: DepKind> DepGraph<K> {\n         }\n \n         // We never try to mark eval_always nodes as green\n-        debug_assert!(!dep_node.kind.is_eval_always());\n+        debug_assert!(!tcx.dep_context().is_eval_always(dep_node.kind));\n \n         debug_assert_eq!(data.previous.index_to_node(prev_dep_node_index), *dep_node);\n "}, {"sha": "6a81c401105b31ec08a61ffb4878b7281c1183b6", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=b09de95fab42d3afbcb74185ea1f8a2d200a6353", "patch": "@@ -32,6 +32,11 @@ pub trait DepContext: Copy {\n \n     /// Access the compiler session.\n     fn sess(&self) -> &Session;\n+\n+    /// Return whether this kind always require evaluation.\n+    fn is_eval_always(&self, kind: Self::DepKind) -> bool;\n+\n+    fn fingerprint_style(&self, kind: Self::DepKind) -> FingerprintStyle;\n }\n \n pub trait HasDepContext: Copy {\n@@ -75,9 +80,6 @@ impl FingerprintStyle {\n pub trait DepKind: Copy + fmt::Debug + Eq + Hash + Send + Encodable<FileEncoder> + 'static {\n     const NULL: Self;\n \n-    /// Return whether this kind always require evaluation.\n-    fn is_eval_always(&self) -> bool;\n-\n     /// Implementation of `std::fmt::Debug` for `DepNode`.\n     fn debug_node(node: &DepNode<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result;\n \n@@ -90,6 +92,4 @@ pub trait DepKind: Copy + fmt::Debug + Eq + Hash + Send + Encodable<FileEncoder>\n     fn read_deps<OP>(op: OP)\n     where\n         OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps<Self>>>);\n-\n-    fn fingerprint_style(&self) -> FingerprintStyle;\n }"}, {"sha": "aa35347534dd0f28dddba45028fbad9cea249a0b", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09de95fab42d3afbcb74185ea1f8a2d200a6353/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=b09de95fab42d3afbcb74185ea1f8a2d200a6353", "patch": "@@ -2,7 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex, DepNodeParams};\n+use crate::dep_graph::{DepContext, DepNode, DepNodeIndex, DepNodeParams};\n use crate::query::caches::QueryCache;\n use crate::query::config::{QueryDescription, QueryVtable, QueryVtableExt};\n use crate::query::job::{\n@@ -520,14 +520,6 @@ where\n         let result = query.try_load_from_disk(tcx, prev_dep_node_index);\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n-        // We always expect to find a cached result for things that\n-        // can be forced from `DepNode`.\n-        debug_assert!(\n-            !dep_node.kind.fingerprint_style().reconstructible() || result.is_some(),\n-            \"missing on-disk cache entry for {:?}\",\n-            dep_node\n-        );\n-\n         if let Some(result) = result {\n             // If `-Zincremental-verify-ich` is specified, re-hash results from\n             // the cache and make sure that they have the expected fingerprint.\n@@ -537,6 +529,14 @@ where\n \n             return Some((result, dep_node_index));\n         }\n+\n+        // We always expect to find a cached result for things that\n+        // can be forced from `DepNode`.\n+        debug_assert!(\n+            !tcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n+            \"missing on-disk cache entry for {:?}\",\n+            dep_node\n+        );\n     }\n \n     // We could not load a result from the on-disk cache, so"}]}