{"sha": "0cde85523f60b8de774bda91d171c9277464d489", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjZGU4NTUyM2Y2MGI4ZGU3NzRiZGE5MWQxNzFjOTI3NzQ2NGQ0ODk=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-03-07T17:09:35Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-03-24T20:48:34Z"}, "message": "Rework rustdoc const type", "tree": {"sha": "be80e7d44e9c12894f4212bf861c618e1b5c76bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be80e7d44e9c12894f4212bf861c618e1b5c76bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cde85523f60b8de774bda91d171c9277464d489", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cde85523f60b8de774bda91d171c9277464d489", "html_url": "https://github.com/rust-lang/rust/commit/0cde85523f60b8de774bda91d171c9277464d489", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cde85523f60b8de774bda91d171c9277464d489/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5fe425c925ef36d5f4c18cfa44173fc42de31b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5fe425c925ef36d5f4c18cfa44173fc42de31b8", "html_url": "https://github.com/rust-lang/rust/commit/f5fe425c925ef36d5f4c18cfa44173fc42de31b8"}], "stats": {"total": 1413, "additions": 805, "deletions": 608}, "files": [{"sha": "223b35634bf2eee3b7e047f8b969684b67359a45", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=0cde85523f60b8de774bda91d171c9277464d489", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::Mutability;\n use rustc_metadata::creader::LoadedMacro;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_mir::const_eval::is_min_const_fn;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -490,24 +490,17 @@ fn build_module(\n     clean::Module { items, is_crate: false }\n }\n \n-crate fn print_inlined_const(cx: &DocContext<'_>, did: DefId) -> String {\n+crate fn print_inlined_const(tcx: TyCtxt<'_>, did: DefId) -> String {\n     if let Some(did) = did.as_local() {\n-        let hir_id = cx.tcx.hir().local_def_id_to_hir_id(did);\n-        rustc_hir_pretty::id_to_string(&cx.tcx.hir(), hir_id)\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n+        rustc_hir_pretty::id_to_string(&tcx.hir(), hir_id)\n     } else {\n-        cx.tcx.rendered_const(did)\n+        tcx.rendered_const(did)\n     }\n }\n \n fn build_const(cx: &mut DocContext<'_>, did: DefId) -> clean::Constant {\n-    clean::Constant {\n-        type_: cx.tcx.type_of(did).clean(cx),\n-        expr: print_inlined_const(cx, did),\n-        value: clean::utils::print_evaluated_const(cx, did),\n-        is_literal: did.as_local().map_or(false, |did| {\n-            clean::utils::is_literal_expr(cx, cx.tcx.hir().local_def_id_to_hir_id(did))\n-        }),\n-    }\n+    clean::Constant::Inline { type_: cx.tcx.type_of(did).clean(cx), did }\n }\n \n fn build_static(cx: &mut DocContext<'_>, did: DefId, mutable: bool) -> clean::Static {"}, {"sha": "6bb8ed60420773003a40aaeaa386f7ae95869cd5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0cde85523f60b8de774bda91d171c9277464d489", "patch": "@@ -393,14 +393,12 @@ impl Clean<Lifetime> for hir::GenericParam<'_> {\n \n impl Clean<Constant> for hir::ConstArg {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n-        Constant {\n+        Constant::Generic {\n             type_: cx\n                 .tcx\n                 .type_of(cx.tcx.hir().body_owner_def_id(self.value.body).to_def_id())\n                 .clean(cx),\n-            expr: print_const_expr(cx.tcx, self.value.body),\n-            value: None,\n-            is_literal: is_literal_expr(cx, self.value.body.hir_id),\n+            body: self.value.body,\n         }\n     }\n }\n@@ -1135,7 +1133,7 @@ impl Clean<Item> for ty::AssocItem {\n             ty::AssocKind::Const => {\n                 let ty = tcx.type_of(self.def_id);\n                 let default = if self.defaultness.has_value() {\n-                    Some(inline::print_inlined_const(cx, self.def_id))\n+                    Some(inline::print_inlined_const(cx.tcx, self.def_id))\n                 } else {\n                     None\n                 };\n@@ -1745,12 +1743,8 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n-        Constant {\n-            type_: self.ty.clean(cx),\n-            expr: format!(\"{}\", self),\n-            value: None,\n-            is_literal: false,\n-        }\n+        // FIXME: instead of storing `format!(\"{}\", self)`, store `self` directly instead.\n+        Constant::TyConst { type_: self.ty.clean(cx), expr: format!(\"{}\", self) }\n     }\n }\n \n@@ -1951,11 +1945,10 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                 ItemKind::Static(ty, mutability, body_id) => {\n                     StaticItem(Static { type_: ty.clean(cx), mutability, expr: Some(body_id) })\n                 }\n-                ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n+                ItemKind::Const(ty, body_id) => ConstantItem(Constant::Const {\n                     type_: ty.clean(cx),\n-                    expr: print_const_expr(cx.tcx, body_id),\n-                    value: print_evaluated_const(cx, def_id),\n-                    is_literal: is_literal_expr(cx, body_id.hir_id),\n+                    body: body_id,\n+                    did: def_id,\n                 }),\n                 ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n                     bounds: ty.bounds.clean(cx),"}, {"sha": "bc2588a35f9c2cea9416e4a42f550093cb857792", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 60, "deletions": 6, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=0cde85523f60b8de774bda91d171c9277464d489", "patch": "@@ -32,8 +32,9 @@ use rustc_target::spec::abi::Abi;\n \n use crate::clean::cfg::Cfg;\n use crate::clean::external_path;\n-use crate::clean::inline;\n+use crate::clean::inline::{self, print_inlined_const};\n use crate::clean::types::Type::{QPath, ResolvedPath};\n+use crate::clean::utils::{is_literal_expr, print_const_expr, print_evaluated_const};\n use crate::clean::Clean;\n use crate::core::DocContext;\n use crate::formats::cache::Cache;\n@@ -1986,11 +1987,64 @@ crate struct Static {\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-crate struct Constant {\n-    crate type_: Type,\n-    crate expr: String,\n-    crate value: Option<String>,\n-    crate is_literal: bool,\n+crate enum Constant {\n+    /// Typed constant value.\n+    TyConst { type_: Type, expr: String },\n+    /// A constant (expression) that\u2019s not an item or associated item. These are usually found\n+    /// nested inside types (e.g., array lengths) or expressions (e.g., repeat counts), and also\n+    /// used to define explicit discriminant values for enum variants.\n+    Generic { type_: Type, body: BodyId },\n+    /// Inlined constant (from another crate).\n+    Inline { type_: Type, did: DefId },\n+    /// const FOO: u32 = ...;\n+    Const { type_: Type, did: DefId, body: BodyId },\n+}\n+\n+impl Constant {\n+    crate fn expr(&self, tcx: TyCtxt<'_>) -> String {\n+        match self {\n+            Self::TyConst { expr, .. } => expr.clone(),\n+            Self::Inline { did, .. } => print_inlined_const(tcx, *did),\n+            Self::Const { body, .. } | Self::Generic { body, .. } => print_const_expr(tcx, *body),\n+        }\n+    }\n+\n+    crate fn value(&self, tcx: TyCtxt<'_>) -> Option<String> {\n+        match self {\n+            Self::TyConst { .. } | Self::Generic { .. } => None,\n+            Self::Inline { did, .. } | Self::Const { did, .. } => print_evaluated_const(tcx, *did),\n+        }\n+    }\n+\n+    crate fn is_literal(&self, tcx: TyCtxt<'_>) -> bool {\n+        match self {\n+            Self::TyConst { .. } => false,\n+            Self::Inline { did, .. } => did\n+                .as_local()\n+                .map_or(false, |did| is_literal_expr(tcx, tcx.hir().local_def_id_to_hir_id(did))),\n+            Self::Const { body, .. } | Self::Generic { body, .. } => {\n+                is_literal_expr(tcx, body.hir_id)\n+            }\n+        }\n+    }\n+\n+    crate fn type_(&self) -> &Type {\n+        match *self {\n+            Self::TyConst { ref type_, .. }\n+            | Self::Inline { ref type_, .. }\n+            | Self::Const { ref type_, .. }\n+            | Self::Generic { ref type_, .. } => type_,\n+        }\n+    }\n+\n+    crate fn to_type(self) -> Type {\n+        match self {\n+            Self::TyConst { type_, .. }\n+            | Self::Inline { type_, .. }\n+            | Self::Const { type_, .. }\n+            | Self::Generic { type_, .. } => type_,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "32bac53e8f51b78f89da360452a4f61a53c7b0cb", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=0cde85523f60b8de774bda91d171c9277464d489", "patch": "@@ -301,7 +301,7 @@ crate fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n                 let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def.did);\n                 print_const_expr(cx.tcx, cx.tcx.hir().body_owned_by(hir_id))\n             } else {\n-                inline::print_inlined_const(cx, def.did)\n+                inline::print_inlined_const(cx.tcx, def.did)\n             };\n             if let Some(promoted) = promoted {\n                 s.push_str(&format!(\"::{:?}\", promoted))\n@@ -324,15 +324,15 @@ crate fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n     }\n }\n \n-crate fn print_evaluated_const(cx: &DocContext<'_>, def_id: DefId) -> Option<String> {\n-    cx.tcx.const_eval_poly(def_id).ok().and_then(|val| {\n-        let ty = cx.tcx.type_of(def_id);\n+crate fn print_evaluated_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<String> {\n+    tcx.const_eval_poly(def_id).ok().and_then(|val| {\n+        let ty = tcx.type_of(def_id);\n         match (val, ty.kind()) {\n             (_, &ty::Ref(..)) => None,\n             (ConstValue::Scalar(_), &ty::Adt(_, _)) => None,\n             (ConstValue::Scalar(_), _) => {\n-                let const_ = ty::Const::from_value(cx.tcx, val, ty);\n-                Some(print_const_with_custom_print_scalar(cx, const_))\n+                let const_ = ty::Const::from_value(tcx, val, ty);\n+                Some(print_const_with_custom_print_scalar(tcx, const_))\n             }\n             _ => None,\n         }\n@@ -349,16 +349,16 @@ fn format_integer_with_underscore_sep(num: &str) -> String {\n         .collect()\n }\n \n-fn print_const_with_custom_print_scalar(cx: &DocContext<'_>, ct: &'tcx ty::Const<'tcx>) -> String {\n+fn print_const_with_custom_print_scalar(tcx: TyCtxt<'_>, ct: &'tcx ty::Const<'tcx>) -> String {\n     // Use a slightly different format for integer types which always shows the actual value.\n     // For all other types, fallback to the original `pretty_print_const`.\n     match (ct.val, ct.ty.kind()) {\n         (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Uint(ui)) => {\n             format!(\"{}{}\", format_integer_with_underscore_sep(&int.to_string()), ui.name_str())\n         }\n         (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Int(i)) => {\n-            let ty = cx.tcx.lift(ct.ty).unwrap();\n-            let size = cx.tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size;\n+            let ty = tcx.lift(ct.ty).unwrap();\n+            let size = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size;\n             let data = int.assert_bits(size);\n             let sign_extended_data = size.sign_extend(data) as i128;\n \n@@ -372,8 +372,8 @@ fn print_const_with_custom_print_scalar(cx: &DocContext<'_>, ct: &'tcx ty::Const\n     }\n }\n \n-crate fn is_literal_expr(cx: &DocContext<'_>, hir_id: hir::HirId) -> bool {\n-    if let hir::Node::Expr(expr) = cx.tcx.hir().get(hir_id) {\n+crate fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n+    if let hir::Node::Expr(expr) = tcx.hir().get(hir_id) {\n         if let hir::ExprKind::Lit(_) = &expr.kind {\n             return true;\n         }\n@@ -411,7 +411,7 @@ crate fn resolve_type(cx: &mut DocContext<'_>, path: Path, id: hir::HirId) -> Ty\n             return Generic(kw::SelfUpper);\n         }\n         Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n-            return Generic(Symbol::intern(&format!(\"{:#}\", path.print(&cx.cache))));\n+            return Generic(Symbol::intern(&format!(\"{:#}\", path.print(&cx.cache, cx.tcx))));\n         }\n         Res::SelfTy(..) | Res::Def(DefKind::TyParam | DefKind::AssocTy, _) => true,\n         _ => false,"}, {"sha": "a004ee5054ed68baacb27f118788c5890685b1af", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 404, "deletions": 313, "changes": 717, "blob_url": "https://github.com/rust-lang/rust/blob/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0cde85523f60b8de774bda91d171c9277464d489", "patch": "@@ -5,10 +5,10 @@\n //! assume that HTML output is desired, although it may be possible to redesign\n //! them in the future to instead emit any format desired.\n \n-use std::borrow::Cow;\n use std::cell::Cell;\n use std::fmt;\n \n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_middle::ty::TyCtxt;\n@@ -111,31 +111,6 @@ impl Buffer {\n     }\n }\n \n-/// Wrapper struct for properly emitting a function or method declaration.\n-crate struct Function<'a> {\n-    /// The declaration to emit.\n-    crate decl: &'a clean::FnDecl,\n-    /// The length of the function header and name. In other words, the number of characters in the\n-    /// function declaration up to but not including the parentheses.\n-    ///\n-    /// Used to determine line-wrapping.\n-    crate header_len: usize,\n-    /// The number of spaces to indent each successive line with, if line-wrapping is necessary.\n-    crate indent: usize,\n-    /// Whether the function is async or not.\n-    crate asyncness: hir::IsAsync,\n-}\n-\n-/// Wrapper struct for emitting a where-clause from Generics.\n-crate struct WhereClause<'a> {\n-    /// The Generics from which to emit a where-clause.\n-    crate gens: &'a clean::Generics,\n-    /// The number of spaces to indent each line with.\n-    crate indent: usize,\n-    /// Whether the where-clause needs to add a comma and newline after the last bound.\n-    crate end_newline: bool,\n-}\n-\n fn comma_sep<T: fmt::Display>(items: impl Iterator<Item = T>) -> impl fmt::Display {\n     display_fn(move |f| {\n         for (i, item) in items.enumerate() {\n@@ -148,173 +123,188 @@ fn comma_sep<T: fmt::Display>(items: impl Iterator<Item = T>) -> impl fmt::Displ\n     })\n }\n \n-crate fn print_generic_bounds<'a>(\n+crate fn print_generic_bounds<'a, 'tcx: 'a>(\n     bounds: &'a [clean::GenericBound],\n     cache: &'a Cache,\n-) -> impl fmt::Display + 'a {\n+    tcx: TyCtxt<'tcx>,\n+) -> impl fmt::Display + 'a + Captures<'tcx> {\n     display_fn(move |f| {\n         let mut bounds_dup = FxHashSet::default();\n \n         for (i, bound) in\n-            bounds.iter().filter(|b| bounds_dup.insert(b.print(cache).to_string())).enumerate()\n+            bounds.iter().filter(|b| bounds_dup.insert(b.print(cache, tcx).to_string())).enumerate()\n         {\n             if i > 0 {\n                 f.write_str(\" + \")?;\n             }\n-            fmt::Display::fmt(&bound.print(cache), f)?;\n+            fmt::Display::fmt(&bound.print(cache, tcx), f)?;\n         }\n         Ok(())\n     })\n }\n \n impl clean::GenericParamDef {\n-    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+    crate fn print<'a, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'a Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self.kind {\n             clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n             clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n                 f.write_str(&*self.name.as_str())?;\n \n                 if !bounds.is_empty() {\n                     if f.alternate() {\n-                        write!(f, \": {:#}\", print_generic_bounds(bounds, cache))?;\n+                        write!(f, \": {:#}\", print_generic_bounds(bounds, cache, tcx))?;\n                     } else {\n-                        write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cache))?;\n+                        write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cache, tcx))?;\n                     }\n                 }\n \n                 if let Some(ref ty) = default {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty.print(cache))?;\n+                        write!(f, \" = {:#}\", ty.print(cache, tcx))?;\n                     } else {\n-                        write!(f, \"&nbsp;=&nbsp;{}\", ty.print(cache))?;\n+                        write!(f, \"&nbsp;=&nbsp;{}\", ty.print(cache, tcx))?;\n                     }\n                 }\n \n                 Ok(())\n             }\n             clean::GenericParamDefKind::Const { ref ty, .. } => {\n                 if f.alternate() {\n-                    write!(f, \"const {}: {:#}\", self.name, ty.print(cache))\n+                    write!(f, \"const {}: {:#}\", self.name, ty.print(cache, tcx))\n                 } else {\n-                    write!(f, \"const {}:&nbsp;{}\", self.name, ty.print(cache))\n+                    write!(f, \"const {}:&nbsp;{}\", self.name, ty.print(cache, tcx))\n                 }\n             }\n         })\n     }\n }\n \n impl clean::Generics {\n-    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+    crate fn print<'a, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'a Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             let real_params =\n                 self.params.iter().filter(|p| !p.is_synthetic_type_param()).collect::<Vec<_>>();\n             if real_params.is_empty() {\n                 return Ok(());\n             }\n             if f.alternate() {\n-                write!(f, \"<{:#}>\", comma_sep(real_params.iter().map(|g| g.print(cache))))\n+                write!(f, \"<{:#}>\", comma_sep(real_params.iter().map(|g| g.print(cache, tcx))))\n             } else {\n-                write!(f, \"&lt;{}&gt;\", comma_sep(real_params.iter().map(|g| g.print(cache))))\n+                write!(f, \"&lt;{}&gt;\", comma_sep(real_params.iter().map(|g| g.print(cache, tcx))))\n             }\n         })\n     }\n }\n \n-impl<'a> WhereClause<'a> {\n-    crate fn print<'b>(&'b self, cache: &'b Cache) -> impl fmt::Display + 'b {\n-        display_fn(move |f| {\n-            let &WhereClause { gens, indent, end_newline } = self;\n-            if gens.where_predicates.is_empty() {\n-                return Ok(());\n+/// * The Generics from which to emit a where-clause.\n+/// * The number of spaces to indent each line with.\n+/// * Whether the where-clause needs to add a comma and newline after the last bound.\n+crate fn print_where_clause<'a, 'tcx: 'a>(\n+    gens: &'a clean::Generics,\n+    cache: &'a Cache,\n+    tcx: TyCtxt<'tcx>,\n+    indent: usize,\n+    end_newline: bool,\n+) -> impl fmt::Display + 'a + Captures<'tcx> {\n+    display_fn(move |f| {\n+        if gens.where_predicates.is_empty() {\n+            return Ok(());\n+        }\n+        let mut clause = String::new();\n+        if f.alternate() {\n+            clause.push_str(\" where\");\n+        } else {\n+            if end_newline {\n+                clause.push_str(\" <span class=\\\"where fmt-newline\\\">where\");\n+            } else {\n+                clause.push_str(\" <span class=\\\"where\\\">where\");\n             }\n-            let mut clause = String::new();\n+        }\n+        for (i, pred) in gens.where_predicates.iter().enumerate() {\n             if f.alternate() {\n-                clause.push_str(\" where\");\n+                clause.push(' ');\n             } else {\n-                if end_newline {\n-                    clause.push_str(\" <span class=\\\"where fmt-newline\\\">where\");\n-                } else {\n-                    clause.push_str(\" <span class=\\\"where\\\">where\");\n-                }\n+                clause.push_str(\"<br>\");\n             }\n-            for (i, pred) in gens.where_predicates.iter().enumerate() {\n-                if f.alternate() {\n-                    clause.push(' ');\n-                } else {\n-                    clause.push_str(\"<br>\");\n-                }\n \n-                match pred {\n-                    clean::WherePredicate::BoundPredicate { ty, bounds } => {\n-                        let bounds = bounds;\n-                        if f.alternate() {\n-                            clause.push_str(&format!(\n-                                \"{:#}: {:#}\",\n-                                ty.print(cache),\n-                                print_generic_bounds(bounds, cache)\n-                            ));\n-                        } else {\n-                            clause.push_str(&format!(\n-                                \"{}: {}\",\n-                                ty.print(cache),\n-                                print_generic_bounds(bounds, cache)\n-                            ));\n-                        }\n-                    }\n-                    clean::WherePredicate::RegionPredicate { lifetime, bounds } => {\n+            match pred {\n+                clean::WherePredicate::BoundPredicate { ty, bounds } => {\n+                    let bounds = bounds;\n+                    if f.alternate() {\n+                        clause.push_str(&format!(\n+                            \"{:#}: {:#}\",\n+                            ty.print(cache, tcx),\n+                            print_generic_bounds(bounds, cache, tcx)\n+                        ));\n+                    } else {\n                         clause.push_str(&format!(\n                             \"{}: {}\",\n-                            lifetime.print(),\n-                            bounds\n-                                .iter()\n-                                .map(|b| b.print(cache).to_string())\n-                                .collect::<Vec<_>>()\n-                                .join(\" + \")\n+                            ty.print(cache, tcx),\n+                            print_generic_bounds(bounds, cache, tcx)\n                         ));\n                     }\n-                    clean::WherePredicate::EqPredicate { lhs, rhs } => {\n-                        if f.alternate() {\n-                            clause.push_str(&format!(\n-                                \"{:#} == {:#}\",\n-                                lhs.print(cache),\n-                                rhs.print(cache)\n-                            ));\n-                        } else {\n-                            clause.push_str(&format!(\n-                                \"{} == {}\",\n-                                lhs.print(cache),\n-                                rhs.print(cache)\n-                            ));\n-                        }\n+                }\n+                clean::WherePredicate::RegionPredicate { lifetime, bounds } => {\n+                    clause.push_str(&format!(\n+                        \"{}: {}\",\n+                        lifetime.print(),\n+                        bounds\n+                            .iter()\n+                            .map(|b| b.print(cache, tcx).to_string())\n+                            .collect::<Vec<_>>()\n+                            .join(\" + \")\n+                    ));\n+                }\n+                clean::WherePredicate::EqPredicate { lhs, rhs } => {\n+                    if f.alternate() {\n+                        clause.push_str(&format!(\n+                            \"{:#} == {:#}\",\n+                            lhs.print(cache, tcx),\n+                            rhs.print(cache, tcx),\n+                        ));\n+                    } else {\n+                        clause.push_str(&format!(\n+                            \"{} == {}\",\n+                            lhs.print(cache, tcx),\n+                            rhs.print(cache, tcx),\n+                        ));\n                     }\n                 }\n+            }\n \n-                if i < gens.where_predicates.len() - 1 || end_newline {\n-                    clause.push(',');\n-                }\n+            if i < gens.where_predicates.len() - 1 || end_newline {\n+                clause.push(',');\n             }\n+        }\n \n-            if end_newline {\n-                // add a space so stripping <br> tags and breaking spaces still renders properly\n-                if f.alternate() {\n-                    clause.push(' ');\n-                } else {\n-                    clause.push_str(\"&nbsp;\");\n-                }\n+        if end_newline {\n+            // add a space so stripping <br> tags and breaking spaces still renders properly\n+            if f.alternate() {\n+                clause.push(' ');\n+            } else {\n+                clause.push_str(\"&nbsp;\");\n             }\n+        }\n \n-            if !f.alternate() {\n-                clause.push_str(\"</span>\");\n-                let padding = \"&nbsp;\".repeat(indent + 4);\n-                clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n-                clause.insert_str(0, &\"&nbsp;\".repeat(indent.saturating_sub(1)));\n-                if !end_newline {\n-                    clause.insert_str(0, \"<br>\");\n-                }\n+        if !f.alternate() {\n+            clause.push_str(\"</span>\");\n+            let padding = \"&nbsp;\".repeat(indent + 4);\n+            clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n+            clause.insert_str(0, &\"&nbsp;\".repeat(indent.saturating_sub(1)));\n+            if !end_newline {\n+                clause.insert_str(0, \"<br>\");\n             }\n-            write!(f, \"{}\", clause)\n-        })\n-    }\n+        }\n+        write!(f, \"{}\", clause)\n+    })\n }\n \n impl clean::Lifetime {\n@@ -324,46 +314,53 @@ impl clean::Lifetime {\n }\n \n impl clean::Constant {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n-        display_fn(move |f| {\n-            if f.alternate() {\n-                f.write_str(&self.expr)\n-            } else {\n-                write!(f, \"{}\", Escape(&self.expr))\n-            }\n-        })\n+    crate fn print(&self, tcx: TyCtxt<'_>) -> impl fmt::Display + '_ {\n+        let expr = self.expr(tcx);\n+        display_fn(\n+            move |f| {\n+                if f.alternate() { f.write_str(&expr) } else { write!(f, \"{}\", Escape(&expr)) }\n+            },\n+        )\n     }\n }\n \n impl clean::PolyTrait {\n-    fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+    fn print<'a, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'a Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             if !self.generic_params.is_empty() {\n                 if f.alternate() {\n                     write!(\n                         f,\n                         \"for<{:#}> \",\n-                        comma_sep(self.generic_params.iter().map(|g| g.print(cache)))\n+                        comma_sep(self.generic_params.iter().map(|g| g.print(cache, tcx)))\n                     )?;\n                 } else {\n                     write!(\n                         f,\n                         \"for&lt;{}&gt; \",\n-                        comma_sep(self.generic_params.iter().map(|g| g.print(cache)))\n+                        comma_sep(self.generic_params.iter().map(|g| g.print(cache, tcx)))\n                     )?;\n                 }\n             }\n             if f.alternate() {\n-                write!(f, \"{:#}\", self.trait_.print(cache))\n+                write!(f, \"{:#}\", self.trait_.print(cache, tcx))\n             } else {\n-                write!(f, \"{}\", self.trait_.print(cache))\n+                write!(f, \"{}\", self.trait_.print(cache, tcx))\n             }\n         })\n     }\n }\n \n impl clean::GenericBound {\n-    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+    crate fn print<'a, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'a Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self {\n             clean::GenericBound::Outlives(lt) => write!(f, \"{}\", lt.print()),\n             clean::GenericBound::TraitBound(ty, modifier) => {\n@@ -373,17 +370,21 @@ impl clean::GenericBound {\n                     hir::TraitBoundModifier::MaybeConst => \"?const\",\n                 };\n                 if f.alternate() {\n-                    write!(f, \"{}{:#}\", modifier_str, ty.print(cache))\n+                    write!(f, \"{}{:#}\", modifier_str, ty.print(cache, tcx))\n                 } else {\n-                    write!(f, \"{}{}\", modifier_str, ty.print(cache))\n+                    write!(f, \"{}{}\", modifier_str, ty.print(cache, tcx))\n                 }\n             }\n         })\n     }\n }\n \n impl clean::GenericArgs {\n-    fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+    fn print<'a, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'a Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             match self {\n                 clean::GenericArgs::AngleBracketed { args, bindings } => {\n@@ -400,9 +401,9 @@ impl clean::GenericArgs {\n                             }\n                             comma = true;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", arg.print(cache))?;\n+                                write!(f, \"{:#}\", arg.print(cache, tcx))?;\n                             } else {\n-                                write!(f, \"{}\", arg.print(cache))?;\n+                                write!(f, \"{}\", arg.print(cache, tcx))?;\n                             }\n                         }\n                         for binding in bindings {\n@@ -411,9 +412,9 @@ impl clean::GenericArgs {\n                             }\n                             comma = true;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", binding.print(cache))?;\n+                                write!(f, \"{:#}\", binding.print(cache, tcx))?;\n                             } else {\n-                                write!(f, \"{}\", binding.print(cache))?;\n+                                write!(f, \"{}\", binding.print(cache, tcx))?;\n                             }\n                         }\n                         if f.alternate() {\n@@ -432,17 +433,17 @@ impl clean::GenericArgs {\n                         }\n                         comma = true;\n                         if f.alternate() {\n-                            write!(f, \"{:#}\", ty.print(cache))?;\n+                            write!(f, \"{:#}\", ty.print(cache, tcx))?;\n                         } else {\n-                            write!(f, \"{}\", ty.print(cache))?;\n+                            write!(f, \"{}\", ty.print(cache, tcx))?;\n                         }\n                     }\n                     f.write_str(\")\")?;\n                     if let Some(ref ty) = *output {\n                         if f.alternate() {\n-                            write!(f, \" -> {:#}\", ty.print(cache))?;\n+                            write!(f, \" -> {:#}\", ty.print(cache, tcx))?;\n                         } else {\n-                            write!(f, \" -&gt; {}\", ty.print(cache))?;\n+                            write!(f, \" -&gt; {}\", ty.print(cache, tcx))?;\n                         }\n                     }\n                 }\n@@ -453,19 +454,27 @@ impl clean::GenericArgs {\n }\n \n impl clean::PathSegment {\n-    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+    crate fn print<'a, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'a Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             if f.alternate() {\n-                write!(f, \"{}{:#}\", self.name, self.args.print(cache))\n+                write!(f, \"{}{:#}\", self.name, self.args.print(cache, tcx))\n             } else {\n-                write!(f, \"{}{}\", self.name, self.args.print(cache))\n+                write!(f, \"{}{}\", self.name, self.args.print(cache, tcx))\n             }\n         })\n     }\n }\n \n impl clean::Path {\n-    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+    crate fn print<'a, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'a Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             if self.global {\n                 f.write_str(\"::\")?\n@@ -476,9 +485,9 @@ impl clean::Path {\n                     f.write_str(\"::\")?\n                 }\n                 if f.alternate() {\n-                    write!(f, \"{:#}\", seg.print(cache))?;\n+                    write!(f, \"{:#}\", seg.print(cache, tcx))?;\n                 } else {\n-                    write!(f, \"{}\", seg.print(cache))?;\n+                    write!(f, \"{}\", seg.print(cache, tcx))?;\n                 }\n             }\n             Ok(())\n@@ -528,13 +537,14 @@ crate fn href(did: DefId, cache: &Cache) -> Option<(String, ItemType, Vec<String\n \n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n-fn resolved_path(\n+fn resolved_path<'a, 'tcx: 'a>(\n     w: &mut fmt::Formatter<'_>,\n     did: DefId,\n     path: &clean::Path,\n     print_all: bool,\n     use_absolute: bool,\n     cache: &Cache,\n+    tcx: TyCtxt<'tcx>,\n ) -> fmt::Result {\n     let last = path.segments.last().unwrap();\n \n@@ -544,7 +554,7 @@ fn resolved_path(\n         }\n     }\n     if w.alternate() {\n-        write!(w, \"{}{:#}\", &last.name, last.args.print(cache))?;\n+        write!(w, \"{}{:#}\", &last.name, last.args.print(cache, tcx))?;\n     } else {\n         let path = if use_absolute {\n             if let Some((_, _, fqp)) = href(did, cache) {\n@@ -559,7 +569,7 @@ fn resolved_path(\n         } else {\n             anchor(did, &*last.name.as_str(), cache).to_string()\n         };\n-        write!(w, \"{}{}\", path, last.args.print(cache))?;\n+        write!(w, \"{}{}\", path, last.args.print(cache, tcx))?;\n     }\n     Ok(())\n }\n@@ -615,15 +625,16 @@ fn primitive_link(\n }\n \n /// Helper to render type parameters\n-fn tybounds<'a>(\n+fn tybounds<'a, 'tcx: 'a>(\n     param_names: &'a Option<Vec<clean::GenericBound>>,\n     cache: &'a Cache,\n-) -> impl fmt::Display + 'a {\n+    tcx: TyCtxt<'tcx>,\n+) -> impl fmt::Display + 'a + Captures<'tcx> {\n     display_fn(move |f| match *param_names {\n         Some(ref params) => {\n             for param in params {\n                 write!(f, \" + \")?;\n-                fmt::Display::fmt(&param.print(cache), f)?;\n+                fmt::Display::fmt(&param.print(cache, tcx), f)?;\n             }\n             Ok(())\n         }\n@@ -654,6 +665,7 @@ fn fmt_type(\n     f: &mut fmt::Formatter<'_>,\n     use_absolute: bool,\n     cache: &Cache,\n+    tcx: TyCtxt<'_>,\n ) -> fmt::Result {\n     debug!(\"fmt_type(t = {:?})\", t);\n \n@@ -664,8 +676,8 @@ fn fmt_type(\n                 f.write_str(\"dyn \")?;\n             }\n             // Paths like `T::Output` and `Self::Output` should be rendered with all segments.\n-            resolved_path(f, did, path, is_generic, use_absolute, cache)?;\n-            fmt::Display::fmt(&tybounds(param_names, cache), f)\n+            resolved_path(f, did, path, is_generic, use_absolute, cache, tcx)?;\n+            fmt::Display::fmt(&tybounds(param_names, cache, tcx), f)\n         }\n         clean::Infer => write!(f, \"_\"),\n         clean::Primitive(prim) => primitive_link(f, prim, prim.as_str(), cache),\n@@ -674,21 +686,21 @@ fn fmt_type(\n                 write!(\n                     f,\n                     \"{:#}{}{:#}fn{:#}\",\n-                    decl.print_hrtb_with_space(cache),\n+                    decl.print_hrtb_with_space(cache, tcx),\n                     decl.unsafety.print_with_space(),\n                     print_abi_with_space(decl.abi),\n-                    decl.decl.print(cache)\n+                    decl.decl.print(cache, tcx),\n                 )\n             } else {\n                 write!(\n                     f,\n                     \"{}{}{}\",\n-                    decl.print_hrtb_with_space(cache),\n+                    decl.print_hrtb_with_space(cache, tcx),\n                     decl.unsafety.print_with_space(),\n                     print_abi_with_space(decl.abi)\n                 )?;\n                 primitive_link(f, PrimitiveType::Fn, \"fn\", cache)?;\n-                write!(f, \"{}\", decl.decl.print(cache))\n+                write!(f, \"{}\", decl.decl.print(cache, tcx))\n             }\n         }\n         clean::Tuple(ref typs) => {\n@@ -697,7 +709,7 @@ fn fmt_type(\n                 &[ref one] => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\", cache)?;\n                     // Carry `f.alternate()` into this display w/o branching manually.\n-                    fmt::Display::fmt(&one.print(cache), f)?;\n+                    fmt::Display::fmt(&one.print(cache, tcx), f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \",)\", cache)\n                 }\n                 many => {\n@@ -706,20 +718,20 @@ fn fmt_type(\n                         if i != 0 {\n                             write!(f, \", \")?;\n                         }\n-                        fmt::Display::fmt(&item.print(cache), f)?;\n+                        fmt::Display::fmt(&item.print(cache, tcx), f)?;\n                     }\n                     primitive_link(f, PrimitiveType::Tuple, \")\", cache)\n                 }\n             }\n         }\n         clean::Slice(ref t) => {\n             primitive_link(f, PrimitiveType::Slice, \"[\", cache)?;\n-            fmt::Display::fmt(&t.print(cache), f)?;\n+            fmt::Display::fmt(&t.print(cache, tcx), f)?;\n             primitive_link(f, PrimitiveType::Slice, \"]\", cache)\n         }\n         clean::Array(ref t, ref n) => {\n             primitive_link(f, PrimitiveType::Array, \"[\", cache)?;\n-            fmt::Display::fmt(&t.print(cache), f)?;\n+            fmt::Display::fmt(&t.print(cache, tcx), f)?;\n             if f.alternate() {\n                 primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n), cache)\n             } else {\n@@ -738,14 +750,14 @@ fn fmt_type(\n                         primitive_link(\n                             f,\n                             clean::PrimitiveType::RawPointer,\n-                            &format!(\"*{} {:#}\", m, t.print(cache)),\n+                            &format!(\"*{} {:#}\", m, t.print(cache, tcx)),\n                             cache,\n                         )\n                     } else {\n                         primitive_link(\n                             f,\n                             clean::PrimitiveType::RawPointer,\n-                            &format!(\"*{} {}\", m, t.print(cache)),\n+                            &format!(\"*{} {}\", m, t.print(cache, tcx)),\n                             cache,\n                         )\n                     }\n@@ -757,7 +769,7 @@ fn fmt_type(\n                         &format!(\"*{} \", m),\n                         cache,\n                     )?;\n-                    fmt::Display::fmt(&t.print(cache), f)\n+                    fmt::Display::fmt(&t.print(cache, tcx), f)\n                 }\n             }\n         }\n@@ -777,14 +789,14 @@ fn fmt_type(\n                                 primitive_link(\n                                     f,\n                                     PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, bt.print(cache)),\n+                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, bt.print(cache, tcx)),\n                                     cache,\n                                 )\n                             } else {\n                                 primitive_link(\n                                     f,\n                                     PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{}]\", amp, lt, m, bt.print(cache)),\n+                                    &format!(\"{}{}{}[{}]\", amp, lt, m, bt.print(cache, tcx)),\n                                     cache,\n                                 )\n                             }\n@@ -797,17 +809,17 @@ fn fmt_type(\n                                 cache,\n                             )?;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", bt.print(cache))?;\n+                                write!(f, \"{:#}\", bt.print(cache, tcx))?;\n                             } else {\n-                                write!(f, \"{}\", bt.print(cache))?;\n+                                write!(f, \"{}\", bt.print(cache, tcx))?;\n                             }\n                             primitive_link(f, PrimitiveType::Slice, \"]\", cache)\n                         }\n                     }\n                 }\n                 clean::ResolvedPath { param_names: Some(ref v), .. } if !v.is_empty() => {\n                     write!(f, \"{}{}{}(\", amp, lt, m)?;\n-                    fmt_type(&ty, f, use_absolute, cache)?;\n+                    fmt_type(&ty, f, use_absolute, cache, tcx)?;\n                     write!(f, \")\")\n                 }\n                 clean::Generic(..) => {\n@@ -817,19 +829,19 @@ fn fmt_type(\n                         &format!(\"{}{}{}\", amp, lt, m),\n                         cache,\n                     )?;\n-                    fmt_type(&ty, f, use_absolute, cache)\n+                    fmt_type(&ty, f, use_absolute, cache, tcx)\n                 }\n                 _ => {\n                     write!(f, \"{}{}{}\", amp, lt, m)?;\n-                    fmt_type(&ty, f, use_absolute, cache)\n+                    fmt_type(&ty, f, use_absolute, cache, tcx)\n                 }\n             }\n         }\n         clean::ImplTrait(ref bounds) => {\n             if f.alternate() {\n-                write!(f, \"impl {:#}\", print_generic_bounds(bounds, cache))\n+                write!(f, \"impl {:#}\", print_generic_bounds(bounds, cache, tcx))\n             } else {\n-                write!(f, \"impl {}\", print_generic_bounds(bounds, cache))\n+                write!(f, \"impl {}\", print_generic_bounds(bounds, cache, tcx))\n             }\n         }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n@@ -841,15 +853,25 @@ fn fmt_type(\n             };\n             if f.alternate() {\n                 if should_show_cast {\n-                    write!(f, \"<{:#} as {:#}>::\", self_type.print(cache), trait_.print(cache))?\n+                    write!(\n+                        f,\n+                        \"<{:#} as {:#}>::\",\n+                        self_type.print(cache, tcx),\n+                        trait_.print(cache, tcx)\n+                    )?\n                 } else {\n-                    write!(f, \"{:#}::\", self_type.print(cache))?\n+                    write!(f, \"{:#}::\", self_type.print(cache, tcx))?\n                 }\n             } else {\n                 if should_show_cast {\n-                    write!(f, \"&lt;{} as {}&gt;::\", self_type.print(cache), trait_.print(cache))?\n+                    write!(\n+                        f,\n+                        \"&lt;{} as {}&gt;::\",\n+                        self_type.print(cache, tcx),\n+                        trait_.print(cache, tcx)\n+                    )?\n                 } else {\n-                    write!(f, \"{}::\", self_type.print(cache))?\n+                    write!(f, \"{}::\", self_type.print(cache, tcx))?\n                 }\n             };\n             match *trait_ {\n@@ -890,52 +912,64 @@ fn fmt_type(\n }\n \n impl clean::Type {\n-    crate fn print<'b, 'a: 'b>(&'a self, cache: &'b Cache) -> impl fmt::Display + 'b {\n-        display_fn(move |f| fmt_type(self, f, false, cache))\n+    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'b Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n+        display_fn(move |f| fmt_type(self, f, false, cache, tcx))\n     }\n }\n \n impl clean::Impl {\n-    crate fn print<'a>(&'a self, cache: &'a Cache, use_absolute: bool) -> impl fmt::Display + 'a {\n+    crate fn print<'a, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'a Cache,\n+        use_absolute: bool,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             if f.alternate() {\n-                write!(f, \"impl{:#} \", self.generics.print(cache))?;\n+                write!(f, \"impl{:#} \", self.generics.print(cache, tcx))?;\n             } else {\n-                write!(f, \"impl{} \", self.generics.print(cache))?;\n+                write!(f, \"impl{} \", self.generics.print(cache, tcx))?;\n             }\n \n             if let Some(ref ty) = self.trait_ {\n                 if self.negative_polarity {\n                     write!(f, \"!\")?;\n                 }\n-                fmt::Display::fmt(&ty.print(cache), f)?;\n+                fmt::Display::fmt(&ty.print(cache, tcx), f)?;\n                 write!(f, \" for \")?;\n             }\n \n             if let Some(ref ty) = self.blanket_impl {\n-                fmt_type(ty, f, use_absolute, cache)?;\n+                fmt_type(ty, f, use_absolute, cache, tcx)?;\n             } else {\n-                fmt_type(&self.for_, f, use_absolute, cache)?;\n+                fmt_type(&self.for_, f, use_absolute, cache, tcx)?;\n             }\n \n-            let where_clause = WhereClause { gens: &self.generics, indent: 0, end_newline: true };\n-            fmt::Display::fmt(&where_clause.print(cache), f)?;\n+            fmt::Display::fmt(&print_where_clause(&self.generics, cache, tcx, 0, true), f)?;\n             Ok(())\n         })\n     }\n }\n \n impl clean::Arguments {\n-    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+    crate fn print<'a, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'a Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             for (i, input) in self.values.iter().enumerate() {\n                 if !input.name.is_empty() {\n                     write!(f, \"{}: \", input.name)?;\n                 }\n                 if f.alternate() {\n-                    write!(f, \"{:#}\", input.type_.print(cache))?;\n+                    write!(f, \"{:#}\", input.type_.print(cache, tcx))?;\n                 } else {\n-                    write!(f, \"{}\", input.type_.print(cache))?;\n+                    write!(f, \"{}\", input.type_.print(cache, tcx))?;\n                 }\n                 if i + 1 < self.values.len() {\n                     write!(f, \", \")?;\n@@ -947,21 +981,33 @@ impl clean::Arguments {\n }\n \n impl clean::FnRetTy {\n-    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+    crate fn print<'a, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'a Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self {\n             clean::Return(clean::Tuple(tys)) if tys.is_empty() => Ok(()),\n-            clean::Return(ty) if f.alternate() => write!(f, \" -> {:#}\", ty.print(cache)),\n-            clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print(cache)),\n+            clean::Return(ty) if f.alternate() => write!(f, \" -> {:#}\", ty.print(cache, tcx)),\n+            clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print(cache, tcx)),\n             clean::DefaultReturn => Ok(()),\n         })\n     }\n }\n \n impl clean::BareFunctionDecl {\n-    fn print_hrtb_with_space<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+    fn print_hrtb_with_space<'a, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'a Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             if !self.generic_params.is_empty() {\n-                write!(f, \"for<{}> \", comma_sep(self.generic_params.iter().map(|g| g.print(cache))))\n+                write!(\n+                    f,\n+                    \"for<{}> \",\n+                    comma_sep(self.generic_params.iter().map(|g| g.print(cache, tcx)))\n+                )\n             } else {\n                 Ok(())\n             }\n@@ -970,147 +1016,176 @@ impl clean::BareFunctionDecl {\n }\n \n impl clean::FnDecl {\n-    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'b Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n         display_fn(move |f| {\n             let ellipsis = if self.c_variadic { \", ...\" } else { \"\" };\n             if f.alternate() {\n                 write!(\n                     f,\n                     \"({args:#}{ellipsis}){arrow:#}\",\n-                    args = self.inputs.print(cache),\n+                    args = self.inputs.print(cache, tcx),\n                     ellipsis = ellipsis,\n-                    arrow = self.output.print(cache)\n+                    arrow = self.output.print(cache, tcx)\n                 )\n             } else {\n                 write!(\n                     f,\n                     \"({args}{ellipsis}){arrow}\",\n-                    args = self.inputs.print(cache),\n+                    args = self.inputs.print(cache, tcx),\n                     ellipsis = ellipsis,\n-                    arrow = self.output.print(cache)\n+                    arrow = self.output.print(cache, tcx)\n                 )\n             }\n         })\n     }\n-}\n \n-impl Function<'_> {\n-    crate fn print<'b, 'a: 'b>(&'a self, cache: &'b Cache) -> impl fmt::Display + 'b {\n-        display_fn(move |f| {\n-            let &Function { decl, header_len, indent, asyncness } = self;\n-            let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n-            let mut args = String::new();\n-            let mut args_plain = String::new();\n-            for (i, input) in decl.inputs.values.iter().enumerate() {\n-                if i == 0 {\n-                    args.push_str(\"<br>\");\n-                }\n+    /// * `header_len`: The length of the function header and name. In other words, the number of\n+    ///   characters in the function declaration up to but not including the parentheses.\n+    ///   <br>Used to determine line-wrapping.\n+    /// * `indent`: The number of spaces to indent each successive line with, if line-wrapping is\n+    ///   necessary.\n+    /// * `asyncness`: Whether the function is async or not.\n+    crate fn full_print<'b, 'a: 'b, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'b Cache,\n+        tcx: TyCtxt<'tcx>,\n+        header_len: usize,\n+        indent: usize,\n+        asyncness: hir::IsAsync,\n+    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n+        display_fn(move |f| self.inner_full_print(cache, tcx, header_len, indent, asyncness, f))\n+    }\n \n-                if let Some(selfty) = input.to_self() {\n-                    match selfty {\n-                        clean::SelfValue => {\n-                            args.push_str(\"self\");\n-                            args_plain.push_str(\"self\");\n-                        }\n-                        clean::SelfBorrowed(Some(ref lt), mtbl) => {\n-                            args.push_str(&format!(\n-                                \"{}{} {}self\",\n-                                amp,\n-                                lt.print(),\n-                                mtbl.print_with_space()\n-                            ));\n-                            args_plain.push_str(&format!(\n-                                \"&{} {}self\",\n-                                lt.print(),\n-                                mtbl.print_with_space()\n-                            ));\n-                        }\n-                        clean::SelfBorrowed(None, mtbl) => {\n-                            args.push_str(&format!(\"{}{}self\", amp, mtbl.print_with_space()));\n-                            args_plain.push_str(&format!(\"&{}self\", mtbl.print_with_space()));\n-                        }\n-                        clean::SelfExplicit(ref typ) => {\n-                            if f.alternate() {\n-                                args.push_str(&format!(\"self: {:#}\", typ.print(cache)));\n-                            } else {\n-                                args.push_str(&format!(\"self: {}\", typ.print(cache)));\n-                            }\n-                            args_plain.push_str(&format!(\"self: {:#}\", typ.print(cache)));\n-                        }\n+    fn inner_full_print(\n+        &self,\n+        cache: &Cache,\n+        tcx: TyCtxt<'_>,\n+        header_len: usize,\n+        indent: usize,\n+        asyncness: hir::IsAsync,\n+        f: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n+        let mut args = String::new();\n+        let mut args_plain = String::new();\n+        for (i, input) in self.inputs.values.iter().enumerate() {\n+            if i == 0 {\n+                args.push_str(\"<br>\");\n+            }\n+\n+            if let Some(selfty) = input.to_self() {\n+                match selfty {\n+                    clean::SelfValue => {\n+                        args.push_str(\"self\");\n+                        args_plain.push_str(\"self\");\n                     }\n-                } else {\n-                    if i > 0 {\n-                        args.push_str(\" <br>\");\n-                        args_plain.push(' ');\n+                    clean::SelfBorrowed(Some(ref lt), mtbl) => {\n+                        args.push_str(&format!(\n+                            \"{}{} {}self\",\n+                            amp,\n+                            lt.print(),\n+                            mtbl.print_with_space()\n+                        ));\n+                        args_plain.push_str(&format!(\n+                            \"&{} {}self\",\n+                            lt.print(),\n+                            mtbl.print_with_space()\n+                        ));\n                     }\n-                    if !input.name.is_empty() {\n-                        args.push_str(&format!(\"{}: \", input.name));\n-                        args_plain.push_str(&format!(\"{}: \", input.name));\n+                    clean::SelfBorrowed(None, mtbl) => {\n+                        args.push_str(&format!(\"{}{}self\", amp, mtbl.print_with_space()));\n+                        args_plain.push_str(&format!(\"&{}self\", mtbl.print_with_space()));\n                     }\n-\n-                    if f.alternate() {\n-                        args.push_str(&format!(\"{:#}\", input.type_.print(cache)));\n-                    } else {\n-                        args.push_str(&input.type_.print(cache).to_string());\n+                    clean::SelfExplicit(ref typ) => {\n+                        if f.alternate() {\n+                            args.push_str(&format!(\"self: {:#}\", typ.print(cache, tcx)));\n+                        } else {\n+                            args.push_str(&format!(\"self: {}\", typ.print(cache, tcx)));\n+                        }\n+                        args_plain.push_str(&format!(\"self: {:#}\", typ.print(cache, tcx)));\n                     }\n-                    args_plain.push_str(&format!(\"{:#}\", input.type_.print(cache)));\n                 }\n-                if i + 1 < decl.inputs.values.len() {\n-                    args.push(',');\n-                    args_plain.push(',');\n+            } else {\n+                if i > 0 {\n+                    args.push_str(\" <br>\");\n+                    args_plain.push(' ');\n+                }\n+                if !input.name.is_empty() {\n+                    args.push_str(&format!(\"{}: \", input.name));\n+                    args_plain.push_str(&format!(\"{}: \", input.name));\n                 }\n-            }\n-\n-            let mut args_plain = format!(\"({})\", args_plain);\n \n-            if decl.c_variadic {\n-                args.push_str(\",<br> ...\");\n-                args_plain.push_str(\", ...\");\n+                if f.alternate() {\n+                    args.push_str(&format!(\"{:#}\", input.type_.print(cache, tcx)));\n+                } else {\n+                    args.push_str(&input.type_.print(cache, tcx).to_string());\n+                }\n+                args_plain.push_str(&format!(\"{:#}\", input.type_.print(cache, tcx)));\n+            }\n+            if i + 1 < self.inputs.values.len() {\n+                args.push(',');\n+                args_plain.push(',');\n             }\n+        }\n \n-            let output = if let hir::IsAsync::Async = asyncness {\n-                Cow::Owned(decl.sugared_async_return_type())\n-            } else {\n-                Cow::Borrowed(&decl.output)\n-            };\n+        let mut args_plain = format!(\"({})\", args_plain);\n \n-            let arrow_plain = format!(\"{:#}\", &output.print(cache));\n-            let arrow = if f.alternate() {\n-                format!(\"{:#}\", &output.print(cache))\n-            } else {\n-                output.print(cache).to_string()\n-            };\n+        if self.c_variadic {\n+            args.push_str(\",<br> ...\");\n+            args_plain.push_str(\", ...\");\n+        }\n \n-            let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n-            let output = if declaration_len > 80 {\n-                let full_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent + 4));\n-                let close_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent));\n-                format!(\n-                    \"({args}{close}){arrow}\",\n-                    args = args.replace(\"<br>\", &full_pad),\n-                    close = close_pad,\n-                    arrow = arrow\n-                )\n+        let arrow_plain;\n+        let arrow = if let hir::IsAsync::Async = asyncness {\n+            let output = self.sugared_async_return_type();\n+            arrow_plain = format!(\"{:#}\", output.print(cache, tcx));\n+            if f.alternate() {\n+                arrow_plain.clone()\n             } else {\n-                format!(\"({args}){arrow}\", args = args.replace(\"<br>\", \"\"), arrow = arrow)\n-            };\n-\n+                format!(\"{}\", output.print(cache, tcx))\n+            }\n+        } else {\n+            arrow_plain = format!(\"{:#}\", self.output.print(cache, tcx));\n             if f.alternate() {\n-                write!(f, \"{}\", output.replace(\"<br>\", \"\\n\"))\n+                arrow_plain.clone()\n             } else {\n-                write!(f, \"{}\", output)\n+                format!(\"{}\", self.output.print(cache, tcx))\n             }\n-        })\n+        };\n+\n+        let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n+        let output = if declaration_len > 80 {\n+            let full_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent + 4));\n+            let close_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent));\n+            format!(\n+                \"({args}{close}){arrow}\",\n+                args = args.replace(\"<br>\", &full_pad),\n+                close = close_pad,\n+                arrow = arrow\n+            )\n+        } else {\n+            format!(\"({args}){arrow}\", args = args.replace(\"<br>\", \"\"), arrow = arrow)\n+        };\n+\n+        if f.alternate() {\n+            write!(f, \"{}\", output.replace(\"<br>\", \"\\n\"))\n+        } else {\n+            write!(f, \"{}\", output)\n+        }\n     }\n }\n \n impl clean::Visibility {\n-    crate fn print_with_space<'tcx>(\n+    crate fn print_with_space<'a, 'tcx: 'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         item_did: DefId,\n-        cache: &Cache,\n-    ) -> impl fmt::Display + 'tcx {\n+        cache: &'a Cache,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         use rustc_span::symbol::kw;\n \n         let to_print = match self {\n@@ -1202,30 +1277,38 @@ impl PrintWithSpace for hir::Mutability {\n }\n \n impl clean::Import {\n-    crate fn print<'b, 'a: 'b>(&'a self, cache: &'b Cache) -> impl fmt::Display + 'b {\n+    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'b Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n         display_fn(move |f| match self.kind {\n             clean::ImportKind::Simple(name) => {\n                 if name == self.source.path.last() {\n-                    write!(f, \"use {};\", self.source.print(cache))\n+                    write!(f, \"use {};\", self.source.print(cache, tcx))\n                 } else {\n-                    write!(f, \"use {} as {};\", self.source.print(cache), name)\n+                    write!(f, \"use {} as {};\", self.source.print(cache, tcx), name)\n                 }\n             }\n             clean::ImportKind::Glob => {\n                 if self.source.path.segments.is_empty() {\n                     write!(f, \"use *;\")\n                 } else {\n-                    write!(f, \"use {}::*;\", self.source.print(cache))\n+                    write!(f, \"use {}::*;\", self.source.print(cache, tcx))\n                 }\n             }\n         })\n     }\n }\n \n impl clean::ImportSource {\n-    crate fn print<'b, 'a: 'b>(&'a self, cache: &'b Cache) -> impl fmt::Display + 'b {\n+    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'b Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n         display_fn(move |f| match self.did {\n-            Some(did) => resolved_path(f, did, &self.path, true, false, cache),\n+            Some(did) => resolved_path(f, did, &self.path, true, false, cache, tcx),\n             _ => {\n                 for seg in &self.path.segments[..self.path.segments.len() - 1] {\n                     write!(f, \"{}::\", seg.name)?;\n@@ -1243,23 +1326,27 @@ impl clean::ImportSource {\n }\n \n impl clean::TypeBinding {\n-    crate fn print<'b, 'a: 'b>(&'a self, cache: &'b Cache) -> impl fmt::Display + 'b {\n+    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'b Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n         display_fn(move |f| {\n             f.write_str(&*self.name.as_str())?;\n             match self.kind {\n                 clean::TypeBindingKind::Equality { ref ty } => {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty.print(cache))?;\n+                        write!(f, \" = {:#}\", ty.print(cache, tcx))?;\n                     } else {\n-                        write!(f, \" = {}\", ty.print(cache))?;\n+                        write!(f, \" = {}\", ty.print(cache, tcx))?;\n                     }\n                 }\n                 clean::TypeBindingKind::Constraint { ref bounds } => {\n                     if !bounds.is_empty() {\n                         if f.alternate() {\n-                            write!(f, \": {:#}\", print_generic_bounds(bounds, cache))?;\n+                            write!(f, \": {:#}\", print_generic_bounds(bounds, cache, tcx))?;\n                         } else {\n-                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cache))?;\n+                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cache, tcx))?;\n                         }\n                     }\n                 }\n@@ -1284,11 +1371,15 @@ crate fn print_default_space<'a>(v: bool) -> &'a str {\n }\n \n impl clean::GenericArg {\n-    crate fn print<'b, 'a: 'b>(&'a self, cache: &'b Cache) -> impl fmt::Display + 'b {\n+    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+        &'a self,\n+        cache: &'b Cache,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n         display_fn(move |f| match self {\n             clean::GenericArg::Lifetime(lt) => fmt::Display::fmt(&lt.print(), f),\n-            clean::GenericArg::Type(ty) => fmt::Display::fmt(&ty.print(cache), f),\n-            clean::GenericArg::Const(ct) => fmt::Display::fmt(&ct.print(), f),\n+            clean::GenericArg::Type(ty) => fmt::Display::fmt(&ty.print(cache, tcx), f),\n+            clean::GenericArg::Const(ct) => fmt::Display::fmt(&ct.print(tcx), f),\n         })\n     }\n }"}, {"sha": "25e0be4109453604790751fae379c3d4bec53b0e", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 63, "deletions": 33, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=0cde85523f60b8de774bda91d171c9277464d489", "patch": "@@ -67,8 +67,8 @@ use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n-    href, print_abi_with_space, print_default_space, print_generic_bounds, Buffer, Function,\n-    PrintWithSpace, WhereClause,\n+    href, print_abi_with_space, print_default_space, print_generic_bounds, print_where_clause,\n+    Buffer, PrintWithSpace,\n };\n use crate::html::layout;\n use crate::html::markdown::{self, ErrorCodes, Markdown, MarkdownHtml, MarkdownSummaryLine};\n@@ -918,7 +918,7 @@ fn assoc_const(\n         it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n         naive_assoc_href(it, link, cx.cache()),\n         it.name.as_ref().unwrap(),\n-        ty.print(cx.cache())\n+        ty.print(cx.cache(), cx.tcx())\n     );\n }\n \n@@ -930,6 +930,7 @@ fn assoc_type(\n     link: AssocItemLink<'_>,\n     extra: &str,\n     cache: &Cache,\n+    tcx: TyCtxt<'_>,\n ) {\n     write!(\n         w,\n@@ -939,10 +940,10 @@ fn assoc_type(\n         it.name.as_ref().unwrap()\n     );\n     if !bounds.is_empty() {\n-        write!(w, \": {}\", print_generic_bounds(bounds, cache))\n+        write!(w, \": {}\", print_generic_bounds(bounds, cache, tcx))\n     }\n     if let Some(default) = default {\n-        write!(w, \" = {}\", default.print(cache))\n+        write!(w, \" = {}\", default.print(cache, tcx))\n     }\n }\n \n@@ -1017,7 +1018,7 @@ fn render_assoc_item(\n         let defaultness = print_default_space(meth.is_default());\n         let abi = print_abi_with_space(header.abi).to_string();\n         // NOTE: `{:#}` does not print HTML formatting, `{}` does. So `g.print` can't be reused between the length calculation and `write!`.\n-        let generics_len = format!(\"{:#}\", g.print(cx.cache())).len();\n+        let generics_len = format!(\"{:#}\", g.print(cx.cache(), tcx)).len();\n         let mut header_len = \"fn \".len()\n             + vis.len()\n             + constness.len()\n@@ -1049,11 +1050,10 @@ fn render_assoc_item(\n             abi,\n             href = href,\n             name = name,\n-            generics = g.print(cx.cache()),\n-            decl = Function { decl: d, header_len, indent, asyncness: header.asyncness }\n-                .print(cx.cache()),\n-            spotlight = spotlight_decl(&d, cx.cache()),\n-            where_clause = WhereClause { gens: g, indent, end_newline }.print(cx.cache())\n+            generics = g.print(cx.cache(), cx.tcx()),\n+            decl = d.full_print(cx.cache(), cx.tcx(), header_len, indent, header.asyncness),\n+            spotlight = spotlight_decl(&d, cx.cache(), cx.tcx()),\n+            where_clause = print_where_clause(g, cx.cache(), cx.tcx(), indent, end_newline),\n         )\n     }\n     match *item.kind {\n@@ -1081,6 +1081,7 @@ fn render_assoc_item(\n             link,\n             if parent == ItemType::Trait { \"    \" } else { \"\" },\n             cx.cache(),\n+            cx.tcx(),\n         ),\n         _ => panic!(\"render_assoc_item called on non-associated-item\"),\n     }\n@@ -1169,9 +1170,9 @@ fn render_assoc_items(\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n                 let id = cx.derive_id(small_url_encode(format!(\n                     \"deref-methods-{:#}\",\n-                    type_.print(cx.cache())\n+                    type_.print(cx.cache(), cx.tcx())\n                 )));\n-                debug!(\"Adding {} to deref id map\", type_.print(cx.cache()));\n+                debug!(\"Adding {} to deref id map\", type_.print(cx.cache(), cx.tcx()));\n                 cx.deref_id_map\n                     .borrow_mut()\n                     .insert(type_.def_id_full(cx.cache()).unwrap(), id.clone());\n@@ -1182,8 +1183,8 @@ fn render_assoc_items(\n                          <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n                      </h2>\",\n                     id = id,\n-                    trait_ = trait_.print(cx.cache()),\n-                    type_ = type_.print(cx.cache()),\n+                    trait_ = trait_.print(cx.cache(), cx.tcx()),\n+                    type_ = type_.print(cx.cache(), cx.tcx()),\n                 );\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n@@ -1335,7 +1336,7 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, cache: &Cache) -> bo\n     }\n }\n \n-fn spotlight_decl(decl: &clean::FnDecl, cache: &Cache) -> String {\n+fn spotlight_decl(decl: &clean::FnDecl, cache: &Cache, tcx: TyCtxt<'_>) -> String {\n     let mut out = Buffer::html();\n     let mut trait_ = String::new();\n \n@@ -1351,16 +1352,16 @@ fn spotlight_decl(decl: &clean::FnDecl, cache: &Cache) -> String {\n                             &mut out,\n                             \"<h3 class=\\\"notable\\\">Notable traits for {}</h3>\\\n                              <code class=\\\"content\\\">\",\n-                            impl_.for_.print(cache)\n+                            impl_.for_.print(cache, tcx)\n                         );\n-                        trait_.push_str(&impl_.for_.print(cache).to_string());\n+                        trait_.push_str(&impl_.for_.print(cache, tcx).to_string());\n                     }\n \n                     //use the \"where\" class here to make it small\n                     write!(\n                         &mut out,\n                         \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n-                        impl_.print(cache, false)\n+                        impl_.print(cache, false, tcx)\n                     );\n                     let t_did = impl_.trait_.def_id_full(cache).unwrap();\n                     for it in &impl_.items {\n@@ -1374,6 +1375,7 @@ fn spotlight_decl(decl: &clean::FnDecl, cache: &Cache) -> String {\n                                 AssocItemLink::GotoSource(t_did, &FxHashSet::default()),\n                                 \"\",\n                                 cache,\n+                                tcx,\n                             );\n                             out.push_str(\";</span>\");\n                         }\n@@ -1419,9 +1421,12 @@ fn render_impl(\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => {\n                 if is_on_foreign_type {\n-                    get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t, cx.cache())\n+                    get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t, cx.cache(), cx.tcx())\n                 } else {\n-                    format!(\"impl-{}\", small_url_encode(format!(\"{:#}\", t.print(cx.cache()))))\n+                    format!(\n+                        \"impl-{}\",\n+                        small_url_encode(format!(\"{:#}\", t.print(cx.cache(), cx.tcx())))\n+                    )\n                 }\n             }\n             None => \"impl\".to_string(),\n@@ -1433,7 +1438,7 @@ fn render_impl(\n         };\n         if let Some(use_absolute) = use_absolute {\n             write!(w, \"<h3 id=\\\"{}\\\" class=\\\"impl\\\"{}><code class=\\\"in-band\\\">\", id, aliases);\n-            write!(w, \"{}\", i.inner_impl().print(cx.cache(), use_absolute));\n+            write!(w, \"{}\", i.inner_impl().print(cx.cache(), use_absolute, cx.tcx()));\n             if show_def_docs {\n                 for it in &i.inner_impl().items {\n                     if let clean::TypedefItem(ref tydef, _) = *it.kind {\n@@ -1446,6 +1451,7 @@ fn render_impl(\n                             AssocItemLink::Anchor(None),\n                             \"\",\n                             cx.cache(),\n+                            cx.tcx(),\n                         );\n                         w.write_str(\";</span>\");\n                     }\n@@ -1458,7 +1464,7 @@ fn render_impl(\n                 \"<h3 id=\\\"{}\\\" class=\\\"impl\\\"{}><code class=\\\"in-band\\\">{}</code>\",\n                 id,\n                 aliases,\n-                i.inner_impl().print(cx.cache(), false)\n+                i.inner_impl().print(cx.cache(), false, cx.tcx())\n             );\n         }\n         write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n@@ -1558,6 +1564,7 @@ fn render_impl(\n                     link.anchor(&id),\n                     \"\",\n                     cx.cache(),\n+                    cx.tcx(),\n                 );\n                 w.write_str(\"</code></h4>\");\n             }\n@@ -1579,7 +1586,16 @@ fn render_impl(\n             clean::AssocTypeItem(ref bounds, ref default) => {\n                 let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                 write!(w, \"<h4 id=\\\"{}\\\" class=\\\"{}{}\\\"><code>\", id, item_type, extra_class);\n-                assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id), \"\", cx.cache());\n+                assoc_type(\n+                    w,\n+                    item,\n+                    bounds,\n+                    default.as_ref(),\n+                    link.anchor(&id),\n+                    \"\",\n+                    cx.cache(),\n+                    cx.tcx(),\n+                );\n                 w.write_str(\"</code></h4>\");\n             }\n             clean::StrippedItem(..) => return,\n@@ -1922,9 +1938,10 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n                     .iter()\n                     .filter_map(|it| {\n                         if let Some(ref i) = it.inner_impl().trait_ {\n-                            let i_display = format!(\"{:#}\", i.print(cx.cache()));\n+                            let i_display = format!(\"{:#}\", i.print(cx.cache(), cx.tcx()));\n                             let out = Escape(&i_display);\n-                            let encoded = small_url_encode(format!(\"{:#}\", i.print(cx.cache())));\n+                            let encoded =\n+                                small_url_encode(format!(\"{:#}\", i.print(cx.cache(), cx.tcx())));\n                             let generated = format!(\n                                 \"<a href=\\\"#impl-{}\\\">{}{}</a>\",\n                                 encoded,\n@@ -1988,6 +2005,7 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n \n fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &Vec<Impl>) {\n     let c = cx.cache();\n+    let tcx = cx.tcx();\n \n     debug!(\"found Deref: {:?}\", impl_);\n     if let Some((target, real_target)) =\n@@ -2036,8 +2054,11 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n                     out,\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#{}\\\">Methods from {}&lt;Target={}&gt;</a>\",\n                     id,\n-                    Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print(c))),\n-                    Escape(&format!(\"{:#}\", real_target.print(c))),\n+                    Escape(&format!(\n+                        \"{:#}\",\n+                        impl_.inner_impl().trait_.as_ref().unwrap().print(c, tcx)\n+                    )),\n+                    Escape(&format!(\"{:#}\", real_target.print(c, tcx))),\n                 );\n                 // We want links' order to be reproducible so we don't use unstable sort.\n                 ret.sort();\n@@ -2094,17 +2115,26 @@ fn get_id_for_impl_on_foreign_type(\n     for_: &clean::Type,\n     trait_: &clean::Type,\n     cache: &Cache,\n+    tcx: TyCtxt<'_>,\n ) -> String {\n-    small_url_encode(format!(\"impl-{:#}-for-{:#}\", trait_.print(cache), for_.print(cache)))\n+    small_url_encode(format!(\n+        \"impl-{:#}-for-{:#}\",\n+        trait_.print(cache, tcx),\n+        for_.print(cache, tcx)\n+    ))\n }\n \n-fn extract_for_impl_name(item: &clean::Item, cache: &Cache) -> Option<(String, String)> {\n+fn extract_for_impl_name(\n+    item: &clean::Item,\n+    cache: &Cache,\n+    tcx: TyCtxt<'_>,\n+) -> Option<(String, String)> {\n     match *item.kind {\n         clean::ItemKind::ImplItem(ref i) => {\n             if let Some(ref trait_) = i.trait_ {\n                 Some((\n-                    format!(\"{:#}\", i.for_.print(cache)),\n-                    get_id_for_impl_on_foreign_type(&i.for_, trait_, cache),\n+                    format!(\"{:#}\", i.for_.print(cache, tcx)),\n+                    get_id_for_impl_on_foreign_type(&i.for_, trait_, cache, tcx),\n                 ))\n             } else {\n                 None\n@@ -2192,7 +2222,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n                     .def_id_full(cx.cache())\n                     .map_or(false, |d| !cx.cache.paths.contains_key(&d))\n             })\n-            .filter_map(|i| extract_for_impl_name(&i.impl_item, cx.cache()))\n+            .filter_map(|i| extract_for_impl_name(&i.impl_item, cx.cache(), cx.tcx()))\n             .collect::<Vec<_>>();\n \n         if !res.is_empty() {"}, {"sha": "7662dcf60e3e7102c04b11e06090f71be5b9f189", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 62, "deletions": 66, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=0cde85523f60b8de774bda91d171c9277464d489", "patch": "@@ -19,7 +19,7 @@ use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n use crate::html::escape::Escape;\n-use crate::html::format::{print_abi_with_space, Buffer, Function, PrintWithSpace, WhereClause};\n+use crate::html::format::{print_abi_with_space, print_where_clause, Buffer, PrintWithSpace};\n use crate::html::highlight;\n use crate::html::markdown::MarkdownSummaryLine;\n \n@@ -266,7 +266,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     w,\n                     \"<tr><td><code>{}{}</code></td></tr>\",\n                     myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n-                    import.print(cx.cache())\n+                    import.print(cx.cache(), cx.tcx()),\n                 );\n             }\n \n@@ -372,7 +372,7 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         f.header.unsafety.print_with_space(),\n         print_abi_with_space(f.header.abi),\n         it.name.as_ref().unwrap(),\n-        f.generics.print(cx.cache())\n+        f.generics.print(cx.cache(), cx.tcx())\n     )\n     .len();\n     w.write_str(\"<pre class=\\\"rust fn\\\">\");\n@@ -387,18 +387,16 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         unsafety = f.header.unsafety.print_with_space(),\n         abi = print_abi_with_space(f.header.abi),\n         name = it.name.as_ref().unwrap(),\n-        generics = f.generics.print(cx.cache()),\n-        where_clause =\n-            WhereClause { gens: &f.generics, indent: 0, end_newline: true }.print(cx.cache()),\n-        decl = Function { decl: &f.decl, header_len, indent: 0, asyncness: f.header.asyncness }\n-            .print(cx.cache()),\n-        spotlight = spotlight_decl(&f.decl, cx.cache()),\n+        generics = f.generics.print(cx.cache(), cx.tcx()),\n+        where_clause = print_where_clause(&f.generics, cx.cache(), cx.tcx(), 0, true),\n+        decl = f.decl.full_print(cx.cache(), cx.tcx(), header_len, 0, f.header.asyncness),\n+        spotlight = spotlight_decl(&f.decl, cx.cache(), cx.tcx()),\n     );\n     document(w, cx, it, None)\n }\n \n fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait) {\n-    let bounds = bounds(&t.bounds, false, cx.cache());\n+    let bounds = bounds(&t.bounds, false, cx.cache(), cx.tcx());\n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n     let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n@@ -415,13 +413,12 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             t.unsafety.print_with_space(),\n             if t.is_auto { \"auto \" } else { \"\" },\n             it.name.as_ref().unwrap(),\n-            t.generics.print(cx.cache()),\n+            t.generics.print(cx.cache(), cx.tcx()),\n             bounds\n         );\n \n         if !t.generics.where_predicates.is_empty() {\n-            let where_ = WhereClause { gens: &t.generics, indent: 0, end_newline: true };\n-            write!(w, \"{}\", where_.print(cx.cache()));\n+            write!(w, \"{}\", print_where_clause(&t.generics, cx.cache(), cx.tcx(), 0, true));\n         } else {\n             w.write_str(\" \");\n         }\n@@ -594,8 +591,8 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             local.iter().partition(|i| i.inner_impl().synthetic);\n \n-        synthetic.sort_by(|a, b| compare_impl(a, b, cx.cache()));\n-        concrete.sort_by(|a, b| compare_impl(a, b, cx.cache()));\n+        synthetic.sort_by(|a, b| compare_impl(a, b, cx.cache(), cx.tcx()));\n+        concrete.sort_by(|a, b| compare_impl(a, b, cx.cache(), cx.tcx()));\n \n         if !foreign.is_empty() {\n             write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\");\n@@ -700,9 +697,9 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n         w,\n         \"trait {}{}{} = {};</pre>\",\n         it.name.as_ref().unwrap(),\n-        t.generics.print(cx.cache()),\n-        WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n-        bounds(&t.bounds, true, cx.cache())\n+        t.generics.print(cx.cache(), cx.tcx()),\n+        print_where_clause(&t.generics, cx.cache(), cx.tcx(), 0, true),\n+        bounds(&t.bounds, true, cx.cache(), cx.tcx())\n     );\n \n     document(w, cx, it, None);\n@@ -721,10 +718,9 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n         w,\n         \"type {}{}{where_clause} = impl {bounds};</pre>\",\n         it.name.as_ref().unwrap(),\n-        t.generics.print(cx.cache()),\n-        where_clause =\n-            WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n-        bounds = bounds(&t.bounds, false, cx.cache())\n+        t.generics.print(cx.cache(), cx.tcx()),\n+        where_clause = print_where_clause(&t.generics, cx.cache(), cx.tcx(), 0, true),\n+        bounds = bounds(&t.bounds, false, cx.cache(), cx.tcx()),\n     );\n \n     document(w, cx, it, None);\n@@ -743,10 +739,9 @@ fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::T\n         w,\n         \"type {}{}{where_clause} = {type_};</pre>\",\n         it.name.as_ref().unwrap(),\n-        t.generics.print(cx.cache()),\n-        where_clause =\n-            WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n-        type_ = t.type_.print(cx.cache())\n+        t.generics.print(cx.cache(), cx.tcx()),\n+        where_clause = print_where_clause(&t.generics, cx.cache(), cx.tcx(), 0, true),\n+        type_ = t.type_.print(cx.cache(), cx.tcx()),\n     );\n \n     document(w, cx, it, None);\n@@ -793,7 +788,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n                 id = id,\n                 name = name,\n                 shortty = ItemType::StructField,\n-                ty = ty.print(cx.cache())\n+                ty = ty.print(cx.cache(), cx.tcx()),\n             );\n             if let Some(stability_class) = field.stability_class(cx.tcx()) {\n                 write!(w, \"<span class=\\\"stab {stab}\\\"></span>\", stab = stability_class);\n@@ -813,8 +808,8 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             \"{}enum {}{}{}\",\n             it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n             it.name.as_ref().unwrap(),\n-            e.generics.print(cx.cache()),\n-            WhereClause { gens: &e.generics, indent: 0, end_newline: true }.print(cx.cache())\n+            e.generics.print(cx.cache(), cx.tcx()),\n+            print_where_clause(&e.generics, cx.cache(), cx.tcx(), 0, true),\n         );\n         if e.variants.is_empty() && !e.variants_stripped {\n             w.write_str(\" {}\");\n@@ -832,7 +827,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                                 if i > 0 {\n                                     w.write_str(\",&nbsp;\")\n                                 }\n-                                write!(w, \"{}\", ty.print(cx.cache()));\n+                                write!(w, \"{}\", ty.print(cx.cache(), cx.tcx()));\n                             }\n                             w.write_str(\")\");\n                         }\n@@ -879,7 +874,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                     if i > 0 {\n                         w.write_str(\",&nbsp;\");\n                     }\n-                    write!(w, \"{}\", ty.print(cx.cache()));\n+                    write!(w, \"{}\", ty.print(cx.cache(), cx.tcx()));\n                 }\n                 w.write_str(\")\");\n             }\n@@ -916,7 +911,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                              </span>\",\n                             id = id,\n                             f = field.name.as_ref().unwrap(),\n-                            t = ty.print(cx.cache())\n+                            t = ty.print(cx.cache(), cx.tcx())\n                         );\n                         document(w, cx, field, Some(variant));\n                     }\n@@ -987,19 +982,22 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n         \"{vis}const {name}: {typ}\",\n         vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n         name = it.name.as_ref().unwrap(),\n-        typ = c.type_.print(cx.cache()),\n+        typ = c.type_().print(cx.cache(), cx.tcx()),\n     );\n \n-    if c.value.is_some() || c.is_literal {\n-        write!(w, \" = {expr};\", expr = Escape(&c.expr));\n+    let value = c.value(cx.tcx());\n+    let is_literal = c.is_literal(cx.tcx());\n+    let expr = c.expr(cx.tcx());\n+    if value.is_some() || is_literal {\n+        write!(w, \" = {expr};\", expr = Escape(&expr));\n     } else {\n         w.write_str(\";\");\n     }\n \n-    if let Some(value) = &c.value {\n-        if !c.is_literal {\n+    if !is_literal {\n+        if let Some(value) = &value {\n             let value_lowercase = value.to_lowercase();\n-            let expr_lowercase = c.expr.to_lowercase();\n+            let expr_lowercase = expr.to_lowercase();\n \n             if value_lowercase != expr_lowercase\n                 && value_lowercase.trim_end_matches(\"i32\") != expr_lowercase\n@@ -1054,7 +1052,7 @@ fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n                     item_type = ItemType::StructField,\n                     id = id,\n                     name = field.name.as_ref().unwrap(),\n-                    ty = ty.print(cx.cache())\n+                    ty = ty.print(cx.cache(), cx.tcx())\n                 );\n                 document(w, cx, field, Some(it));\n             }\n@@ -1072,7 +1070,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n         vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n         mutability = s.mutability.print_with_space(),\n         name = it.name.as_ref().unwrap(),\n-        typ = s.type_.print(cx.cache())\n+        typ = s.type_.print(cx.cache(), cx.tcx())\n     );\n     document(w, cx, it, None)\n }\n@@ -1147,7 +1145,12 @@ pub(super) fn item_path(ty: ItemType, name: &str) -> String {\n     }\n }\n \n-fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool, cache: &Cache) -> String {\n+fn bounds(\n+    t_bounds: &[clean::GenericBound],\n+    trait_alias: bool,\n+    cache: &Cache,\n+    tcx: TyCtxt<'_>,\n+) -> String {\n     let mut bounds = String::new();\n     if !t_bounds.is_empty() {\n         if !trait_alias {\n@@ -1157,7 +1160,7 @@ fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool, cache: &Cache) ->\n             if i > 0 {\n                 bounds.push_str(\" + \");\n             }\n-            bounds.push_str(&p.print(cache).to_string());\n+            bounds.push_str(&p.print(cache, tcx).to_string());\n         }\n     }\n     bounds\n@@ -1187,9 +1190,14 @@ fn render_stability_since(\n     )\n }\n \n-fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl, cache: &Cache) -> Ordering {\n-    let lhs = format!(\"{}\", lhs.inner_impl().print(cache, false));\n-    let rhs = format!(\"{}\", rhs.inner_impl().print(cache, false));\n+fn compare_impl<'a, 'b>(\n+    lhs: &'a &&Impl,\n+    rhs: &'b &&Impl,\n+    cache: &Cache,\n+    tcx: TyCtxt<'_>,\n+) -> Ordering {\n+    let lhs = format!(\"{}\", lhs.inner_impl().print(cache, false, tcx));\n+    let rhs = format!(\"{}\", rhs.inner_impl().print(cache, false, tcx));\n \n     // lhs and rhs are formatted as HTML, which may be unnecessary\n     compare_names(&lhs, &rhs)\n@@ -1247,8 +1255,8 @@ fn render_union(\n         it.name.as_ref().unwrap()\n     );\n     if let Some(g) = g {\n-        write!(w, \"{}\", g.print(cx.cache()));\n-        write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true }.print(cx.cache()));\n+        write!(w, \"{}\", g.print(cx.cache(), cx.tcx()));\n+        write!(w, \"{}\", print_where_clause(&g, cx.cache(), cx.tcx(), 0, true));\n     }\n \n     write!(w, \" {{\\n{}\", tab);\n@@ -1259,7 +1267,7 @@ fn render_union(\n                 \"    {}{}: {},\\n{}\",\n                 field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n                 field.name.as_ref().unwrap(),\n-                ty.print(cx.cache()),\n+                ty.print(cx.cache(), cx.tcx()),\n                 tab\n             );\n         }\n@@ -1289,16 +1297,12 @@ fn render_struct(\n         it.name.as_ref().unwrap()\n     );\n     if let Some(g) = g {\n-        write!(w, \"{}\", g.print(cx.cache()))\n+        write!(w, \"{}\", g.print(cx.cache(), cx.tcx()))\n     }\n     match ty {\n         CtorKind::Fictive => {\n             if let Some(g) = g {\n-                write!(\n-                    w,\n-                    \"{}\",\n-                    WhereClause { gens: g, indent: 0, end_newline: true }.print(cx.cache())\n-                )\n+                write!(w, \"{}\", print_where_clause(g, cx.cache(), cx.tcx(), 0, true),)\n             }\n             let mut has_visible_fields = false;\n             w.write_str(\" {\");\n@@ -1310,7 +1314,7 @@ fn render_struct(\n                         tab,\n                         field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n                         field.name.as_ref().unwrap(),\n-                        ty.print(cx.cache())\n+                        ty.print(cx.cache(), cx.tcx()),\n                     );\n                     has_visible_fields = true;\n                 }\n@@ -1341,30 +1345,22 @@ fn render_struct(\n                             w,\n                             \"{}{}\",\n                             field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n-                            ty.print(cx.cache())\n+                            ty.print(cx.cache(), cx.tcx()),\n                         )\n                     }\n                     _ => unreachable!(),\n                 }\n             }\n             w.write_str(\")\");\n             if let Some(g) = g {\n-                write!(\n-                    w,\n-                    \"{}\",\n-                    WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n-                )\n+                write!(w, \"{}\", print_where_clause(g, cx.cache(), cx.tcx(), 0, false),)\n             }\n             w.write_str(\";\");\n         }\n         CtorKind::Const => {\n             // Needed for PhantomData.\n             if let Some(g) = g {\n-                write!(\n-                    w,\n-                    \"{}\",\n-                    WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n-                )\n+                write!(w, \"{}\", print_where_clause(g, cx.cache(), cx.tcx(), 0, false),)\n             }\n             w.write_str(\";\");\n         }"}, {"sha": "dc967552116220f0df0ccc09ad97a2a353be675d", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=0cde85523f60b8de774bda91d171c9277464d489", "patch": "@@ -430,7 +430,7 @@ pub(super) fn write_shared(\n                     None\n                 } else {\n                     Some(Implementor {\n-                        text: imp.inner_impl().print(cx.cache(), false).to_string(),\n+                        text: imp.inner_impl().print(cx.cache(), false, cx.tcx()).to_string(),\n                         synthetic: imp.inner_impl().synthetic,\n                         types: collect_paths_for_type(imp.inner_impl().for_.clone(), cx.cache()),\n                     })"}, {"sha": "110046bebdfbddb4a7709237966fe764bb293962", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 175, "deletions": 143, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=0cde85523f60b8de774bda91d171c9277464d489", "patch": "@@ -27,7 +27,7 @@ impl JsonRenderer<'_> {\n         let clean::Item { span, name, attrs, kind, visibility, def_id } = item;\n         let inner = match *kind {\n             clean::StrippedItem(_) => return None,\n-            x => from_clean_item_kind(x, self.tcx, &name),\n+            kind => from_clean_item_kind(kind, self.tcx, &name),\n         };\n         Some(Item {\n             id: from_def_id(def_id),\n@@ -87,59 +87,78 @@ impl JsonRenderer<'_> {\n     }\n }\n \n+crate trait FromWithTcx<T> {\n+    fn from_tcx(f: T, tcx: TyCtxt<'_>) -> Self;\n+}\n+\n+crate trait IntoWithTcx<T> {\n+    fn into_tcx(self, tcx: TyCtxt<'_>) -> T;\n+}\n+\n+impl<T, U> IntoWithTcx<U> for T\n+where\n+    U: FromWithTcx<T>,\n+{\n+    fn into_tcx(self, tcx: TyCtxt<'_>) -> U {\n+        U::from_tcx(self, tcx)\n+    }\n+}\n+\n crate fn from_deprecation(deprecation: rustc_attr::Deprecation) -> Deprecation {\n     #[rustfmt::skip]\n     let rustc_attr::Deprecation { since, note, is_since_rustc_version: _, suggestion: _ } = deprecation;\n     Deprecation { since: since.map(|s| s.to_string()), note: note.map(|s| s.to_string()) }\n }\n \n-impl From<clean::GenericArgs> for GenericArgs {\n-    fn from(args: clean::GenericArgs) -> Self {\n+impl FromWithTcx<clean::GenericArgs> for GenericArgs {\n+    fn from_tcx(args: clean::GenericArgs, tcx: TyCtxt<'_>) -> Self {\n         use clean::GenericArgs::*;\n         match args {\n             AngleBracketed { args, bindings } => GenericArgs::AngleBracketed {\n-                args: args.into_iter().map(Into::into).collect(),\n-                bindings: bindings.into_iter().map(Into::into).collect(),\n+                args: args.into_iter().map(|a| a.into_tcx(tcx)).collect(),\n+                bindings: bindings.into_iter().map(|a| a.into_tcx(tcx)).collect(),\n             },\n             Parenthesized { inputs, output } => GenericArgs::Parenthesized {\n-                inputs: inputs.into_iter().map(Into::into).collect(),\n-                output: output.map(Into::into),\n+                inputs: inputs.into_iter().map(|a| a.into_tcx(tcx)).collect(),\n+                output: output.map(|a| a.into_tcx(tcx)),\n             },\n         }\n     }\n }\n \n-impl From<clean::GenericArg> for GenericArg {\n-    fn from(arg: clean::GenericArg) -> Self {\n+impl FromWithTcx<clean::GenericArg> for GenericArg {\n+    fn from_tcx(arg: clean::GenericArg, tcx: TyCtxt<'_>) -> Self {\n         use clean::GenericArg::*;\n         match arg {\n             Lifetime(l) => GenericArg::Lifetime(l.0.to_string()),\n-            Type(t) => GenericArg::Type(t.into()),\n-            Const(c) => GenericArg::Const(c.into()),\n+            Type(t) => GenericArg::Type(t.into_tcx(tcx)),\n+            Const(c) => GenericArg::Const(c.into_tcx(tcx)),\n         }\n     }\n }\n \n-impl From<clean::Constant> for Constant {\n-    fn from(constant: clean::Constant) -> Self {\n-        let clean::Constant { type_, expr, value, is_literal } = constant;\n-        Constant { type_: type_.into(), expr, value, is_literal }\n+impl FromWithTcx<clean::Constant> for Constant {\n+    fn from_tcx(constant: clean::Constant, tcx: TyCtxt<'_>) -> Self {\n+        let expr = constant.expr(tcx);\n+        let value = constant.value(tcx);\n+        let is_literal = constant.is_literal(tcx);\n+        Constant { type_: constant.to_type().into_tcx(tcx), expr, value, is_literal }\n     }\n }\n \n-impl From<clean::TypeBinding> for TypeBinding {\n-    fn from(binding: clean::TypeBinding) -> Self {\n-        TypeBinding { name: binding.name.to_string(), binding: binding.kind.into() }\n+impl FromWithTcx<clean::TypeBinding> for TypeBinding {\n+    fn from_tcx(binding: clean::TypeBinding, tcx: TyCtxt<'_>) -> Self {\n+        TypeBinding { name: binding.name.to_string(), binding: binding.kind.into_tcx(tcx) }\n     }\n }\n \n-impl From<clean::TypeBindingKind> for TypeBindingKind {\n-    fn from(kind: clean::TypeBindingKind) -> Self {\n+impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n+    fn from_tcx(kind: clean::TypeBindingKind, tcx: TyCtxt<'_>) -> Self {\n         use clean::TypeBindingKind::*;\n         match kind {\n-            Equality { ty } => TypeBindingKind::Equality(ty.into()),\n+            Equality { ty } => TypeBindingKind::Equality(ty.into_tcx(tcx)),\n             Constraint { bounds } => {\n-                TypeBindingKind::Constraint(bounds.into_iter().map(Into::into).collect())\n+                TypeBindingKind::Constraint(bounds.into_iter().map(|a| a.into_tcx(tcx)).collect())\n             }\n         }\n     }\n@@ -152,32 +171,32 @@ crate fn from_def_id(did: DefId) -> Id {\n fn from_clean_item_kind(item: clean::ItemKind, tcx: TyCtxt<'_>, name: &Option<Symbol>) -> ItemEnum {\n     use clean::ItemKind::*;\n     match item {\n-        ModuleItem(m) => ItemEnum::Module(m.into()),\n-        ImportItem(i) => ItemEnum::Import(i.into()),\n-        StructItem(s) => ItemEnum::Struct(s.into()),\n-        UnionItem(u) => ItemEnum::Union(u.into()),\n-        StructFieldItem(f) => ItemEnum::StructField(f.into()),\n-        EnumItem(e) => ItemEnum::Enum(e.into()),\n-        VariantItem(v) => ItemEnum::Variant(v.into()),\n-        FunctionItem(f) => ItemEnum::Function(f.into()),\n-        ForeignFunctionItem(f) => ItemEnum::Function(f.into()),\n-        TraitItem(t) => ItemEnum::Trait(t.into()),\n-        TraitAliasItem(t) => ItemEnum::TraitAlias(t.into()),\n-        MethodItem(m, _) => ItemEnum::Method(from_function_method(m, true)),\n-        TyMethodItem(m) => ItemEnum::Method(from_function_method(m, false)),\n-        ImplItem(i) => ItemEnum::Impl(i.into()),\n-        StaticItem(s) => ItemEnum::Static(from_clean_static(s, tcx)),\n-        ForeignStaticItem(s) => ItemEnum::Static(from_clean_static(s, tcx)),\n+        ModuleItem(m) => ItemEnum::Module(m.into_tcx(tcx)),\n+        ImportItem(i) => ItemEnum::Import(i.into_tcx(tcx)),\n+        StructItem(s) => ItemEnum::Struct(s.into_tcx(tcx)),\n+        UnionItem(u) => ItemEnum::Union(u.into_tcx(tcx)),\n+        StructFieldItem(f) => ItemEnum::StructField(f.into_tcx(tcx)),\n+        EnumItem(e) => ItemEnum::Enum(e.into_tcx(tcx)),\n+        VariantItem(v) => ItemEnum::Variant(v.into_tcx(tcx)),\n+        FunctionItem(f) => ItemEnum::Function(f.into_tcx(tcx)),\n+        ForeignFunctionItem(f) => ItemEnum::Function(f.into_tcx(tcx)),\n+        TraitItem(t) => ItemEnum::Trait(t.into_tcx(tcx)),\n+        TraitAliasItem(t) => ItemEnum::TraitAlias(t.into_tcx(tcx)),\n+        MethodItem(m, _) => ItemEnum::Method(from_function_method(m, true, tcx)),\n+        TyMethodItem(m) => ItemEnum::Method(from_function_method(m, false, tcx)),\n+        ImplItem(i) => ItemEnum::Impl(i.into_tcx(tcx)),\n+        StaticItem(s) => ItemEnum::Static(s.into_tcx(tcx)),\n+        ForeignStaticItem(s) => ItemEnum::Static(s.into_tcx(tcx)),\n         ForeignTypeItem => ItemEnum::ForeignType,\n-        TypedefItem(t, _) => ItemEnum::Typedef(t.into()),\n-        OpaqueTyItem(t) => ItemEnum::OpaqueTy(t.into()),\n-        ConstantItem(c) => ItemEnum::Constant(c.into()),\n+        TypedefItem(t, _) => ItemEnum::Typedef(t.into_tcx(tcx)),\n+        OpaqueTyItem(t) => ItemEnum::OpaqueTy(t.into_tcx(tcx)),\n+        ConstantItem(c) => ItemEnum::Constant(c.into_tcx(tcx)),\n         MacroItem(m) => ItemEnum::Macro(m.source),\n-        ProcMacroItem(m) => ItemEnum::ProcMacro(m.into()),\n-        AssocConstItem(t, s) => ItemEnum::AssocConst { type_: t.into(), default: s },\n+        ProcMacroItem(m) => ItemEnum::ProcMacro(m.into_tcx(tcx)),\n+        AssocConstItem(t, s) => ItemEnum::AssocConst { type_: t.into_tcx(tcx), default: s },\n         AssocTypeItem(g, t) => ItemEnum::AssocType {\n-            bounds: g.into_iter().map(Into::into).collect(),\n-            default: t.map(Into::into),\n+            bounds: g.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+            default: t.map(|x| x.into_tcx(tcx)),\n         },\n         StrippedItem(inner) => from_clean_item_kind(*inner, tcx, name),\n         PrimitiveItem(_) | KeywordItem(_) => {\n@@ -190,30 +209,30 @@ fn from_clean_item_kind(item: clean::ItemKind, tcx: TyCtxt<'_>, name: &Option<Sy\n     }\n }\n \n-impl From<clean::Module> for Module {\n-    fn from(module: clean::Module) -> Self {\n+impl FromWithTcx<clean::Module> for Module {\n+    fn from_tcx(module: clean::Module, _tcx: TyCtxt<'_>) -> Self {\n         Module { is_crate: module.is_crate, items: ids(module.items) }\n     }\n }\n \n-impl From<clean::Struct> for Struct {\n-    fn from(struct_: clean::Struct) -> Self {\n+impl FromWithTcx<clean::Struct> for Struct {\n+    fn from_tcx(struct_: clean::Struct, tcx: TyCtxt<'_>) -> Self {\n         let clean::Struct { struct_type, generics, fields, fields_stripped } = struct_;\n         Struct {\n             struct_type: from_ctor_kind(struct_type),\n-            generics: generics.into(),\n+            generics: generics.into_tcx(tcx),\n             fields_stripped,\n             fields: ids(fields),\n             impls: Vec::new(), // Added in JsonRenderer::item\n         }\n     }\n }\n \n-impl From<clean::Union> for Union {\n-    fn from(struct_: clean::Union) -> Self {\n+impl FromWithTcx<clean::Union> for Union {\n+    fn from_tcx(struct_: clean::Union, tcx: TyCtxt<'_>) -> Self {\n         let clean::Union { generics, fields, fields_stripped } = struct_;\n         Union {\n-            generics: generics.into(),\n+            generics: generics.into_tcx(tcx),\n             fields_stripped,\n             fields: ids(fields),\n             impls: Vec::new(), // Added in JsonRenderer::item\n@@ -247,74 +266,81 @@ crate fn from_fn_header(header: &rustc_hir::FnHeader) -> HashSet<Qualifiers> {\n     v\n }\n \n-impl From<clean::Function> for Function {\n-    fn from(function: clean::Function) -> Self {\n+impl FromWithTcx<clean::Function> for Function {\n+    fn from_tcx(function: clean::Function, tcx: TyCtxt<'_>) -> Self {\n         let clean::Function { decl, generics, header } = function;\n         Function {\n-            decl: decl.into(),\n-            generics: generics.into(),\n+            decl: decl.into_tcx(tcx),\n+            generics: generics.into_tcx(tcx),\n             header: from_fn_header(&header),\n             abi: header.abi.to_string(),\n         }\n     }\n }\n \n-impl From<clean::Generics> for Generics {\n-    fn from(generics: clean::Generics) -> Self {\n+impl FromWithTcx<clean::Generics> for Generics {\n+    fn from_tcx(generics: clean::Generics, tcx: TyCtxt<'_>) -> Self {\n         Generics {\n-            params: generics.params.into_iter().map(Into::into).collect(),\n-            where_predicates: generics.where_predicates.into_iter().map(Into::into).collect(),\n+            params: generics.params.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+            where_predicates: generics\n+                .where_predicates\n+                .into_iter()\n+                .map(|x| x.into_tcx(tcx))\n+                .collect(),\n         }\n     }\n }\n \n-impl From<clean::GenericParamDef> for GenericParamDef {\n-    fn from(generic_param: clean::GenericParamDef) -> Self {\n-        GenericParamDef { name: generic_param.name.to_string(), kind: generic_param.kind.into() }\n+impl FromWithTcx<clean::GenericParamDef> for GenericParamDef {\n+    fn from_tcx(generic_param: clean::GenericParamDef, tcx: TyCtxt<'_>) -> Self {\n+        GenericParamDef {\n+            name: generic_param.name.to_string(),\n+            kind: generic_param.kind.into_tcx(tcx),\n+        }\n     }\n }\n \n-impl From<clean::GenericParamDefKind> for GenericParamDefKind {\n-    fn from(kind: clean::GenericParamDefKind) -> Self {\n+impl FromWithTcx<clean::GenericParamDefKind> for GenericParamDefKind {\n+    fn from_tcx(kind: clean::GenericParamDefKind, tcx: TyCtxt<'_>) -> Self {\n         use clean::GenericParamDefKind::*;\n         match kind {\n             Lifetime => GenericParamDefKind::Lifetime,\n             Type { did: _, bounds, default, synthetic: _ } => GenericParamDefKind::Type {\n-                bounds: bounds.into_iter().map(Into::into).collect(),\n-                default: default.map(Into::into),\n+                bounds: bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+                default: default.map(|x| x.into_tcx(tcx)),\n             },\n-            Const { did: _, ty } => GenericParamDefKind::Const(ty.into()),\n+            Const { did: _, ty } => GenericParamDefKind::Const(ty.into_tcx(tcx)),\n         }\n     }\n }\n \n-impl From<clean::WherePredicate> for WherePredicate {\n-    fn from(predicate: clean::WherePredicate) -> Self {\n+impl FromWithTcx<clean::WherePredicate> for WherePredicate {\n+    fn from_tcx(predicate: clean::WherePredicate, tcx: TyCtxt<'_>) -> Self {\n         use clean::WherePredicate::*;\n         match predicate {\n             BoundPredicate { ty, bounds } => WherePredicate::BoundPredicate {\n-                ty: ty.into(),\n-                bounds: bounds.into_iter().map(Into::into).collect(),\n+                ty: ty.into_tcx(tcx),\n+                bounds: bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n             },\n             RegionPredicate { lifetime, bounds } => WherePredicate::RegionPredicate {\n                 lifetime: lifetime.0.to_string(),\n-                bounds: bounds.into_iter().map(Into::into).collect(),\n+                bounds: bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n             },\n             EqPredicate { lhs, rhs } => {\n-                WherePredicate::EqPredicate { lhs: lhs.into(), rhs: rhs.into() }\n+                WherePredicate::EqPredicate { lhs: lhs.into_tcx(tcx), rhs: rhs.into_tcx(tcx) }\n             }\n         }\n     }\n }\n \n-impl From<clean::GenericBound> for GenericBound {\n-    fn from(bound: clean::GenericBound) -> Self {\n+impl FromWithTcx<clean::GenericBound> for GenericBound {\n+    fn from_tcx(bound: clean::GenericBound, tcx: TyCtxt<'_>) -> Self {\n         use clean::GenericBound::*;\n         match bound {\n             TraitBound(clean::PolyTrait { trait_, generic_params }, modifier) => {\n                 GenericBound::TraitBound {\n-                    trait_: trait_.into(),\n-                    generic_params: generic_params.into_iter().map(Into::into).collect(),\n+                    trait_: trait_.into_tcx(tcx),\n+                    generic_params: generic_params.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n                     modifier: from_trait_bound_modifier(modifier),\n                 }\n             }\n@@ -332,47 +358,47 @@ crate fn from_trait_bound_modifier(modifier: rustc_hir::TraitBoundModifier) -> T\n     }\n }\n \n-impl From<clean::Type> for Type {\n-    fn from(ty: clean::Type) -> Self {\n+impl FromWithTcx<clean::Type> for Type {\n+    fn from_tcx(ty: clean::Type, tcx: TyCtxt<'_>) -> Self {\n         use clean::Type::*;\n         match ty {\n             ResolvedPath { path, param_names, did, is_generic: _ } => Type::ResolvedPath {\n                 name: path.whole_name(),\n                 id: from_def_id(did),\n-                args: path.segments.last().map(|args| Box::new(args.clone().args.into())),\n+                args: path.segments.last().map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n                 param_names: param_names\n-                    .map(|v| v.into_iter().map(Into::into).collect())\n+                    .map(|v| v.into_iter().map(|x| x.into_tcx(tcx)).collect())\n                     .unwrap_or_default(),\n             },\n             Generic(s) => Type::Generic(s.to_string()),\n             Primitive(p) => Type::Primitive(p.as_str().to_string()),\n-            BareFunction(f) => Type::FunctionPointer(Box::new((*f).into())),\n-            Tuple(t) => Type::Tuple(t.into_iter().map(Into::into).collect()),\n-            Slice(t) => Type::Slice(Box::new((*t).into())),\n-            Array(t, s) => Type::Array { type_: Box::new((*t).into()), len: s },\n-            ImplTrait(g) => Type::ImplTrait(g.into_iter().map(Into::into).collect()),\n+            BareFunction(f) => Type::FunctionPointer(Box::new((*f).into_tcx(tcx))),\n+            Tuple(t) => Type::Tuple(t.into_iter().map(|x| x.into_tcx(tcx)).collect()),\n+            Slice(t) => Type::Slice(Box::new((*t).into_tcx(tcx))),\n+            Array(t, s) => Type::Array { type_: Box::new((*t).into_tcx(tcx)), len: s },\n+            ImplTrait(g) => Type::ImplTrait(g.into_iter().map(|x| x.into_tcx(tcx)).collect()),\n             Never => Type::Never,\n             Infer => Type::Infer,\n             RawPointer(mutability, type_) => Type::RawPointer {\n                 mutable: mutability == ast::Mutability::Mut,\n-                type_: Box::new((*type_).into()),\n+                type_: Box::new((*type_).into_tcx(tcx)),\n             },\n             BorrowedRef { lifetime, mutability, type_ } => Type::BorrowedRef {\n                 lifetime: lifetime.map(|l| l.0.to_string()),\n                 mutable: mutability == ast::Mutability::Mut,\n-                type_: Box::new((*type_).into()),\n+                type_: Box::new((*type_).into_tcx(tcx)),\n             },\n             QPath { name, self_type, trait_ } => Type::QualifiedPath {\n                 name: name.to_string(),\n-                self_type: Box::new((*self_type).into()),\n-                trait_: Box::new((*trait_).into()),\n+                self_type: Box::new((*self_type).into_tcx(tcx)),\n+                trait_: Box::new((*trait_).into_tcx(tcx)),\n             },\n         }\n     }\n }\n \n-impl From<clean::BareFunctionDecl> for FunctionPointer {\n-    fn from(bare_decl: clean::BareFunctionDecl) -> Self {\n+impl FromWithTcx<clean::BareFunctionDecl> for FunctionPointer {\n+    fn from_tcx(bare_decl: clean::BareFunctionDecl, tcx: TyCtxt<'_>) -> Self {\n         let clean::BareFunctionDecl { unsafety, generic_params, decl, abi } = bare_decl;\n         FunctionPointer {\n             header: if let rustc_hir::Unsafety::Unsafe = unsafety {\n@@ -382,47 +408,47 @@ impl From<clean::BareFunctionDecl> for FunctionPointer {\n             } else {\n                 HashSet::new()\n             },\n-            generic_params: generic_params.into_iter().map(Into::into).collect(),\n-            decl: decl.into(),\n+            generic_params: generic_params.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+            decl: decl.into_tcx(tcx),\n             abi: abi.to_string(),\n         }\n     }\n }\n \n-impl From<clean::FnDecl> for FnDecl {\n-    fn from(decl: clean::FnDecl) -> Self {\n+impl FromWithTcx<clean::FnDecl> for FnDecl {\n+    fn from_tcx(decl: clean::FnDecl, tcx: TyCtxt<'_>) -> Self {\n         let clean::FnDecl { inputs, output, c_variadic, attrs: _ } = decl;\n         FnDecl {\n             inputs: inputs\n                 .values\n                 .into_iter()\n-                .map(|arg| (arg.name.to_string(), arg.type_.into()))\n+                .map(|arg| (arg.name.to_string(), arg.type_.into_tcx(tcx)))\n                 .collect(),\n             output: match output {\n-                clean::FnRetTy::Return(t) => Some(t.into()),\n+                clean::FnRetTy::Return(t) => Some(t.into_tcx(tcx)),\n                 clean::FnRetTy::DefaultReturn => None,\n             },\n             c_variadic,\n         }\n     }\n }\n \n-impl From<clean::Trait> for Trait {\n-    fn from(trait_: clean::Trait) -> Self {\n+impl FromWithTcx<clean::Trait> for Trait {\n+    fn from_tcx(trait_: clean::Trait, tcx: TyCtxt<'_>) -> Self {\n         let clean::Trait { unsafety, items, generics, bounds, is_auto } = trait_;\n         Trait {\n             is_auto,\n             is_unsafe: unsafety == rustc_hir::Unsafety::Unsafe,\n             items: ids(items),\n-            generics: generics.into(),\n-            bounds: bounds.into_iter().map(Into::into).collect(),\n+            generics: generics.into_tcx(tcx),\n+            bounds: bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n             implementors: Vec::new(), // Added in JsonRenderer::item\n         }\n     }\n }\n \n-impl From<clean::Impl> for Impl {\n-    fn from(impl_: clean::Impl) -> Self {\n+impl FromWithTcx<clean::Impl> for Impl {\n+    fn from_tcx(impl_: clean::Impl, tcx: TyCtxt<'_>) -> Self {\n         let clean::Impl {\n             unsafety,\n             generics,\n@@ -436,46 +462,50 @@ impl From<clean::Impl> for Impl {\n         } = impl_;\n         Impl {\n             is_unsafe: unsafety == rustc_hir::Unsafety::Unsafe,\n-            generics: generics.into(),\n+            generics: generics.into_tcx(tcx),\n             provided_trait_methods: provided_trait_methods\n                 .into_iter()\n                 .map(|x| x.to_string())\n                 .collect(),\n-            trait_: trait_.map(Into::into),\n-            for_: for_.into(),\n+            trait_: trait_.map(|x| x.into_tcx(tcx)),\n+            for_: for_.into_tcx(tcx),\n             items: ids(items),\n             negative: negative_polarity,\n             synthetic,\n-            blanket_impl: blanket_impl.map(Into::into),\n+            blanket_impl: blanket_impl.map(|x| x.into_tcx(tcx)),\n         }\n     }\n }\n \n-crate fn from_function_method(function: clean::Function, has_body: bool) -> Method {\n+crate fn from_function_method(\n+    function: clean::Function,\n+    has_body: bool,\n+    tcx: TyCtxt<'_>,\n+) -> Method {\n     let clean::Function { header, decl, generics } = function;\n     Method {\n-        decl: decl.into(),\n-        generics: generics.into(),\n+        decl: decl.into_tcx(tcx),\n+        generics: generics.into_tcx(tcx),\n         header: from_fn_header(&header),\n         abi: header.abi.to_string(),\n         has_body,\n     }\n }\n \n-impl From<clean::Enum> for Enum {\n-    fn from(enum_: clean::Enum) -> Self {\n+impl FromWithTcx<clean::Enum> for Enum {\n+    fn from_tcx(enum_: clean::Enum, tcx: TyCtxt<'_>) -> Self {\n         let clean::Enum { variants, generics, variants_stripped } = enum_;\n         Enum {\n-            generics: generics.into(),\n+            generics: generics.into_tcx(tcx),\n             variants_stripped,\n             variants: ids(variants),\n             impls: Vec::new(), // Added in JsonRenderer::item\n         }\n     }\n }\n \n-impl From<clean::VariantStruct> for Struct {\n-    fn from(struct_: clean::VariantStruct) -> Self {\n+impl FromWithTcx<clean::VariantStruct> for Struct {\n+    fn from_tcx(struct_: clean::VariantStruct, _tcx: TyCtxt<'_>) -> Self {\n         let clean::VariantStruct { struct_type, fields, fields_stripped } = struct_;\n         Struct {\n             struct_type: from_ctor_kind(struct_type),\n@@ -487,19 +517,19 @@ impl From<clean::VariantStruct> for Struct {\n     }\n }\n \n-impl From<clean::Variant> for Variant {\n-    fn from(variant: clean::Variant) -> Self {\n+impl FromWithTcx<clean::Variant> for Variant {\n+    fn from_tcx(variant: clean::Variant, tcx: TyCtxt<'_>) -> Self {\n         use clean::Variant::*;\n         match variant {\n             CLike => Variant::Plain,\n-            Tuple(t) => Variant::Tuple(t.into_iter().map(Into::into).collect()),\n+            Tuple(t) => Variant::Tuple(t.into_iter().map(|x| x.into_tcx(tcx)).collect()),\n             Struct(s) => Variant::Struct(ids(s.fields)),\n         }\n     }\n }\n \n-impl From<clean::Import> for Import {\n-    fn from(import: clean::Import) -> Self {\n+impl FromWithTcx<clean::Import> for Import {\n+    fn from_tcx(import: clean::Import, _tcx: TyCtxt<'_>) -> Self {\n         use clean::ImportKind::*;\n         match import.kind {\n             Simple(s) => Import {\n@@ -518,8 +548,8 @@ impl From<clean::Import> for Import {\n     }\n }\n \n-impl From<clean::ProcMacro> for ProcMacro {\n-    fn from(mac: clean::ProcMacro) -> Self {\n+impl FromWithTcx<clean::ProcMacro> for ProcMacro {\n+    fn from_tcx(mac: clean::ProcMacro, _tcx: TyCtxt<'_>) -> Self {\n         ProcMacro {\n             kind: from_macro_kind(mac.kind),\n             helpers: mac.helpers.iter().map(|x| x.to_string()).collect(),\n@@ -536,41 +566,43 @@ crate fn from_macro_kind(kind: rustc_span::hygiene::MacroKind) -> MacroKind {\n     }\n }\n \n-impl From<clean::Typedef> for Typedef {\n-    fn from(typedef: clean::Typedef) -> Self {\n+impl FromWithTcx<clean::Typedef> for Typedef {\n+    fn from_tcx(typedef: clean::Typedef, tcx: TyCtxt<'_>) -> Self {\n         let clean::Typedef { type_, generics, item_type: _ } = typedef;\n-        Typedef { type_: type_.into(), generics: generics.into() }\n+        Typedef { type_: type_.into_tcx(tcx), generics: generics.into_tcx(tcx) }\n     }\n }\n \n-impl From<clean::OpaqueTy> for OpaqueTy {\n-    fn from(opaque: clean::OpaqueTy) -> Self {\n+impl FromWithTcx<clean::OpaqueTy> for OpaqueTy {\n+    fn from_tcx(opaque: clean::OpaqueTy, tcx: TyCtxt<'_>) -> Self {\n         OpaqueTy {\n-            bounds: opaque.bounds.into_iter().map(Into::into).collect(),\n-            generics: opaque.generics.into(),\n+            bounds: opaque.bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+            generics: opaque.generics.into_tcx(tcx),\n         }\n     }\n }\n \n-fn from_clean_static(stat: clean::Static, tcx: TyCtxt<'_>) -> Static {\n-    Static {\n-        type_: stat.type_.into(),\n-        mutable: stat.mutability == ast::Mutability::Mut,\n-        expr: stat.expr.map(|e| print_const_expr(tcx, e)).unwrap_or_default(),\n+impl FromWithTcx<clean::Static> for Static {\n+    fn from_tcx(stat: clean::Static, tcx: TyCtxt<'_>) -> Self {\n+        Static {\n+            type_: stat.type_.into_tcx(tcx),\n+            mutable: stat.mutability == ast::Mutability::Mut,\n+            expr: stat.expr.map(|e| print_const_expr(tcx, e)).unwrap_or_default(),\n+        }\n     }\n }\n \n-impl From<clean::TraitAlias> for TraitAlias {\n-    fn from(alias: clean::TraitAlias) -> Self {\n+impl FromWithTcx<clean::TraitAlias> for TraitAlias {\n+    fn from_tcx(alias: clean::TraitAlias, tcx: TyCtxt<'_>) -> Self {\n         TraitAlias {\n-            generics: alias.generics.into(),\n-            params: alias.bounds.into_iter().map(Into::into).collect(),\n+            generics: alias.generics.into_tcx(tcx),\n+            params: alias.bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n         }\n     }\n }\n \n-impl From<ItemType> for ItemKind {\n-    fn from(kind: ItemType) -> Self {\n+impl FromWithTcx<ItemType> for ItemKind {\n+    fn from_tcx(kind: ItemType, _tcx: TyCtxt<'_>) -> Self {\n         use ItemType::*;\n         match kind {\n             Module => ItemKind::Module,"}, {"sha": "6d18dbe67e405bcf943985c41e2e1fa414acae19", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=0cde85523f60b8de774bda91d171c9277464d489", "patch": "@@ -24,7 +24,7 @@ use crate::error::Error;\n use crate::formats::cache::Cache;\n use crate::formats::FormatRenderer;\n use crate::html::render::cache::ExternalLocation;\n-use crate::json::conversions::from_def_id;\n+use crate::json::conversions::{from_def_id, IntoWithTcx};\n \n #[derive(Clone)]\n crate struct JsonRenderer<'tcx> {\n@@ -108,7 +108,7 @@ impl JsonRenderer<'tcx> {\n                                 .last()\n                                 .map(Clone::clone),\n                             visibility: types::Visibility::Public,\n-                            inner: types::ItemEnum::Trait(trait_item.clone().into()),\n+                            inner: types::ItemEnum::Trait(trait_item.clone().into_tcx(self.tcx)),\n                             span: None,\n                             docs: Default::default(),\n                             links: Default::default(),\n@@ -225,7 +225,11 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 .map(|(k, (path, kind))| {\n                     (\n                         from_def_id(k),\n-                        types::ItemSummary { crate_id: k.krate.as_u32(), path, kind: kind.into() },\n+                        types::ItemSummary {\n+                            crate_id: k.krate.as_u32(),\n+                            path,\n+                            kind: kind.into_tcx(self.tcx),\n+                        },\n                     )\n                 })\n                 .collect(),"}, {"sha": "ad269413ac6c551d75b1d1d0ad770ead94843f4f", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cde85523f60b8de774bda91d171c9277464d489/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=0cde85523f60b8de774bda91d171c9277464d489", "patch": "@@ -216,8 +216,8 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n                 if let Some(ref tr) = impl_.trait_ {\n                     debug!(\n                         \"impl {:#} for {:#} in {}\",\n-                        tr.print(&self.ctx.cache),\n-                        impl_.for_.print(&self.ctx.cache),\n+                        tr.print(&self.ctx.cache, self.ctx.tcx),\n+                        impl_.for_.print(&self.ctx.cache, self.ctx.tcx),\n                         filename,\n                     );\n \n@@ -228,7 +228,11 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n                     // inherent impls *can* be documented, and those docs show up, but in most\n                     // cases it doesn't make sense, as all methods on a type are in one single\n                     // impl block\n-                    debug!(\"impl {:#} in {}\", impl_.for_.print(&self.ctx.cache), filename);\n+                    debug!(\n+                        \"impl {:#} in {}\",\n+                        impl_.for_.print(&self.ctx.cache, self.ctx.tcx),\n+                        filename\n+                    );\n                 }\n             }\n             _ => {"}]}