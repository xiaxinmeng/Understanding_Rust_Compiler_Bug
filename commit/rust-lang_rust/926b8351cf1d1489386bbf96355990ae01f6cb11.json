{"sha": "926b8351cf1d1489386bbf96355990ae01f6cb11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNmI4MzUxY2YxZDE0ODkzODZiYmY5NjM1NTk5MGFlMDFmNmNiMTE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-13T04:11:50Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-17T21:41:40Z"}, "message": "Tweak intrinsic error handling.\n\nBetter error messages, US spelling, more real checks.", "tree": {"sha": "e2d128808f4e99cadbb177b77136e85b1a034838", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2d128808f4e99cadbb177b77136e85b1a034838"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/926b8351cf1d1489386bbf96355990ae01f6cb11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/926b8351cf1d1489386bbf96355990ae01f6cb11", "html_url": "https://github.com/rust-lang/rust/commit/926b8351cf1d1489386bbf96355990ae01f6cb11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/926b8351cf1d1489386bbf96355990ae01f6cb11/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e500673cc540828f9ec609f83d07f4e1c271de0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e500673cc540828f9ec609f83d07f4e1c271de0", "html_url": "https://github.com/rust-lang/rust/commit/3e500673cc540828f9ec609f83d07f4e1c271de0"}], "stats": {"total": 69, "additions": 47, "deletions": 22}, "files": [{"sha": "90a85e873645803cdd34125290d9b10db077d666", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/926b8351cf1d1489386bbf96355990ae01f6cb11/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926b8351cf1d1489386bbf96355990ae01f6cb11/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=926b8351cf1d1489386bbf96355990ae01f6cb11", "patch": "@@ -1359,21 +1359,24 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n \n     if let Some(cmp_op) = comparison {\n         assert_eq!(arg_tys.len(), 2);\n-        // we need nominal equality here, not LLVM (structural)\n-        // equality\n-        require!(arg_tys[0] == arg_tys[1],\n-                 \"SIMD comparison intrinsic monomorphised with different input types\");\n         require!(arg_tys[0].is_simd(tcx),\n-                 \"SIMD comparison intrinsic monomorphised for non-SIMD argument type\");\n+                 \"SIMD comparison intrinsic monomorphized for non-SIMD argument type `{}`\",\n+                 arg_tys[0]);\n         require!(ret_ty.is_simd(tcx),\n-                 \"SIMD comparison intrinsic monomorphised for non-SIMD return type\");\n+                 \"SIMD comparison intrinsic monomorphized for non-SIMD return type `{}`\",\n+                 ret_ty);\n \n         let in_len = arg_tys[0].simd_size(tcx);\n         let out_len = ret_ty.simd_size(tcx);\n         require!(in_len == out_len,\n-                 \"SIMD comparison intrinsic monomorphised for non-SIMD argument type\");\n+                 \"SIMD cast intrinsic monomorphized with input type `{}` and \\\n+                  return type `{}` with different lengths: {} vs. {}\",\n+                 arg_tys[0],\n+                 ret_ty,\n+                 in_len,\n+                 out_len);\n         require!(llret_ty.element_type().kind() == llvm::Integer,\n-                 \"SIMD comparison intrinsic monomorphised with non-integer return\");\n+                 \"SIMD comparison intrinsic monomorphized with non-integer return\");\n \n         return compare_simd_types(bcx,\n                                   llargs[0],\n@@ -1391,18 +1394,20 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n                                           \"bad `simd_shuffle` instruction only caught in trans?\")\n         };\n \n-        require!(arg_tys[0] == arg_tys[1],\n-                 \"SIMD shuffle intrinsic monomorphised with different input types\");\n+        require!(arg_tys[0].is_simd(tcx),\n+                 \"SIMD shuffle intrinsic monomorphized with non-SIMD input type `{}`\",\n+                 arg_tys[0]);\n         require!(ret_ty.is_simd(tcx),\n-                 \"SIMD shuffle intrinsic monomorphised for non-SIMD return type\");\n+                 \"SIMD shuffle intrinsic monomorphized for non-SIMD return type `{}`\",\n+                 ret_ty);\n \n         let in_len = arg_tys[0].simd_size(tcx);\n         let out_len = ret_ty.simd_size(tcx);\n         require!(out_len == n,\n-                 \"SIMD shuffle intrinsic monomorphised with return type of length {} (expected {})\",\n+                 \"SIMD shuffle intrinsic monomorphized with return type of length {} (expected {})\",\n                  out_len, n);\n         require!(arg_tys[0].simd_type(tcx) == ret_ty.simd_type(tcx),\n-                 \"SIMD shuffle intrinsic monomorphised with different \\\n+                 \"SIMD shuffle intrinsic monomorphized with different \\\n                   input and return element types\");\n \n         let total_len = in_len as u64 * 2;\n@@ -1448,27 +1453,37 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n \n     if name == \"simd_insert\" {\n         require!(arg_tys[0].is_simd(tcx),\n-                 \"SIMD insert intrinsic monomorphised for non-SIMD input type\");\n+                 \"SIMD insert intrinsic monomorphized for non-SIMD input type\");\n \n         let elem_ty = arg_tys[0].simd_type(tcx);\n         require!(arg_tys[2] == elem_ty,\n-                 \"SIMD insert intrinsic monomorphised with inserted type not SIMD element type\");\n+                 \"SIMD insert intrinsic monomorphized with inserted type not SIMD element type\");\n         return InsertElement(bcx, llargs[0], llargs[2], llargs[1])\n     }\n     if name == \"simd_extract\" {\n         require!(arg_tys[0].is_simd(tcx),\n-                 \"SIMD insert intrinsic monomorphised for non-SIMD input type\");\n+                 \"SIMD insert intrinsic monomorphized for non-SIMD input type\");\n \n         let elem_ty = arg_tys[0].simd_type(tcx);\n         require!(ret_ty == elem_ty,\n-                 \"SIMD insert intrinsic monomorphised with returned type not SIMD element type\");\n+                 \"SIMD insert intrinsic monomorphized with returned type not SIMD element type\");\n         return ExtractElement(bcx, llargs[0], llargs[1])\n     }\n \n     if name == \"simd_cast\" {\n+        require!(arg_tys[0].is_simd(tcx),\n+                 \"SIMD cast intrinsic monomorphized with non-SIMD input type `{}`\",\n+                 arg_tys[0]);\n+        require!(ret_ty.is_simd(tcx),\n+                 \"SIMD cast intrinsic monomorphized with non-SIMD return type `{}`\",\n+                 ret_ty);\n         require!(arg_tys[0].simd_size(tcx) == ret_ty.simd_size(tcx),\n-                 \"SIMD cast intrinsic monomorphised with input and \\\n-                  return types of different lengths\");\n+                 \"SIMD cast intrinsic monomorphized with input type `{}` and \\\n+                  return type `{}` with different lengths: {} vs. {}\",\n+                 arg_tys[0],\n+                 ret_ty,\n+                 arg_tys[0].simd_size(tcx),\n+                 ret_ty.simd_size(tcx));\n         // casting cares about nominal type, not just structural type\n         let in_ = arg_tys[0].simd_type(tcx);\n         let out = ret_ty.simd_type(tcx);\n@@ -1590,12 +1605,19 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n             }\n             _ => {}\n         }\n-        require!(false, \"SIMD cast intrinsic monomorphised with incompatible cast\");\n+        require!(false,\n+                 \"SIMD cast intrinsic monomorphized with incompatible cast \\\n+                  from `{}` (element `{}`)to `{}` (element `{}`)\",\n+                 arg_tys[0], in_,\n+                 ret_ty, out);\n     }\n     macro_rules! arith {\n         ($($name: ident: $($($p: ident),* => $call: expr),*;)*) => {\n             $(\n                 if name == stringify!($name) {\n+                    require!(arg_tys[0].is_simd(tcx),\n+                             \"`{}` intrinsic monomorphized with non-SIMD type `{}`\",\n+                             name, arg_tys[0]);\n                     let in_ = arg_tys[0].simd_type(tcx);\n                     match in_.sty {\n                         $(\n@@ -1606,8 +1628,11 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n                         _ => {},\n                     }\n                     require!(false,\n-                             \"{} intrinsic monomorphised with invalid type\",\n-                             name)\n+                             \"`{}` intrinsic monomorphized with SIMD vector `{}` \\\n+                              with unsupported element type `{}`\",\n+                             name,\n+                             arg_tys[0],\n+                             in_)\n                 })*\n         }\n     }"}]}