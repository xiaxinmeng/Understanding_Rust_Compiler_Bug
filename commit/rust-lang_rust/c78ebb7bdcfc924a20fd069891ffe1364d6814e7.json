{"sha": "c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3OGViYjdiZGNmYzkyNGEyMGZkMDY5ODkxZmZlMTM2NGQ2ODE0ZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-17T15:26:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-17T15:26:27Z"}, "message": "Auto merge of #87123 - RalfJung:miri-provenance-overhaul, r=oli-obk\n\nCTFE/Miri engine Pointer type overhaul\n\nThis fixes the long-standing problem that we are using `Scalar` as a type to represent pointers that might be integer values (since they point to a ZST). The main problem is that with int-to-ptr casts, there are multiple ways to represent the same pointer as a `Scalar` and it is unclear if \"normalization\" (i.e., the cast) already happened or not. This leads to ugly methods like `force_mplace_ptr` and `force_op_ptr`.\nAnother problem this solves is that in Miri, it would make a lot more sense to have the `Pointer::offset` field represent the full absolute address (instead of being relative to the `AllocId`). This means we can do ptr-to-int casts without access to any machine state, and it means that the overflow checks on pointer arithmetic are (finally!) accurate.\n\nTo solve this, the `Pointer` type is made entirely parametric over the provenance, so that we can use `Pointer<AllocId>` inside `Scalar` but use `Pointer<Option<AllocId>>` when accessing memory (where `None` represents the case that we could not figure out an `AllocId`; in that case the `offset` is an absolute address). Moreover, the `Provenance` trait determines if a pointer with a given provenance can be cast to an integer by simply dropping the provenance.\n\nI hope this can be read commit-by-commit, but the first commit does the bulk of the work. It introduces some FIXMEs that are resolved later.\nFixes https://github.com/rust-lang/miri/issues/841\nMiri PR: https://github.com/rust-lang/miri/pull/1851\nr? `@oli-obk`", "tree": {"sha": "42c1c852e5ca783556e9477361ed6b3fef733aad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42c1c852e5ca783556e9477361ed6b3fef733aad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "html_url": "https://github.com/rust-lang/rust/commit/c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f502bd3abd12111bbfae0974db018c165a977c0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f502bd3abd12111bbfae0974db018c165a977c0e", "html_url": "https://github.com/rust-lang/rust/commit/f502bd3abd12111bbfae0974db018c165a977c0e"}, {"sha": "efbee50600e63293608811d7ee200f12641f1958", "url": "https://api.github.com/repos/rust-lang/rust/commits/efbee50600e63293608811d7ee200f12641f1958", "html_url": "https://github.com/rust-lang/rust/commit/efbee50600e63293608811d7ee200f12641f1958"}], "stats": {"total": 2712, "additions": 1311, "deletions": 1401}, "files": [{"sha": "c87309e22224f8955a17c639b646e7e782fecea4", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -193,20 +193,21 @@ pub(crate) fn codegen_const_value<'tcx>(\n                     place.to_cvalue(fx)\n                 }\n             }\n-            Scalar::Ptr(ptr) => {\n-                let alloc_kind = fx.tcx.get_global_alloc(ptr.alloc_id);\n+            Scalar::Ptr(ptr, _size) => {\n+                let (alloc_id, offset) = ptr.into_parts(); // we know the `offset` is relative\n+                let alloc_kind = fx.tcx.get_global_alloc(alloc_id);\n                 let base_addr = match alloc_kind {\n                     Some(GlobalAlloc::Memory(alloc)) => {\n                         let data_id = data_id_for_alloc_id(\n                             &mut fx.constants_cx,\n                             fx.module,\n-                            ptr.alloc_id,\n+                            alloc_id,\n                             alloc.mutability,\n                         );\n                         let local_data_id =\n                             fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                         if fx.clif_comments.enabled() {\n-                            fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n+                            fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n                         }\n                         fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                     }\n@@ -226,10 +227,10 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         }\n                         fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                     }\n-                    None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n+                    None => bug!(\"missing allocation {:?}\", alloc_id),\n                 };\n-                let val = if ptr.offset.bytes() != 0 {\n-                    fx.bcx.ins().iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap())\n+                let val = if offset.bytes() != 0 {\n+                    fx.bcx.ins().iadd_imm(base_addr, i64::try_from(offset.bytes()).unwrap())\n                 } else {\n                     base_addr\n                 };\n@@ -406,7 +407,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n         let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()).to_vec();\n         data_ctx.define(bytes.into_boxed_slice());\n \n-        for &(offset, (_tag, reloc)) in alloc.relocations().iter() {\n+        for &(offset, alloc_id) in alloc.relocations().iter() {\n             let addend = {\n                 let endianness = tcx.data_layout.endian;\n                 let offset = offset.bytes() as usize;\n@@ -417,7 +418,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 read_target_uint(endianness, bytes).unwrap()\n             };\n \n-            let reloc_target_alloc = tcx.get_global_alloc(reloc).unwrap();\n+            let reloc_target_alloc = tcx.get_global_alloc(alloc_id).unwrap();\n             let data_id = match reloc_target_alloc {\n                 GlobalAlloc::Function(instance) => {\n                     assert_eq!(addend, 0);\n@@ -427,7 +428,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                     continue;\n                 }\n                 GlobalAlloc::Memory(target_alloc) => {\n-                    data_id_for_alloc_id(cx, module, reloc, target_alloc.mutability)\n+                    data_id_for_alloc_id(cx, module, alloc_id, target_alloc.mutability)\n                 }\n                 GlobalAlloc::Static(def_id) => {\n                     if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)"}, {"sha": "35e72621c565d6473423b398758fb201f925c8e5", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -243,16 +243,17 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     self.const_bitcast(llval, llty)\n                 }\n             }\n-            Scalar::Ptr(ptr) => {\n-                let (base_addr, base_addr_space) = match self.tcx.global_alloc(ptr.alloc_id) {\n+            Scalar::Ptr(ptr, _size) => {\n+                let (alloc_id, offset) = ptr.into_parts();\n+                let (base_addr, base_addr_space) = match self.tcx.global_alloc(alloc_id) {\n                     GlobalAlloc::Memory(alloc) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n                         let value = match alloc.mutability {\n                             Mutability::Mut => self.static_addr_of_mut(init, alloc.align, None),\n                             _ => self.static_addr_of(init, alloc.align, None),\n                         };\n                         if !self.sess().fewer_names() {\n-                            llvm::set_value_name(value, format!(\"{:?}\", ptr.alloc_id).as_bytes());\n+                            llvm::set_value_name(value, format!(\"{:?}\", alloc_id).as_bytes());\n                         }\n                         (value, AddressSpace::DATA)\n                     }\n@@ -269,7 +270,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 let llval = unsafe {\n                     llvm::LLVMConstInBoundsGEP(\n                         self.const_bitcast(base_addr, self.type_i8p_ext(base_addr_space)),\n-                        &self.const_usize(ptr.offset.bytes()),\n+                        &self.const_usize(offset.bytes()),\n                         1,\n                     )\n                 };"}, {"sha": "3ca295f4a7e89396658d0e002151e7ae6c0f8309", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -11,7 +11,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::interpret::{\n-    read_target_uint, Allocation, ErrorHandled, GlobalAlloc, Pointer,\n+    read_target_uint, Allocation, ErrorHandled, GlobalAlloc, Pointer, Scalar as InterpScalar,\n };\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n@@ -25,7 +25,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n     let pointer_size = dl.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n-    for &(offset, ((), alloc_id)) in alloc.relocations().iter() {\n+    for &(offset, alloc_id) in alloc.relocations().iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n@@ -55,7 +55,10 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         };\n \n         llvals.push(cx.scalar_to_backend(\n-            Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n+            InterpScalar::from_pointer(\n+                Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n+                &cx.tcx,\n+            ),\n             &Scalar { value: Primitive::Pointer, valid_range: 0..=!0 },\n             cx.type_i8p_ext(address_space),\n         ));"}, {"sha": "3e8386bc88feda1facf37b2d13ed2765d2147f53", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -90,10 +90,10 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                     Abi::ScalarPair(ref a, _) => a,\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout),\n                 };\n-                let a = Scalar::from(Pointer::new(\n-                    bx.tcx().create_memory_alloc(data),\n-                    Size::from_bytes(start),\n-                ));\n+                let a = Scalar::from_pointer(\n+                    Pointer::new(bx.tcx().create_memory_alloc(data), Size::from_bytes(start)),\n+                    &bx.tcx(),\n+                );\n                 let a_llval = bx.scalar_to_backend(\n                     a,\n                     a_scalar,"}, {"sha": "f2acc601d4f62dc5b2b6d79e1fa0cdb9b4ac9d43", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -49,6 +49,7 @@\n #![feature(iter_zip)]\n #![feature(thread_local_const_init)]\n #![feature(try_reserve)]\n+#![feature(nonzero_ops)]\n #![recursion_limit = \"512\"]\n \n #[macro_use]"}, {"sha": "bbf792edcded9ee27cade96ed363776996ec9cb3", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 56, "deletions": 48, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -3,7 +3,7 @@\n use std::borrow::Cow;\n use std::convert::TryFrom;\n use std::iter;\n-use std::ops::{Deref, DerefMut, Range};\n+use std::ops::{Deref, Range};\n use std::ptr;\n \n use rustc_ast::Mutability;\n@@ -25,7 +25,7 @@ use crate::ty;\n /// module provides higher-level access.\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n-pub struct Allocation<Tag = (), Extra = ()> {\n+pub struct Allocation<Tag = AllocId, Extra = ()> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer.\n     bytes: Vec<u8>,\n@@ -154,26 +154,32 @@ impl<Tag> Allocation<Tag> {\n     }\n }\n \n-impl Allocation<()> {\n-    /// Add Tag and Extra fields\n-    pub fn with_tags_and_extra<T, E>(\n+impl Allocation {\n+    /// Convert Tag and add Extra fields\n+    pub fn convert_tag_add_extra<Tag, Extra>(\n         self,\n-        mut tagger: impl FnMut(AllocId) -> T,\n-        extra: E,\n-    ) -> Allocation<T, E> {\n+        cx: &impl HasDataLayout,\n+        extra: Extra,\n+        mut tagger: impl FnMut(Pointer<AllocId>) -> Pointer<Tag>,\n+    ) -> Allocation<Tag, Extra> {\n+        // Compute new pointer tags, which also adjusts the bytes.\n+        let mut bytes = self.bytes;\n+        let mut new_relocations = Vec::with_capacity(self.relocations.0.len());\n+        let ptr_size = cx.data_layout().pointer_size.bytes_usize();\n+        let endian = cx.data_layout().endian;\n+        for &(offset, alloc_id) in self.relocations.iter() {\n+            let idx = offset.bytes_usize();\n+            let ptr_bytes = &mut bytes[idx..idx + ptr_size];\n+            let bits = read_target_uint(endian, ptr_bytes).unwrap();\n+            let (ptr_tag, ptr_offset) =\n+                tagger(Pointer::new(alloc_id, Size::from_bytes(bits))).into_parts();\n+            write_target_uint(endian, ptr_bytes, ptr_offset.bytes().into()).unwrap();\n+            new_relocations.push((offset, ptr_tag));\n+        }\n+        // Create allocation.\n         Allocation {\n-            bytes: self.bytes,\n-            relocations: Relocations::from_presorted(\n-                self.relocations\n-                    .iter()\n-                    // The allocations in the relocations (pointers stored *inside* this allocation)\n-                    // all get the base pointer tag.\n-                    .map(|&(offset, ((), alloc))| {\n-                        let tag = tagger(alloc);\n-                        (offset, (tag, alloc))\n-                    })\n-                    .collect(),\n-            ),\n+            bytes,\n+            relocations: Relocations::from_presorted(new_relocations),\n             init_mask: self.init_mask,\n             align: self.align,\n             mutability: self.mutability,\n@@ -279,6 +285,9 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// A raw pointer variant of `get_bytes_mut` that avoids invalidating existing aliases into this memory.\n     pub fn get_bytes_mut_ptr(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> *mut [u8] {\n         self.mark_init(range, true);\n+        // This also clears relocations that just overlap with the written range. So writing to some\n+        // byte can de-initialize its neighbors! See\n+        // <https://github.com/rust-lang/rust/issues/87184> for details.\n         self.clear_relocations(cx, range);\n \n         assert!(range.end().bytes_usize() <= self.bytes.len()); // need to do our own bounds-check\n@@ -321,7 +330,11 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         range: AllocRange,\n     ) -> AllocResult<ScalarMaybeUninit<Tag>> {\n-        // `get_bytes_unchecked` tests relocation edges.\n+        // `get_bytes_with_uninit_and_ptr` tests relocation edges.\n+        // We deliberately error when loading data that partially has provenance, or partially\n+        // initialized data (that's the check below), into a scalar. The LLVM semantics of this are\n+        // unclear so we are conservative. See <https://github.com/rust-lang/rust/issues/69488> for\n+        // further discussion.\n         let bytes = self.get_bytes_with_uninit_and_ptr(cx, range)?;\n         // Uninit check happens *after* we established that the alignment is correct.\n         // We must not return `Ok()` for unaligned pointers!\n@@ -339,9 +352,9 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n             self.check_relocations(cx, range)?;\n         } else {\n             // Maybe a pointer.\n-            if let Some(&(tag, alloc_id)) = self.relocations.get(&range.start) {\n-                let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits), tag);\n-                return Ok(ScalarMaybeUninit::Scalar(ptr.into()));\n+            if let Some(&prov) = self.relocations.get(&range.start) {\n+                let ptr = Pointer::new(prov, Size::from_bytes(bits));\n+                return Ok(ScalarMaybeUninit::from_pointer(ptr, cx));\n             }\n         }\n         // We don't. Just return the bits.\n@@ -371,18 +384,23 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n             }\n         };\n \n-        let bytes = match val.to_bits_or_ptr(range.size, cx) {\n-            Err(val) => u128::from(val.offset.bytes()),\n-            Ok(data) => data,\n+        // `to_bits_or_ptr_internal` is the right method because we just want to store this data\n+        // as-is into memory.\n+        let (bytes, provenance) = match val.to_bits_or_ptr_internal(range.size) {\n+            Err(val) => {\n+                let (provenance, offset) = val.into_parts();\n+                (u128::from(offset.bytes()), Some(provenance))\n+            }\n+            Ok(data) => (data, None),\n         };\n \n         let endian = cx.data_layout().endian;\n         let dst = self.get_bytes_mut(cx, range);\n         write_target_uint(endian, dst, bytes).unwrap();\n \n         // See if we have to also write a relocation.\n-        if let Scalar::Ptr(val) = val {\n-            self.relocations.insert(range.start, (val.tag, val.alloc_id));\n+        if let Some(provenance) = provenance {\n+            self.relocations.0.insert(range.start, provenance);\n         }\n \n         Ok(())\n@@ -392,11 +410,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n /// Relocations.\n impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Returns all relocations overlapping with the given pointer-offset pair.\n-    pub fn get_relocations(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        range: AllocRange,\n-    ) -> &[(Size, (Tag, AllocId))] {\n+    pub fn get_relocations(&self, cx: &impl HasDataLayout, range: AllocRange) -> &[(Size, Tag)] {\n         // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n         // the beginning of this range.\n         let start = range.start.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n@@ -446,7 +460,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         }\n \n         // Forget all the relocations.\n-        self.relocations.remove_range(first..last);\n+        self.relocations.0.remove_range(first..last);\n     }\n \n     /// Errors if there are relocations overlapping with the edges of the\n@@ -582,39 +596,33 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n-/// Relocations.\n+/// \"Relocations\" stores the provenance information of pointers stored in memory.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n-pub struct Relocations<Tag = (), Id = AllocId>(SortedMap<Size, (Tag, Id)>);\n+pub struct Relocations<Tag = AllocId>(SortedMap<Size, Tag>);\n \n-impl<Tag, Id> Relocations<Tag, Id> {\n+impl<Tag> Relocations<Tag> {\n     pub fn new() -> Self {\n         Relocations(SortedMap::new())\n     }\n \n     // The caller must guarantee that the given relocations are already sorted\n     // by address and contain no duplicates.\n-    pub fn from_presorted(r: Vec<(Size, (Tag, Id))>) -> Self {\n+    pub fn from_presorted(r: Vec<(Size, Tag)>) -> Self {\n         Relocations(SortedMap::from_presorted_elements(r))\n     }\n }\n \n impl<Tag> Deref for Relocations<Tag> {\n-    type Target = SortedMap<Size, (Tag, AllocId)>;\n+    type Target = SortedMap<Size, Tag>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.0\n     }\n }\n \n-impl<Tag> DerefMut for Relocations<Tag> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.0\n-    }\n-}\n-\n /// A partial, owned list of relocations to transfer into another allocation.\n pub struct AllocationRelocations<Tag> {\n-    relative_relocations: Vec<(Size, (Tag, AllocId))>,\n+    relative_relocations: Vec<(Size, Tag)>,\n }\n \n impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n@@ -652,7 +660,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// The affected range, as defined in the parameters to `prepare_relocation_copy` is expected\n     /// to be clear of relocations.\n     pub fn mark_relocation_range(&mut self, relocations: AllocationRelocations<Tag>) {\n-        self.relocations.insert_presorted(relocations.relative_relocations);\n+        self.relocations.0.insert_presorted(relocations.relative_relocations);\n     }\n }\n "}, {"sha": "432d078dc9b05d8488b6a58f16ff82483ebedc85", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -170,6 +170,8 @@ impl fmt::Display for InvalidProgramInfo<'_> {\n /// Details of why a pointer had to be in-bounds.\n #[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n pub enum CheckInAllocMsg {\n+    /// We are dereferencing a pointer (i.e., creating a place).\n+    DerefTest,\n     /// We are access memory.\n     MemoryAccessTest,\n     /// We are doing pointer arithmetic.\n@@ -179,13 +181,14 @@ pub enum CheckInAllocMsg {\n }\n \n impl fmt::Display for CheckInAllocMsg {\n-    /// When this is printed as an error the context looks like this\n-    /// \"{msg}pointer must be in-bounds at offset...\"\n+    /// When this is printed as an error the context looks like this:\n+    /// \"{msg}0x01 is not a valid pointer\".\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n             \"{}\",\n             match *self {\n+                CheckInAllocMsg::DerefTest => \"dereferencing pointer failed: \",\n                 CheckInAllocMsg::MemoryAccessTest => \"memory access failed: \",\n                 CheckInAllocMsg::PointerArithmeticTest => \"pointer arithmetic failed: \",\n                 CheckInAllocMsg::InboundsTest => \"\",\n@@ -238,7 +241,9 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     PointerUseAfterFree(AllocId),\n     /// Used a pointer outside the bounds it is valid for.\n     PointerOutOfBounds {\n-        ptr: Pointer,\n+        alloc_id: AllocId,\n+        offset: Size,\n+        size: Size,\n         msg: CheckInAllocMsg,\n         allocation_size: Size,\n     },\n@@ -307,20 +312,30 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             InvalidVtableAlignment(msg) => write!(f, \"invalid vtable: alignment {}\", msg),\n             UnterminatedCString(p) => write!(\n                 f,\n-                \"reading a null-terminated string starting at {} with no null found before end of allocation\",\n+                \"reading a null-terminated string starting at {:?} with no null found before end of allocation\",\n                 p,\n             ),\n             PointerUseAfterFree(a) => {\n                 write!(f, \"pointer to {} was dereferenced after this allocation got freed\", a)\n             }\n-            PointerOutOfBounds { ptr, msg, allocation_size } => write!(\n+            PointerOutOfBounds { alloc_id, offset, size: Size::ZERO, msg, allocation_size } => {\n+                write!(\n+                    f,\n+                    \"{}{} has size {}, so pointer at offset {} is out-of-bounds\",\n+                    msg,\n+                    alloc_id,\n+                    allocation_size.bytes(),\n+                    offset.bytes(),\n+                )\n+            }\n+            PointerOutOfBounds { alloc_id, offset, size, msg, allocation_size } => write!(\n                 f,\n-                \"{}pointer must be in-bounds at offset {}, \\\n-                           but is outside bounds of {} which has size {}\",\n+                \"{}{} has size {}, so pointer to {} bytes starting at offset {} is out-of-bounds\",\n                 msg,\n-                ptr.offset.bytes(),\n-                ptr.alloc_id,\n-                allocation_size.bytes()\n+                alloc_id,\n+                allocation_size.bytes(),\n+                size.bytes(),\n+                offset.bytes(),\n             ),\n             DanglingIntPointer(0, CheckInAllocMsg::InboundsTest) => {\n                 write!(f, \"null pointer is not a valid pointer for this operation\")\n@@ -348,13 +363,13 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             }\n             InvalidTag(val) => write!(f, \"enum value has invalid tag: {}\", val),\n             InvalidFunctionPointer(p) => {\n-                write!(f, \"using {} as function pointer but it does not point to a function\", p)\n+                write!(f, \"using {:?} as function pointer but it does not point to a function\", p)\n             }\n             InvalidStr(err) => write!(f, \"this string is not valid UTF-8: {}\", err),\n             InvalidUninitBytes(Some((alloc, access))) => write!(\n                 f,\n-                \"reading {} byte{} of memory starting at {}, \\\n-                 but {} byte{} {} uninitialized starting at {}, \\\n+                \"reading {} byte{} of memory starting at {:?}, \\\n+                 but {} byte{} {} uninitialized starting at {:?}, \\\n                  and this operation requires initialized memory\",\n                 access.access_size.bytes(),\n                 pluralize!(access.access_size.bytes()),\n@@ -392,8 +407,6 @@ pub enum UnsupportedOpInfo {\n     //\n     // The variants below are only reachable from CTFE/const prop, miri will never emit them.\n     //\n-    /// Encountered raw bytes where we needed a pointer.\n-    ReadBytesAsPointer,\n     /// Accessing thread local statics\n     ThreadLocalStatic(DefId),\n     /// Accessing an unsupported extern static.\n@@ -408,7 +421,6 @@ impl fmt::Display for UnsupportedOpInfo {\n             ReadExternStatic(did) => write!(f, \"cannot read from extern static ({:?})\", did),\n             NoMirFor(did) => write!(f, \"no MIR body is available for {:?}\", did),\n             ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\",),\n-            ReadBytesAsPointer => write!(f, \"unable to turn bytes into a pointer\"),\n             ThreadLocalStatic(did) => write!(f, \"cannot access thread local static ({:?})\", did),\n         }\n     }"}, {"sha": "dd9ac7f5c3955321c5ed8e9d7cf727a47dbd39a2", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -99,7 +99,7 @@ use std::convert::TryFrom;\n use std::fmt;\n use std::io;\n use std::io::{Read, Write};\n-use std::num::NonZeroU32;\n+use std::num::{NonZeroU32, NonZeroU64};\n use std::sync::atomic::{AtomicU32, Ordering};\n \n use rustc_ast::LitKind;\n@@ -127,7 +127,7 @@ pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar, ScalarMay\n \n pub use self::allocation::{alloc_range, AllocRange, Allocation, InitMask, Relocations};\n \n-pub use self::pointer::{Pointer, PointerArithmetic};\n+pub use self::pointer::{Pointer, PointerArithmetic, Provenance};\n \n /// Uniquely identifies one of the following:\n /// - A constant\n@@ -176,7 +176,7 @@ pub enum LitToConstError {\n }\n \n #[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-pub struct AllocId(pub u64);\n+pub struct AllocId(pub NonZeroU64);\n \n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n@@ -427,7 +427,11 @@ crate struct AllocMap<'tcx> {\n \n impl<'tcx> AllocMap<'tcx> {\n     crate fn new() -> Self {\n-        AllocMap { alloc_map: Default::default(), dedup: Default::default(), next_id: AllocId(0) }\n+        AllocMap {\n+            alloc_map: Default::default(),\n+            dedup: Default::default(),\n+            next_id: AllocId(NonZeroU64::new(1).unwrap()),\n+        }\n     }\n     fn reserve(&mut self) -> AllocId {\n         let next = self.next_id;"}, {"sha": "7e7a7119be6a8144e6c7892fb5a38cb51bc217d8", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 99, "deletions": 58, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -83,55 +83,77 @@ pub trait PointerArithmetic: HasDataLayout {\n \n impl<T: HasDataLayout> PointerArithmetic for T {}\n \n+/// This trait abstracts over the kind of provenance that is associated with a `Pointer`. It is\n+/// mostly opaque; the `Machine` trait extends it with some more operations that also have access to\n+/// some global state.\n+/// We don't actually care about this `Debug` bound (we use `Provenance::fmt` to format the entire\n+/// pointer), but `derive` adds some unecessary bounds.\n+pub trait Provenance: Copy + fmt::Debug {\n+    /// Says whether the `offset` field of `Pointer`s with this provenance is the actual physical address.\n+    /// If `true, ptr-to-int casts work by simply discarding the provenance.\n+    /// If `false`, ptr-to-int casts are not supported. The offset *must* be relative in that case.\n+    const OFFSET_IS_ADDR: bool;\n+\n+    /// Determines how a pointer should be printed.\n+    fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result\n+    where\n+        Self: Sized;\n+\n+    /// Provenance must always be able to identify the allocation this ptr points to.\n+    /// (Identifying the offset in that allocation, however, is harder -- use `Memory::ptr_get_alloc` for that.)\n+    fn get_alloc_id(self) -> AllocId;\n+}\n+\n+impl Provenance for AllocId {\n+    // With the `AllocId` as provenance, the `offset` is interpreted *relative to the allocation*,\n+    // so ptr-to-int casts are not possible (since we do not know the global physical offset).\n+    const OFFSET_IS_ADDR: bool = false;\n+\n+    fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Forward `alternate` flag to `alloc_id` printing.\n+        if f.alternate() {\n+            write!(f, \"{:#?}\", ptr.provenance)?;\n+        } else {\n+            write!(f, \"{:?}\", ptr.provenance)?;\n+        }\n+        // Print offset only if it is non-zero.\n+        if ptr.offset.bytes() > 0 {\n+            write!(f, \"+0x{:x}\", ptr.offset.bytes())?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn get_alloc_id(self) -> AllocId {\n+        self\n+    }\n+}\n+\n /// Represents a pointer in the Miri engine.\n ///\n-/// `Pointer` is generic over the `Tag` associated with each pointer,\n-/// which is used to do provenance tracking during execution.\n+/// Pointers are \"tagged\" with provenance information; typically the `AllocId` they belong to.\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n-pub struct Pointer<Tag = ()> {\n-    pub alloc_id: AllocId,\n-    pub offset: Size,\n-    pub tag: Tag,\n+pub struct Pointer<Tag = AllocId> {\n+    pub(super) offset: Size, // kept private to avoid accidental misinterpretation (meaning depends on `Tag` type)\n+    pub provenance: Tag,\n }\n \n static_assert_size!(Pointer, 16);\n \n-/// Print the address of a pointer (without the tag)\n-fn print_ptr_addr<Tag>(ptr: &Pointer<Tag>, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    // Forward `alternate` flag to `alloc_id` printing.\n-    if f.alternate() {\n-        write!(f, \"{:#?}\", ptr.alloc_id)?;\n-    } else {\n-        write!(f, \"{:?}\", ptr.alloc_id)?;\n-    }\n-    // Print offset only if it is non-zero.\n-    if ptr.offset.bytes() > 0 {\n-        write!(f, \"+0x{:x}\", ptr.offset.bytes())?;\n-    }\n-    Ok(())\n-}\n-\n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n-// We have to use `Debug` output for the tag, because `()` does not implement\n-// `Display` so we cannot specialize that.\n-impl<Tag: fmt::Debug> fmt::Debug for Pointer<Tag> {\n-    default fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        print_ptr_addr(self, f)?;\n-        write!(f, \"[{:?}]\", self.tag)\n-    }\n-}\n-// Specialization for no tag\n-impl fmt::Debug for Pointer<()> {\n+impl<Tag: Provenance> fmt::Debug for Pointer<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        print_ptr_addr(self, f)\n+        Provenance::fmt(self, f)\n     }\n }\n \n-impl<Tag: fmt::Debug> fmt::Display for Pointer<Tag> {\n+impl<Tag: Provenance> fmt::Debug for Pointer<Option<Tag>> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(self, f)\n+        match self.provenance {\n+            Some(tag) => Provenance::fmt(&Pointer::new(tag, self.offset), f),\n+            None => write!(f, \"0x{:x}\", self.offset.bytes()),\n+        }\n     }\n }\n \n@@ -143,37 +165,61 @@ impl From<AllocId> for Pointer {\n     }\n }\n \n-impl Pointer<()> {\n+impl<Tag> From<Pointer<Tag>> for Pointer<Option<Tag>> {\n     #[inline(always)]\n-    pub fn new(alloc_id: AllocId, offset: Size) -> Self {\n-        Pointer { alloc_id, offset, tag: () }\n+    fn from(ptr: Pointer<Tag>) -> Self {\n+        let (tag, offset) = ptr.into_parts();\n+        Pointer::new(Some(tag), offset)\n+    }\n+}\n+\n+impl<Tag> Pointer<Option<Tag>> {\n+    pub fn into_pointer_or_addr(self) -> Result<Pointer<Tag>, Size> {\n+        match self.provenance {\n+            Some(tag) => Ok(Pointer::new(tag, self.offset)),\n+            None => Err(self.offset),\n+        }\n     }\n+}\n \n+impl<Tag> Pointer<Option<Tag>> {\n     #[inline(always)]\n-    pub fn with_tag<Tag>(self, tag: Tag) -> Pointer<Tag> {\n-        Pointer::new_with_tag(self.alloc_id, self.offset, tag)\n+    pub fn null() -> Self {\n+        Pointer { provenance: None, offset: Size::ZERO }\n     }\n }\n \n impl<'tcx, Tag> Pointer<Tag> {\n     #[inline(always)]\n-    pub fn new_with_tag(alloc_id: AllocId, offset: Size, tag: Tag) -> Self {\n-        Pointer { alloc_id, offset, tag }\n+    pub fn new(provenance: Tag, offset: Size) -> Self {\n+        Pointer { provenance, offset }\n+    }\n+\n+    /// Obtain the constituents of this pointer. Not that the meaning of the offset depends on the type `Tag`!\n+    /// This function must only be used in the implementation of `Machine::ptr_get_alloc`,\n+    /// and when a `Pointer` is taken apart to be stored efficiently in an `Allocation`.\n+    #[inline(always)]\n+    pub fn into_parts(self) -> (Tag, Size) {\n+        (self.provenance, self.offset)\n+    }\n+\n+    pub fn map_provenance(self, f: impl FnOnce(Tag) -> Tag) -> Self {\n+        Pointer { provenance: f(self.provenance), ..self }\n     }\n \n     #[inline]\n     pub fn offset(self, i: Size, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n-        Ok(Pointer::new_with_tag(\n-            self.alloc_id,\n-            Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n-            self.tag,\n-        ))\n+        Ok(Pointer {\n+            offset: Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n+            ..self\n+        })\n     }\n \n     #[inline]\n     pub fn overflowing_offset(self, i: Size, cx: &impl HasDataLayout) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_offset(self.offset.bytes(), i.bytes());\n-        (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n+        let ptr = Pointer { offset: Size::from_bytes(res), ..self };\n+        (ptr, over)\n     }\n \n     #[inline(always)]\n@@ -183,26 +229,21 @@ impl<'tcx, Tag> Pointer<Tag> {\n \n     #[inline]\n     pub fn signed_offset(self, i: i64, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n-        Ok(Pointer::new_with_tag(\n-            self.alloc_id,\n-            Size::from_bytes(cx.data_layout().signed_offset(self.offset.bytes(), i)?),\n-            self.tag,\n-        ))\n+        Ok(Pointer {\n+            offset: Size::from_bytes(cx.data_layout().signed_offset(self.offset.bytes(), i)?),\n+            ..self\n+        })\n     }\n \n     #[inline]\n     pub fn overflowing_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n-        (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n+        let ptr = Pointer { offset: Size::from_bytes(res), ..self };\n+        (ptr, over)\n     }\n \n     #[inline(always)]\n     pub fn wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n         self.overflowing_signed_offset(i, cx).0\n     }\n-\n-    #[inline(always)]\n-    pub fn erase_tag(self) -> Pointer {\n-        Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n-    }\n }"}, {"sha": "62b71b10d5a1b98c7a0b94b100d46829dfac1fc7", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 93, "deletions": 162, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -6,11 +6,13 @@ use rustc_apfloat::{\n     Float,\n };\n use rustc_macros::HashStable;\n-use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n+use rustc_target::abi::{HasDataLayout, Size};\n \n use crate::ty::{Lift, ParamEnv, ScalarInt, Ty, TyCtxt};\n \n-use super::{AllocId, AllocRange, Allocation, InterpResult, Pointer, PointerArithmetic};\n+use super::{\n+    AllocId, AllocRange, Allocation, InterpResult, Pointer, PointerArithmetic, Provenance,\n+};\n \n /// Represents the result of const evaluation via the `eval_to_allocation` query.\n #[derive(Copy, Clone, HashStable, TyEncodable, TyDecodable, Debug, Hash, Eq, PartialEq)]\n@@ -47,12 +49,6 @@ pub enum ConstValue<'tcx> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(ConstValue<'_>, 32);\n \n-impl From<Scalar> for ConstValue<'tcx> {\n-    fn from(s: Scalar) -> Self {\n-        Self::Scalar(s)\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n     type Lifted = ConstValue<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ConstValue<'tcx>> {\n@@ -70,7 +66,7 @@ impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n \n impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n-    pub fn try_to_scalar(&self) -> Option<Scalar> {\n+    pub fn try_to_scalar(&self) -> Option<Scalar<AllocId>> {\n         match *self {\n             ConstValue::ByRef { .. } | ConstValue::Slice { .. } => None,\n             ConstValue::Scalar(val) => Some(val),\n@@ -120,37 +116,44 @@ impl<'tcx> ConstValue<'tcx> {\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 16 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n /// of a simple value or a pointer into another `Allocation`\n+///\n+/// These variants would be private if there was a convenient way to achieve that in Rust.\n+/// Do *not* match on a `Scalar`! Use the various `to_*` methods instead.\n #[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n-pub enum Scalar<Tag = ()> {\n+pub enum Scalar<Tag = AllocId> {\n     /// The raw bytes of a simple value.\n     Int(ScalarInt),\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n     /// relocation and its associated offset together as a `Pointer` here.\n-    Ptr(Pointer<Tag>),\n+    ///\n+    /// We also store the size of the pointer, such that a `Scalar` always knows how big it is.\n+    /// The size is always the pointer size of the current target, but this is not information\n+    /// that we always have readily available.\n+    Ptr(Pointer<Tag>, u8),\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(Scalar, 24);\n \n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n-impl<Tag: fmt::Debug> fmt::Debug for Scalar<Tag> {\n+impl<Tag: Provenance> fmt::Debug for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Scalar::Ptr(ptr) => write!(f, \"{:?}\", ptr),\n+            Scalar::Ptr(ptr, _size) => write!(f, \"{:?}\", ptr),\n             Scalar::Int(int) => write!(f, \"{:?}\", int),\n         }\n     }\n }\n \n-impl<Tag: fmt::Debug> fmt::Display for Scalar<Tag> {\n+impl<Tag: Provenance> fmt::Display for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Scalar::Ptr(ptr) => write!(f, \"pointer to {}\", ptr),\n-            Scalar::Int { .. } => fmt::Debug::fmt(self, f),\n+            Scalar::Ptr(ptr, _size) => write!(f, \"pointer to {:?}\", ptr),\n+            Scalar::Int(int) => write!(f, \"{:?}\", int),\n         }\n     }\n }\n@@ -169,83 +172,34 @@ impl<Tag> From<Double> for Scalar<Tag> {\n     }\n }\n \n-impl Scalar<()> {\n-    /// Tag this scalar with `new_tag` if it is a pointer, leave it unchanged otherwise.\n-    ///\n-    /// Used by `MemPlace::replace_tag`.\n-    #[inline]\n-    pub fn with_tag<Tag>(self, new_tag: Tag) -> Scalar<Tag> {\n-        match self {\n-            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_tag(new_tag)),\n-            Scalar::Int(int) => Scalar::Int(int),\n-        }\n+impl<Tag> From<ScalarInt> for Scalar<Tag> {\n+    #[inline(always)]\n+    fn from(ptr: ScalarInt) -> Self {\n+        Scalar::Int(ptr)\n     }\n }\n \n-impl<'tcx, Tag> Scalar<Tag> {\n+impl<Tag> Scalar<Tag> {\n     pub const ZST: Self = Scalar::Int(ScalarInt::ZST);\n \n-    /// Erase the tag from the scalar, if any.\n-    ///\n-    /// Used by error reporting code to avoid having the error type depend on `Tag`.\n-    #[inline]\n-    pub fn erase_tag(self) -> Scalar {\n-        match self {\n-            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.erase_tag()),\n-            Scalar::Int(int) => Scalar::Int(int),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn null_ptr(cx: &impl HasDataLayout) -> Self {\n-        Scalar::Int(ScalarInt::null(cx.data_layout().pointer_size))\n-    }\n-\n     #[inline(always)]\n-    fn ptr_op(\n-        self,\n-        dl: &TargetDataLayout,\n-        f_int: impl FnOnce(u64) -> InterpResult<'tcx, u64>,\n-        f_ptr: impl FnOnce(Pointer<Tag>) -> InterpResult<'tcx, Pointer<Tag>>,\n-    ) -> InterpResult<'tcx, Self> {\n-        match self {\n-            Scalar::Int(int) => Ok(Scalar::Int(int.ptr_sized_op(dl, f_int)?)),\n-            Scalar::Ptr(ptr) => Ok(Scalar::Ptr(f_ptr(ptr)?)),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n-        let dl = cx.data_layout();\n-        self.ptr_op(dl, |int| dl.offset(int, i.bytes()), |ptr| ptr.offset(i, dl))\n+    pub fn from_pointer(ptr: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n+        Scalar::Ptr(ptr, u8::try_from(cx.pointer_size().bytes()).unwrap())\n     }\n \n-    #[inline]\n-    pub fn ptr_wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n-        let dl = cx.data_layout();\n-        self.ptr_op(\n-            dl,\n-            |int| Ok(dl.overflowing_offset(int, i.bytes()).0),\n-            |ptr| Ok(ptr.wrapping_offset(i, dl)),\n-        )\n-        .unwrap()\n-    }\n-\n-    #[inline]\n-    pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> InterpResult<'tcx, Self> {\n-        let dl = cx.data_layout();\n-        self.ptr_op(dl, |int| dl.signed_offset(int, i), |ptr| ptr.signed_offset(i, dl))\n+    /// Create a Scalar from a pointer with an `Option<_>` tag (where `None` represents a plain integer).\n+    pub fn from_maybe_pointer(ptr: Pointer<Option<Tag>>, cx: &impl HasDataLayout) -> Self {\n+        match ptr.into_parts() {\n+            (Some(tag), offset) => Scalar::from_pointer(Pointer::new(tag, offset), cx),\n+            (None, offset) => {\n+                Scalar::Int(ScalarInt::try_from_uint(offset.bytes(), cx.pointer_size()).unwrap())\n+            }\n+        }\n     }\n \n     #[inline]\n-    pub fn ptr_wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n-        let dl = cx.data_layout();\n-        self.ptr_op(\n-            dl,\n-            |int| Ok(dl.overflowing_signed_offset(int, i).0),\n-            |ptr| Ok(ptr.wrapping_signed_offset(i, dl)),\n-        )\n-        .unwrap()\n+    pub fn null_ptr(cx: &impl HasDataLayout) -> Self {\n+        Scalar::Int(ScalarInt::null(cx.pointer_size()))\n     }\n \n     #[inline]\n@@ -332,74 +286,71 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Scalar::Int(f.into())\n     }\n \n-    /// This is very rarely the method you want!  You should dispatch on the type\n-    /// and use `force_bits`/`assert_bits`/`force_ptr`/`assert_ptr`.\n-    /// This method only exists for the benefit of low-level memory operations\n-    /// as well as the implementation of the `force_*` methods.\n+    /// This is almost certainly not the method you want!  You should dispatch on the type\n+    /// and use `to_{u8,u16,...}`/`scalar_to_ptr` to perform ptr-to-int / int-to-ptr casts as needed.\n+    ///\n+    /// This method only exists for the benefit of low-level operations that truly need to treat the\n+    /// scalar in whatever form it is.\n     #[inline]\n-    pub fn to_bits_or_ptr(\n-        self,\n-        target_size: Size,\n-        cx: &impl HasDataLayout,\n-    ) -> Result<u128, Pointer<Tag>> {\n+    pub fn to_bits_or_ptr_internal(self, target_size: Size) -> Result<u128, Pointer<Tag>> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n             Scalar::Int(int) => Ok(int.assert_bits(target_size)),\n-            Scalar::Ptr(ptr) => {\n-                assert_eq!(target_size, cx.data_layout().pointer_size);\n+            Scalar::Ptr(ptr, sz) => {\n+                assert_eq!(target_size.bytes(), u64::from(sz));\n                 Err(ptr)\n             }\n         }\n     }\n+}\n \n-    /// This method is intentionally private!\n-    /// It is just a helper for other methods in this file.\n+impl<'tcx, Tag: Provenance> Scalar<Tag> {\n+    /// Fundamental scalar-to-int (cast) operation. Many convenience wrappers exist below, that you\n+    /// likely want to use instead.\n+    ///\n+    /// Will perform ptr-to-int casts if needed and possible.\n+    /// If that fails, we know the offset is relative, so we return an \"erased\" Scalar\n+    /// (which is useful for error messages but not much else).\n     #[inline]\n-    fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n-        assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n+    pub fn try_to_int(self) -> Result<ScalarInt, Scalar<AllocId>> {\n         match self {\n-            Scalar::Int(int) => int.to_bits(target_size).map_err(|size| {\n-                err_ub!(ScalarSizeMismatch {\n-                    target_size: target_size.bytes(),\n-                    data_size: size.bytes(),\n-                })\n-                .into()\n-            }),\n-            Scalar::Ptr(_) => throw_unsup!(ReadPointerAsBytes),\n+            Scalar::Int(int) => Ok(int),\n+            Scalar::Ptr(ptr, sz) => {\n+                if Tag::OFFSET_IS_ADDR {\n+                    Ok(ScalarInt::try_from_uint(ptr.offset.bytes(), Size::from_bytes(sz)).unwrap())\n+                } else {\n+                    // We know `offset` is relative, since `OFFSET_IS_ADDR == false`.\n+                    let (tag, offset) = ptr.into_parts();\n+                    Err(Scalar::Ptr(Pointer::new(tag.get_alloc_id(), offset), sz))\n+                }\n+            }\n         }\n     }\n \n     #[inline(always)]\n-    pub fn assert_bits(self, target_size: Size) -> u128 {\n-        self.to_bits(target_size).expect(\"expected Raw bits but got a Pointer\")\n-    }\n-\n-    #[inline]\n     pub fn assert_int(self) -> ScalarInt {\n-        match self {\n-            Scalar::Ptr(_) => bug!(\"expected an int but got an abstract pointer\"),\n-            Scalar::Int(int) => int,\n-        }\n+        self.try_to_int().unwrap()\n     }\n \n+    /// This throws UB (instead of ICEing) on a size mismatch since size mismatches can arise in\n+    /// Miri when someone declares a function that we shim (such as `malloc`) with a wrong type.\n     #[inline]\n-    pub fn assert_ptr(self) -> Pointer<Tag> {\n-        match self {\n-            Scalar::Ptr(p) => p,\n-            Scalar::Int { .. } => bug!(\"expected a Pointer but got Raw bits\"),\n-        }\n-    }\n-\n-    /// Do not call this method!  Dispatch based on the type instead.\n-    #[inline]\n-    pub fn is_bits(self) -> bool {\n-        matches!(self, Scalar::Int { .. })\n+    pub fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n+        assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n+        self.try_to_int().map_err(|_| err_unsup!(ReadPointerAsBytes))?.to_bits(target_size).map_err(\n+            |size| {\n+                err_ub!(ScalarSizeMismatch {\n+                    target_size: target_size.bytes(),\n+                    data_size: size.bytes(),\n+                })\n+                .into()\n+            },\n+        )\n     }\n \n-    /// Do not call this method!  Dispatch based on the type instead.\n-    #[inline]\n-    pub fn is_ptr(self) -> bool {\n-        matches!(self, Scalar::Ptr(_))\n+    #[inline(always)]\n+    pub fn assert_bits(self, target_size: Size) -> u128 {\n+        self.to_bits(target_size).unwrap()\n     }\n \n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n@@ -507,22 +458,8 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n }\n \n-impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n-    #[inline(always)]\n-    fn from(ptr: Pointer<Tag>) -> Self {\n-        Scalar::Ptr(ptr)\n-    }\n-}\n-\n-impl<Tag> From<ScalarInt> for Scalar<Tag> {\n-    #[inline(always)]\n-    fn from(ptr: ScalarInt) -> Self {\n-        Scalar::Int(ptr)\n-    }\n-}\n-\n #[derive(Clone, Copy, Eq, PartialEq, TyEncodable, TyDecodable, HashStable, Hash)]\n-pub enum ScalarMaybeUninit<Tag = ()> {\n+pub enum ScalarMaybeUninit<Tag = AllocId> {\n     Scalar(Scalar<Tag>),\n     Uninit,\n }\n@@ -537,16 +474,9 @@ impl<Tag> From<Scalar<Tag>> for ScalarMaybeUninit<Tag> {\n     }\n }\n \n-impl<Tag> From<Pointer<Tag>> for ScalarMaybeUninit<Tag> {\n-    #[inline(always)]\n-    fn from(s: Pointer<Tag>) -> Self {\n-        ScalarMaybeUninit::Scalar(s.into())\n-    }\n-}\n-\n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n-impl<Tag: fmt::Debug> fmt::Debug for ScalarMaybeUninit<Tag> {\n+impl<Tag: Provenance> fmt::Debug for ScalarMaybeUninit<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             ScalarMaybeUninit::Uninit => write!(f, \"<uninitialized>\"),\n@@ -555,7 +485,7 @@ impl<Tag: fmt::Debug> fmt::Debug for ScalarMaybeUninit<Tag> {\n     }\n }\n \n-impl<Tag: fmt::Debug> fmt::Display for ScalarMaybeUninit<Tag> {\n+impl<Tag: Provenance> fmt::Display for ScalarMaybeUninit<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             ScalarMaybeUninit::Uninit => write!(f, \"uninitialized bytes\"),\n@@ -564,16 +494,15 @@ impl<Tag: fmt::Debug> fmt::Display for ScalarMaybeUninit<Tag> {\n     }\n }\n \n-impl<'tcx, Tag> ScalarMaybeUninit<Tag> {\n-    /// Erase the tag from the scalar, if any.\n-    ///\n-    /// Used by error reporting code to avoid having the error type depend on `Tag`.\n+impl<Tag> ScalarMaybeUninit<Tag> {\n     #[inline]\n-    pub fn erase_tag(self) -> ScalarMaybeUninit {\n-        match self {\n-            ScalarMaybeUninit::Scalar(s) => ScalarMaybeUninit::Scalar(s.erase_tag()),\n-            ScalarMaybeUninit::Uninit => ScalarMaybeUninit::Uninit,\n-        }\n+    pub fn from_pointer(ptr: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n+        ScalarMaybeUninit::Scalar(Scalar::from_pointer(ptr, cx))\n+    }\n+\n+    #[inline]\n+    pub fn from_maybe_pointer(ptr: Pointer<Option<Tag>>, cx: &impl HasDataLayout) -> Self {\n+        ScalarMaybeUninit::Scalar(Scalar::from_maybe_pointer(ptr, cx))\n     }\n \n     #[inline]\n@@ -583,7 +512,9 @@ impl<'tcx, Tag> ScalarMaybeUninit<Tag> {\n             ScalarMaybeUninit::Uninit => throw_ub!(InvalidUninitBytes(None)),\n         }\n     }\n+}\n \n+impl<'tcx, Tag: Provenance> ScalarMaybeUninit<Tag> {\n     #[inline(always)]\n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n         self.check_init()?.to_bool()"}, {"sha": "da0d2575dcbe3377663318d64b83766be84b48fe", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -3,7 +3,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n use crate::mir::coverage::{CodeRegion, CoverageKind};\n-use crate::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n+use crate::mir::interpret::{Allocation, ConstValue, GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -2095,7 +2095,7 @@ impl<'tcx> Operand<'tcx> {\n         Operand::Constant(box Constant {\n             span,\n             user_ty: None,\n-            literal: ConstantKind::Val(val.into(), ty),\n+            literal: ConstantKind::Val(ConstValue::Scalar(val), ty),\n         })\n     }\n \n@@ -2458,7 +2458,7 @@ pub enum ConstantKind<'tcx> {\n impl Constant<'tcx> {\n     pub fn check_static_ptr(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n         match self.literal.const_for_ty()?.val.try_to_scalar() {\n-            Some(Scalar::Ptr(ptr)) => match tcx.global_alloc(ptr.alloc_id) {\n+            Some(Scalar::Ptr(ptr, _size)) => match tcx.global_alloc(ptr.provenance) {\n                 GlobalAlloc::Static(def_id) => {\n                     assert!(!tcx.is_thread_local_static(def_id));\n                     Some(def_id)"}, {"sha": "8262bc261996a510b45fc83bf0d0974301057b7a", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -1,7 +1,7 @@\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-use rustc_target::abi::{Size, TargetDataLayout};\n+use rustc_target::abi::Size;\n use std::convert::{TryFrom, TryInto};\n use std::fmt;\n \n@@ -193,15 +193,6 @@ impl ScalarInt {\n         self.data == 0\n     }\n \n-    pub(crate) fn ptr_sized_op<E>(\n-        self,\n-        dl: &TargetDataLayout,\n-        f_int: impl FnOnce(u64) -> Result<u64, E>,\n-    ) -> Result<Self, E> {\n-        assert_eq!(u64::from(self.size), dl.pointer_size.bytes());\n-        Ok(Self::try_from_uint(f_int(u64::try_from(self.data).unwrap())?, self.size()).unwrap())\n-    }\n-\n     #[inline]\n     pub fn try_from_uint(i: impl Into<u128>, size: Size) -> Option<Self> {\n         let data = i.into();"}, {"sha": "f2db95d162b888363fc7d016fe40af5c7f261e45", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -1,7 +1,6 @@\n use std::convert::TryInto;\n \n-use crate::mir::interpret::ConstValue;\n-use crate::mir::interpret::Scalar;\n+use crate::mir::interpret::{AllocId, ConstValue, Scalar};\n use crate::mir::Promoted;\n use crate::ty::subst::{InternalSubsts, SubstsRef};\n use crate::ty::ParamEnv;\n@@ -59,7 +58,7 @@ impl<'tcx> ConstKind<'tcx> {\n     }\n \n     #[inline]\n-    pub fn try_to_scalar(self) -> Option<Scalar> {\n+    pub fn try_to_scalar(self) -> Option<Scalar<AllocId>> {\n         self.try_to_value()?.try_to_scalar()\n     }\n "}, {"sha": "6dfbd28f7763b7db91a00610dc21d5ef151eb3b3", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -1,5 +1,5 @@\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n-use crate::mir::interpret::{AllocRange, ConstValue, GlobalAlloc, Pointer, Scalar};\n+use crate::mir::interpret::{AllocRange, ConstValue, GlobalAlloc, Pointer, Provenance, Scalar};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::ieee::{Double, Single};\n@@ -974,7 +974,7 @@ pub trait PrettyPrinter<'tcx>:\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {\n         match scalar {\n-            Scalar::Ptr(ptr) => self.pretty_print_const_scalar_ptr(ptr, ty, print_ty),\n+            Scalar::Ptr(ptr, _size) => self.pretty_print_const_scalar_ptr(ptr, ty, print_ty),\n             Scalar::Int(int) => self.pretty_print_const_scalar_int(int, ty, print_ty),\n         }\n     }\n@@ -987,6 +987,7 @@ pub trait PrettyPrinter<'tcx>:\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n+        let (alloc_id, offset) = ptr.into_parts();\n         match ty.kind() {\n             // Byte strings (&[u8; N])\n             ty::Ref(\n@@ -1002,10 +1003,10 @@ pub trait PrettyPrinter<'tcx>:\n                     ..\n                 },\n                 _,\n-            ) => match self.tcx().get_global_alloc(ptr.alloc_id) {\n+            ) => match self.tcx().get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Memory(alloc)) => {\n                     let len = int.assert_bits(self.tcx().data_layout.pointer_size);\n-                    let range = AllocRange { start: ptr.offset, size: Size::from_bytes(len) };\n+                    let range = AllocRange { start: offset, size: Size::from_bytes(len) };\n                     if let Ok(byte_str) = alloc.get_bytes(&self.tcx(), range) {\n                         p!(pretty_print_byte_str(byte_str))\n                     } else {\n@@ -1020,7 +1021,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::FnPtr(_) => {\n                 // FIXME: We should probably have a helper method to share code with the \"Byte strings\"\n                 // printing above (which also has to handle pointers to all sorts of things).\n-                match self.tcx().get_global_alloc(ptr.alloc_id) {\n+                match self.tcx().get_global_alloc(alloc_id) {\n                     Some(GlobalAlloc::Function(instance)) => {\n                         self = self.typed_value(\n                             |this| this.print_value_path(instance.def_id(), instance.substs),\n@@ -1068,8 +1069,8 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Char if char::try_from(int).is_ok() => {\n                 p!(write(\"{:?}\", char::try_from(int).unwrap()))\n             }\n-            // Raw pointers\n-            ty::RawPtr(_) | ty::FnPtr(_) => {\n+            // Pointer types\n+            ty::Ref(..) | ty::RawPtr(_) | ty::FnPtr(_) => {\n                 let data = int.assert_bits(self.tcx().data_layout.pointer_size);\n                 self = self.typed_value(\n                     |mut this| {\n@@ -1106,9 +1107,9 @@ pub trait PrettyPrinter<'tcx>:\n \n     /// This is overridden for MIR printing because we only want to hide alloc ids from users, not\n     /// from MIR where it is actually useful.\n-    fn pretty_print_const_pointer(\n+    fn pretty_print_const_pointer<Tag: Provenance>(\n         mut self,\n-        _: Pointer,\n+        _: Pointer<Tag>,\n         ty: Ty<'tcx>,\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {\n@@ -1679,9 +1680,9 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         }\n     }\n \n-    fn pretty_print_const_pointer(\n+    fn pretty_print_const_pointer<Tag: Provenance>(\n         self,\n-        p: Pointer,\n+        p: Pointer<Tag>,\n         ty: Ty<'tcx>,\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {"}, {"sha": "a4c36be21992b36b56743a1ca6a14edd7ad7180b", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -595,9 +595,12 @@ fn check_const_value_eq<R: TypeRelation<'tcx>>(\n         (ConstValue::Scalar(Scalar::Int(a_val)), ConstValue::Scalar(Scalar::Int(b_val))) => {\n             a_val == b_val\n         }\n-        (ConstValue::Scalar(Scalar::Ptr(a_val)), ConstValue::Scalar(Scalar::Ptr(b_val))) => {\n+        (\n+            ConstValue::Scalar(Scalar::Ptr(a_val, _a_size)),\n+            ConstValue::Scalar(Scalar::Ptr(b_val, _b_size)),\n+        ) => {\n             a_val == b_val\n-                || match (tcx.global_alloc(a_val.alloc_id), tcx.global_alloc(b_val.alloc_id)) {\n+                || match (tcx.global_alloc(a_val.provenance), tcx.global_alloc(b_val.provenance)) {\n                     (GlobalAlloc::Function(a_instance), GlobalAlloc::Function(b_instance)) => {\n                         a_instance == b_instance\n                     }"}, {"sha": "78109fc7b5713beeeb494c7e5d56ef4ad77e96bc", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -1,6 +1,6 @@\n use std::convert::TryFrom;\n \n-use crate::mir::interpret::{alloc_range, AllocId, Allocation, Pointer, Scalar};\n+use crate::mir::interpret::{alloc_range, AllocId, Allocation, Pointer, Scalar, ScalarMaybeUninit};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::{self, DefId, SubstsRef, Ty, TyCtxt};\n use rustc_ast::Mutability;\n@@ -74,7 +74,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     let instance = ty::Instance::resolve_drop_in_place(tcx, ty);\n                     let fn_alloc_id = tcx.create_fn_alloc(instance);\n                     let fn_ptr = Pointer::from(fn_alloc_id);\n-                    fn_ptr.into()\n+                    ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n                 }\n                 VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size).into(),\n                 VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size).into(),\n@@ -90,7 +90,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                             .polymorphize(tcx);\n                     let fn_alloc_id = tcx.create_fn_alloc(instance);\n                     let fn_ptr = Pointer::from(fn_alloc_id);\n-                    fn_ptr.into()\n+                    ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n                 }\n             };\n             vtable"}, {"sha": "5da1681662577648009f96b1da5b0aabfe02229d", "filename": "compiler/rustc_mir/src/const_eval/error.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Ferror.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -16,7 +16,6 @@ use crate::interpret::{\n #[derive(Clone, Debug)]\n pub enum ConstEvalErrKind {\n     NeedsRfc(String),\n-    PtrToIntCast,\n     ConstAccessesStatic,\n     ModifiedGlobal,\n     AssertFailure(AssertKind<ConstInt>),\n@@ -49,12 +48,6 @@ impl fmt::Display for ConstEvalErrKind {\n             NeedsRfc(ref msg) => {\n                 write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg)\n             }\n-            PtrToIntCast => {\n-                write!(\n-                    f,\n-                    \"cannot cast pointer to integer because it was not created by cast from integer\"\n-                )\n-            }\n             ConstAccessesStatic => write!(f, \"constant accesses static\"),\n             ModifiedGlobal => {\n                 write!(f, \"modifying a static's initial value from another static's initializer\")"}, {"sha": "dc6a6b0b9f3d8bca119dcd52d4dde902e5ac5a29", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -136,19 +136,19 @@ pub(super) fn op_to_const<'tcx>(\n         // by-val is if we are in destructure_const, i.e., if this is (a field of) something that we\n         // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n         // structs containing such.\n-        op.try_as_mplace(ecx)\n+        op.try_as_mplace()\n     };\n \n-    let to_const_value = |mplace: &MPlaceTy<'_>| match mplace.ptr {\n-        Scalar::Ptr(ptr) => {\n-            let alloc = ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory();\n-            ConstValue::ByRef { alloc, offset: ptr.offset }\n+    // We know `offset` is relative to the allocation, so we can use `into_parts`.\n+    let to_const_value = |mplace: &MPlaceTy<'_>| match mplace.ptr.into_parts() {\n+        (Some(alloc_id), offset) => {\n+            let alloc = ecx.tcx.global_alloc(alloc_id).unwrap_memory();\n+            ConstValue::ByRef { alloc, offset }\n         }\n-        Scalar::Int(int) => {\n+        (None, offset) => {\n             assert!(mplace.layout.is_zst());\n             assert_eq!(\n-                int.assert_bits(ecx.tcx.data_layout.pointer_size)\n-                    % u128::from(mplace.layout.align.abi.bytes()),\n+                offset.bytes() % mplace.layout.align.abi.bytes(),\n                 0,\n                 \"this MPlaceTy must come from a validated constant, thus we can assume the \\\n                 alignment is correct\",\n@@ -162,14 +162,15 @@ pub(super) fn op_to_const<'tcx>(\n         Err(imm) => match *imm {\n             Immediate::Scalar(x) => match x {\n                 ScalarMaybeUninit::Scalar(s) => ConstValue::Scalar(s),\n-                ScalarMaybeUninit::Uninit => to_const_value(&op.assert_mem_place(ecx)),\n+                ScalarMaybeUninit::Uninit => to_const_value(&op.assert_mem_place()),\n             },\n             Immediate::ScalarPair(a, b) => {\n-                let (data, start) = match a.check_init().unwrap() {\n-                    Scalar::Ptr(ptr) => {\n-                        (ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory(), ptr.offset.bytes())\n+                // We know `offset` is relative to the allocation, so we can use `into_parts`.\n+                let (data, start) = match ecx.scalar_to_ptr(a.check_init().unwrap()).into_parts() {\n+                    (Some(alloc_id), offset) => {\n+                        (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n                     }\n-                    Scalar::Int { .. } => (\n+                    (None, _offset) => (\n                         ecx.tcx.intern_const_alloc(Allocation::from_bytes_byte_aligned_immutable(\n                             b\"\" as &[u8],\n                         )),\n@@ -369,6 +370,7 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                     inner = true;\n                 }\n             };\n+            let alloc_id = mplace.ptr.provenance.unwrap();\n             if let Err(error) = validation {\n                 // Validation failed, report an error. This is always a hard error.\n                 let err = ConstEvalErr::new(&ecx, error, None);\n@@ -381,17 +383,15 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                             \"the raw bytes of the constant ({}\",\n                             display_allocation(\n                                 *ecx.tcx,\n-                                ecx.tcx\n-                                    .global_alloc(mplace.ptr.assert_ptr().alloc_id)\n-                                    .unwrap_memory()\n+                                ecx.tcx.global_alloc(alloc_id).unwrap_memory()\n                             )\n                         ));\n                         diag.emit();\n                     },\n                 ))\n             } else {\n                 // Convert to raw constant\n-                Ok(ConstAlloc { alloc_id: mplace.ptr.assert_ptr().alloc_id, ty: mplace.layout.ty })\n+                Ok(ConstAlloc { alloc_id, ty: mplace.layout.ty })\n             }\n         }\n     }"}, {"sha": "c809f4f273aa5e059377ddb5ab9a98c29b768cc8", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -16,8 +16,8 @@ use rustc_target::abi::{Align, Size};\n use rustc_target::spec::abi::Abi;\n \n use crate::interpret::{\n-    self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, InterpCx, InterpResult, Memory,\n-    OpTy, PlaceTy, Pointer, Scalar, StackPopUnwind,\n+    self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, InterpCx, InterpResult, OpTy,\n+    PlaceTy, Scalar, StackPopUnwind,\n };\n \n use super::error::*;\n@@ -59,7 +59,7 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     pub steps_remaining: usize,\n \n     /// The virtual call stack.\n-    pub(crate) stack: Vec<Frame<'mir, 'tcx, (), ()>>,\n+    pub(crate) stack: Vec<Frame<'mir, 'tcx, AllocId, ()>>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -168,11 +168,11 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n             // Comparisons between integers are always known.\n             (Scalar::Int { .. }, Scalar::Int { .. }) => a == b,\n             // Equality with integers can never be known for sure.\n-            (Scalar::Int { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Int { .. }) => false,\n+            (Scalar::Int { .. }, Scalar::Ptr(..)) | (Scalar::Ptr(..), Scalar::Int { .. }) => false,\n             // FIXME: return `true` for when both sides are the same pointer, *except* that\n             // some things (like functions and vtables) do not have stable addresses\n             // so we need to be careful around them (see e.g. #73722).\n-            (Scalar::Ptr(_), Scalar::Ptr(_)) => false,\n+            (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n         }\n     }\n \n@@ -183,13 +183,13 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n             // Comparisons of abstract pointers with null pointers are known if the pointer\n             // is in bounds, because if they are in bounds, the pointer can't be null.\n             // Inequality with integers other than null can never be known for sure.\n-            (Scalar::Int(int), Scalar::Ptr(ptr)) | (Scalar::Ptr(ptr), Scalar::Int(int)) => {\n-                int.is_null() && !self.memory.ptr_may_be_null(ptr)\n+            (Scalar::Int(int), Scalar::Ptr(ptr, _)) | (Scalar::Ptr(ptr, _), Scalar::Int(int)) => {\n+                int.is_null() && !self.memory.ptr_may_be_null(ptr.into())\n             }\n             // FIXME: return `true` for at least some comparisons where we can reliably\n             // determine the result of runtime inequality tests at compile-time.\n             // Examples include comparison of addresses in different static items.\n-            (Scalar::Ptr(_), Scalar::Ptr(_)) => false,\n+            (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n         }\n     }\n }\n@@ -312,7 +312,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     align,\n                     interpret::MemoryKind::Machine(MemoryKind::Heap),\n                 )?;\n-                ecx.write_scalar(Scalar::Ptr(ptr), dest)?;\n+                ecx.write_pointer(ptr, dest)?;\n             }\n             _ => {\n                 return Err(ConstEvalErrKind::NeedsRfc(format!(\n@@ -356,10 +356,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Err(ConstEvalErrKind::Abort(msg).into())\n     }\n \n-    fn ptr_to_int(_mem: &Memory<'mir, 'tcx, Self>, _ptr: Pointer) -> InterpResult<'tcx, u64> {\n-        Err(ConstEvalErrKind::PtrToIntCast.into())\n-    }\n-\n     fn binary_ptr_op(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,"}, {"sha": "a334165df4cb1ff28a3747663808b2416edec18f", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -35,7 +35,7 @@ pub(crate) fn const_caller_location(\n     if intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &loc_place).is_err() {\n         bug!(\"intern_const_alloc_recursive should not error in this case\")\n     }\n-    ConstValue::Scalar(loc_place.ptr)\n+    ConstValue::Scalar(Scalar::from_pointer(loc_place.ptr.into_pointer_or_addr().unwrap(), &tcx))\n }\n \n /// Convert an evaluated constant to a type level constant\n@@ -179,9 +179,9 @@ pub(crate) fn deref_const<'tcx>(\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n     let op = ecx.const_to_op(val, None).unwrap();\n     let mplace = ecx.deref_operand(&op).unwrap();\n-    if let Scalar::Ptr(ptr) = mplace.ptr {\n+    if let Some(alloc_id) = mplace.ptr.provenance {\n         assert_eq!(\n-            tcx.get_global_alloc(ptr.alloc_id).unwrap().unwrap_memory().mutability,\n+            tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().mutability,\n             Mutability::Not,\n             \"deref_const cannot be used with mutable allocations as \\\n             that could allow pattern matching to observe mutable statics\","}, {"sha": "514c1aa9646a063c28e50ac54ca11a1a8d755d01", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -57,7 +57,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         .ok_or_else(|| err_inval!(TooGeneric))?;\n \n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n-                        self.write_scalar(fn_ptr, dest)?;\n+                        self.write_pointer(fn_ptr, dest)?;\n                     }\n                     _ => span_bug!(self.cur_span(), \"reify fn pointer on {:?}\", src.layout.ty),\n                 }\n@@ -88,7 +88,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             ty::ClosureKind::FnOnce,\n                         );\n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n-                        self.write_scalar(fn_ptr, dest)?;\n+                        self.write_pointer(fn_ptr, dest)?;\n                     }\n                     _ => span_bug!(self.cur_span(), \"closure fn pointer on {:?}\", src.layout.ty),\n                 }\n@@ -175,7 +175,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // (a) cast a raw ptr to usize, or\n         // (b) cast from an integer-like (including bool, char, enums).\n         // In both cases we want the bits.\n-        let bits = self.force_bits(src.to_scalar()?, src.layout.size)?;\n+        let bits = src.to_scalar()?.to_bits(src.layout.size)?;\n         Ok(self.cast_from_scalar(bits, src.layout, cast_ty).into())\n     }\n \n@@ -280,7 +280,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable(src_pointee_ty, data.principal())?;\n                 let ptr = self.read_immediate(src)?.to_scalar()?;\n-                let val = Immediate::new_dyn_trait(ptr, vtable);\n+                let val = Immediate::new_dyn_trait(ptr, vtable, &*self.tcx);\n                 self.write_immediate(val, dest)\n             }\n "}, {"sha": "516ef4f4e53ca8130a1c9a5d9f73b57d4c5f7982", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 44, "deletions": 54, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -8,7 +8,6 @@ use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{GlobalId, InterpResult, Pointer, Scalar};\n use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::{\n     self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n@@ -18,8 +17,9 @@ use rustc_span::{Pos, Span};\n use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n \n use super::{\n-    Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, MemoryKind, Operand, Place,\n-    PlaceTy, ScalarMaybeUninit, StackPopJump,\n+    AllocId, GlobalId, Immediate, InterpResult, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory,\n+    MemoryKind, Operand, Place, PlaceTy, Pointer, Provenance, Scalar, ScalarMaybeUninit,\n+    StackPopJump,\n };\n use crate::transform::validate::equal_up_to_regions;\n use crate::util::storage::AlwaysLiveLocals;\n@@ -80,7 +80,7 @@ impl Drop for SpanGuard {\n }\n \n /// A stack frame.\n-pub struct Frame<'mir, 'tcx, Tag = (), Extra = ()> {\n+pub struct Frame<'mir, 'tcx, Tag: Provenance = AllocId, Extra = ()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Function and callsite information\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -161,16 +161,16 @@ pub enum StackPopCleanup {\n \n /// State of a local variable including a memoized layout\n #[derive(Clone, PartialEq, Eq, HashStable)]\n-pub struct LocalState<'tcx, Tag = ()> {\n+pub struct LocalState<'tcx, Tag: Provenance = AllocId> {\n     pub value: LocalValue<Tag>,\n     /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n     #[stable_hasher(ignore)]\n     pub layout: Cell<Option<TyAndLayout<'tcx>>>,\n }\n \n /// Current value of a local variable\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, HashStable)] // Miri debug-prints these\n-pub enum LocalValue<Tag = ()> {\n+#[derive(Copy, Clone, PartialEq, Eq, HashStable, Debug)] // Miri debug-prints these\n+pub enum LocalValue<Tag: Provenance = AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,\n     /// This local is alive but not yet initialized. It can be written to\n@@ -186,7 +186,7 @@ pub enum LocalValue<Tag = ()> {\n     Live(Operand<Tag>),\n }\n \n-impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance + 'static> LocalState<'tcx, Tag> {\n     /// Read the local's value or error if the local is not yet live or not live anymore.\n     ///\n     /// Note: This may only be invoked from the `Machine::access_local` hook and not from\n@@ -220,7 +220,7 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     }\n }\n \n-impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n+impl<'mir, 'tcx, Tag: Provenance> Frame<'mir, 'tcx, Tag> {\n     pub fn with_extra<Extra>(self, extra: Extra) -> Frame<'mir, 'tcx, Tag, Extra> {\n         Frame {\n             body: self.body,\n@@ -235,7 +235,7 @@ impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n     }\n }\n \n-impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n+impl<'mir, 'tcx, Tag: Provenance, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n     /// Get the current location within the Frame.\n     ///\n     /// If this is `Err`, we are not currently executing any particular statement in\n@@ -406,20 +406,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     #[inline(always)]\n-    pub fn force_ptr(\n-        &self,\n-        scalar: Scalar<M::PointerTag>,\n-    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        self.memory.force_ptr(scalar)\n-    }\n-\n-    #[inline(always)]\n-    pub fn force_bits(\n-        &self,\n-        scalar: Scalar<M::PointerTag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx, u128> {\n-        self.memory.force_bits(scalar, size)\n+    pub fn scalar_to_ptr(&self, scalar: Scalar<M::PointerTag>) -> Pointer<Option<M::PointerTag>> {\n+        self.memory.scalar_to_ptr(scalar)\n     }\n \n     /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n@@ -650,7 +638,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Ok(Some((size, align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = metadata.unwrap_meta();\n+                let vtable = self.scalar_to_ptr(metadata.unwrap_meta());\n                 // Read size and align from vtable (already checks size).\n                 Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n             }\n@@ -897,9 +885,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn deallocate_local(&mut self, local: LocalValue<M::PointerTag>) -> InterpResult<'tcx> {\n         if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             // All locals have a backing allocation, even if the allocation is empty\n-            // due to the local having ZST type.\n-            let ptr = ptr.assert_ptr();\n-            trace!(\"deallocating local: {:?}\", self.memory.dump_alloc(ptr.alloc_id));\n+            // due to the local having ZST type. Hence we can `unwrap`.\n+            trace!(\n+                \"deallocating local {:?}: {:?}\",\n+                local,\n+                self.memory.dump_alloc(ptr.provenance.unwrap().get_alloc_id())\n+            );\n             self.memory.deallocate(ptr, None, MemoryKind::Stack)?;\n         };\n         Ok(())\n@@ -975,54 +966,53 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n                 match self.ecx.stack()[frame].locals[local].value {\n                     LocalValue::Dead => write!(fmt, \" is dead\")?,\n                     LocalValue::Uninitialized => write!(fmt, \" is uninitialized\")?,\n-                    LocalValue::Live(Operand::Indirect(mplace)) => match mplace.ptr {\n-                        Scalar::Ptr(ptr) => {\n-                            write!(\n-                                fmt,\n-                                \" by align({}){} ref:\",\n-                                mplace.align.bytes(),\n-                                match mplace.meta {\n-                                    MemPlaceMeta::Meta(meta) => format!(\" meta({:?})\", meta),\n-                                    MemPlaceMeta::Poison | MemPlaceMeta::None => String::new(),\n-                                }\n-                            )?;\n-                            allocs.push(ptr.alloc_id);\n-                        }\n-                        ptr => write!(fmt, \" by integral ref: {:?}\", ptr)?,\n-                    },\n+                    LocalValue::Live(Operand::Indirect(mplace)) => {\n+                        write!(\n+                            fmt,\n+                            \" by align({}){} ref {:?}:\",\n+                            mplace.align.bytes(),\n+                            match mplace.meta {\n+                                MemPlaceMeta::Meta(meta) => format!(\" meta({:?})\", meta),\n+                                MemPlaceMeta::Poison | MemPlaceMeta::None => String::new(),\n+                            },\n+                            mplace.ptr,\n+                        )?;\n+                        allocs.extend(mplace.ptr.provenance.map(Provenance::get_alloc_id));\n+                    }\n                     LocalValue::Live(Operand::Immediate(Immediate::Scalar(val))) => {\n                         write!(fmt, \" {:?}\", val)?;\n-                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val {\n-                            allocs.push(ptr.alloc_id);\n+                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val {\n+                            allocs.push(ptr.provenance.get_alloc_id());\n                         }\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::ScalarPair(val1, val2))) => {\n                         write!(fmt, \" ({:?}, {:?})\", val1, val2)?;\n-                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val1 {\n-                            allocs.push(ptr.alloc_id);\n+                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val1 {\n+                            allocs.push(ptr.provenance.get_alloc_id());\n                         }\n-                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val2 {\n-                            allocs.push(ptr.alloc_id);\n+                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val2 {\n+                            allocs.push(ptr.provenance.get_alloc_id());\n                         }\n                     }\n                 }\n \n                 write!(fmt, \": {:?}\", self.ecx.memory.dump_allocs(allocs))\n             }\n-            Place::Ptr(mplace) => match mplace.ptr {\n-                Scalar::Ptr(ptr) => write!(\n+            Place::Ptr(mplace) => match mplace.ptr.provenance.map(Provenance::get_alloc_id) {\n+                Some(alloc_id) => write!(\n                     fmt,\n-                    \"by align({}) ref: {:?}\",\n+                    \"by align({}) ref {:?}: {:?}\",\n                     mplace.align.bytes(),\n-                    self.ecx.memory.dump_alloc(ptr.alloc_id)\n+                    mplace.ptr,\n+                    self.ecx.memory.dump_alloc(alloc_id)\n                 ),\n                 ptr => write!(fmt, \" integral by ref: {:?}\", ptr),\n             },\n         }\n     }\n }\n \n-impl<'ctx, 'mir, 'tcx, Tag, Extra> HashStable<StableHashingContext<'ctx>>\n+impl<'ctx, 'mir, 'tcx, Tag: Provenance, Extra> HashStable<StableHashingContext<'ctx>>\n     for Frame<'mir, 'tcx, Tag, Extra>\n where\n     Extra: HashStable<StableHashingContext<'ctx>>,"}, {"sha": "f2457d11d9ee3cd4a19a603901813b7f02d88d7b", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -20,18 +20,17 @@ use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::InterpResult;\n use rustc_middle::ty::{self, layout::TyAndLayout, Ty};\n-use rustc_target::abi::Size;\n \n use rustc_ast::Mutability;\n \n-use super::{AllocId, Allocation, InterpCx, MPlaceTy, Machine, MemoryKind, Scalar, ValueVisitor};\n+use super::{AllocId, Allocation, InterpCx, MPlaceTy, Machine, MemoryKind, PlaceTy, ValueVisitor};\n use crate::const_eval;\n \n pub trait CompileTimeMachine<'mir, 'tcx, T> = Machine<\n     'mir,\n     'tcx,\n     MemoryKind = T,\n-    PointerTag = (),\n+    PointerTag = AllocId,\n     ExtraFnVal = !,\n     FrameExtra = (),\n     AllocExtra = (),\n@@ -136,7 +135,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n     };\n     // link the alloc id to the actual allocation\n     let alloc = tcx.intern_const_alloc(alloc);\n-    leftover_allocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n+    leftover_allocations.extend(alloc.relocations().iter().map(|&(_, alloc_id)| alloc_id));\n     tcx.set_alloc_id_memory(alloc_id, alloc);\n     None\n }\n@@ -203,10 +202,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n             if let ty::Dynamic(..) =\n                 tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind()\n             {\n-                if let Scalar::Ptr(vtable) = mplace.meta.unwrap_meta() {\n+                let ptr = self.ecx.scalar_to_ptr(mplace.meta.unwrap_meta());\n+                if let Some(alloc_id) = ptr.provenance {\n                     // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n-                    self.intern_shallow(vtable.alloc_id, InternMode::Const, None);\n+                    self.intern_shallow(alloc_id, InternMode::Const, None);\n                 } else {\n                     // Validation will error (with a better message) on an invalid vtable pointer.\n                     // Let validation show the error message, but make sure it *does* error.\n@@ -216,7 +216,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n             }\n             // Check if we have encountered this pointer+layout combination before.\n             // Only recurse for allocation-backed pointers.\n-            if let Scalar::Ptr(ptr) = mplace.ptr {\n+            if let Some(alloc_id) = mplace.ptr.provenance {\n                 // Compute the mode with which we intern this. Our goal here is to make as many\n                 // statics as we can immutable so they can be placed in read-only memory by LLVM.\n                 let ref_mode = match self.mode {\n@@ -259,7 +259,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n                         InternMode::Const\n                     }\n                 };\n-                match self.intern_shallow(ptr.alloc_id, ref_mode, Some(referenced_ty)) {\n+                match self.intern_shallow(alloc_id, ref_mode, Some(referenced_ty)) {\n                     // No need to recurse, these are interned already and statics may have\n                     // cycles, so we don't want to recurse there\n                     Some(IsStaticOrFn) => {}\n@@ -321,7 +321,7 @@ where\n         leftover_allocations,\n         // The outermost allocation must exist, because we allocated it with\n         // `Memory::allocate`.\n-        ret.ptr.assert_ptr().alloc_id,\n+        ret.ptr.provenance.unwrap(),\n         base_intern_mode,\n         Some(ret.layout.ty),\n     );\n@@ -395,9 +395,9 @@ where\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.set_alloc_id_memory(alloc_id, alloc);\n-            for &(_, ((), reloc)) in alloc.relocations().iter() {\n-                if leftover_allocations.insert(reloc) {\n-                    todo.push(reloc);\n+            for &(_, alloc_id) in alloc.relocations().iter() {\n+                if leftover_allocations.insert(alloc_id) {\n+                    todo.push(alloc_id);\n                 }\n             }\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n@@ -425,14 +425,12 @@ impl<'mir, 'tcx: 'mir, M: super::intern::CompileTimeMachine<'mir, 'tcx, !>>\n         layout: TyAndLayout<'tcx>,\n         f: impl FnOnce(\n             &mut InterpCx<'mir, 'tcx, M>,\n-            &MPlaceTy<'tcx, M::PointerTag>,\n+            &PlaceTy<'tcx, M::PointerTag>,\n         ) -> InterpResult<'tcx, ()>,\n     ) -> InterpResult<'tcx, &'tcx Allocation> {\n         let dest = self.allocate(layout, MemoryKind::Stack)?;\n-        f(self, &dest)?;\n-        let ptr = dest.ptr.assert_ptr();\n-        assert_eq!(ptr.offset, Size::ZERO);\n-        let mut alloc = self.memory.alloc_map.remove(&ptr.alloc_id).unwrap().1;\n+        f(self, &dest.into())?;\n+        let mut alloc = self.memory.alloc_map.remove(&dest.ptr.provenance.unwrap()).unwrap().1;\n         alloc.mutability = Mutability::Not;\n         Ok(self.tcx.intern_const_alloc(alloc))\n     }"}, {"sha": "dc1f9053b61f028fe968a3c1b31928e657a61481", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -18,6 +18,7 @@ use rustc_target::abi::{Abi, Align, LayoutOf as _, Primitive, Size};\n \n use super::{\n     util::ensure_monomorphic_enough, CheckInAllocMsg, ImmTy, InterpCx, Machine, OpTy, PlaceTy,\n+    Pointer,\n };\n \n mod caller_location;\n@@ -138,7 +139,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::caller_location => {\n                 let span = self.find_closest_untracked_caller_location();\n                 let location = self.alloc_caller_location_for_span(span);\n-                self.write_scalar(location.ptr, dest)?;\n+                self.write_immediate(location.to_ref(self), dest)?;\n             }\n \n             sym::min_align_of_val | sym::size_of_val => {\n@@ -190,7 +191,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let ty = substs.type_at(0);\n                 let layout_of = self.layout_of(ty)?;\n                 let val = self.read_scalar(&args[0])?.check_init()?;\n-                let bits = self.force_bits(val, layout_of.size)?;\n+                let bits = val.to_bits(layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     Abi::Scalar(ref scalar) => scalar.value,\n                     _ => span_bug!(\n@@ -238,7 +239,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         // term since the sign of the second term can be inferred from this and\n                         // the fact that the operation has overflowed (if either is 0 no\n                         // overflow can occur)\n-                        let first_term: u128 = self.force_bits(l.to_scalar()?, l.layout.size)?;\n+                        let first_term: u128 = l.to_scalar()?.to_bits(l.layout.size)?;\n                         let first_term_positive = first_term & (1 << (num_bits - 1)) == 0;\n                         if first_term_positive {\n                             // Negative overflow not possible since the positive first term\n@@ -298,7 +299,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, &l, &r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n-                    let r_val = self.force_bits(r.to_scalar()?, layout.size)?;\n+                    let r_val = r.to_scalar()?.to_bits(layout.size)?;\n                     if let sym::unchecked_shl | sym::unchecked_shr = intrinsic_name {\n                         throw_ub_format!(\"overflowing shift by {} in `{}`\", r_val, intrinsic_name);\n                     } else {\n@@ -312,9 +313,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n                 let layout = self.layout_of(substs.type_at(0))?;\n                 let val = self.read_scalar(&args[0])?.check_init()?;\n-                let val_bits = self.force_bits(val, layout.size)?;\n+                let val_bits = val.to_bits(layout.size)?;\n                 let raw_shift = self.read_scalar(&args[1])?.check_init()?;\n-                let raw_shift_bits = self.force_bits(raw_shift, layout.size)?;\n+                let raw_shift_bits = raw_shift.to_bits(layout.size)?;\n                 let width_bits = u128::from(layout.size.bits());\n                 let shift_bits = raw_shift_bits % width_bits;\n                 let inv_shift_bits = (width_bits - shift_bits) % width_bits;\n@@ -331,22 +332,22 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.copy_intrinsic(&args[0], &args[1], &args[2], /*nonoverlapping*/ false)?;\n             }\n             sym::offset => {\n-                let ptr = self.read_scalar(&args[0])?.check_init()?;\n+                let ptr = self.read_pointer(&args[0])?;\n                 let offset_count = self.read_scalar(&args[1])?.to_machine_isize(self)?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n-                self.write_scalar(offset_ptr, dest)?;\n+                self.write_pointer(offset_ptr, dest)?;\n             }\n             sym::arith_offset => {\n-                let ptr = self.read_scalar(&args[0])?.check_init()?;\n+                let ptr = self.read_pointer(&args[0])?;\n                 let offset_count = self.read_scalar(&args[1])?.to_machine_isize(self)?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n                 let offset_bytes = offset_count.wrapping_mul(pointee_size);\n-                let offset_ptr = ptr.ptr_wrapping_signed_offset(offset_bytes, self);\n-                self.write_scalar(offset_ptr, dest)?;\n+                let offset_ptr = ptr.wrapping_signed_offset(offset_bytes, self);\n+                self.write_pointer(offset_ptr, dest)?;\n             }\n             sym::ptr_offset_from => {\n                 let a = self.read_immediate(&args[0])?.to_scalar()?;\n@@ -361,9 +362,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 //\n                 // Control flow is weird because we cannot early-return (to reach the\n                 // `go_to_block` at the end).\n-                let done = if a.is_bits() && b.is_bits() {\n-                    let a = a.to_machine_usize(self)?;\n-                    let b = b.to_machine_usize(self)?;\n+                let done = if let (Ok(a), Ok(b)) = (a.try_to_int(), b.try_to_int()) {\n+                    let a = a.try_to_machine_usize(*self.tcx).unwrap();\n+                    let b = b.try_to_machine_usize(*self.tcx).unwrap();\n                     if a == b && a != 0 {\n                         self.write_scalar(Scalar::from_machine_isize(0, self), dest)?;\n                         true\n@@ -376,18 +377,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 if !done {\n                     // General case: we need two pointers.\n-                    let a = self.force_ptr(a)?;\n-                    let b = self.force_ptr(b)?;\n-                    if a.alloc_id != b.alloc_id {\n+                    let a = self.scalar_to_ptr(a);\n+                    let b = self.scalar_to_ptr(b);\n+                    let (a_alloc_id, a_offset, _) = self.memory.ptr_get_alloc(a)?;\n+                    let (b_alloc_id, b_offset, _) = self.memory.ptr_get_alloc(b)?;\n+                    if a_alloc_id != b_alloc_id {\n                         throw_ub_format!(\n                             \"ptr_offset_from cannot compute offset of pointers into different \\\n                             allocations.\",\n                         );\n                     }\n                     let usize_layout = self.layout_of(self.tcx.types.usize)?;\n                     let isize_layout = self.layout_of(self.tcx.types.isize)?;\n-                    let a_offset = ImmTy::from_uint(a.offset.bytes(), usize_layout);\n-                    let b_offset = ImmTy::from_uint(b.offset.bytes(), usize_layout);\n+                    let a_offset = ImmTy::from_uint(a_offset.bytes(), usize_layout);\n+                    let b_offset = ImmTy::from_uint(b_offset.bytes(), usize_layout);\n                     let (val, _overflowed, _ty) =\n                         self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?;\n                     let pointee_layout = self.layout_of(substs.type_at(0))?;\n@@ -513,18 +516,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// 0, so offset-by-0 (and only 0) is okay -- except that null cannot be offset by _any_ value.\n     pub fn ptr_offset_inbounds(\n         &self,\n-        ptr: Scalar<M::PointerTag>,\n+        ptr: Pointer<Option<M::PointerTag>>,\n         pointee_ty: Ty<'tcx>,\n         offset_count: i64,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n         // We cannot overflow i64 as a type's size must be <= isize::MAX.\n         let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n         // The computed offset, in bytes, cannot overflow an isize.\n         let offset_bytes =\n             offset_count.checked_mul(pointee_size).ok_or(err_ub!(PointerArithOverflow))?;\n         // The offset being in bounds cannot rely on \"wrapping around\" the address space.\n         // So, first rule out overflows in the pointer arithmetic.\n-        let offset_ptr = ptr.ptr_signed_offset(offset_bytes, self)?;\n+        let offset_ptr = ptr.signed_offset(offset_bytes, self)?;\n         // ptr and offset_ptr must be in bounds of the same allocated object. This means all of the\n         // memory between these pointers must be accessible. Note that we do not require the\n         // pointers to be properly aligned (unlike a read/write operation).\n@@ -558,8 +561,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             )\n         })?;\n \n-        let src = self.read_scalar(&src)?.check_init()?;\n-        let dst = self.read_scalar(&dst)?.check_init()?;\n+        let src = self.read_pointer(&src)?;\n+        let dst = self.read_pointer(&dst)?;\n \n         self.memory.copy(src, align, dst, align, size, nonoverlapping)\n     }\n@@ -572,8 +575,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let layout = self.layout_of(lhs.layout.ty.builtin_deref(true).unwrap().ty)?;\n         assert!(!layout.is_unsized());\n \n-        let lhs = self.read_scalar(lhs)?.check_init()?;\n-        let rhs = self.read_scalar(rhs)?.check_init()?;\n+        let lhs = self.read_pointer(lhs)?;\n+        let rhs = self.read_pointer(rhs)?;\n         let lhs_bytes = self.memory.read_bytes(lhs, layout.size)?;\n         let rhs_bytes = self.memory.read_bytes(rhs, layout.size)?;\n         Ok(Scalar::from_bool(lhs_bytes == rhs_bytes))"}, {"sha": "022129b2a22046a04806c4dbb893cbd4555aa5a1", "filename": "compiler/rustc_mir/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -96,7 +96,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation).unwrap();\n \n         // Initialize fields.\n-        self.write_immediate(file.to_ref(), &self.mplace_field(&location, 0).unwrap().into())\n+        self.write_immediate(file.to_ref(self), &self.mplace_field(&location, 0).unwrap().into())\n             .expect(\"writing to memory we just allocated cannot fail\");\n         self.write_scalar(line, &self.mplace_field(&location, 1).unwrap().into())\n             .expect(\"writing to memory we just allocated cannot fail\");"}, {"sha": "323e102b8723b904e8deadc005f055d421b139ec", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 65, "deletions": 71, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -13,8 +13,8 @@ use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n use super::{\n-    AllocId, Allocation, CheckInAllocMsg, Frame, ImmTy, InterpCx, InterpResult, LocalValue,\n-    MemPlace, Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Scalar, StackPopUnwind,\n+    AllocId, AllocRange, Allocation, Frame, ImmTy, InterpCx, InterpResult, LocalValue, MemPlace,\n+    Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -84,12 +84,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     type MemoryKind: Debug + std::fmt::Display + MayLeak + Eq + 'static;\n \n-    /// Tag tracked alongside every pointer. This is used to implement \"Stacked Borrows\"\n-    /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>.\n-    /// The `default()` is used for pointers to consts, statics, vtables and functions.\n-    /// The `Debug` formatting is used for displaying pointers; we cannot use `Display`\n-    /// as `()` does not implement that, but it should be \"nice\" output.\n-    type PointerTag: Debug + Copy + Eq + Hash + 'static;\n+    /// Pointers are \"tagged\" with provenance information; typically the `AllocId` they belong to.\n+    type PointerTag: Provenance + Eq + Hash + 'static;\n \n     /// Machines can define extra (non-instance) things that represent values of function pointers.\n     /// For example, Miri uses this to return a function pointer from `dlsym`\n@@ -266,28 +262,39 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     }\n \n     /// Return the `AllocId` for the given thread-local static in the current thread.\n-    fn thread_local_static_alloc_id(\n+    fn thread_local_static_base_pointer(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         def_id: DefId,\n-    ) -> InterpResult<'tcx, AllocId> {\n+    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n         throw_unsup!(ThreadLocalStatic(def_id))\n     }\n \n-    /// Return the `AllocId` backing the given `extern static`.\n-    fn extern_static_alloc_id(\n+    /// Return the root pointer for the given `extern static`.\n+    fn extern_static_base_pointer(\n         mem: &Memory<'mir, 'tcx, Self>,\n         def_id: DefId,\n-    ) -> InterpResult<'tcx, AllocId> {\n-        // Use the `AllocId` associated with the `DefId`. Any actual *access* will fail.\n-        Ok(mem.tcx.create_static_alloc(def_id))\n-    }\n+    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>>;\n \n-    /// Return the \"base\" tag for the given *global* allocation: the one that is used for direct\n-    /// accesses to this static/const/fn allocation. If `id` is not a global allocation,\n-    /// this will return an unusable tag (i.e., accesses will be UB)!\n+    /// Return a \"base\" pointer for the given allocation: the one that is used for direct\n+    /// accesses to this static/const/fn allocation, or the one returned from the heap allocator.\n     ///\n-    /// Called on the id returned by `thread_local_static_alloc_id` and `extern_static_alloc_id`, if needed.\n-    fn tag_global_base_pointer(memory_extra: &Self::MemoryExtra, id: AllocId) -> Self::PointerTag;\n+    /// Not called on `extern` or thread-local statics (those use the methods above).\n+    fn tag_alloc_base_pointer(\n+        mem: &Memory<'mir, 'tcx, Self>,\n+        ptr: Pointer,\n+    ) -> Pointer<Self::PointerTag>;\n+\n+    /// \"Int-to-pointer cast\"\n+    fn ptr_from_addr(\n+        mem: &Memory<'mir, 'tcx, Self>,\n+        addr: u64,\n+    ) -> Pointer<Option<Self::PointerTag>>;\n+\n+    /// Convert a pointer with provenance into an allocation-offset pair.\n+    fn ptr_get_alloc(\n+        mem: &Memory<'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::PointerTag>,\n+    ) -> (AllocId, Size);\n \n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n@@ -302,16 +309,12 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n-    ///\n-    /// Also return the \"base\" tag to use for this allocation: the one that is used for direct\n-    /// accesses to this allocation. If `kind == STATIC_KIND`, this tag must be consistent\n-    /// with `tag_global_base_pointer`.\n     fn init_allocation_extra<'b>(\n-        memory_extra: &Self::MemoryExtra,\n+        mem: &Memory<'mir, 'tcx, Self>,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag);\n+    ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>;\n \n     /// Hook for performing extra checks on a memory read access.\n     ///\n@@ -322,8 +325,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn memory_read(\n         _memory_extra: &Self::MemoryExtra,\n         _alloc_extra: &Self::AllocExtra,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _size: Size,\n+        _tag: Self::PointerTag,\n+        _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n@@ -333,8 +336,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn memory_written(\n         _memory_extra: &mut Self::MemoryExtra,\n         _alloc_extra: &mut Self::AllocExtra,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _size: Size,\n+        _tag: Self::PointerTag,\n+        _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n@@ -344,17 +347,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn memory_deallocated(\n         _memory_extra: &mut Self::MemoryExtra,\n         _alloc_extra: &mut Self::AllocExtra,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _size: Size,\n-    ) -> InterpResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    /// Called after initializing static memory using the interpreter.\n-    fn after_static_mem_initialized(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _size: Size,\n+        _tag: Self::PointerTag,\n+        _range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n@@ -399,32 +393,12 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         // By default, we do not support unwinding from panics\n         Ok(StackPopJump::Normal)\n     }\n-\n-    fn int_to_ptr(\n-        _mem: &Memory<'mir, 'tcx, Self>,\n-        int: u64,\n-    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n-        Err((if int == 0 {\n-            // This is UB, seriously.\n-            // (`DanglingIntPointer` with these exact arguments has special printing code.)\n-            err_ub!(DanglingIntPointer(0, CheckInAllocMsg::InboundsTest))\n-        } else {\n-            // This is just something we cannot support during const-eval.\n-            err_unsup!(ReadBytesAsPointer)\n-        })\n-        .into())\n-    }\n-\n-    fn ptr_to_int(\n-        _mem: &Memory<'mir, 'tcx, Self>,\n-        _ptr: Pointer<Self::PointerTag>,\n-    ) -> InterpResult<'tcx, u64>;\n }\n \n // A lot of the flexibility above is just needed for `Miri`, but all \"compile-time\" machines\n // (CTFE and ConstProp) use the same instance.  Here, we share that code.\n pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n-    type PointerTag = ();\n+    type PointerTag = AllocId;\n     type ExtraFnVal = !;\n \n     type MemoryMap =\n@@ -466,20 +440,40 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n \n     #[inline(always)]\n     fn init_allocation_extra<'b>(\n-        _memory_extra: &Self::MemoryExtra,\n+        _mem: &Memory<$mir, $tcx, Self>,\n         _id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         _kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n+    ) -> Cow<'b, Allocation<Self::PointerTag>> {\n         // We do not use a tag so we can just cheaply forward the allocation\n-        (alloc, ())\n+        alloc\n+    }\n+\n+    fn extern_static_base_pointer(\n+        mem: &Memory<$mir, $tcx, Self>,\n+        def_id: DefId,\n+    ) -> InterpResult<$tcx, Pointer> {\n+        // Use the `AllocId` associated with the `DefId`. Any actual *access* will fail.\n+        Ok(Pointer::new(mem.tcx.create_static_alloc(def_id), Size::ZERO))\n     }\n \n     #[inline(always)]\n-    fn tag_global_base_pointer(\n-        _memory_extra: &Self::MemoryExtra,\n-        _id: AllocId,\n-    ) -> Self::PointerTag {\n-        ()\n+    fn tag_alloc_base_pointer(\n+        _mem: &Memory<$mir, $tcx, Self>,\n+        ptr: Pointer<AllocId>,\n+    ) -> Pointer<AllocId> {\n+        ptr\n+    }\n+\n+    #[inline(always)]\n+    fn ptr_from_addr(_mem: &Memory<$mir, $tcx, Self>, addr: u64) -> Pointer<Option<AllocId>> {\n+        Pointer::new(None, Size::from_bytes(addr))\n+    }\n+\n+    #[inline(always)]\n+    fn ptr_get_alloc(_mem: &Memory<$mir, $tcx, Self>, ptr: Pointer<AllocId>) -> (AllocId, Size) {\n+        // We know `offset` is relative to the allocation, so we can use `into_parts`.\n+        let (alloc_id, offset) = ptr.into_parts();\n+        (alloc_id, offset)\n     }\n }"}, {"sha": "d145ad734cf7aeb011252a31e2903cdfcad16048", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 222, "deletions": 190, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -9,7 +9,7 @@\n use std::assert_matches::assert_matches;\n use std::borrow::Cow;\n use std::collections::VecDeque;\n-use std::convert::{TryFrom, TryInto};\n+use std::convert::TryFrom;\n use std::fmt;\n use std::ptr;\n \n@@ -20,7 +20,8 @@ use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n     alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc,\n-    InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Scalar, ScalarMaybeUninit,\n+    InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance, Scalar,\n+    ScalarMaybeUninit,\n };\n use crate::util::pretty;\n \n@@ -163,25 +164,22 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     #[inline]\n     pub fn global_base_pointer(\n         &self,\n-        mut ptr: Pointer,\n+        ptr: Pointer<AllocId>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+        // We know `offset` is relative to the allocation, so we can use `into_parts`.\n+        let (alloc_id, offset) = ptr.into_parts();\n         // We need to handle `extern static`.\n-        let ptr = match self.tcx.get_global_alloc(ptr.alloc_id) {\n+        match self.tcx.get_global_alloc(alloc_id) {\n             Some(GlobalAlloc::Static(def_id)) if self.tcx.is_thread_local_static(def_id) => {\n                 bug!(\"global memory cannot point to thread-local static\")\n             }\n             Some(GlobalAlloc::Static(def_id)) if self.tcx.is_foreign_item(def_id) => {\n-                ptr.alloc_id = M::extern_static_alloc_id(self, def_id)?;\n-                ptr\n-            }\n-            _ => {\n-                // No need to change the `AllocId`.\n-                ptr\n+                return M::extern_static_base_pointer(self, def_id);\n             }\n-        };\n+            _ => {}\n+        }\n         // And we need to get the tag.\n-        let tag = M::tag_global_base_pointer(&self.extra, ptr.alloc_id);\n-        Ok(ptr.with_tag(tag))\n+        Ok(M::tag_alloc_base_pointer(self, Pointer::new(alloc_id, offset)))\n     }\n \n     pub fn create_fn_alloc(\n@@ -235,21 +233,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n             \"dynamically allocating global memory\"\n         );\n-        // This is a new allocation, not a new global one, so no `global_base_ptr`.\n-        let (alloc, tag) = M::init_allocation_extra(&self.extra, id, Cow::Owned(alloc), Some(kind));\n+        let alloc = M::init_allocation_extra(self, id, Cow::Owned(alloc), Some(kind));\n         self.alloc_map.insert(id, (kind, alloc.into_owned()));\n-        Pointer::from(id).with_tag(tag)\n+        M::tag_alloc_base_pointer(self, Pointer::from(id))\n     }\n \n     pub fn reallocate(\n         &mut self,\n-        ptr: Pointer<M::PointerTag>,\n+        ptr: Pointer<Option<M::PointerTag>>,\n         old_size_and_align: Option<(Size, Align)>,\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        if ptr.offset.bytes() != 0 {\n+        let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n+        if offset.bytes() != 0 {\n             throw_ub_format!(\n                 \"reallocating {:?} which does not point to the beginning of an object\",\n                 ptr\n@@ -261,7 +259,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let new_ptr = self.allocate(new_size, new_align, kind)?;\n         let old_size = match old_size_and_align {\n             Some((size, _align)) => size,\n-            None => self.get_raw(ptr.alloc_id)?.size(),\n+            None => self.get_raw(alloc_id)?.size(),\n         };\n         // This will also call the access hooks.\n         self.copy(\n@@ -272,50 +270,51 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,\n         )?;\n-        self.deallocate(ptr, old_size_and_align, kind)?;\n+        self.deallocate(ptr.into(), old_size_and_align, kind)?;\n \n         Ok(new_ptr)\n     }\n \n     pub fn deallocate(\n         &mut self,\n-        ptr: Pointer<M::PointerTag>,\n+        ptr: Pointer<Option<M::PointerTag>>,\n         old_size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"deallocating: {}\", ptr.alloc_id);\n+        let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n+        trace!(\"deallocating: {}\", alloc_id);\n \n-        if ptr.offset.bytes() != 0 {\n+        if offset.bytes() != 0 {\n             throw_ub_format!(\n                 \"deallocating {:?} which does not point to the beginning of an object\",\n                 ptr\n             );\n         }\n \n-        let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n+        let (alloc_kind, mut alloc) = match self.alloc_map.remove(&alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating global memory -- always an error\n-                return Err(match self.tcx.get_global_alloc(ptr.alloc_id) {\n+                return Err(match self.tcx.get_global_alloc(alloc_id) {\n                     Some(GlobalAlloc::Function(..)) => {\n-                        err_ub_format!(\"deallocating {}, which is a function\", ptr.alloc_id)\n+                        err_ub_format!(\"deallocating {}, which is a function\", alloc_id)\n                     }\n                     Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n-                        err_ub_format!(\"deallocating {}, which is static memory\", ptr.alloc_id)\n+                        err_ub_format!(\"deallocating {}, which is static memory\", alloc_id)\n                     }\n-                    None => err_ub!(PointerUseAfterFree(ptr.alloc_id)),\n+                    None => err_ub!(PointerUseAfterFree(alloc_id)),\n                 }\n                 .into());\n             }\n         };\n \n         if alloc.mutability == Mutability::Not {\n-            throw_ub_format!(\"deallocating immutable allocation {}\", ptr.alloc_id);\n+            throw_ub_format!(\"deallocating immutable allocation {}\", alloc_id);\n         }\n         if alloc_kind != kind {\n             throw_ub_format!(\n                 \"deallocating {}, which is {} memory, using {} deallocation operation\",\n-                ptr.alloc_id,\n+                alloc_id,\n                 alloc_kind,\n                 kind\n             );\n@@ -324,7 +323,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             if size != alloc.size() || align != alloc.align {\n                 throw_ub_format!(\n                     \"incorrect layout on deallocation: {} has size {} and alignment {}, but gave size {} and alignment {}\",\n-                    ptr.alloc_id,\n+                    alloc_id,\n                     alloc.size().bytes(),\n                     alloc.align.bytes(),\n                     size.bytes(),\n@@ -335,63 +334,85 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         // Let the machine take some extra action\n         let size = alloc.size();\n-        M::memory_deallocated(&mut self.extra, &mut alloc.extra, ptr, size)?;\n+        M::memory_deallocated(\n+            &mut self.extra,\n+            &mut alloc.extra,\n+            ptr.provenance,\n+            alloc_range(Size::ZERO, size),\n+        )?;\n \n         // Don't forget to remember size and align of this now-dead allocation\n-        let old = self.dead_alloc_map.insert(ptr.alloc_id, (size, alloc.align));\n+        let old = self.dead_alloc_map.insert(alloc_id, (size, alloc.align));\n         if old.is_some() {\n             bug!(\"Nothing can be deallocated twice\");\n         }\n \n         Ok(())\n     }\n \n-    /// Internal helper function for APIs that offer memory access based on `Scalar` pointers.\n+    /// Internal helper function to determine the allocation and offset of a pointer (if any).\n     #[inline(always)]\n-    pub(super) fn check_ptr_access(\n+    fn get_ptr_access(\n         &self,\n-        sptr: Scalar<M::PointerTag>,\n+        ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n         align: Align,\n-    ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Option<(AllocId, Size, Pointer<M::PointerTag>)>> {\n         let align = M::enforce_alignment(&self.extra).then_some(align);\n-        self.check_and_deref_ptr(sptr, size, align, CheckInAllocMsg::MemoryAccessTest, |ptr| {\n-            let (size, align) =\n-                self.get_size_and_align(ptr.alloc_id, AllocCheck::Dereferenceable)?;\n-            Ok((size, align, ptr))\n-        })\n+        self.check_and_deref_ptr(\n+            ptr,\n+            size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+            |alloc_id, offset, ptr| {\n+                let (size, align) =\n+                    self.get_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n+                Ok((size, align, (alloc_id, offset, ptr)))\n+            },\n+        )\n     }\n \n-    /// Check if the given scalar is allowed to do a memory access of given `size` and `align`\n+    /// Check if the given pointerpoints to live memory of given `size` and `align`\n     /// (ignoring `M::enforce_alignment`). The caller can control the error message for the\n     /// out-of-bounds case.\n     #[inline(always)]\n     pub fn check_ptr_access_align(\n         &self,\n-        sptr: Scalar<M::PointerTag>,\n+        ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n         align: Align,\n         msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx> {\n-        self.check_and_deref_ptr(sptr, size, Some(align), msg, |ptr| {\n-            let (size, align) =\n-                self.get_size_and_align(ptr.alloc_id, AllocCheck::Dereferenceable)?;\n+        self.check_and_deref_ptr(ptr, size, Some(align), msg, |alloc_id, _, _| {\n+            let check = match msg {\n+                CheckInAllocMsg::DerefTest | CheckInAllocMsg::MemoryAccessTest => {\n+                    AllocCheck::Dereferenceable\n+                }\n+                CheckInAllocMsg::PointerArithmeticTest | CheckInAllocMsg::InboundsTest => {\n+                    AllocCheck::Live\n+                }\n+            };\n+            let (size, align) = self.get_size_and_align(alloc_id, check)?;\n             Ok((size, align, ()))\n         })?;\n         Ok(())\n     }\n \n     /// Low-level helper function to check if a ptr is in-bounds and potentially return a reference\n-    /// to the allocation it points to. Supports both shared and mutable references, to the actual\n+    /// to the allocation it points to. Supports both shared and mutable references, as the actual\n     /// checking is offloaded to a helper closure. `align` defines whether and which alignment check\n     /// is done. Returns `None` for size 0, and otherwise `Some` of what `alloc_size` returned.\n     fn check_and_deref_ptr<T>(\n         &self,\n-        sptr: Scalar<M::PointerTag>,\n+        ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n         align: Option<Align>,\n         msg: CheckInAllocMsg,\n-        alloc_size: impl FnOnce(Pointer<M::PointerTag>) -> InterpResult<'tcx, (Size, Align, T)>,\n+        alloc_size: impl FnOnce(\n+            AllocId,\n+            Size,\n+            Pointer<M::PointerTag>,\n+        ) -> InterpResult<'tcx, (Size, Align, T)>,\n     ) -> InterpResult<'tcx, Option<T>> {\n         fn check_offset_align(offset: u64, align: Align) -> InterpResult<'static> {\n             if offset % align.bytes() == 0 {\n@@ -406,53 +427,50 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n         }\n \n-        // Normalize to a `Pointer` if we definitely need one.\n-        let normalized = if size.bytes() == 0 {\n-            // Can be an integer, just take what we got.  We do NOT `force_bits` here;\n-            // if this is already a `Pointer` we want to do the bounds checks!\n-            sptr\n+        // Extract from the pointer an `Option<AllocId>` and an offset, which is relative to the\n+        // allocation or (if that is `None`) an absolute address.\n+        let ptr_or_addr = if size.bytes() == 0 {\n+            // Let's see what we can do, but don't throw errors if there's nothing there.\n+            self.ptr_try_get_alloc(ptr)\n         } else {\n-            // A \"real\" access, we must get a pointer to be able to check the bounds.\n-            Scalar::from(self.force_ptr(sptr)?)\n+            // A \"real\" access, we insist on getting an `AllocId`.\n+            Ok(self.ptr_get_alloc(ptr)?)\n         };\n-        Ok(match normalized.to_bits_or_ptr(self.pointer_size(), self) {\n-            Ok(bits) => {\n-                let bits = u64::try_from(bits).unwrap(); // it's ptr-sized\n-                assert!(size.bytes() == 0);\n+        Ok(match ptr_or_addr {\n+            Err(addr) => {\n+                // No memory is actually being accessed.\n+                debug_assert!(size.bytes() == 0);\n                 // Must be non-null.\n-                if bits == 0 {\n+                if addr == 0 {\n                     throw_ub!(DanglingIntPointer(0, msg))\n                 }\n                 // Must be aligned.\n                 if let Some(align) = align {\n-                    check_offset_align(bits, align)?;\n+                    check_offset_align(addr, align)?;\n                 }\n                 None\n             }\n-            Err(ptr) => {\n-                let (allocation_size, alloc_align, ret_val) = alloc_size(ptr)?;\n+            Ok((alloc_id, offset, ptr)) => {\n+                let (allocation_size, alloc_align, ret_val) = alloc_size(alloc_id, offset, ptr)?;\n                 // Test bounds. This also ensures non-null.\n-                // It is sufficient to check this for the end pointer. The addition\n-                // checks for overflow.\n-                let end_ptr = ptr.offset(size, self)?;\n-                if end_ptr.offset > allocation_size {\n-                    // equal is okay!\n-                    throw_ub!(PointerOutOfBounds { ptr: end_ptr.erase_tag(), msg, allocation_size })\n+                // It is sufficient to check this for the end pointer. Also check for overflow!\n+                if offset.checked_add(size, &self.tcx).map_or(true, |end| end > allocation_size) {\n+                    throw_ub!(PointerOutOfBounds { alloc_id, offset, size, allocation_size, msg })\n                 }\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n                     if M::force_int_for_alignment_check(&self.extra) {\n-                        let bits = self\n-                            .force_bits(ptr.into(), self.pointer_size())\n+                        let addr = Scalar::from_pointer(ptr, &self.tcx)\n+                            .to_machine_usize(&self.tcx)\n                             .expect(\"ptr-to-int cast for align check should never fail\");\n-                        check_offset_align(bits.try_into().unwrap(), align)?;\n+                        check_offset_align(addr, align)?;\n                     } else {\n                         // Check allocation alignment and offset alignment.\n                         if alloc_align.bytes() < align.bytes() {\n                             throw_ub!(AlignmentCheckFailed { has: alloc_align, required: align });\n                         }\n-                        check_offset_align(ptr.offset.bytes(), align)?;\n+                        check_offset_align(offset.bytes(), align)?;\n                     }\n                 }\n \n@@ -464,13 +482,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     /// Test if the pointer might be null.\n-    pub fn ptr_may_be_null(&self, ptr: Pointer<M::PointerTag>) -> bool {\n-        let (size, _align) = self\n-            .get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)\n-            .expect(\"alloc info with MaybeDead cannot fail\");\n-        // If the pointer is out-of-bounds, it may be null.\n-        // Note that one-past-the-end (offset == size) is still inbounds, and never null.\n-        ptr.offset > size\n+    pub fn ptr_may_be_null(&self, ptr: Pointer<Option<M::PointerTag>>) -> bool {\n+        match self.ptr_try_get_alloc(ptr) {\n+            Ok((alloc_id, offset, _)) => {\n+                let (size, _align) = self\n+                    .get_size_and_align(alloc_id, AllocCheck::MaybeDead)\n+                    .expect(\"alloc info with MaybeDead cannot fail\");\n+                // If the pointer is out-of-bounds, it may be null.\n+                // Note that one-past-the-end (offset == size) is still inbounds, and never null.\n+                offset > size\n+            }\n+            Err(offset) => offset == 0,\n+        }\n     }\n }\n \n@@ -482,21 +505,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// this machine use the same pointer tag, so it is indirected through\n     /// `M::tag_allocation`.\n     fn get_global_alloc(\n-        memory_extra: &M::MemoryExtra,\n-        tcx: TyCtxt<'tcx>,\n+        &self,\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n-        let (alloc, def_id) = match tcx.get_global_alloc(id) {\n+        let (alloc, def_id) = match self.tcx.get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n                 (mem, None)\n             }\n             Some(GlobalAlloc::Function(..)) => throw_ub!(DerefFunctionPointer(id)),\n             None => throw_ub!(PointerUseAfterFree(id)),\n             Some(GlobalAlloc::Static(def_id)) => {\n-                assert!(tcx.is_static(def_id));\n-                assert!(!tcx.is_thread_local_static(def_id));\n+                assert!(self.tcx.is_static(def_id));\n+                assert!(!self.tcx.is_thread_local_static(def_id));\n                 // Notice that every static has two `AllocId` that will resolve to the same\n                 // thing here: one maps to `GlobalAlloc::Static`, this is the \"lazy\" ID,\n                 // and the other one is maps to `GlobalAlloc::Memory`, this is returned by\n@@ -507,24 +529,22 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n                 // contains a reference to memory that was created during its evaluation (i.e., not\n                 // to another static), those inner references only exist in \"resolved\" form.\n-                if tcx.is_foreign_item(def_id) {\n+                if self.tcx.is_foreign_item(def_id) {\n                     throw_unsup!(ReadExternStatic(def_id));\n                 }\n \n-                (tcx.eval_static_initializer(def_id)?, Some(def_id))\n+                (self.tcx.eval_static_initializer(def_id)?, Some(def_id))\n             }\n         };\n-        M::before_access_global(memory_extra, id, alloc, def_id, is_write)?;\n+        M::before_access_global(&self.extra, id, alloc, def_id, is_write)?;\n         let alloc = Cow::Borrowed(alloc);\n         // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n-        let (alloc, tag) = M::init_allocation_extra(\n-            memory_extra,\n+        let alloc = M::init_allocation_extra(\n+            self,\n             id, // always use the ID we got as input, not the \"hidden\" one.\n             alloc,\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n         );\n-        // Sanity check that this is the same pointer we would have gotten via `global_base_pointer`.\n-        debug_assert_eq!(tag, M::tag_global_base_pointer(memory_extra, id));\n         Ok(alloc)\n     }\n \n@@ -539,8 +559,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n         // So the error type is `InterpResult<'tcx, &Allocation<M::PointerTag>>`.\n         let a = self.alloc_map.get_or(id, || {\n-            let alloc = Self::get_global_alloc(&self.extra, self.tcx, id, /*is_write*/ false)\n-                .map_err(Err)?;\n+            let alloc = self.get_global_alloc(id, /*is_write*/ false).map_err(Err)?;\n             match alloc {\n                 Cow::Borrowed(alloc) => {\n                     // We got a ref, cheaply return that as an \"error\" so that the\n@@ -567,30 +586,30 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// \"Safe\" (bounds and align-checked) allocation access.\n     pub fn get<'a>(\n         &'a self,\n-        sptr: Scalar<M::PointerTag>,\n+        ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n         let align = M::enforce_alignment(&self.extra).then_some(align);\n         let ptr_and_alloc = self.check_and_deref_ptr(\n-            sptr,\n+            ptr,\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n-            |ptr| {\n-                let alloc = self.get_raw(ptr.alloc_id)?;\n-                Ok((alloc.size(), alloc.align, (ptr, alloc)))\n+            |alloc_id, offset, ptr| {\n+                let alloc = self.get_raw(alloc_id)?;\n+                Ok((alloc.size(), alloc.align, (alloc_id, offset, ptr, alloc)))\n             },\n         )?;\n-        if let Some((ptr, alloc)) = ptr_and_alloc {\n-            M::memory_read(&self.extra, &alloc.extra, ptr, size)?;\n-            let range = alloc_range(ptr.offset, size);\n-            Ok(Some(AllocRef { alloc, range, tcx: self.tcx, alloc_id: ptr.alloc_id }))\n+        if let Some((alloc_id, offset, ptr, alloc)) = ptr_and_alloc {\n+            let range = alloc_range(offset, size);\n+            M::memory_read(&self.extra, &alloc.extra, ptr.provenance, range)?;\n+            Ok(Some(AllocRef { alloc, range, tcx: self.tcx, alloc_id }))\n         } else {\n             // Even in this branch we have to be sure that we actually access the allocation, in\n             // order to ensure that `static FOO: Type = FOO;` causes a cycle error instead of\n             // magically pulling *any* ZST value from the ether. However, the `get_raw` above is\n-            // always called when `sptr` is truly a `Pointer`, so we are good.\n+            // always called when `ptr` has an `AllocId`.\n             Ok(None)\n         }\n     }\n@@ -610,48 +629,44 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n     ) -> InterpResult<'tcx, (&mut Allocation<M::PointerTag, M::AllocExtra>, &mut M::MemoryExtra)>\n     {\n-        let tcx = self.tcx;\n-        let memory_extra = &mut self.extra;\n-        let a = self.alloc_map.get_mut_or(id, || {\n-            // Need to make a copy, even if `get_global_alloc` is able\n-            // to give us a cheap reference.\n-            let alloc = Self::get_global_alloc(memory_extra, tcx, id, /*is_write*/ true)?;\n+        // We have \"NLL problem case #3\" here, which cannot be worked around without loss of\n+        // efficiency even for the common case where the key is in the map.\n+        // <https://rust-lang.github.io/rfcs/2094-nll.html#problem-case-3-conditional-control-flow-across-functions>\n+        // (Cannot use `get_mut_or` since `get_global_alloc` needs `&self`.)\n+        if self.alloc_map.get_mut(id).is_none() {\n+            // Slow path.\n+            // Allocation not found locally, go look global.\n+            let alloc = self.get_global_alloc(id, /*is_write*/ true)?;\n             let kind = M::GLOBAL_KIND.expect(\n                 \"I got a global allocation that I have to copy but the machine does \\\n                     not expect that to happen\",\n             );\n-            Ok((MemoryKind::Machine(kind), alloc.into_owned()))\n-        });\n-        // Unpack the error type manually because type inference doesn't\n-        // work otherwise (and we cannot help it because `impl Trait`)\n-        match a {\n-            Err(e) => Err(e),\n-            Ok(a) => {\n-                let a = &mut a.1;\n-                if a.mutability == Mutability::Not {\n-                    throw_ub!(WriteToReadOnly(id))\n-                }\n-                Ok((a, memory_extra))\n-            }\n+            self.alloc_map.insert(id, (MemoryKind::Machine(kind), alloc.into_owned()));\n+        }\n+\n+        let (_kind, alloc) = self.alloc_map.get_mut(id).unwrap();\n+        if alloc.mutability == Mutability::Not {\n+            throw_ub!(WriteToReadOnly(id))\n         }\n+        Ok((alloc, &mut self.extra))\n     }\n \n     /// \"Safe\" (bounds and align-checked) allocation access.\n     pub fn get_mut<'a>(\n         &'a mut self,\n-        sptr: Scalar<M::PointerTag>,\n+        ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n-        let ptr = self.check_ptr_access(sptr, size, align)?;\n-        if let Some(ptr) = ptr {\n+        let parts = self.get_ptr_access(ptr, size, align)?;\n+        if let Some((alloc_id, offset, ptr)) = parts {\n             let tcx = self.tcx;\n             // FIXME: can we somehow avoid looking up the allocation twice here?\n             // We cannot call `get_raw_mut` inside `check_and_deref_ptr` as that would duplicate `&mut self`.\n-            let (alloc, extra) = self.get_raw_mut(ptr.alloc_id)?;\n-            M::memory_written(extra, &mut alloc.extra, ptr, size)?;\n-            let range = alloc_range(ptr.offset, size);\n-            Ok(Some(AllocRefMut { alloc, range, tcx, alloc_id: ptr.alloc_id }))\n+            let (alloc, extra) = self.get_raw_mut(alloc_id)?;\n+            let range = alloc_range(offset, size);\n+            M::memory_written(extra, &mut alloc.extra, ptr.provenance, range)?;\n+            Ok(Some(AllocRefMut { alloc, range, tcx, alloc_id }))\n         } else {\n             Ok(None)\n         }\n@@ -728,7 +743,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     fn get_fn_alloc(&self, id: AllocId) -> Option<FnVal<'tcx, M::ExtraFnVal>> {\n-        trace!(\"reading fn ptr: {}\", id);\n         if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n             Some(FnVal::Other(*extra))\n         } else {\n@@ -741,14 +755,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     pub fn get_fn(\n         &self,\n-        ptr: Scalar<M::PointerTag>,\n+        ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n-        let ptr = self.force_ptr(ptr)?; // We definitely need a pointer value.\n-        if ptr.offset.bytes() != 0 {\n-            throw_ub!(InvalidFunctionPointer(ptr.erase_tag()))\n+        trace!(\"get_fn({:?})\", ptr);\n+        let (alloc_id, offset, _ptr) = self.ptr_get_alloc(ptr)?;\n+        if offset.bytes() != 0 {\n+            throw_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset)))\n         }\n-        self.get_fn_alloc(ptr.alloc_id)\n-            .ok_or_else(|| err_ub!(InvalidFunctionPointer(ptr.erase_tag())).into())\n+        self.get_fn_alloc(alloc_id)\n+            .ok_or_else(|| err_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset))).into())\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n@@ -787,7 +802,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 if reachable.insert(id) {\n                     // This is a new allocation, add its relocations to `todo`.\n                     if let Some((_, alloc)) = self.alloc_map.get(id) {\n-                        todo.extend(alloc.relocations().values().map(|&(_, target_id)| target_id));\n+                        todo.extend(alloc.relocations().values().map(|tag| tag.get_alloc_id()));\n                     }\n                 }\n             }\n@@ -821,14 +836,14 @@ pub struct DumpAllocs<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a, 'mir, 'tcx, M> {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Cannot be a closure because it is generic in `Tag`, `Extra`.\n-        fn write_allocation_track_relocs<'tcx, Tag: Copy + fmt::Debug, Extra>(\n+        fn write_allocation_track_relocs<'tcx, Tag: Provenance, Extra>(\n             fmt: &mut std::fmt::Formatter<'_>,\n             tcx: TyCtxt<'tcx>,\n             allocs_to_print: &mut VecDeque<AllocId>,\n             alloc: &Allocation<Tag, Extra>,\n         ) -> std::fmt::Result {\n-            for &(_, target_id) in alloc.relocations().values() {\n-                allocs_to_print.push_back(target_id);\n+            for alloc_id in alloc.relocations().values().map(|tag| tag.get_alloc_id()) {\n+                allocs_to_print.push_back(alloc_id);\n             }\n             write!(fmt, \"{}\", pretty::display_allocation(tcx, alloc))\n         }\n@@ -931,8 +946,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// Reads the given number of bytes from memory. Returns them as a slice.\n     ///\n     /// Performs appropriate bounds checks.\n-    pub fn read_bytes(&self, sptr: Scalar<M::PointerTag>, size: Size) -> InterpResult<'tcx, &[u8]> {\n-        let alloc_ref = match self.get(sptr, size, Align::ONE)? {\n+    pub fn read_bytes(\n+        &self,\n+        ptr: Pointer<Option<M::PointerTag>>,\n+        size: Size,\n+    ) -> InterpResult<'tcx, &[u8]> {\n+        let alloc_ref = match self.get(ptr, size, Align::ONE)? {\n             Some(a) => a,\n             None => return Ok(&[]), // zero-sized access\n         };\n@@ -949,7 +968,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// Performs appropriate bounds checks.\n     pub fn write_bytes(\n         &mut self,\n-        sptr: Scalar<M::PointerTag>,\n+        ptr: Pointer<Option<M::PointerTag>>,\n         src: impl IntoIterator<Item = u8>,\n     ) -> InterpResult<'tcx> {\n         let mut src = src.into_iter();\n@@ -958,7 +977,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         assert_eq!(lower, len, \"can only write iterators with a precise length\");\n \n         let size = Size::from_bytes(len);\n-        let alloc_ref = match self.get_mut(sptr, size, Align::ONE)? {\n+        let alloc_ref = match self.get_mut(ptr, size, Align::ONE)? {\n             Some(alloc_ref) => alloc_ref,\n             None => {\n                 // zero-sized access\n@@ -985,9 +1004,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     pub fn copy(\n         &mut self,\n-        src: Scalar<M::PointerTag>,\n+        src: Pointer<Option<M::PointerTag>>,\n         src_align: Align,\n-        dest: Scalar<M::PointerTag>,\n+        dest: Pointer<Option<M::PointerTag>>,\n         dest_align: Align,\n         size: Size,\n         nonoverlapping: bool,\n@@ -997,32 +1016,33 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     pub fn copy_repeatedly(\n         &mut self,\n-        src: Scalar<M::PointerTag>,\n+        src: Pointer<Option<M::PointerTag>>,\n         src_align: Align,\n-        dest: Scalar<M::PointerTag>,\n+        dest: Pointer<Option<M::PointerTag>>,\n         dest_align: Align,\n         size: Size,\n         num_copies: u64,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n         let tcx = self.tcx;\n         // We need to do our own bounds-checks.\n-        let src = self.check_ptr_access(src, size, src_align)?;\n-        let dest = self.check_ptr_access(dest, size * num_copies, dest_align)?; // `Size` multiplication\n+        let src_parts = self.get_ptr_access(src, size, src_align)?;\n+        let dest_parts = self.get_ptr_access(dest, size * num_copies, dest_align)?; // `Size` multiplication\n \n         // FIXME: we look up both allocations twice here, once ebfore for the `check_ptr_access`\n         // and once below to get the underlying `&[mut] Allocation`.\n \n         // Source alloc preparations and access hooks.\n-        let src = match src {\n+        let (src_alloc_id, src_offset, src) = match src_parts {\n             None => return Ok(()), // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n             Some(src_ptr) => src_ptr,\n         };\n-        let src_alloc = self.get_raw(src.alloc_id)?;\n-        M::memory_read(&self.extra, &src_alloc.extra, src, size)?;\n+        let src_alloc = self.get_raw(src_alloc_id)?;\n+        let src_range = alloc_range(src_offset, size);\n+        M::memory_read(&self.extra, &src_alloc.extra, src.provenance, src_range)?;\n         // We need the `dest` ptr for the next operation, so we get it now.\n         // We already did the source checks and called the hooks so we are good to return early.\n-        let dest = match dest {\n+        let (dest_alloc_id, dest_offset, dest) = match dest_parts {\n             None => return Ok(()), // Zero-sized *destiantion*.\n             Some(dest_ptr) => dest_ptr,\n         };\n@@ -1032,26 +1052,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // since we don't want to keep any relocations at the target.\n         // (`get_bytes_with_uninit_and_ptr` below checks that there are no\n         // relocations overlapping the edges; those would not be handled correctly).\n-        let relocations = src_alloc.prepare_relocation_copy(\n-            self,\n-            alloc_range(src.offset, size),\n-            dest.offset,\n-            num_copies,\n-        );\n+        let relocations =\n+            src_alloc.prepare_relocation_copy(self, src_range, dest_offset, num_copies);\n         // Prepare a copy of the initialization mask.\n-        let compressed = src_alloc.compress_uninit_range(alloc_range(src.offset, size));\n+        let compressed = src_alloc.compress_uninit_range(src_range);\n         // This checks relocation edges on the src.\n         let src_bytes = src_alloc\n-            .get_bytes_with_uninit_and_ptr(&tcx, alloc_range(src.offset, size))\n-            .map_err(|e| e.to_interp_error(src.alloc_id))?\n+            .get_bytes_with_uninit_and_ptr(&tcx, src_range)\n+            .map_err(|e| e.to_interp_error(src_alloc_id))?\n             .as_ptr(); // raw ptr, so we can also get a ptr to the destination allocation\n \n         // Destination alloc preparations and access hooks.\n-        let (dest_alloc, extra) = self.get_raw_mut(dest.alloc_id)?;\n-        M::memory_written(extra, &mut dest_alloc.extra, dest, size * num_copies)?;\n-        let dest_bytes = dest_alloc\n-            .get_bytes_mut_ptr(&tcx, alloc_range(dest.offset, size * num_copies))\n-            .as_mut_ptr();\n+        let (dest_alloc, extra) = self.get_raw_mut(dest_alloc_id)?;\n+        let dest_range = alloc_range(dest_offset, size * num_copies);\n+        M::memory_written(extra, &mut dest_alloc.extra, dest.provenance, dest_range)?;\n+        let dest_bytes = dest_alloc.get_bytes_mut_ptr(&tcx, dest_range).as_mut_ptr();\n \n         if compressed.no_bytes_init() {\n             // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range\n@@ -1060,7 +1075,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // This also avoids writing to the target bytes so that the backing allocation is never\n             // touched if the bytes stay uninitialized for the whole interpreter execution. On contemporary\n             // operating system this can avoid physically allocating the page.\n-            dest_alloc.mark_init(alloc_range(dest.offset, size * num_copies), false); // `Size` multiplication\n+            dest_alloc.mark_init(dest_range, false); // `Size` multiplication\n             dest_alloc.mark_relocation_range(relocations);\n             return Ok(());\n         }\n@@ -1071,11 +1086,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // The pointers above remain valid even if the `HashMap` table is moved around because they\n         // point into the `Vec` storing the bytes.\n         unsafe {\n-            if src.alloc_id == dest.alloc_id {\n+            if src_alloc_id == dest_alloc_id {\n                 if nonoverlapping {\n                     // `Size` additions\n-                    if (src.offset <= dest.offset && src.offset + size > dest.offset)\n-                        || (dest.offset <= src.offset && dest.offset + size > src.offset)\n+                    if (src_offset <= dest_offset && src_offset + size > dest_offset)\n+                        || (dest_offset <= src_offset && dest_offset + size > src_offset)\n                     {\n                         throw_ub_format!(\"copy_nonoverlapping called on overlapping ranges\")\n                     }\n@@ -1102,7 +1117,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // now fill in all the \"init\" data\n         dest_alloc.mark_compressed_init_range(\n             &compressed,\n-            alloc_range(dest.offset, size),\n+            alloc_range(dest_offset, size), // just a single copy (i.e., not full `dest_range`)\n             num_copies,\n         );\n         // copy the relocations to the destination\n@@ -1114,24 +1129,41 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n /// Machine pointer introspection.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n-    pub fn force_ptr(\n-        &self,\n-        scalar: Scalar<M::PointerTag>,\n-    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        match scalar {\n-            Scalar::Ptr(ptr) => Ok(ptr),\n-            _ => M::int_to_ptr(&self, scalar.to_machine_usize(self)?),\n+    pub fn scalar_to_ptr(&self, scalar: Scalar<M::PointerTag>) -> Pointer<Option<M::PointerTag>> {\n+        // We use `to_bits_or_ptr_internal` since we are just implementing the method people need to\n+        // call to force getting out a pointer.\n+        match scalar.to_bits_or_ptr_internal(self.pointer_size()) {\n+            Err(ptr) => ptr.into(),\n+            Ok(bits) => {\n+                let addr = u64::try_from(bits).unwrap();\n+                M::ptr_from_addr(&self, addr)\n+            }\n         }\n     }\n \n-    pub fn force_bits(\n+    /// Turning a \"maybe pointer\" into a proper pointer (and some information\n+    /// about where it points), or an absolute address.\n+    pub fn ptr_try_get_alloc(\n         &self,\n-        scalar: Scalar<M::PointerTag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx, u128> {\n-        match scalar.to_bits_or_ptr(size, self) {\n-            Ok(bits) => Ok(bits),\n-            Err(ptr) => Ok(M::ptr_to_int(&self, ptr)?.into()),\n+        ptr: Pointer<Option<M::PointerTag>>,\n+    ) -> Result<(AllocId, Size, Pointer<M::PointerTag>), u64> {\n+        match ptr.into_pointer_or_addr() {\n+            Ok(ptr) => {\n+                let (alloc_id, offset) = M::ptr_get_alloc(self, ptr);\n+                Ok((alloc_id, offset, ptr))\n+            }\n+            Err(addr) => Err(addr.bytes()),\n         }\n     }\n+\n+    /// Turning a \"maybe pointer\" into a proper pointer (and some information about where it points).\n+    #[inline(always)]\n+    pub fn ptr_get_alloc(\n+        &self,\n+        ptr: Pointer<Option<M::PointerTag>>,\n+    ) -> InterpResult<'tcx, (AllocId, Size, Pointer<M::PointerTag>)> {\n+        self.ptr_try_get_alloc(ptr).map_err(|offset| {\n+            err_ub!(DanglingIntPointer(offset, CheckInAllocMsg::InboundsTest)).into()\n+        })\n+    }\n }"}, {"sha": "aba7db7816843001930e9a2f1cf58478617b1e3b", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 71, "deletions": 62, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -15,8 +15,9 @@ use rustc_target::abi::{Abi, HasDataLayout, LayoutOf, Size, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n-    alloc_range, from_known_layout, mir_assign_valid_types, ConstValue, GlobalId, InterpCx,\n-    InterpResult, MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n+    alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, GlobalId,\n+    InterpCx, InterpResult, MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Provenance,\n+    Scalar, ScalarMaybeUninit,\n };\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n@@ -26,43 +27,44 @@ use super::{\n /// operations and wide pointers. This idea was taken from rustc's codegen.\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Immediate`, and do not have to work with a `Place`.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, Hash)]\n-pub enum Immediate<Tag = ()> {\n+#[derive(Copy, Clone, PartialEq, Eq, HashStable, Hash, Debug)]\n+pub enum Immediate<Tag: Provenance = AllocId> {\n     Scalar(ScalarMaybeUninit<Tag>),\n     ScalarPair(ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>),\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Immediate, 56);\n \n-impl<Tag> From<ScalarMaybeUninit<Tag>> for Immediate<Tag> {\n+impl<Tag: Provenance> From<ScalarMaybeUninit<Tag>> for Immediate<Tag> {\n     #[inline(always)]\n     fn from(val: ScalarMaybeUninit<Tag>) -> Self {\n         Immediate::Scalar(val)\n     }\n }\n \n-impl<Tag> From<Scalar<Tag>> for Immediate<Tag> {\n+impl<Tag: Provenance> From<Scalar<Tag>> for Immediate<Tag> {\n     #[inline(always)]\n     fn from(val: Scalar<Tag>) -> Self {\n         Immediate::Scalar(val.into())\n     }\n }\n \n-impl<Tag> From<Pointer<Tag>> for Immediate<Tag> {\n-    #[inline(always)]\n-    fn from(val: Pointer<Tag>) -> Self {\n-        Immediate::Scalar(Scalar::from(val).into())\n+impl<'tcx, Tag: Provenance> Immediate<Tag> {\n+    pub fn from_pointer(p: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n+        Immediate::Scalar(ScalarMaybeUninit::from_pointer(p, cx))\n+    }\n+\n+    pub fn from_maybe_pointer(p: Pointer<Option<Tag>>, cx: &impl HasDataLayout) -> Self {\n+        Immediate::Scalar(ScalarMaybeUninit::from_maybe_pointer(p, cx))\n     }\n-}\n \n-impl<'tcx, Tag> Immediate<Tag> {\n     pub fn new_slice(val: Scalar<Tag>, len: u64, cx: &impl HasDataLayout) -> Self {\n         Immediate::ScalarPair(val.into(), Scalar::from_machine_usize(len, cx).into())\n     }\n \n-    pub fn new_dyn_trait(val: Scalar<Tag>, vtable: Pointer<Tag>) -> Self {\n-        Immediate::ScalarPair(val.into(), vtable.into())\n+    pub fn new_dyn_trait(val: Scalar<Tag>, vtable: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n+        Immediate::ScalarPair(val.into(), ScalarMaybeUninit::from_pointer(vtable, cx))\n     }\n \n     #[inline]\n@@ -82,25 +84,31 @@ impl<'tcx, Tag> Immediate<Tag> {\n // ScalarPair needs a type to interpret, so we often have an immediate and a type together\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n-pub struct ImmTy<'tcx, Tag = ()> {\n+pub struct ImmTy<'tcx, Tag: Provenance = AllocId> {\n     imm: Immediate<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(ImmTy<'_>, 72);\n \n-impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n+impl<Tag: Provenance> std::fmt::Display for ImmTy<'tcx, Tag> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         /// Helper function for printing a scalar to a FmtPrinter\n-        fn p<'a, 'tcx, F: std::fmt::Write, Tag>(\n+        fn p<'a, 'tcx, F: std::fmt::Write, Tag: Provenance>(\n             cx: FmtPrinter<'a, 'tcx, F>,\n             s: ScalarMaybeUninit<Tag>,\n             ty: Ty<'tcx>,\n         ) -> Result<FmtPrinter<'a, 'tcx, F>, std::fmt::Error> {\n             match s {\n-                ScalarMaybeUninit::Scalar(s) => {\n-                    cx.pretty_print_const_scalar(s.erase_tag(), ty, true)\n+                ScalarMaybeUninit::Scalar(Scalar::Int(int)) => {\n+                    cx.pretty_print_const_scalar_int(int, ty, true)\n+                }\n+                ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _sz)) => {\n+                    // Just print the ptr value. `pretty_print_const_scalar_ptr` would also try to\n+                    // print what is points to, which would fail since it has no access to the local\n+                    // memory.\n+                    cx.pretty_print_const_pointer(ptr, ty, true)\n                 }\n                 ScalarMaybeUninit::Uninit => cx.typed_value(\n                     |mut this| {\n@@ -120,18 +128,18 @@ impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n                         p(cx, s, ty)?;\n                         return Ok(());\n                     }\n-                    write!(f, \"{}: {}\", s.erase_tag(), self.layout.ty)\n+                    write!(f, \"{}: {}\", s, self.layout.ty)\n                 }\n                 Immediate::ScalarPair(a, b) => {\n                     // FIXME(oli-obk): at least print tuples and slices nicely\n-                    write!(f, \"({}, {}): {}\", a.erase_tag(), b.erase_tag(), self.layout.ty,)\n+                    write!(f, \"({}, {}): {}\", a, b, self.layout.ty,)\n                 }\n             }\n         })\n     }\n }\n \n-impl<'tcx, Tag> std::ops::Deref for ImmTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> std::ops::Deref for ImmTy<'tcx, Tag> {\n     type Target = Immediate<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &Immediate<Tag> {\n@@ -142,51 +150,51 @@ impl<'tcx, Tag> std::ops::Deref for ImmTy<'tcx, Tag> {\n /// An `Operand` is the result of computing a `mir::Operand`. It can be immediate,\n /// or still in memory. The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, Hash)]\n-pub enum Operand<Tag = ()> {\n+#[derive(Copy, Clone, PartialEq, Eq, HashStable, Hash, Debug)]\n+pub enum Operand<Tag: Provenance = AllocId> {\n     Immediate(Immediate<Tag>),\n     Indirect(MemPlace<Tag>),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct OpTy<'tcx, Tag = ()> {\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct OpTy<'tcx, Tag: Provenance = AllocId> {\n     op: Operand<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(OpTy<'_, ()>, 80);\n+rustc_data_structures::static_assert_size!(OpTy<'_>, 80);\n \n-impl<'tcx, Tag> std::ops::Deref for OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> std::ops::Deref for OpTy<'tcx, Tag> {\n     type Target = Operand<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &Operand<Tag> {\n         &self.op\n     }\n }\n \n-impl<'tcx, Tag: Copy> From<MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> From<MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n         OpTy { op: Operand::Indirect(*mplace), layout: mplace.layout }\n     }\n }\n \n-impl<'tcx, Tag: Copy> From<&'_ MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> From<&'_ MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: &MPlaceTy<'tcx, Tag>) -> Self {\n         OpTy { op: Operand::Indirect(**mplace), layout: mplace.layout }\n     }\n }\n \n-impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(val: ImmTy<'tcx, Tag>) -> Self {\n         OpTy { op: Operand::Immediate(val.imm), layout: val.layout }\n     }\n }\n \n-impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> ImmTy<'tcx, Tag> {\n     #[inline]\n     pub fn from_scalar(val: Scalar<Tag>, layout: TyAndLayout<'tcx>) -> Self {\n         ImmTy { imm: val.into(), layout }\n@@ -225,19 +233,6 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    /// Normalize `place.ptr` to a `Pointer` if this is a place and not a ZST.\n-    /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n-    #[inline]\n-    pub fn force_op_ptr(\n-        &self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        match op.try_as_mplace(self) {\n-            Ok(mplace) => Ok(self.force_mplace_ptr(mplace)?.into()),\n-            Err(imm) => Ok(imm.into()), // Nothing to cast/force\n-        }\n-    }\n-\n     /// Try reading an immediate in memory; this is interesting particularly for `ScalarPair`.\n     /// Returns `None` if the layout does not permit loading this as a value.\n     fn try_read_immediate_from_mplace(\n@@ -291,7 +286,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         src: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n-        Ok(match src.try_as_mplace(self) {\n+        Ok(match src.try_as_mplace() {\n             Ok(ref mplace) => {\n                 if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n                     Ok(val)\n@@ -324,6 +319,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(self.read_immediate(op)?.to_scalar_or_uninit())\n     }\n \n+    /// Read a pointer from a place.\n+    pub fn read_pointer(\n+        &self,\n+        op: &OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n+        Ok(self.scalar_to_ptr(self.read_scalar(op)?.check_init()?))\n+    }\n+\n     // Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n@@ -338,7 +341,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         op: &OpTy<'tcx, M::PointerTag>,\n         field: usize,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let base = match op.try_as_mplace(self) {\n+        let base = match op.try_as_mplace() {\n             Ok(ref mplace) => {\n                 // We can reuse the mplace field computation logic for indirect operands.\n                 let field = self.mplace_field(mplace, field)?;\n@@ -381,7 +384,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.operand_field(op, index)\n         } else {\n             // Indexing into a big array. This must be an mplace.\n-            let mplace = op.assert_mem_place(self);\n+            let mplace = op.assert_mem_place();\n             Ok(self.mplace_index(&mplace, index)?.into())\n         }\n     }\n@@ -392,7 +395,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n-        Ok(match op.try_as_mplace(self) {\n+        Ok(match op.try_as_mplace() {\n             Ok(ref mplace) => self.mplace_downcast(mplace, variant)?.into(),\n             Err(..) => {\n                 let layout = op.layout.for_variant(self, variant);\n@@ -414,7 +417,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n                 // The rest should only occur as mplace, we do not use Immediates for types\n                 // allowing such operations.  This matches place_projection forcing an allocation.\n-                let mplace = base.assert_mem_place(self);\n+                let mplace = base.assert_mem_place();\n                 self.mplace_projection(&mplace, proj_elem)?.into()\n             }\n         })\n@@ -569,7 +572,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Other cases need layout.\n         let tag_scalar = |scalar| -> InterpResult<'tcx, _> {\n             Ok(match scalar {\n-                Scalar::Ptr(ptr) => Scalar::Ptr(self.global_base_pointer(ptr)?),\n+                Scalar::Ptr(ptr, size) => Scalar::Ptr(self.global_base_pointer(ptr)?, size),\n                 Scalar::Int(int) => Scalar::Int(int),\n             })\n         };\n@@ -580,9 +583,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n                 let ptr = self.global_base_pointer(Pointer::new(id, offset))?;\n-                Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n+                Operand::Indirect(MemPlace::from_ptr(ptr.into(), layout.align.abi))\n             }\n-            ConstValue::Scalar(x) => Operand::Immediate(tag_scalar(x)?.into()),\n+            ConstValue::Scalar(x) => Operand::Immediate(tag_scalar(x.into())?.into()),\n             ConstValue::Slice { data, start, end } => {\n                 // We rely on mutability being set correctly in `data` to prevent writes\n                 // where none should happen.\n@@ -591,7 +594,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Size::from_bytes(start), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice(\n-                    self.global_base_pointer(ptr)?.into(),\n+                    Scalar::from_pointer(self.global_base_pointer(ptr)?, &*self.tcx),\n                     u64::try_from(end.checked_sub(start).unwrap()).unwrap(), // len: `end - start`\n                     self,\n                 ))\n@@ -658,9 +661,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Figure out which discriminant and variant this corresponds to.\n         Ok(match *tag_encoding {\n             TagEncoding::Direct => {\n-                let tag_bits = self\n-                    .force_bits(tag_val, tag_layout.size)\n-                    .map_err(|_| err_ub!(InvalidTag(tag_val.erase_tag())))?;\n+                let tag_bits = tag_val\n+                    .try_to_int()\n+                    .map_err(|dbg_val| err_ub!(InvalidTag(dbg_val)))?\n+                    .assert_bits(tag_layout.size);\n                 // Cast bits from tag layout to discriminant layout.\n                 let discr_val = self.cast_from_scalar(tag_bits, tag_layout, discr_layout.ty);\n                 let discr_bits = discr_val.assert_bits(discr_layout.size);\n@@ -677,7 +681,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     _ => span_bug!(self.cur_span(), \"tagged layout for non-adt non-generator\"),\n                 }\n-                .ok_or_else(|| err_ub!(InvalidTag(tag_val.erase_tag())))?;\n+                .ok_or_else(|| err_ub!(InvalidTag(Scalar::from_uint(tag_bits, tag_layout.size))))?;\n                 // Return the cast value, and the index.\n                 (discr_val, index.0)\n             }\n@@ -686,18 +690,23 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // discriminant (encoded in niche/tag) and variant index are the same.\n                 let variants_start = niche_variants.start().as_u32();\n                 let variants_end = niche_variants.end().as_u32();\n-                let variant = match tag_val.to_bits_or_ptr(tag_layout.size, self) {\n-                    Err(ptr) => {\n-                        // The niche must be just 0 (which an inbounds pointer value never is)\n+                let variant = match tag_val.try_to_int() {\n+                    Err(dbg_val) => {\n+                        // So this is a pointer then, and casting to an int failed.\n+                        // Can only happen during CTFE.\n+                        let ptr = self.scalar_to_ptr(tag_val);\n+                        // The niche must be just 0, and the ptr not null, then we know this is\n+                        // okay. Everything else, we conservatively reject.\n                         let ptr_valid = niche_start == 0\n                             && variants_start == variants_end\n                             && !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            throw_ub!(InvalidTag(tag_val.erase_tag()))\n+                            throw_ub!(InvalidTag(dbg_val))\n                         }\n                         dataful_variant\n                     }\n                     Ok(tag_bits) => {\n+                        let tag_bits = tag_bits.assert_bits(tag_layout.size);\n                         // We need to use machine arithmetic to get the relative variant idx:\n                         // variant_index_relative = tag_val - niche_start_val\n                         let tag_val = ImmTy::from_uint(tag_bits, tag_layout);"}, {"sha": "79b493d74e19b47006653f8bbd6fb0ccad7012e0", "filename": "compiler/rustc_mir/src/interpret/operator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -318,8 +318,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     right.layout.ty\n                 );\n \n-                let l = self.force_bits(left.to_scalar()?, left.layout.size)?;\n-                let r = self.force_bits(right.to_scalar()?, right.layout.size)?;\n+                let l = left.to_scalar()?.to_bits(left.layout.size)?;\n+                let r = right.to_scalar()?.to_bits(right.layout.size)?;\n                 self.binary_int_op(bin_op, l, left.layout, r, right.layout)\n             }\n             _ if left.layout.ty.is_any_ptr() => {\n@@ -386,7 +386,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             _ => {\n                 assert!(layout.ty.is_integral());\n-                let val = self.force_bits(val, layout.size)?;\n+                let val = val.to_bits(layout.size)?;\n                 let (res, overflow) = match un_op {\n                     Not => (self.truncate(!val, layout), false), // bitwise negation, then truncate\n                     Neg => {"}, {"sha": "91fcc3495b1c12abeaa3523d705462214f3db23d", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 81, "deletions": 142, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -3,7 +3,6 @@\n //! All high-level functions to write to memory work on places as destinations.\n \n use std::convert::TryFrom;\n-use std::fmt::Debug;\n use std::hash::Hash;\n \n use rustc_ast::Mutability;\n@@ -15,14 +14,14 @@ use rustc_target::abi::{Abi, Align, FieldsShape, TagEncoding};\n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, VariantIdx, Variants};\n \n use super::{\n-    alloc_range, mir_assign_valid_types, AllocRef, AllocRefMut, ConstAlloc, ImmTy, Immediate,\n-    InterpCx, InterpResult, LocalValue, Machine, MemoryKind, OpTy, Operand, Pointer,\n-    PointerArithmetic, Scalar, ScalarMaybeUninit,\n+    alloc_range, mir_assign_valid_types, AllocId, AllocRef, AllocRefMut, CheckInAllocMsg,\n+    ConstAlloc, ImmTy, Immediate, InterpCx, InterpResult, LocalValue, Machine, MemoryKind, OpTy,\n+    Operand, Pointer, PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit,\n };\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n /// Information required for the sound usage of a `MemPlace`.\n-pub enum MemPlaceMeta<Tag = ()> {\n+pub enum MemPlaceMeta<Tag: Provenance = AllocId> {\n     /// The unsized payload (e.g. length for slices or vtable pointer for trait objects).\n     Meta(Scalar<Tag>),\n     /// `Sized` types or unsized `extern type`\n@@ -37,7 +36,7 @@ pub enum MemPlaceMeta<Tag = ()> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(MemPlaceMeta, 24);\n \n-impl<Tag> MemPlaceMeta<Tag> {\n+impl<Tag: Provenance> MemPlaceMeta<Tag> {\n     pub fn unwrap_meta(self) -> Scalar<Tag> {\n         match self {\n             Self::Meta(s) => s,\n@@ -52,22 +51,12 @@ impl<Tag> MemPlaceMeta<Tag> {\n             Self::None | Self::Poison => false,\n         }\n     }\n-\n-    pub fn erase_tag(self) -> MemPlaceMeta<()> {\n-        match self {\n-            Self::Meta(s) => MemPlaceMeta::Meta(s.erase_tag()),\n-            Self::None => MemPlaceMeta::None,\n-            Self::Poison => MemPlaceMeta::Poison,\n-        }\n-    }\n }\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n-pub struct MemPlace<Tag = ()> {\n-    /// A place may have an integral pointer for ZSTs, and since it might\n-    /// be turned back into a reference before ever being dereferenced.\n-    /// However, it may never be uninit.\n-    pub ptr: Scalar<Tag>,\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n+pub struct MemPlace<Tag: Provenance = AllocId> {\n+    /// The pointer can be a pure integer, with the `None` tag.\n+    pub ptr: Pointer<Option<Tag>>,\n     pub align: Align,\n     /// Metadata for unsized places. Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n@@ -76,10 +65,10 @@ pub struct MemPlace<Tag = ()> {\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MemPlace, 56);\n+rustc_data_structures::static_assert_size!(MemPlace, 48);\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n-pub enum Place<Tag = ()> {\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n+pub enum Place<Tag: Provenance = AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n     Ptr(MemPlace<Tag>),\n \n@@ -89,18 +78,18 @@ pub enum Place<Tag = ()> {\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Place, 64);\n+rustc_data_structures::static_assert_size!(Place, 56);\n \n #[derive(Copy, Clone, Debug)]\n-pub struct PlaceTy<'tcx, Tag = ()> {\n+pub struct PlaceTy<'tcx, Tag: Provenance = AllocId> {\n     place: Place<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(PlaceTy<'_>, 80);\n+rustc_data_structures::static_assert_size!(PlaceTy<'_>, 72);\n \n-impl<'tcx, Tag> std::ops::Deref for PlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> std::ops::Deref for PlaceTy<'tcx, Tag> {\n     type Target = Place<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &Place<Tag> {\n@@ -109,59 +98,50 @@ impl<'tcx, Tag> std::ops::Deref for PlaceTy<'tcx, Tag> {\n }\n \n /// A MemPlace with its layout. Constructing it is only possible in this module.\n-#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n-pub struct MPlaceTy<'tcx, Tag = ()> {\n+#[derive(Copy, Clone, Hash, Eq, PartialEq, Debug)]\n+pub struct MPlaceTy<'tcx, Tag: Provenance = AllocId> {\n     mplace: MemPlace<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MPlaceTy<'_>, 72);\n+rustc_data_structures::static_assert_size!(MPlaceTy<'_>, 64);\n \n-impl<'tcx, Tag> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n     type Target = MemPlace<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &MemPlace<Tag> {\n         &self.mplace\n     }\n }\n \n-impl<'tcx, Tag> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n         PlaceTy { place: Place::Ptr(mplace.mplace), layout: mplace.layout }\n     }\n }\n \n-impl<Tag> MemPlace<Tag> {\n-    /// Replace ptr tag, maintain vtable tag (if any)\n-    #[inline]\n-    pub fn replace_tag(self, new_tag: Tag) -> Self {\n-        MemPlace { ptr: self.ptr.erase_tag().with_tag(new_tag), align: self.align, meta: self.meta }\n-    }\n-\n-    #[inline]\n-    pub fn erase_tag(self) -> MemPlace {\n-        MemPlace { ptr: self.ptr.erase_tag(), align: self.align, meta: self.meta.erase_tag() }\n-    }\n-\n+impl<Tag: Provenance> MemPlace<Tag> {\n     #[inline(always)]\n-    fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n+    pub fn from_ptr(ptr: Pointer<Option<Tag>>, align: Align) -> Self {\n         MemPlace { ptr, align, meta: MemPlaceMeta::None }\n     }\n \n-    #[inline(always)]\n-    pub fn from_ptr(ptr: Pointer<Tag>, align: Align) -> Self {\n-        Self::from_scalar_ptr(ptr.into(), align)\n+    /// Adjust the provenance of the main pointer (metadata is unaffected).\n+    pub fn map_provenance(self, f: impl FnOnce(Option<Tag>) -> Option<Tag>) -> Self {\n+        MemPlace { ptr: self.ptr.map_provenance(f), ..self }\n     }\n \n     /// Turn a mplace into a (thin or wide) pointer, as a reference, pointing to the same space.\n     /// This is the inverse of `ref_to_mplace`.\n     #[inline(always)]\n-    pub fn to_ref(self) -> Immediate<Tag> {\n+    pub fn to_ref(self, cx: &impl HasDataLayout) -> Immediate<Tag> {\n         match self.meta {\n-            MemPlaceMeta::None => Immediate::Scalar(self.ptr.into()),\n-            MemPlaceMeta::Meta(meta) => Immediate::ScalarPair(self.ptr.into(), meta.into()),\n+            MemPlaceMeta::None => Immediate::from(Scalar::from_maybe_pointer(self.ptr, cx)),\n+            MemPlaceMeta::Meta(meta) => {\n+                Immediate::ScalarPair(Scalar::from_maybe_pointer(self.ptr, cx).into(), meta.into())\n+            }\n             MemPlaceMeta::Poison => bug!(\n                 \"MPlaceTy::dangling may never be used to produce a \\\n                 place that will have the address of its pointee taken\"\n@@ -177,29 +157,23 @@ impl<Tag> MemPlace<Tag> {\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n         Ok(MemPlace {\n-            ptr: self.ptr.ptr_offset(offset, cx)?,\n+            ptr: self.ptr.offset(offset, cx)?,\n             align: self.align.restrict_for_offset(offset),\n             meta,\n         })\n     }\n }\n \n-impl<'tcx, Tag: Copy> MPlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n     /// Produces a MemPlace that works for ZST but nothing else\n     #[inline]\n-    pub fn dangling(layout: TyAndLayout<'tcx>, cx: &impl HasDataLayout) -> Self {\n+    pub fn dangling(layout: TyAndLayout<'tcx>) -> Self {\n         let align = layout.align.abi;\n-        let ptr = Scalar::from_machine_usize(align.bytes(), cx);\n+        let ptr = Pointer::new(None, Size::from_bytes(align.bytes())); // no provenance, absolute address\n         // `Poison` this to make sure that the pointer value `ptr` is never observable by the program.\n         MPlaceTy { mplace: MemPlace { ptr, align, meta: MemPlaceMeta::Poison }, layout }\n     }\n \n-    /// Replace ptr tag, maintain vtable tag (if any)\n-    #[inline]\n-    pub fn replace_tag(&self, new_tag: Tag) -> Self {\n-        MPlaceTy { mplace: self.mplace.replace_tag(new_tag), layout: self.layout }\n-    }\n-\n     #[inline]\n     pub fn offset(\n         &self,\n@@ -212,7 +186,7 @@ impl<'tcx, Tag: Copy> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    fn from_aligned_ptr(ptr: Pointer<Tag>, layout: TyAndLayout<'tcx>) -> Self {\n+    pub fn from_aligned_ptr(ptr: Pointer<Option<Tag>>, layout: TyAndLayout<'tcx>) -> Self {\n         MPlaceTy { mplace: MemPlace::from_ptr(ptr, layout.align.abi), layout }\n     }\n \n@@ -244,32 +218,27 @@ impl<'tcx, Tag: Copy> MPlaceTy<'tcx, Tag> {\n }\n \n // These are defined here because they produce a place.\n-impl<'tcx, Tag: Debug + Copy> OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n     #[inline(always)]\n     /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n     /// read from the resulting mplace, not to get its address back.\n-    pub fn try_as_mplace(\n-        &self,\n-        cx: &impl HasDataLayout,\n-    ) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n+    pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n         match **self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n-            Operand::Immediate(_) if self.layout.is_zst() => {\n-                Ok(MPlaceTy::dangling(self.layout, cx))\n-            }\n+            Operand::Immediate(_) if self.layout.is_zst() => Ok(MPlaceTy::dangling(self.layout)),\n             Operand::Immediate(imm) => Err(ImmTy::from_immediate(imm, self.layout)),\n         }\n     }\n \n     #[inline(always)]\n     /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n     /// read from the resulting mplace, not to get its address back.\n-    pub fn assert_mem_place(&self, cx: &impl HasDataLayout) -> MPlaceTy<'tcx, Tag> {\n-        self.try_as_mplace(cx).unwrap()\n+    pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Tag> {\n+        self.try_as_mplace().unwrap()\n     }\n }\n \n-impl<Tag: Debug> Place<Tag> {\n+impl<Tag: Provenance> Place<Tag> {\n     #[inline]\n     pub fn assert_mem_place(self) -> MemPlace<Tag> {\n         match self {\n@@ -279,7 +248,7 @@ impl<Tag: Debug> Place<Tag> {\n     }\n }\n \n-impl<'tcx, Tag: Debug> PlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> PlaceTy<'tcx, Tag> {\n     #[inline]\n     pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n         MPlaceTy { mplace: self.place.assert_mem_place(), layout: self.layout }\n@@ -290,7 +259,7 @@ impl<'tcx, Tag: Debug> PlaceTy<'tcx, Tag> {\n impl<'mir, 'tcx: 'mir, Tag, M> InterpCx<'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n-    Tag: Debug + Copy + Eq + Hash + 'static,\n+    Tag: Provenance + Eq + Hash + 'static,\n     M: Machine<'mir, 'tcx, PointerTag = Tag>,\n {\n     /// Take a value, which represents a (thin or wide) reference, and make it a place.\n@@ -307,14 +276,12 @@ where\n             val.layout.ty.builtin_deref(true).expect(\"`ref_to_mplace` called on non-ptr type\").ty;\n         let layout = self.layout_of(pointee_type)?;\n         let (ptr, meta) = match **val {\n-            Immediate::Scalar(ptr) => (ptr.check_init()?, MemPlaceMeta::None),\n-            Immediate::ScalarPair(ptr, meta) => {\n-                (ptr.check_init()?, MemPlaceMeta::Meta(meta.check_init()?))\n-            }\n+            Immediate::Scalar(ptr) => (ptr, MemPlaceMeta::None),\n+            Immediate::ScalarPair(ptr, meta) => (ptr, MemPlaceMeta::Meta(meta.check_init()?)),\n         };\n \n         let mplace = MemPlace {\n-            ptr,\n+            ptr: self.scalar_to_ptr(ptr.check_init()?),\n             // We could use the run-time alignment here. For now, we do not, because\n             // the point of tracking the alignment here is to make sure that the *static*\n             // alignment information emitted with the loads is correct. The run-time\n@@ -333,8 +300,9 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let val = self.read_immediate(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n-        let place = self.ref_to_mplace(&val)?;\n-        self.mplace_access_checked(place, None)\n+        let mplace = self.ref_to_mplace(&val)?;\n+        self.check_mplace_access(mplace, CheckInAllocMsg::DerefTest)?;\n+        Ok(mplace)\n     }\n \n     #[inline]\n@@ -359,38 +327,19 @@ where\n         self.memory.get_mut(place.ptr, size, place.align)\n     }\n \n-    /// Return the \"access-checked\" version of this `MPlace`, where for non-ZST\n-    /// this is definitely a `Pointer`.\n-    ///\n-    /// `force_align` must only be used when correct alignment does not matter,\n-    /// like in Stacked Borrows.\n-    pub fn mplace_access_checked(\n+    /// Check if this mplace is dereferencable and sufficiently aligned.\n+    fn check_mplace_access(\n         &self,\n-        mut place: MPlaceTy<'tcx, M::PointerTag>,\n-        force_align: Option<Align>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        mplace: MPlaceTy<'tcx, M::PointerTag>,\n+        msg: CheckInAllocMsg,\n+    ) -> InterpResult<'tcx> {\n         let (size, align) = self\n-            .size_and_align_of_mplace(&place)?\n-            .unwrap_or((place.layout.size, place.layout.align.abi));\n-        assert!(place.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n-        let align = force_align.unwrap_or(align);\n-        // Record new (stricter, unless forced) alignment requirement in place.\n-        place.mplace.align = align;\n-        // When dereferencing a pointer, it must be non-null, aligned, and live.\n-        if let Some(ptr) = self.memory.check_ptr_access(place.ptr, size, align)? {\n-            place.mplace.ptr = ptr.into();\n-        }\n-        Ok(place)\n-    }\n-\n-    /// Force `place.ptr` to a `Pointer`.\n-    /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n-    pub(super) fn force_mplace_ptr(\n-        &self,\n-        mut place: MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        place.mplace.ptr = self.force_ptr(place.mplace.ptr)?.into();\n-        Ok(place)\n+            .size_and_align_of_mplace(&mplace)?\n+            .unwrap_or((mplace.layout.size, mplace.layout.align.abi));\n+        assert!(mplace.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n+        let align = M::enforce_alignment(&self.memory.extra).then_some(align);\n+        self.memory.check_ptr_access_align(mplace.ptr, size, align.unwrap_or(Align::ONE), msg)?;\n+        Ok(())\n     }\n \n     /// Offset a pointer to project to a field of a struct/union. Unlike `place_field`, this is\n@@ -558,10 +507,7 @@ where\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n                 let n = self.access_local(self.frame(), local, Some(layout))?;\n                 let n = self.read_scalar(&n)?;\n-                let n = u64::try_from(\n-                    self.force_bits(n.check_init()?, self.tcx.data_layout.pointer_size)?,\n-                )\n-                .unwrap();\n+                let n = n.to_machine_usize(self)?;\n                 self.mplace_index(base, n)?\n             }\n \n@@ -677,16 +623,6 @@ where\n         Ok(place_ty)\n     }\n \n-    /// Write a scalar to a place\n-    #[inline(always)]\n-    pub fn write_scalar(\n-        &mut self,\n-        val: impl Into<ScalarMaybeUninit<M::PointerTag>>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx> {\n-        self.write_immediate(Immediate::Scalar(val.into()), dest)\n-    }\n-\n     /// Write an immediate to a place\n     #[inline(always)]\n     pub fn write_immediate(\n@@ -704,21 +640,24 @@ where\n         Ok(())\n     }\n \n-    /// Write an `Immediate` to memory.\n+    /// Write a scalar to a place\n     #[inline(always)]\n-    pub fn write_immediate_to_mplace(\n+    pub fn write_scalar(\n         &mut self,\n-        src: Immediate<M::PointerTag>,\n-        dest: &MPlaceTy<'tcx, M::PointerTag>,\n+        val: impl Into<ScalarMaybeUninit<M::PointerTag>>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        self.write_immediate_to_mplace_no_validate(src, dest)?;\n-\n-        if M::enforce_validity(self) {\n-            // Data got changed, better make sure it matches the type!\n-            self.validate_operand(&dest.into())?;\n-        }\n+        self.write_immediate(Immediate::Scalar(val.into()), dest)\n+    }\n \n-        Ok(())\n+    /// Write a pointer to a place\n+    #[inline(always)]\n+    pub fn write_pointer(\n+        &mut self,\n+        ptr: impl Into<Pointer<Option<M::PointerTag>>>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx> {\n+        self.write_scalar(Scalar::from_maybe_pointer(ptr.into(), self), dest)\n     }\n \n     /// Write an immediate to a place.\n@@ -733,7 +672,7 @@ where\n             // This is a very common path, avoid some checks in release mode\n             assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n             match src {\n-                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Ptr(_))) => assert_eq!(\n+                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Ptr(..))) => assert_eq!(\n                     self.pointer_size(),\n                     dest.layout.size,\n                     \"Size mismatch when writing pointer\"\n@@ -1020,7 +959,7 @@ where\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'static, MPlaceTy<'tcx, M::PointerTag>> {\n         let ptr = self.memory.allocate(layout.size, layout.align.abi, kind)?;\n-        Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n+        Ok(MPlaceTy::from_aligned_ptr(ptr.into(), layout))\n     }\n \n     /// Returns a wide MPlace of type `&'static [mut] str` to a new 1-aligned allocation.\n@@ -1125,7 +1064,7 @@ where\n         let _ = self.tcx.global_alloc(raw.alloc_id);\n         let ptr = self.global_base_pointer(Pointer::from(raw.alloc_id))?;\n         let layout = self.layout_of(raw.ty)?;\n-        Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n+        Ok(MPlaceTy::from_aligned_ptr(ptr.into(), layout))\n     }\n \n     /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type.\n@@ -1134,7 +1073,7 @@ where\n         &self,\n         mplace: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n-        let vtable = mplace.vtable(); // also sanity checks the type\n+        let vtable = self.scalar_to_ptr(mplace.vtable()); // also sanity checks the type\n         let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n "}, {"sha": "f2a8a067dfac2a11287515d4a2e927aec3c62946", "filename": "compiler/rustc_mir/src/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -162,9 +162,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc_middle::mir::Rvalue::*;\n         match *rvalue {\n             ThreadLocalRef(did) => {\n-                let id = M::thread_local_static_alloc_id(self, did)?;\n-                let val = self.global_base_pointer(id.into())?;\n-                self.write_scalar(val, &dest)?;\n+                let ptr = M::thread_local_static_base_pointer(self, did)?;\n+                self.write_pointer(ptr, &dest)?;\n             }\n \n             Use(ref operand) => {\n@@ -240,7 +239,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // of the first element.\n                     let elem_size = first.layout.size;\n                     let first_ptr = first.ptr;\n-                    let rest_ptr = first_ptr.ptr_offset(elem_size, self)?;\n+                    let rest_ptr = first_ptr.offset(elem_size, self)?;\n                     self.memory.copy_repeatedly(\n                         first_ptr,\n                         first.align,\n@@ -264,11 +263,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             AddressOf(_, place) | Ref(_, _, place) => {\n                 let src = self.eval_place(place)?;\n                 let place = self.force_allocation(&src)?;\n-                if place.layout.size.bytes() > 0 {\n-                    // definitely not a ZST\n-                    assert!(place.ptr.is_ptr(), \"non-ZST places should be normalized to `Pointer`\");\n-                }\n-                self.write_immediate(place.to_ref(), &dest)?;\n+                self.write_immediate(place.to_ref(self), &dest)?;\n             }\n \n             NullaryOp(mir::NullOp::Box, _) => {"}, {"sha": "f369480d959fede95e17d9e7bc4c77271f8fb1a8", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -12,8 +12,8 @@ use rustc_target::abi::{self, LayoutOf as _};\n use rustc_target::spec::abi::Abi;\n \n use super::{\n-    FnVal, ImmTy, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, PlaceTy, StackPopCleanup,\n-    StackPopUnwind,\n+    FnVal, ImmTy, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, PlaceTy, Scalar,\n+    StackPopCleanup, StackPopUnwind,\n };\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -72,8 +72,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (fn_val, abi, caller_can_unwind) = match *func.layout.ty.kind() {\n                     ty::FnPtr(sig) => {\n                         let caller_abi = sig.abi();\n-                        let fn_ptr = self.read_scalar(&func)?.check_init()?;\n-                        let fn_val = self.memory.get_fn(fn_ptr)?;\n+                        let fn_ptr = self.read_pointer(&func)?;\n+                        let fn_val = self.memory.get_fn(fn_ptr.into())?;\n                         (\n                             fn_val,\n                             caller_abi,\n@@ -454,11 +454,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     None => {\n                         // Unsized self.\n-                        args[0].assert_mem_place(self)\n+                        args[0].assert_mem_place()\n                     }\n                 };\n                 // Find and consult vtable\n-                let vtable = receiver_place.vtable();\n+                let vtable = self.scalar_to_ptr(receiver_place.vtable());\n                 let fn_val = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n@@ -468,8 +468,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let receiver_ptr_ty = self.tcx.mk_mut_ptr(receiver_place.layout.ty);\n                 let this_receiver_ptr = self.layout_of(receiver_ptr_ty)?.field(self, 0)?;\n                 // Adjust receiver argument.\n-                args[0] =\n-                    OpTy::from(ImmTy::from_immediate(receiver_place.ptr.into(), this_receiver_ptr));\n+                args[0] = OpTy::from(ImmTy::from_immediate(\n+                    Scalar::from_maybe_pointer(receiver_place.ptr, self).into(),\n+                    this_receiver_ptr,\n+                ));\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(fn_val, caller_abi, &args, ret, unwind)\n@@ -499,12 +501,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         let arg = ImmTy::from_immediate(\n-            place.to_ref(),\n+            place.to_ref(self),\n             self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         );\n \n         let ty = self.tcx.mk_unit(); // return type is ()\n-        let dest = MPlaceTy::dangling(self.layout_of(ty)?, self);\n+        let dest = MPlaceTy::dangling(self.layout_of(ty)?);\n \n         self.eval_fn_call(\n             FnVal::Instance(instance),"}, {"sha": "7a93fcee78e3389a60ff1b8ee360215ab8a03052", "filename": "compiler/rustc_mir/src/interpret/traits.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -1,6 +1,6 @@\n use std::convert::TryFrom;\n \n-use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n+use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic};\n use rustc_middle::ty::{\n     self, Ty, COMMON_VTABLE_ENTRIES, COMMON_VTABLE_ENTRIES_ALIGN,\n     COMMON_VTABLE_ENTRIES_DROPINPLACE, COMMON_VTABLE_ENTRIES_SIZE,\n@@ -42,23 +42,23 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// corresponds to the first method declared in the trait of the provided vtable.\n     pub fn get_vtable_slot(\n         &self,\n-        vtable: Scalar<M::PointerTag>,\n+        vtable: Pointer<Option<M::PointerTag>>,\n         idx: u64,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr_size = self.pointer_size();\n-        let vtable_slot = vtable.ptr_offset(ptr_size * idx, self)?;\n+        let vtable_slot = vtable.offset(ptr_size * idx, self)?;\n         let vtable_slot = self\n             .memory\n             .get(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n-        let fn_ptr = vtable_slot.read_ptr_sized(Size::ZERO)?.check_init()?;\n+        let fn_ptr = self.scalar_to_ptr(vtable_slot.read_ptr_sized(Size::ZERO)?.check_init()?);\n         self.memory.get_fn(fn_ptr)\n     }\n \n     /// Returns the drop fn instance as well as the actual dynamic type.\n     pub fn read_drop_type_from_vtable(\n         &self,\n-        vtable: Scalar<M::PointerTag>,\n+        vtable: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, (ty::Instance<'tcx>, Ty<'tcx>)> {\n         let pointer_size = self.pointer_size();\n         // We don't care about the pointee type; we just want a pointer.\n@@ -77,7 +77,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .check_init()?;\n         // We *need* an instance here, no other kind of function value, to be able\n         // to determine the type.\n-        let drop_instance = self.memory.get_fn(drop_fn)?.as_instance()?;\n+        let drop_instance = self.memory.get_fn(self.scalar_to_ptr(drop_fn))?.as_instance()?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx, self.param_env).fn_sig(*self.tcx);\n         let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig);\n@@ -93,7 +93,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn read_size_and_align_from_vtable(\n         &self,\n-        vtable: Scalar<M::PointerTag>,\n+        vtable: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, (Size, Align)> {\n         let pointer_size = self.pointer_size();\n         // We check for `size = 3 * ptr_size`, which covers the drop fn (unused here),\n@@ -109,11 +109,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let size = vtable\n             .read_ptr_sized(pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_SIZE).unwrap())?\n             .check_init()?;\n-        let size = u64::try_from(self.force_bits(size, pointer_size)?).unwrap();\n+        let size = size.to_machine_usize(self)?;\n         let align = vtable\n             .read_ptr_sized(pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_ALIGN).unwrap())?\n             .check_init()?;\n-        let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n+        let align = align.to_machine_usize(self)?;\n         let align = Align::from_bytes(align).map_err(|e| err_ub!(InvalidVtableAlignment(e)))?;\n \n         if size >= self.tcx.data_layout.obj_size_bound() {"}, {"sha": "0c7f89c1a36ba10ab46dac0240255cdf8d9501bd", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -21,7 +21,7 @@ use std::hash::Hash;\n \n use super::{\n     alloc_range, CheckInAllocMsg, GlobalAlloc, InterpCx, InterpResult, MPlaceTy, Machine,\n-    MemPlaceMeta, OpTy, Scalar, ScalarMaybeUninit, ValueVisitor,\n+    MemPlaceMeta, OpTy, ScalarMaybeUninit, ValueVisitor,\n };\n \n macro_rules! throw_validation_failure {\n@@ -324,7 +324,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n         match tail.kind() {\n             ty::Dynamic(..) => {\n-                let vtable = meta.unwrap_meta();\n+                let vtable = self.ecx.scalar_to_ptr(meta.unwrap_meta());\n                 // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n                 try_validation!(\n                     self.ecx.memory.check_ptr_access_align(\n@@ -335,8 +335,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     ),\n                     self.path,\n                     err_ub!(DanglingIntPointer(..)) |\n-                    err_ub!(PointerUseAfterFree(..)) |\n-                    err_unsup!(ReadBytesAsPointer) =>\n+                    err_ub!(PointerUseAfterFree(..)) =>\n                         { \"dangling vtable pointer in wide pointer\" },\n                     err_ub!(AlignmentCheckFailed { .. }) =>\n                         { \"unaligned vtable pointer in wide pointer\" },\n@@ -347,8 +346,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     self.ecx.read_drop_type_from_vtable(vtable),\n                     self.path,\n                     err_ub!(DanglingIntPointer(..)) |\n-                    err_ub!(InvalidFunctionPointer(..)) |\n-                    err_unsup!(ReadBytesAsPointer) =>\n+                    err_ub!(InvalidFunctionPointer(..)) =>\n                         { \"invalid drop function pointer in vtable (not pointing to a function)\" },\n                     err_ub!(InvalidVtableDropFn(..)) =>\n                         { \"invalid drop function pointer in vtable (function has incompatible signature)\" },\n@@ -437,8 +435,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 { \"a dangling {} (address 0x{:x} is unallocated)\", kind, i },\n             err_ub!(PointerOutOfBounds { .. }) =>\n                 { \"a dangling {} (going beyond the bounds of its allocation)\", kind },\n-            err_unsup!(ReadBytesAsPointer) =>\n-                { \"a dangling {} (created from integer)\", kind },\n             // This cannot happen during const-eval (because interning already detects\n             // dangling pointers), but it can happen in Miri.\n             err_ub!(PointerUseAfterFree(..)) =>\n@@ -448,17 +444,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if let Some(ref mut ref_tracking) = self.ref_tracking {\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n-            // Normalize before handing `place` to tracking because that will\n-            // check for duplicates.\n-            let place = if size.bytes() > 0 {\n-                self.ecx.force_mplace_ptr(place).expect(\"we already bounds-checked\")\n-            } else {\n-                place\n-            };\n             // Skip validation entirely for some external statics\n-            if let Scalar::Ptr(ptr) = place.ptr {\n+            if let Ok((alloc_id, _offset, _ptr)) = self.ecx.memory.ptr_try_get_alloc(place.ptr) {\n                 // not a ZST\n-                let alloc_kind = self.ecx.tcx.get_global_alloc(ptr.alloc_id);\n+                let alloc_kind = self.ecx.tcx.get_global_alloc(alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                     assert!(!self.ecx.tcx.is_thread_local_static(did));\n                     assert!(self.ecx.tcx.is_static(did));\n@@ -546,7 +535,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // types below!\n                 if self.ctfe_mode.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n-                    let is_bits = value.check_init().map_or(false, |v| v.is_bits());\n+                    let is_bits = value.check_init().map_or(false, |v| v.try_to_int().is_ok());\n                     if !is_bits {\n                         throw_validation_failure!(self.path,\n                             { \"{}\", value } expected { \"initialized plain (non-pointer) bytes\" }\n@@ -601,12 +590,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // message below.\n                 let value = value.to_scalar_or_uninit();\n                 let _fn = try_validation!(\n-                    value.check_init().and_then(|ptr| self.ecx.memory.get_fn(ptr)),\n+                    value.check_init().and_then(|ptr| self.ecx.memory.get_fn(self.ecx.scalar_to_ptr(ptr))),\n                     self.path,\n                     err_ub!(DanglingIntPointer(..)) |\n                     err_ub!(InvalidFunctionPointer(..)) |\n-                    err_ub!(InvalidUninitBytes(None)) |\n-                    err_unsup!(ReadBytesAsPointer) =>\n+                    err_ub!(InvalidUninitBytes(None)) =>\n                         { \"{}\", value } expected { \"a function pointer\" },\n                 );\n                 // FIXME: Check if the signature matches\n@@ -664,8 +652,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             err_ub!(InvalidUninitBytes(None)) => { \"{}\", value }\n                 expected { \"something {}\", wrapping_range_format(valid_range, max_hi) },\n         );\n-        let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n-            Err(ptr) => {\n+        let bits = match value.try_to_int() {\n+            Err(_) => {\n+                // So this is a pointer then, and casting to an int failed.\n+                // Can only happen during CTFE.\n+                let ptr = self.ecx.scalar_to_ptr(value);\n                 if lo == 1 && hi == max_hi {\n                     // Only null is the niche.  So make sure the ptr is NOT null.\n                     if self.ecx.memory.ptr_may_be_null(ptr) {\n@@ -690,7 +681,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     )\n                 }\n             }\n-            Ok(data) => data,\n+            Ok(int) => int.assert_bits(op.layout.size),\n         };\n         // Now compare. This is slightly subtle because this is a special \"wrap-around\" range.\n         if wrapping_range_contains(&valid_range, bits) {\n@@ -832,7 +823,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     ) -> InterpResult<'tcx> {\n         match op.layout.ty.kind() {\n             ty::Str => {\n-                let mplace = op.assert_mem_place(self.ecx); // strings are never immediate\n+                let mplace = op.assert_mem_place(); // strings are never immediate\n                 let len = mplace.len(self.ecx)?;\n                 try_validation!(\n                     self.ecx.memory.read_bytes(mplace.ptr, Size::from_bytes(len)),\n@@ -853,7 +844,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // Optimized handling for arrays of integer/float type.\n \n                 // Arrays cannot be immediate, slices are never immediate.\n-                let mplace = op.assert_mem_place(self.ecx);\n+                let mplace = op.assert_mem_place();\n                 // This is the length of the array/slice.\n                 let len = mplace.len(self.ecx)?;\n                 // This is the element type size.\n@@ -940,9 +931,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Construct a visitor\n         let mut visitor = ValidityVisitor { path, ref_tracking, ctfe_mode, ecx: self };\n \n-        // Try to cast to ptr *once* instead of all the time.\n-        let op = self.force_op_ptr(&op).unwrap_or(*op);\n-\n         // Run it.\n         match visitor.visit_value(&op) {\n             Ok(()) => Ok(()),"}, {"sha": "679d30227f1366cb4e89b1b25ad9e923a6efc268", "filename": "compiler/rustc_mir/src/interpret/visitor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -211,7 +211,8 @@ macro_rules! make_value_visitor {\n                     // If it is a trait object, switch to the real type that was used to create it.\n                     ty::Dynamic(..) => {\n                         // immediate trait objects are not a thing\n-                        let dest = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n+                        let op = v.to_op(self.ecx())?;\n+                        let dest = op.assert_mem_place();\n                         let inner = self.ecx().unpack_dyn_trait(&dest)?.1;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n                         // recurse with the inner type\n@@ -241,7 +242,8 @@ macro_rules! make_value_visitor {\n                     },\n                     FieldsShape::Array { .. } => {\n                         // Let's get an mplace first.\n-                        let mplace = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n+                        let op = v.to_op(self.ecx())?;\n+                        let mplace = op.assert_mem_place();\n                         // Now we can go over all the fields.\n                         // This uses the *run-time length*, i.e., if we are a slice,\n                         // the dynamic info from the metadata is used."}, {"sha": "2ce7cf71116bbf9125ff8ba57777fcfcb093b2c6", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -403,7 +403,7 @@ fn collect_items_rec<'tcx>(\n             recursion_depth_reset = None;\n \n             if let Ok(alloc) = tcx.eval_static_initializer(def_id) {\n-                for &((), id) in alloc.relocations().values() {\n+                for &id in alloc.relocations().values() {\n                     collect_miri(tcx, id, &mut neighbors);\n                 }\n             }\n@@ -1369,7 +1369,7 @@ fn collect_miri<'tcx>(\n         }\n         GlobalAlloc::Memory(alloc) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n-            for &((), inner) in alloc.relocations().values() {\n+            for &inner in alloc.relocations().values() {\n                 rustc_data_structures::stack::ensure_sufficient_stack(|| {\n                     collect_miri(tcx, inner, output);\n                 });\n@@ -1402,9 +1402,9 @@ fn collect_const_value<'tcx>(\n     output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     match value {\n-        ConstValue::Scalar(Scalar::Ptr(ptr)) => collect_miri(tcx, ptr.alloc_id, output),\n+        ConstValue::Scalar(Scalar::Ptr(ptr, _size)) => collect_miri(tcx, ptr.provenance, output),\n         ConstValue::Slice { data: alloc, start: _, end: _ } | ConstValue::ByRef { alloc, .. } => {\n-            for &((), id) in alloc.relocations().values() {\n+            for &id in alloc.relocations().values() {\n                 collect_miri(tcx, id, output);\n             }\n         }"}, {"sha": "e02e41d62061a380dd70045ac07b57043f2753d2", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -31,9 +31,8 @@ use rustc_trait_selection::traits;\n use crate::const_eval::ConstEvalErr;\n use crate::interpret::{\n     self, compile_time_machine, AllocId, Allocation, ConstValue, CtfeValidationMode, Frame, ImmTy,\n-    Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy,\n-    Operand as InterpOperand, PlaceTy, Pointer, Scalar, ScalarMaybeUninit, StackPopCleanup,\n-    StackPopUnwind,\n+    Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, MemoryKind, OpTy,\n+    Operand as InterpOperand, PlaceTy, Scalar, ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n };\n use crate::transform::MirPass;\n \n@@ -157,7 +156,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n \n struct ConstPropMachine<'mir, 'tcx> {\n     /// The virtual call stack.\n-    stack: Vec<Frame<'mir, 'tcx, (), ()>>,\n+    stack: Vec<Frame<'mir, 'tcx>>,\n     /// `OnlyInsideOwnBlock` locals that were written in the current block get erased at the end.\n     written_only_inside_own_block_locals: FxHashSet<Local>,\n     /// Locals that need to be cleared after every block terminates.\n@@ -223,10 +222,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         bug!(\"panics terminators are not evaluated in ConstProp\")\n     }\n \n-    fn ptr_to_int(_mem: &Memory<'mir, 'tcx, Self>, _ptr: Pointer) -> InterpResult<'tcx, u64> {\n-        throw_unsup!(ReadPointerAsBytes)\n-    }\n-\n     fn binary_ptr_op(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _bin_op: BinOp,\n@@ -587,8 +582,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n             let right_size = r.layout.size;\n             let r_bits = r.to_scalar().ok();\n-            // This is basically `force_bits`.\n-            let r_bits = r_bits.and_then(|r| r.to_bits_or_ptr(right_size, &self.tcx).ok());\n+            let r_bits = r_bits.and_then(|r| r.to_bits(right_size).ok());\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n                 debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n                 self.report_assert_as_lint(\n@@ -759,8 +753,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                         }\n                     };\n \n-                    let arg_value =\n-                        this.ecx.force_bits(const_arg.to_scalar()?, const_arg.layout.size)?;\n+                    let arg_value = const_arg.to_scalar()?.to_bits(const_arg.layout.size)?;\n                     let dest = this.ecx.eval_place(place)?;\n \n                     match op {\n@@ -876,7 +869,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                                     let alloc = this\n                                         .ecx\n                                         .intern_with_temp_alloc(value.layout, |ecx, dest| {\n-                                            ecx.write_immediate_to_mplace(*imm, dest)\n+                                            ecx.write_immediate(*imm, dest)\n                                         })\n                                         .unwrap();\n                                     Ok(Some(alloc))\n@@ -928,12 +921,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         match **op {\n             interpret::Operand::Immediate(Immediate::Scalar(ScalarMaybeUninit::Scalar(s))) => {\n-                s.is_bits()\n+                s.try_to_int().is_ok()\n             }\n             interpret::Operand::Immediate(Immediate::ScalarPair(\n                 ScalarMaybeUninit::Scalar(l),\n                 ScalarMaybeUninit::Scalar(r),\n-            )) => l.is_bits() && r.is_bits(),\n+            )) => l.try_to_int().is_ok() && r.try_to_int().is_ok(),\n             _ => false,\n         }\n     }"}, {"sha": "1ddf7c9cd0c9e096c16b2fe73d9adb5d4aa762f3", "filename": "compiler/rustc_mir/src/transform/simplify_comparison_integral.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n                         .expect(\"if we have an evaluated constant we must know the layout\");\n                     int.assert_bits(layout.size)\n                 }\n-                Scalar::Ptr(_) => continue,\n+                Scalar::Ptr(..) => continue,\n             };\n             const FALSE: u128 = 0;\n \n@@ -211,7 +211,7 @@ fn find_branch_value_info<'tcx>(\n                 return None;\n             };\n             let branch_value_scalar = branch_value.literal.try_to_scalar()?;\n-            Some((branch_value_scalar, branch_value_ty, *to_switch_on))\n+            Some((branch_value_scalar.into(), branch_value_ty, *to_switch_on))\n         }\n         _ => None,\n     }"}, {"sha": "d0b1bc47ea80063cf6a7ea21651653915cebfc31", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -1,6 +1,6 @@\n use std::collections::BTreeSet;\n+use std::fmt::Display;\n use std::fmt::Write as _;\n-use std::fmt::{Debug, Display};\n use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n@@ -13,7 +13,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{\n-    read_target_uint, AllocId, Allocation, ConstValue, GlobalAlloc, Pointer,\n+    read_target_uint, AllocId, Allocation, ConstValue, GlobalAlloc, Pointer, Provenance,\n };\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n@@ -665,12 +665,12 @@ pub fn write_allocations<'tcx>(\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n     fn alloc_ids_from_alloc(alloc: &Allocation) -> impl DoubleEndedIterator<Item = AllocId> + '_ {\n-        alloc.relocations().values().map(|(_, id)| *id)\n+        alloc.relocations().values().map(|id| *id)\n     }\n     fn alloc_ids_from_const(val: ConstValue<'_>) -> impl Iterator<Item = AllocId> + '_ {\n         match val {\n-            ConstValue::Scalar(interpret::Scalar::Ptr(ptr)) => {\n-                Either::Left(Either::Left(std::iter::once(ptr.alloc_id)))\n+            ConstValue::Scalar(interpret::Scalar::Ptr(ptr, _size)) => {\n+                Either::Left(Either::Left(std::iter::once(ptr.provenance)))\n             }\n             ConstValue::Scalar(interpret::Scalar::Int { .. }) => {\n                 Either::Left(Either::Right(std::iter::empty()))\n@@ -755,7 +755,7 @@ pub fn write_allocations<'tcx>(\n /// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n /// characters or characters whose value is larger than 127) with a `.`\n /// This also prints relocations adequately.\n-pub fn display_allocation<Tag: Copy + Debug, Extra>(\n+pub fn display_allocation<Tag, Extra>(\n     tcx: TyCtxt<'tcx>,\n     alloc: &'a Allocation<Tag, Extra>,\n ) -> RenderAllocation<'a, 'tcx, Tag, Extra> {\n@@ -768,7 +768,7 @@ pub struct RenderAllocation<'a, 'tcx, Tag, Extra> {\n     alloc: &'a Allocation<Tag, Extra>,\n }\n \n-impl<Tag: Copy + Debug, Extra> std::fmt::Display for RenderAllocation<'a, 'tcx, Tag, Extra> {\n+impl<Tag: Provenance, Extra> std::fmt::Display for RenderAllocation<'a, 'tcx, Tag, Extra> {\n     fn fmt(&self, w: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         let RenderAllocation { tcx, alloc } = *self;\n         write!(w, \"size: {}, align: {})\", alloc.size().bytes(), alloc.align.bytes())?;\n@@ -811,7 +811,7 @@ fn write_allocation_newline(\n /// The `prefix` argument allows callers to add an arbitrary prefix before each line (even if there\n /// is only one line). Note that your prefix should contain a trailing space as the lines are\n /// printed directly after it.\n-fn write_allocation_bytes<Tag: Copy + Debug, Extra>(\n+fn write_allocation_bytes<Tag: Provenance, Extra>(\n     tcx: TyCtxt<'tcx>,\n     alloc: &Allocation<Tag, Extra>,\n     w: &mut dyn std::fmt::Write,\n@@ -847,15 +847,15 @@ fn write_allocation_bytes<Tag: Copy + Debug, Extra>(\n         if i != line_start {\n             write!(w, \" \")?;\n         }\n-        if let Some(&(tag, target_id)) = alloc.relocations().get(&i) {\n+        if let Some(&tag) = alloc.relocations().get(&i) {\n             // Memory with a relocation must be defined\n             let j = i.bytes_usize();\n             let offset = alloc\n                 .inspect_with_uninit_and_ptr_outside_interpreter(j..j + ptr_size.bytes_usize());\n             let offset = read_target_uint(tcx.data_layout.endian, offset).unwrap();\n             let offset = Size::from_bytes(offset);\n             let relocation_width = |bytes| bytes * 3;\n-            let ptr = Pointer::new_with_tag(target_id, offset, tag);\n+            let ptr = Pointer::new(tag, offset);\n             let mut target = format!(\"{:?}\", ptr);\n             if target.len() > relocation_width(ptr_size.bytes_usize() - 1) {\n                 // This is too long, try to save some space."}, {"sha": "f9e7b39f7049ce6ea86da0d9f73aac47fe02c62e", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -38,7 +38,7 @@ crate fn lit_to_const<'tcx>(\n         }\n         (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n             let id = tcx.allocate_bytes(data);\n-            ConstValue::Scalar(Scalar::Ptr(id.into()))\n+            ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n         }\n         (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n             ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))"}, {"sha": "c3908ddd4fbe85dfb2b813e1b9131a36baa7edda", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -928,7 +928,11 @@ impl<'tcx> Cx<'tcx> {\n                 } else {\n                     let ptr = self.tcx.create_static_alloc(id);\n                     ExprKind::StaticRef {\n-                        literal: ty::Const::from_scalar(self.tcx, Scalar::Ptr(ptr.into()), ty),\n+                        literal: ty::Const::from_scalar(\n+                            self.tcx,\n+                            Scalar::from_pointer(ptr.into(), &self.tcx),\n+                            ty,\n+                        ),\n                         def_id: id,\n                     }\n                 };"}, {"sha": "ace13ea44624d627b8959b0328e7e8310d15ba68", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -123,7 +123,7 @@ impl IntRange {\n                     // straight to the result, after doing a bit of checking. (We\n                     // could remove this branch and just fall through, which\n                     // is more general but much slower.)\n-                    if let Ok(bits) = scalar.to_bits_or_ptr(target_size, &tcx) {\n+                    if let Ok(bits) = scalar.to_bits_or_ptr_internal(target_size) {\n                         return Some(bits);\n                     }\n                 }"}, {"sha": "7f945299c22a6c9bb77fb8b39f9c797071da59d4", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -10,7 +10,7 @@\n // CHECK: @STATIC = {{.*}}, align 4\n \n // This checks the constants from inline_enum_const\n-// CHECK: @alloc8 = {{.*}}, align 2\n+// CHECK: @alloc9 = {{.*}}, align 2\n \n // This checks the constants from {low,high}_align_const, they share the same\n // constant, but the alignment differs, so the higher one should be used"}, {"sha": "698dfe6b4f3419e76f7770b06136dfe13e53294d", "filename": "src/test/codegen/remap_path_prefix/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -12,7 +12,7 @@ mod aux_mod;\n include!(\"aux_mod.rs\");\n \n // Here we check that the expansion of the file!() macro is mapped.\n-// CHECK: @alloc1 = private unnamed_addr constant <{ [34 x i8] }> <{ [34 x i8] c\"/the/src/remap_path_prefix/main.rs\" }>, align 1\n+// CHECK: @alloc2 = private unnamed_addr constant <{ [34 x i8] }> <{ [34 x i8] c\"/the/src/remap_path_prefix/main.rs\" }>, align 1\n pub static FILE_PATH: &'static str = file!();\n \n fn main() {"}, {"sha": "e22adae815c020816e7c9a1d740b4d45d6ae23ed", "filename": "src/test/mir-opt/byte_slice.main.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fbyte_slice.main.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fbyte_slice.main.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbyte_slice.main.SimplifyCfg-elaborate-drops.after.mir?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -16,10 +16,10 @@ fn main() -> () {\n         _1 = const b\"foo\";               // scope 0 at $DIR/byte_slice.rs:5:13: 5:19\n                                          // ty::Const\n                                          // + ty: &[u8; 3]\n-                                         // + val: Value(Scalar(alloc0))\n+                                         // + val: Value(Scalar(alloc1))\n                                          // mir::Constant\n                                          // + span: $DIR/byte_slice.rs:5:13: 5:19\n-                                         // + literal: Const { ty: &[u8; 3], val: Value(Scalar(alloc0)) }\n+                                         // + literal: Const { ty: &[u8; 3], val: Value(Scalar(alloc1)) }\n         StorageLive(_2);                 // scope 1 at $DIR/byte_slice.rs:6:9: 6:10\n         _2 = [const 5_u8, const 120_u8]; // scope 1 at $DIR/byte_slice.rs:6:13: 6:24\n         _0 = const ();                   // scope 0 at $DIR/byte_slice.rs:4:11: 7:2\n@@ -29,6 +29,6 @@ fn main() -> () {\n     }\n }\n \n-alloc0 (size: 3, align: 1) {\n+alloc1 (size: 3, align: 1) {\n     66 6f 6f                                        \u2502 foo\n }"}, {"sha": "8e02dca4fb8b6541694c546117efd7479b41ed99", "filename": "src/test/mir-opt/const_allocation.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -8,13 +8,13 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n         StorageLive(_2);                 // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n-        _2 = const {alloc0: &&[(Option<i32>, &[&str])]}; // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+        _2 = const {alloc1: &&[(Option<i32>, &[&str])]}; // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n                                          // ty::Const\n                                          // + ty: &&[(std::option::Option<i32>, &[&str])]\n-                                         // + val: Value(Scalar(alloc0))\n+                                         // + val: Value(Scalar(alloc1))\n                                          // mir::Constant\n                                          // + span: $DIR/const_allocation.rs:8:5: 8:8\n-                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&str])], val: Value(Scalar(alloc0)) }\n+                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&str])], val: Value(Scalar(alloc1)) }\n         _1 = (*_2);                      // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n         StorageDead(_2);                 // scope 0 at $DIR/const_allocation.rs:8:8: 8:9\n         StorageDead(_1);                 // scope 0 at $DIR/const_allocation.rs:8:8: 8:9\n@@ -23,43 +23,43 @@ fn main() -> () {\n     }\n }\n \n-alloc0 (static: FOO, size: 8, align: 4) {\n-    \u257e\u2500alloc17\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+alloc1 (static: FOO, size: 8, align: 4) {\n+    \u257e\u2500alloc18\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc17 (size: 48, align: 4) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc4\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc8\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc13\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+alloc18 (size: 48, align: 4) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc5\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc9\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc14\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n-alloc4 (size: 0, align: 4) {}\n+alloc5 (size: 0, align: 4) {}\n \n-alloc8 (size: 16, align: 4) {\n-    \u257e\u2500alloc7\u2500\u2500\u257c 03 00 00 00 \u257e\u2500alloc9\u2500\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+alloc9 (size: 16, align: 4) {\n+    \u257e\u2500alloc8\u2500\u2500\u257c 03 00 00 00 \u257e\u2500alloc10\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n }\n \n-alloc7 (size: 3, align: 1) {\n+alloc8 (size: 3, align: 1) {\n     66 6f 6f                                        \u2502 foo\n }\n \n-alloc9 (size: 3, align: 1) {\n+alloc10 (size: 3, align: 1) {\n     62 61 72                                        \u2502 bar\n }\n \n-alloc13 (size: 24, align: 4) {\n-    0x00 \u2502 \u257e\u2500alloc12\u2500\u257c 03 00 00 00 \u257e\u2500alloc14\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 \u257e\u2500alloc15\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+alloc14 (size: 24, align: 4) {\n+    0x00 \u2502 \u257e\u2500alloc13\u2500\u257c 03 00 00 00 \u257e\u2500alloc15\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 \u257e\u2500alloc16\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc12 (size: 3, align: 1) {\n+alloc13 (size: 3, align: 1) {\n     6d 65 68                                        \u2502 meh\n }\n \n-alloc14 (size: 3, align: 1) {\n+alloc15 (size: 3, align: 1) {\n     6d 6f 70                                        \u2502 mop\n }\n \n-alloc15 (size: 4, align: 1) {\n+alloc16 (size: 4, align: 1) {\n     6d c3 b6 70                                     \u2502 m..p\n }"}, {"sha": "88cdbda2fae36cbd28ccfa25c9cb86dc2914a5c4", "filename": "src/test/mir-opt/const_allocation.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -8,13 +8,13 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n         StorageLive(_2);                 // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n-        _2 = const {alloc0: &&[(Option<i32>, &[&str])]}; // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n+        _2 = const {alloc1: &&[(Option<i32>, &[&str])]}; // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n                                          // ty::Const\n                                          // + ty: &&[(std::option::Option<i32>, &[&str])]\n-                                         // + val: Value(Scalar(alloc0))\n+                                         // + val: Value(Scalar(alloc1))\n                                          // mir::Constant\n                                          // + span: $DIR/const_allocation.rs:8:5: 8:8\n-                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&str])], val: Value(Scalar(alloc0)) }\n+                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&str])], val: Value(Scalar(alloc1)) }\n         _1 = (*_2);                      // scope 0 at $DIR/const_allocation.rs:8:5: 8:8\n         StorageDead(_2);                 // scope 0 at $DIR/const_allocation.rs:8:8: 8:9\n         StorageDead(_1);                 // scope 0 at $DIR/const_allocation.rs:8:8: 8:9\n@@ -23,47 +23,47 @@ fn main() -> () {\n     }\n }\n \n-alloc0 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc17\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+alloc1 (static: FOO, size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc17 (size: 72, align: 8) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc18 (size: 72, align: 8) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc5\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc4 (size: 0, align: 8) {}\n+alloc5 (size: 0, align: 8) {}\n \n-alloc8 (size: 32, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+alloc9 (size: 32, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc7 (size: 3, align: 1) {\n+alloc8 (size: 3, align: 1) {\n     66 6f 6f                                        \u2502 foo\n }\n \n-alloc9 (size: 3, align: 1) {\n+alloc10 (size: 3, align: 1) {\n     62 61 72                                        \u2502 bar\n }\n \n-alloc13 (size: 48, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+alloc14 (size: 48, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc12 (size: 3, align: 1) {\n+alloc13 (size: 3, align: 1) {\n     6d 65 68                                        \u2502 meh\n }\n \n-alloc14 (size: 3, align: 1) {\n+alloc15 (size: 3, align: 1) {\n     6d 6f 70                                        \u2502 mop\n }\n \n-alloc15 (size: 4, align: 1) {\n+alloc16 (size: 4, align: 1) {\n     6d c3 b6 70                                     \u2502 m..p\n }"}, {"sha": "059b721f5bb6332d0d8ac8e70e609ae0e68e9fa5", "filename": "src/test/mir-opt/const_allocation2.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -8,13 +8,13 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n         StorageLive(_2);                 // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n-        _2 = const {alloc0: &&[(Option<i32>, &[&u8])]}; // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+        _2 = const {alloc1: &&[(Option<i32>, &[&u8])]}; // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n                                          // ty::Const\n                                          // + ty: &&[(std::option::Option<i32>, &[&u8])]\n-                                         // + val: Value(Scalar(alloc0))\n+                                         // + val: Value(Scalar(alloc1))\n                                          // mir::Constant\n                                          // + span: $DIR/const_allocation2.rs:5:5: 5:8\n-                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&u8])], val: Value(Scalar(alloc0)) }\n+                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&u8])], val: Value(Scalar(alloc1)) }\n         _1 = (*_2);                      // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n         StorageDead(_2);                 // scope 0 at $DIR/const_allocation2.rs:5:8: 5:9\n         StorageDead(_1);                 // scope 0 at $DIR/const_allocation2.rs:5:8: 5:9\n@@ -23,42 +23,42 @@ fn main() -> () {\n     }\n }\n \n-alloc0 (static: FOO, size: 8, align: 4) {\n-    \u257e\u2500alloc27\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+alloc1 (static: FOO, size: 8, align: 4) {\n+    \u257e\u2500alloc28\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc27 (size: 48, align: 4) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc12\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc17\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc25\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+alloc28 (size: 48, align: 4) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc13\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc18\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc26\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n-alloc12 (size: 0, align: 4) {}\n+alloc13 (size: 0, align: 4) {}\n \n-alloc17 (size: 8, align: 4) {\n-    \u257e\u2500alloc15\u2500\u257c \u257e\u2500alloc16\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc18 (size: 8, align: 4) {\n+    \u257e\u2500alloc16\u2500\u257c \u257e\u2500alloc17\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc15 (size: 1, align: 1) {\n+alloc16 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc16 (size: 1, align: 1) {\n+alloc17 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc25 (size: 12, align: 4) {\n-    \u257e\u2500a21+0x3\u2500\u257c \u257e\u2500alloc22\u2500\u257c \u257e\u2500a24+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc26 (size: 12, align: 4) {\n+    \u257e\u2500a22+0x3\u2500\u257c \u257e\u2500alloc23\u2500\u257c \u257e\u2500a25+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc21 (size: 4, align: 1) {\n+alloc22 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc22 (size: 1, align: 1) {\n+alloc23 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc24 (size: 4, align: 1) {\n+alloc25 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "d6a97917d6226c7f5aece75f866cbe85a12ca581", "filename": "src/test/mir-opt/const_allocation2.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -8,13 +8,13 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n         StorageLive(_2);                 // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n-        _2 = const {alloc0: &&[(Option<i32>, &[&u8])]}; // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n+        _2 = const {alloc1: &&[(Option<i32>, &[&u8])]}; // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n                                          // ty::Const\n                                          // + ty: &&[(std::option::Option<i32>, &[&u8])]\n-                                         // + val: Value(Scalar(alloc0))\n+                                         // + val: Value(Scalar(alloc1))\n                                          // mir::Constant\n                                          // + span: $DIR/const_allocation2.rs:5:5: 5:8\n-                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&u8])], val: Value(Scalar(alloc0)) }\n+                                         // + literal: Const { ty: &&[(std::option::Option<i32>, &[&u8])], val: Value(Scalar(alloc1)) }\n         _1 = (*_2);                      // scope 0 at $DIR/const_allocation2.rs:5:5: 5:8\n         StorageDead(_2);                 // scope 0 at $DIR/const_allocation2.rs:5:8: 5:9\n         StorageDead(_1);                 // scope 0 at $DIR/const_allocation2.rs:5:8: 5:9\n@@ -23,45 +23,45 @@ fn main() -> () {\n     }\n }\n \n-alloc0 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc27\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+alloc1 (static: FOO, size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc28\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc27 (size: 72, align: 8) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc28 (size: 72, align: 8) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc17\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc25\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc26\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc12 (size: 0, align: 8) {}\n+alloc13 (size: 0, align: 8) {}\n \n-alloc17 (size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc18 (size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc17\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc15 (size: 1, align: 1) {\n+alloc16 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc16 (size: 1, align: 1) {\n+alloc17 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc25 (size: 24, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc21+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc22\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc24+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc26 (size: 24, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc22+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc23\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc25+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc21 (size: 4, align: 1) {\n+alloc22 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc22 (size: 1, align: 1) {\n+alloc23 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc24 (size: 4, align: 1) {\n+alloc25 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "32000340dcebfc35a4bd434ea0fe3a2c7cb393e6", "filename": "src/test/mir-opt/const_allocation3.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -8,13 +8,13 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n         StorageLive(_2);                 // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n-        _2 = const {alloc0: &&Packed};   // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+        _2 = const {alloc1: &&Packed};   // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n                                          // ty::Const\n                                          // + ty: &&Packed\n-                                         // + val: Value(Scalar(alloc0))\n+                                         // + val: Value(Scalar(alloc1))\n                                          // mir::Constant\n                                          // + span: $DIR/const_allocation3.rs:5:5: 5:8\n-                                         // + literal: Const { ty: &&Packed, val: Value(Scalar(alloc0)) }\n+                                         // + literal: Const { ty: &&Packed, val: Value(Scalar(alloc1)) }\n         _1 = (*_2);                      // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n         StorageDead(_2);                 // scope 0 at $DIR/const_allocation3.rs:5:8: 5:9\n         StorageDead(_1);                 // scope 0 at $DIR/const_allocation3.rs:5:8: 5:9\n@@ -23,31 +23,31 @@ fn main() -> () {\n     }\n }\n \n-alloc0 (static: FOO, size: 4, align: 4) {\n-    \u257e\u2500alloc10\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+alloc1 (static: FOO, size: 4, align: 4) {\n+    \u257e\u2500alloc11\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n }\n \n-alloc10 (size: 168, align: 1) {\n+alloc11 (size: 168, align: 1) {\n     0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n-    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500alloc5\u2500\u2500\u257c \u2502 ............\u257e\u2500\u2500\u257c\n+    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500alloc6\u2500\u2500\u257c \u2502 ............\u257e\u2500\u2500\u257c\n     0x20 \u2502 01 ef cd ab 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x30 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x40 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x50 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x60 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x70 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n-    0x80 \u2502 00 00 00 00 00 00 00 00 00 00 \u257e\u2500alloc7\u2500\u2500\u257c 00 00 \u2502 ..........\u257e\u2500\u2500\u257c..\n-    0x90 \u2502 \u257e\u2500a8+0x63\u2500\u257c 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u257c............\n+    0x80 \u2502 00 00 00 00 00 00 00 00 00 00 \u257e\u2500alloc8\u2500\u2500\u257c 00 00 \u2502 ..........\u257e\u2500\u2500\u257c..\n+    0x90 \u2502 \u257e\u2500a9+0x63\u2500\u257c 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u257c............\n     0xa0 \u2502 00 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc5 (size: 4, align: 4) {\n+alloc6 (size: 4, align: 4) {\n     2a 00 00 00                                     \u2502 *...\n }\n \n-alloc7 (fn: main)\n+alloc8 (fn: main)\n \n-alloc8 (size: 100, align: 1) {\n+alloc9 (size: 100, align: 1) {\n     0x00 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x20 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................"}, {"sha": "cac882333aeb94debb5ea1a446f5bb613d8b7643", "filename": "src/test/mir-opt/const_allocation3.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -8,13 +8,13 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n         StorageLive(_2);                 // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n-        _2 = const {alloc0: &&Packed};   // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n+        _2 = const {alloc1: &&Packed};   // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n                                          // ty::Const\n                                          // + ty: &&Packed\n-                                         // + val: Value(Scalar(alloc0))\n+                                         // + val: Value(Scalar(alloc1))\n                                          // mir::Constant\n                                          // + span: $DIR/const_allocation3.rs:5:5: 5:8\n-                                         // + literal: Const { ty: &&Packed, val: Value(Scalar(alloc0)) }\n+                                         // + literal: Const { ty: &&Packed, val: Value(Scalar(alloc1)) }\n         _1 = (*_2);                      // scope 0 at $DIR/const_allocation3.rs:5:5: 5:8\n         StorageDead(_2);                 // scope 0 at $DIR/const_allocation3.rs:5:8: 5:9\n         StorageDead(_1);                 // scope 0 at $DIR/const_allocation3.rs:5:8: 5:9\n@@ -23,32 +23,32 @@ fn main() -> () {\n     }\n }\n \n-alloc0 (static: FOO, size: 8, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc1 (static: FOO, size: 8, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc11\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc10 (size: 180, align: 1) {\n+alloc11 (size: 180, align: 1) {\n     0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n-    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500\u2500alloc5\u2500\u2500 \u2502 ............\u257e\u2500\u2500\u2500\n+    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500\u2500alloc6\u2500\u2500 \u2502 ............\u257e\u2500\u2500\u2500\n     0x20 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 ef cd ab 00 00 00 00 00 00 00 00 \u2502 \u2500\u2500\u2500\u257c............\n     0x30 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x40 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x50 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x60 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x70 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x80 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u257e\u2500\u2500\u2500\u2500 \u2502 ..............\u257e\u2500\n-    0x90 \u2502 \u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u257c 00 00 \u257e\u2500\u2500\u2500\u2500\u2500alloc8+0x63\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u2500\u2500\u2500\u2500\u2500\u257c..\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x90 \u2502 \u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u257c 00 00 \u257e\u2500\u2500\u2500\u2500\u2500alloc9+0x63\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u2500\u2500\u2500\u2500\u2500\u257c..\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0xa0 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0xb0 \u2502 00 00 00 00                                     \u2502 ....\n }\n \n-alloc5 (size: 4, align: 4) {\n+alloc6 (size: 4, align: 4) {\n     2a 00 00 00                                     \u2502 *...\n }\n \n-alloc7 (fn: main)\n+alloc8 (fn: main)\n \n-alloc8 (size: 100, align: 1) {\n+alloc9 (size: 100, align: 1) {\n     0x00 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x20 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................"}, {"sha": "a64c960b9f716bf27f739eb6b3937c82f20fe164", "filename": "src/test/mir-opt/const_promotion_extern_static.BAR-promoted[0].SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.BAR-promoted%5B0%5D.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.BAR-promoted%5B0%5D.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.BAR-promoted%5B0%5D.SimplifyCfg-elaborate-drops.after.mir?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -7,20 +7,20 @@ promoted[0] in BAR: &[&i32; 1] = {\n     let mut _3: &i32;                    // in scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n \n     bb0: {\n-        _3 = const {alloc0: &i32};       // scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n+        _3 = const {alloc1: &i32};       // scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n                                          // ty::Const\n                                          // + ty: &i32\n-                                         // + val: Value(Scalar(alloc0))\n+                                         // + val: Value(Scalar(alloc1))\n                                          // mir::Constant\n                                          // + span: $DIR/const-promotion-extern-static.rs:9:33: 9:34\n-                                         // + literal: Const { ty: &i32, val: Value(Scalar(alloc0)) }\n+                                         // + literal: Const { ty: &i32, val: Value(Scalar(alloc1)) }\n         _2 = &(*_3);                     // scope 0 at $DIR/const-promotion-extern-static.rs:9:32: 9:34\n         _1 = [move _2];                  // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n         _0 = &_1;                        // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n         return;                          // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n     }\n }\n \n-alloc0 (static: Y, size: 4, align: 4) {\n+alloc1 (static: Y, size: 4, align: 4) {\n     2a 00 00 00                                     \u2502 *...\n }"}, {"sha": "6f4bd65b85d4d784f210dd403aa89eeeb11e6ffa", "filename": "src/test/mir-opt/const_promotion_extern_static.BAR.PromoteTemps.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.BAR.PromoteTemps.diff", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.BAR.PromoteTemps.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.BAR.PromoteTemps.diff?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -16,16 +16,16 @@\n -         StorageLive(_3);                 // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n -         StorageLive(_4);                 // scope 0 at $DIR/const-promotion-extern-static.rs:9:32: 9:34\n -         StorageLive(_5);                 // scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n--         _5 = const {alloc0: &i32};       // scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n+-         _5 = const {alloc1: &i32};       // scope 0 at $DIR/const-promotion-extern-static.rs:9:33: 9:34\n +         _6 = const BAR::promoted[0];     // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n                                            // ty::Const\n -                                          // + ty: &i32\n--                                          // + val: Value(Scalar(alloc0))\n+-                                          // + val: Value(Scalar(alloc1))\n +                                          // + ty: &[&i32; 1]\n +                                          // + val: Unevaluated(BAR, [], Some(promoted[0]))\n                                            // mir::Constant\n -                                          // + span: $DIR/const-promotion-extern-static.rs:9:33: 9:34\n--                                          // + literal: Const { ty: &i32, val: Value(Scalar(alloc0)) }\n+-                                          // + literal: Const { ty: &i32, val: Value(Scalar(alloc1)) }\n -         _4 = &(*_5);                     // scope 0 at $DIR/const-promotion-extern-static.rs:9:32: 9:34\n -         _3 = [move _4];                  // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n -         _2 = &_3;                        // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n@@ -53,7 +53,7 @@\n       }\n - }\n - \n-- alloc0 (static: Y, size: 4, align: 4) {\n+- alloc1 (static: Y, size: 4, align: 4) {\n -     2a 00 00 00                                     \u2502 *...\n   }\n   "}, {"sha": "8b3c5d332f2514ebfed3247cb93f5d2a22f7fbcb", "filename": "src/test/mir-opt/const_promotion_extern_static.FOO-promoted[0].SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.FOO-promoted%5B0%5D.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.FOO-promoted%5B0%5D.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.FOO-promoted%5B0%5D.SimplifyCfg-elaborate-drops.after.mir?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -7,18 +7,18 @@ promoted[0] in FOO: &[&i32; 1] = {\n     let mut _3: *const i32;              // in scope 0 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n \n     bb0: {\n-        _3 = const {alloc2: *const i32}; // scope 0 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n+        _3 = const {alloc3: *const i32}; // scope 0 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n                                          // ty::Const\n                                          // + ty: *const i32\n-                                         // + val: Value(Scalar(alloc2))\n+                                         // + val: Value(Scalar(alloc3))\n                                          // mir::Constant\n                                          // + span: $DIR/const-promotion-extern-static.rs:13:42: 13:43\n-                                         // + literal: Const { ty: *const i32, val: Value(Scalar(alloc2)) }\n+                                         // + literal: Const { ty: *const i32, val: Value(Scalar(alloc3)) }\n         _2 = &(*_3);                     // scope 0 at $DIR/const-promotion-extern-static.rs:13:41: 13:43\n         _1 = [move _2];                  // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n         _0 = &_1;                        // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n         return;                          // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n     }\n }\n \n-alloc2 (extern static: X)\n+alloc3 (extern static: X)"}, {"sha": "8c9a37bce854ba8c2db12d7066e2c8ed4054f128", "filename": "src/test/mir-opt/const_promotion_extern_static.FOO.PromoteTemps.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.FOO.PromoteTemps.diff", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.FOO.PromoteTemps.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.FOO.PromoteTemps.diff?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -18,16 +18,16 @@\n -         StorageLive(_3);                 // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n -         StorageLive(_4);                 // scope 0 at $DIR/const-promotion-extern-static.rs:13:32: 13:45\n -         StorageLive(_5);                 // scope 1 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n--         _5 = const {alloc2: *const i32}; // scope 1 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n+-         _5 = const {alloc3: *const i32}; // scope 1 at $DIR/const-promotion-extern-static.rs:13:42: 13:43\n +         _6 = const FOO::promoted[0];     // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n                                            // ty::Const\n -                                          // + ty: *const i32\n--                                          // + val: Value(Scalar(alloc2))\n+-                                          // + val: Value(Scalar(alloc3))\n +                                          // + ty: &[&i32; 1]\n +                                          // + val: Unevaluated(FOO, [], Some(promoted[0]))\n                                            // mir::Constant\n -                                          // + span: $DIR/const-promotion-extern-static.rs:13:42: 13:43\n--                                          // + literal: Const { ty: *const i32, val: Value(Scalar(alloc2)) }\n+-                                          // + literal: Const { ty: *const i32, val: Value(Scalar(alloc3)) }\n -         _4 = &(*_5);                     // scope 1 at $DIR/const-promotion-extern-static.rs:13:41: 13:43\n -         _3 = [move _4];                  // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n -         _2 = &_3;                        // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n@@ -55,5 +55,5 @@\n       }\n   }\n - \n-- alloc2 (extern static: X)\n+- alloc3 (extern static: X)\n   "}, {"sha": "afc621784633e5cf7f8670c59d386d30ce985a52", "filename": "src/test/mir-opt/const_prop/mutable_variable_no_prop.main.ConstProp.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_no_prop.main.ConstProp.diff?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -23,13 +23,13 @@\n           StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_no_prop.rs:8:5: 10:6\n           StorageLive(_3);                 // scope 2 at $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n           StorageLive(_4);                 // scope 2 at $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n-          _4 = const {alloc0: *mut u32};   // scope 2 at $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n+          _4 = const {alloc1: *mut u32};   // scope 2 at $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n                                            // ty::Const\n                                            // + ty: *mut u32\n-                                           // + val: Value(Scalar(alloc0))\n+                                           // + val: Value(Scalar(alloc1))\n                                            // mir::Constant\n                                            // + span: $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n-                                           // + literal: Const { ty: *mut u32, val: Value(Scalar(alloc0)) }\n+                                           // + literal: Const { ty: *mut u32, val: Value(Scalar(alloc1)) }\n           _3 = (*_4);                      // scope 2 at $DIR/mutable_variable_no_prop.rs:9:13: 9:19\n           _1 = move _3;                    // scope 2 at $DIR/mutable_variable_no_prop.rs:9:9: 9:19\n           StorageDead(_3);                 // scope 2 at $DIR/mutable_variable_no_prop.rs:9:18: 9:19\n@@ -45,7 +45,7 @@\n       }\n   }\n   \n-  alloc0 (static: STATIC, size: 4, align: 4) {\n+  alloc1 (static: STATIC, size: 4, align: 4) {\n       2a 00 00 00                                     \u2502 *...\n   }\n   "}, {"sha": "13ef30d89a076e89ef73b07a0f594f6a9028285f", "filename": "src/test/mir-opt/const_prop/read_immutable_static.main.ConstProp.diff", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.main.ConstProp.diff?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -16,24 +16,24 @@\n           StorageLive(_1);                 // scope 0 at $DIR/read_immutable_static.rs:7:9: 7:10\n           StorageLive(_2);                 // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:16\n           StorageLive(_3);                 // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:16\n-          _3 = const {alloc0: &u8};        // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:16\n+          _3 = const {alloc1: &u8};        // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:16\n                                            // ty::Const\n                                            // + ty: &u8\n-                                           // + val: Value(Scalar(alloc0))\n+                                           // + val: Value(Scalar(alloc1))\n                                            // mir::Constant\n                                            // + span: $DIR/read_immutable_static.rs:7:13: 7:16\n-                                           // + literal: Const { ty: &u8, val: Value(Scalar(alloc0)) }\n+                                           // + literal: Const { ty: &u8, val: Value(Scalar(alloc1)) }\n -         _2 = (*_3);                      // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:16\n +         _2 = const 2_u8;                 // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:16\n           StorageLive(_4);                 // scope 0 at $DIR/read_immutable_static.rs:7:19: 7:22\n           StorageLive(_5);                 // scope 0 at $DIR/read_immutable_static.rs:7:19: 7:22\n-          _5 = const {alloc0: &u8};        // scope 0 at $DIR/read_immutable_static.rs:7:19: 7:22\n+          _5 = const {alloc1: &u8};        // scope 0 at $DIR/read_immutable_static.rs:7:19: 7:22\n                                            // ty::Const\n                                            // + ty: &u8\n-                                           // + val: Value(Scalar(alloc0))\n+                                           // + val: Value(Scalar(alloc1))\n                                            // mir::Constant\n                                            // + span: $DIR/read_immutable_static.rs:7:19: 7:22\n-                                           // + literal: Const { ty: &u8, val: Value(Scalar(alloc0)) }\n+                                           // + literal: Const { ty: &u8, val: Value(Scalar(alloc1)) }\n -         _4 = (*_5);                      // scope 0 at $DIR/read_immutable_static.rs:7:19: 7:22\n -         _1 = Add(move _2, move _4);      // scope 0 at $DIR/read_immutable_static.rs:7:13: 7:22\n +         _4 = const 2_u8;                 // scope 0 at $DIR/read_immutable_static.rs:7:19: 7:22\n@@ -48,7 +48,7 @@\n       }\n   }\n   \n-  alloc0 (static: FOO, size: 1, align: 1) {\n+  alloc1 (static: FOO, size: 1, align: 1) {\n       02                                              \u2502 .\n   }\n   "}, {"sha": "92541779213a4e33e90286785f2ac7e490358626", "filename": "src/test/ui/const-ptr/out_of_bounds_read.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -4,7 +4,7 @@ error[E0080]: evaluation of constant value failed\n LL |     unsafe { copy_nonoverlapping(src, dst, count) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |              |\n-   |              memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n+   |              memory access failed: alloc7 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |              inside `copy_nonoverlapping::<u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    | \n   ::: $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n@@ -23,7 +23,7 @@ error[E0080]: evaluation of constant value failed\n LL |     unsafe { copy_nonoverlapping(src, dst, count) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |              |\n-   |              memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n+   |              memory access failed: alloc7 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |              inside `copy_nonoverlapping::<u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    | \n   ::: $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n@@ -47,7 +47,7 @@ error[E0080]: evaluation of constant value failed\n LL |     unsafe { copy_nonoverlapping(src, dst, count) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |              |\n-   |              memory access failed: pointer must be in-bounds at offset 8, but is outside bounds of alloc6 which has size 4\n+   |              memory access failed: alloc7 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |              inside `copy_nonoverlapping::<u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    | \n   ::: $SRC_DIR/core/src/ptr/mod.rs:LL:COL"}, {"sha": "5f23cc2311db0be75c7b1341c51d56134c3bef23", "filename": "src/test/ui/consts/const-eval/const-pointer-values-in-various-types.64bit.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -2,11 +2,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:26:5\n    |\n LL |     const I32_REF_USIZE_UNION: usize = unsafe { Nonsense { int_32_ref: &3 }.u };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc2, but expected initialized plain (non-pointer) bytes\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc3, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: any use of this value will cause an error\n@@ -47,11 +47,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:41:5\n    |\n LL |     const I32_REF_U64_UNION: u64 = unsafe { Nonsense { int_32_ref: &3 }.uint_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc18, but expected initialized plain (non-pointer) bytes\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc19, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc19\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -102,11 +102,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:59:5\n    |\n LL |     const I32_REF_I64_UNION: i64 = unsafe { Nonsense { int_32_ref: &3 }.int_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc38, but expected initialized plain (non-pointer) bytes\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc39, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc38\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc39\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -135,11 +135,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:69:5\n    |\n LL |     const I32_REF_F64_UNION: f64 = unsafe { Nonsense { int_32_ref: &3 }.float_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc50, but expected initialized plain (non-pointer) bytes\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc51, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc50\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc51\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: any use of this value will cause an error\n@@ -201,11 +201,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:92:5\n    |\n LL |     const STR_U64_UNION: u64 = unsafe { Nonsense { stringy: \"3\" }.uint_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc71, but expected initialized plain (non-pointer) bytes\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc72, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc71\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc72\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: any use of this value will cause an error\n@@ -256,11 +256,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:111:5\n    |\n LL |     const STR_I64_UNION: i64 = unsafe { Nonsense { stringy: \"3\" }.int_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc86, but expected initialized plain (non-pointer) bytes\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc87, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc86\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc87\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: any use of this value will cause an error\n@@ -289,11 +289,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:122:5\n    |\n LL |     const STR_F64_UNION: f64 = unsafe { Nonsense { stringy: \"3\" }.float_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc95, but expected initialized plain (non-pointer) bytes\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc96, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc95\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc96\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: any use of this value will cause an error"}, {"sha": "11f6a58be360ce96550a973884a357396f2006af", "filename": "src/test/ui/consts/const-eval/const_raw_ptr_ops2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops2.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -6,7 +6,7 @@ fn main() {}\n const Z: i32 = unsafe { *(&1 as *const i32) };\n \n // bad, will thus error in miri\n-const Z2: i32 = unsafe { *(42 as *const i32) }; //~ ERROR any use of this value will cause\n-//~| WARN this was previously accepted by the compiler but is being phased out\n-const Z3: i32 = unsafe { *(44 as *const i32) }; //~ ERROR any use of this value will cause\n-//~| WARN this was previously accepted by the compiler but is being phased out\n+const Z2: i32 = unsafe { *(42 as *const i32) }; //~ ERROR evaluation of constant value failed\n+//~| is not a valid pointer\n+const Z3: i32 = unsafe { *(44 as *const i32) }; //~ ERROR evaluation of constant value failed\n+//~| is not a valid pointer"}, {"sha": "ca3290077378a9edf8a7fb0a3135f9265f5b07a8", "filename": "src/test/ui/consts/const-eval/const_raw_ptr_ops2.stderr", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops2.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -1,25 +1,15 @@\n-error: any use of this value will cause an error\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/const_raw_ptr_ops2.rs:9:26\n    |\n LL | const Z2: i32 = unsafe { *(42 as *const i32) };\n-   | -------------------------^^^^^^^^^^^^^^^^^^^---\n-   |                          |\n-   |                          unable to turn bytes into a pointer\n-   |\n-   = note: `#[deny(const_err)]` on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   |                          ^^^^^^^^^^^^^^^^^^^ 0x2a is not a valid pointer\n \n-error: any use of this value will cause an error\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/const_raw_ptr_ops2.rs:11:26\n    |\n LL | const Z3: i32 = unsafe { *(44 as *const i32) };\n-   | -------------------------^^^^^^^^^^^^^^^^^^^---\n-   |                          |\n-   |                          unable to turn bytes into a pointer\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   |                          ^^^^^^^^^^^^^^^^^^^ 0x2c is not a valid pointer\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "c11fea8533d8517eeae0d68c4de907b4e43fc35d", "filename": "src/test/ui/consts/const-eval/heap/alloc_intrinsic_uninit.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_uninit.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_uninit.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_uninit.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -6,7 +6,7 @@ LL | const BAR: &i32 = unsafe { &*(intrinsics::const_allocate(4, 4) as *mut i32)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc1\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc2\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "58d24dc2e8e0be709bb71448529a50439574d875", "filename": "src/test/ui/consts/const-eval/heap/alloc_intrinsic_uninit.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_uninit.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_uninit.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_uninit.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -6,7 +6,7 @@ LL | const BAR: &i32 = unsafe { &*(intrinsics::const_allocate(4, 4) as *mut i32)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc1\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "4fd8e18909655bacc5bfbfc4022dcb7619d8b266", "filename": "src/test/ui/consts/const-eval/issue-49296.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -2,7 +2,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-49296.rs:19:16\n    |\n LL | const X: u64 = *wat(42);\n-   |                ^^^^^^^^ pointer to alloc1 was dereferenced after this allocation got freed\n+   |                ^^^^^^^^ pointer to alloc2 was dereferenced after this allocation got freed\n \n error: aborting due to previous error\n "}, {"sha": "ff90bb5fdd2423dbf0e866abdec69236bd5b7962", "filename": "src/test/ui/consts/const-eval/ref_to_int_match.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -2,11 +2,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ref_to_int_match.rs:26:1\n    |\n LL | const BAR: Int = unsafe { Foo { r: &42 }.f };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc2, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc3, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc2\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc3\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error: could not evaluate constant pattern"}, {"sha": "499c4536c4b661a9be0def683d1bfb2c0ef2811f", "filename": "src/test/ui/consts/const-eval/ref_to_int_match.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -2,11 +2,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ref_to_int_match.rs:26:1\n    |\n LL | const BAR: Int = unsafe { Foo { r: &42 }.f };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc2, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc3, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: could not evaluate constant pattern"}, {"sha": "850acb52b0c8987b9be23f7fade77904202b3c59", "filename": "src/test/ui/consts/const-eval/ub-enum.32bit.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -13,22 +13,22 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-tag>: encountered pointer to alloc8, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-tag>: encountered pointer to alloc9, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc8\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc9\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:30:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0.<enum-tag>: encountered pointer to alloc12, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0.<enum-tag>: encountered pointer to alloc13, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc12\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc13\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -46,22 +46,22 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:44:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-tag>: encountered pointer to alloc18, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-tag>: encountered pointer to alloc19, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc18\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc19\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:47:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0.<enum-tag>: encountered pointer to alloc22, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0.<enum-tag>: encountered pointer to alloc23, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc22\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc23\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -79,11 +79,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:60:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-tag>: encountered pointer to alloc28, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-tag>: encountered pointer to alloc29, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc28\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc29\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value"}, {"sha": "4f7dd5cdf7c733c91973e4d8a552b0620d22cd85", "filename": "src/test/ui/consts/const-eval/ub-enum.64bit.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -13,22 +13,22 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-tag>: encountered pointer to alloc8, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-tag>: encountered pointer to alloc9, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:30:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0.<enum-tag>: encountered pointer to alloc12, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0.<enum-tag>: encountered pointer to alloc13, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -46,22 +46,22 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:44:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-tag>: encountered pointer to alloc18, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-tag>: encountered pointer to alloc19, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc19\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:47:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0.<enum-tag>: encountered pointer to alloc22, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0.<enum-tag>: encountered pointer to alloc23, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc22\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc23\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -79,11 +79,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:60:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-tag>: encountered pointer to alloc28, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-tag>: encountered pointer to alloc29, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc28\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc29\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value"}, {"sha": "e44f324945481e2f84cc695315d701aecd25078e", "filename": "src/test/ui/consts/const-eval/ub-nonnull.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -13,7 +13,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-nonnull.rs:19:30\n    |\n LL |     let out_of_bounds_ptr = &ptr[255];\n-   |                              ^^^^^^^^ memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of alloc10 which has size 1\n+   |                              ^^^^^^^^ dereferencing pointer failed: alloc11 has size 1, so pointer to 256 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-nonnull.rs:23:1"}, {"sha": "1ce87bc7c1ce87a4e22b3c66578373ff1b11703e", "filename": "src/test/ui/consts/const-eval/ub-nonnull.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -13,7 +13,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-nonnull.rs:19:30\n    |\n LL |     let out_of_bounds_ptr = &ptr[255];\n-   |                              ^^^^^^^^ memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of alloc10 which has size 1\n+   |                              ^^^^^^^^ dereferencing pointer failed: alloc11 has size 1, so pointer to 256 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-nonnull.rs:23:1"}, {"sha": "c8ec7cc4875a53ea098b3534243e48792cd72f69", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -6,7 +6,7 @@ LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc2\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc3\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -17,7 +17,7 @@ LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc6\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc7\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -46,11 +46,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:30:1\n    |\n LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc14, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc15, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc14\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc15\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -61,7 +61,7 @@ LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc20\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc21\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -72,14 +72,14 @@ LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[us\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc25\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc26\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:39:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (created from integer)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (address 0x539 is unallocated)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n@@ -90,7 +90,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:42:1\n    |\n LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (created from integer)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (address 0x539 is unallocated)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "60a174ac5a7f61421a3fc583465248c96fe222d1", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -6,7 +6,7 @@ LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -17,7 +17,7 @@ LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -46,11 +46,11 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:30:1\n    |\n LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc14, but expected initialized plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer to alloc15, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -61,7 +61,7 @@ LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc20\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc21\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -72,14 +72,14 @@ LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[us\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc25\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc26\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:39:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (created from integer)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (address 0x539 is unallocated)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n@@ -90,7 +90,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:42:1\n    |\n LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (created from integer)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (address 0x539 is unallocated)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {"}, {"sha": "27b98c2547ce7eab9154c69ae5ba0bd95c6b3b38", "filename": "src/test/ui/consts/const-eval/ub-upvars.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -10,7 +10,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc2\u2500\u2500\u257c \u257e\u2500alloc5\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc3\u2500\u2500\u257c \u257e\u2500alloc6\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "9cc9fb59bd7f076bffdb7a99cb51fdc341eaf3c0", "filename": "src/test/ui/consts/const-eval/ub-upvars.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -10,7 +10,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc5\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "2a489e8b69c8f70a7fe2a9b8c327cd9289ae7ac4", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -302,7 +302,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/ub-wide-ptr.rs:139:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: pointer must be in-bounds at offset N, but is outside bounds of allocN which has size N\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: allocN has size N, so pointer to 12 bytes starting at offset N is out-of-bounds\n \n error: aborting due to 28 previous errors\n "}, {"sha": "ff850d2dbe9a0aa2cb072ade07eefda59c98d110", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -302,7 +302,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/ub-wide-ptr.rs:139:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: pointer must be in-bounds at offset N, but is outside bounds of allocN which has size N\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: allocN has size N, so pointer to 24 bytes starting at offset N is out-of-bounds\n \n error: aborting due to 28 previous errors\n "}, {"sha": "a9411fb0e3d4c23c726540be5dc9879a6321541d", "filename": "src/test/ui/consts/const-mut-refs/issue-76510.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -27,7 +27,7 @@ LL | const S: &'static mut str = &mut \" hello \";\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc2\u2500\u2500\u257c 07 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257e\u2500alloc3\u2500\u2500\u257c 07 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error: aborting due to 4 previous errors"}, {"sha": "9ad5f20d57cb2f2ea7b73a583fc599f6b40efa28", "filename": "src/test/ui/consts/const-mut-refs/issue-76510.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fissue-76510.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -27,7 +27,7 @@ LL | const S: &'static mut str = &mut \" hello \";\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 07 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 07 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error: aborting due to 4 previous errors"}, {"sha": "24d7bc49147d89df6f825b806763cbfb5f46eb63", "filename": "src/test/ui/consts/const-mut-refs/mut_ref_in_final_dynamic_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final_dynamic_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final_dynamic_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final_dynamic_check.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -11,8 +11,8 @@\n const fn helper() -> Option<&'static mut i32> { unsafe {\n     // Undefined behaviour (integer as pointer), who doesn't love tests like this.\n     // This code never gets executed, because the static checks fail before that.\n-    Some(&mut *(42 as *mut i32)) //~ ERROR any use of this value will cause an error\n-    //~| WARN this was previously accepted by the compiler but is being phased out\n+    Some(&mut *(42 as *mut i32)) //~ ERROR evaluation of constant value failed\n+    //~| 0x2a is not a valid pointer\n } }\n // The error is an evaluation error and not a validation error, so the error is reported\n // directly at the site where it occurs."}, {"sha": "b3fcd6a7fecd3d508239c744e174fa7372c5b187", "filename": "src/test/ui/consts/const-mut-refs/mut_ref_in_final_dynamic_check.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final_dynamic_check.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final_dynamic_check.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final_dynamic_check.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -1,19 +1,14 @@\n-error: any use of this value will cause an error\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/mut_ref_in_final_dynamic_check.rs:14:10\n    |\n LL |     Some(&mut *(42 as *mut i32))\n    |          ^^^^^^^^^^^^^^^^^^^^^^\n    |          |\n-   |          unable to turn bytes into a pointer\n+   |          0x2a is not a valid pointer\n    |          inside `helper` at $DIR/mut_ref_in_final_dynamic_check.rs:14:10\n-   |          inside `A` at $DIR/mut_ref_in_final_dynamic_check.rs:19:29\n ...\n LL | const A: Option<&mut i32> = helper();\n-   | -------------------------------------\n-   |\n-   = note: `#[deny(const_err)]` on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   |                             -------- inside `A` at $DIR/mut_ref_in_final_dynamic_check.rs:19:29\n \n error: encountered dangling pointer in final constant\n   --> $DIR/mut_ref_in_final_dynamic_check.rs:26:1\n@@ -23,3 +18,4 @@ LL | const B: Option<&mut i32> = helper2();\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "78af2c30d0437091b1b29d12abfaa50d3d3df0e2", "filename": "src/test/ui/consts/const-points-to-static.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -6,7 +6,7 @@ LL | const TEST: &u8 = &MY_STATIC;\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc0\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc1\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n warning: skipping const checks"}, {"sha": "f5a0a6b0addef7810f209b23111e43480aa807df", "filename": "src/test/ui/consts/const-points-to-static.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -6,7 +6,7 @@ LL | const TEST: &u8 = &MY_STATIC;\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc1\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n warning: skipping const checks"}, {"sha": "124e16e2b2c0f0cb9410c9199ce1f705c2352441", "filename": "src/test/ui/consts/copy-intrinsic.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fcopy-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fcopy-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcopy-intrinsic.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -24,20 +24,21 @@ const COPY_OOB_1: () = unsafe {\n     let mut x = 0i32;\n     let dangle = (&mut x as *mut i32).wrapping_add(10);\n     // Even if the first ptr is an int ptr and this is a ZST copy, we should detect dangling 2nd ptrs.\n-    copy_nonoverlapping(0x100 as *const i32, dangle, 0); //~ evaluation of constant value failed [E0080]\n+    copy_nonoverlapping(0x100 as *const i32, dangle, 0); //~ ERROR evaluation of constant value failed [E0080]\n+    //~| pointer at offset 40 is out-of-bounds\n };\n const COPY_OOB_2: () = unsafe {\n     let x = 0i32;\n     let dangle = (&x as *const i32).wrapping_add(10);\n     // Even if the second ptr is an int ptr and this is a ZST copy, we should detect dangling 1st ptrs.\n-    copy_nonoverlapping(dangle, 0x100 as *mut i32, 0); //~ evaluation of constant value failed [E0080]\n-    //~| memory access failed: pointer must be in-bounds\n+    copy_nonoverlapping(dangle, 0x100 as *mut i32, 0); //~ ERROR evaluation of constant value failed [E0080]\n+    //~| pointer at offset 40 is out-of-bounds\n };\n \n const COPY_SIZE_OVERFLOW: () = unsafe {\n     let x = 0;\n     let mut y = 0;\n-    copy(&x, &mut y, 1usize << (mem::size_of::<usize>() * 8 - 1)); //~ evaluation of constant value failed [E0080]\n+    copy(&x, &mut y, 1usize << (mem::size_of::<usize>() * 8 - 1)); //~ ERROR evaluation of constant value failed [E0080]\n     //~| overflow computing total size of `copy`\n };\n const COPY_NONOVERLAPPING_SIZE_OVERFLOW: () = unsafe {"}, {"sha": "be41c2db398bebfde848dc5530770c1a3b7ce4a3", "filename": "src/test/ui/consts/copy-intrinsic.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fcopy-intrinsic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fcopy-intrinsic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcopy-intrinsic.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -2,22 +2,22 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/copy-intrinsic.rs:27:5\n    |\n LL |     copy_nonoverlapping(0x100 as *const i32, dangle, 0);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: pointer must be in-bounds at offset 40, but is outside bounds of alloc4 which has size 4\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: alloc5 has size 4, so pointer at offset 40 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/copy-intrinsic.rs:33:5\n+  --> $DIR/copy-intrinsic.rs:34:5\n    |\n LL |     copy_nonoverlapping(dangle, 0x100 as *mut i32, 0);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: pointer must be in-bounds at offset 40, but is outside bounds of alloc6 which has size 4\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: alloc7 has size 4, so pointer at offset 40 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/copy-intrinsic.rs:40:5\n+  --> $DIR/copy-intrinsic.rs:41:5\n    |\n LL |     copy(&x, &mut y, 1usize << (mem::size_of::<usize>() * 8 - 1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ overflow computing total size of `copy`\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/copy-intrinsic.rs:46:5\n+  --> $DIR/copy-intrinsic.rs:47:5\n    |\n LL |     copy_nonoverlapping(&x, &mut y, 1usize << (mem::size_of::<usize>() * 8 - 1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ overflow computing total size of `copy_nonoverlapping`"}, {"sha": "6a6097d5ec6238cf15b568ad6ec3bae80adaed21", "filename": "src/test/ui/consts/issue-63952.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -12,7 +12,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc3\u2500\u2500\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257e\u2500alloc4\u2500\u2500\u257c ff ff ff ff                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error: aborting due to previous error"}, {"sha": "6547c3384da8291ac06cca40565916e025d3fef9", "filename": "src/test/ui/consts/issue-63952.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -12,7 +12,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c ff ff ff ff ff ff ff ff \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error: aborting due to previous error"}, {"sha": "bf0ef9e6dc07e966843556b1938f5809d1787ae3", "filename": "src/test/ui/consts/issue-79690.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fissue-79690.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fissue-79690.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-79690.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -6,7 +6,7 @@ LL | const G: Fat = unsafe { Transmute { t: FOO }.u };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc5\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: aborting due to previous error"}, {"sha": "a15668d4ec1b955a73b3b52424847691b9a527cf", "filename": "src/test/ui/consts/issue-83182.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -6,7 +6,7 @@ LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc3\u2500\u2500\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+               \u257e\u2500alloc4\u2500\u2500\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n error: aborting due to previous error"}, {"sha": "5c3ade7c1de44115861e001267349bb8a033395c", "filename": "src/test/ui/consts/issue-83182.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -6,7 +6,7 @@ LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n error: aborting due to previous error"}, {"sha": "1a6ed0f43b0f1d0581a03e8cc167a328f3b56d0c", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static2.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -10,7 +10,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc0\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc1\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -25,7 +25,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc1\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc2\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n warning: skipping const checks"}, {"sha": "4f268dd905d03d9aae102ea6890d27c3effe3867", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static2.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static2.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -10,7 +10,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc1\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -25,7 +25,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc1\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n warning: skipping const checks"}, {"sha": "64a1214e8bf1b06995039b00c38f9c827c3923b9", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static_cross_crate.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -9,7 +9,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc0\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc1\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error: could not evaluate constant pattern\n@@ -29,7 +29,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc0\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc1\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error: could not evaluate constant pattern"}, {"sha": "66fe4ec076005eabab019bc48fba0edea4700ffc", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static_cross_crate.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -9,7 +9,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc1\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: could not evaluate constant pattern\n@@ -29,7 +29,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc1\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error: could not evaluate constant pattern"}, {"sha": "9d1bb2ac91c49d48b9d953a935b1797025e3ab2b", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.32bit.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.32bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -8,7 +8,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc2\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc3\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -19,7 +19,7 @@ LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n-               \u257e\u2500alloc6\u2500\u2500\u257c \u257e\u2500alloc8\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc7\u2500\u2500\u257c \u257e\u2500alloc9\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -30,7 +30,7 @@ LL | const BLUNT: &mut i32 = &mut 42;\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500alloc10\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257e\u2500alloc11\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n warning: skipping const checks"}, {"sha": "fe939c039318966adc5b4a174746a12c8b1c43d9", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.64bit.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.64bit.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -8,7 +8,7 @@ LL | | };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -19,7 +19,7 @@ LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n@@ -30,7 +30,7 @@ LL | const BLUNT: &mut i32 = &mut 42;\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc11\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n warning: skipping const checks"}, {"sha": "22314160c5e89e5a839696ddb295ee2fa954246a", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -8,14 +8,21 @@ static CMP: () = {\n     let x = &0 as *const _;\n     let _v = x == x;\n     //~^ ERROR could not evaluate static initializer\n-    //~| NOTE pointer arithmetic or comparison\n+    //~| \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n };\n \n-static INT_PTR_ARITH: () = unsafe {\n+static PTR_INT_CAST: () = {\n+    let x = &0 as *const _ as usize;\n+    //~^ ERROR could not evaluate static initializer\n+    //~| unable to turn pointer into raw bytes\n+    let _v = x == x;\n+};\n+\n+static PTR_INT_TRANSMUTE: () = unsafe {\n     let x: usize = std::mem::transmute(&0);\n     let _v = x + 0;\n     //~^ ERROR could not evaluate static initializer\n-    //~| NOTE cannot cast pointer to integer\n+    //~| unable to turn pointer into raw bytes\n };\n \n fn main() {}"}, {"sha": "2764d10348a761689260ea58f83f9b270ba23aef", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -5,10 +5,16 @@ LL |     let _v = x == x;\n    |              ^^^^^^ \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ptr_arith.rs:16:14\n+  --> $DIR/ptr_arith.rs:15:13\n+   |\n+LL |     let x = &0 as *const _ as usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/ptr_arith.rs:23:14\n    |\n LL |     let _v = x + 0;\n-   |              ^^^^^ cannot cast pointer to integer because it was not created by cast from integer\n+   |              ^^^^^ unable to turn pointer into raw bytes\n \n warning: skipping const checks\n    |\n@@ -17,7 +23,12 @@ help: skipping check that does not even have a feature gate\n    |\n LL |     let _v = x == x;\n    |              ^^^^^^\n+help: skipping check that does not even have a feature gate\n+  --> $DIR/ptr_arith.rs:15:13\n+   |\n+LL |     let x = &0 as *const _ as usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors; 1 warning emitted\n+error: aborting due to 3 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "4b55c299b5c4c93901bd44cc47acbdb8a73992bf", "filename": "src/test/ui/consts/offset_from_ub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -41,8 +41,8 @@ pub const OFFSET_FROM_NULL: isize = {\n pub const DIFFERENT_INT: isize = { // offset_from with two different integers: like DIFFERENT_ALLOC\n     let ptr1 = 8 as *const u8;\n     let ptr2 = 16 as *const u8;\n-    unsafe { ptr_offset_from(ptr2, ptr1) } //~ERROR any use of this value will cause an error\n-    //~| WARN previously accepted\n+    unsafe { ptr_offset_from(ptr2, ptr1) } //~ERROR evaluation of constant value failed\n+    //~| 0x10 is not a valid pointer\n };\n \n fn main() {}"}, {"sha": "663bfbdade0ce932c660dadb1203daec2d16eee1", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -4,26 +4,19 @@ error[E0080]: evaluation of constant value failed\n LL |     let offset = unsafe { ptr_offset_from(field_ptr, base_ptr) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from cannot compute offset of pointers into different allocations.\n \n-error: any use of this value will cause an error\n+error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                    |\n-   |                    unable to turn bytes into a pointer\n-   |                    inside `ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |                    inside `NOT_PTR` at $DIR/offset_from_ub.rs:24:14\n+LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  0x2a is not a valid pointer\n+   |                  inside `ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    | \n-  ::: $DIR/offset_from_ub.rs:23:1\n-   |\n-LL | / pub const NOT_PTR: usize = {\n-LL | |     unsafe { (42 as *const u8).offset_from(&5u8) as usize }\n-LL | | };\n-   | |__-\n+  ::: $DIR/offset_from_ub.rs:24:14\n    |\n-   = note: `#[deny(const_err)]` on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+LL |     unsafe { (42 as *const u8).offset_from(&5u8) as usize }\n+   |              ----------------------------------- inside `NOT_PTR` at $DIR/offset_from_ub.rs:24:14\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:31:14\n@@ -37,20 +30,11 @@ error[E0080]: evaluation of constant value failed\n LL |     unsafe { ptr_offset_from(ptr, ptr) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^ null pointer is not a valid pointer for this operation\n \n-error: any use of this value will cause an error\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:44:14\n    |\n-LL | / pub const DIFFERENT_INT: isize = { // offset_from with two different integers: like DIFFERENT_ALLOC\n-LL | |     let ptr1 = 8 as *const u8;\n-LL | |     let ptr2 = 16 as *const u8;\n-LL | |     unsafe { ptr_offset_from(ptr2, ptr1) }\n-   | |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn bytes into a pointer\n-LL | |\n-LL | | };\n-   | |__-\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+LL |     unsafe { ptr_offset_from(ptr2, ptr1) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ 0x10 is not a valid pointer\n \n error: aborting due to 5 previous errors\n "}, {"sha": "a22296a7b0085c0d89a4ef5863be03db353d3cb8", "filename": "src/test/ui/consts/offset_ub.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -2,6 +2,8 @@\n use std::ptr;\n \n // normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n+// normalize-stderr-test \"0x7f+\" -> \"0x7f..f\"\n+\n \n pub const BEFORE_START: *const u8 = unsafe { (&0u8 as *const u8).offset(-1) }; //~NOTE\n pub const AFTER_END: *const u8 = unsafe { (&0u8 as *const u8).offset(2) }; //~NOTE"}, {"sha": "4f7c4f92060a24352fbd799251f2487fd7880413", "filename": "src/test/ui/consts/offset_ub.stderr", "status": "modified", "additions": 29, "deletions": 38, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -7,38 +7,38 @@ LL |         unsafe { intrinsics::offset(self, count) }\n    |                  overflowing in-bounds pointer arithmetic\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    | \n-  ::: $DIR/offset_ub.rs:6:46\n+  ::: $DIR/offset_ub.rs:8:46\n    |\n LL | pub const BEFORE_START: *const u8 = unsafe { (&0u8 as *const u8).offset(-1) };\n-   |                                              ------------------------------ inside `BEFORE_START` at $DIR/offset_ub.rs:6:46\n+   |                                              ------------------------------ inside `BEFORE_START` at $DIR/offset_ub.rs:8:46\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  pointer arithmetic failed: pointer must be in-bounds at offset 2, but is outside bounds of allocN which has size 1\n+   |                  pointer arithmetic failed: allocN has size 1, so pointer to 2 bytes starting at offset 0 is out-of-bounds\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    | \n-  ::: $DIR/offset_ub.rs:7:43\n+  ::: $DIR/offset_ub.rs:9:43\n    |\n LL | pub const AFTER_END: *const u8 = unsafe { (&0u8 as *const u8).offset(2) };\n-   |                                           ----------------------------- inside `AFTER_END` at $DIR/offset_ub.rs:7:43\n+   |                                           ----------------------------- inside `AFTER_END` at $DIR/offset_ub.rs:9:43\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  pointer arithmetic failed: pointer must be in-bounds at offset 101, but is outside bounds of allocN which has size 100\n+   |                  pointer arithmetic failed: allocN has size 100, so pointer to 101 bytes starting at offset 0 is out-of-bounds\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    | \n-  ::: $DIR/offset_ub.rs:8:45\n+  ::: $DIR/offset_ub.rs:10:45\n    |\n LL | pub const AFTER_ARRAY: *const u8 = unsafe { [0u8; 100].as_ptr().offset(101) };\n-   |                                             ------------------------------- inside `AFTER_ARRAY` at $DIR/offset_ub.rs:8:45\n+   |                                             ------------------------------- inside `AFTER_ARRAY` at $DIR/offset_ub.rs:10:45\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -49,10 +49,10 @@ LL |         unsafe { intrinsics::offset(self, count) }\n    |                  overflowing in-bounds pointer arithmetic\n    |                  inside `ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    | \n-  ::: $DIR/offset_ub.rs:10:43\n+  ::: $DIR/offset_ub.rs:12:43\n    |\n LL | pub const OVERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MAX) };\n-   |                                           ------------------------------------- inside `OVERFLOW` at $DIR/offset_ub.rs:10:43\n+   |                                           ------------------------------------- inside `OVERFLOW` at $DIR/offset_ub.rs:12:43\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -63,10 +63,10 @@ LL |         unsafe { intrinsics::offset(self, count) }\n    |                  overflowing in-bounds pointer arithmetic\n    |                  inside `ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    | \n-  ::: $DIR/offset_ub.rs:11:44\n+  ::: $DIR/offset_ub.rs:13:44\n    |\n LL | pub const UNDERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MIN) };\n-   |                                            ------------------------------------- inside `UNDERFLOW` at $DIR/offset_ub.rs:11:44\n+   |                                            ------------------------------------- inside `UNDERFLOW` at $DIR/offset_ub.rs:13:44\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -77,10 +77,10 @@ LL |         unsafe { intrinsics::offset(self, count) }\n    |                  overflowing in-bounds pointer arithmetic\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    | \n-  ::: $DIR/offset_ub.rs:12:56\n+  ::: $DIR/offset_ub.rs:14:56\n    |\n LL | pub const OVERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (usize::MAX as *const u8).offset(2) };\n-   |                                                        ----------------------------------- inside `OVERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:12:56\n+   |                                                        ----------------------------------- inside `OVERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:14:56\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -91,43 +91,38 @@ LL |         unsafe { intrinsics::offset(self, count) }\n    |                  overflowing in-bounds pointer arithmetic\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    | \n-  ::: $DIR/offset_ub.rs:13:57\n+  ::: $DIR/offset_ub.rs:15:57\n    |\n LL | pub const UNDERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (1 as *const u8).offset(-2) };\n-   |                                                         --------------------------- inside `UNDERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:13:57\n+   |                                                         --------------------------- inside `UNDERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:15:57\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  pointer arithmetic failed: pointer must be in-bounds at offset 1, but is outside bounds of allocN which has size 0\n+   |                  pointer arithmetic failed: allocN has size 0, so pointer to 1 bytes starting at offset 0 is out-of-bounds\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    | \n-  ::: $DIR/offset_ub.rs:15:50\n+  ::: $DIR/offset_ub.rs:17:50\n    |\n LL | pub const ZERO_SIZED_ALLOC: *const u8 = unsafe { [0u8; 0].as_ptr().offset(1) };\n-   |                                                  --------------------------- inside `ZERO_SIZED_ALLOC` at $DIR/offset_ub.rs:15:50\n+   |                                                  --------------------------- inside `ZERO_SIZED_ALLOC` at $DIR/offset_ub.rs:17:50\n \n-error: any use of this value will cause an error\n+error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::offset(self, count) as *mut T }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  unable to turn bytes into a pointer\n+   |                  0x1 is not a valid pointer\n    |                  inside `ptr::mut_ptr::<impl *mut u8>::offset` at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-   |                  inside `DANGLING` at $DIR/offset_ub.rs:16:42\n    | \n-  ::: $DIR/offset_ub.rs:16:1\n+  ::: $DIR/offset_ub.rs:18:42\n    |\n LL | pub const DANGLING: *const u8 = unsafe { ptr::NonNull::<u8>::dangling().as_ptr().offset(4) };\n-   | ---------------------------------------------------------------------------------------------\n-   |\n-   = note: `#[deny(const_err)]` on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   |                                          ------------------------------------------------- inside `DANGLING` at $DIR/offset_ub.rs:18:42\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -138,28 +133,24 @@ LL |         unsafe { intrinsics::offset(self, count) }\n    |                  pointer arithmetic failed: 0x0 is not a valid pointer\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    | \n-  ::: $DIR/offset_ub.rs:19:50\n+  ::: $DIR/offset_ub.rs:21:50\n    |\n LL | pub const NULL_OFFSET_ZERO: *const u8 = unsafe { ptr::null::<u8>().offset(0) };\n-   |                                                  --------------------------- inside `NULL_OFFSET_ZERO` at $DIR/offset_ub.rs:19:50\n+   |                                                  --------------------------- inside `NULL_OFFSET_ZERO` at $DIR/offset_ub.rs:21:50\n \n-error: any use of this value will cause an error\n+error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  unable to turn bytes into a pointer\n+   |                  0x7f..f is not a valid pointer\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |                  inside `UNDERFLOW_ABS` at $DIR/offset_ub.rs:22:47\n    | \n-  ::: $DIR/offset_ub.rs:22:1\n+  ::: $DIR/offset_ub.rs:24:47\n    |\n LL | pub const UNDERFLOW_ABS: *const u8 = unsafe { (usize::MAX as *const u8).offset(isize::MIN) };\n-   | ---------------------------------------------------------------------------------------------\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   |                                               -------------------------------------------- inside `UNDERFLOW_ABS` at $DIR/offset_ub.rs:24:47\n \n error: aborting due to 11 previous errors\n "}, {"sha": "9b5fd18f818b0a0b071ddf98d62d6d68583b57f2", "filename": "src/test/ui/consts/ptr_comparisons.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -1,6 +1,6 @@\n // compile-flags: --crate-type=lib\n-// normalize-stderr-32bit: \"offset 8\" -> \"offset $$TWO_WORDS\"\n-// normalize-stderr-64bit: \"offset 16\" -> \"offset $$TWO_WORDS\"\n+// normalize-stderr-32bit: \"8 bytes\" -> \"$$TWO_WORDS bytes\"\n+// normalize-stderr-64bit: \"16 bytes\" -> \"$$TWO_WORDS bytes\"\n // normalize-stderr-32bit: \"size 4\" -> \"size $$WORD\"\n // normalize-stderr-64bit: \"size 8\" -> \"size $$WORD\"\n \n@@ -63,14 +63,14 @@ const _: *const usize = unsafe { (FOO as *const usize).offset(2) };\n const _: *const u8 =\n     unsafe { std::ptr::addr_of!((*(FOO as *const usize as *const [u8; 1000]))[999]) };\n //~^ ERROR evaluation of constant value failed\n-//~| pointer must be in-bounds\n+//~| out-of-bounds\n \n const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) + 4 };\n //~^ ERROR any use of this value will cause an error\n-//~| cannot cast pointer to integer\n+//~| unable to turn pointer into raw bytes\n //~| WARN this was previously accepted by the compiler but is being phased out\n \n const _: usize = unsafe { *std::mem::transmute::<&&usize, &usize>(&FOO) + 4 };\n //~^ ERROR any use of this value will cause an error\n-//~| cannot cast pointer to integer\n+//~| unable to turn pointer into raw bytes\n //~| WARN this was previously accepted by the compiler but is being phased out"}, {"sha": "6ae24c179ff1c838dff09e859328d831bdc7b74f", "filename": "src/test/ui/consts/ptr_comparisons.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -4,7 +4,7 @@ error[E0080]: evaluation of constant value failed\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  pointer arithmetic failed: pointer must be in-bounds at offset $TWO_WORDS, but is outside bounds of alloc2 which has size $WORD\n+   |                  pointer arithmetic failed: alloc3 has size $WORD, so pointer to $TWO_WORDS bytes starting at offset 0 is out-of-bounds\n    |                  inside `ptr::const_ptr::<impl *const usize>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    | \n   ::: $DIR/ptr_comparisons.rs:61:34\n@@ -16,15 +16,15 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ptr_comparisons.rs:64:33\n    |\n LL |     unsafe { std::ptr::addr_of!((*(FOO as *const usize as *const [u8; 1000]))[999]) };\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: pointer must be in-bounds at offset 1000, but is outside bounds of alloc2 which has size $WORD\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: alloc3 has size $WORD, so pointer to 1000 bytes starting at offset 0 is out-of-bounds\n \n error: any use of this value will cause an error\n   --> $DIR/ptr_comparisons.rs:68:27\n    |\n LL | const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) + 4 };\n    | --------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                           |\n-   |                           cannot cast pointer to integer because it was not created by cast from integer\n+   |                           unable to turn pointer into raw bytes\n    |\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n@@ -36,7 +36,7 @@ error: any use of this value will cause an error\n LL | const _: usize = unsafe { *std::mem::transmute::<&&usize, &usize>(&FOO) + 4 };\n    | --------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                           |\n-   |                           cannot cast pointer to integer because it was not created by cast from integer\n+   |                           unable to turn pointer into raw bytes\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>"}, {"sha": "654b21f05b6fe58e315fa586b73f59969c9e8b20", "filename": "src/test/ui/error-codes/E0396-fixed.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Ferror-codes%2FE0396-fixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Ferror-codes%2FE0396-fixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0396-fixed.rs?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -3,8 +3,7 @@\n const REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n \n const VALUE: u8 = unsafe { *REG_ADDR };\n-//~^ ERROR any use of this value will cause an error\n-//~| WARN this was previously accepted by the compiler but is being phased out\n+//~^ ERROR evaluation of constant value failed\n \n fn main() {\n }"}, {"sha": "91997fcf0f901c66fe733d8a7246832cf3182b65", "filename": "src/test/ui/error-codes/E0396-fixed.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Ferror-codes%2FE0396-fixed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Ferror-codes%2FE0396-fixed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0396-fixed.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -1,14 +1,9 @@\n-error: any use of this value will cause an error\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/E0396-fixed.rs:5:28\n    |\n LL | const VALUE: u8 = unsafe { *REG_ADDR };\n-   | ---------------------------^^^^^^^^^---\n-   |                            |\n-   |                            unable to turn bytes into a pointer\n-   |\n-   = note: `#[deny(const_err)]` on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   |                            ^^^^^^^^^ 0x5f3759df is not a valid pointer\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "ff78c252731bd1cd2113d64811ac116ec8108387", "filename": "src/test/ui/intrinsics/intrinsic-raw_eq-const-padding.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c78ebb7bdcfc924a20fd069891ffe1364d6814e7/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-raw_eq-const-padding.stderr?ref=c78ebb7bdcfc924a20fd069891ffe1364d6814e7", "patch": "@@ -2,7 +2,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/intrinsic-raw_eq-const-padding.rs:6:5\n    |\n LL |     std::intrinsics::raw_eq(&(1_u8, 2_u16), &(1_u8, 2_u16))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ reading 4 bytes of memory starting at alloc2, but 1 byte is uninitialized starting at alloc2+0x1, and this operation requires initialized memory\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ reading 4 bytes of memory starting at alloc3, but 1 byte is uninitialized starting at alloc3+0x1, and this operation requires initialized memory\n \n error: aborting due to previous error\n "}]}