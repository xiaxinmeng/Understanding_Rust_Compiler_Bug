{"sha": "a1dd5ac78745a9f266573d539ba34bbd75b50277", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZGQ1YWM3ODc0NWE5ZjI2NjU3M2Q1MzliYTM0YmJkNzViNTAyNzc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-21T22:28:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-21T22:28:53Z"}, "message": "rollup merge of #24636: alexcrichton/remove-deprecated\n\nConflicts:\n\tsrc/libcore/result.rs", "tree": {"sha": "584e29815ca61d4045fa6bfa048d3804c7ce529a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/584e29815ca61d4045fa6bfa048d3804c7ce529a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1dd5ac78745a9f266573d539ba34bbd75b50277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1dd5ac78745a9f266573d539ba34bbd75b50277", "html_url": "https://github.com/rust-lang/rust/commit/a1dd5ac78745a9f266573d539ba34bbd75b50277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1dd5ac78745a9f266573d539ba34bbd75b50277/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98e9765d973d46faa5c80fb37a48040ca9e87b28", "url": "https://api.github.com/repos/rust-lang/rust/commits/98e9765d973d46faa5c80fb37a48040ca9e87b28", "html_url": "https://github.com/rust-lang/rust/commit/98e9765d973d46faa5c80fb37a48040ca9e87b28"}, {"sha": "a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "url": "https://api.github.com/repos/rust-lang/rust/commits/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "html_url": "https://github.com/rust-lang/rust/commit/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881"}], "stats": {"total": 7800, "additions": 1380, "deletions": 6420}, "files": [{"sha": "3e77d3c603bac90909a481f68df961c545b4f566", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -336,7 +336,7 @@ This shows off the additional feature of `where` clauses: they allow bounds\n where the left-hand side is an arbitrary type (`i32` in this case), not just a\n plain type parameter (like `T`).\n \n-# Default methods\n+## Default methods\n \n There\u2019s one last feature of traits we should cover: default methods. It\u2019s\n easiest just to show an example:"}, {"sha": "d9151298a35e3165a1dbfe7ad7fc4659dfaac45a", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -40,7 +40,6 @@\n //! ```\n //! # #![feature(collections, core, step_by)]\n //! use std::collections::{BitSet, BitVec};\n-//! use std::num::Float;\n //! use std::iter;\n //!\n //! let max_prime = 10000;"}, {"sha": "2b502b2227ef343449971c36363ee0d94cfafe68", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -175,7 +175,6 @@\n //! # #![feature(core, std_misc)]\n //! use std::fmt;\n //! use std::f64;\n-//! use std::num::Float;\n //!\n //! #[derive(Debug)]\n //! struct Vector2D {\n@@ -200,10 +199,11 @@\n //!         let magnitude = magnitude.sqrt();\n //!\n //!         // Respect the formatting flags by using the helper method\n-//!         // `pad_integral` on the Formatter object. See the method documentation\n-//!         // for details, and the function `pad` can be used to pad strings.\n+//!         // `pad_integral` on the Formatter object. See the method\n+//!         // documentation for details, and the function `pad` can be used\n+//!         // to pad strings.\n //!         let decimals = f.precision().unwrap_or(3);\n-//!         let string = f64::to_str_exact(magnitude, decimals);\n+//!         let string = format!(\"{:.*}\", decimals, magnitude);\n //!         f.pad_integral(true, \"\", &string)\n //!     }\n //! }"}, {"sha": "6622d8a9c40633a3b1a2bb374056d6cd0f69ec9c", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -98,7 +98,7 @@ use self::Direction::*;\n use borrow::{Borrow, BorrowMut, ToOwned};\n use vec::Vec;\n \n-pub use core::slice::{Chunks, AsSlice, Windows};\n+pub use core::slice::{Chunks, Windows};\n pub use core::slice::{Iter, IterMut};\n pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};"}, {"sha": "db9f526a0f22e368459aacb92c48aba6493aa8f8", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -67,7 +67,7 @@ use rustc_unicode;\n use vec::Vec;\n use slice::SliceConcatExt;\n \n-pub use core::str::{FromStr, Utf8Error, Str};\n+pub use core::str::{FromStr, Utf8Error};\n pub use core::str::{Lines, LinesAny, CharRange};\n pub use core::str::{Split, RSplit};\n pub use core::str::{SplitN, RSplitN};"}, {"sha": "420fc9f59b0d2f154e9f4955f2f9fa42742dded2", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -837,15 +837,6 @@ impl<'a, 'b> PartialEq<Cow<'a, str>> for &'b str {\n     fn ne(&self, other: &Cow<'a, str>) -> bool { PartialEq::ne(&self[..], &other[..]) }\n }\n \n-#[unstable(feature = \"collections\", reason = \"waiting on Str stabilization\")]\n-#[allow(deprecated)]\n-impl Str for String {\n-    #[inline]\n-    fn as_slice(&self) -> &str {\n-        unsafe { mem::transmute(&*self.vec) }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for String {\n     #[inline]\n@@ -1067,14 +1058,6 @@ impl<'a> IntoCow<'a, str> for &'a str {\n     }\n }\n \n-#[allow(deprecated)]\n-impl<'a> Str for Cow<'a, str> {\n-    #[inline]\n-    fn as_slice<'b>(&'b self) -> &'b str {\n-        &**self\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Write for String {\n     #[inline]"}, {"sha": "4bbfabdd72fd1e66e559f7131535bb64b8d48f5e", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -1591,18 +1591,6 @@ impl<T: Ord> Ord for Vec<T> {\n     }\n }\n \n-#[unstable(feature = \"collections\",\n-           reason = \"will be replaced by slice syntax\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n-#[allow(deprecated)]\n-impl<T> AsSlice<T> for Vec<T> {\n-    /// Deprecated: use `&mut s[..]` instead.\n-    #[inline]\n-    fn as_slice(&self) -> &[T] {\n-        self\n-    }\n-}\n-\n #[unstable(feature = \"collections\",\n            reason = \"recent addition, needs more experience\")]\n impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {"}, {"sha": "4b75bd5f67e3d94fd7d07b23a19c4567e0ade186", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -11,15 +11,15 @@\n pub use self::ExponentFormat::*;\n pub use self::SignificantDigits::*;\n \n-use char::{self, CharExt};\n+use prelude::*;\n+\n+use char;\n use fmt;\n-use iter::Iterator;\n-use num::{cast, Float, ToPrimitive};\n+use num::Float;\n use num::FpCategory as Fp;\n-use ops::FnOnce;\n-use result::Result::Ok;\n-use slice::{self, SliceExt};\n-use str::{self, StrExt};\n+use ops::{Div, Rem, Mul};\n+use slice;\n+use str;\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n pub enum ExponentFormat {\n@@ -42,6 +42,21 @@ pub enum SignificantDigits {\n     DigExact(usize)\n }\n \n+#[doc(hidden)]\n+pub trait MyFloat: Float + PartialEq + PartialOrd + Div<Output=Self> +\n+                   Mul<Output=Self> + Rem<Output=Self> + Copy {\n+    fn from_u32(u: u32) -> Self;\n+    fn to_i32(&self) -> i32;\n+}\n+\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl MyFloat for $t {\n+        fn from_u32(u: u32) -> $t { u as $t }\n+        fn to_i32(&self) -> i32 { *self as i32 }\n+    })*)\n+}\n+doit! { f32 f64 }\n+\n /// Converts a float number to its string representation.\n /// This is meant to be a common base implementation for various formatting styles.\n /// The number is assumed to be non-negative, callers use `Formatter::pad_integral`\n@@ -63,7 +78,7 @@ pub enum SignificantDigits {\n /// # Panics\n ///\n /// - Panics if `num` is negative.\n-pub fn float_to_str_bytes_common<T: Float, U, F>(\n+pub fn float_to_str_bytes_common<T: MyFloat, U, F>(\n     num: T,\n     digits: SignificantDigits,\n     exp_format: ExponentFormat,\n@@ -72,10 +87,10 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n ) -> U where\n     F: FnOnce(&str) -> U,\n {\n-    let _0: T = Float::zero();\n-    let _1: T = Float::one();\n+    let _0: T = T::zero();\n+    let _1: T = T::one();\n     let radix: u32 = 10;\n-    let radix_f: T = cast(radix).unwrap();\n+    let radix_f = T::from_u32(radix);\n \n     assert!(num.is_nan() || num >= _0, \"float_to_str_bytes_common: number is negative\");\n \n@@ -99,7 +114,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n     let (num, exp) = match exp_format {\n         ExpDec if num != _0 => {\n             let exp = num.log10().floor();\n-            (num / radix_f.powf(exp), cast::<T, i32>(exp).unwrap())\n+            (num / radix_f.powf(exp), exp.to_i32())\n         }\n         _ => (num, 0)\n     };\n@@ -114,7 +129,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         deccum = deccum / radix_f;\n         deccum = deccum.trunc();\n \n-        let c = char::from_digit(current_digit.to_isize().unwrap() as u32, radix);\n+        let c = char::from_digit(current_digit.to_i32() as u32, radix);\n         buf[end] = c.unwrap() as u8;\n         end += 1;\n \n@@ -158,7 +173,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             let current_digit = deccum.trunc();\n \n-            let c = char::from_digit(current_digit.to_isize().unwrap() as u32, radix);\n+            let c = char::from_digit(current_digit.to_i32() as u32, radix);\n             buf[end] = c.unwrap() as u8;\n             end += 1;\n "}, {"sha": "0178b321e88c35a68be363b49bf4a91eb4b097c4", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,21 +12,16 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use prelude::*;\n+\n use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n-use char::CharExt;\n-use clone::Clone;\n-use iter::Iterator;\n-use marker::{Copy, PhantomData, Sized};\n+use marker::PhantomData;\n use mem;\n-use num::Float;\n-use option::Option;\n-use option::Option::{Some, None};\n-use result::Result::Ok;\n-use ops::{Deref, FnOnce};\n+use ops::Deref;\n use result;\n-use slice::SliceExt;\n+use num::Float;\n use slice;\n-use str::{self, StrExt};\n+use str;\n use self::rt::v1::Alignment;\n \n pub use self::num::radix;\n@@ -929,7 +924,8 @@ impl<'a, T> Pointer for &'a mut T {\n }\n \n // Common code of floating point Debug and Display.\n-fn float_to_str_common<T: Float, F>(num: &T, precision: Option<usize>, post: F) -> Result\n+fn float_to_str_common<T: float::MyFloat, F>(num: &T, precision: Option<usize>,\n+                                             post: F) -> Result\n         where F : FnOnce(&str) -> Result {\n     let digits = match precision {\n         Some(i) => float::DigExact(i),\n@@ -967,8 +963,6 @@ macro_rules! floating { ($ty:ident) => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl LowerExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            use num::Float;\n-\n             let digits = match fmt.precision {\n                 Some(i) => float::DigExact(i),\n                 None => float::DigMax(6),\n@@ -986,8 +980,6 @@ macro_rules! floating { ($ty:ident) => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl UpperExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            use num::Float;\n-\n             let digits = match fmt.precision {\n                 Some(i) => float::DigExact(i),\n                 None => float::DigMax(6),"}, {"sha": "122fffc5959056a99c3edbe3d97155ec878c0d66", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,12 +14,28 @@\n \n #![allow(unsigned_negation)]\n \n+use prelude::*;\n+\n use fmt;\n-use iter::Iterator;\n-use num::{Int, cast};\n-use slice::SliceExt;\n+use num::Zero;\n+use ops::{Div, Rem, Sub};\n use str;\n \n+#[doc(hidden)]\n+trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n+           Sub<Output=Self> + Copy {\n+    fn from_u8(u: u8) -> Self;\n+    fn to_u8(&self) -> u8;\n+}\n+\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl Int for $t {\n+        fn from_u8(u: u8) -> $t { u as $t }\n+        fn to_u8(&self) -> u8 { *self as u8 }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n /// A type that represents a specific radix\n #[doc(hidden)]\n trait GenericRadix {\n@@ -33,33 +49,32 @@ trait GenericRadix {\n     fn digit(&self, x: u8) -> u8;\n \n     /// Format an integer using the radix using a formatter.\n-    #[allow(deprecated)] // Int\n     fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n         // The radix can be as low as 2, so we need a buffer of at least 64\n         // characters for a base 2 number.\n-        let zero = Int::zero();\n+        let zero = T::zero();\n         let is_positive = x >= zero;\n         let mut buf = [0; 64];\n         let mut curr = buf.len();\n-        let base = cast(self.base()).unwrap();\n+        let base = T::from_u8(self.base());\n         if is_positive {\n             // Accumulate each digit of the number from the least significant\n             // to the most significant figure.\n             for byte in buf.iter_mut().rev() {\n-                let n = x % base;                         // Get the current place value.\n-                x = x / base;                             // Deaccumulate the number.\n-                *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n+                let n = x % base;              // Get the current place value.\n+                x = x / base;                  // Deaccumulate the number.\n+                *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero { break };                   // No more digits left to accumulate.\n+                if x == zero { break };        // No more digits left to accumulate.\n             }\n         } else {\n             // Do the same as above, but accounting for two's complement.\n             for byte in buf.iter_mut().rev() {\n-                let n = zero - (x % base);                // Get the current place value.\n-                x = x / base;                             // Deaccumulate the number.\n-                *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n+                let n = zero - (x % base);     // Get the current place value.\n+                x = x / base;                  // Deaccumulate the number.\n+                *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero { break };                   // No more digits left to accumulate.\n+                if x == zero { break };        // No more digits left to accumulate.\n             }\n         }\n         let buf = unsafe { str::from_utf8_unchecked(&buf[curr..]) };"}, {"sha": "233ed018119302deceb23bedcdac7e0175a9b0e0", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 77, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -64,7 +64,7 @@ use cmp::{Ord, PartialOrd, PartialEq};\n use default::Default;\n use marker;\n use mem;\n-use num::{Int, Zero, One};\n+use num::{Zero, One};\n use ops::{self, Add, Sub, FnMut, Mul, RangeFrom};\n use option::Option::{self, Some, None};\n use marker::Sized;\n@@ -2327,9 +2327,8 @@ impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n /// An iterator that yields sequential Fibonacci numbers, and stops on overflow.\n ///\n /// ```\n-/// # #![feature(core)]\n+/// #![feature(core)]\n /// use std::iter::Unfold;\n-/// use std::num::Int; // For `.checked_add()`\n ///\n /// // This iterator will yield up to the last Fibonacci number before the max\n /// // value of `u32`. You can simply change `u32` to `u64` in this line if\n@@ -2647,80 +2646,6 @@ impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n     }\n }\n \n-/// An iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n-#[derive(Clone)]\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-pub struct RangeStepInclusive<A> {\n-    state: A,\n-    stop: A,\n-    step: A,\n-    rev: bool,\n-    done: bool,\n-}\n-\n-/// Returns an iterator over the range [start, stop] by `step`.\n-///\n-/// It handles overflow by stopping.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(core)]\n-/// use std::iter::range_step_inclusive;\n-///\n-/// for i in range_step_inclusive(0, 10, 2) {\n-///     println!(\"{}\", i);\n-/// }\n-/// ```\n-///\n-/// This prints:\n-///\n-/// ```text\n-/// 0\n-/// 2\n-/// 4\n-/// 6\n-/// 8\n-/// 10\n-/// ```\n-#[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n-pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n-    let rev = step < Int::zero();\n-    RangeStepInclusive {\n-        state: start,\n-        stop: stop,\n-        step: step,\n-        rev: rev,\n-        done: false,\n-    }\n-}\n-\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n-impl<A: Int> Iterator for RangeStepInclusive<A> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        if !self.done && ((self.rev && self.state >= self.stop) ||\n-                          (!self.rev && self.state <= self.stop)) {\n-            let result = self.state;\n-            match self.state.checked_add(self.step) {\n-                Some(x) => self.state = x,\n-                None => self.done = true\n-            }\n-            Some(result)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "249f0a0c389a3deda580019f845e047ed3aed18d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -108,6 +108,7 @@ mod uint_macros;\n #[path = \"num/f32.rs\"]   pub mod f32;\n #[path = \"num/f64.rs\"]   pub mod f64;\n \n+#[macro_use]\n pub mod num;\n \n /* The libcore prelude, not as all-encompassing as the libstd prelude */"}, {"sha": "fdabdbc5ed4ce0c59c8d2853e662084247d7544c", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 47, "deletions": 34, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -35,7 +35,16 @@ use hash::Hasher;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n-#[allow(deprecated)]\n+#[cfg(not(stage0))]\n+pub unsafe trait Send {\n+    // empty.\n+}\n+\n+/// Types able to be transferred across thread boundaries.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[lang=\"send\"]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n+#[cfg(stage0)]\n pub unsafe trait Send : MarkerTrait {\n     // empty.\n }\n@@ -51,7 +60,17 @@ impl !Send for Managed { }\n #[lang=\"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n-#[allow(deprecated)]\n+#[cfg(not(stage0))]\n+pub trait Sized {\n+    // Empty.\n+}\n+\n+/// Types with a constant size known at compile-time.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[lang=\"sized\"]\n+#[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n+#[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n+#[cfg(stage0)]\n pub trait Sized : MarkerTrait {\n     // Empty.\n }\n@@ -199,13 +218,23 @@ pub trait Copy : Clone {\n /// the `sync` crate do ensure that any mutation cannot cause data\n /// races.  Hence these types are `Sync`.\n ///\n-/// Any types with interior mutability must also use the `std::cell::UnsafeCell` wrapper around the\n-/// value(s) which can be mutated when behind a `&` reference; not doing this is undefined\n-/// behaviour (for example, `transmute`-ing from `&T` to `&mut T` is illegal).\n+/// Any types with interior mutability must also use the `std::cell::UnsafeCell`\n+/// wrapper around the value(s) which can be mutated when behind a `&`\n+/// reference; not doing this is undefined behaviour (for example,\n+/// `transmute`-ing from `&T` to `&mut T` is illegal).\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[lang=\"sync\"]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n+pub unsafe trait Sync {\n+    // Empty\n+}\n+\n+/// dox\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n-#[allow(deprecated)]\n pub unsafe trait Sync : MarkerTrait {\n     // Empty\n }\n@@ -272,42 +301,20 @@ macro_rules! impls{\n         )\n }\n \n-/// `MarkerTrait` is deprecated and no longer needed.\n+/// dox\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n-#[allow(deprecated)]\n #[cfg(stage0)]\n pub trait MarkerTrait : PhantomFn<Self,Self> { }\n \n-/// `MarkerTrait` is deprecated and no longer needed.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n-#[allow(deprecated)]\n-#[cfg(not(stage0))]\n-pub trait MarkerTrait { }\n-\n-#[allow(deprecated)]\n-impl<T:?Sized> MarkerTrait for T { }\n+#[cfg(stage0)]\n+impl<T: ?Sized> MarkerTrait for T {}\n \n-/// `PhantomFn` is a deprecated marker trait that is no longer needed.\n+/// dox\n #[lang=\"phantom_fn\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n #[cfg(stage0)]\n pub trait PhantomFn<A:?Sized,R:?Sized=()> {\n }\n \n-/// `PhantomFn` is a deprecated marker trait that is no longer needed.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n-#[cfg(not(stage0))]\n-pub trait PhantomFn<A:?Sized,R:?Sized=()> {\n-}\n-\n-#[allow(deprecated)]\n-#[cfg(not(stage0))]\n-impl<A:?Sized,R:?Sized,T:?Sized> PhantomFn<A,R> for T { }\n-\n /// `PhantomData<T>` allows you to describe that a type acts as if it stores a value of type `T`,\n /// even though it does not. This allows you to inform the compiler about certain safety properties\n /// of your code.\n@@ -454,8 +461,14 @@ mod impls {\n #[rustc_reflect_like]\n #[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n #[allow(deprecated)]\n-pub trait Reflect : MarkerTrait {\n-}\n+#[cfg(not(stage0))]\n+pub trait Reflect {}\n+\n+/// dox\n+#[rustc_reflect_like]\n+#[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n+#[cfg(stage0)]\n+pub trait Reflect: MarkerTrait {}\n \n impl Reflect for .. { }\n "}, {"sha": "9ea44c39fe9c6382c6a27b441df0f0a028d62a36", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,12 +10,17 @@\n \n //! Exposes the NonZero lang item which provides optimization hints.\n \n-use marker::{Sized, MarkerTrait};\n+use marker::Sized;\n use ops::Deref;\n+#[cfg(stage0)] use marker::MarkerTrait;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n-#[allow(deprecated)]\n-pub unsafe trait Zeroable : MarkerTrait {}\n+#[cfg(not(stage0))]\n+pub unsafe trait Zeroable {}\n+\n+/// Unsafe trait to indicate what types are usable with the NonZero struct\n+#[cfg(stage0)]\n+pub unsafe trait Zeroable: MarkerTrait {}\n \n unsafe impl<T:?Sized> Zeroable for *const T {}\n unsafe impl<T:?Sized> Zeroable for *mut T {}"}, {"sha": "50dd3f1661adf6c0fa632841668af366e683c104", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 5, "deletions": 80, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -16,11 +16,12 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use prelude::*;\n+\n use intrinsics;\n use mem;\n-use num::Float;\n+use num::{Float, ParseFloatError};\n use num::FpCategory as Fp;\n-use option::Option;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const RADIX: u32 = 2;\n@@ -33,19 +34,6 @@ pub const DIGITS: u32 = 6;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f32 = 1.19209290e-07_f32;\n \n-/// Smallest finite f32 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f32::MIN`\")]\n-pub const MIN_VALUE: f32 = -3.40282347e+38_f32;\n-/// Smallest positive, normalized f32 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f32::MIN_POSITIVE`\")]\n-pub const MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n-/// Largest finite f32 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f32::MAX`\")]\n-pub const MAX_VALUE: f32 = 3.40282347e+38_f32;\n-\n /// Smallest finite f32 value\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: f32 = -3.40282347e+38_f32;\n@@ -118,26 +106,14 @@ pub mod consts {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_2_SQRT_PI: f32 = 1.12837916709551257389615890312154517_f32;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_2_SQRT_PI\")]\n-    pub const FRAC_2_SQRTPI: f32 = 1.12837916709551257389615890312154517_f32;\n-\n     /// sqrt(2.0)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const SQRT_2: f32 = 1.41421356237309504880168872420969808_f32;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to SQRT_2\")]\n-    pub const SQRT2: f32 = 1.41421356237309504880168872420969808_f32;\n-\n     /// 1.0/sqrt(2.0)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_1_SQRT_2: f32 = 0.707106781186547524400844362104849039_f32;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_1_SQRT_2\")]\n-    pub const FRAC_1_SQRT2: f32 = 0.707106781186547524400844362104849039_f32;\n-\n     /// Euler's number\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const E: f32 = 2.71828182845904523536028747135266250_f32;\n@@ -179,6 +155,8 @@ impl Float for f32 {\n     #[inline]\n     fn one() -> f32 { 1.0 }\n \n+    from_str_radix_float_impl! { f32 }\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }\n@@ -218,56 +196,6 @@ impl Float for f32 {\n         }\n     }\n \n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn mantissa_digits(_: Option<f32>) -> usize { MANTISSA_DIGITS as usize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn digits(_: Option<f32>) -> usize { DIGITS as usize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn epsilon() -> f32 { EPSILON }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_exp(_: Option<f32>) -> isize { MIN_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_exp(_: Option<f32>) -> isize { MAX_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_10_exp(_: Option<f32>) -> isize { MIN_10_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_10_exp(_: Option<f32>) -> isize { MAX_10_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_value() -> f32 { MIN }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_pos_value(_: Option<f32>) -> f32 { MIN_POSITIVE }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_value() -> f32 { MAX }\n-\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u32 = unsafe { mem::transmute(self) };\n@@ -310,9 +238,6 @@ impl Float for f32 {\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    ///\n     /// let x = 1.65f32;\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```"}, {"sha": "62b566e7eb40cb65f8b45d704e0f8c2fa83d22f7", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 5, "deletions": 80, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -16,11 +16,12 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use prelude::*;\n+\n use intrinsics;\n use mem;\n-use num::Float;\n use num::FpCategory as Fp;\n-use option::Option;\n+use num::{Float, ParseFloatError};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const RADIX: u32 = 2;\n@@ -33,19 +34,6 @@ pub const DIGITS: u32 = 15;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n \n-/// Smallest finite f64 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f64::MIN`\")]\n-pub const MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n-/// Smallest positive, normalized f64 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f64::MIN_POSITIVE`\")]\n-pub const MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n-/// Largest finite f64 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f64::MAX`\")]\n-pub const MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n-\n /// Smallest finite f64 value\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: f64 = -1.7976931348623157e+308_f64;\n@@ -118,26 +106,14 @@ pub mod consts {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_2_SQRT_PI: f64 = 1.12837916709551257389615890312154517_f64;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_2_SQRT_PI\")]\n-    pub const FRAC_2_SQRTPI: f64 = 1.12837916709551257389615890312154517_f64;\n-\n     /// sqrt(2.0)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const SQRT_2: f64 = 1.41421356237309504880168872420969808_f64;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to SQRT_2\")]\n-    pub const SQRT2: f64 = 1.41421356237309504880168872420969808_f64;\n-\n     /// 1.0/sqrt(2.0)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_1_SQRT_2: f64 = 0.707106781186547524400844362104849039_f64;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_1_SQRT_2\")]\n-    pub const FRAC_1_SQRT2: f64 = 0.707106781186547524400844362104849039_f64;\n-\n     /// Euler's number\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const E: f64 = 2.71828182845904523536028747135266250_f64;\n@@ -179,6 +155,8 @@ impl Float for f64 {\n     #[inline]\n     fn one() -> f64 { 1.0 }\n \n+    from_str_radix_float_impl! { f64 }\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }\n@@ -218,56 +196,6 @@ impl Float for f64 {\n         }\n     }\n \n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn mantissa_digits(_: Option<f64>) -> usize { MANTISSA_DIGITS as usize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn digits(_: Option<f64>) -> usize { DIGITS as usize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn epsilon() -> f64 { EPSILON }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_exp(_: Option<f64>) -> isize { MIN_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_exp(_: Option<f64>) -> isize { MAX_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_10_exp(_: Option<f64>) -> isize { MIN_10_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_10_exp(_: Option<f64>) -> isize { MAX_10_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_value() -> f64 { MIN }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_pos_value(_: Option<f64>) -> f64 { MIN_POSITIVE }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_value() -> f64 { MAX }\n-\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u64 = unsafe { mem::transmute(self) };\n@@ -310,9 +238,6 @@ impl Float for f64 {\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    ///\n     /// let x = 1.65f64;\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```"}, {"sha": "5ee0dc19f9bf684ca855056f2a8551e63a6ffc2c", "filename": "src/libcore/num/float_macros.rs", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -18,3 +18,145 @@ macro_rules! assert_approx_eq {\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n }\n+\n+macro_rules! from_str_radix_float_impl {\n+    ($T:ty) => {\n+        fn from_str_radix(src: &str, radix: u32)\n+                          -> Result<$T, ParseFloatError> {\n+            use num::FloatErrorKind::*;\n+            use num::ParseFloatError as PFE;\n+\n+            // Special values\n+            match src {\n+                \"inf\"   => return Ok(Float::infinity()),\n+                \"-inf\"  => return Ok(Float::neg_infinity()),\n+                \"NaN\"   => return Ok(Float::nan()),\n+                _       => {},\n+            }\n+\n+            let (is_positive, src) =  match src.slice_shift_char() {\n+                None             => return Err(PFE { kind: Empty }),\n+                Some(('-', \"\"))  => return Err(PFE { kind: Empty }),\n+                Some(('-', src)) => (false, src),\n+                Some((_, _))     => (true,  src),\n+            };\n+\n+            // The significand to accumulate\n+            let mut sig = if is_positive { 0.0 } else { -0.0 };\n+            // Necessary to detect overflow\n+            let mut prev_sig = sig;\n+            let mut cs = src.chars().enumerate();\n+            // Exponent prefix and exponent index offset\n+            let mut exp_info = None::<(char, usize)>;\n+\n+            // Parse the integer part of the significand\n+            for (i, c) in cs.by_ref() {\n+                match c.to_digit(radix) {\n+                    Some(digit) => {\n+                        // shift significand one digit left\n+                        sig = sig * (radix as $T);\n+\n+                        // add/subtract current digit depending on sign\n+                        if is_positive {\n+                            sig = sig + ((digit as isize) as $T);\n+                        } else {\n+                            sig = sig - ((digit as isize) as $T);\n+                        }\n+\n+                        // Detect overflow by comparing to last value, except\n+                        // if we've not seen any non-zero digits.\n+                        if prev_sig != 0.0 {\n+                            if is_positive && sig <= prev_sig\n+                                { return Ok(Float::infinity()); }\n+                            if !is_positive && sig >= prev_sig\n+                                { return Ok(Float::neg_infinity()); }\n+\n+                            // Detect overflow by reversing the shift-and-add process\n+                            if is_positive && (prev_sig != (sig - digit as $T) / radix as $T)\n+                                { return Ok(Float::infinity()); }\n+                            if !is_positive && (prev_sig != (sig + digit as $T) / radix as $T)\n+                                { return Ok(Float::neg_infinity()); }\n+                        }\n+                        prev_sig = sig;\n+                    },\n+                    None => match c {\n+                        'e' | 'E' | 'p' | 'P' => {\n+                            exp_info = Some((c, i + 1));\n+                            break;  // start of exponent\n+                        },\n+                        '.' => {\n+                            break;  // start of fractional part\n+                        },\n+                        _ => {\n+                            return Err(PFE { kind: Invalid });\n+                        },\n+                    },\n+                }\n+            }\n+\n+            // If we are not yet at the exponent parse the fractional\n+            // part of the significand\n+            if exp_info.is_none() {\n+                let mut power = 1.0;\n+                for (i, c) in cs.by_ref() {\n+                    match c.to_digit(radix) {\n+                        Some(digit) => {\n+                            // Decrease power one order of magnitude\n+                            power = power / (radix as $T);\n+                            // add/subtract current digit depending on sign\n+                            sig = if is_positive {\n+                                sig + (digit as $T) * power\n+                            } else {\n+                                sig - (digit as $T) * power\n+                            };\n+                            // Detect overflow by comparing to last value\n+                            if is_positive && sig < prev_sig\n+                                { return Ok(Float::infinity()); }\n+                            if !is_positive && sig > prev_sig\n+                                { return Ok(Float::neg_infinity()); }\n+                            prev_sig = sig;\n+                        },\n+                        None => match c {\n+                            'e' | 'E' | 'p' | 'P' => {\n+                                exp_info = Some((c, i + 1));\n+                                break; // start of exponent\n+                            },\n+                            _ => {\n+                                return Err(PFE { kind: Invalid });\n+                            },\n+                        },\n+                    }\n+                }\n+            }\n+\n+            // Parse and calculate the exponent\n+            let exp = match exp_info {\n+                Some((c, offset)) => {\n+                    let base = match c {\n+                        'E' | 'e' if radix == 10 => 10.0,\n+                        'P' | 'p' if radix == 16 => 2.0,\n+                        _ => return Err(PFE { kind: Invalid }),\n+                    };\n+\n+                    // Parse the exponent as decimal integer\n+                    let src = &src[offset..];\n+                    let (is_positive, exp) = match src.slice_shift_char() {\n+                        Some(('-', src)) => (false, src.parse::<usize>()),\n+                        Some(('+', src)) => (true,  src.parse::<usize>()),\n+                        Some((_, _))     => (true,  src.parse::<usize>()),\n+                        None             => return Err(PFE { kind: Invalid }),\n+                    };\n+\n+                    match (is_positive, exp) {\n+                        (true,  Ok(exp)) => base.powi(exp as i32),\n+                        (false, Ok(exp)) => 1.0 / base.powi(exp as i32),\n+                        (_, Err(_))      => return Err(PFE { kind: Invalid }),\n+                    }\n+                },\n+                None => 1.0, // no exponent\n+            };\n+\n+            Ok(sig * exp)\n+        }\n+    }\n+}"}, {"sha": "44d5333ce1f46bb582a11b97e2fe08718c52029e", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 123, "deletions": 1736, "changes": 1859, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,18 +13,14 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-use self::wrapping::{OverflowingOps, WrappingOps};\n+use self::wrapping::OverflowingOps;\n \n use char::CharExt;\n-use clone::Clone;\n-use cmp::{PartialEq, Eq, PartialOrd, Ord};\n+use cmp::{Eq, PartialOrd};\n use fmt;\n use intrinsics;\n-use iter::Iterator;\n use marker::Copy;\n use mem::size_of;\n-use ops::{Add, Sub, Mul, Div, Rem, Neg};\n-use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use str::{FromStr, StrExt};\n@@ -98,736 +94,20 @@ macro_rules! zero_one_impl_float {\n }\n zero_one_impl_float! { f32 f64 }\n \n-/// A built-in signed or unsigned integer.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"replaced by inherent methods; for generics, use rust-lang/num\")]\n-#[allow(deprecated)]\n-pub trait Int\n-    : Copy + Clone\n-    + NumCast\n-    + PartialOrd + Ord\n-    + PartialEq + Eq\n-    + Add<Output=Self>\n-    + Sub<Output=Self>\n-    + Mul<Output=Self>\n-    + Div<Output=Self>\n-    + Rem<Output=Self>\n-    + Not<Output=Self>\n-    + BitAnd<Output=Self>\n-    + BitOr<Output=Self>\n-    + BitXor<Output=Self>\n-    + Shl<usize, Output=Self>\n-    + Shr<usize, Output=Self>\n-    + WrappingOps\n-    + OverflowingOps\n-{\n-    /// Returns the `0` value of this integer type.\n-    // FIXME (#5527): Should be an associated constant\n-    #[unstable(feature = \"core\",\n-               reason = \"unsure about its place in the world\")]\n-    fn zero() -> Self;\n-\n-    /// Returns the `1` value of this integer type.\n-    // FIXME (#5527): Should be an associated constant\n-    #[unstable(feature = \"core\",\n-               reason = \"unsure about its place in the world\")]\n-    fn one() -> Self;\n-\n-    /// Returns the smallest value that can be represented by this integer type.\n-    // FIXME (#5527): Should be and associated constant\n-    #[unstable(feature = \"core\",\n-               reason = \"unsure about its place in the world\")]\n-    fn min_value() -> Self;\n-\n-    /// Returns the largest value that can be represented by this integer type.\n-    // FIXME (#5527): Should be and associated constant\n-    #[unstable(feature = \"core\",\n-               reason = \"unsure about its place in the world\")]\n-    fn max_value() -> Self;\n-\n-    /// Returns the number of ones in the binary representation of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0b01001100u8;\n-    ///\n-    /// assert_eq!(n.count_ones(), 3);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn count_ones(self) -> u32;\n-\n-    /// Returns the number of zeros in the binary representation of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0b01001100u8;\n-    ///\n-    /// assert_eq!(n.count_zeros(), 5);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    #[inline]\n-    fn count_zeros(self) -> u32 {\n-        (!self).count_ones()\n-    }\n-\n-    /// Returns the number of leading zeros in the binary representation\n-    /// of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0b0101000u16;\n-    ///\n-    /// assert_eq!(n.leading_zeros(), 10);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn leading_zeros(self) -> u32;\n-\n-    /// Returns the number of trailing zeros in the binary representation\n-    /// of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0b0101000u16;\n-    ///\n-    /// assert_eq!(n.trailing_zeros(), 3);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn trailing_zeros(self) -> u32;\n-\n-    /// Shifts the bits to the left by a specified amount, `n`, wrapping\n-    /// the truncated bits to the end of the resulting integer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0x3456789ABCDEF012u64;\n-    ///\n-    /// assert_eq!(n.rotate_left(12), m);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn rotate_left(self, n: u32) -> Self;\n-\n-    /// Shifts the bits to the right by a specified amount, `n`, wrapping\n-    /// the truncated bits to the beginning of the resulting integer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0xDEF0123456789ABCu64;\n-    ///\n-    /// assert_eq!(n.rotate_right(12), m);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn rotate_right(self, n: u32) -> Self;\n-\n-    /// Reverses the byte order of the integer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0xEFCDAB8967452301u64;\n-    ///\n-    /// assert_eq!(n.swap_bytes(), m);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn swap_bytes(self) -> Self;\n-\n-    /// Converts an integer from big endian to the target's endianness.\n-    ///\n-    /// On big endian this is a no-op. On little endian the bytes are swapped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"big\") {\n-    ///     assert_eq!(Int::from_be(n), n)\n-    /// } else {\n-    ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn from_be(x: Self) -> Self {\n-        if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n-    }\n-\n-    /// Converts an integer from little endian to the target's endianness.\n-    ///\n-    /// On little endian this is a no-op. On big endian the bytes are swapped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"little\") {\n-    ///     assert_eq!(Int::from_le(n), n)\n-    /// } else {\n-    ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn from_le(x: Self) -> Self {\n-        if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n-    }\n-\n-    /// Converts `self` to big endian from the target's endianness.\n-    ///\n-    /// On big endian this is a no-op. On little endian the bytes are swapped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"big\") {\n-    ///     assert_eq!(n.to_be(), n)\n-    /// } else {\n-    ///     assert_eq!(n.to_be(), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn to_be(self) -> Self { // or not to be?\n-        if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n-    }\n-\n-    /// Converts `self` to little endian from the target's endianness.\n-    ///\n-    /// On little endian this is a no-op. On big endian the bytes are swapped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"little\") {\n-    ///     assert_eq!(n.to_le(), n)\n-    /// } else {\n-    ///     assert_eq!(n.to_le(), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn to_le(self) -> Self {\n-        if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n-    }\n-\n-    /// Checked integer addition. Computes `self + other`, returning `None` if\n-    /// overflow occurred.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(5u16.checked_add(65530), Some(65535));\n-    /// assert_eq!(6u16.checked_add(65530), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_add(self, other: Self) -> Option<Self>;\n-\n-    /// Checked integer subtraction. Computes `self - other`, returning `None`\n-    /// if underflow occurred.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n-    /// assert_eq!((-128i8).checked_sub(1), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_sub(self, other: Self) -> Option<Self>;\n-\n-    /// Checked integer multiplication. Computes `self * other`, returning\n-    /// `None` if underflow or overflow occurred.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(5u8.checked_mul(51), Some(255));\n-    /// assert_eq!(5u8.checked_mul(52), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_mul(self, other: Self) -> Option<Self>;\n-\n-    /// Checked integer division. Computes `self / other`, returning `None` if\n-    /// `other == 0` or the operation results in underflow or overflow.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!((-127i8).checked_div(-1), Some(127));\n-    /// assert_eq!((-128i8).checked_div(-1), None);\n-    /// assert_eq!((1i8).checked_div(0), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_div(self, other: Self) -> Option<Self>;\n-\n-    /// Saturating integer addition. Computes `self + other`, saturating at\n-    /// the numeric bounds instead of overflowing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(5u16.saturating_add(65534), 65535);\n-    /// assert_eq!((-5i16).saturating_add(-32767), -32768);\n-    /// assert_eq!(100u32.saturating_add(4294967294), 4294967295);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn saturating_add(self, other: Self) -> Self {\n-        match self.checked_add(other) {\n-            Some(x)                      => x,\n-            None if other >= Int::zero() => Int::max_value(),\n-            None                         => Int::min_value(),\n-        }\n-    }\n-\n-    /// Saturating integer subtraction. Computes `self - other`, saturating at\n-    /// the numeric bounds instead of overflowing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(5u16.saturating_sub(65534), 0);\n-    /// assert_eq!(5i16.saturating_sub(-32767), 32767);\n-    /// assert_eq!(100u32.saturating_sub(4294967294), 0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn saturating_sub(self, other: Self) -> Self {\n-        match self.checked_sub(other) {\n-            Some(x)                      => x,\n-            None if other >= Int::zero() => Int::min_value(),\n-            None                         => Int::max_value(),\n-        }\n-    }\n-\n-    /// Raises self to the power of `exp`, using exponentiation by squaring.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(2.pow(4), 16);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    #[inline]\n-    fn pow(self, mut exp: u32) -> Self {\n-        let mut base = self;\n-        let mut acc: Self = Int::one();\n-\n-        let mut prev_base = self;\n-        let mut base_oflo = false;\n-        while exp > 0 {\n-            if (exp & 1) == 1 {\n-                if base_oflo {\n-                    // ensure overflow occurs in the same manner it\n-                    // would have otherwise (i.e. signal any exception\n-                    // it would have otherwise).\n-                    acc = acc * (prev_base * prev_base);\n-                } else {\n-                    acc = acc * base;\n-                }\n-            }\n-            prev_base = base;\n-            let (new_base, new_base_oflo) = base.overflowing_mul(base);\n-            base = new_base;\n-            base_oflo = new_base_oflo;\n-            exp /= 2;\n-        }\n-        acc\n-    }\n-}\n-\n macro_rules! checked_op {\n     ($T:ty, $U:ty, $op:path, $x:expr, $y:expr) => {{\n         let (result, overflowed) = unsafe { $op($x as $U, $y as $U) };\n         if overflowed { None } else { Some(result as $T) }\n     }}\n }\n \n-macro_rules! uint_impl {\n-    ($T:ty = $ActualT:ty, $BITS:expr,\n-     $ctpop:path,\n-     $ctlz:path,\n-     $cttz:path,\n-     $bswap:path,\n-     $add_with_overflow:path,\n-     $sub_with_overflow:path,\n-     $mul_with_overflow:path) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl Int for $T {\n-            #[inline]\n-            fn zero() -> $T { 0 }\n-\n-            #[inline]\n-            fn one() -> $T { 1 }\n-\n-            #[inline]\n-            fn min_value() -> $T { 0 }\n-\n-            #[inline]\n-            fn max_value() -> $T { !0 }\n-\n-            #[inline]\n-            fn count_ones(self) -> u32 {\n-                unsafe { $ctpop(self as $ActualT) as u32 }\n-            }\n-\n-            #[inline]\n-            fn leading_zeros(self) -> u32 {\n-                unsafe { $ctlz(self as $ActualT) as u32 }\n-            }\n-\n-            #[inline]\n-            fn trailing_zeros(self) -> u32 {\n-                unsafe { $cttz(self as $ActualT) as u32 }\n-            }\n-\n-            #[inline]\n-            fn rotate_left(self, n: u32) -> $T {\n-                // Protect against undefined behaviour for over-long bit shifts\n-                let n = n % $BITS;\n-                (self << n) | (self >> (($BITS - n) % $BITS))\n-            }\n-\n-            #[inline]\n-            fn rotate_right(self, n: u32) -> $T {\n-                // Protect against undefined behaviour for over-long bit shifts\n-                let n = n % $BITS;\n-                (self >> n) | (self << (($BITS - n) % $BITS))\n-            }\n-\n-            #[inline]\n-            fn swap_bytes(self) -> $T {\n-                unsafe { $bswap(self as $ActualT) as $T }\n-            }\n-\n-            #[inline]\n-            fn checked_add(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_sub(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_mul(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_div(self, v: $T) -> Option<$T> {\n-                match v {\n-                    0 => None,\n-                    v => Some(self / v),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n /// Swapping a single byte is a no-op. This is marked as `unsafe` for\n /// consistency with the other `bswap` intrinsics.\n unsafe fn bswap8(x: u8) -> u8 { x }\n \n-uint_impl! { u8 = u8, 8,\n-    intrinsics::ctpop8,\n-    intrinsics::ctlz8,\n-    intrinsics::cttz8,\n-    bswap8,\n-    intrinsics::u8_add_with_overflow,\n-    intrinsics::u8_sub_with_overflow,\n-    intrinsics::u8_mul_with_overflow }\n-\n-uint_impl! { u16 = u16, 16,\n-    intrinsics::ctpop16,\n-    intrinsics::ctlz16,\n-    intrinsics::cttz16,\n-    intrinsics::bswap16,\n-    intrinsics::u16_add_with_overflow,\n-    intrinsics::u16_sub_with_overflow,\n-    intrinsics::u16_mul_with_overflow }\n-\n-uint_impl! { u32 = u32, 32,\n-    intrinsics::ctpop32,\n-    intrinsics::ctlz32,\n-    intrinsics::cttz32,\n-    intrinsics::bswap32,\n-    intrinsics::u32_add_with_overflow,\n-    intrinsics::u32_sub_with_overflow,\n-    intrinsics::u32_mul_with_overflow }\n-\n-uint_impl! { u64 = u64, 64,\n-    intrinsics::ctpop64,\n-    intrinsics::ctlz64,\n-    intrinsics::cttz64,\n-    intrinsics::bswap64,\n-    intrinsics::u64_add_with_overflow,\n-    intrinsics::u64_sub_with_overflow,\n-    intrinsics::u64_mul_with_overflow }\n-\n-#[cfg(target_pointer_width = \"32\")]\n-uint_impl! { usize = u32, 32,\n-    intrinsics::ctpop32,\n-    intrinsics::ctlz32,\n-    intrinsics::cttz32,\n-    intrinsics::bswap32,\n-    intrinsics::u32_add_with_overflow,\n-    intrinsics::u32_sub_with_overflow,\n-    intrinsics::u32_mul_with_overflow }\n-\n-#[cfg(target_pointer_width = \"64\")]\n-uint_impl! { usize = u64, 64,\n-    intrinsics::ctpop64,\n-    intrinsics::ctlz64,\n-    intrinsics::cttz64,\n-    intrinsics::bswap64,\n-    intrinsics::u64_add_with_overflow,\n-    intrinsics::u64_sub_with_overflow,\n-    intrinsics::u64_mul_with_overflow }\n-\n-macro_rules! int_impl {\n-    ($T:ty = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n-     $add_with_overflow:path,\n-     $sub_with_overflow:path,\n-     $mul_with_overflow:path) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl Int for $T {\n-            #[inline]\n-            fn zero() -> $T { 0 }\n-\n-            #[inline]\n-            fn one() -> $T { 1 }\n-\n-            #[inline]\n-            fn min_value() -> $T { (-1 as $T) << ($BITS - 1) }\n-\n-            #[inline]\n-            fn max_value() -> $T { let min: $T = Int::min_value(); !min }\n-\n-            #[inline]\n-            fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n-\n-            #[inline]\n-            fn leading_zeros(self) -> u32 {\n-                (self as $UnsignedT).leading_zeros()\n-            }\n-\n-            #[inline]\n-            fn trailing_zeros(self) -> u32 {\n-                (self as $UnsignedT).trailing_zeros()\n-            }\n-\n-            #[inline]\n-            fn rotate_left(self, n: u32) -> $T {\n-                (self as $UnsignedT).rotate_left(n) as $T\n-            }\n-\n-            #[inline]\n-            fn rotate_right(self, n: u32) -> $T {\n-                (self as $UnsignedT).rotate_right(n) as $T\n-            }\n-\n-            #[inline]\n-            fn swap_bytes(self) -> $T {\n-                (self as $UnsignedT).swap_bytes() as $T\n-            }\n-\n-            #[inline]\n-            fn checked_add(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_sub(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_mul(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_div(self, v: $T) -> Option<$T> {\n-                match v {\n-                    0   => None,\n-                   -1 if self == Int::min_value()\n-                        => None,\n-                    v   => Some(self / v),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-int_impl! { i8 = i8, u8, 8,\n-    intrinsics::i8_add_with_overflow,\n-    intrinsics::i8_sub_with_overflow,\n-    intrinsics::i8_mul_with_overflow }\n-\n-int_impl! { i16 = i16, u16, 16,\n-    intrinsics::i16_add_with_overflow,\n-    intrinsics::i16_sub_with_overflow,\n-    intrinsics::i16_mul_with_overflow }\n-\n-int_impl! { i32 = i32, u32, 32,\n-    intrinsics::i32_add_with_overflow,\n-    intrinsics::i32_sub_with_overflow,\n-    intrinsics::i32_mul_with_overflow }\n-\n-int_impl! { i64 = i64, u64, 64,\n-    intrinsics::i64_add_with_overflow,\n-    intrinsics::i64_sub_with_overflow,\n-    intrinsics::i64_mul_with_overflow }\n-\n-#[cfg(target_pointer_width = \"32\")]\n-int_impl! { isize = i32, u32, 32,\n-    intrinsics::i32_add_with_overflow,\n-    intrinsics::i32_sub_with_overflow,\n-    intrinsics::i32_mul_with_overflow }\n-\n-#[cfg(target_pointer_width = \"64\")]\n-int_impl! { isize = i64, u64, 64,\n-    intrinsics::i64_add_with_overflow,\n-    intrinsics::i64_sub_with_overflow,\n-    intrinsics::i64_mul_with_overflow }\n-\n-/// A built-in two's complement integer.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"replaced by inherent methods; for generics, use rust-lang/num\")]\n-#[allow(deprecated)]\n-pub trait SignedInt\n-    : Int\n-    + Neg<Output=Self>\n-{\n-    /// Computes the absolute value of `self`. `Int::min_value()` will be\n-    /// returned if the number is `Int::min_value()`.\n-    #[unstable(feature = \"core\", reason = \"overflow in debug builds?\")]\n-    fn abs(self) -> Self;\n-\n-    /// Returns a number representing sign of `self`.\n-    ///\n-    /// - `0` if the number is zero\n-    /// - `1` if the number is positive\n-    /// - `-1` if the number is negative\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn signum(self) -> Self;\n-\n-    /// Returns `true` if `self` is positive and `false` if the number\n-    /// is zero or negative.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_positive(self) -> bool;\n-\n-    /// Returns `true` if `self` is negative and `false` if the number\n-    /// is zero or positive.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_negative(self) -> bool;\n-}\n-\n-macro_rules! signed_int_impl {\n-    ($T:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl SignedInt for $T {\n-            #[inline]\n-            fn abs(self) -> $T {\n-                if self.is_negative() { -self } else { self }\n-            }\n-\n-            #[inline]\n-            fn signum(self) -> $T {\n-                match self {\n-                    n if n > 0 =>  1,\n-                    0          =>  0,\n-                    _          => -1,\n-                }\n-            }\n-\n-            #[inline]\n-            fn is_positive(self) -> bool { self > 0 }\n-\n-            #[inline]\n-            fn is_negative(self) -> bool { self < 0 }\n-        }\n-    }\n-}\n-\n-signed_int_impl! { i8 }\n-signed_int_impl! { i16 }\n-signed_int_impl! { i32 }\n-signed_int_impl! { i64 }\n-signed_int_impl! { isize }\n-\n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n-    ($T:ty = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n+    ($T:ident = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n@@ -840,7 +120,7 @@ macro_rules! int_impl {\n         /// Returns the largest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub fn max_value() -> $T {\n-            let min: $T = Int::min_value(); !min\n+            let min = $T::min_value(); !min\n         }\n \n         /// Converts a string slice in a given base to an integer.\n@@ -859,17 +139,14 @@ macro_rules! int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n         pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n-            <Self as FromStrRadix>::from_str_radix(src, radix)\n+            from_str_radix(src, radix)\n         }\n \n         /// Returns the number of ones in the binary representation of `self`.\n         ///\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_ones(), 3);\n@@ -883,9 +160,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_zeros(), 5);\n@@ -902,9 +176,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.leading_zeros(), 10);\n@@ -921,9 +192,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.trailing_zeros(), 3);\n@@ -940,9 +208,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0x3456789ABCDEF012u64;\n         ///\n@@ -961,9 +226,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xDEF0123456789ABCu64;\n         ///\n@@ -980,8 +242,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xEFCDAB8967452301u64;\n         ///\n@@ -1001,14 +261,12 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n-        ///     assert_eq!(Int::from_be(n), n)\n+        ///     assert_eq!(u64::from_be(n), n)\n         /// } else {\n-        ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n+        ///     assert_eq!(u64::from_be(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1025,14 +283,12 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n-        ///     assert_eq!(Int::from_le(n), n)\n+        ///     assert_eq!(u64::from_le(n), n)\n         /// } else {\n-        ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n+        ///     assert_eq!(u64::from_le(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1049,8 +305,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n@@ -1073,8 +327,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n@@ -1095,8 +347,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!(5u16.checked_add(65530), Some(65535));\n         /// assert_eq!(6u16.checked_add(65530), None);\n         /// ```\n@@ -1112,8 +362,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n         /// assert_eq!((-128i8).checked_sub(1), None);\n         /// ```\n@@ -1129,8 +377,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!(5u8.checked_mul(51), Some(255));\n         /// assert_eq!(5u8.checked_mul(52), None);\n         /// ```\n@@ -1146,8 +392,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!((-127i8).checked_div(-1), Some(127));\n         /// assert_eq!((-128i8).checked_div(-1), None);\n         /// assert_eq!((1i8).checked_div(0), None);\n@@ -1439,17 +683,14 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n         pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n-            <Self as FromStrRadix>::from_str_radix(src, radix)\n+            from_str_radix(src, radix)\n         }\n \n         /// Returns the number of ones in the binary representation of `self`.\n         ///\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_ones(), 3);\n@@ -1465,9 +706,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_zeros(), 5);\n@@ -1484,9 +722,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.leading_zeros(), 10);\n@@ -1503,9 +738,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.trailing_zeros(), 3);\n@@ -1522,9 +754,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0x3456789ABCDEF012u64;\n         ///\n@@ -1545,9 +774,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xDEF0123456789ABCu64;\n         ///\n@@ -1566,8 +792,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xEFCDAB8967452301u64;\n         ///\n@@ -1587,14 +811,12 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n-        ///     assert_eq!(Int::from_be(n), n)\n+        ///     assert_eq!(u64::from_be(n), n)\n         /// } else {\n-        ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n+        ///     assert_eq!(u64::from_be(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1611,14 +833,12 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n-        ///     assert_eq!(Int::from_le(n), n)\n+        ///     assert_eq!(u64::from_le(n), n)\n         /// } else {\n-        ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n+        ///     assert_eq!(u64::from_le(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1635,8 +855,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n@@ -1659,8 +877,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n@@ -1681,8 +897,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!(5u16.checked_add(65530), Some(65535));\n         /// assert_eq!(6u16.checked_add(65530), None);\n         /// ```\n@@ -1698,8 +912,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n         /// assert_eq!((-128i8).checked_sub(1), None);\n         /// ```\n@@ -1715,8 +927,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!(5u8.checked_mul(51), Some(255));\n         /// assert_eq!(5u8.checked_mul(52), None);\n         /// ```\n@@ -1732,8 +942,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!((-127i8).checked_div(-1), Some(127));\n         /// assert_eq!((-128i8).checked_div(-1), None);\n         /// assert_eq!((1i8).checked_div(0), None);\n@@ -1866,10 +1074,7 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n-        /// assert_eq!(2.pow(4), 16);\n+        /// assert_eq!(2i32.pow(4), 16);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -2007,575 +1212,6 @@ impl usize {\n         intrinsics::u64_mul_with_overflow }\n }\n \n-/// A generic trait for converting a value to a number.\n-#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n-pub trait ToPrimitive {\n-    /// Converts the value of `self` to an `isize`.\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use to_isize\")]\n-    fn to_int(&self) -> Option<isize> {\n-        self.to_i64().and_then(|x| x.to_isize())\n-    }\n-\n-    /// Converts the value of `self` to an `isize`.\n-    #[inline]\n-    fn to_isize(&self) -> Option<isize> {\n-        self.to_i64().and_then(|x| x.to_isize())\n-    }\n-\n-    /// Converts the value of `self` to an `i8`.\n-    #[inline]\n-    fn to_i8(&self) -> Option<i8> {\n-        self.to_i64().and_then(|x| x.to_i8())\n-    }\n-\n-    /// Converts the value of `self` to an `i16`.\n-    #[inline]\n-    fn to_i16(&self) -> Option<i16> {\n-        self.to_i64().and_then(|x| x.to_i16())\n-    }\n-\n-    /// Converts the value of `self` to an `i32`.\n-    #[inline]\n-    fn to_i32(&self) -> Option<i32> {\n-        self.to_i64().and_then(|x| x.to_i32())\n-    }\n-\n-    /// Converts the value of `self` to an `i64`.\n-    fn to_i64(&self) -> Option<i64>;\n-\n-    /// Converts the value of `self` to an `usize`.\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use to_usize\")]\n-    fn to_uint(&self) -> Option<usize> {\n-        self.to_u64().and_then(|x| x.to_usize())\n-    }\n-\n-    /// Converts the value of `self` to a `usize`.\n-    #[inline]\n-    fn to_usize(&self) -> Option<usize> {\n-        self.to_u64().and_then(|x| x.to_usize())\n-    }\n-\n-    /// Converts the value of `self` to an `u8`.\n-    #[inline]\n-    fn to_u8(&self) -> Option<u8> {\n-        self.to_u64().and_then(|x| x.to_u8())\n-    }\n-\n-    /// Converts the value of `self` to an `u16`.\n-    #[inline]\n-    fn to_u16(&self) -> Option<u16> {\n-        self.to_u64().and_then(|x| x.to_u16())\n-    }\n-\n-    /// Converts the value of `self` to an `u32`.\n-    #[inline]\n-    fn to_u32(&self) -> Option<u32> {\n-        self.to_u64().and_then(|x| x.to_u32())\n-    }\n-\n-    /// Converts the value of `self` to an `u64`.\n-    #[inline]\n-    fn to_u64(&self) -> Option<u64>;\n-\n-    /// Converts the value of `self` to an `f32`.\n-    #[inline]\n-    fn to_f32(&self) -> Option<f32> {\n-        self.to_f64().and_then(|x| x.to_f32())\n-    }\n-\n-    /// Converts the value of `self` to an `f64`.\n-    #[inline]\n-    fn to_f64(&self) -> Option<f64> {\n-        self.to_i64().and_then(|x| x.to_f64())\n-    }\n-}\n-\n-macro_rules! impl_to_primitive_int_to_int {\n-    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n-        {\n-            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some($slf as $DstT)\n-            } else {\n-                let n = $slf as i64;\n-                let min_value: $DstT = Int::min_value();\n-                let max_value: $DstT = Int::max_value();\n-                if min_value as i64 <= n && n <= max_value as i64 {\n-                    Some($slf as $DstT)\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_int_to_uint {\n-    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n-        {\n-            let zero: $SrcT = Int::zero();\n-            let max_value: $DstT = Int::max_value();\n-            if zero <= $slf && $slf as u64 <= max_value as u64 {\n-                Some($slf as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_int {\n-    ($T:ty) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<isize> { impl_to_primitive_int_to_int!($T, isize, *self) }\n-            #[inline]\n-            fn to_isize(&self) -> Option<isize> { impl_to_primitive_int_to_int!($T, isize, *self) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8, *self) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16, *self) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32, *self) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64, *self) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<usize> { impl_to_primitive_int_to_uint!($T, usize, *self) }\n-            #[inline]\n-            fn to_usize(&self) -> Option<usize> { impl_to_primitive_int_to_uint!($T, usize, *self) }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8, *self) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16, *self) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32, *self) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64, *self) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n-        }\n-    )\n-}\n-\n-impl_to_primitive_int! { isize }\n-impl_to_primitive_int! { i8 }\n-impl_to_primitive_int! { i16 }\n-impl_to_primitive_int! { i32 }\n-impl_to_primitive_int! { i64 }\n-\n-macro_rules! impl_to_primitive_uint_to_int {\n-    ($DstT:ty, $slf:expr) => (\n-        {\n-            let max_value: $DstT = Int::max_value();\n-            if $slf as u64 <= max_value as u64 {\n-                Some($slf as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_uint_to_uint {\n-    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n-        {\n-            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some($slf as $DstT)\n-            } else {\n-                let zero: $SrcT = Int::zero();\n-                let max_value: $DstT = Int::max_value();\n-                if zero <= $slf && $slf as u64 <= max_value as u64 {\n-                    Some($slf as $DstT)\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_uint {\n-    ($T:ty) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<isize> { impl_to_primitive_uint_to_int!(isize, *self) }\n-            #[inline]\n-            fn to_isize(&self) -> Option<isize> { impl_to_primitive_uint_to_int!(isize, *self) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8, *self) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16, *self) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32, *self) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64, *self) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<usize> { impl_to_primitive_uint_to_uint!($T, usize, *self) }\n-            #[inline]\n-            fn to_usize(&self) -> Option<usize> {\n-                impl_to_primitive_uint_to_uint!($T, usize, *self)\n-            }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8, *self) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16, *self) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32, *self) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64, *self) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n-        }\n-    )\n-}\n-\n-impl_to_primitive_uint! { usize }\n-impl_to_primitive_uint! { u8 }\n-impl_to_primitive_uint! { u16 }\n-impl_to_primitive_uint! { u32 }\n-impl_to_primitive_uint! { u64 }\n-\n-macro_rules! impl_to_primitive_float_to_float {\n-    ($SrcT:ident, $DstT:ident, $slf:expr) => (\n-        if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-            Some($slf as $DstT)\n-        } else {\n-            let n = $slf as f64;\n-            let max_value: $SrcT = ::$SrcT::MAX;\n-            if -max_value as f64 <= n && n <= max_value as f64 {\n-                Some($slf as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_float {\n-    ($T:ident) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<isize> { Some(*self as isize) }\n-            #[inline]\n-            fn to_isize(&self) -> Option<isize> { Some(*self as isize) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { Some(*self as i8) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { Some(*self as i16) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { Some(*self as i32) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { Some(*self as i64) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<usize> { Some(*self as usize) }\n-            #[inline]\n-            fn to_usize(&self) -> Option<usize> { Some(*self as usize) }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { Some(*self as u8) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { Some(*self as u16) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { Some(*self as u32) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { Some(*self as u64) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32, *self) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64, *self) }\n-        }\n-    )\n-}\n-\n-impl_to_primitive_float! { f32 }\n-impl_to_primitive_float! { f64 }\n-\n-/// A generic trait for converting a number to a value.\n-#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n-pub trait FromPrimitive : ::marker::Sized {\n-    /// Converts an `isize` to return an optional value of this type. If the\n-    /// value cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use from_isize\")]\n-    fn from_int(n: isize) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `isize` to return an optional value of this type. If the\n-    /// value cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_isize(n: isize) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `i8` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i8(n: i8) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `i16` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i16(n: i16) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `i32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i32(n: i32) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `i64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    fn from_i64(n: i64) -> Option<Self>;\n-\n-    /// Converts an `usize` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use from_usize\")]\n-    fn from_uint(n: usize) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts a `usize` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_usize(n: usize) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts an `u8` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u8(n: u8) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts an `u16` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u16(n: u16) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts an `u32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u32(n: u32) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts an `u64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    fn from_u64(n: u64) -> Option<Self>;\n-\n-    /// Converts a `f32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_f32(n: f32) -> Option<Self> {\n-        FromPrimitive::from_f64(n as f64)\n-    }\n-\n-    /// Converts a `f64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_f64(n: f64) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_int`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use from_isize\")]\n-pub fn from_int<A: FromPrimitive>(n: isize) -> Option<A> {\n-    FromPrimitive::from_isize(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_isize`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_isize<A: FromPrimitive>(n: isize) -> Option<A> {\n-    FromPrimitive::from_isize(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i8`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n-    FromPrimitive::from_i8(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i16`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n-    FromPrimitive::from_i16(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i32`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n-    FromPrimitive::from_i32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i64`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n-    FromPrimitive::from_i64(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_uint`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use from_uint\")]\n-pub fn from_uint<A: FromPrimitive>(n: usize) -> Option<A> {\n-    FromPrimitive::from_usize(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_usize`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_usize<A: FromPrimitive>(n: usize) -> Option<A> {\n-    FromPrimitive::from_usize(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u8`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n-    FromPrimitive::from_u8(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u16`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n-    FromPrimitive::from_u16(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u32`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n-    FromPrimitive::from_u32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u64`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n-    FromPrimitive::from_u64(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_f32`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n-    FromPrimitive::from_f32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_f64`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n-    FromPrimitive::from_f64(n)\n-}\n-\n-macro_rules! impl_from_primitive {\n-    ($T:ty, $to_ty:ident) => (\n-        #[allow(deprecated)]\n-        impl FromPrimitive for $T {\n-            #[inline] fn from_int(n: isize) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_i8(n: i8) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_i16(n: i16) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_i32(n: i32) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_i64(n: i64) -> Option<$T> { n.$to_ty() }\n-\n-            #[inline] fn from_uint(n: usize) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_u8(n: u8) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_u16(n: u16) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_u32(n: u32) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_u64(n: u64) -> Option<$T> { n.$to_ty() }\n-\n-            #[inline] fn from_f32(n: f32) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_f64(n: f64) -> Option<$T> { n.$to_ty() }\n-        }\n-    )\n-}\n-\n-impl_from_primitive! { isize, to_int }\n-impl_from_primitive! { i8, to_i8 }\n-impl_from_primitive! { i16, to_i16 }\n-impl_from_primitive! { i32, to_i32 }\n-impl_from_primitive! { i64, to_i64 }\n-impl_from_primitive! { usize, to_uint }\n-impl_from_primitive! { u8, to_u8 }\n-impl_from_primitive! { u16, to_u16 }\n-impl_from_primitive! { u32, to_u32 }\n-impl_from_primitive! { u64, to_u64 }\n-impl_from_primitive! { f32, to_f32 }\n-impl_from_primitive! { f64, to_f64 }\n-\n-/// Casts from one machine scalar to another.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(core)]\n-/// use std::num;\n-///\n-/// let twenty: f32 = num::cast(0x14).unwrap();\n-/// assert_eq!(twenty, 20f32);\n-/// ```\n-///\n-#[inline]\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n-    NumCast::from(n)\n-}\n-\n-/// An interface for casting between machine scalars.\n-#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n-pub trait NumCast: ToPrimitive {\n-    /// Creates a number from another value that can be converted into a primitive via the\n-    /// `ToPrimitive` trait.\n-    fn from<T: ToPrimitive>(n: T) -> Option<Self>;\n-}\n-\n-macro_rules! impl_num_cast {\n-    ($T:ty, $conv:ident) => (\n-        impl NumCast for $T {\n-            #[inline]\n-            #[allow(deprecated)]\n-            fn from<N: ToPrimitive>(n: N) -> Option<$T> {\n-                // `$conv` could be generated using `concat_idents!`, but that\n-                // macro seems to be broken at the moment\n-                n.$conv()\n-            }\n-        }\n-    )\n-}\n-\n-impl_num_cast! { u8,    to_u8 }\n-impl_num_cast! { u16,   to_u16 }\n-impl_num_cast! { u32,   to_u32 }\n-impl_num_cast! { u64,   to_u64 }\n-impl_num_cast! { usize,  to_uint }\n-impl_num_cast! { i8,    to_i8 }\n-impl_num_cast! { i16,   to_i16 }\n-impl_num_cast! { i32,   to_i32 }\n-impl_num_cast! { i64,   to_i64 }\n-impl_num_cast! { isize,   to_int }\n-impl_num_cast! { f32,   to_f32 }\n-impl_num_cast! { f64,   to_f64 }\n-\n /// Used for representing the classification of floating point numbers\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2602,93 +1238,22 @@ pub enum FpCategory {\n }\n \n /// A built-in floating point number.\n-// FIXME(#5527): In a future version of Rust, many of these functions will\n-//               become constants.\n-//\n-// FIXME(#8888): Several of these functions have a parameter named\n-//               `unused_self`. Removing it requires #8888 to be fixed.\n-#[unstable(feature = \"core\",\n-           reason = \"distribution of methods between core/std is unclear\")]\n #[doc(hidden)]\n-pub trait Float\n-    : Copy + Clone\n-    + NumCast\n-    + PartialOrd\n-    + PartialEq\n-    + Neg<Output=Self>\n-    + Add<Output=Self>\n-    + Sub<Output=Self>\n-    + Mul<Output=Self>\n-    + Div<Output=Self>\n-    + Rem<Output=Self>\n-{\n+pub trait Float {\n     /// Returns the NaN value.\n     fn nan() -> Self;\n     /// Returns the infinite value.\n     fn infinity() -> Self;\n     /// Returns the negative infinite value.\n     fn neg_infinity() -> Self;\n-    /// Returns the `0` value.\n-    fn zero() -> Self;\n     /// Returns -0.0.\n     fn neg_zero() -> Self;\n-    /// Returns the `1` value.\n+    /// Returns 0.0.\n+    fn zero() -> Self;\n+    /// Returns 1.0.\n     fn one() -> Self;\n-\n-    // FIXME (#5527): These should be associated constants\n-\n-    /// Returns the number of binary digits of mantissa that this type supports.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n-                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n-    fn mantissa_digits(unused_self: Option<Self>) -> usize;\n-    /// Returns the number of base-10 digits of precision that this type supports.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n-    fn digits(unused_self: Option<Self>) -> usize;\n-    /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n-    fn epsilon() -> Self;\n-    /// Returns the minimum binary exponent that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n-    fn min_exp(unused_self: Option<Self>) -> isize;\n-    /// Returns the maximum binary exponent that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n-    fn max_exp(unused_self: Option<Self>) -> isize;\n-    /// Returns the minimum base-10 exponent that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n-    fn min_10_exp(unused_self: Option<Self>) -> isize;\n-    /// Returns the maximum base-10 exponent that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n-    fn max_10_exp(unused_self: Option<Self>) -> isize;\n-    /// Returns the smallest finite value that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN` or `std::f64::MIN` as appropriate\")]\n-    fn min_value() -> Self;\n-    /// Returns the smallest normalized positive number that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_POSITIVE` or \\\n-                           `std::f64::MIN_POSITIVE` as appropriate\")]\n-    fn min_pos_value(unused_self: Option<Self>) -> Self;\n-    /// Returns the largest finite value that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX` or `std::f64::MAX` as appropriate\")]\n-    fn max_value() -> Self;\n+    /// Parses the string `s` with the radix `r` as a float.\n+    fn from_str_radix(s: &str, r: u32) -> Result<Self, ParseFloatError>;\n \n     /// Returns true if this value is NaN and false otherwise.\n     fn is_nan(self) -> bool;\n@@ -2705,16 +1270,16 @@ pub trait Float\n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Returns the largest integer less than or equal to a number.\n+    /// Return the largest integer less than or equal to a number.\n     fn floor(self) -> Self;\n-    /// Returns the smallest integer greater than or equal to a number.\n+    /// Return the smallest integer greater than or equal to a number.\n     fn ceil(self) -> Self;\n-    /// Returns the nearest integer to a number. Round half-way cases away from\n+    /// Return the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n     fn round(self) -> Self;\n-    /// Returns the integer part of a number.\n+    /// Return the integer part of a number.\n     fn trunc(self) -> Self;\n-    /// Returns the fractional part of a number.\n+    /// Return the fractional part of a number.\n     fn fract(self) -> Self;\n \n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n@@ -2737,21 +1302,21 @@ pub trait Float\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n     fn mul_add(self, a: Self, b: Self) -> Self;\n-    /// Takes the reciprocal (inverse) of a number, `1/x`.\n+    /// Take the reciprocal (inverse) of a number, `1/x`.\n     fn recip(self) -> Self;\n \n-    /// Raises a number to an integer power.\n+    /// Raise a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n     fn powi(self, n: i32) -> Self;\n-    /// Raises a number to a floating point power.\n+    /// Raise a number to a floating point power.\n     fn powf(self, n: Self) -> Self;\n \n-    /// Takes the square root of a number.\n+    /// Take the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n     fn sqrt(self) -> Self;\n-    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     fn rsqrt(self) -> Self;\n \n     /// Returns `e^(self)`, (the exponential function).\n@@ -2767,39 +1332,14 @@ pub trait Float\n     /// Returns the base 10 logarithm of the number.\n     fn log10(self) -> Self;\n \n-    /// Converts radians to degrees.\n+    /// Convert radians to degrees.\n     fn to_degrees(self) -> Self;\n-    /// Converts degrees to radians.\n+    /// Convert degrees to radians.\n     fn to_radians(self) -> Self;\n }\n \n-/// A generic trait for converting a string with a radix (base) to a value\n-#[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"moved to inherent methods; use e.g. i32::from_str_radix\")]\n-pub trait FromStrRadix {\n-    #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"moved to inherent methods\")]\n-    type Err;\n-\n-    #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"moved to inherent methods; use e.g. i32::from_str_radix\")]\n-    #[allow(deprecated)]\n-    fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::Err>;\n-}\n-\n-/// A utility function that just calls `FromStrRadix::from_str_radix`.\n-#[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use e.g. i32::from_str_radix\")]\n-#[allow(deprecated)]\n-pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: u32)\n-                                       -> Result<T, T::Err> {\n-    FromStrRadix::from_str_radix(str, radix)\n-}\n-\n-macro_rules! from_str_radix_float_impl {\n-    ($T:ty) => {\n+macro_rules! from_str_float_impl {\n+    ($T:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStr for $T {\n             type Err = ParseFloatError;\n@@ -2827,265 +1367,113 @@ macro_rules! from_str_radix_float_impl {\n             ///\n             /// # Return value\n             ///\n-            /// `Err(ParseFloatError)` if the string did not represent a valid number.\n-            /// Otherwise, `Ok(n)` where `n` is the floating-point number represented by `src`.\n+            /// `Err(ParseFloatError)` if the string did not represent a valid\n+            /// number.  Otherwise, `Ok(n)` where `n` is the floating-point\n+            /// number represented by `src`.\n             #[inline]\n             #[allow(deprecated)]\n             fn from_str(src: &str) -> Result<$T, ParseFloatError> {\n-                from_str_radix(src, 10)\n-            }\n-        }\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl FromStrRadix for $T {\n-            type Err = ParseFloatError;\n-\n-            /// Converts a string in a given base to a float.\n-            ///\n-            /// Due to possible conflicts, this function does **not** accept\n-            /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n-            /// does it recognize exponents of any kind.\n-            ///\n-            /// Leading and trailing whitespace represent an error.\n-            ///\n-            /// # Arguments\n-            ///\n-            /// * src - A string\n-            /// * radix - The base to use. Must lie in the range [2 .. 36]\n-            ///\n-            /// # Return value\n-            ///\n-            /// `Err(ParseFloatError)` if the string did not represent a valid number.\n-            /// Otherwise, `Ok(n)` where `n` is the floating-point number represented by `src`.\n-            fn from_str_radix(src: &str, radix: u32)\n-                              -> Result<$T, ParseFloatError> {\n-                use self::FloatErrorKind::*;\n-                use self::ParseFloatError as PFE;\n-                assert!(radix >= 2 && radix <= 36,\n-                       \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n-                       radix);\n-\n-                // Special values\n-                match src {\n-                    \"inf\"   => return Ok(Float::infinity()),\n-                    \"-inf\"  => return Ok(Float::neg_infinity()),\n-                    \"NaN\"   => return Ok(Float::nan()),\n-                    _       => {},\n-                }\n-\n-                let (is_positive, src) =  match src.slice_shift_char() {\n-                    None             => return Err(PFE { kind: Empty }),\n-                    Some(('-', \"\"))  => return Err(PFE { kind: Empty }),\n-                    Some(('-', src)) => (false, src),\n-                    Some((_, _))     => (true,  src),\n-                };\n-\n-                // The significand to accumulate\n-                let mut sig = if is_positive { 0.0 } else { -0.0 };\n-                // Necessary to detect overflow\n-                let mut prev_sig = sig;\n-                let mut cs = src.chars().enumerate();\n-                // Exponent prefix and exponent index offset\n-                let mut exp_info = None::<(char, usize)>;\n-\n-                // Parse the integer part of the significand\n-                for (i, c) in cs.by_ref() {\n-                    match c.to_digit(radix) {\n-                        Some(digit) => {\n-                            // shift significand one digit left\n-                            sig = sig * (radix as $T);\n-\n-                            // add/subtract current digit depending on sign\n-                            if is_positive {\n-                                sig = sig + ((digit as isize) as $T);\n-                            } else {\n-                                sig = sig - ((digit as isize) as $T);\n-                            }\n-\n-                            // Detect overflow by comparing to last value, except\n-                            // if we've not seen any non-zero digits.\n-                            if prev_sig != 0.0 {\n-                                if is_positive && sig <= prev_sig\n-                                    { return Ok(Float::infinity()); }\n-                                if !is_positive && sig >= prev_sig\n-                                    { return Ok(Float::neg_infinity()); }\n-\n-                                // Detect overflow by reversing the shift-and-add process\n-                                if is_positive && (prev_sig != (sig - digit as $T) / radix as $T)\n-                                    { return Ok(Float::infinity()); }\n-                                if !is_positive && (prev_sig != (sig + digit as $T) / radix as $T)\n-                                    { return Ok(Float::neg_infinity()); }\n-                            }\n-                            prev_sig = sig;\n-                        },\n-                        None => match c {\n-                            'e' | 'E' | 'p' | 'P' => {\n-                                exp_info = Some((c, i + 1));\n-                                break;  // start of exponent\n-                            },\n-                            '.' => {\n-                                break;  // start of fractional part\n-                            },\n-                            _ => {\n-                                return Err(PFE { kind: Invalid });\n-                            },\n-                        },\n-                    }\n-                }\n-\n-                // If we are not yet at the exponent parse the fractional\n-                // part of the significand\n-                if exp_info.is_none() {\n-                    let mut power = 1.0;\n-                    for (i, c) in cs.by_ref() {\n-                        match c.to_digit(radix) {\n-                            Some(digit) => {\n-                                // Decrease power one order of magnitude\n-                                power = power / (radix as $T);\n-                                // add/subtract current digit depending on sign\n-                                sig = if is_positive {\n-                                    sig + (digit as $T) * power\n-                                } else {\n-                                    sig - (digit as $T) * power\n-                                };\n-                                // Detect overflow by comparing to last value\n-                                if is_positive && sig < prev_sig\n-                                    { return Ok(Float::infinity()); }\n-                                if !is_positive && sig > prev_sig\n-                                    { return Ok(Float::neg_infinity()); }\n-                                prev_sig = sig;\n-                            },\n-                            None => match c {\n-                                'e' | 'E' | 'p' | 'P' => {\n-                                    exp_info = Some((c, i + 1));\n-                                    break; // start of exponent\n-                                },\n-                                _ => {\n-                                    return Err(PFE { kind: Invalid });\n-                                },\n-                            },\n-                        }\n-                    }\n-                }\n-\n-                // Parse and calculate the exponent\n-                let exp = match exp_info {\n-                    Some((c, offset)) => {\n-                        let base = match c {\n-                            'E' | 'e' if radix == 10 => 10.0,\n-                            'P' | 'p' if radix == 16 => 2.0,\n-                            _ => return Err(PFE { kind: Invalid }),\n-                        };\n-\n-                        // Parse the exponent as decimal integer\n-                        let src = &src[offset..];\n-                        let (is_positive, exp) = match src.slice_shift_char() {\n-                            Some(('-', src)) => (false, src.parse::<usize>()),\n-                            Some(('+', src)) => (true,  src.parse::<usize>()),\n-                            Some((_, _))     => (true,  src.parse::<usize>()),\n-                            None             => return Err(PFE { kind: Invalid }),\n-                        };\n-\n-                        match (is_positive, exp) {\n-                            (true,  Ok(exp)) => base.powi(exp as i32),\n-                            (false, Ok(exp)) => 1.0 / base.powi(exp as i32),\n-                            (_, Err(_))      => return Err(PFE { kind: Invalid }),\n-                        }\n-                    },\n-                    None => 1.0, // no exponent\n-                };\n-\n-                Ok(sig * exp)\n+                $T::from_str_radix(src, 10)\n             }\n         }\n     }\n }\n-from_str_radix_float_impl! { f32 }\n-from_str_radix_float_impl! { f64 }\n+from_str_float_impl!(f32);\n+from_str_float_impl!(f64);\n \n macro_rules! from_str_radix_int_impl {\n-    ($T:ty) => {\n+    ($($T:ident)*) => {$(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n         impl FromStr for $T {\n             type Err = ParseIntError;\n-            #[inline]\n             fn from_str(src: &str) -> Result<$T, ParseIntError> {\n                 from_str_radix(src, 10)\n             }\n         }\n+    )*}\n+}\n+from_str_radix_int_impl! { isize i8 i16 i32 i64 usize u8 u16 u32 u64 }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl FromStrRadix for $T {\n-            type Err = ParseIntError;\n-            fn from_str_radix(src: &str, radix: u32)\n-                              -> Result<$T, ParseIntError> {\n-                use self::IntErrorKind::*;\n-                use self::ParseIntError as PIE;\n-                assert!(radix >= 2 && radix <= 36,\n-                       \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n-                       radix);\n-\n-                let is_signed_ty = (0 as $T) > Int::min_value();\n-\n-                match src.slice_shift_char() {\n-                    Some(('-', \"\")) => Err(PIE { kind: Empty }),\n-                    Some(('-', src)) if is_signed_ty => {\n-                        // The number is negative\n-                        let mut result = 0;\n-                        for c in src.chars() {\n-                            let x = match c.to_digit(radix) {\n-                                Some(x) => x,\n-                                None => return Err(PIE { kind: InvalidDigit }),\n-                            };\n-                            result = match result.checked_mul(radix as $T) {\n-                                Some(result) => result,\n-                                None => return Err(PIE { kind: Underflow }),\n-                            };\n-                            result = match result.checked_sub(x as $T) {\n-                                Some(result) => result,\n-                                None => return Err(PIE { kind: Underflow }),\n-                            };\n-                        }\n-                        Ok(result)\n-                    },\n-                    Some((_, _)) => {\n-                        // The number is signed\n-                        let mut result = 0;\n-                        for c in src.chars() {\n-                            let x = match c.to_digit(radix) {\n-                                Some(x) => x,\n-                                None => return Err(PIE { kind: InvalidDigit }),\n-                            };\n-                            result = match result.checked_mul(radix as $T) {\n-                                Some(result) => result,\n-                                None => return Err(PIE { kind: Overflow }),\n-                            };\n-                            result = match result.checked_add(x as $T) {\n-                                Some(result) => result,\n-                                None => return Err(PIE { kind: Overflow }),\n-                            };\n-                        }\n-                        Ok(result)\n-                    },\n-                    None => Err(ParseIntError { kind: Empty }),\n-                }\n+#[doc(hidden)]\n+trait FromStrRadixHelper: PartialOrd + Copy {\n+    fn min_value() -> Self;\n+    fn from_u32(u: u32) -> Self;\n+    fn checked_mul(&self, other: u32) -> Option<Self>;\n+    fn checked_sub(&self, other: u32) -> Option<Self>;\n+    fn checked_add(&self, other: u32) -> Option<Self>;\n+}\n+\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl FromStrRadixHelper for $t {\n+        fn min_value() -> Self { <$t>::min_value() }\n+        fn from_u32(u: u32) -> Self { u as $t }\n+        fn checked_mul(&self, other: u32) -> Option<Self> {\n+            <$t>::checked_mul(*self, other as $t)\n+        }\n+        fn checked_sub(&self, other: u32) -> Option<Self> {\n+            <$t>::checked_sub(*self, other as $t)\n+        }\n+        fn checked_add(&self, other: u32) -> Option<Self> {\n+            <$t>::checked_add(*self, other as $t)\n+        }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n+fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n+                                         -> Result<T, ParseIntError> {\n+    use self::IntErrorKind::*;\n+    use self::ParseIntError as PIE;\n+    assert!(radix >= 2 && radix <= 36,\n+           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n+           radix);\n+\n+    let is_signed_ty = T::from_u32(0) > T::min_value();\n+\n+    match src.slice_shift_char() {\n+        Some(('-', \"\")) => Err(PIE { kind: Empty }),\n+        Some(('-', src)) if is_signed_ty => {\n+            // The number is negative\n+            let mut result = T::from_u32(0);\n+            for c in src.chars() {\n+                let x = match c.to_digit(radix) {\n+                    Some(x) => x,\n+                    None => return Err(PIE { kind: InvalidDigit }),\n+                };\n+                result = match result.checked_mul(radix) {\n+                    Some(result) => result,\n+                    None => return Err(PIE { kind: Underflow }),\n+                };\n+                result = match result.checked_sub(x) {\n+                    Some(result) => result,\n+                    None => return Err(PIE { kind: Underflow }),\n+                };\n             }\n-        }\n+            Ok(result)\n+        },\n+        Some((_, _)) => {\n+            // The number is signed\n+            let mut result = T::from_u32(0);\n+            for c in src.chars() {\n+                let x = match c.to_digit(radix) {\n+                    Some(x) => x,\n+                    None => return Err(PIE { kind: InvalidDigit }),\n+                };\n+                result = match result.checked_mul(radix) {\n+                    Some(result) => result,\n+                    None => return Err(PIE { kind: Overflow }),\n+                };\n+                result = match result.checked_add(x) {\n+                    Some(result) => result,\n+                    None => return Err(PIE { kind: Overflow }),\n+                };\n+            }\n+            Ok(result)\n+        },\n+        None => Err(ParseIntError { kind: Empty }),\n     }\n }\n-from_str_radix_int_impl! { isize }\n-from_str_radix_int_impl! { i8 }\n-from_str_radix_int_impl! { i16 }\n-from_str_radix_int_impl! { i32 }\n-from_str_radix_int_impl! { i64 }\n-from_str_radix_int_impl! { usize }\n-from_str_radix_int_impl! { u8 }\n-from_str_radix_int_impl! { u16 }\n-from_str_radix_int_impl! { u32 }\n-from_str_radix_int_impl! { u64 }\n \n /// An error which can be returned when parsing an integer.\n #[derive(Debug, Clone, PartialEq)]\n@@ -3121,11 +1509,10 @@ impl fmt::Display for ParseIntError {\n \n /// An error which can be returned when parsing a float.\n #[derive(Debug, Clone, PartialEq)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ParseFloatError { kind: FloatErrorKind }\n+pub struct ParseFloatError { pub kind: FloatErrorKind }\n \n #[derive(Debug, Clone, PartialEq)]\n-enum FloatErrorKind {\n+pub enum FloatErrorKind {\n     Empty,\n     Invalid,\n }"}, {"sha": "b7ca497db18637bcd0d1d83a9c1d945a550b5b24", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -15,8 +15,6 @@ use super::Wrapping;\n \n use ops::*;\n \n-use intrinsics::{overflowing_add, overflowing_sub, overflowing_mul};\n-\n use intrinsics::{i8_add_with_overflow, u8_add_with_overflow};\n use intrinsics::{i16_add_with_overflow, u16_add_with_overflow};\n use intrinsics::{i32_add_with_overflow, u32_add_with_overflow};\n@@ -32,14 +30,6 @@ use intrinsics::{i64_mul_with_overflow, u64_mul_with_overflow};\n \n use ::{i8,i16,i32,i64};\n \n-#[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"moved to inherent methods\")]\n-pub trait WrappingOps {\n-    fn wrapping_add(self, rhs: Self) -> Self;\n-    fn wrapping_sub(self, rhs: Self) -> Self;\n-    fn wrapping_mul(self, rhs: Self) -> Self;\n-}\n-\n #[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n pub trait OverflowingOps {\n     fn overflowing_add(self, rhs: Self) -> (Self, bool);\n@@ -99,27 +89,6 @@ sh_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n \n macro_rules! wrapping_impl {\n     ($($t:ty)*) => ($(\n-        impl WrappingOps for $t {\n-            #[inline(always)]\n-            fn wrapping_add(self, rhs: $t) -> $t {\n-                unsafe {\n-                    overflowing_add(self, rhs)\n-                }\n-            }\n-            #[inline(always)]\n-            fn wrapping_sub(self, rhs: $t) -> $t {\n-                unsafe {\n-                    overflowing_sub(self, rhs)\n-                }\n-            }\n-            #[inline(always)]\n-            fn wrapping_mul(self, rhs: $t) -> $t {\n-                unsafe {\n-                    overflowing_mul(self, rhs)\n-                }\n-            }\n-        }\n-\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Add for Wrapping<$t> {\n             type Output = Wrapping<$t>;"}, {"sha": "e909946ece40221ffa548666aed832ce44b2e9fd", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -234,8 +234,6 @@ use fmt;\n use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSizeIterator, IntoIterator};\n use ops::{FnMut, FnOnce};\n use option::Option::{self, None, Some};\n-#[allow(deprecated)]\n-use slice::AsSlice;\n use slice;\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n@@ -768,26 +766,6 @@ impl<T: fmt::Debug, E> Result<T, E> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"core\",\n-           reason = \"waiting on the stability of the trait itself\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use inherent method instead\")]\n-#[allow(deprecated)]\n-impl<T, E> AsSlice<T> for Result<T, E> {\n-    /// Converts from `Result<T, E>` to `&[T]` (without copying)\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a [T] {\n-        match *self {\n-            Ok(ref x) => slice::ref_slice(x),\n-            Err(_) => {\n-                // work around lack of implicit coercion from fixed-size array to slice\n-                let emp: &[_] = &[];\n-                emp\n-            }\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, E> IntoIterator for Result<T, E> {\n     type Item = T;"}, {"sha": "1e96d761d405a948e3db12b02f4f45f18ca27c19", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -51,7 +51,7 @@ use result::Result::{Ok, Err};\n use ptr;\n use mem;\n use mem::size_of;\n-use marker::{Send, Sized, Sync, self};\n+use marker::{Send, Sync, self};\n use raw::Repr;\n // Avoid conflicts with *both* the Slice trait (buggy) and the `slice::raw` module.\n use raw::Slice as RawSlice;\n@@ -595,37 +595,6 @@ impl<T> ops::IndexMut<RangeFull> for [T] {\n // Common traits\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Data that is viewable as a slice.\n-#[unstable(feature = \"core\",\n-           reason = \"will be replaced by slice syntax\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use std::convert::AsRef<[T]> instead\")]\n-pub trait AsSlice<T> {\n-    /// Work with `self` as a slice.\n-    fn as_slice<'a>(&'a self) -> &'a [T];\n-}\n-\n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<T> AsSlice<T> for [T] {\n-    #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { self }\n-}\n-\n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a U {\n-    #[inline(always)]\n-    fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n-}\n-\n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n-    #[inline(always)]\n-    fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Default for &'a [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "4d343ea0f1e42c37712371a6b2fc47a70d72d93b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -25,7 +25,6 @@ use default::Default;\n use fmt;\n use iter::ExactSizeIterator;\n use iter::{Map, Iterator, DoubleEndedIterator};\n-use marker::Sized;\n use mem;\n use ops::{Fn, FnMut, FnOnce};\n use option::Option::{self, None, Some};\n@@ -1463,30 +1462,6 @@ mod traits {\n     }\n }\n \n-/// Any string that can be represented as a slice\n-#[unstable(feature = \"core\",\n-           reason = \"Instead of taking this bound generically, this trait will be \\\n-                     replaced with one of slicing syntax (&foo[..]), deref coercions, or \\\n-                     a more generic conversion trait\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use std::convert::AsRef<str> instead\")]\n-pub trait Str {\n-    /// Work with `self` as a slice.\n-    fn as_slice<'a>(&'a self) -> &'a str;\n-}\n-\n-#[allow(deprecated)]\n-impl Str for str {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a str { self }\n-}\n-\n-#[allow(deprecated)]\n-impl<'a, S: ?Sized> Str for &'a S where S: Str {\n-    #[inline]\n-    fn as_slice(&self) -> &str { Str::as_slice(*self) }\n-}\n-\n /// Methods for string slices\n #[allow(missing_docs)]\n #[doc(hidden)]"}, {"sha": "e0d396c68b4c4847cb572580b497066de3a00689", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -110,8 +110,6 @@ fn test_partial_max() {\n \n #[test]\n fn test_user_defined_eq() {\n-    use core::num::SignedInt;\n-\n     // Our type.\n     struct SketchyNum {\n         num : isize"}, {"sha": "2866c193c3b1546a99f10736c0f4d11bade8343a", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -11,7 +11,6 @@\n use core::iter::*;\n use core::iter::order::*;\n use core::iter::MinMaxResult::*;\n-use core::num::SignedInt;\n use core::usize;\n use core::cmp;\n \n@@ -783,16 +782,6 @@ fn test_range_step() {\n     assert_eq!((200..200).step_by(1).collect::<Vec<isize>>(), []);\n }\n \n-#[test]\n-fn test_range_step_inclusive() {\n-    assert_eq!(range_step_inclusive(0, 20, 5).collect::<Vec<isize>>(), [0, 5, 10, 15, 20]);\n-    assert_eq!(range_step_inclusive(20, 0, -5).collect::<Vec<isize>>(), [20, 15, 10, 5, 0]);\n-    assert_eq!(range_step_inclusive(20, 0, -6).collect::<Vec<isize>>(), [20, 14, 8, 2]);\n-    assert_eq!(range_step_inclusive(200, 255, 50).collect::<Vec<u8>>(), [200, 250]);\n-    assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<isize>>(), []);\n-    assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<isize>>(), [200]);\n-}\n-\n #[test]\n fn test_reverse() {\n     let mut ys = [1, 2, 3, 4, 5];"}, {"sha": "e0e8e46af6cdde2a241b352e7d427013866a9ce9", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,8 +10,8 @@\n \n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]\n+\n #![feature(box_syntax)]\n-#![feature(int_uint)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_destructor)]\n #![feature(core)]\n@@ -21,13 +21,11 @@\n #![feature(std_misc)]\n #![feature(libc)]\n #![feature(hash)]\n-#![feature(io)]\n-#![feature(collections)]\n #![feature(debug_builders)]\n #![feature(unique)]\n #![feature(step_by)]\n #![feature(slice_patterns)]\n-#![allow(deprecated)] // rand\n+#![feature(float_from_str_radix)]\n \n extern crate core;\n extern crate test;"}, {"sha": "b1c8aec3c35e9798b9e30e030001b16e4139ee17", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! int_module { ($T:ty, $T_i:ident) => (\n+macro_rules! int_module { ($T:ident, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n     use core::isize;\n-    use core::num::{FromStrRadix, Int, SignedInt};\n     use core::ops::{Shl, Shr, Not, BitXor, BitAnd, BitOr};\n     use num;\n \n@@ -129,30 +128,30 @@ mod tests {\n \n     #[test]\n     fn test_le() {\n-        assert_eq!(Int::from_le(A.to_le()), A);\n-        assert_eq!(Int::from_le(B.to_le()), B);\n-        assert_eq!(Int::from_le(C.to_le()), C);\n-        assert_eq!(Int::from_le(_0), _0);\n-        assert_eq!(Int::from_le(_1), _1);\n+        assert_eq!($T::from_le(A.to_le()), A);\n+        assert_eq!($T::from_le(B.to_le()), B);\n+        assert_eq!($T::from_le(C.to_le()), C);\n+        assert_eq!($T::from_le(_0), _0);\n+        assert_eq!($T::from_le(_1), _1);\n         assert_eq!(_0.to_le(), _0);\n         assert_eq!(_1.to_le(), _1);\n     }\n \n     #[test]\n     fn test_be() {\n-        assert_eq!(Int::from_be(A.to_be()), A);\n-        assert_eq!(Int::from_be(B.to_be()), B);\n-        assert_eq!(Int::from_be(C.to_be()), C);\n-        assert_eq!(Int::from_be(_0), _0);\n-        assert_eq!(Int::from_be(_1), _1);\n+        assert_eq!($T::from_be(A.to_be()), A);\n+        assert_eq!($T::from_be(B.to_be()), B);\n+        assert_eq!($T::from_be(C.to_be()), C);\n+        assert_eq!($T::from_be(_0), _0);\n+        assert_eq!($T::from_be(_1), _1);\n         assert_eq!(_0.to_be(), _0);\n         assert_eq!(_1.to_be(), _1);\n     }\n \n     #[test]\n     fn test_signed_checked_div() {\n-        assert!(10.checked_div(2) == Some(5));\n-        assert!(5.checked_div(0) == None);\n+        assert!((10 as $T).checked_div(2) == Some(5));\n+        assert!((5 as $T).checked_div(0) == None);\n         assert!(isize::MIN.checked_div(-1) == None);\n     }\n \n@@ -180,26 +179,26 @@ mod tests {\n \n     #[test]\n     fn test_from_str_radix() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Ok(123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Ok(9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Ok(83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Ok(291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Ok(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Ok(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Ok(35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Ok(35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Ok(-123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Ok(-9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Ok(-83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Ok(-291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Ok(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Ok(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Ok(-35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Ok(-35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35).ok(), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2).ok(), None::<$T>);\n+        assert_eq!($T::from_str_radix(\"123\", 10), Ok(123 as $T));\n+        assert_eq!($T::from_str_radix(\"1001\", 2), Ok(9 as $T));\n+        assert_eq!($T::from_str_radix(\"123\", 8), Ok(83 as $T));\n+        assert_eq!(i32::from_str_radix(\"123\", 16), Ok(291 as i32));\n+        assert_eq!(i32::from_str_radix(\"ffff\", 16), Ok(65535 as i32));\n+        assert_eq!(i32::from_str_radix(\"FFFF\", 16), Ok(65535 as i32));\n+        assert_eq!($T::from_str_radix(\"z\", 36), Ok(35 as $T));\n+        assert_eq!($T::from_str_radix(\"Z\", 36), Ok(35 as $T));\n+\n+        assert_eq!($T::from_str_radix(\"-123\", 10), Ok(-123 as $T));\n+        assert_eq!($T::from_str_radix(\"-1001\", 2), Ok(-9 as $T));\n+        assert_eq!($T::from_str_radix(\"-123\", 8), Ok(-83 as $T));\n+        assert_eq!(i32::from_str_radix(\"-123\", 16), Ok(-291 as i32));\n+        assert_eq!(i32::from_str_radix(\"-ffff\", 16), Ok(-65535 as i32));\n+        assert_eq!(i32::from_str_radix(\"-FFFF\", 16), Ok(-65535 as i32));\n+        assert_eq!($T::from_str_radix(\"-z\", 36), Ok(-35 as $T));\n+        assert_eq!($T::from_str_radix(\"-Z\", 36), Ok(-35 as $T));\n+\n+        assert_eq!($T::from_str_radix(\"Z\", 35).ok(), None::<$T>);\n+        assert_eq!($T::from_str_radix(\"-9\", 2).ok(), None::<$T>);\n     }\n \n     #[test]"}, {"sha": "85ca547da85260bfda02b72c8644362ae853e46f", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,7 +10,6 @@\n \n use core::cmp::PartialEq;\n use core::fmt::Debug;\n-use core::num::{NumCast, cast};\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::marker::Copy;\n \n@@ -32,18 +31,12 @@ mod u64;\n \n /// Helper function for testing numeric operations\n pub fn test_num<T>(ten: T, two: T) where\n-    T: PartialEq + NumCast\n+    T: PartialEq\n      + Add<Output=T> + Sub<Output=T>\n      + Mul<Output=T> + Div<Output=T>\n      + Rem<Output=T> + Debug\n      + Copy\n {\n-    assert_eq!(ten.add(two),  cast(12).unwrap());\n-    assert_eq!(ten.sub(two),  cast(8).unwrap());\n-    assert_eq!(ten.mul(two),  cast(20).unwrap());\n-    assert_eq!(ten.div(two),  cast(5).unwrap());\n-    assert_eq!(ten.rem(two),  cast(0).unwrap());\n-\n     assert_eq!(ten.add(two),  ten + two);\n     assert_eq!(ten.sub(two),  ten - two);\n     assert_eq!(ten.mul(two),  ten * two);\n@@ -56,33 +49,33 @@ mod test {\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n     use core::num::Float;\n-    use core::num::from_str_radix;\n \n     #[test]\n     fn from_str_issue7588() {\n-        let u : Option<u8> = from_str_radix(\"1000\", 10).ok();\n+        let u : Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n         assert_eq!(u, None);\n-        let s : Option<i16> = from_str_radix(\"80000\", 10).ok();\n+        let s : Option<i16> = i16::from_str_radix(\"80000\", 10).ok();\n         assert_eq!(s, None);\n-        let f : Option<f32> = from_str_radix(\"10000000000000000000000000000000000000000\", 10).ok();\n+        let s = \"10000000000000000000000000000000000000000\";\n+        let f : Option<f32> = f32::from_str_radix(s, 10).ok();\n         assert_eq!(f, Some(Float::infinity()));\n-        let fe : Option<f32> = from_str_radix(\"1e40\", 10).ok();\n+        let fe : Option<f32> = f32::from_str_radix(\"1e40\", 10).ok();\n         assert_eq!(fe, Some(Float::infinity()));\n     }\n \n     #[test]\n     fn test_from_str_radix_float() {\n-        let x1 : Option<f64> = from_str_radix(\"-123.456\", 10).ok();\n+        let x1 : Option<f64> = f64::from_str_radix(\"-123.456\", 10).ok();\n         assert_eq!(x1, Some(-123.456));\n-        let x2 : Option<f32> = from_str_radix(\"123.456\", 10).ok();\n+        let x2 : Option<f32> = f32::from_str_radix(\"123.456\", 10).ok();\n         assert_eq!(x2, Some(123.456));\n-        let x3 : Option<f32> = from_str_radix(\"-0.0\", 10).ok();\n+        let x3 : Option<f32> = f32::from_str_radix(\"-0.0\", 10).ok();\n         assert_eq!(x3, Some(-0.0));\n-        let x4 : Option<f32> = from_str_radix(\"0.0\", 10).ok();\n+        let x4 : Option<f32> = f32::from_str_radix(\"0.0\", 10).ok();\n         assert_eq!(x4, Some(0.0));\n-        let x4 : Option<f32> = from_str_radix(\"1.0\", 10).ok();\n+        let x4 : Option<f32> = f32::from_str_radix(\"1.0\", 10).ok();\n         assert_eq!(x4, Some(1.0));\n-        let x5 : Option<f32> = from_str_radix(\"-1.0\", 10).ok();\n+        let x5 : Option<f32> = f32::from_str_radix(\"-1.0\", 10).ok();\n         assert_eq!(x5, Some(-1.0));\n     }\n "}, {"sha": "1712345f9d9a7c8316b04f1e8e85e3980873a0fd", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! uint_module { ($T:ty, $T_i:ident) => (\n+macro_rules! uint_module { ($T:ident, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n-    use core::num::Int;\n     use num;\n     use core::ops::{BitOr, BitAnd, BitXor, Shl, Shr, Not};\n \n@@ -97,30 +96,30 @@ mod tests {\n \n     #[test]\n     fn test_le() {\n-        assert_eq!(Int::from_le(A.to_le()), A);\n-        assert_eq!(Int::from_le(B.to_le()), B);\n-        assert_eq!(Int::from_le(C.to_le()), C);\n-        assert_eq!(Int::from_le(_0), _0);\n-        assert_eq!(Int::from_le(_1), _1);\n+        assert_eq!($T::from_le(A.to_le()), A);\n+        assert_eq!($T::from_le(B.to_le()), B);\n+        assert_eq!($T::from_le(C.to_le()), C);\n+        assert_eq!($T::from_le(_0), _0);\n+        assert_eq!($T::from_le(_1), _1);\n         assert_eq!(_0.to_le(), _0);\n         assert_eq!(_1.to_le(), _1);\n     }\n \n     #[test]\n     fn test_be() {\n-        assert_eq!(Int::from_be(A.to_be()), A);\n-        assert_eq!(Int::from_be(B.to_be()), B);\n-        assert_eq!(Int::from_be(C.to_be()), C);\n-        assert_eq!(Int::from_be(_0), _0);\n-        assert_eq!(Int::from_be(_1), _1);\n+        assert_eq!($T::from_be(A.to_be()), A);\n+        assert_eq!($T::from_be(B.to_be()), B);\n+        assert_eq!($T::from_be(C.to_be()), C);\n+        assert_eq!($T::from_be(_0), _0);\n+        assert_eq!($T::from_be(_1), _1);\n         assert_eq!(_0.to_be(), _0);\n         assert_eq!(_1.to_be(), _1);\n     }\n \n     #[test]\n     fn test_unsigned_checked_div() {\n-        assert!(10.checked_div(2) == Some(5));\n-        assert!(5.checked_div(0) == None);\n+        assert!((10 as $T).checked_div(2) == Some(5));\n+        assert!((5 as $T).checked_div(0) == None);\n     }\n }\n "}, {"sha": "9cd3b74e1552d95adef258408645af0715a20bd6", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -11,8 +11,6 @@\n //! The ChaCha random number generator.\n \n use core::prelude::*;\n-use core::num::Int;\n-use core::num::wrapping::WrappingOps;\n use {Rng, SeedableRng, Rand};\n \n const KEY_WORDS    : usize =  8; // 8 words for the 256-bit key"}, {"sha": "4ea81b8e61938b4f9c5f2e54f369a754750ee644", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -18,7 +18,7 @@\n //! that do not need to record state.\n \n use core::prelude::*;\n-use core::num::{Float, Int};\n+use core::num::Float;\n use core::marker::PhantomData;\n \n use {Rng, Rand};"}, {"sha": "4916e305b70e369141ad8e7743fe59aebdc78865", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,8 +13,6 @@\n // this is surprisingly complicated to be both generic & correct\n \n use core::prelude::PartialOrd;\n-use core::num::Int;\n-use core::num::wrapping::WrappingOps;\n \n use Rng;\n use distributions::{Sample, IndependentSample};\n@@ -73,7 +71,7 @@ pub trait SampleRange {\n }\n \n macro_rules! integer_impl {\n-    ($ty:ty, $unsigned:ty) => {\n+    ($ty:ident, $unsigned:ident) => {\n         impl SampleRange for $ty {\n             // we play free and fast with unsigned vs signed here\n             // (when $ty is signed), but that's fine, since the\n@@ -83,7 +81,7 @@ macro_rules! integer_impl {\n \n             fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n                 let range = (high as $unsigned).wrapping_sub(low as $unsigned);\n-                let unsigned_max: $unsigned = Int::max_value();\n+                let unsigned_max: $unsigned = $unsigned::max_value();\n \n                 // this is the largest number that fits into $unsigned\n                 // that `range` divides evenly, so, if we've sampled\n@@ -148,7 +146,6 @@ float_impl! { f64 }\n \n #[cfg(test)]\n mod tests {\n-    use std::num::Int;\n     use std::prelude::v1::*;\n     use distributions::{Sample, IndependentSample};\n     use super::Range as Range;\n@@ -168,11 +165,11 @@ mod tests {\n     fn test_integers() {\n         let mut rng = ::test::rng();\n         macro_rules! t {\n-            ($($ty:ty),*) => {{\n+            ($($ty:ident),*) => {{\n                 $(\n                    let v: &[($ty, $ty)] = &[(0, 10),\n                                             (10, 127),\n-                                            (Int::min_value(), Int::max_value())];\n+                                            ($ty::min_value(), $ty::max_value())];\n                    for &(low, high) in v {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n                         for _ in 0..1000 {"}, {"sha": "b7938397038b490d6b02c4b0092ad4ad8b62966a", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -836,7 +836,6 @@ pub mod writer {\n     use std::io::prelude::*;\n     use std::io::{self, SeekFrom, Cursor};\n     use std::slice::bytes;\n-    use std::num::ToPrimitive;\n \n     use super::{ EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n         EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8,\n@@ -1070,10 +1069,10 @@ pub mod writer {\n     impl<'a> Encoder<'a> {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_sub(&mut self, v: usize) -> EncodeResult {\n-            if let Some(v) = v.to_u8() {\n-                self.wr_tagged_raw_u8(EsSub8 as usize, v)\n-            } else if let Some(v) = v.to_u32() {\n-                self.wr_tagged_raw_u32(EsSub32 as usize, v)\n+            if v as u8 as usize == v {\n+                self.wr_tagged_raw_u8(EsSub8 as usize, v as u8)\n+            } else if v as u32 as usize == v {\n+                self.wr_tagged_raw_u32(EsSub32 as usize, v as u32)\n             } else {\n                 Err(io::Error::new(io::ErrorKind::Other,\n                                    &format!(\"length or variant id too big: {}\",\n@@ -1101,21 +1100,24 @@ pub mod writer {\n             self.emit_u64(v as u64)\n         }\n         fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-            match v.to_u32() {\n-                Some(v) => self.emit_u32(v),\n-                None => self.wr_tagged_raw_u64(EsU64 as usize, v)\n+            if v as u32 as u64 == v {\n+                self.emit_u32(v as u32)\n+            } else {\n+                self.wr_tagged_raw_u64(EsU64 as usize, v)\n             }\n         }\n         fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-            match v.to_u16() {\n-                Some(v) => self.emit_u16(v),\n-                None => self.wr_tagged_raw_u32(EsU32 as usize, v)\n+            if v as u16 as u32 == v {\n+                self.emit_u16(v as u16)\n+            } else {\n+                self.wr_tagged_raw_u32(EsU32 as usize, v)\n             }\n         }\n         fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-            match v.to_u8() {\n-                Some(v) => self.emit_u8(v),\n-                None => self.wr_tagged_raw_u16(EsU16 as usize, v)\n+            if v as u8 as u16 == v {\n+                self.emit_u8(v as u8)\n+            } else {\n+                self.wr_tagged_raw_u16(EsU16 as usize, v)\n             }\n         }\n         fn emit_u8(&mut self, v: u8) -> EncodeResult {\n@@ -1126,21 +1128,24 @@ pub mod writer {\n             self.emit_i64(v as i64)\n         }\n         fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-            match v.to_i32() {\n-                Some(v) => self.emit_i32(v),\n-                None => self.wr_tagged_raw_i64(EsI64 as usize, v)\n+            if v as i32 as i64 == v {\n+                self.emit_i32(v as i32)\n+            } else {\n+                self.wr_tagged_raw_i64(EsI64 as usize, v)\n             }\n         }\n         fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-            match v.to_i16() {\n-                Some(v) => self.emit_i16(v),\n-                None => self.wr_tagged_raw_i32(EsI32 as usize, v)\n+            if v as i16 as i32 == v {\n+                self.emit_i16(v as i16)\n+            } else {\n+                self.wr_tagged_raw_i32(EsI32 as usize, v)\n             }\n         }\n         fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-            match v.to_i8() {\n-                Some(v) => self.emit_i8(v),\n-                None => self.wr_tagged_raw_i16(EsI16 as usize, v)\n+            if v as i8 as i16 == v {\n+                self.emit_i8(v as i8)\n+            } else {\n+                self.wr_tagged_raw_i16(EsI16 as usize, v)\n             }\n         }\n         fn emit_i8(&mut self, v: i8) -> EncodeResult {"}, {"sha": "9093b3b9f5c91b8169b9a6c198c96cbbb248036a", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -68,6 +68,9 @@ extern crate test;\n \n pub use rustc_llvm as llvm;\n \n+#[macro_use]\n+mod macros;\n+\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;\n@@ -141,6 +144,7 @@ pub mod util {\n     pub mod ppaux;\n     pub mod nodemap;\n     pub mod lev_distance;\n+    pub mod num;\n }\n \n pub mod lib {"}, {"sha": "ed764ebd9f95dd4e27b579342fc0f4c66e77a486", "filename": "src/librustc/macros.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! enum_from_u32 {\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident = $e:expr,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant = $e),*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant,)*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    }\n+}"}, {"sha": "06a40f1dd277da124749bebf2b9ede7b975b18fa", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -116,37 +116,39 @@ pub const tag_items_data_item_reexport_def_id: usize = 0x47;\n pub const tag_items_data_item_reexport_name: usize = 0x48;\n \n // used to encode crate_ctxt side tables\n-#[derive(Copy, Clone, PartialEq, FromPrimitive)]\n-#[repr(usize)]\n-pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n-    tag_ast = 0x50,\n-\n-    tag_tree = 0x51,\n-\n-    tag_id_range = 0x52,\n-\n-    tag_table = 0x53,\n-    // GAP 0x54, 0x55\n-    tag_table_def = 0x56,\n-    tag_table_node_type = 0x57,\n-    tag_table_item_subst = 0x58,\n-    tag_table_freevars = 0x59,\n-    tag_table_tcache = 0x5a,\n-    tag_table_param_defs = 0x5b,\n-    tag_table_mutbl = 0x5c,\n-    tag_table_last_use = 0x5d,\n-    tag_table_spill = 0x5e,\n-    tag_table_method_map = 0x5f,\n-    tag_table_vtable_map = 0x60,\n-    tag_table_adjustments = 0x61,\n-    tag_table_moves_map = 0x62,\n-    tag_table_capture_map = 0x63,\n-    tag_table_closure_tys = 0x64,\n-    tag_table_closure_kinds = 0x65,\n-    tag_table_upvar_capture_map = 0x66,\n-    tag_table_capture_modes = 0x67,\n-    tag_table_object_cast_map = 0x68,\n-    tag_table_const_qualif = 0x69,\n+enum_from_u32! {\n+    #[derive(Copy, Clone, PartialEq)]\n+    #[repr(usize)]\n+    pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n+        tag_ast = 0x50,\n+\n+        tag_tree = 0x51,\n+\n+        tag_id_range = 0x52,\n+\n+        tag_table = 0x53,\n+        // GAP 0x54, 0x55\n+        tag_table_def = 0x56,\n+        tag_table_node_type = 0x57,\n+        tag_table_item_subst = 0x58,\n+        tag_table_freevars = 0x59,\n+        tag_table_tcache = 0x5a,\n+        tag_table_param_defs = 0x5b,\n+        tag_table_mutbl = 0x5c,\n+        tag_table_last_use = 0x5d,\n+        tag_table_spill = 0x5e,\n+        tag_table_method_map = 0x5f,\n+        tag_table_vtable_map = 0x60,\n+        tag_table_adjustments = 0x61,\n+        tag_table_moves_map = 0x62,\n+        tag_table_capture_map = 0x63,\n+        tag_table_closure_tys = 0x64,\n+        tag_table_closure_kinds = 0x65,\n+        tag_table_upvar_capture_map = 0x66,\n+        tag_table_capture_modes = 0x67,\n+        tag_table_object_cast_map = 0x68,\n+        tag_table_const_qualif = 0x69,\n+    }\n }\n \n pub const tag_item_trait_item_sort: usize = 0x70;"}, {"sha": "1f18b13fc46fe26fff04ab9c29d40db0d2f499fd", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -68,11 +68,13 @@ pub enum LinkagePreference {\n     RequireStatic,\n }\n \n-#[derive(Copy, Clone, PartialEq, FromPrimitive)]\n-pub enum NativeLibraryKind {\n-    NativeStatic,    // native static library (.a archive)\n-    NativeFramework, // OSX-specific\n-    NativeUnknown,   // default way to specify a dynamic library\n+enum_from_u32! {\n+    #[derive(Copy, Clone, PartialEq)]\n+    pub enum NativeLibraryKind {\n+        NativeStatic,    // native static library (.a archive)\n+        NativeFramework, // OSX-specific\n+        NativeUnknown,   // default way to specify a dynamic library\n+    }\n }\n \n // Where a crate came from on the local filesystem. One of these two options"}, {"sha": "cbd542567709c13f9b114d9949b1fc62784de9d3", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -35,7 +35,6 @@ use std::collections::HashMap;\n use std::hash::{self, Hash, SipHasher};\n use std::io::prelude::*;\n use std::io;\n-use std::num::FromPrimitive;\n use std::rc::Rc;\n use std::slice::bytes;\n use std::str;\n@@ -1349,7 +1348,7 @@ pub fn get_native_libraries(cdata: Cmd)\n         let kind_doc = reader::get_doc(lib_doc, tag_native_libraries_kind);\n         let name_doc = reader::get_doc(lib_doc, tag_native_libraries_name);\n         let kind: cstore::NativeLibraryKind =\n-            FromPrimitive::from_u32(reader::doc_as_u32(kind_doc)).unwrap();\n+            cstore::NativeLibraryKind::from_u32(reader::doc_as_u32(kind_doc)).unwrap();\n         let name = name_doc.as_str().to_string();\n         result.push((kind, name));\n         true\n@@ -1359,7 +1358,7 @@ pub fn get_native_libraries(cdata: Cmd)\n \n pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n     reader::maybe_get_doc(rbml::Doc::new(data), tag_plugin_registrar_fn)\n-        .map(|doc| FromPrimitive::from_u32(reader::doc_as_u32(doc)).unwrap())\n+        .map(|doc| reader::doc_as_u32(doc))\n }\n \n pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n@@ -1407,7 +1406,7 @@ pub fn get_missing_lang_items(cdata: Cmd)\n     let mut result = Vec::new();\n     reader::tagged_docs(items, tag_lang_items_missing, |missing_docs| {\n         let item: lang_items::LangItem =\n-            FromPrimitive::from_u32(reader::doc_as_u32(missing_docs)).unwrap();\n+            lang_items::LangItem::from_u32(reader::doc_as_u32(missing_docs)).unwrap();\n         result.push(item);\n         true\n     });"}, {"sha": "ee8373279d976f9f4d95c76cbba2a566121b93f2", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -41,7 +41,6 @@ use syntax;\n use std::cell::Cell;\n use std::io::SeekFrom;\n use std::io::prelude::*;\n-use std::num::FromPrimitive;\n use std::rc::Rc;\n use std::fmt::Debug;\n \n@@ -1713,7 +1712,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n         debug!(\">> Side table document with tag 0x{:x} \\\n                 found for id {} (orig {})\",\n                tag, id, id0);\n-        let decoded_tag: Option<c::astencode_tag> = FromPrimitive::from_usize(tag);\n+        let tag = tag as u32;\n+        let decoded_tag: Option<c::astencode_tag> = c::astencode_tag::from_u32(tag);\n         match decoded_tag {\n             None => {\n                 dcx.tcx.sess.bug("}, {"sha": "2c6ffb3281fcb4922cd173710578565938bf65d3", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -20,6 +20,7 @@ use middle::{astencode, def};\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n use middle::astconv_util::ast_ty_to_prim_ty;\n+use util::num::ToPrimitive;\n \n use syntax::ast::{self, Expr};\n use syntax::codemap::Span;\n@@ -30,7 +31,6 @@ use syntax::{ast_map, ast_util, codemap};\n \n use std::borrow::{Cow, IntoCow};\n use std::num::wrapping::OverflowingOps;\n-use std::num::ToPrimitive;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n use std::{i8, i16, i32, i64};"}, {"sha": "c77a43e75cdc089a3dc70f8396bae1675f27619f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -36,7 +36,6 @@ use syntax::visit::Visitor;\n use syntax::visit;\n \n use std::iter::Enumerate;\n-use std::num::FromPrimitive;\n use std::slice;\n \n // The actual lang items defined come at the end of this file in one handy table.\n@@ -46,9 +45,12 @@ macro_rules! lets_do_this {\n         $( $variant:ident, $name:expr, $method:ident; )*\n     ) => {\n \n-#[derive(Copy, Clone, FromPrimitive, PartialEq, Eq, Hash)]\n-pub enum LangItem {\n-    $($variant),*\n+\n+enum_from_u32! {\n+    #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+    pub enum LangItem {\n+        $($variant,)*\n+    }\n }\n \n pub struct LanguageItems {\n@@ -71,7 +73,7 @@ impl LanguageItems {\n     }\n \n     pub fn item_name(index: usize) -> &'static str {\n-        let item: Option<LangItem> = FromPrimitive::from_usize(index);\n+        let item: Option<LangItem> = LangItem::from_u32(index as u32);\n         match item {\n             $( Some($variant) => $name, )*\n             None => \"???\""}, {"sha": "2c94399f92138c981f0ca805b039bbb7f404cd26", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -63,6 +63,7 @@ use util::ppaux::{Repr, UserString};\n use util::common::{memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::FnvHashMap;\n+use util::num::ToPrimitive;\n \n use arena::TypedArena;\n use std::borrow::{Borrow, Cow};\n@@ -71,7 +72,6 @@ use std::cmp;\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n use std::mem;\n-use std::num::ToPrimitive;\n use std::ops;\n use std::rc::Rc;\n use std::vec::IntoIter;"}, {"sha": "da04976a96a37234b4f1cfaf05af3b622ce865ab", "filename": "src/librustc/util/num.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Futil%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc%2Futil%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnum.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait ToPrimitive {\n+    fn to_i8(&self) -> Option<i8>;\n+    fn to_i16(&self) -> Option<i16>;\n+    fn to_i32(&self) -> Option<i32>;\n+    fn to_i64(&self) -> Option<i64>;\n+    fn to_u8(&self) -> Option<u8>;\n+    fn to_u16(&self) -> Option<u16>;\n+    fn to_u32(&self) -> Option<u32>;\n+    fn to_u64(&self) -> Option<u64>;\n+}\n+\n+impl ToPrimitive for i64 {\n+    fn to_i8(&self) -> Option<i8> {\n+        if *self < i8::min_value() as i64 || *self > i8::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as i8)\n+        }\n+    }\n+    fn to_i16(&self) -> Option<i16> {\n+        if *self < i16::min_value() as i64 || *self > i16::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as i16)\n+        }\n+    }\n+    fn to_i32(&self) -> Option<i32> {\n+        if *self < i32::min_value() as i64 || *self > i32::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as i32)\n+        }\n+    }\n+    fn to_i64(&self) -> Option<i64> {\n+        Some(*self)\n+    }\n+    fn to_u8(&self) -> Option<u8> {\n+        if *self < 0 || *self > u8::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as u8)\n+        }\n+    }\n+    fn to_u16(&self) -> Option<u16> {\n+        if *self < 0 || *self > u16::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as u16)\n+        }\n+    }\n+    fn to_u32(&self) -> Option<u32> {\n+        if *self < 0 || *self > u32::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as u32)\n+        }\n+    }\n+    fn to_u64(&self) -> Option<u64> {\n+        if *self < 0 {None} else {Some(*self as u64)}\n+    }\n+}\n+\n+impl ToPrimitive for u64 {\n+    fn to_i8(&self) -> Option<i8> {\n+        if *self > i8::max_value() as u64 {None} else {Some(*self as i8)}\n+    }\n+    fn to_i16(&self) -> Option<i16> {\n+        if *self > i16::max_value() as u64 {None} else {Some(*self as i16)}\n+    }\n+    fn to_i32(&self) -> Option<i32> {\n+        if *self > i32::max_value() as u64 {None} else {Some(*self as i32)}\n+    }\n+    fn to_i64(&self) -> Option<i64> {\n+        if *self > i64::max_value() as u64 {None} else {Some(*self as i64)}\n+    }\n+    fn to_u8(&self) -> Option<u8> {\n+        if *self > u8::max_value() as u64 {None} else {Some(*self as u8)}\n+    }\n+    fn to_u16(&self) -> Option<u16> {\n+        if *self > u16::max_value() as u64 {None} else {Some(*self as u16)}\n+    }\n+    fn to_u32(&self) -> Option<u32> {\n+        if *self > u32::max_value() as u64 {None} else {Some(*self as u32)}\n+    }\n+    fn to_u64(&self) -> Option<u64> {\n+        Some(*self)\n+    }\n+}"}, {"sha": "9ed827da8b2e4de2194e8289b282b2b6f6c4e5a0", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,10 +12,7 @@\n //! use. This implementation is not intended for external use or for any use where security is\n //! important.\n \n-#![allow(deprecated)] // to_be32\n-\n use std::iter::repeat;\n-use std::num::Int;\n use std::slice::bytes::{MutableByteVector, copy_memory};\n use serialize::hex::ToHex;\n \n@@ -61,10 +58,10 @@ impl ToBits for u64 {\n \n /// Adds the specified number of bytes to the bit count. panic!() if this would cause numeric\n /// overflow.\n-fn add_bytes_to_bits<T: Int + ToBits>(bits: T, bytes: T) -> T {\n+fn add_bytes_to_bits(bits: u64, bytes: u64) -> u64 {\n     let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n-    if new_high_bits > T::zero() {\n+    if new_high_bits > 0 {\n         panic!(\"numeric overflow occurred.\")\n     }\n \n@@ -543,14 +540,14 @@ mod tests {\n     // A normal addition - no overflow occurs\n     #[test]\n     fn test_add_bytes_to_bits_ok() {\n-        assert!(super::add_bytes_to_bits::<u64>(100, 10) == 180);\n+        assert!(super::add_bytes_to_bits(100, 10) == 180);\n     }\n \n     // A simple failure case - adding 1 to the max value\n     #[test]\n     #[should_panic]\n     fn test_add_bytes_to_bits_overflow() {\n-        super::add_bytes_to_bits::<u64>(u64::MAX, 1);\n+        super::add_bytes_to_bits(u64::MAX, 1);\n     }\n \n     struct Test {"}, {"sha": "6457140bcc0f987ba68fef92b00428c45cccc2b9", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -21,9 +21,6 @@ use libc;\n use flate;\n \n use std::ffi::CString;\n-use std::mem;\n-#[allow(deprecated)]\n-use std::num::Int;\n \n pub fn run(sess: &session::Session, llmod: ModuleRef,\n            tm: TargetMachineRef, reachable: &[String]) {\n@@ -199,19 +196,15 @@ fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n }\n \n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n-    return read_from_le_bytes::<u32>(bc, link::RLIB_BYTECODE_OBJECT_VERSION_OFFSET);\n+    let pos = link::RLIB_BYTECODE_OBJECT_VERSION_OFFSET;\n+    let byte_data = &bc[pos..pos + 4];\n+    let data = unsafe { *(byte_data.as_ptr() as *const u32) };\n+    u32::from_le(data)\n }\n \n fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n-    return read_from_le_bytes::<u64>(bc, link::RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET);\n-}\n-\n-#[allow(deprecated)]\n-fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: usize) -> T {\n-    let byte_data = &bytes[position_in_bytes..position_in_bytes + mem::size_of::<T>()];\n-    let data = unsafe {\n-        *(byte_data.as_ptr() as *const T)\n-    };\n-\n-    Int::from_le(data)\n+    let pos = link::RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET;\n+    let byte_data = &bc[pos..pos + 8];\n+    let data = unsafe { *(byte_data.as_ptr() as *const u64) };\n+    u64::from_le(data)\n }"}, {"sha": "e2827eeae15d0bbb0cf17ae56fa57d6e4b8fc82f", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -45,8 +45,6 @@\n \n pub use self::Repr::*;\n \n-#[allow(deprecated)]\n-use std::num::Int;\n use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};"}, {"sha": "9f01521313633360909b34399635ecc7049b589d", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -21,8 +21,6 @@ use util::ppaux::Repr;\n \n use trans::type_::Type;\n \n-#[allow(deprecated)]\n-use std::num::Int;\n use syntax::abi;\n use syntax::ast;\n "}, {"sha": "baa6493533d2929c54f486e24d27e97bfb8a1188", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -204,12 +204,10 @@ use std::io::prelude::*;\n use std::io;\n use std::mem::swap;\n use std::num::FpCategory as Fp;\n-#[allow(deprecated)]\n-use std::num::wrapping::WrappingOps;\n use std::ops::Index;\n use std::str::FromStr;\n use std::string;\n-use std::{char, f64, fmt, num, str};\n+use std::{char, f64, fmt, str};\n use std;\n use rustc_unicode::str as unicode_str;\n use rustc_unicode::str::Utf16Item;\n@@ -460,8 +458,8 @@ fn spaces(wr: &mut fmt::Write, mut n: usize) -> EncodeResult {\n fn fmt_number_or_null(v: f64) -> string::String {\n     match v.classify() {\n         Fp::Nan | Fp::Infinite => string::String::from_str(\"null\"),\n-        _ if v.fract() != 0f64 => f64::to_str_digits(v, 6),\n-        _ => f64::to_str_digits(v, 6) + \".0\",\n+        _ if v.fract() != 0f64 => v.to_string(),\n+        _ => v.to_string() + \".0\",\n     }\n }\n \n@@ -1165,7 +1163,7 @@ impl Json {\n     pub fn as_i64(&self) -> Option<i64> {\n         match *self {\n             Json::I64(n) => Some(n),\n-            Json::U64(n) => num::cast(n),\n+            Json::U64(n) => Some(n as i64),\n             _ => None\n         }\n     }\n@@ -1174,7 +1172,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_u64(&self) -> Option<u64> {\n         match *self {\n-            Json::I64(n) => num::cast(n),\n+            Json::I64(n) => Some(n as u64),\n             Json::U64(n) => Some(n),\n             _ => None\n         }\n@@ -1184,8 +1182,8 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_f64(&self) -> Option<f64> {\n         match *self {\n-            Json::I64(n) => num::cast(n),\n-            Json::U64(n) => num::cast(n),\n+            Json::I64(n) => Some(n as f64),\n+            Json::U64(n) => Some(n as f64),\n             Json::F64(n) => Some(n),\n             _ => None\n         }\n@@ -1556,7 +1554,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n \n     #[allow(deprecated)] // possible resolve bug is mapping these to traits\n     fn parse_u64(&mut self) -> Result<u64, ParserError> {\n-        let mut accum = 0;\n+        let mut accum = 0u64;\n         let last_accum = 0; // necessary to detect overflow.\n \n         match self.ch_or_null() {\n@@ -2121,14 +2119,8 @@ macro_rules! read_primitive {\n     ($name:ident, $ty:ty) => {\n         fn $name(&mut self) -> DecodeResult<$ty> {\n             match self.pop() {\n-                Json::I64(f) => match num::cast(f) {\n-                    Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n-                },\n-                Json::U64(f) => match num::cast(f) {\n-                    Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n-                },\n+                Json::I64(f) => Ok(f as $ty),\n+                Json::U64(f) => Ok(f as $ty),\n                 Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{}\", f))),\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n                 // is going to have a string here, as per JSON spec."}, {"sha": "9ba90c470f8ae667776078f2d3a267b998145099", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -1620,7 +1620,7 @@ mod test_map {\n \n     use super::HashMap;\n     use super::Entry::{Occupied, Vacant};\n-    use iter::{range_inclusive, range_step_inclusive, repeat};\n+    use iter::{range_inclusive, repeat};\n     use cell::RefCell;\n     use rand::{thread_rng, Rng};\n \n@@ -1856,7 +1856,7 @@ mod test_map {\n             }\n \n             // remove backwards\n-            for i in range_step_inclusive(1000, 1, -1) {\n+            for i in (1..1001).rev() {\n                 assert!(m.remove(&i).is_some());\n \n                 for j in range_inclusive(i, 1000) {"}, {"sha": "3a63e2ab59cc85ed5ddfd4356cac3813eb437c93", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -17,7 +17,7 @@ use iter::{Iterator, ExactSizeIterator};\n use marker::{Copy, Send, Sync, Sized, self};\n use mem::{min_align_of, size_of};\n use mem;\n-use num::wrapping::{OverflowingOps, WrappingOps};\n+use num::wrapping::OverflowingOps;\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};"}, {"sha": "114d0dd79a0a3056b338498bd472607fc52292c5", "filename": "src/libstd/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -771,7 +771,7 @@ mod tests {\n     }\n \n     fn eq(a: Option<OsString>, b: Option<&str>) {\n-        assert_eq!(a.as_ref().map(|s| &**s), b.map(OsStr::from_str).map(|s| &*s));\n+        assert_eq!(a.as_ref().map(|s| &**s), b.map(OsStr::new).map(|s| &*s));\n     }\n \n     #[test]\n@@ -894,7 +894,7 @@ mod tests {\n     fn join_paths_unix() {\n         fn test_eq(input: &[&str], output: &str) -> bool {\n             &*join_paths(input.iter().cloned()).unwrap() ==\n-                OsStr::from_str(output)\n+                OsStr::new(output)\n         }\n \n         assert!(test_eq(&[], \"\"));\n@@ -910,7 +910,7 @@ mod tests {\n     fn join_paths_windows() {\n         fn test_eq(input: &[&str], output: &str) -> bool {\n             &*join_paths(input.iter().cloned()).unwrap() ==\n-                OsStr::from_str(output)\n+                OsStr::new(output)\n         }\n \n         assert!(test_eq(&[], \"\"));"}, {"sha": "dfe706e077366c609f2fb43c9ae95d3a12fa2ca3", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -20,11 +20,3 @@ pub use self::os_str::{OsString, OsStr};\n \n mod c_str;\n mod os_str;\n-\n-// FIXME (#21670): these should be defined in the os_str module\n-/// Freely convertible to an `&OsStr` slice.\n-#[unstable(feature = \"std_misc\")]\n-pub trait AsOsStr {\n-    /// Converts to an `&OsStr` slice.\n-    fn as_os_str(&self) -> &OsStr;\n-}"}, {"sha": "97bf33335b02a8091af837556176f015ad494508", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -46,7 +46,6 @@ use vec::Vec;\n \n use sys::os_str::{Buf, Slice};\n use sys_common::{AsInner, IntoInner, FromInner};\n-use super::AsOsStr;\n \n /// Owned, mutable OS strings.\n #[derive(Clone)]\n@@ -226,14 +225,6 @@ impl OsStr {\n         s.as_ref()\n     }\n \n-    /// Coerces directly from a `&str` slice to a `&OsStr` slice.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `OsStr::new` instead\")]\n-    pub fn from_str(s: &str) -> &OsStr {\n-        unsafe { mem::transmute(Slice::from_str(s)) }\n-    }\n-\n     /// Yields a `&str` slice if the `OsStr` is valid unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n@@ -378,46 +369,6 @@ impl ToOwned for OsStr {\n     fn to_owned(&self) -> OsString { self.to_os_string() }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl<'a, T: AsOsStr + ?Sized> AsOsStr for &'a T {\n-    fn as_os_str(&self) -> &OsStr {\n-        (*self).as_os_str()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for OsStr {\n-    fn as_os_str(&self) -> &OsStr {\n-        self\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for OsString {\n-    fn as_os_str(&self) -> &OsStr {\n-        &self[..]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for str {\n-    fn as_os_str(&self) -> &OsStr {\n-        unsafe { mem::transmute(Slice::from_str(self)) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for String {\n-    fn as_os_str(&self) -> &OsStr {\n-        unsafe { mem::transmute(Slice::from_str(self)) }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for OsStr {\n     fn as_ref(&self) -> &OsStr {"}, {"sha": "97c5a29d308a11c8975611bac9680094f78a153e", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -172,13 +172,6 @@ impl Error {\n         Error { repr: Repr::Os(code) }\n     }\n \n-    /// Creates a new instance of an `Error` from a particular OS error code.\n-    #[unstable(feature = \"io\", reason = \"deprecated\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to from_raw_os_error\")]\n-    pub fn from_os_error(code: i32) -> Error {\n-        Error { repr: Repr::Os(code) }\n-    }\n-\n     /// Returns the OS error that this error represents (if any).\n     ///\n     /// If this `Error` was constructed via `last_os_error` then this function"}, {"sha": "96665259a4d0c2d6cbf5328cf7fac00602b3ac13", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -128,6 +128,8 @@\n #![feature(std_misc)]\n #![feature(slice_patterns)]\n #![feature(debug_builders)]\n+#![feature(zero_one)]\n+#![cfg_attr(test, feature(float_from_str_radix))]\n #![cfg_attr(test, feature(test, rustc_private, std_misc))]\n \n // Don't link to std. We are std."}, {"sha": "3bfc764e540b21b900f0a95673a4c3c7288dbd03", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -18,8 +18,6 @@\n use prelude::v1::*;\n \n use io::{self, Error, ErrorKind};\n-#[allow(deprecated)] // Int\n-use num::Int;\n use sys_common::net2 as net_imp;\n \n pub use self::ip::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n@@ -55,10 +53,21 @@ pub enum Shutdown {\n     Both,\n }\n \n-#[allow(deprecated)] // Int\n-fn hton<I: Int>(i: I) -> I { i.to_be() }\n-#[allow(deprecated)] // Int\n-fn ntoh<I: Int>(i: I) -> I { Int::from_be(i) }\n+#[doc(hidden)]\n+trait NetInt {\n+    fn from_be(i: Self) -> Self;\n+    fn to_be(&self) -> Self;\n+}\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl NetInt for $t {\n+        fn from_be(i: Self) -> Self { <$t>::from_be(i) }\n+        fn to_be(&self) -> Self { <$t>::to_be(*self) }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n+fn hton<I: NetInt>(i: I) -> I { i.to_be() }\n+fn ntoh<I: NetInt>(i: I) -> I { I::from_be(i) }\n \n fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n     where F: FnMut(&SocketAddr) -> io::Result<T>"}, {"sha": "0efc04ef83c6874e96f28ef71dcbd2e0bdeea5ad", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 112, "deletions": 544, "changes": 656, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -17,18 +17,14 @@\n \n use prelude::v1::*;\n \n+use core::num;\n use intrinsics;\n use libc::c_int;\n-use num::{Float, FpCategory};\n-use num::strconv;\n-use num::strconv::ExponentFormat::{ExpNone, ExpDec};\n-use num::strconv::SignificantDigits::{DigAll, DigMax, DigExact};\n-use num::strconv::SignFormat::SignNeg;\n-\n-use core::num;\n+use num::{FpCategory, ParseFloatError};\n+use sys_common::FromInner;\n \n-pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n-pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n+pub use core::f32::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n pub use core::f32::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n pub use core::f32::{MIN, MIN_POSITIVE, MAX};\n pub use core::f32::consts;\n@@ -74,294 +70,16 @@ mod cmath {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl Float for f32 {\n-    #[inline]\n-    fn nan() -> f32 { num::Float::nan() }\n-    #[inline]\n-    fn infinity() -> f32 { num::Float::infinity() }\n-    #[inline]\n-    fn neg_infinity() -> f32 { num::Float::neg_infinity() }\n-    #[inline]\n-    fn zero() -> f32 { num::Float::zero() }\n-    #[inline]\n-    fn neg_zero() -> f32 { num::Float::neg_zero() }\n-    #[inline]\n-    fn one() -> f32 { num::Float::one() }\n-\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn mantissa_digits(unused_self: Option<f32>) -> usize {\n-        num::Float::mantissa_digits(unused_self)\n-    }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn digits(unused_self: Option<f32>) -> usize { num::Float::digits(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn epsilon() -> f32 { num::Float::epsilon() }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_exp(unused_self: Option<f32>) -> isize { num::Float::min_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_exp(unused_self: Option<f32>) -> isize { num::Float::max_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_10_exp(unused_self: Option<f32>) -> isize { num::Float::min_10_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_10_exp(unused_self: Option<f32>) -> isize { num::Float::max_10_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_value() -> f32 { num::Float::min_value() }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_pos_value(unused_self: Option<f32>) -> f32 { num::Float::min_pos_value(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_value() -> f32 { num::Float::max_value() }\n-\n-    #[inline]\n-    fn is_nan(self) -> bool { num::Float::is_nan(self) }\n-    #[inline]\n-    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n-    #[inline]\n-    fn is_finite(self) -> bool { num::Float::is_finite(self) }\n-    #[inline]\n-    fn is_normal(self) -> bool { num::Float::is_normal(self) }\n-    #[inline]\n-    fn classify(self) -> FpCategory { num::Float::classify(self) }\n-\n-    #[inline]\n-    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n-\n-    #[inline]\n-    fn floor(self) -> f32 { num::Float::floor(self) }\n-    #[inline]\n-    fn ceil(self) -> f32 { num::Float::ceil(self) }\n-    #[inline]\n-    fn round(self) -> f32 { num::Float::round(self) }\n-    #[inline]\n-    fn trunc(self) -> f32 { num::Float::trunc(self) }\n-    #[inline]\n-    fn fract(self) -> f32 { num::Float::fract(self) }\n-\n-    #[inline]\n-    fn abs(self) -> f32 { num::Float::abs(self) }\n-    #[inline]\n-    fn signum(self) -> f32 { num::Float::signum(self) }\n-    #[inline]\n-    fn is_positive(self) -> bool { num::Float::is_positive(self) }\n-    #[inline]\n-    fn is_negative(self) -> bool { num::Float::is_negative(self) }\n-\n-    #[inline]\n-    fn mul_add(self, a: f32, b: f32) -> f32 { num::Float::mul_add(self, a, b) }\n-    #[inline]\n-    fn recip(self) -> f32 { num::Float::recip(self) }\n-\n-    #[inline]\n-    fn powi(self, n: i32) -> f32 { num::Float::powi(self, n) }\n-    #[inline]\n-    fn powf(self, n: f32) -> f32 { num::Float::powf(self, n) }\n-\n-    #[inline]\n-    fn sqrt(self) -> f32 { num::Float::sqrt(self) }\n-    #[inline]\n-    fn rsqrt(self) -> f32 { num::Float::rsqrt(self) }\n-\n-    #[inline]\n-    fn exp(self) -> f32 { num::Float::exp(self) }\n-    #[inline]\n-    fn exp2(self) -> f32 { num::Float::exp2(self) }\n-    #[inline]\n-    fn ln(self) -> f32 { num::Float::ln(self) }\n-    #[inline]\n-    fn log(self, base: f32) -> f32 { num::Float::log(self, base) }\n-    #[inline]\n-    fn log2(self) -> f32 { num::Float::log2(self) }\n-    #[inline]\n-    fn log10(self) -> f32 { num::Float::log10(self) }\n-    #[inline]\n-    fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }\n-    #[inline]\n-    fn to_radians(self) -> f32 { num::Float::to_radians(self) }\n-\n-    /// Constructs a floating point number by multiplying `x` by 2 raised to the\n-    /// power of `exp`\n-    #[inline]\n-    fn ldexp(self, exp: isize) -> f32 {\n-        unsafe { cmath::ldexpf(self, exp as c_int) }\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    /// - `self = x * pow(2, exp)`\n-    /// - `0.5 <= abs(x) < 1.0`\n-    #[inline]\n-    fn frexp(self) -> (f32, isize) {\n-        unsafe {\n-            let mut exp = 0;\n-            let x = cmath::frexpf(self, &mut exp);\n-            (x, exp as isize)\n-        }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    #[inline]\n-    fn next_after(self, other: f32) -> f32 {\n-        unsafe { cmath::nextafterf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn max(self, other: f32) -> f32 {\n-        unsafe { cmath::fmaxf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn min(self, other: f32) -> f32 {\n-        unsafe { cmath::fminf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn abs_sub(self, other: f32) -> f32 {\n-        unsafe { cmath::fdimf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn cbrt(self) -> f32 {\n-        unsafe { cmath::cbrtf(self) }\n-    }\n-\n-    #[inline]\n-    fn hypot(self, other: f32) -> f32 {\n-        unsafe { cmath::hypotf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn sin(self) -> f32 {\n-        unsafe { intrinsics::sinf32(self) }\n-    }\n-\n-    #[inline]\n-    fn cos(self) -> f32 {\n-        unsafe { intrinsics::cosf32(self) }\n-    }\n-\n-    #[inline]\n-    fn tan(self) -> f32 {\n-        unsafe { cmath::tanf(self) }\n-    }\n-\n-    #[inline]\n-    fn asin(self) -> f32 {\n-        unsafe { cmath::asinf(self) }\n-    }\n-\n-    #[inline]\n-    fn acos(self) -> f32 {\n-        unsafe { cmath::acosf(self) }\n-    }\n-\n-    #[inline]\n-    fn atan(self) -> f32 {\n-        unsafe { cmath::atanf(self) }\n-    }\n-\n-    #[inline]\n-    fn atan2(self, other: f32) -> f32 {\n-        unsafe { cmath::atan2f(self, other) }\n-    }\n-\n-    /// Simultaneously computes the sine and cosine of the number\n-    #[inline]\n-    fn sin_cos(self) -> (f32, f32) {\n-        (self.sin(), self.cos())\n-    }\n-\n-    /// Returns the exponential of the number, minus `1`, in a way that is\n-    /// accurate even if the number is close to zero\n-    #[inline]\n-    fn exp_m1(self) -> f32 {\n-        unsafe { cmath::expm1f(self) }\n-    }\n-\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n-    /// accurately than if the operations were performed separately\n-    #[inline]\n-    fn ln_1p(self) -> f32 {\n-        unsafe { cmath::log1pf(self) }\n-    }\n-\n-    #[inline]\n-    fn sinh(self) -> f32 {\n-        unsafe { cmath::sinhf(self) }\n-    }\n-\n-    #[inline]\n-    fn cosh(self) -> f32 {\n-        unsafe { cmath::coshf(self) }\n-    }\n-\n-    #[inline]\n-    fn tanh(self) -> f32 {\n-        unsafe { cmath::tanhf(self) }\n-    }\n-\n-    /// Inverse hyperbolic sine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic sine of `self` will be returned\n-    /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n-    /// - `NAN` if `self` is `NAN`\n-    #[inline]\n-    fn asinh(self) -> f32 {\n-        match self {\n-            NEG_INFINITY => NEG_INFINITY,\n-            x => (x + ((x * x) + 1.0).sqrt()).ln(),\n-        }\n-    }\n-\n-    /// Inverse hyperbolic cosine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic cosine of `self` will be returned\n-    /// - `INFINITY` if `self` is `INFINITY`\n-    /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n-    #[inline]\n-    fn acosh(self) -> f32 {\n-        match self {\n-            x if x < 1.0 => Float::nan(),\n-            x => (x + ((x * x) - 1.0).sqrt()).ln(),\n-        }\n-    }\n-\n-    /// Inverse hyperbolic tangent\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic tangent of `self` will be returned\n-    /// - `self` if `self` is `0.0` or `-0.0`\n-    /// - `INFINITY` if `self` is `1.0`\n-    /// - `NEG_INFINITY` if `self` is `-1.0`\n-    /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n-    ///   (including `INFINITY` and `NEG_INFINITY`)\n-    #[inline]\n-    fn atanh(self) -> f32 {\n-        0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n-    }\n-}\n-\n #[cfg(not(test))]\n #[lang = \"f32\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl f32 {\n+    /// Parses a float as with a given radix\n+    #[unstable(feature = \"float_from_str_radix\", reason = \"recently moved API\")]\n+    pub fn from_str_radix(s: &str, radix: u32) -> Result<f32, ParseFloatError> {\n+        num::Float::from_str_radix(s, radix).map_err(FromInner::from_inner)\n+    }\n+\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n@@ -617,11 +335,6 @@ impl f32 {\n     #[inline]\n     pub fn is_sign_positive(self) -> bool { num::Float::is_positive(self) }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")]\n-    #[inline]\n-    pub fn is_positive(self) -> bool { num::Float::is_positive(self) }\n-\n     /// Returns `true` if `self`'s sign is negative, including `-0.0`\n     /// and `NEG_INFINITY`.\n     ///\n@@ -641,11 +354,6 @@ impl f32 {\n     #[inline]\n     pub fn is_sign_negative(self) -> bool { num::Float::is_negative(self) }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")]\n-    #[inline]\n-    pub fn is_negative(self) -> bool { num::Float::is_negative(self) }\n-\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n@@ -729,24 +437,6 @@ impl f32 {\n     #[inline]\n     pub fn sqrt(self) -> f32 { num::Float::sqrt(self) }\n \n-    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::f32;\n-    ///\n-    /// let f = 4.0f32;\n-    ///\n-    /// let abs_difference = (f.rsqrt() - 0.5).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use self.sqrt().recip() instead\")]\n-    #[inline]\n-    pub fn rsqrt(self) -> f32 { num::Float::rsqrt(self) }\n-\n     /// Returns `e^(self)`, (the exponential function).\n     ///\n     /// ```\n@@ -1339,7 +1029,7 @@ impl f32 {\n     #[inline]\n     pub fn acosh(self) -> f32 {\n         match self {\n-            x if x < 1.0 => Float::nan(),\n+            x if x < 1.0 => ::f32::NAN,\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n     }\n@@ -1363,116 +1053,9 @@ impl f32 {\n     }\n }\n \n-//\n-// Section: String Conversions\n-//\n-\n-/// Converts a float to a string\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use the ToString trait instead\")]\n-pub fn to_string(num: f32) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigAll, ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string in hexadecimal format\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n-pub fn to_str_hex(num: f32) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 16, true, SignNeg, DigAll, ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string in a given radix, and a flag indicating\n-/// whether it's a special value\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * radix - The base to use\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n-pub fn to_str_radix_special(num: f32, rdx: u32) -> (String, bool) {\n-    strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n-}\n-\n-/// Converts a float to a string with exactly the number of\n-/// provided significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exact(num: f32, dig: usize) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string with a maximum number of\n-/// significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_digits(num: f32, dig: usize) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string using the exponential notation with exactly the number of\n-/// provided digits after the decimal point in the significand\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of digits after the decimal point\n-/// * upper - Use `E` instead of `e` for the exponent sign\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_exact(num: f32, dig: usize, upper: bool) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n-    r\n-}\n-\n-/// Converts a float to a string using the exponential notation with the maximum number of\n-/// digits after the decimal point in the significand\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of digits after the decimal point\n-/// * upper - Use `E` instead of `e` for the exponent sign\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_digits(num: f32, dig: usize, upper: bool) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n-    r\n-}\n-\n #[cfg(test)]\n mod tests {\n+    use f32;\n     use f32::*;\n     use num::*;\n     use num::FpCategory as Fp;\n@@ -1496,7 +1079,7 @@ mod tests {\n \n     #[test]\n     fn test_nan() {\n-        let nan: f32 = Float::nan();\n+        let nan: f32 = f32::NAN;\n         assert!(nan.is_nan());\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n@@ -1508,7 +1091,7 @@ mod tests {\n \n     #[test]\n     fn test_infinity() {\n-        let inf: f32 = Float::infinity();\n+        let inf: f32 = f32::INFINITY;\n         assert!(inf.is_infinite());\n         assert!(!inf.is_finite());\n         assert!(inf.is_sign_positive());\n@@ -1520,7 +1103,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_infinity() {\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert!(neg_inf.is_infinite());\n         assert!(!neg_inf.is_finite());\n         assert!(!neg_inf.is_sign_positive());\n@@ -1532,7 +1115,7 @@ mod tests {\n \n     #[test]\n     fn test_zero() {\n-        let zero: f32 = Float::zero();\n+        let zero: f32 = 0.0f32;\n         assert_eq!(0.0, zero);\n         assert!(!zero.is_infinite());\n         assert!(zero.is_finite());\n@@ -1545,7 +1128,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_zero() {\n-        let neg_zero: f32 = Float::neg_zero();\n+        let neg_zero: f32 = -0.0;\n         assert_eq!(0.0, neg_zero);\n         assert!(!neg_zero.is_infinite());\n         assert!(neg_zero.is_finite());\n@@ -1558,7 +1141,7 @@ mod tests {\n \n     #[test]\n     fn test_one() {\n-        let one: f32 = Float::one();\n+        let one: f32 = 1.0f32;\n         assert_eq!(1.0, one);\n         assert!(!one.is_infinite());\n         assert!(one.is_finite());\n@@ -1571,9 +1154,9 @@ mod tests {\n \n     #[test]\n     fn test_is_nan() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert!(nan.is_nan());\n         assert!(!0.0f32.is_nan());\n         assert!(!5.3f32.is_nan());\n@@ -1584,9 +1167,9 @@ mod tests {\n \n     #[test]\n     fn test_is_infinite() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert!(!nan.is_infinite());\n         assert!(inf.is_infinite());\n         assert!(neg_inf.is_infinite());\n@@ -1597,9 +1180,9 @@ mod tests {\n \n     #[test]\n     fn test_is_finite() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert!(!nan.is_finite());\n         assert!(!inf.is_finite());\n         assert!(!neg_inf.is_finite());\n@@ -1610,11 +1193,11 @@ mod tests {\n \n     #[test]\n     fn test_is_normal() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Float::zero();\n-        let neg_zero: f32 = Float::neg_zero();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let zero: f32 = 0.0f32;\n+        let neg_zero: f32 = -0.0;\n         assert!(!nan.is_normal());\n         assert!(!inf.is_normal());\n         assert!(!neg_inf.is_normal());\n@@ -1627,11 +1210,11 @@ mod tests {\n \n     #[test]\n     fn test_classify() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Float::zero();\n-        let neg_zero: f32 = Float::neg_zero();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let zero: f32 = 0.0f32;\n+        let neg_zero: f32 = -0.0;\n         assert_eq!(nan.classify(), Fp::Nan);\n         assert_eq!(inf.classify(), Fp::Infinite);\n         assert_eq!(neg_inf.classify(), Fp::Infinite);\n@@ -1774,9 +1357,9 @@ mod tests {\n \n     #[test]\n     fn test_mul_add() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_approx_eq!(12.3f32.mul_add(4.5, 6.7), 62.05);\n         assert_approx_eq!((-12.3f32).mul_add(-4.5, -6.7), 48.65);\n         assert_approx_eq!(0.0f32.mul_add(8.9, 1.2), 1.2);\n@@ -1790,9 +1373,9 @@ mod tests {\n \n     #[test]\n     fn test_recip() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(1.0f32.recip(), 1.0);\n         assert_eq!(2.0f32.recip(), 0.5);\n         assert_eq!((-0.4f32).recip(), -2.5);\n@@ -1804,9 +1387,9 @@ mod tests {\n \n     #[test]\n     fn test_powi() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(1.0f32.powi(1), 1.0);\n         assert_approx_eq!((-3.1f32).powi(2), 9.61);\n         assert_approx_eq!(5.9f32.powi(-2), 0.028727);\n@@ -1818,9 +1401,9 @@ mod tests {\n \n     #[test]\n     fn test_powf() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(1.0f32.powf(1.0), 1.0);\n         assert_approx_eq!(3.4f32.powf(4.5), 246.408218);\n         assert_approx_eq!(2.7f32.powf(-3.2), 0.041652);\n@@ -1843,30 +1426,15 @@ mod tests {\n         assert_eq!(INFINITY.sqrt(), INFINITY);\n     }\n \n-    #[test]\n-    fn test_rsqrt() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        assert!(nan.rsqrt().is_nan());\n-        assert_eq!(inf.rsqrt(), 0.0);\n-        assert!(neg_inf.rsqrt().is_nan());\n-        assert!((-1.0f32).rsqrt().is_nan());\n-        assert_eq!((-0.0f32).rsqrt(), neg_inf);\n-        assert_eq!(0.0f32.rsqrt(), inf);\n-        assert_eq!(1.0f32.rsqrt(), 1.0);\n-        assert_eq!(4.0f32.rsqrt(), 0.5);\n-    }\n-\n     #[test]\n     fn test_exp() {\n         assert_eq!(1.0, 0.0f32.exp());\n         assert_approx_eq!(2.718282, 1.0f32.exp());\n         assert_approx_eq!(148.413162, 5.0f32.exp());\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(inf, inf.exp());\n         assert_eq!(0.0, neg_inf.exp());\n         assert!(nan.exp().is_nan());\n@@ -1877,19 +1445,19 @@ mod tests {\n         assert_eq!(32.0, 5.0f32.exp2());\n         assert_eq!(1.0, 0.0f32.exp2());\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(inf, inf.exp2());\n         assert_eq!(0.0, neg_inf.exp2());\n         assert!(nan.exp2().is_nan());\n     }\n \n     #[test]\n     fn test_ln() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_approx_eq!(1.0f32.exp().ln(), 1.0);\n         assert!(nan.ln().is_nan());\n         assert_eq!(inf.ln(), inf);\n@@ -1902,12 +1470,12 @@ mod tests {\n \n     #[test]\n     fn test_log() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(10.0f32.log(10.0), 1.0);\n         assert_approx_eq!(2.3f32.log(3.5), 0.664858);\n-        assert_eq!(1.0f32.exp().log(1.0.exp()), 1.0);\n+        assert_eq!(1.0f32.exp().log(1.0f32.exp()), 1.0);\n         assert!(1.0f32.log(1.0).is_nan());\n         assert!(1.0f32.log(-13.9).is_nan());\n         assert!(nan.log(2.3).is_nan());\n@@ -1920,9 +1488,9 @@ mod tests {\n \n     #[test]\n     fn test_log2() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_approx_eq!(10.0f32.log2(), 3.321928);\n         assert_approx_eq!(2.3f32.log2(), 1.201634);\n         assert_approx_eq!(1.0f32.exp().log2(), 1.442695);\n@@ -1936,9 +1504,9 @@ mod tests {\n \n     #[test]\n     fn test_log10() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(10.0f32.log10(), 1.0);\n         assert_approx_eq!(2.3f32.log10(), 0.361728);\n         assert_approx_eq!(1.0f32.exp().log10(), 0.434294);\n@@ -1954,9 +1522,9 @@ mod tests {\n     #[test]\n     fn test_to_degrees() {\n         let pi: f32 = consts::PI;\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(0.0f32.to_degrees(), 0.0);\n         assert_approx_eq!((-5.8f32).to_degrees(), -332.315521);\n         assert_eq!(pi.to_degrees(), 180.0);\n@@ -1968,9 +1536,9 @@ mod tests {\n     #[test]\n     fn test_to_radians() {\n         let pi: f32 = consts::PI;\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(0.0f32.to_radians(), 0.0);\n         assert_approx_eq!(154.6f32.to_radians(), 2.698279);\n         assert_approx_eq!((-332.31f32).to_radians(), -5.799903);\n@@ -1984,50 +1552,50 @@ mod tests {\n     fn test_ldexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f32 = FromStrRadix::from_str_radix(\"1.Cp-12\", 16).unwrap();\n-        assert_eq!(1f32.ldexp(-123), f1);\n-        assert_eq!(1f32.ldexp(-111), f2);\n-        assert_eq!(Float::ldexp(1.75f32, -12), f3);\n+        let f1: f32 = f32::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = f32::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f32 = f32::from_str_radix(\"1.Cp-12\", 16).unwrap();\n+        assert_eq!(f32::ldexp(1f32, -123), f1);\n+        assert_eq!(f32::ldexp(1f32, -111), f2);\n+        assert_eq!(f32::ldexp(1.75f32, -12), f3);\n \n-        assert_eq!(Float::ldexp(0f32, -123), 0f32);\n-        assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n+        assert_eq!(f32::ldexp(0f32, -123), 0f32);\n+        assert_eq!(f32::ldexp(-0f32, -123), -0f32);\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n+        assert_eq!(f32::ldexp(inf, -123), inf);\n+        assert_eq!(f32::ldexp(neg_inf, -123), neg_inf);\n+        assert!(f32::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n     fn test_frexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f32 = FromStrRadix::from_str_radix(\"1.Cp-123\", 16).unwrap();\n+        let f1: f32 = f32::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = f32::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f32 = f32::from_str_radix(\"1.Cp-123\", 16).unwrap();\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n         let (x3, exp3) = f3.frexp();\n         assert_eq!((x1, exp1), (0.5f32, -122));\n         assert_eq!((x2, exp2), (0.5f32, -110));\n         assert_eq!((x3, exp3), (0.875f32, -122));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n-        assert_eq!(Float::ldexp(x3, exp3), f3);\n+        assert_eq!(f32::ldexp(x1, exp1), f1);\n+        assert_eq!(f32::ldexp(x2, exp2), f2);\n+        assert_eq!(f32::ldexp(x3, exp3), f3);\n \n         assert_eq!(0f32.frexp(), (0f32, 0));\n         assert_eq!((-0f32).frexp(), (-0f32, 0));\n     }\n \n     #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n     fn test_frexp_nowin() {\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n         assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n         assert!(match nan.frexp() { (x, _) => x.is_nan() })\n@@ -2056,9 +1624,9 @@ mod tests {\n         assert_eq!(0.0f32.asinh(), 0.0f32);\n         assert_eq!((-0.0f32).asinh(), -0.0f32);\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n         assert!(nan.asinh().is_nan());\n@@ -2071,9 +1639,9 @@ mod tests {\n         assert_eq!(1.0f32.acosh(), 0.0f32);\n         assert!(0.999f32.acosh().is_nan());\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(inf.acosh(), inf);\n         assert!(neg_inf.acosh().is_nan());\n         assert!(nan.acosh().is_nan());\n@@ -2086,17 +1654,17 @@ mod tests {\n         assert_eq!(0.0f32.atanh(), 0.0f32);\n         assert_eq!((-0.0f32).atanh(), -0.0f32);\n \n-        let inf32: f32 = Float::infinity();\n-        let neg_inf32: f32 = Float::neg_infinity();\n+        let inf32: f32 = f32::INFINITY;\n+        let neg_inf32: f32 = f32::NEG_INFINITY;\n         assert_eq!(1.0f32.atanh(), inf32);\n         assert_eq!((-1.0f32).atanh(), neg_inf32);\n \n         assert!(2f64.atanh().atanh().is_nan());\n         assert!((-2f64).atanh().atanh().is_nan());\n \n-        let inf64: f32 = Float::infinity();\n-        let neg_inf64: f32 = Float::neg_infinity();\n-        let nan32: f32 = Float::nan();\n+        let inf64: f32 = f32::INFINITY;\n+        let neg_inf64: f32 = f32::NEG_INFINITY;\n+        let nan32: f32 = f32::NAN;\n         assert!(inf64.atanh().is_nan());\n         assert!(neg_inf64.atanh().is_nan());\n         assert!(nan32.atanh().is_nan());\n@@ -2118,9 +1686,9 @@ mod tests {\n         let frac_pi_8: f32 = consts::FRAC_PI_8;\n         let frac_1_pi: f32 = consts::FRAC_1_PI;\n         let frac_2_pi: f32 = consts::FRAC_2_PI;\n-        let frac_2_sqrtpi: f32 = consts::FRAC_2_SQRTPI;\n-        let sqrt2: f32 = consts::SQRT2;\n-        let frac_1_sqrt2: f32 = consts::FRAC_1_SQRT2;\n+        let frac_2_sqrtpi: f32 = consts::FRAC_2_SQRT_PI;\n+        let sqrt2: f32 = consts::SQRT_2;\n+        let frac_1_sqrt2: f32 = consts::FRAC_1_SQRT_2;\n         let e: f32 = consts::E;\n         let log2_e: f32 = consts::LOG2_E;\n         let log10_e: f32 = consts::LOG10_E;"}, {"sha": "e1497f3958dabf1bd897c62f0c2598fcd3763999", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 110, "deletions": 531, "changes": 641, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -16,18 +16,14 @@\n \n use prelude::v1::*;\n \n+use core::num;\n use intrinsics;\n use libc::c_int;\n-use num::{Float, FpCategory};\n-use num::strconv;\n-use num::strconv::ExponentFormat::{ExpNone, ExpDec};\n-use num::strconv::SignificantDigits::{DigAll, DigMax, DigExact};\n-use num::strconv::SignFormat::SignNeg;\n-\n-use core::num;\n+use num::{FpCategory, ParseFloatError};\n+use sys_common::FromInner;\n \n-pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n-pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n+pub use core::f64::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n pub use core::f64::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n pub use core::f64::{MIN, MIN_POSITIVE, MAX};\n pub use core::f64::consts;\n@@ -82,295 +78,16 @@ mod cmath {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl Float for f64 {\n-    // inlined methods from `num::Float`\n-    #[inline]\n-    fn nan() -> f64 { num::Float::nan() }\n-    #[inline]\n-    fn infinity() -> f64 { num::Float::infinity() }\n-    #[inline]\n-    fn neg_infinity() -> f64 { num::Float::neg_infinity() }\n-    #[inline]\n-    fn zero() -> f64 { num::Float::zero() }\n-    #[inline]\n-    fn neg_zero() -> f64 { num::Float::neg_zero() }\n-    #[inline]\n-    fn one() -> f64 { num::Float::one() }\n-\n-\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn mantissa_digits(unused_self: Option<f64>) -> usize {\n-        num::Float::mantissa_digits(unused_self)\n-    }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn digits(unused_self: Option<f64>) -> usize { num::Float::digits(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn epsilon() -> f64 { num::Float::epsilon() }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_exp(unused_self: Option<f64>) -> isize { num::Float::min_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_exp(unused_self: Option<f64>) -> isize { num::Float::max_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_10_exp(unused_self: Option<f64>) -> isize { num::Float::min_10_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_10_exp(unused_self: Option<f64>) -> isize { num::Float::max_10_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_value() -> f64 { num::Float::min_value() }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_pos_value(unused_self: Option<f64>) -> f64 { num::Float::min_pos_value(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_value() -> f64 { num::Float::max_value() }\n-\n-    #[inline]\n-    fn is_nan(self) -> bool { num::Float::is_nan(self) }\n-    #[inline]\n-    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n-    #[inline]\n-    fn is_finite(self) -> bool { num::Float::is_finite(self) }\n-    #[inline]\n-    fn is_normal(self) -> bool { num::Float::is_normal(self) }\n-    #[inline]\n-    fn classify(self) -> FpCategory { num::Float::classify(self) }\n-\n-    #[inline]\n-    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n-\n-    #[inline]\n-    fn floor(self) -> f64 { num::Float::floor(self) }\n-    #[inline]\n-    fn ceil(self) -> f64 { num::Float::ceil(self) }\n-    #[inline]\n-    fn round(self) -> f64 { num::Float::round(self) }\n-    #[inline]\n-    fn trunc(self) -> f64 { num::Float::trunc(self) }\n-    #[inline]\n-    fn fract(self) -> f64 { num::Float::fract(self) }\n-\n-    #[inline]\n-    fn abs(self) -> f64 { num::Float::abs(self) }\n-    #[inline]\n-    fn signum(self) -> f64 { num::Float::signum(self) }\n-    #[inline]\n-    fn is_positive(self) -> bool { num::Float::is_positive(self) }\n-    #[inline]\n-    fn is_negative(self) -> bool { num::Float::is_negative(self) }\n-\n-    #[inline]\n-    fn mul_add(self, a: f64, b: f64) -> f64 { num::Float::mul_add(self, a, b) }\n-    #[inline]\n-    fn recip(self) -> f64 { num::Float::recip(self) }\n-\n-    #[inline]\n-    fn powi(self, n: i32) -> f64 { num::Float::powi(self, n) }\n-    #[inline]\n-    fn powf(self, n: f64) -> f64 { num::Float::powf(self, n) }\n-\n-    #[inline]\n-    fn sqrt(self) -> f64 { num::Float::sqrt(self) }\n-    #[inline]\n-    fn rsqrt(self) -> f64 { num::Float::rsqrt(self) }\n-\n-    #[inline]\n-    fn exp(self) -> f64 { num::Float::exp(self) }\n-    #[inline]\n-    fn exp2(self) -> f64 { num::Float::exp2(self) }\n-    #[inline]\n-    fn ln(self) -> f64 { num::Float::ln(self) }\n-    #[inline]\n-    fn log(self, base: f64) -> f64 { num::Float::log(self, base) }\n-    #[inline]\n-    fn log2(self) -> f64 { num::Float::log2(self) }\n-    #[inline]\n-    fn log10(self) -> f64 { num::Float::log10(self) }\n-\n-    #[inline]\n-    fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }\n-    #[inline]\n-    fn to_radians(self) -> f64 { num::Float::to_radians(self) }\n-\n-    #[inline]\n-    fn ldexp(self, exp: isize) -> f64 {\n-        unsafe { cmath::ldexp(self, exp as c_int) }\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    /// - `self = x * pow(2, exp)`\n-    /// - `0.5 <= abs(x) < 1.0`\n-    #[inline]\n-    fn frexp(self) -> (f64, isize) {\n-        unsafe {\n-            let mut exp = 0;\n-            let x = cmath::frexp(self, &mut exp);\n-            (x, exp as isize)\n-        }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    #[inline]\n-    fn next_after(self, other: f64) -> f64 {\n-        unsafe { cmath::nextafter(self, other) }\n-    }\n-\n-    #[inline]\n-    fn max(self, other: f64) -> f64 {\n-        unsafe { cmath::fmax(self, other) }\n-    }\n-\n-    #[inline]\n-    fn min(self, other: f64) -> f64 {\n-        unsafe { cmath::fmin(self, other) }\n-    }\n-\n-    #[inline]\n-    fn abs_sub(self, other: f64) -> f64 {\n-        unsafe { cmath::fdim(self, other) }\n-    }\n-\n-    #[inline]\n-    fn cbrt(self) -> f64 {\n-        unsafe { cmath::cbrt(self) }\n-    }\n-\n-    #[inline]\n-    fn hypot(self, other: f64) -> f64 {\n-        unsafe { cmath::hypot(self, other) }\n-    }\n-\n-    #[inline]\n-    fn sin(self) -> f64 {\n-        unsafe { intrinsics::sinf64(self) }\n-    }\n-\n-    #[inline]\n-    fn cos(self) -> f64 {\n-        unsafe { intrinsics::cosf64(self) }\n-    }\n-\n-    #[inline]\n-    fn tan(self) -> f64 {\n-        unsafe { cmath::tan(self) }\n-    }\n-\n-    #[inline]\n-    fn asin(self) -> f64 {\n-        unsafe { cmath::asin(self) }\n-    }\n-\n-    #[inline]\n-    fn acos(self) -> f64 {\n-        unsafe { cmath::acos(self) }\n-    }\n-\n-    #[inline]\n-    fn atan(self) -> f64 {\n-        unsafe { cmath::atan(self) }\n-    }\n-\n-    #[inline]\n-    fn atan2(self, other: f64) -> f64 {\n-        unsafe { cmath::atan2(self, other) }\n-    }\n-\n-    /// Simultaneously computes the sine and cosine of the number\n-    #[inline]\n-    fn sin_cos(self) -> (f64, f64) {\n-        (self.sin(), self.cos())\n-    }\n-\n-    /// Returns the exponential of the number, minus `1`, in a way that is\n-    /// accurate even if the number is close to zero\n-    #[inline]\n-    fn exp_m1(self) -> f64 {\n-        unsafe { cmath::expm1(self) }\n-    }\n-\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n-    /// accurately than if the operations were performed separately\n-    #[inline]\n-    fn ln_1p(self) -> f64 {\n-        unsafe { cmath::log1p(self) }\n-    }\n-\n-    #[inline]\n-    fn sinh(self) -> f64 {\n-        unsafe { cmath::sinh(self) }\n-    }\n-\n-    #[inline]\n-    fn cosh(self) -> f64 {\n-        unsafe { cmath::cosh(self) }\n-    }\n-\n-    #[inline]\n-    fn tanh(self) -> f64 {\n-        unsafe { cmath::tanh(self) }\n-    }\n-\n-    /// Inverse hyperbolic sine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic sine of `self` will be returned\n-    /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n-    /// - `NAN` if `self` is `NAN`\n-    #[inline]\n-    fn asinh(self) -> f64 {\n-        match self {\n-            NEG_INFINITY => NEG_INFINITY,\n-            x => (x + ((x * x) + 1.0).sqrt()).ln(),\n-        }\n-    }\n-\n-    /// Inverse hyperbolic cosine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic cosine of `self` will be returned\n-    /// - `INFINITY` if `self` is `INFINITY`\n-    /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n-    #[inline]\n-    fn acosh(self) -> f64 {\n-        match self {\n-            x if x < 1.0 => Float::nan(),\n-            x => (x + ((x * x) - 1.0).sqrt()).ln(),\n-        }\n-    }\n-\n-    /// Inverse hyperbolic tangent\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic tangent of `self` will be returned\n-    /// - `self` if `self` is `0.0` or `-0.0`\n-    /// - `INFINITY` if `self` is `1.0`\n-    /// - `NEG_INFINITY` if `self` is `-1.0`\n-    /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n-    ///   (including `INFINITY` and `NEG_INFINITY`)\n-    #[inline]\n-    fn atanh(self) -> f64 {\n-        0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n-    }\n-}\n-\n #[cfg(not(test))]\n #[lang = \"f64\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl f64 {\n+    /// Parses a float as with a given radix\n+    #[unstable(feature = \"float_from_str_radix\", reason = \"recently moved API\")]\n+    pub fn from_str_radix(s: &str, radix: u32) -> Result<f64, ParseFloatError> {\n+        num::Float::from_str_radix(s, radix).map_err(FromInner::from_inner)\n+    }\n+\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n@@ -726,22 +443,6 @@ impl f64 {\n     #[inline]\n     pub fn sqrt(self) -> f64 { num::Float::sqrt(self) }\n \n-    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// let f = 4.0_f64;\n-    ///\n-    /// let abs_difference = (f.rsqrt() - 0.5).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use self.sqrt().recip() instead\")]\n-    #[inline]\n-    pub fn rsqrt(self) -> f64 { num::Float::rsqrt(self) }\n-\n     /// Returns `e^(self)`, (the exponential function).\n     ///\n     /// ```\n@@ -1304,7 +1005,7 @@ impl f64 {\n     #[inline]\n     pub fn acosh(self) -> f64 {\n         match self {\n-            x if x < 1.0 => Float::nan(),\n+            x if x < 1.0 => NAN,\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n     }\n@@ -1328,116 +1029,9 @@ impl f64 {\n     }\n }\n \n-//\n-// Section: String Conversions\n-//\n-\n-/// Converts a float to a string\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use the ToString trait instead\")]\n-pub fn to_string(num: f64) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigAll, ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string in hexadecimal format\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n-pub fn to_str_hex(num: f64) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 16, true, SignNeg, DigAll, ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string in a given radix, and a flag indicating\n-/// whether it's a special value\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * radix - The base to use\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n-pub fn to_str_radix_special(num: f64, rdx: u32) -> (String, bool) {\n-    strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n-}\n-\n-/// Converts a float to a string with exactly the number of\n-/// provided significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exact(num: f64, dig: usize) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string with a maximum number of\n-/// significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_digits(num: f64, dig: usize) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string using the exponential notation with exactly the number of\n-/// provided digits after the decimal point in the significand\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of digits after the decimal point\n-/// * upper - Use `E` instead of `e` for the exponent sign\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_exact(num: f64, dig: usize, upper: bool) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n-    r\n-}\n-\n-/// Converts a float to a string using the exponential notation with the maximum number of\n-/// digits after the decimal point in the significand\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of digits after the decimal point\n-/// * upper - Use `E` instead of `e` for the exponent sign\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_digits(num: f64, dig: usize, upper: bool) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n-    r\n-}\n-\n #[cfg(test)]\n mod tests {\n+    use f64;\n     use f64::*;\n     use num::*;\n     use num::FpCategory as Fp;\n@@ -1461,7 +1055,7 @@ mod tests {\n \n     #[test]\n     fn test_nan() {\n-        let nan: f64 = Float::nan();\n+        let nan: f64 = NAN;\n         assert!(nan.is_nan());\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n@@ -1473,7 +1067,7 @@ mod tests {\n \n     #[test]\n     fn test_infinity() {\n-        let inf: f64 = Float::infinity();\n+        let inf: f64 = INFINITY;\n         assert!(inf.is_infinite());\n         assert!(!inf.is_finite());\n         assert!(inf.is_sign_positive());\n@@ -1485,7 +1079,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_infinity() {\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert!(neg_inf.is_infinite());\n         assert!(!neg_inf.is_finite());\n         assert!(!neg_inf.is_sign_positive());\n@@ -1497,7 +1091,7 @@ mod tests {\n \n     #[test]\n     fn test_zero() {\n-        let zero: f64 = Float::zero();\n+        let zero: f64 = 0.0f64;\n         assert_eq!(0.0, zero);\n         assert!(!zero.is_infinite());\n         assert!(zero.is_finite());\n@@ -1510,7 +1104,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_zero() {\n-        let neg_zero: f64 = Float::neg_zero();\n+        let neg_zero: f64 = -0.0;\n         assert_eq!(0.0, neg_zero);\n         assert!(!neg_zero.is_infinite());\n         assert!(neg_zero.is_finite());\n@@ -1523,7 +1117,7 @@ mod tests {\n \n     #[test]\n     fn test_one() {\n-        let one: f64 = Float::one();\n+        let one: f64 = 1.0f64;\n         assert_eq!(1.0, one);\n         assert!(!one.is_infinite());\n         assert!(one.is_finite());\n@@ -1536,9 +1130,9 @@ mod tests {\n \n     #[test]\n     fn test_is_nan() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert!(nan.is_nan());\n         assert!(!0.0f64.is_nan());\n         assert!(!5.3f64.is_nan());\n@@ -1549,9 +1143,9 @@ mod tests {\n \n     #[test]\n     fn test_is_infinite() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert!(!nan.is_infinite());\n         assert!(inf.is_infinite());\n         assert!(neg_inf.is_infinite());\n@@ -1562,9 +1156,9 @@ mod tests {\n \n     #[test]\n     fn test_is_finite() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert!(!nan.is_finite());\n         assert!(!inf.is_finite());\n         assert!(!neg_inf.is_finite());\n@@ -1575,11 +1169,11 @@ mod tests {\n \n     #[test]\n     fn test_is_normal() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Float::zero();\n-        let neg_zero: f64 = Float::neg_zero();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let zero: f64 = 0.0f64;\n+        let neg_zero: f64 = -0.0;\n         assert!(!nan.is_normal());\n         assert!(!inf.is_normal());\n         assert!(!neg_inf.is_normal());\n@@ -1592,11 +1186,11 @@ mod tests {\n \n     #[test]\n     fn test_classify() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Float::zero();\n-        let neg_zero: f64 = Float::neg_zero();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let zero: f64 = 0.0f64;\n+        let neg_zero: f64 = -0.0;\n         assert_eq!(nan.classify(), Fp::Nan);\n         assert_eq!(inf.classify(), Fp::Infinite);\n         assert_eq!(neg_inf.classify(), Fp::Infinite);\n@@ -1738,9 +1332,9 @@ mod tests {\n \n     #[test]\n     fn test_mul_add() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_approx_eq!(12.3f64.mul_add(4.5, 6.7), 62.05);\n         assert_approx_eq!((-12.3f64).mul_add(-4.5, -6.7), 48.65);\n         assert_approx_eq!(0.0f64.mul_add(8.9, 1.2), 1.2);\n@@ -1754,9 +1348,9 @@ mod tests {\n \n     #[test]\n     fn test_recip() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(1.0f64.recip(), 1.0);\n         assert_eq!(2.0f64.recip(), 0.5);\n         assert_eq!((-0.4f64).recip(), -2.5);\n@@ -1768,9 +1362,9 @@ mod tests {\n \n     #[test]\n     fn test_powi() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(1.0f64.powi(1), 1.0);\n         assert_approx_eq!((-3.1f64).powi(2), 9.61);\n         assert_approx_eq!(5.9f64.powi(-2), 0.028727);\n@@ -1782,9 +1376,9 @@ mod tests {\n \n     #[test]\n     fn test_powf() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(1.0f64.powf(1.0), 1.0);\n         assert_approx_eq!(3.4f64.powf(4.5), 246.408183);\n         assert_approx_eq!(2.7f64.powf(-3.2), 0.041652);\n@@ -1807,30 +1401,15 @@ mod tests {\n         assert_eq!(INFINITY.sqrt(), INFINITY);\n     }\n \n-    #[test]\n-    fn test_rsqrt() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        assert!(nan.rsqrt().is_nan());\n-        assert_eq!(inf.rsqrt(), 0.0);\n-        assert!(neg_inf.rsqrt().is_nan());\n-        assert!((-1.0f64).rsqrt().is_nan());\n-        assert_eq!((-0.0f64).rsqrt(), neg_inf);\n-        assert_eq!(0.0f64.rsqrt(), inf);\n-        assert_eq!(1.0f64.rsqrt(), 1.0);\n-        assert_eq!(4.0f64.rsqrt(), 0.5);\n-    }\n-\n     #[test]\n     fn test_exp() {\n         assert_eq!(1.0, 0.0f64.exp());\n         assert_approx_eq!(2.718282, 1.0f64.exp());\n         assert_approx_eq!(148.413159, 5.0f64.exp());\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(inf, inf.exp());\n         assert_eq!(0.0, neg_inf.exp());\n         assert!(nan.exp().is_nan());\n@@ -1841,19 +1420,19 @@ mod tests {\n         assert_eq!(32.0, 5.0f64.exp2());\n         assert_eq!(1.0, 0.0f64.exp2());\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(inf, inf.exp2());\n         assert_eq!(0.0, neg_inf.exp2());\n         assert!(nan.exp2().is_nan());\n     }\n \n     #[test]\n     fn test_ln() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_approx_eq!(1.0f64.exp().ln(), 1.0);\n         assert!(nan.ln().is_nan());\n         assert_eq!(inf.ln(), inf);\n@@ -1866,12 +1445,12 @@ mod tests {\n \n     #[test]\n     fn test_log() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(10.0f64.log(10.0), 1.0);\n         assert_approx_eq!(2.3f64.log(3.5), 0.664858);\n-        assert_eq!(1.0f64.exp().log(1.0.exp()), 1.0);\n+        assert_eq!(1.0f64.exp().log(1.0f64.exp()), 1.0);\n         assert!(1.0f64.log(1.0).is_nan());\n         assert!(1.0f64.log(-13.9).is_nan());\n         assert!(nan.log(2.3).is_nan());\n@@ -1884,9 +1463,9 @@ mod tests {\n \n     #[test]\n     fn test_log2() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_approx_eq!(10.0f64.log2(), 3.321928);\n         assert_approx_eq!(2.3f64.log2(), 1.201634);\n         assert_approx_eq!(1.0f64.exp().log2(), 1.442695);\n@@ -1900,9 +1479,9 @@ mod tests {\n \n     #[test]\n     fn test_log10() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(10.0f64.log10(), 1.0);\n         assert_approx_eq!(2.3f64.log10(), 0.361728);\n         assert_approx_eq!(1.0f64.exp().log10(), 0.434294);\n@@ -1918,9 +1497,9 @@ mod tests {\n     #[test]\n     fn test_to_degrees() {\n         let pi: f64 = consts::PI;\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(0.0f64.to_degrees(), 0.0);\n         assert_approx_eq!((-5.8f64).to_degrees(), -332.315521);\n         assert_eq!(pi.to_degrees(), 180.0);\n@@ -1932,9 +1511,9 @@ mod tests {\n     #[test]\n     fn test_to_radians() {\n         let pi: f64 = consts::PI;\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(0.0f64.to_radians(), 0.0);\n         assert_approx_eq!(154.6f64.to_radians(), 2.698279);\n         assert_approx_eq!((-332.31f64).to_radians(), -5.799903);\n@@ -1948,50 +1527,50 @@ mod tests {\n     fn test_ldexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f64 = FromStrRadix::from_str_radix(\"1.Cp-12\", 16).unwrap();\n-        assert_eq!(1f64.ldexp(-123), f1);\n-        assert_eq!(1f64.ldexp(-111), f2);\n-        assert_eq!(Float::ldexp(1.75f64, -12), f3);\n+        let f1: f64 = f64::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = f64::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f64 = f64::from_str_radix(\"1.Cp-12\", 16).unwrap();\n+        assert_eq!(f64::ldexp(1f64, -123), f1);\n+        assert_eq!(f64::ldexp(1f64, -111), f2);\n+        assert_eq!(f64::ldexp(1.75f64, -12), f3);\n \n-        assert_eq!(Float::ldexp(0f64, -123), 0f64);\n-        assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n+        assert_eq!(f64::ldexp(0f64, -123), 0f64);\n+        assert_eq!(f64::ldexp(-0f64, -123), -0f64);\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n+        assert_eq!(f64::ldexp(inf, -123), inf);\n+        assert_eq!(f64::ldexp(neg_inf, -123), neg_inf);\n+        assert!(f64::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n     fn test_frexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f64 = FromStrRadix::from_str_radix(\"1.Cp-123\", 16).unwrap();\n+        let f1: f64 = f64::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = f64::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f64 = f64::from_str_radix(\"1.Cp-123\", 16).unwrap();\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n         let (x3, exp3) = f3.frexp();\n         assert_eq!((x1, exp1), (0.5f64, -122));\n         assert_eq!((x2, exp2), (0.5f64, -110));\n         assert_eq!((x3, exp3), (0.875f64, -122));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n-        assert_eq!(Float::ldexp(x3, exp3), f3);\n+        assert_eq!(f64::ldexp(x1, exp1), f1);\n+        assert_eq!(f64::ldexp(x2, exp2), f2);\n+        assert_eq!(f64::ldexp(x3, exp3), f3);\n \n         assert_eq!(0f64.frexp(), (0f64, 0));\n         assert_eq!((-0f64).frexp(), (-0f64, 0));\n     }\n \n     #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n     fn test_frexp_nowin() {\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n         assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n         assert!(match nan.frexp() { (x, _) => x.is_nan() })\n@@ -2020,9 +1599,9 @@ mod tests {\n         assert_eq!(0.0f64.asinh(), 0.0f64);\n         assert_eq!((-0.0f64).asinh(), -0.0f64);\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n         assert!(nan.asinh().is_nan());\n@@ -2035,9 +1614,9 @@ mod tests {\n         assert_eq!(1.0f64.acosh(), 0.0f64);\n         assert!(0.999f64.acosh().is_nan());\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(inf.acosh(), inf);\n         assert!(neg_inf.acosh().is_nan());\n         assert!(nan.acosh().is_nan());\n@@ -2050,9 +1629,9 @@ mod tests {\n         assert_eq!(0.0f64.atanh(), 0.0f64);\n         assert_eq!((-0.0f64).atanh(), -0.0f64);\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(1.0f64.atanh(), inf);\n         assert_eq!((-1.0f64).atanh(), neg_inf);\n         assert!(2f64.atanh().atanh().is_nan());\n@@ -2076,9 +1655,9 @@ mod tests {\n         let frac_pi_8: f64 = consts::FRAC_PI_8;\n         let frac_1_pi: f64 = consts::FRAC_1_PI;\n         let frac_2_pi: f64 = consts::FRAC_2_PI;\n-        let frac_2_sqrtpi: f64 = consts::FRAC_2_SQRTPI;\n-        let sqrt2: f64 = consts::SQRT2;\n-        let frac_1_sqrt2: f64 = consts::FRAC_1_SQRT2;\n+        let frac_2_sqrtpi: f64 = consts::FRAC_2_SQRT_PI;\n+        let sqrt2: f64 = consts::SQRT_2;\n+        let frac_1_sqrt2: f64 = consts::FRAC_1_SQRT_2;\n         let e: f64 = consts::E;\n         let log2_e: f64 = consts::LOG2_E;\n         let log10_e: f64 = consts::LOG10_E;"}, {"sha": "cd26be013c41eaa814ec13e728f33290146b4cf1", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 52, "deletions": 1589, "changes": 1641, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -15,1124 +15,59 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n-#![allow(deprecated)]\n \n-#[cfg(test)] use fmt::Debug;\n-use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+use fmt;\n+use core::num;\n \n-use marker::Copy;\n-use clone::Clone;\n-use cmp::{PartialOrd, PartialEq};\n-\n-pub use core::num::{Int, SignedInt, Zero, One};\n-pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n-pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n-pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n-pub use core::num::{from_f32, from_f64};\n-pub use core::num::{FromStrRadix, from_str_radix};\n-pub use core::num::{FpCategory, ParseIntError, ParseFloatError};\n+pub use core::num::{Zero, One};\n+pub use core::num::{FpCategory, ParseIntError};\n pub use core::num::{wrapping, Wrapping};\n \n-use option::Option;\n-\n-#[unstable(feature = \"std_misc\", reason = \"likely to be removed\")]\n-pub mod strconv;\n-\n-/// Mathematical operations on primitive floating point numbers.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"replaced by inherent methods; use rust-lang/num for generics\")]\n-pub trait Float\n-    : Copy + Clone\n-    + NumCast\n-    + PartialOrd\n-    + PartialEq\n-    + Neg<Output=Self>\n-    + Add<Output=Self>\n-    + Sub<Output=Self>\n-    + Mul<Output=Self>\n-    + Div<Output=Self>\n-    + Rem<Output=Self>\n-{\n-    // inlined methods from `num::Float`\n-    /// Returns the `NaN` value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let nan: f32 = Float::nan();\n-    ///\n-    /// assert!(nan.is_nan());\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn nan() -> Self;\n-    /// Returns the infinite value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let infinity: f32 = Float::infinity();\n-    ///\n-    /// assert!(infinity.is_infinite());\n-    /// assert!(!infinity.is_finite());\n-    /// assert!(infinity > f32::MAX);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn infinity() -> Self;\n-    /// Returns the negative infinite value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let neg_infinity: f32 = Float::neg_infinity();\n-    ///\n-    /// assert!(neg_infinity.is_infinite());\n-    /// assert!(!neg_infinity.is_finite());\n-    /// assert!(neg_infinity < f32::MIN);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn neg_infinity() -> Self;\n-    /// Returns `0.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let inf: f32 = Float::infinity();\n-    /// let zero: f32 = Float::zero();\n-    /// let neg_zero: f32 = Float::neg_zero();\n-    ///\n-    /// assert_eq!(zero, neg_zero);\n-    /// assert_eq!(7.0f32/inf, zero);\n-    /// assert_eq!(zero * 10.0, zero);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn zero() -> Self;\n-    /// Returns `-0.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let inf: f32 = Float::infinity();\n-    /// let zero: f32 = Float::zero();\n-    /// let neg_zero: f32 = Float::neg_zero();\n-    ///\n-    /// assert_eq!(zero, neg_zero);\n-    /// assert_eq!(7.0f32/inf, zero);\n-    /// assert_eq!(zero * 10.0, zero);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn neg_zero() -> Self;\n-    /// Returns `1.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let one: f32 = Float::one();\n-    ///\n-    /// assert_eq!(one, 1.0f32);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn one() -> Self;\n-\n-    // FIXME (#5527): These should be associated constants\n-\n-    /// Deprecated: use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS`\n-    /// instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n-                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n-    fn mantissa_digits(unused_self: Option<Self>) -> usize;\n-    /// Deprecated: use `std::f32::DIGITS` or `std::f64::DIGITS` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n-    fn digits(unused_self: Option<Self>) -> usize;\n-    /// Deprecated: use `std::f32::EPSILON` or `std::f64::EPSILON` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n-    fn epsilon() -> Self;\n-    /// Deprecated: use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n-    fn min_exp(unused_self: Option<Self>) -> isize;\n-    /// Deprecated: use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n-    fn max_exp(unused_self: Option<Self>) -> isize;\n-    /// Deprecated: use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n-    fn min_10_exp(unused_self: Option<Self>) -> isize;\n-    /// Deprecated: use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n-    fn max_10_exp(unused_self: Option<Self>) -> isize;\n-\n-    /// Returns the smallest finite value that this type can represent.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x: f64 = Float::min_value();\n-    ///\n-    /// assert_eq!(x, f64::MIN);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn min_value() -> Self;\n-    /// Returns the smallest normalized positive number that this type can represent.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn min_pos_value(unused_self: Option<Self>) -> Self;\n-    /// Returns the largest finite value that this type can represent.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x: f64 = Float::max_value();\n-    /// assert_eq!(x, f64::MAX);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn max_value() -> Self;\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let nan = f64::NAN;\n-    /// let f = 7.0;\n-    ///\n-    /// assert!(nan.is_nan());\n-    /// assert!(!f.is_nan());\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n-    fn is_nan(self) -> bool;\n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let f = 7.0f32;\n-    /// let inf: f32 = Float::infinity();\n-    /// let neg_inf: f32 = Float::neg_infinity();\n-    /// let nan: f32 = f32::NAN;\n-    ///\n-    /// assert!(!f.is_infinite());\n-    /// assert!(!nan.is_infinite());\n-    ///\n-    /// assert!(inf.is_infinite());\n-    /// assert!(neg_inf.is_infinite());\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n-    fn is_infinite(self) -> bool;\n-    /// Returns `true` if this number is neither infinite nor `NaN`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let f = 7.0f32;\n-    /// let inf: f32 = Float::infinity();\n-    /// let neg_inf: f32 = Float::neg_infinity();\n-    /// let nan: f32 = f32::NAN;\n-    ///\n-    /// assert!(f.is_finite());\n-    ///\n-    /// assert!(!nan.is_finite());\n-    /// assert!(!inf.is_finite());\n-    /// assert!(!neg_inf.is_finite());\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n-    fn is_finite(self) -> bool;\n-\n-    /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal][subnormal], or `NaN`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n-    /// let max = f32::MAX;\n-    /// let lower_than_min = 1.0e-40_f32;\n-    /// let zero = 0.0f32;\n-    ///\n-    /// assert!(min.is_normal());\n-    /// assert!(max.is_normal());\n-    ///\n-    /// assert!(!zero.is_normal());\n-    /// assert!(!f32::NAN.is_normal());\n-    /// assert!(!f32::INFINITY.is_normal());\n-    /// // Values between `0` and `min` are Subnormal.\n-    /// assert!(!lower_than_min.is_normal());\n-    /// ```\n-    /// [subnormal]: http://en.wikipedia.org/wiki/Denormal_number\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n-    fn is_normal(self) -> bool;\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    ///\n-    /// ```\n-    /// use std::num::{Float, FpCategory};\n-    /// use std::f32;\n-    ///\n-    /// let num = 12.4f32;\n-    /// let inf = f32::INFINITY;\n-    ///\n-    /// assert_eq!(num.classify(), FpCategory::Normal);\n-    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn classify(self) -> FpCategory;\n-\n-    /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n-    /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n-    /// The floating point encoding is documented in the [Reference][floating-point].\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let num = 2.0f32;\n-    ///\n-    /// // (8388608, -22, 1)\n-    /// let (mantissa, exponent, sign) = num.integer_decode();\n-    /// let sign_f = sign as f32;\n-    /// let mantissa_f = mantissa as f32;\n-    /// let exponent_f = num.powf(exponent as f32);\n-    ///\n-    /// // 1 * 8388608 * 2^(-22) == 2\n-    /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    /// [floating-point]: ../../../../../reference.html#machine-types\n-    #[unstable(feature = \"std_misc\", reason = \"signature is undecided\")]\n-    fn integer_decode(self) -> (u64, i16, i8);\n-\n-    /// Returns the largest integer less than or equal to a number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.99;\n-    /// let g = 3.0;\n-    ///\n-    /// assert_eq!(f.floor(), 3.0);\n-    /// assert_eq!(g.floor(), 3.0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn floor(self) -> Self;\n-    /// Returns the smallest integer greater than or equal to a number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.01;\n-    /// let g = 4.0;\n-    ///\n-    /// assert_eq!(f.ceil(), 4.0);\n-    /// assert_eq!(g.ceil(), 4.0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn ceil(self) -> Self;\n-    /// Returns the nearest integer to a number. Round half-way cases away from\n-    /// `0.0`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.3;\n-    /// let g = -3.3;\n-    ///\n-    /// assert_eq!(f.round(), 3.0);\n-    /// assert_eq!(g.round(), -3.0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn round(self) -> Self;\n-    /// Returns the integer part of a number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.3;\n-    /// let g = -3.7;\n-    ///\n-    /// assert_eq!(f.trunc(), 3.0);\n-    /// assert_eq!(g.trunc(), -3.0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trunc(self) -> Self;\n-    /// Returns the fractional part of a number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 3.5;\n-    /// let y = -3.5;\n-    /// let abs_difference_x = (x.fract() - 0.5).abs();\n-    /// let abs_difference_y = (y.fract() - (-0.5)).abs();\n-    ///\n-    /// assert!(abs_difference_x < 1e-10);\n-    /// assert!(abs_difference_y < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fract(self) -> Self;\n-    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n-    /// number is `Float::nan()`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = 3.5;\n-    /// let y = -3.5;\n-    ///\n-    /// let abs_difference_x = (x.abs() - x).abs();\n-    /// let abs_difference_y = (y.abs() - (-y)).abs();\n-    ///\n-    /// assert!(abs_difference_x < 1e-10);\n-    /// assert!(abs_difference_y < 1e-10);\n-    ///\n-    /// assert!(f64::NAN.abs().is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn abs(self) -> Self;\n-    /// Returns a number that represents the sign of `self`.\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n-    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n-    /// - `Float::nan()` if the number is `Float::nan()`\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let f = 3.5;\n-    ///\n-    /// assert_eq!(f.signum(), 1.0);\n-    /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);\n-    ///\n-    /// assert!(f64::NAN.signum().is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn signum(self) -> Self;\n-    /// Returns `true` if `self` is positive, including `+0.0` and\n-    /// `Float::infinity()`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let nan: f64 = f64::NAN;\n-    ///\n-    /// let f = 7.0;\n-    /// let g = -7.0;\n-    ///\n-    /// assert!(f.is_positive());\n-    /// assert!(!g.is_positive());\n-    /// // Requires both tests to determine if is `NaN`\n-    /// assert!(!nan.is_positive() && !nan.is_negative());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_positive(self) -> bool;\n-    /// Returns `true` if `self` is negative, including `-0.0` and\n-    /// `Float::neg_infinity()`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let nan = f64::NAN;\n-    ///\n-    /// let f = 7.0;\n-    /// let g = -7.0;\n-    ///\n-    /// assert!(!f.is_negative());\n-    /// assert!(g.is_negative());\n-    /// // Requires both tests to determine if is `NaN`.\n-    /// assert!(!nan.is_positive() && !nan.is_negative());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_negative(self) -> bool;\n-\n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let m = 10.0;\n-    /// let x = 4.0;\n-    /// let b = 60.0;\n-    ///\n-    /// // 100.0\n-    /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn mul_add(self, a: Self, b: Self) -> Self;\n-    /// Takes the reciprocal (inverse) of a number, `1/x`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn recip(self) -> Self;\n-\n-    /// Raises a number to an integer power.\n-    ///\n-    /// Using this function is generally faster than using `powf`\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let abs_difference = (x.powi(2) - x*x).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn powi(self, n: i32) -> Self;\n-    /// Raises a number to a floating point power.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let abs_difference = (x.powf(2.0) - x*x).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn powf(self, n: Self) -> Self;\n-    /// Takes the square root of a number.\n-    ///\n-    /// Returns NaN if `self` is a negative number.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let positive = 4.0;\n-    /// let negative = -4.0;\n-    ///\n-    /// let abs_difference = (positive.sqrt() - 2.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// assert!(negative.sqrt().is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sqrt(self) -> Self;\n-\n-    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 4.0;\n-    ///\n-    /// let abs_difference = (f.rsqrt() - 0.5).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn rsqrt(self) -> Self;\n-\n-    /// Returns `e^(self)`, (the exponential function).\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let one = 1.0;\n-    /// // e^1\n-    /// let e = one.exp();\n-    ///\n-    /// // ln(e) - 1 == 0\n-    /// let abs_difference = (e.ln() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn exp(self) -> Self;\n-    /// Returns `2^(self)`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 2.0;\n-    ///\n-    /// // 2^2 - 4 == 0\n-    /// let abs_difference = (f.exp2() - 4.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn exp2(self) -> Self;\n-    /// Returns the natural logarithm of the number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let one = 1.0;\n-    /// // e^1\n-    /// let e = one.exp();\n-    ///\n-    /// // ln(e) - 1 == 0\n-    /// let abs_difference = (e.ln() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn ln(self) -> Self;\n-    /// Returns the logarithm of the number with respect to an arbitrary base.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let ten = 10.0;\n-    /// let two = 2.0;\n-    ///\n-    /// // log10(10) - 1 == 0\n-    /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();\n-    ///\n-    /// // log2(2) - 1 == 0\n-    /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference_10 < 1e-10);\n-    /// assert!(abs_difference_2 < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn log(self, base: Self) -> Self;\n-    /// Returns the base 2 logarithm of the number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let two = 2.0;\n-    ///\n-    /// // log2(2) - 1 == 0\n-    /// let abs_difference = (two.log2() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn log2(self) -> Self;\n-    /// Returns the base 10 logarithm of the number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let ten = 10.0;\n-    ///\n-    /// // log10(10) - 1 == 0\n-    /// let abs_difference = (ten.log10() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn log10(self) -> Self;\n-\n-    /// Converts radians to degrees.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64::consts;\n-    ///\n-    /// let angle = consts::PI;\n-    ///\n-    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n-    fn to_degrees(self) -> Self;\n-    /// Converts degrees to radians.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64::consts;\n-    ///\n-    /// let angle = 180.0;\n-    ///\n-    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n-    fn to_radians(self) -> Self;\n-    /// Constructs a floating point number of `x*2^exp`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// // 3*2^2 - 12 == 0\n-    /// let abs_difference = (Float::ldexp(3.0, 2) - 12.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"pending integer conventions\")]\n-    fn ldexp(self, exp: isize) -> Self;\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    ///  * `self = x * 2^exp`\n-    ///  * `0.5 <= abs(x) < 1.0`\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 4.0;\n-    ///\n-    /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n-    /// let f = x.frexp();\n-    /// let abs_difference_0 = (f.0 - 0.5).abs();\n-    /// let abs_difference_1 = (f.1 as f64 - 3.0).abs();\n-    ///\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// assert!(abs_difference_1 < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"pending integer conventions\")]\n-    fn frexp(self) -> (Self, isize);\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0f32;\n-    ///\n-    /// let abs_diff = (x.next_after(2.0) - 1.00000011920928955078125_f32).abs();\n-    ///\n-    /// assert!(abs_diff < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn next_after(self, other: Self) -> Self;\n-\n-    /// Returns the maximum of the two numbers.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let y = 2.0;\n-    ///\n-    /// assert_eq!(x.max(y), y);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn max(self, other: Self) -> Self;\n-    /// Returns the minimum of the two numbers.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let y = 2.0;\n-    ///\n-    /// assert_eq!(x.min(y), x);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn min(self, other: Self) -> Self;\n-\n-    /// The positive difference of two numbers.\n-    ///\n-    /// * If `self <= other`: `0:0`\n-    /// * Else: `self - other`\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 3.0;\n-    /// let y = -3.0;\n-    ///\n-    /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n-    /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n-    ///\n-    /// assert!(abs_difference_x < 1e-10);\n-    /// assert!(abs_difference_y < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n-    fn abs_sub(self, other: Self) -> Self;\n-    /// Takes the cubic root of a number.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 8.0;\n-    ///\n-    /// // x^(1/3) - 2 == 0\n-    /// let abs_difference = (x.cbrt() - 2.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n-    fn cbrt(self) -> Self;\n-    /// Calculates the length of the hypotenuse of a right-angle triangle given\n-    /// legs of length `x` and `y`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let y = 3.0;\n-    ///\n-    /// // sqrt(x^2 + y^2)\n-    /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn hypot(self, other: Self) -> Self;\n-\n-    /// Computes the sine of a number (in radians).\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = f64::consts::PI/2.0;\n-    ///\n-    /// let abs_difference = (x.sin() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sin(self) -> Self;\n-    /// Computes the cosine of a number (in radians).\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = 2.0*f64::consts::PI;\n-    ///\n-    /// let abs_difference = (x.cos() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn cos(self) -> Self;\n-    /// Computes the tangent of a number (in radians).\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = f64::consts::PI/4.0;\n-    /// let abs_difference = (x.tan() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-14);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn tan(self) -> Self;\n-    /// Computes the arcsine of a number. Return value is in radians in\n-    /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n-    /// [-1, 1].\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let f = f64::consts::PI / 2.0;\n-    ///\n-    /// // asin(sin(pi/2))\n-    /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn asin(self) -> Self;\n-    /// Computes the arccosine of a number. Return value is in radians in\n-    /// the range [0, pi] or NaN if the number is outside the range\n-    /// [-1, 1].\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let f = f64::consts::PI / 4.0;\n-    ///\n-    /// // acos(cos(pi/4))\n-    /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn acos(self) -> Self;\n-    /// Computes the arctangent of a number. Return value is in radians in the\n-    /// range [-pi/2, pi/2];\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 1.0;\n-    ///\n-    /// // atan(tan(1))\n-    /// let abs_difference = (f.tan().atan() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn atan(self) -> Self;\n-    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).\n-    ///\n-    /// * `x = 0`, `y = 0`: `0`\n-    /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n-    /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`\n-    /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let pi = f64::consts::PI;\n-    /// // All angles from horizontal right (+x)\n-    /// // 45 deg counter-clockwise\n-    /// let x1 = 3.0;\n-    /// let y1 = -3.0;\n-    ///\n-    /// // 135 deg clockwise\n-    /// let x2 = -3.0;\n-    /// let y2 = 3.0;\n-    ///\n-    /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n-    /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n-    ///\n-    /// assert!(abs_difference_1 < 1e-10);\n-    /// assert!(abs_difference_2 < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn atan2(self, other: Self) -> Self;\n-    /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n-    /// `(sin(x), cos(x))`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = f64::consts::PI/4.0;\n-    /// let f = x.sin_cos();\n-    ///\n-    /// let abs_difference_0 = (f.0 - x.sin()).abs();\n-    /// let abs_difference_1 = (f.1 - x.cos()).abs();\n-    ///\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sin_cos(self) -> (Self, Self);\n-\n-    /// Returns `e^(self) - 1` in a way that is accurate even if the\n-    /// number is close to zero.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 7.0;\n-    ///\n-    /// // e^(ln(7)) - 1\n-    /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n-    fn exp_m1(self) -> Self;\n-    /// Returns `ln(1+n)` (natural logarithm) more accurately than if\n-    /// the operations were performed separately.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = f64::consts::E - 1.0;\n-    ///\n-    /// // ln(1 + (e - 1)) == ln(e) == 1\n-    /// let abs_difference = (x.ln_1p() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n-    fn ln_1p(self) -> Self;\n-\n-    /// Hyperbolic sine function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let e = f64::consts::E;\n-    /// let x = 1.0;\n-    ///\n-    /// let f = x.sinh();\n-    /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n-    /// let g = (e*e - 1.0)/(2.0*e);\n-    /// let abs_difference = (f - g).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sinh(self) -> Self;\n-    /// Hyperbolic cosine function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let e = f64::consts::E;\n-    /// let x = 1.0;\n-    /// let f = x.cosh();\n-    /// // Solving cosh() at 1 gives this result\n-    /// let g = (e*e + 1.0)/(2.0*e);\n-    /// let abs_difference = (f - g).abs();\n-    ///\n-    /// // Same result\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn cosh(self) -> Self;\n-    /// Hyperbolic tangent function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let e = f64::consts::E;\n-    /// let x = 1.0;\n-    ///\n-    /// let f = x.tanh();\n-    /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n-    /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\n-    /// let abs_difference = (f - g).abs();\n-    ///\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn tanh(self) -> Self;\n-    /// Inverse hyperbolic sine function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let f = x.sinh().asinh();\n-    ///\n-    /// let abs_difference = (f - x).abs();\n-    ///\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn asinh(self) -> Self;\n-    /// Inverse hyperbolic cosine function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let f = x.cosh().acosh();\n-    ///\n-    /// let abs_difference = (f - x).abs();\n-    ///\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn acosh(self) -> Self;\n-    /// Inverse hyperbolic tangent function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let e = f64::consts::E;\n-    /// let f = e.tanh().atanh();\n-    ///\n-    /// let abs_difference = (f - e).abs();\n-    ///\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn atanh(self) -> Self;\n-}\n+#[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n+#[cfg(test)] use cmp::PartialEq;\n+#[cfg(test)] use marker::Copy;\n \n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T>(ten: T, two: T) where\n-    T: PartialEq + NumCast\n+    T: PartialEq\n      + Add<Output=T> + Sub<Output=T>\n      + Mul<Output=T> + Div<Output=T>\n-     + Rem<Output=T> + Debug\n+     + Rem<Output=T> + fmt::Debug\n      + Copy\n {\n-    assert_eq!(ten.add(two),  cast(12).unwrap());\n-    assert_eq!(ten.sub(two),  cast(8).unwrap());\n-    assert_eq!(ten.mul(two),  cast(20).unwrap());\n-    assert_eq!(ten.div(two),  cast(5).unwrap());\n-    assert_eq!(ten.rem(two),  cast(0).unwrap());\n-\n     assert_eq!(ten.add(two),  ten + two);\n     assert_eq!(ten.sub(two),  ten - two);\n     assert_eq!(ten.mul(two),  ten * two);\n     assert_eq!(ten.div(two),  ten / two);\n     assert_eq!(ten.rem(two),  ten % two);\n }\n \n+/// An error which can be returned when parsing a float.\n+#[derive(Debug, Clone, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseFloatError { inner: num::ParseFloatError }\n+\n+impl ::sys_common::FromInner<num::ParseFloatError> for ParseFloatError {\n+    fn from_inner(inner: num::ParseFloatError) -> ParseFloatError {\n+        ParseFloatError { inner: inner }\n+    }\n+}\n+\n+impl ParseFloatError {\n+    #[unstable(feature = \"core\", reason = \"available through Error trait\")]\n+    pub fn description(&self) -> &str {\n+        self.inner.description()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseFloatError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.description().fmt(f)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use core::prelude::*;\n@@ -1148,432 +83,7 @@ mod tests {\n     use u64;\n     use usize;\n     use string::ToString;\n-\n-    macro_rules! test_cast_20 {\n-        ($_20:expr) => ({\n-            let _20 = $_20;\n-\n-            assert_eq!(20usize, _20.to_uint().unwrap());\n-            assert_eq!(20u8,    _20.to_u8().unwrap());\n-            assert_eq!(20u16,   _20.to_u16().unwrap());\n-            assert_eq!(20u32,   _20.to_u32().unwrap());\n-            assert_eq!(20u64,   _20.to_u64().unwrap());\n-            assert_eq!(20,      _20.to_int().unwrap());\n-            assert_eq!(20i8,    _20.to_i8().unwrap());\n-            assert_eq!(20i16,   _20.to_i16().unwrap());\n-            assert_eq!(20i32,   _20.to_i32().unwrap());\n-            assert_eq!(20i64,   _20.to_i64().unwrap());\n-            assert_eq!(20f32,   _20.to_f32().unwrap());\n-            assert_eq!(20f64,   _20.to_f64().unwrap());\n-\n-            assert_eq!(_20, NumCast::from(20usize).unwrap());\n-            assert_eq!(_20, NumCast::from(20u8).unwrap());\n-            assert_eq!(_20, NumCast::from(20u16).unwrap());\n-            assert_eq!(_20, NumCast::from(20u32).unwrap());\n-            assert_eq!(_20, NumCast::from(20u64).unwrap());\n-            assert_eq!(_20, NumCast::from(20).unwrap());\n-            assert_eq!(_20, NumCast::from(20i8).unwrap());\n-            assert_eq!(_20, NumCast::from(20i16).unwrap());\n-            assert_eq!(_20, NumCast::from(20i32).unwrap());\n-            assert_eq!(_20, NumCast::from(20i64).unwrap());\n-            assert_eq!(_20, NumCast::from(20f32).unwrap());\n-            assert_eq!(_20, NumCast::from(20f64).unwrap());\n-\n-            assert_eq!(_20, cast(20usize).unwrap());\n-            assert_eq!(_20, cast(20u8).unwrap());\n-            assert_eq!(_20, cast(20u16).unwrap());\n-            assert_eq!(_20, cast(20u32).unwrap());\n-            assert_eq!(_20, cast(20u64).unwrap());\n-            assert_eq!(_20, cast(20).unwrap());\n-            assert_eq!(_20, cast(20i8).unwrap());\n-            assert_eq!(_20, cast(20i16).unwrap());\n-            assert_eq!(_20, cast(20i32).unwrap());\n-            assert_eq!(_20, cast(20i64).unwrap());\n-            assert_eq!(_20, cast(20f32).unwrap());\n-            assert_eq!(_20, cast(20f64).unwrap());\n-        })\n-    }\n-\n-    #[test] fn test_u8_cast()    { test_cast_20!(20u8)    }\n-    #[test] fn test_u16_cast()   { test_cast_20!(20u16)   }\n-    #[test] fn test_u32_cast()   { test_cast_20!(20u32)   }\n-    #[test] fn test_u64_cast()   { test_cast_20!(20u64)   }\n-    #[test] fn test_uint_cast()  { test_cast_20!(20usize) }\n-    #[test] fn test_i8_cast()    { test_cast_20!(20i8)    }\n-    #[test] fn test_i16_cast()   { test_cast_20!(20i16)   }\n-    #[test] fn test_i32_cast()   { test_cast_20!(20i32)   }\n-    #[test] fn test_i64_cast()   { test_cast_20!(20i64)   }\n-    #[test] fn test_int_cast()   { test_cast_20!(20)      }\n-    #[test] fn test_f32_cast()   { test_cast_20!(20f32)   }\n-    #[test] fn test_f64_cast()   { test_cast_20!(20f64)   }\n-\n-    #[test]\n-    fn test_cast_range_int_min() {\n-        assert_eq!(isize::MIN.to_int(),  Some(isize::MIN as isize));\n-        assert_eq!(isize::MIN.to_i8(),   None);\n-        assert_eq!(isize::MIN.to_i16(),  None);\n-        // isize::MIN.to_i32() is word-size specific\n-        assert_eq!(isize::MIN.to_i64(),  Some(isize::MIN as i64));\n-        assert_eq!(isize::MIN.to_uint(), None);\n-        assert_eq!(isize::MIN.to_u8(),   None);\n-        assert_eq!(isize::MIN.to_u16(),  None);\n-        assert_eq!(isize::MIN.to_u32(),  None);\n-        assert_eq!(isize::MIN.to_u64(),  None);\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(isize::MIN.to_i32(), Some(isize::MIN as i32));\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(isize::MIN.to_i32(), None);\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i8_min() {\n-        assert_eq!(i8::MIN.to_int(),  Some(i8::MIN as isize));\n-        assert_eq!(i8::MIN.to_i8(),   Some(i8::MIN as i8));\n-        assert_eq!(i8::MIN.to_i16(),  Some(i8::MIN as i16));\n-        assert_eq!(i8::MIN.to_i32(),  Some(i8::MIN as i32));\n-        assert_eq!(i8::MIN.to_i64(),  Some(i8::MIN as i64));\n-        assert_eq!(i8::MIN.to_uint(), None);\n-        assert_eq!(i8::MIN.to_u8(),   None);\n-        assert_eq!(i8::MIN.to_u16(),  None);\n-        assert_eq!(i8::MIN.to_u32(),  None);\n-        assert_eq!(i8::MIN.to_u64(),  None);\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i16_min() {\n-        assert_eq!(i16::MIN.to_int(),  Some(i16::MIN as isize));\n-        assert_eq!(i16::MIN.to_i8(),   None);\n-        assert_eq!(i16::MIN.to_i16(),  Some(i16::MIN as i16));\n-        assert_eq!(i16::MIN.to_i32(),  Some(i16::MIN as i32));\n-        assert_eq!(i16::MIN.to_i64(),  Some(i16::MIN as i64));\n-        assert_eq!(i16::MIN.to_uint(), None);\n-        assert_eq!(i16::MIN.to_u8(),   None);\n-        assert_eq!(i16::MIN.to_u16(),  None);\n-        assert_eq!(i16::MIN.to_u32(),  None);\n-        assert_eq!(i16::MIN.to_u64(),  None);\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i32_min() {\n-        assert_eq!(i32::MIN.to_int(),  Some(i32::MIN as isize));\n-        assert_eq!(i32::MIN.to_i8(),   None);\n-        assert_eq!(i32::MIN.to_i16(),  None);\n-        assert_eq!(i32::MIN.to_i32(),  Some(i32::MIN as i32));\n-        assert_eq!(i32::MIN.to_i64(),  Some(i32::MIN as i64));\n-        assert_eq!(i32::MIN.to_uint(), None);\n-        assert_eq!(i32::MIN.to_u8(),   None);\n-        assert_eq!(i32::MIN.to_u16(),  None);\n-        assert_eq!(i32::MIN.to_u32(),  None);\n-        assert_eq!(i32::MIN.to_u64(),  None);\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i64_min() {\n-        // i64::MIN.to_int() is word-size specific\n-        assert_eq!(i64::MIN.to_i8(),   None);\n-        assert_eq!(i64::MIN.to_i16(),  None);\n-        assert_eq!(i64::MIN.to_i32(),  None);\n-        assert_eq!(i64::MIN.to_i64(),  Some(i64::MIN as i64));\n-        assert_eq!(i64::MIN.to_uint(), None);\n-        assert_eq!(i64::MIN.to_u8(),   None);\n-        assert_eq!(i64::MIN.to_u16(),  None);\n-        assert_eq!(i64::MIN.to_u32(),  None);\n-        assert_eq!(i64::MIN.to_u64(),  None);\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(i64::MIN.to_int(), None);\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(i64::MIN.to_int(), Some(i64::MIN as isize));\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_int_max() {\n-        assert_eq!(isize::MAX.to_int(),  Some(isize::MAX as isize));\n-        assert_eq!(isize::MAX.to_i8(),   None);\n-        assert_eq!(isize::MAX.to_i16(),  None);\n-        // isize::MAX.to_i32() is word-size specific\n-        assert_eq!(isize::MAX.to_i64(),  Some(isize::MAX as i64));\n-        assert_eq!(isize::MAX.to_u8(),   None);\n-        assert_eq!(isize::MAX.to_u16(),  None);\n-        // isize::MAX.to_u32() is word-size specific\n-        assert_eq!(isize::MAX.to_u64(),  Some(isize::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(isize::MAX.to_i32(), Some(isize::MAX as i32));\n-            assert_eq!(isize::MAX.to_u32(), Some(isize::MAX as u32));\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(isize::MAX.to_i32(), None);\n-            assert_eq!(isize::MAX.to_u32(), None);\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i8_max() {\n-        assert_eq!(i8::MAX.to_int(),  Some(i8::MAX as isize));\n-        assert_eq!(i8::MAX.to_i8(),   Some(i8::MAX as i8));\n-        assert_eq!(i8::MAX.to_i16(),  Some(i8::MAX as i16));\n-        assert_eq!(i8::MAX.to_i32(),  Some(i8::MAX as i32));\n-        assert_eq!(i8::MAX.to_i64(),  Some(i8::MAX as i64));\n-        assert_eq!(i8::MAX.to_uint(), Some(i8::MAX as usize));\n-        assert_eq!(i8::MAX.to_u8(),   Some(i8::MAX as u8));\n-        assert_eq!(i8::MAX.to_u16(),  Some(i8::MAX as u16));\n-        assert_eq!(i8::MAX.to_u32(),  Some(i8::MAX as u32));\n-        assert_eq!(i8::MAX.to_u64(),  Some(i8::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i16_max() {\n-        assert_eq!(i16::MAX.to_int(),  Some(i16::MAX as isize));\n-        assert_eq!(i16::MAX.to_i8(),   None);\n-        assert_eq!(i16::MAX.to_i16(),  Some(i16::MAX as i16));\n-        assert_eq!(i16::MAX.to_i32(),  Some(i16::MAX as i32));\n-        assert_eq!(i16::MAX.to_i64(),  Some(i16::MAX as i64));\n-        assert_eq!(i16::MAX.to_uint(), Some(i16::MAX as usize));\n-        assert_eq!(i16::MAX.to_u8(),   None);\n-        assert_eq!(i16::MAX.to_u16(),  Some(i16::MAX as u16));\n-        assert_eq!(i16::MAX.to_u32(),  Some(i16::MAX as u32));\n-        assert_eq!(i16::MAX.to_u64(),  Some(i16::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i32_max() {\n-        assert_eq!(i32::MAX.to_int(),  Some(i32::MAX as isize));\n-        assert_eq!(i32::MAX.to_i8(),   None);\n-        assert_eq!(i32::MAX.to_i16(),  None);\n-        assert_eq!(i32::MAX.to_i32(),  Some(i32::MAX as i32));\n-        assert_eq!(i32::MAX.to_i64(),  Some(i32::MAX as i64));\n-        assert_eq!(i32::MAX.to_uint(), Some(i32::MAX as usize));\n-        assert_eq!(i32::MAX.to_u8(),   None);\n-        assert_eq!(i32::MAX.to_u16(),  None);\n-        assert_eq!(i32::MAX.to_u32(),  Some(i32::MAX as u32));\n-        assert_eq!(i32::MAX.to_u64(),  Some(i32::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i64_max() {\n-        // i64::MAX.to_int() is word-size specific\n-        assert_eq!(i64::MAX.to_i8(),   None);\n-        assert_eq!(i64::MAX.to_i16(),  None);\n-        assert_eq!(i64::MAX.to_i32(),  None);\n-        assert_eq!(i64::MAX.to_i64(),  Some(i64::MAX as i64));\n-        // i64::MAX.to_uint() is word-size specific\n-        assert_eq!(i64::MAX.to_u8(),   None);\n-        assert_eq!(i64::MAX.to_u16(),  None);\n-        assert_eq!(i64::MAX.to_u32(),  None);\n-        assert_eq!(i64::MAX.to_u64(),  Some(i64::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(i64::MAX.to_int(),  None);\n-            assert_eq!(i64::MAX.to_uint(), None);\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(i64::MAX.to_int(),  Some(i64::MAX as isize));\n-            assert_eq!(i64::MAX.to_uint(), Some(i64::MAX as usize));\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_uint_min() {\n-        assert_eq!(usize::MIN.to_int(),  Some(usize::MIN as isize));\n-        assert_eq!(usize::MIN.to_i8(),   Some(usize::MIN as i8));\n-        assert_eq!(usize::MIN.to_i16(),  Some(usize::MIN as i16));\n-        assert_eq!(usize::MIN.to_i32(),  Some(usize::MIN as i32));\n-        assert_eq!(usize::MIN.to_i64(),  Some(usize::MIN as i64));\n-        assert_eq!(usize::MIN.to_uint(), Some(usize::MIN as usize));\n-        assert_eq!(usize::MIN.to_u8(),   Some(usize::MIN as u8));\n-        assert_eq!(usize::MIN.to_u16(),  Some(usize::MIN as u16));\n-        assert_eq!(usize::MIN.to_u32(),  Some(usize::MIN as u32));\n-        assert_eq!(usize::MIN.to_u64(),  Some(usize::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u8_min() {\n-        assert_eq!(u8::MIN.to_int(),  Some(u8::MIN as isize));\n-        assert_eq!(u8::MIN.to_i8(),   Some(u8::MIN as i8));\n-        assert_eq!(u8::MIN.to_i16(),  Some(u8::MIN as i16));\n-        assert_eq!(u8::MIN.to_i32(),  Some(u8::MIN as i32));\n-        assert_eq!(u8::MIN.to_i64(),  Some(u8::MIN as i64));\n-        assert_eq!(u8::MIN.to_uint(), Some(u8::MIN as usize));\n-        assert_eq!(u8::MIN.to_u8(),   Some(u8::MIN as u8));\n-        assert_eq!(u8::MIN.to_u16(),  Some(u8::MIN as u16));\n-        assert_eq!(u8::MIN.to_u32(),  Some(u8::MIN as u32));\n-        assert_eq!(u8::MIN.to_u64(),  Some(u8::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u16_min() {\n-        assert_eq!(u16::MIN.to_int(),  Some(u16::MIN as isize));\n-        assert_eq!(u16::MIN.to_i8(),   Some(u16::MIN as i8));\n-        assert_eq!(u16::MIN.to_i16(),  Some(u16::MIN as i16));\n-        assert_eq!(u16::MIN.to_i32(),  Some(u16::MIN as i32));\n-        assert_eq!(u16::MIN.to_i64(),  Some(u16::MIN as i64));\n-        assert_eq!(u16::MIN.to_uint(), Some(u16::MIN as usize));\n-        assert_eq!(u16::MIN.to_u8(),   Some(u16::MIN as u8));\n-        assert_eq!(u16::MIN.to_u16(),  Some(u16::MIN as u16));\n-        assert_eq!(u16::MIN.to_u32(),  Some(u16::MIN as u32));\n-        assert_eq!(u16::MIN.to_u64(),  Some(u16::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u32_min() {\n-        assert_eq!(u32::MIN.to_int(),  Some(u32::MIN as isize));\n-        assert_eq!(u32::MIN.to_i8(),   Some(u32::MIN as i8));\n-        assert_eq!(u32::MIN.to_i16(),  Some(u32::MIN as i16));\n-        assert_eq!(u32::MIN.to_i32(),  Some(u32::MIN as i32));\n-        assert_eq!(u32::MIN.to_i64(),  Some(u32::MIN as i64));\n-        assert_eq!(u32::MIN.to_uint(), Some(u32::MIN as usize));\n-        assert_eq!(u32::MIN.to_u8(),   Some(u32::MIN as u8));\n-        assert_eq!(u32::MIN.to_u16(),  Some(u32::MIN as u16));\n-        assert_eq!(u32::MIN.to_u32(),  Some(u32::MIN as u32));\n-        assert_eq!(u32::MIN.to_u64(),  Some(u32::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u64_min() {\n-        assert_eq!(u64::MIN.to_int(),  Some(u64::MIN as isize));\n-        assert_eq!(u64::MIN.to_i8(),   Some(u64::MIN as i8));\n-        assert_eq!(u64::MIN.to_i16(),  Some(u64::MIN as i16));\n-        assert_eq!(u64::MIN.to_i32(),  Some(u64::MIN as i32));\n-        assert_eq!(u64::MIN.to_i64(),  Some(u64::MIN as i64));\n-        assert_eq!(u64::MIN.to_uint(), Some(u64::MIN as usize));\n-        assert_eq!(u64::MIN.to_u8(),   Some(u64::MIN as u8));\n-        assert_eq!(u64::MIN.to_u16(),  Some(u64::MIN as u16));\n-        assert_eq!(u64::MIN.to_u32(),  Some(u64::MIN as u32));\n-        assert_eq!(u64::MIN.to_u64(),  Some(u64::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_uint_max() {\n-        assert_eq!(usize::MAX.to_int(),  None);\n-        assert_eq!(usize::MAX.to_i8(),   None);\n-        assert_eq!(usize::MAX.to_i16(),  None);\n-        assert_eq!(usize::MAX.to_i32(),  None);\n-        // usize::MAX.to_i64() is word-size specific\n-        assert_eq!(usize::MAX.to_u8(),   None);\n-        assert_eq!(usize::MAX.to_u16(),  None);\n-        // usize::MAX.to_u32() is word-size specific\n-        assert_eq!(usize::MAX.to_u64(),  Some(usize::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(usize::MAX.to_u32(), Some(usize::MAX as u32));\n-            assert_eq!(usize::MAX.to_i64(), Some(usize::MAX as i64));\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(usize::MAX.to_u32(), None);\n-            assert_eq!(usize::MAX.to_i64(), None);\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u8_max() {\n-        assert_eq!(u8::MAX.to_int(),  Some(u8::MAX as isize));\n-        assert_eq!(u8::MAX.to_i8(),   None);\n-        assert_eq!(u8::MAX.to_i16(),  Some(u8::MAX as i16));\n-        assert_eq!(u8::MAX.to_i32(),  Some(u8::MAX as i32));\n-        assert_eq!(u8::MAX.to_i64(),  Some(u8::MAX as i64));\n-        assert_eq!(u8::MAX.to_uint(), Some(u8::MAX as usize));\n-        assert_eq!(u8::MAX.to_u8(),   Some(u8::MAX as u8));\n-        assert_eq!(u8::MAX.to_u16(),  Some(u8::MAX as u16));\n-        assert_eq!(u8::MAX.to_u32(),  Some(u8::MAX as u32));\n-        assert_eq!(u8::MAX.to_u64(),  Some(u8::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u16_max() {\n-        assert_eq!(u16::MAX.to_int(),  Some(u16::MAX as isize));\n-        assert_eq!(u16::MAX.to_i8(),   None);\n-        assert_eq!(u16::MAX.to_i16(),  None);\n-        assert_eq!(u16::MAX.to_i32(),  Some(u16::MAX as i32));\n-        assert_eq!(u16::MAX.to_i64(),  Some(u16::MAX as i64));\n-        assert_eq!(u16::MAX.to_uint(), Some(u16::MAX as usize));\n-        assert_eq!(u16::MAX.to_u8(),   None);\n-        assert_eq!(u16::MAX.to_u16(),  Some(u16::MAX as u16));\n-        assert_eq!(u16::MAX.to_u32(),  Some(u16::MAX as u32));\n-        assert_eq!(u16::MAX.to_u64(),  Some(u16::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u32_max() {\n-        // u32::MAX.to_int() is word-size specific\n-        assert_eq!(u32::MAX.to_i8(),   None);\n-        assert_eq!(u32::MAX.to_i16(),  None);\n-        assert_eq!(u32::MAX.to_i32(),  None);\n-        assert_eq!(u32::MAX.to_i64(),  Some(u32::MAX as i64));\n-        assert_eq!(u32::MAX.to_uint(), Some(u32::MAX as usize));\n-        assert_eq!(u32::MAX.to_u8(),   None);\n-        assert_eq!(u32::MAX.to_u16(),  None);\n-        assert_eq!(u32::MAX.to_u32(),  Some(u32::MAX as u32));\n-        assert_eq!(u32::MAX.to_u64(),  Some(u32::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(u32::MAX.to_int(),  None);\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(u32::MAX.to_int(),  Some(u32::MAX as isize));\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u64_max() {\n-        assert_eq!(u64::MAX.to_int(),  None);\n-        assert_eq!(u64::MAX.to_i8(),   None);\n-        assert_eq!(u64::MAX.to_i16(),  None);\n-        assert_eq!(u64::MAX.to_i32(),  None);\n-        assert_eq!(u64::MAX.to_i64(),  None);\n-        // u64::MAX.to_uint() is word-size specific\n-        assert_eq!(u64::MAX.to_u8(),   None);\n-        assert_eq!(u64::MAX.to_u16(),  None);\n-        assert_eq!(u64::MAX.to_u32(),  None);\n-        assert_eq!(u64::MAX.to_u64(),  Some(u64::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(u64::MAX.to_uint(), None);\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(u64::MAX.to_uint(), Some(u64::MAX as usize));\n-        }\n-\n-        check_word_size();\n-    }\n+    use ops::Mul;\n \n     #[test]\n     fn test_saturating_add_uint() {\n@@ -1596,23 +106,23 @@ mod tests {\n     #[test]\n     fn test_saturating_add_int() {\n         use isize::{MIN,MAX};\n-        assert_eq!(3.saturating_add(5), 8);\n-        assert_eq!(3.saturating_add(MAX-1), MAX);\n+        assert_eq!(3i32.saturating_add(5), 8);\n+        assert_eq!(3isize.saturating_add(MAX-1), MAX);\n         assert_eq!(MAX.saturating_add(MAX), MAX);\n         assert_eq!((MAX-2).saturating_add(1), MAX-1);\n-        assert_eq!(3.saturating_add(-5), -2);\n+        assert_eq!(3i32.saturating_add(-5), -2);\n         assert_eq!(MIN.saturating_add(-1), MIN);\n-        assert_eq!((-2).saturating_add(-MAX), MIN);\n+        assert_eq!((-2isize).saturating_add(-MAX), MIN);\n     }\n \n     #[test]\n     fn test_saturating_sub_int() {\n         use isize::{MIN,MAX};\n-        assert_eq!(3.saturating_sub(5), -2);\n+        assert_eq!(3i32.saturating_sub(5), -2);\n         assert_eq!(MIN.saturating_sub(1), MIN);\n-        assert_eq!((-2).saturating_sub(MAX), MIN);\n-        assert_eq!(3.saturating_sub(-5), 8);\n-        assert_eq!(3.saturating_sub(-(MAX-1)), MAX);\n+        assert_eq!((-2isize).saturating_sub(MAX), MIN);\n+        assert_eq!(3i32.saturating_sub(-5), 8);\n+        assert_eq!(3isize.saturating_sub(-(MAX-1)), MAX);\n         assert_eq!(MAX.saturating_sub(-MAX), MAX);\n         assert_eq!((MAX-2).saturating_sub(-1), MAX-1);\n     }\n@@ -1716,56 +226,10 @@ mod tests {\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_u64, u64 }\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_uint, usize }\n \n-    #[derive(PartialEq, Debug)]\n-    struct Value { x: isize }\n-\n-    impl ToPrimitive for Value {\n-        fn to_i64(&self) -> Option<i64> { self.x.to_i64() }\n-        fn to_u64(&self) -> Option<u64> { self.x.to_u64() }\n-    }\n-\n-    impl FromPrimitive for Value {\n-        fn from_i64(n: i64) -> Option<Value> { Some(Value { x: n as isize }) }\n-        fn from_u64(n: u64) -> Option<Value> { Some(Value { x: n as isize }) }\n-    }\n-\n-    #[test]\n-    fn test_to_primitive() {\n-        let value = Value { x: 5 };\n-        assert_eq!(value.to_int(),  Some(5));\n-        assert_eq!(value.to_i8(),   Some(5));\n-        assert_eq!(value.to_i16(),  Some(5));\n-        assert_eq!(value.to_i32(),  Some(5));\n-        assert_eq!(value.to_i64(),  Some(5));\n-        assert_eq!(value.to_uint(), Some(5));\n-        assert_eq!(value.to_u8(),   Some(5));\n-        assert_eq!(value.to_u16(),  Some(5));\n-        assert_eq!(value.to_u32(),  Some(5));\n-        assert_eq!(value.to_u64(),  Some(5));\n-        assert_eq!(value.to_f32(),  Some(5f32));\n-        assert_eq!(value.to_f64(),  Some(5f64));\n-    }\n-\n-    #[test]\n-    fn test_from_primitive() {\n-        assert_eq!(from_int(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_i8(5),     Some(Value { x: 5 }));\n-        assert_eq!(from_i16(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_i32(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_i64(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_uint(5),   Some(Value { x: 5 }));\n-        assert_eq!(from_u8(5),     Some(Value { x: 5 }));\n-        assert_eq!(from_u16(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_u32(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_u64(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_f32(5f32), Some(Value { x: 5 }));\n-        assert_eq!(from_f64(5f64), Some(Value { x: 5 }));\n-    }\n-\n     #[test]\n     fn test_pow() {\n-        fn naive_pow<T: Int>(base: T, exp: usize) -> T {\n-            let one: T = Int::one();\n+        fn naive_pow<T: Mul<Output=T> + One + Copy>(base: T, exp: usize) -> T {\n+            let one: T = T::one();\n             (0..exp).fold(one, |acc, _| acc * base)\n         }\n         macro_rules! assert_pow {\n@@ -1775,11 +239,11 @@ mod tests {\n                 assert_eq!(result, naive_pow($num, $exp));\n             }}\n         }\n-        assert_pow!((3,     0 ) => 1);\n-        assert_pow!((5,     1 ) => 5);\n-        assert_pow!((-4,    2 ) => 16);\n-        assert_pow!((8,     3 ) => 512);\n-        assert_pow!((2u64,   50) => 1125899906842624);\n+        assert_pow!((3u32,     0 ) => 1);\n+        assert_pow!((5u32,     1 ) => 5);\n+        assert_pow!((-4i32,    2 ) => 16);\n+        assert_pow!((8u32,     3 ) => 512);\n+        assert_pow!((2u64,     50) => 1125899906842624);\n     }\n \n     #[test]\n@@ -1854,12 +318,11 @@ mod tests {\n mod bench {\n     extern crate test;\n     use self::test::Bencher;\n-    use num::Int;\n     use prelude::v1::*;\n \n     #[bench]\n     fn bench_pow_function(b: &mut Bencher) {\n-        let v = (0..1024).collect::<Vec<_>>();\n-        b.iter(|| {v.iter().fold(0, |old, new| old.pow(*new as u32));});\n+        let v = (0..1024).collect::<Vec<u32>>();\n+        b.iter(|| {v.iter().fold(0u32, |old, new| old.pow(*new as u32));});\n     }\n }"}, {"sha": "ce1da4742d1dffe0c5c042d6dc627f7bb8713f16", "filename": "src/libstd/num/strconv.rs", "status": "removed", "additions": 0, "deletions": 556, "changes": 556, "blob_url": "https://github.com/rust-lang/rust/blob/98e9765d973d46faa5c80fb37a48040ca9e87b28/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e9765d973d46faa5c80fb37a48040ca9e87b28/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=98e9765d973d46faa5c80fb37a48040ca9e87b28", "patch": "@@ -1,556 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(missing_docs)]\n-#![allow(deprecated)]\n-\n-use self::ExponentFormat::*;\n-use self::SignificantDigits::*;\n-use self::SignFormat::*;\n-\n-use char;\n-use num::{self, Int, Float, ToPrimitive};\n-use num::FpCategory as Fp;\n-use ops::FnMut;\n-use string::String;\n-use vec::Vec;\n-\n-/// A flag that specifies whether to use exponential (scientific) notation.\n-#[derive(Copy, Clone)]\n-pub enum ExponentFormat {\n-    /// Do not use exponential notation.\n-    ExpNone,\n-    /// Use exponential notation with the exponent having a base of 10 and the\n-    /// exponent sign being `e` or `E`. For example, 1000 would be printed\n-    /// 1e3.\n-    ExpDec,\n-    /// Use exponential notation with the exponent having a base of 2 and the\n-    /// exponent sign being `p` or `P`. For example, 8 would be printed 1p3.\n-    ExpBin,\n-}\n-\n-/// The number of digits used for emitting the fractional part of a number, if\n-/// any.\n-#[derive(Copy, Clone)]\n-pub enum SignificantDigits {\n-    /// All calculable digits will be printed.\n-    ///\n-    /// Note that bignums or fractions may cause a surprisingly large number\n-    /// of digits to be printed.\n-    DigAll,\n-\n-    /// At most the given number of digits will be printed, truncating any\n-    /// trailing zeroes.\n-    DigMax(usize),\n-\n-    /// Precisely the given number of digits will be printed.\n-    DigExact(usize)\n-}\n-\n-/// How to emit the sign of a number.\n-#[derive(Copy, Clone)]\n-pub enum SignFormat {\n-    /// No sign will be printed. The exponent sign will also be emitted.\n-    SignNone,\n-    /// `-` will be printed for negative values, but no sign will be emitted\n-    /// for positive numbers.\n-    SignNeg,\n-    /// `+` will be printed for positive values, and `-` will be printed for\n-    /// negative values.\n-    SignAll,\n-}\n-\n-/// Converts an integral number to its string representation as a byte vector.\n-/// This is meant to be a common base implementation for all integral string\n-/// conversion functions like `to_string()` or `to_str_radix()`.\n-///\n-/// # Arguments\n-///\n-/// - `num`           - The number to convert. Accepts any number that\n-///                     implements the numeric traits.\n-/// - `radix`         - Base to use. Accepts only the values 2-36.\n-/// - `sign`          - How to emit the sign. Options are:\n-///     - `SignNone`: No sign at all. Basically emits `abs(num)`.\n-///     - `SignNeg`:  Only `-` on negative values.\n-///     - `SignAll`:  Both `+` on positive, and `-` on negative numbers.\n-/// - `f`             - a callback which will be invoked for each ascii character\n-///                     which composes the string representation of this integer\n-///\n-/// # Panics\n-///\n-/// - Panics if `radix` < 2 or `radix` > 36.\n-fn int_to_str_bytes_common<T, F>(num: T, radix: usize, sign: SignFormat, mut f: F) where\n-    T: Int,\n-    F: FnMut(u8),\n-{\n-    assert!(2 <= radix && radix <= 36);\n-\n-    let _0: T = Int::zero();\n-\n-    let neg = num < _0;\n-    let radix_gen: T = num::cast(radix).unwrap();\n-\n-    let mut deccum = num;\n-    // This is just for integral types, the largest of which is a u64. The\n-    // smallest base that we can have is 2, so the most number of digits we're\n-    // ever going to have is 64\n-    let mut buf = [0; 64];\n-    let mut cur = 0;\n-\n-    // Loop at least once to make sure at least a `0` gets emitted.\n-    loop {\n-        // Calculate the absolute value of each digit instead of only\n-        // doing it once for the whole number because a\n-        // representable negative number doesn't necessary have an\n-        // representable additive inverse of the same type\n-        // (See twos complement). But we assume that for the\n-        // numbers [-35 .. 0] we always have [0 .. 35].\n-        let current_digit_signed = deccum % radix_gen;\n-        let current_digit = if current_digit_signed < _0 {\n-            _0 - current_digit_signed\n-        } else {\n-            current_digit_signed\n-        };\n-        buf[cur] = match current_digit.to_u8().unwrap() {\n-            i @ 0...9 => b'0' + i,\n-            i         => b'a' + (i - 10),\n-        };\n-        cur += 1;\n-\n-        deccum = deccum / radix_gen;\n-        // No more digits to calculate for the non-fractional part -> break\n-        if deccum == _0 { break; }\n-    }\n-\n-    // Decide what sign to put in front\n-    match sign {\n-        SignNeg | SignAll if neg => { f(b'-'); }\n-        SignAll => { f(b'+'); }\n-        _ => ()\n-    }\n-\n-    // We built the number in reverse order, so un-reverse it here\n-    while cur > 0 {\n-        cur -= 1;\n-        f(buf[cur]);\n-    }\n-}\n-\n-/// Converts a number to its string representation as a byte vector.\n-/// This is meant to be a common base implementation for all numeric string\n-/// conversion functions like `to_string()` or `to_str_radix()`.\n-///\n-/// # Arguments\n-///\n-/// - `num`           - The number to convert. Accepts any number that\n-///                     implements the numeric traits.\n-/// - `radix`         - Base to use. Accepts only the values 2-36. If the exponential notation\n-///                     is used, then this base is only used for the significand. The exponent\n-///                     itself always printed using a base of 10.\n-/// - `negative_zero` - Whether to treat the special value `-0` as\n-///                     `-0` or as `+0`.\n-/// - `sign`          - How to emit the sign. See `SignFormat`.\n-/// - `digits`        - The amount of digits to use for emitting the fractional\n-///                     part, if any. See `SignificantDigits`.\n-/// - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n-///                    See `ExponentFormat`.\n-/// - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n-///                     exponential notation is desired.\n-///\n-/// # Return value\n-///\n-/// A tuple containing the byte vector, and a boolean flag indicating\n-/// whether it represents a special value like `inf`, `-inf`, `NaN` or not.\n-/// It returns a tuple because there can be ambiguity between a special value\n-/// and a number representation at higher bases.\n-///\n-/// # Panics\n-///\n-/// - Panics if `radix` < 2 or `radix` > 36.\n-/// - Panics if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n-///   between digit and exponent sign `'e'`.\n-/// - Panics if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n-///   between digit and exponent sign `'p'`.\n-pub fn float_to_str_bytes_common<T: Float>(\n-        num: T, radix: u32, negative_zero: bool,\n-        sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n-        ) -> (Vec<u8>, bool) {\n-    assert!(2 <= radix && radix <= 36);\n-    match exp_format {\n-        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => panic!(\"float_to_str_bytes_common: radix {} incompatible with \\\n-                    use of 'e' as decimal exponent\", radix),\n-        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => panic!(\"float_to_str_bytes_common: radix {} incompatible with \\\n-                    use of 'p' as binary exponent\", radix),\n-        _ => ()\n-    }\n-\n-    let _0: T = Float::zero();\n-    let _1: T = Float::one();\n-\n-    match num.classify() {\n-        Fp::Nan => { return (b\"NaN\".to_vec(), true); }\n-        Fp::Infinite if num > _0 => {\n-            return match sign {\n-                SignAll => (b\"+inf\".to_vec(), true),\n-                _       => (b\"inf\".to_vec(), true)\n-            };\n-        }\n-        Fp::Infinite if num < _0 => {\n-            return match sign {\n-                SignNone => (b\"inf\".to_vec(), true),\n-                _        => (b\"-inf\".to_vec(), true),\n-            };\n-        }\n-        _ => {}\n-    }\n-\n-    let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n-    let mut buf = Vec::new();\n-    let radix_gen: T = num::cast(radix as isize).unwrap();\n-\n-    let (num, exp) = match exp_format {\n-        ExpNone => (num, 0),\n-        ExpDec | ExpBin => {\n-            if num == _0 {\n-                (num, 0)\n-            } else {\n-                let (exp, exp_base) = match exp_format {\n-                    ExpDec => (num.abs().log10().floor(), num::cast::<f64, T>(10.0f64).unwrap()),\n-                    ExpBin => (num.abs().log2().floor(), num::cast::<f64, T>(2.0f64).unwrap()),\n-                    ExpNone => unreachable!()\n-                };\n-\n-                (num / exp_base.powf(exp), num::cast::<T, i32>(exp).unwrap())\n-            }\n-        }\n-    };\n-\n-    // First emit the non-fractional part, looping at least once to make\n-    // sure at least a `0` gets emitted.\n-    let mut deccum = num.trunc();\n-    loop {\n-        // Calculate the absolute value of each digit instead of only\n-        // doing it once for the whole number because a\n-        // representable negative number doesn't necessary have an\n-        // representable additive inverse of the same type\n-        // (See twos complement). But we assume that for the\n-        // numbers [-35 .. 0] we always have [0 .. 35].\n-        let current_digit = (deccum % radix_gen).abs();\n-\n-        // Decrease the deccumulator one digit at a time\n-        deccum = deccum / radix_gen;\n-        deccum = deccum.trunc();\n-\n-        buf.push(char::from_digit(current_digit.to_isize().unwrap() as u32, radix)\n-             .unwrap() as u8);\n-\n-        // No more digits to calculate for the non-fractional part -> break\n-        if deccum == _0 { break; }\n-    }\n-\n-    // If limited digits, calculate one digit more for rounding.\n-    let (limit_digits, digit_count, exact) = match digits {\n-        DigAll          => (false, 0,       false),\n-        DigMax(count)   => (true,  count+1, false),\n-        DigExact(count) => (true,  count+1, true)\n-    };\n-\n-    // Decide what sign to put in front\n-    match sign {\n-        SignNeg | SignAll if neg => {\n-            buf.push(b'-');\n-        }\n-        SignAll => {\n-            buf.push(b'+');\n-        }\n-        _ => ()\n-    }\n-\n-    buf.reverse();\n-\n-    // Remember start of the fractional digits.\n-    // Points one beyond end of buf if none get generated,\n-    // or at the '.' otherwise.\n-    let start_fractional_digits = buf.len();\n-\n-    // Now emit the fractional part, if any\n-    deccum = num.fract();\n-    if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n-        buf.push(b'.');\n-        let mut dig = 0;\n-\n-        // calculate new digits while\n-        // - there is no limit and there are digits left\n-        // - or there is a limit, it's not reached yet and\n-        //   - it's exact\n-        //   - or it's a maximum, and there are still digits left\n-        while (!limit_digits && deccum != _0)\n-           || (limit_digits && dig < digit_count && (\n-                   exact\n-                || (!exact && deccum != _0)\n-              )\n-        ) {\n-            // Shift first fractional digit into the integer part\n-            deccum = deccum * radix_gen;\n-\n-            // Calculate the absolute value of each digit.\n-            // See note in first loop.\n-            let current_digit = deccum.trunc().abs();\n-\n-            buf.push(char::from_digit(\n-                current_digit.to_isize().unwrap() as u32, radix).unwrap() as u8);\n-\n-            // Decrease the deccumulator one fractional digit at a time\n-            deccum = deccum.fract();\n-            dig += 1;\n-        }\n-\n-        // If digits are limited, and that limit has been reached,\n-        // cut off the one extra digit, and depending on its value\n-        // round the remaining ones.\n-        if limit_digits && dig == digit_count {\n-            let ascii2value = |chr: u8| {\n-                (chr as char).to_digit(radix).unwrap()\n-            };\n-            let value2ascii = |val: u32| {\n-                char::from_digit(val, radix).unwrap() as u8\n-            };\n-\n-            let extra_digit = ascii2value(buf.pop().unwrap());\n-            if extra_digit >= radix / 2 { // -> need to round\n-                let mut i: isize = buf.len() as isize - 1;\n-                loop {\n-                    // If reached left end of number, have to\n-                    // insert additional digit:\n-                    if i < 0\n-                    || buf[i as usize] == b'-'\n-                    || buf[i as usize] == b'+' {\n-                        buf.insert((i + 1) as usize, value2ascii(1));\n-                        break;\n-                    }\n-\n-                    // Skip the '.'\n-                    if buf[i as usize] == b'.' { i -= 1; continue; }\n-\n-                    // Either increment the digit,\n-                    // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as usize]);\n-                    if current_digit < (radix - 1) {\n-                        buf[i as usize] = value2ascii(current_digit+1);\n-                        break;\n-                    } else {\n-                        buf[i as usize] = value2ascii(0);\n-                        i -= 1;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // if number of digits is not exact, remove all trailing '0's up to\n-    // and including the '.'\n-    if !exact {\n-        let buf_max_i = buf.len() - 1;\n-\n-        // index to truncate from\n-        let mut i = buf_max_i;\n-\n-        // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && buf[i] == b'0' {\n-            i -= 1;\n-        }\n-\n-        // Only attempt to truncate digits if buf has fractional digits\n-        if i >= start_fractional_digits {\n-            // If buf ends with '.', cut that too.\n-            if buf[i] == b'.' { i -= 1 }\n-\n-            // only resize buf if we actually remove digits\n-            if i < buf_max_i {\n-                buf = buf[.. (i + 1)].to_vec();\n-            }\n-        }\n-    } // If exact and trailing '.', just cut that\n-    else {\n-        let max_i = buf.len() - 1;\n-        if buf[max_i] == b'.' {\n-            buf = buf[.. max_i].to_vec();\n-        }\n-    }\n-\n-    match exp_format {\n-        ExpNone => (),\n-        _ => {\n-            buf.push(match exp_format {\n-                ExpDec if exp_upper => 'E',\n-                ExpDec if !exp_upper => 'e',\n-                ExpBin if exp_upper => 'P',\n-                ExpBin if !exp_upper => 'p',\n-                _ => unreachable!()\n-            } as u8);\n-\n-            int_to_str_bytes_common(exp, 10, sign, |c| buf.push(c));\n-        }\n-    }\n-\n-    (buf, false)\n-}\n-\n-/// Converts a number to its string representation. This is a wrapper for\n-/// `to_str_bytes_common()`, for details see there.\n-#[inline]\n-pub fn float_to_str_common<T: Float>(\n-        num: T, radix: u32, negative_zero: bool,\n-        sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n-        ) -> (String, bool) {\n-    let (bytes, special) = float_to_str_bytes_common(num, radix,\n-                               negative_zero, sign, digits, exp_format, exp_capital);\n-    (String::from_utf8(bytes).unwrap(), special)\n-}\n-\n-// Some constants for from_str_bytes_common's input validation,\n-// they define minimum radix values for which the character is a valid digit.\n-const DIGIT_P_RADIX: u32 = ('p' as u32) - ('a' as u32) + 11;\n-const DIGIT_E_RADIX: u32 = ('e' as u32) - ('a' as u32) + 11;\n-\n-#[cfg(test)]\n-mod tests {\n-    use core::num::wrapping::WrappingOps;\n-    use string::ToString;\n-\n-    #[test]\n-    fn test_int_to_str_overflow() {\n-        let mut i8_val: i8 = 127;\n-        assert_eq!(i8_val.to_string(), \"127\");\n-\n-        i8_val = i8_val.wrapping_add(1);\n-        assert_eq!(i8_val.to_string(), \"-128\");\n-\n-        let mut i16_val: i16 = 32_767;\n-        assert_eq!(i16_val.to_string(), \"32767\");\n-\n-        i16_val = i16_val.wrapping_add(1);\n-        assert_eq!(i16_val.to_string(), \"-32768\");\n-\n-        let mut i32_val: i32 = 2_147_483_647;\n-        assert_eq!(i32_val.to_string(), \"2147483647\");\n-\n-        i32_val = i32_val.wrapping_add(1);\n-        assert_eq!(i32_val.to_string(), \"-2147483648\");\n-\n-        let mut i64_val: i64 = 9_223_372_036_854_775_807;\n-        assert_eq!(i64_val.to_string(), \"9223372036854775807\");\n-\n-        i64_val = i64_val.wrapping_add(1);\n-        assert_eq!(i64_val.to_string(), \"-9223372036854775808\");\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    #![allow(deprecated)] // rand\n-    extern crate test;\n-\n-    mod usize {\n-        use super::test::Bencher;\n-        use rand::{thread_rng, Rng};\n-        use std::fmt;\n-\n-        #[inline]\n-        fn to_string(x: usize, base: u8) {\n-            format!(\"{}\", fmt::radix(x, base));\n-        }\n-\n-        #[bench]\n-        fn to_str_bin(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 2); })\n-        }\n-\n-        #[bench]\n-        fn to_str_oct(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 8); })\n-        }\n-\n-        #[bench]\n-        fn to_str_dec(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 10); })\n-        }\n-\n-        #[bench]\n-        fn to_str_hex(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 16); })\n-        }\n-\n-        #[bench]\n-        fn to_str_base_36(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 36); })\n-        }\n-    }\n-\n-    mod isize {\n-        use super::test::Bencher;\n-        use rand::{thread_rng, Rng};\n-        use std::fmt;\n-\n-        #[inline]\n-        fn to_string(x: isize, base: u8) {\n-            format!(\"{}\", fmt::radix(x, base));\n-        }\n-\n-        #[bench]\n-        fn to_str_bin(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 2); })\n-        }\n-\n-        #[bench]\n-        fn to_str_oct(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 8); })\n-        }\n-\n-        #[bench]\n-        fn to_str_dec(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 10); })\n-        }\n-\n-        #[bench]\n-        fn to_str_hex(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 16); })\n-        }\n-\n-        #[bench]\n-        fn to_str_base_36(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 36); })\n-        }\n-    }\n-\n-    mod f64 {\n-        use super::test::Bencher;\n-        use rand::{thread_rng, Rng};\n-        use f64;\n-\n-        #[bench]\n-        fn float_to_string(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { f64::to_string(rng.gen()); })\n-        }\n-    }\n-}"}, {"sha": "96b0ba1c77f8da8c600cf02a16eebabe43fe0960", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,12 +12,11 @@\n #![doc(hidden)]\n #![allow(unsigned_negation)]\n \n-macro_rules! uint_module { ($T:ty) => (\n+macro_rules! uint_module { ($T:ident) => (\n \n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n-    use num::FromStrRadix;\n \n     fn from_str<T: ::str::FromStr>(t: &str) -> Option<T> {\n         ::str::FromStr::from_str(t).ok()\n@@ -38,15 +37,15 @@ mod tests {\n \n     #[test]\n     pub fn test_parse_bytes() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Ok(123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Ok(9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Ok(83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Ok(291 as u16));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Ok(65535 as u16));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Ok(35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"_\", 2).ok(), None::<$T>);\n+        assert_eq!($T::from_str_radix(\"123\", 10), Ok(123 as $T));\n+        assert_eq!($T::from_str_radix(\"1001\", 2), Ok(9 as $T));\n+        assert_eq!($T::from_str_radix(\"123\", 8), Ok(83 as $T));\n+        assert_eq!(u16::from_str_radix(\"123\", 16), Ok(291 as u16));\n+        assert_eq!(u16::from_str_radix(\"ffff\", 16), Ok(65535 as u16));\n+        assert_eq!($T::from_str_radix(\"z\", 36), Ok(35 as $T));\n+\n+        assert_eq!($T::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n+        assert_eq!($T::from_str_radix(\"_\", 2).ok(), None::<$T>);\n     }\n }\n "}, {"sha": "e8052041aeb300a669eee29af47b3a74287fed9a", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -110,7 +110,7 @@ use string::String;\n use vec::Vec;\n use fmt;\n \n-use ffi::{OsStr, OsString, AsOsStr};\n+use ffi::{OsStr, OsString};\n \n use self::platform::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n \n@@ -1184,14 +1184,6 @@ impl AsRef<OsStr> for PathBuf {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for PathBuf {\n-    fn as_os_str(&self) -> &OsStr {\n-        &self.inner[..]\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Into<OsString> for PathBuf {\n     fn into(self) -> OsString {\n@@ -1652,14 +1644,6 @@ impl AsRef<OsStr> for Path {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for Path {\n-    fn as_os_str(&self) -> &OsStr {\n-        &self.inner\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Path {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n@@ -1711,22 +1695,6 @@ impl cmp::Ord for Path {\n     }\n }\n \n-/// Freely convertible to a `Path`.\n-#[unstable(feature = \"std_misc\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::convert::AsRef<Path> instead\")]\n-pub trait AsPath {\n-    /// Converts to a `Path`.\n-    #[unstable(feature = \"std_misc\")]\n-    fn as_path(&self) -> &Path;\n-}\n-\n-#[unstable(feature = \"std_misc\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::convert::AsRef<Path> instead\")]\n-#[allow(deprecated)]\n-impl<T: AsOsStr + ?Sized> AsPath for T {\n-    fn as_path(&self) -> &Path { Path::new(self.as_os_str()) }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for Path {\n     fn as_ref(&self) -> &Path { self }"}, {"sha": "2837bac445697348b4472a7034d27e92e193b059", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -67,7 +67,6 @@ mod test {\n     use prelude::v1::*;\n \n     use super::ReaderRng;\n-    use num::Int;\n     use rand::Rng;\n \n     #[test]\n@@ -78,18 +77,18 @@ mod test {\n                   0,   0, 0, 0, 0, 0, 0, 3][..];\n         let mut rng = ReaderRng::new(v);\n \n-        assert_eq!(rng.next_u64(), 1.to_be());\n-        assert_eq!(rng.next_u64(), 2.to_be());\n-        assert_eq!(rng.next_u64(), 3.to_be());\n+        assert_eq!(rng.next_u64(), 1u64.to_be());\n+        assert_eq!(rng.next_u64(), 2u64.to_be());\n+        assert_eq!(rng.next_u64(), 3u64.to_be());\n     }\n     #[test]\n     fn test_reader_rng_u32() {\n         let v = &[0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3][..];\n         let mut rng = ReaderRng::new(v);\n \n-        assert_eq!(rng.next_u32(), 1.to_be());\n-        assert_eq!(rng.next_u32(), 2.to_be());\n-        assert_eq!(rng.next_u32(), 3.to_be());\n+        assert_eq!(rng.next_u32(), 1u32.to_be());\n+        assert_eq!(rng.next_u32(), 2u32.to_be());\n+        assert_eq!(rng.next_u32(), 3u32.to_be());\n     }\n     #[test]\n     fn test_reader_rng_fill_bytes() {"}, {"sha": "c2964b7a4f12506d15033e15ef93833f2c14c937", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -161,14 +161,6 @@ impl Condvar {\n         }\n     }\n \n-    /// Deprecated: use `wait_timeout_ms` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use wait_timeout_ms instead\")]\n-    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n-        self.wait_timeout_ms(guard, dur.num_milliseconds() as u32)\n-    }\n-\n     /// Waits on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///"}, {"sha": "56a952e6a7ef6e0d291e34c74cd853507917b7b0", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -37,8 +37,6 @@ use fmt;\n use hash::{Hash, Hasher};\n use iter::FromIterator;\n use mem;\n-#[allow(deprecated)] // Int\n-use num::Int;\n use ops;\n use slice;\n use str;"}, {"sha": "ed6382e000ac90278a0c2e5b852e4c3cd154a2e2", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -17,7 +17,6 @@ use sys::mutex::{self, Mutex};\n use sys::time;\n use sys::sync as ffi;\n use time::Duration;\n-use num::{Int, NumCast};\n \n pub struct Condvar { inner: UnsafeCell<ffi::pthread_cond_t> }\n \n@@ -70,8 +69,8 @@ impl Condvar {\n         let r = ffi::gettimeofday(&mut sys_now, ptr::null_mut());\n         debug_assert_eq!(r, 0);\n \n-        let seconds = NumCast::from(dur.num_seconds());\n-        let timeout = match seconds.and_then(|s| sys_now.tv_sec.checked_add(s)) {\n+        let seconds = dur.num_seconds() as libc::time_t;\n+        let timeout = match sys_now.tv_sec.checked_add(seconds) {\n             Some(sec) => {\n                 libc::timespec {\n                     tv_sec: sec,\n@@ -81,7 +80,7 @@ impl Condvar {\n             }\n             None => {\n                 libc::timespec {\n-                    tv_sec: Int::max_value(),\n+                    tv_sec: <libc::time_t>::max_value(),\n                     tv_nsec: 1_000_000_000 - 1,\n                 }\n             }"}, {"sha": "d99753a6a4c800c47b0237b23fa2b5dfb328d652", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -15,7 +15,8 @@ use prelude::v1::*;\n \n use io::{self, ErrorKind};\n use libc;\n-use num::{Int, SignedInt};\n+use num::One;\n+use ops::Neg;\n \n pub mod backtrace;\n pub mod c;\n@@ -63,23 +64,8 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     }\n }\n \n-#[inline]\n-#[allow(deprecated)]\n-pub fn retry<T, F> (mut f: F) -> T where\n-    T: SignedInt,\n-    F: FnMut() -> T,\n-{\n-    let one: T = Int::one();\n-    loop {\n-        let n = f();\n-        if n == -one && os::errno() == libc::EINTR as i32 { }\n-        else { return n }\n-    }\n-}\n-\n-#[allow(deprecated)]\n-pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n-    let one: T = Int::one();\n+pub fn cvt<T: One + PartialEq + Neg<Output=T>>(t: T) -> io::Result<T> {\n+    let one: T = T::one();\n     if t == -one {\n         Err(io::Error::last_os_error())\n     } else {\n@@ -89,7 +75,7 @@ pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n \n #[allow(deprecated)]\n pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n-    where T: SignedInt, F: FnMut() -> T\n+    where T: One + PartialEq + Neg<Output=T>, F: FnMut() -> T\n {\n     loop {\n         match cvt(f()) {"}, {"sha": "4e7c4d241f53209b2f0acbf99aef8a467d2d7ea8", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -19,7 +19,7 @@ use io::{self, Error, ErrorKind};\n use libc::{self, pid_t, c_void, c_int, gid_t, uid_t};\n use ptr;\n use sys::pipe2::AnonPipe;\n-use sys::{self, retry, c, cvt};\n+use sys::{self, c, cvt, cvt_r};\n use sys::fs2::{File, OpenOptions};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -273,7 +273,7 @@ impl Process {\n                     }\n                 }\n             };\n-            retry(|| libc::dup2(fd.raw(), dst)) != -1\n+            cvt_r(|| libc::dup2(fd.raw(), dst)).is_ok()\n         };\n \n         if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n@@ -317,19 +317,19 @@ impl Process {\n \n     pub fn wait(&self) -> io::Result<ExitStatus> {\n         let mut status = 0 as c_int;\n-        try!(cvt(retry(|| unsafe { c::waitpid(self.pid, &mut status, 0) })));\n+        try!(cvt_r(|| unsafe { c::waitpid(self.pid, &mut status, 0) }));\n         Ok(translate_status(status))\n     }\n \n     pub fn try_wait(&self) -> Option<ExitStatus> {\n         let mut status = 0 as c_int;\n-        match retry(|| unsafe {\n+        match cvt_r(|| unsafe {\n             c::waitpid(self.pid, &mut status, c::WNOHANG)\n         }) {\n-            n if n == self.pid => Some(translate_status(status)),\n-            0 => None,\n-            n => panic!(\"unknown waitpid error `{}`: {}\", n,\n-                       io::Error::last_os_error()),\n+            Ok(0) => None,\n+            Ok(n) if n == self.pid => Some(translate_status(status)),\n+            Ok(n) => panic!(\"unkown pid: {}\", n),\n+            Err(e) => panic!(\"unknown waitpid error: {}\", e),\n         }\n     }\n }"}, {"sha": "af61eec319c5a2b6a8637f229fdf29e6f787d8ad", "filename": "src/libstd/sys/windows/fs2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,7 +13,7 @@ use io::prelude::*;\n use os::windows::prelude::*;\n \n use default::Default;\n-use ffi::{OsString, AsOsStr};\n+use ffi::OsString;\n use fmt;\n use io::{self, Error, SeekFrom};\n use libc::{self, HANDLE};"}, {"sha": "5ae5f6f201bad0bcffb03d7f8e978544bb60ba52", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -17,8 +17,7 @@ use prelude::v1::*;\n use ffi::{OsStr, OsString};\n use io::{self, ErrorKind};\n use libc;\n-#[allow(deprecated)]\n-use num::Int;\n+use num::Zero;\n use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n \n@@ -144,9 +143,8 @@ pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     }\n }\n \n-#[allow(deprecated)]\n-fn cvt<I: Int>(i: I) -> io::Result<I> {\n-    if i == Int::zero() {\n+fn cvt<I: PartialEq + Zero>(i: I) -> io::Result<I> {\n+    if i == I::zero() {\n         Err(io::Error::last_os_error())\n     } else {\n         Ok(i)"}, {"sha": "6bbcd968157aba084deecae84dbe9fad92a8456a", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -15,8 +15,8 @@ use libc::consts::os::extra::INVALID_SOCKET;\n use libc::{self, c_int, c_void};\n use mem;\n use net::SocketAddr;\n-#[allow(deprecated)]\n-use num::{SignedInt, Int};\n+use num::One;\n+use ops::Neg;\n use rt;\n use sync::{Once, ONCE_INIT};\n use sys::c;\n@@ -49,11 +49,8 @@ fn last_error() -> io::Error {\n /// Checks if the signed integer is the Windows constant `SOCKET_ERROR` (-1)\n /// and if so, returns the last error from the Windows socket interface. . This\n /// function must be called before another call to the socket API is made.\n-///\n-/// FIXME: generics needed?\n-#[allow(deprecated)]\n-pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n-    let one: T = Int::one();\n+pub fn cvt<T: One + Neg<Output=T> + PartialEq>(t: T) -> io::Result<T> {\n+    let one: T = T::one();\n     if t == -one {\n         Err(last_error())\n     } else {\n@@ -70,7 +67,9 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n \n /// Provides the functionality of `cvt` for a closure.\n #[allow(deprecated)]\n-pub fn cvt_r<T: SignedInt, F>(mut f: F) -> io::Result<T> where F: FnMut() -> T {\n+pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n+    where F: FnMut() -> T, T: One + Neg<Output=T> + PartialEq\n+{\n     cvt(f())\n }\n "}, {"sha": "5ddcf3d1ea2991f9f62ce90b436b2d6a3510b005", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -140,7 +140,7 @@ impl Process {\n         // read the *child's* PATH if one is provided. See #15149 for more details.\n         let program = cfg.env.as_ref().and_then(|env| {\n             for (key, v) in env {\n-                if OsStr::from_str(\"PATH\") != &**key { continue }\n+                if OsStr::new(\"PATH\") != &**key { continue }\n \n                 // Split the value and test each path to see if the\n                 // program exists.\n@@ -463,7 +463,7 @@ mod tests {\n     fn test_make_command_line() {\n         fn test_wrapper(prog: &str, args: &[&str]) -> String {\n             String::from_utf16(\n-                &make_command_line(OsStr::from_str(prog),\n+                &make_command_line(OsStr::new(prog),\n                                    &args.iter()\n                                         .map(|a| OsString::from(a))\n                                         .collect::<Vec<OsString>>())).unwrap()"}, {"sha": "c65377e238f8fb589fe2d6125970fe050b612dec", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -497,15 +497,6 @@ pub fn sleep_ms(ms: u32) {\n     imp::sleep(Duration::milliseconds(ms as i64))\n }\n \n-/// Deprecated: use `sleep_ms` instead.\n-#[unstable(feature = \"thread_sleep\",\n-           reason = \"recently added, needs an RFC, and `Duration` itself is \\\n-                     unstable\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use sleep_ms instead\")]\n-pub fn sleep(dur: Duration) {\n-    imp::sleep(dur)\n-}\n-\n /// Blocks unless or until the current thread's token is made available (may wake spuriously).\n ///\n /// See the module doc for more detail.\n@@ -546,13 +537,6 @@ pub fn park_timeout_ms(ms: u32) {\n     *guard = false;\n }\n \n-/// Deprecated: use `park_timeout_ms`\n-#[unstable(feature = \"std_misc\", reason = \"recently introduced, depends on Duration\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use park_timeout_ms instead\")]\n-pub fn park_timeout(duration: Duration) {\n-    park_timeout_ms(duration.num_milliseconds() as u32)\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Thread\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "636a0dd697a2bb6003f0a15d87e9f1e2f09bfdd2", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,13 +12,10 @@\n \n #![unstable(feature = \"std_misc\")]\n \n+use prelude::v1::*;\n+\n use {fmt, i64};\n-use ops::{Add, Sub, Mul, Div, Neg, FnOnce};\n-use option::Option;\n-use option::Option::{Some, None};\n-#[allow(deprecated)] // Int\n-use num::Int;\n-use result::Result::Ok;\n+use ops::{Add, Sub, Mul, Div, Neg};\n \n /// The number of nanoseconds in a microsecond.\n const NANOS_PER_MICRO: i32 = 1000;"}, {"sha": "399810cb7f5010ae6d6a4042efadd15bbd347e1e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -66,8 +66,6 @@ use parse::lexer;\n use ptr::P;\n \n use std::fmt;\n-#[allow(deprecated)]\n-use std::num::Int;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -1142,16 +1140,24 @@ pub enum Sign {\n }\n \n impl Sign {\n-    #[allow(deprecated)] // Int\n-    pub fn new<T:Int>(n: T) -> Sign {\n-        if n < Int::zero() {\n-            Minus\n-        } else {\n-            Plus\n-        }\n+    pub fn new<T: IntSign>(n: T) -> Sign {\n+        n.sign()\n     }\n }\n \n+pub trait IntSign {\n+    fn sign(&self) -> Sign;\n+}\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl IntSign for $t {\n+        #[allow(unused_comparisons)]\n+        fn sign(&self) -> Sign {\n+            if *self < 0 {Minus} else {Plus}\n+        }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum LitIntType {\n     SignedIntLit(IntTy, Sign),"}, {"sha": "34ad192845c58e2f94a6f5d150b81b6e3a893452", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -20,7 +20,6 @@\n pub use self::MacroFormat::*;\n \n use std::cell::RefCell;\n-use std::num::ToPrimitive;\n use std::ops::{Add, Sub};\n use std::rc::Rc;\n \n@@ -862,7 +861,11 @@ impl CodeMap {\n     pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n         let mut expansions = self.expansions.borrow_mut();\n         expansions.push(expn_info);\n-        ExpnId(expansions.len().to_u32().expect(\"too many ExpnInfo's!\") - 1)\n+        let len = expansions.len();\n+        if len > u32::max_value() as usize {\n+            panic!(\"too many ExpnInfo's!\");\n+        }\n+        ExpnId(len as u32 - 1)\n     }\n \n     pub fn with_expn_info<T, F>(&self, id: ExpnId, f: F) -> T where"}, {"sha": "1a1713a8ba632fb9fa3d3f99e539525a27266665", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -22,8 +22,6 @@ use std::cell::{Cell, RefCell};\n use std::fs::File;\n use std::io::Read;\n use std::iter;\n-#[allow(deprecated)] // Int\n-use std::num::Int;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::str;"}, {"sha": "b68b1d28b356750787384c625202a81552fd2c26", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -74,7 +74,6 @@ use std::fs::File;\n use std::io::prelude::*;\n use std::io;\n use std::iter::repeat;\n-use std::num::{Float, Int};\n use std::path::PathBuf;\n use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n@@ -412,7 +411,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n \n #[derive(Clone, PartialEq)]\n pub struct BenchSamples {\n-    ns_iter_summ: stats::Summary<f64>,\n+    ns_iter_summ: stats::Summary,\n     mb_s: usize,\n }\n \n@@ -1065,7 +1064,7 @@ impl Bencher {\n     }\n \n     // This is a more statistics-driven benchmark algorithm\n-    pub fn auto_bench<F>(&mut self, mut f: F) -> stats::Summary<f64> where F: FnMut(&mut Bencher) {\n+    pub fn auto_bench<F>(&mut self, mut f: F) -> stats::Summary where F: FnMut(&mut Bencher) {\n         // Initial bench run to get ballpark figure.\n         let mut n = 1;\n         self.bench_n(n, |x| f(x));"}, {"sha": "c1ba1260f67e120fdd058c04f6fbf68fc0f13b4a", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 74, "deletions": 76, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,9 +13,8 @@\n \n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::mem;\n-use std::num::{Float, FromPrimitive};\n \n-fn local_cmp<T:Float>(x: T, y: T) -> Ordering {\n+fn local_cmp(x: f64, y: f64) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n     if y.is_nan() {\n         Less\n@@ -30,37 +29,37 @@ fn local_cmp<T:Float>(x: T, y: T) -> Ordering {\n     }\n }\n \n-fn local_sort<T: Float>(v: &mut [T]) {\n-    v.sort_by(|x: &T, y: &T| local_cmp(*x, *y));\n+fn local_sort(v: &mut [f64]) {\n+    v.sort_by(|x: &f64, y: &f64| local_cmp(*x, *y));\n }\n \n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n-pub trait Stats <T: Float + FromPrimitive> {\n+pub trait Stats {\n \n     /// Sum of the samples.\n     ///\n     /// Note: this method sacrifices performance at the altar of accuracy\n     /// Depends on IEEE-754 arithmetic guarantees. See proof of correctness at:\n     /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\"]\n     /// (http://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps)\n-    fn sum(&self) -> T;\n+    fn sum(&self) -> f64;\n \n     /// Minimum value of the samples.\n-    fn min(&self) -> T;\n+    fn min(&self) -> f64;\n \n     /// Maximum value of the samples.\n-    fn max(&self) -> T;\n+    fn max(&self) -> f64;\n \n     /// Arithmetic mean (average) of the samples: sum divided by sample-count.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Arithmetic_mean\n-    fn mean(&self) -> T;\n+    fn mean(&self) -> f64;\n \n     /// Median of the samples: value separating the lower half of the samples from the higher half.\n     /// Equal to `self.percentile(50.0)`.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Median\n-    fn median(&self) -> T;\n+    fn median(&self) -> f64;\n \n     /// Variance of the samples: bias-corrected mean of the squares of the differences of each\n     /// sample from the sample mean. Note that this calculates the _sample variance_ rather than the\n@@ -69,21 +68,21 @@ pub trait Stats <T: Float + FromPrimitive> {\n     /// than `n`.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Variance\n-    fn var(&self) -> T;\n+    fn var(&self) -> f64;\n \n     /// Standard deviation: the square root of the sample variance.\n     ///\n     /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n     /// `median_abs_dev` for unknown distributions.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Standard_deviation\n-    fn std_dev(&self) -> T;\n+    fn std_dev(&self) -> f64;\n \n     /// Standard deviation as a percent of the mean value. See `std_dev` and `mean`.\n     ///\n     /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n     /// `median_abs_dev_pct` for unknown distributions.\n-    fn std_dev_pct(&self) -> T;\n+    fn std_dev_pct(&self) -> f64;\n \n     /// Scaled median of the absolute deviations of each sample from the sample median. This is a\n     /// robust (distribution-agnostic) estimator of sample variability. Use this in preference to\n@@ -92,10 +91,10 @@ pub trait Stats <T: Float + FromPrimitive> {\n     /// deviation.\n     ///\n     /// See: http://en.wikipedia.org/wiki/Median_absolute_deviation\n-    fn median_abs_dev(&self) -> T;\n+    fn median_abs_dev(&self) -> f64;\n \n     /// Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.\n-    fn median_abs_dev_pct(&self) -> T;\n+    fn median_abs_dev_pct(&self) -> f64;\n \n     /// Percentile: the value below which `pct` percent of the values in `self` fall. For example,\n     /// percentile(95.0) will return the value `v` such that 95% of the samples `s` in `self`\n@@ -104,44 +103,44 @@ pub trait Stats <T: Float + FromPrimitive> {\n     /// Calculated by linear interpolation between closest ranks.\n     ///\n     /// See: http://en.wikipedia.org/wiki/Percentile\n-    fn percentile(&self, pct: T) -> T;\n+    fn percentile(&self, pct: f64) -> f64;\n \n     /// Quartiles of the sample: three values that divide the sample into four equal groups, each\n     /// with 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\n     /// function may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\n     /// is otherwise equivalent.\n     ///\n     /// See also: https://en.wikipedia.org/wiki/Quartile\n-    fn quartiles(&self) -> (T,T,T);\n+    fn quartiles(&self) -> (f64,f64,f64);\n \n     /// Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\n     /// percentile (3rd quartile). See `quartiles`.\n     ///\n     /// See also: https://en.wikipedia.org/wiki/Interquartile_range\n-    fn iqr(&self) -> T;\n+    fn iqr(&self) -> f64;\n }\n \n /// Extracted collection of all the summary statistics of a sample set.\n #[derive(Clone, PartialEq)]\n #[allow(missing_docs)]\n-pub struct Summary<T> {\n-    pub sum: T,\n-    pub min: T,\n-    pub max: T,\n-    pub mean: T,\n-    pub median: T,\n-    pub var: T,\n-    pub std_dev: T,\n-    pub std_dev_pct: T,\n-    pub median_abs_dev: T,\n-    pub median_abs_dev_pct: T,\n-    pub quartiles: (T,T,T),\n-    pub iqr: T,\n+pub struct Summary {\n+    pub sum: f64,\n+    pub min: f64,\n+    pub max: f64,\n+    pub mean: f64,\n+    pub median: f64,\n+    pub var: f64,\n+    pub std_dev: f64,\n+    pub std_dev_pct: f64,\n+    pub median_abs_dev: f64,\n+    pub median_abs_dev_pct: f64,\n+    pub quartiles: (f64,f64,f64),\n+    pub iqr: f64,\n }\n \n-impl<T: Float + FromPrimitive> Summary<T> {\n+impl Summary {\n     /// Construct a new summary of a sample set.\n-    pub fn new(samples: &[T]) -> Summary<T> {\n+    pub fn new(samples: &[f64]) -> Summary {\n         Summary {\n             sum: samples.sum(),\n             min: samples.min(),\n@@ -159,9 +158,9 @@ impl<T: Float + FromPrimitive> Summary<T> {\n     }\n }\n \n-impl<T: Float + FromPrimitive> Stats<T> for [T] {\n+impl Stats for [f64] {\n     // FIXME #11059 handle NaN, inf and overflow\n-    fn sum(&self) -> T {\n+    fn sum(&self) -> f64 {\n         let mut partials = vec![];\n \n         for &x in self {\n@@ -170,15 +169,15 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n             // This inner loop applies `hi`/`lo` summation to each\n             // partial so that the list of partial sums remains exact.\n             for i in 0..partials.len() {\n-                let mut y: T = partials[i];\n+                let mut y: f64 = partials[i];\n                 if x.abs() < y.abs() {\n                     mem::swap(&mut x, &mut y);\n                 }\n                 // Rounded `x+y` is stored in `hi` with round-off stored in\n                 // `lo`. Together `hi+lo` are exactly equal to `x+y`.\n                 let hi = x + y;\n                 let lo = y - (hi - x);\n-                if lo != Float::zero() {\n+                if lo != 0.0 {\n                     partials[j] = lo;\n                     j += 1;\n                 }\n@@ -191,89 +190,89 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n                 partials.truncate(j+1);\n             }\n         }\n-        let zero: T = Float::zero();\n+        let zero: f64 = 0.0;\n         partials.iter().fold(zero, |p, q| p + *q)\n     }\n \n-    fn min(&self) -> T {\n+    fn min(&self) -> f64 {\n         assert!(!self.is_empty());\n         self.iter().fold(self[0], |p, q| p.min(*q))\n     }\n \n-    fn max(&self) -> T {\n+    fn max(&self) -> f64 {\n         assert!(!self.is_empty());\n         self.iter().fold(self[0], |p, q| p.max(*q))\n     }\n \n-    fn mean(&self) -> T {\n+    fn mean(&self) -> f64 {\n         assert!(!self.is_empty());\n-        self.sum() / FromPrimitive::from_usize(self.len()).unwrap()\n+        self.sum() / (self.len() as f64)\n     }\n \n-    fn median(&self) -> T {\n-        self.percentile(FromPrimitive::from_usize(50).unwrap())\n+    fn median(&self) -> f64 {\n+        self.percentile(50 as f64)\n     }\n \n-    fn var(&self) -> T {\n+    fn var(&self) -> f64 {\n         if self.len() < 2 {\n-            Float::zero()\n+            0.0\n         } else {\n             let mean = self.mean();\n-            let mut v: T = Float::zero();\n+            let mut v: f64 = 0.0;\n             for s in self {\n                 let x = *s - mean;\n                 v = v + x*x;\n             }\n             // NB: this is _supposed to be_ len-1, not len. If you\n             // change it back to len, you will be calculating a\n             // population variance, not a sample variance.\n-            let denom = FromPrimitive::from_usize(self.len()-1).unwrap();\n+            let denom = (self.len() - 1) as f64;\n             v/denom\n         }\n     }\n \n-    fn std_dev(&self) -> T {\n+    fn std_dev(&self) -> f64 {\n         self.var().sqrt()\n     }\n \n-    fn std_dev_pct(&self) -> T {\n-        let hundred = FromPrimitive::from_usize(100).unwrap();\n+    fn std_dev_pct(&self) -> f64 {\n+        let hundred = 100 as f64;\n         (self.std_dev() / self.mean()) * hundred\n     }\n \n-    fn median_abs_dev(&self) -> T {\n+    fn median_abs_dev(&self) -> f64 {\n         let med = self.median();\n-        let abs_devs: Vec<T> = self.iter().map(|&v| (med - v).abs()).collect();\n+        let abs_devs: Vec<f64> = self.iter().map(|&v| (med - v).abs()).collect();\n         // This constant is derived by smarter statistics brains than me, but it is\n         // consistent with how R and other packages treat the MAD.\n-        let number = FromPrimitive::from_f64(1.4826).unwrap();\n+        let number = 1.4826;\n         abs_devs.median() * number\n     }\n \n-    fn median_abs_dev_pct(&self) -> T {\n-        let hundred = FromPrimitive::from_usize(100).unwrap();\n+    fn median_abs_dev_pct(&self) -> f64 {\n+        let hundred = 100 as f64;\n         (self.median_abs_dev() / self.median()) * hundred\n     }\n \n-    fn percentile(&self, pct: T) -> T {\n+    fn percentile(&self, pct: f64) -> f64 {\n         let mut tmp = self.to_vec();\n         local_sort(&mut tmp);\n         percentile_of_sorted(&tmp, pct)\n     }\n \n-    fn quartiles(&self) -> (T,T,T) {\n+    fn quartiles(&self) -> (f64,f64,f64) {\n         let mut tmp = self.to_vec();\n         local_sort(&mut tmp);\n-        let first = FromPrimitive::from_usize(25).unwrap();\n+        let first = 25f64;\n         let a = percentile_of_sorted(&tmp, first);\n-        let secound = FromPrimitive::from_usize(50).unwrap();\n+        let secound = 50f64;\n         let b = percentile_of_sorted(&tmp, secound);\n-        let third = FromPrimitive::from_usize(75).unwrap();\n+        let third = 75f64;\n         let c = percentile_of_sorted(&tmp, third);\n         (a,b,c)\n     }\n \n-    fn iqr(&self) -> T {\n+    fn iqr(&self) -> f64 {\n         let (a,_,c) = self.quartiles();\n         c - a\n     }\n@@ -282,41 +281,41 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n \n // Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n // linear interpolation. If samples are not sorted, return nonsensical value.\n-fn percentile_of_sorted<T: Float + FromPrimitive>(sorted_samples: &[T],\n-                                                             pct: T) -> T {\n+fn percentile_of_sorted(sorted_samples: &[f64], pct: f64) -> f64 {\n     assert!(!sorted_samples.is_empty());\n     if sorted_samples.len() == 1 {\n         return sorted_samples[0];\n     }\n-    let zero: T = Float::zero();\n+    let zero: f64 = 0.0;\n     assert!(zero <= pct);\n-    let hundred = FromPrimitive::from_usize(100).unwrap();\n+    let hundred = 100f64;\n     assert!(pct <= hundred);\n     if pct == hundred {\n         return sorted_samples[sorted_samples.len() - 1];\n     }\n-    let length = FromPrimitive::from_usize(sorted_samples.len() - 1).unwrap();\n+    let length = (sorted_samples.len() - 1) as f64;\n     let rank = (pct / hundred) * length;\n     let lrank = rank.floor();\n     let d = rank - lrank;\n-    let n = lrank.to_usize().unwrap();\n+    let n = lrank as usize;\n     let lo = sorted_samples[n];\n     let hi = sorted_samples[n+1];\n     lo + (hi - lo) * d\n }\n \n \n-/// Winsorize a set of samples, replacing values above the `100-pct` percentile and below the `pct`\n-/// percentile with those percentiles themselves. This is a way of minimizing the effect of\n-/// outliers, at the cost of biasing the sample. It differs from trimming in that it does not\n-/// change the number of samples, just changes the values of those that are outliers.\n+/// Winsorize a set of samples, replacing values above the `100-pct` percentile\n+/// and below the `pct` percentile with those percentiles themselves. This is a\n+/// way of minimizing the effect of outliers, at the cost of biasing the sample.\n+/// It differs from trimming in that it does not change the number of samples,\n+/// just changes the values of those that are outliers.\n ///\n /// See: http://en.wikipedia.org/wiki/Winsorising\n-pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n+pub fn winsorize(samples: &mut [f64], pct: f64) {\n     let mut tmp = samples.to_vec();\n     local_sort(&mut tmp);\n     let lo = percentile_of_sorted(&tmp, pct);\n-    let hundred: T = FromPrimitive::from_usize(100).unwrap();\n+    let hundred = 100 as f64;\n     let hi = percentile_of_sorted(&tmp, hundred-pct);\n     for samp in samples {\n         if *samp > hi {\n@@ -339,14 +338,13 @@ mod tests {\n \n     macro_rules! assert_approx_eq {\n         ($a:expr, $b:expr) => ({\n-            use std::num::Float;\n             let (a, b) = (&$a, &$b);\n             assert!((*a - *b).abs() < 1.0e-6,\n                     \"{} is not approximately equal to {}\", *a, *b);\n         })\n     }\n \n-    fn check(samples: &[f64], summ: &Summary<f64>) {\n+    fn check(samples: &[f64], summ: &Summary) {\n \n         let summ2 = Summary::new(samples);\n "}, {"sha": "6472c08c222965b6a6ba1a4e411747d3b26bc0ee", "filename": "src/test/auxiliary/issue_3907.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fissue_3907.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fissue_3907.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3907.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n-\n-pub trait Foo : MarkerTrait {\n+pub trait Foo {\n     fn bar();\n }"}, {"sha": "37ee10c8d37333ec6e64793919ab8a1f504e14ca", "filename": "src/test/auxiliary/private_trait_xc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,6 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n-\n-trait Foo : ::std::marker::MarkerTrait {}\n+trait Foo {}"}, {"sha": "c2ff7a0054f19712bf95d0c3c34c0c5f4cf5d8e8", "filename": "src/test/auxiliary/rustdoc-default-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Frustdoc-default-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Frustdoc-default-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Frustdoc-default-impl.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,7 +14,7 @@\n pub mod bar {\n     use std::marker;\n \n-    pub trait Bar: marker::MarkerTrait + 'static {}\n+    pub trait Bar: 'static {}\n \n     impl Bar for .. {}\n "}, {"sha": "31a97f695f06cdbfcf20cd27edf87cb961020bb0", "filename": "src/test/auxiliary/svh-a-base.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "5339fc8295c6f57f56cfd7820e41cdb3d88be0fc", "filename": "src/test/auxiliary/svh-a-change-lit.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "2a5d9446f879ac65f8d8a4dff31c9616e89c7993", "filename": "src/test/auxiliary/svh-a-change-significant-cfg.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "61f2f2803ab1891dc586ab781cea0158d513b8ed", "filename": "src/test/auxiliary/svh-a-change-trait-bound.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "270ce95be2bb62d70a0366920373362fb5a8e2ae", "filename": "src/test/auxiliary/svh-a-change-type-arg.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "de4cc85a7dc4746bc238bbf344b797eb212de426", "filename": "src/test/auxiliary/svh-a-change-type-ret.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "62f7986f1c3bd729b67c8f50677d01395f20914e", "filename": "src/test/auxiliary/svh-a-change-type-static.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -16,14 +16,12 @@\n #![crate_name = \"a\"]\n #![feature(core)]\n \n-use std::marker::MarkerTrait;\n-\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "22e40822eecfc8b52055dbeece2d9b99e58e88e4", "filename": "src/test/auxiliary/svh-a-comment.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "3d8a728967a4a64bcc274b11818dedc1690d5a2f", "filename": "src/test/auxiliary/svh-a-doc.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "41d7eb7b18645f3ee181fee3406ec62aaea899fd", "filename": "src/test/auxiliary/svh-a-macro.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "31a97f695f06cdbfcf20cd27edf87cb961020bb0", "filename": "src/test/auxiliary/svh-a-no-change.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "e405c337abe4aeb7ef7214625a275c5fc4931b75", "filename": "src/test/auxiliary/svh-a-redundant-cfg.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "9ef788c98427392bfa95bf1156149d7df9a99232", "filename": "src/test/auxiliary/svh-a-whitespace.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "c3ecbb014dc6b0aac1dfa9e077383a15e86b79cd", "filename": "src/test/auxiliary/trait_impl_conflict.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Ftrait_impl_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Ftrait_impl_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_impl_conflict.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n-\n-pub trait Foo : ::std::marker::MarkerTrait {\n+pub trait Foo {\n }\n \n impl Foo for isize {"}, {"sha": "2e425ac96c55f9de510c0358e93105c48424d3ba", "filename": "src/test/auxiliary/typeck_default_trait_impl_cross_crate_coherence_lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Ftypeck_default_trait_impl_cross_crate_coherence_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fauxiliary%2Ftypeck_default_trait_impl_cross_crate_coherence_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeck_default_trait_impl_cross_crate_coherence_lib.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -11,9 +11,7 @@\n #![feature(optin_builtin_traits, core)]\n #![crate_type = \"rlib\"]\n \n-use std::marker::MarkerTrait;\n-\n-pub trait DefaultedTrait : MarkerTrait { }\n+pub trait DefaultedTrait { }\n impl DefaultedTrait for .. { }\n \n pub struct Something<T> { t: T }"}, {"sha": "efbb5dfb5491ebe855be1249909590a2031c055a", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,7 +14,6 @@\n #![feature(rand, core)]\n \n use std::f32::consts::PI;\n-use std::num::Float;\n use std::__rand::{Rng, thread_rng};\n \n #[derive(Copy, Clone)]"}, {"sha": "c576eea3602cb6b95669ac88c29ba6564d4f92c2", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -109,8 +109,7 @@ fn main() {\n     let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n \n     let messages = (min_depth..max_depth + 1).step_by(2).map(|depth| {\n-        use std::num::Int;\n-        let iterations = 2.pow((max_depth - depth + min_depth) as u32);\n+        let iterations = 2i32.pow((max_depth - depth + min_depth) as u32);\n         thread::spawn(move || inner(depth, iterations))\n     }).collect::<Vec<_>>();\n "}, {"sha": "accf525b4e6386ffe1e97faf4ea3189dd2c6f405", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -43,7 +43,6 @@ use std::env;\n use std::fs::File;\n use std::io::{self, BufWriter};\n use std::io::prelude::*;\n-use std::num::Float;\n \n const LINE_LENGTH: usize = 60;\n const IM: u32 = 139968;"}, {"sha": "368dbbb931c269e5b48e8041526b7c7ada882873", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -38,9 +38,7 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(core)]\n-\n-use std::num::Float;\n+use std::mem;\n \n const PI: f64 = 3.141592653589793;\n const SOLAR_MASS: f64 = 4.0 * PI * PI;\n@@ -193,16 +191,9 @@ fn main() {\n /// longer contain the mutable reference. This is a safe operation because the\n /// two mutable borrows are entirely disjoint.\n fn shift_mut_ref<'a, T>(r: &mut &'a mut [T]) -> Option<&'a mut T> {\n-    use std::mem;\n-    use std::raw::Repr;\n-\n-    if r.is_empty() { return None }\n-    unsafe {\n-        let mut raw = r.repr();\n-        let ret = raw.data as *mut T;\n-        raw.data = raw.data.offset(1);\n-        raw.len -= 1;\n-        *r = mem::transmute(raw);\n-        Some({ &mut *ret })\n-    }\n+    let res = mem::replace(r, &mut []);\n+    if res.is_empty() { return None }\n+    let (a, b) = res.split_at_mut(1);\n+    *r = b;\n+    Some(&mut a[0])\n }"}, {"sha": "0fa22abde3cbd9ee695ec1b392bd9aa6d415b9c1", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -46,7 +46,6 @@\n use std::iter::repeat;\n use std::thread;\n use std::mem;\n-use std::num::Float;\n use std::os;\n use std::env;\n use std::raw::Repr;"}, {"sha": "16742f0a6e1a56f5ad2520beaeb591ffd597cb1b", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -16,7 +16,6 @@\n use std::io::prelude::*;\n use std::io;\n use std::iter::repeat;\n-use std::num::Int;\n use std::env;\n \n // Computes a single solution to a given 9x9 sudoku"}, {"sha": "1f9dfdb18470b3718b97289e62345b762f748e65", "filename": "src/test/compile-fail/associated-types-eq-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,7 +10,7 @@\n \n // Check that an associated type cannot be bound in an expression path.\n \n-trait Foo : ::std::marker::MarkerTrait {\n+trait Foo {\n     type A;\n     fn bar() -> isize;\n }"}, {"sha": "82258f124d3233da297edae2e9447118e814e45a", "filename": "src/test/compile-fail/associated-types-issue-17359.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -11,7 +11,7 @@\n // Test that we do not ICE when an impl is missing an associated type (and that we report\n // a useful error, of course).\n \n-trait Trait : ::std::marker::MarkerTrait {\n+trait Trait {\n     type Type;\n }\n "}, {"sha": "9436f825de89dd4b95a51cc7e6f7ce4ad320bcdd", "filename": "src/test/compile-fail/associated-types-multiple-types-one-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fassociated-types-multiple-types-one-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fassociated-types-multiple-types-one-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-multiple-types-one-trait.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo : ::std::marker::MarkerTrait {\n+trait Foo {\n     type X;\n     type Y;\n }"}, {"sha": "bda16c8a85de15d03c00c2470688bb3cb34b158a", "filename": "src/test/compile-fail/associated-types-no-suitable-supertrait-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait-2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -19,7 +19,7 @@\n // which checks that the trait interface itself is not considered an\n // error as long as all impls satisfy the constraint.\n \n-trait Get : ::std::marker::MarkerTrait {\n+trait Get {\n     type Value;\n }\n "}, {"sha": "233532a6085803400c5ae04f9edbf1d70b4f94a9", "filename": "src/test/compile-fail/associated-types-no-suitable-supertrait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -19,7 +19,7 @@\n // which checks that the trait interface itself is not considered an\n // error as long as all impls satisfy the constraint.\n \n-trait Get : ::std::marker::MarkerTrait {\n+trait Get {\n     type Value;\n }\n "}, {"sha": "aecbf217a5b25e916155829b81188bf7401049ac", "filename": "src/test/compile-fail/associated-types-unconstrained.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,7 +10,7 @@\n \n // Check that an associated type cannot be bound in an expression path.\n \n-trait Foo : ::std::marker::MarkerTrait {\n+trait Foo {\n     type A;\n     fn bar() -> isize;\n }"}, {"sha": "fca74e457c21e17be2a9889919730ee6926c32d4", "filename": "src/test/compile-fail/bad-sized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,7 +10,7 @@\n \n use std::cell::RefCell;\n \n-trait Trait : ::std::marker::MarkerTrait {}\n+trait Trait {}\n \n pub fn main() {\n     let x: Vec<Trait + Sized> = Vec::new();"}, {"sha": "b771b959d3e507ef1cf5001777109b9f1cef7e94", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-blanket-implemented.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,7 +10,6 @@\n \n use std::fmt::Debug;\n use std::default::Default;\n-use std::marker::MarkerTrait;\n \n // Test that two blanket impls conflict (at least without negative\n // bounds).  After all, some other crate could implement Even or Odd\n@@ -20,9 +19,9 @@ trait MyTrait {\n     fn get(&self) -> usize;\n }\n \n-trait Even : MarkerTrait { }\n+trait Even { }\n \n-trait Odd : MarkerTrait { }\n+trait Odd { }\n \n impl Even for isize { }\n "}, {"sha": "d3b0e7f10b91bc815a32a1f21384bc2bfd9fd5e9", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-blanket-unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -19,9 +19,9 @@ trait MyTrait {\n     fn get(&self) -> usize;\n }\n \n-trait Even : ::std::marker::MarkerTrait { }\n+trait Even {}\n \n-trait Odd : ::std::marker::MarkerTrait { }\n+trait Odd {}\n \n impl<T:Even> MyTrait for T { //~ ERROR E0119\n     fn get(&self) -> usize { 0 }"}, {"sha": "55c9ba2a0e89aeda6cfb43ea13f0bdd4e8ba049f", "filename": "src/test/compile-fail/coherence-conflicting-negative-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(optin_builtin_traits)]\n \n-trait MyTrait : ::std::marker::MarkerTrait {}\n+trait MyTrait {}\n \n struct TestType<T>(::std::marker::PhantomData<T>);\n "}, {"sha": "cccc8b05b3038b8ae719f192badcb5906edc43b5", "filename": "src/test/compile-fail/coherence-default-trait-impl.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,21 +10,19 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-trait MyTrait: MarkerTrait {}\n+trait MyTrait {}\n \n impl MyTrait for .. {}\n \n impl MyTrait for .. {}\n //~^ ERROR conflicting implementations for trait `MyTrait`\n \n-trait MySafeTrait: MarkerTrait {}\n+trait MySafeTrait {}\n \n unsafe impl MySafeTrait for .. {}\n //~^ ERROR implementing the trait `MySafeTrait` is not unsafe\n \n-unsafe trait MyUnsafeTrait: MarkerTrait {}\n+unsafe trait MyUnsafeTrait {}\n \n impl MyUnsafeTrait for .. {}\n //~^ ERROR the trait `MyUnsafeTrait` requires an `unsafe impl` declaration"}, {"sha": "a6b62d17bc4e6aa9ac34540d80911fa8b0865294", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct_tuple.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -17,11 +17,9 @@\n \n extern crate coherence_copy_like_lib as lib;\n \n-use std::marker::MarkerTrait;\n-\n struct MyType { x: i32 }\n \n-trait MyTrait : MarkerTrait { }\n+trait MyTrait { }\n \n impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n "}, {"sha": "5a9f440f8bb6a98900bb406b1976d6a056232c1b", "filename": "src/test/compile-fail/coherence_copy_like_err_struct.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -15,11 +15,9 @@\n \n extern crate coherence_copy_like_lib as lib;\n \n-use std::marker::MarkerTrait;\n-\n struct MyType { x: i32 }\n \n-trait MyTrait : MarkerTrait { }\n+trait MyTrait { }\n impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n \n // `MyStruct` is not declared fundamental, therefore this would"}, {"sha": "ee0d5550fd61f0ea8e514bec49a723935cf31ac6", "filename": "src/test/compile-fail/coherence_copy_like_err_tuple.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -15,11 +15,9 @@\n \n extern crate coherence_copy_like_lib as lib;\n \n-use std::marker::MarkerTrait;\n-\n struct MyType { x: i32 }\n \n-trait MyTrait : MarkerTrait { }\n+trait MyTrait { }\n impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n \n // Tuples are not fundamental, therefore this would require that"}, {"sha": "160197368d6d983c673f924eb1508fbd62e1a3b1", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -15,7 +15,7 @@ struct Fat<T: ?Sized> {\n }\n \n struct Foo;\n-trait Bar : ::std::marker::MarkerTrait {}\n+trait Bar {}\n impl Bar for Foo {}\n \n pub fn main() {"}, {"sha": "b30eada162b84707134573888de917956f8ca50c", "filename": "src/test/compile-fail/dst-bad-coercions.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,10 +10,8 @@\n \n // Test implicit coercions involving DSTs and raw pointers.\n \n-use std::marker::MarkerTrait;\n-\n struct S;\n-trait T : MarkerTrait {}\n+trait T {}\n impl T for S {}\n \n struct Foo<T: ?Sized> {"}, {"sha": "e116966670d2b7bda22c03def4a8c3f930e065f3", "filename": "src/test/compile-fail/implicit-method-bind.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fimplicit-method-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fimplicit-method-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimplicit-method-bind.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num::SignedInt;\n-\n fn main() {\n-    let _f = 10.abs; //~ ERROR attempted to take value of method\n+    let _f = 10i32.abs; //~ ERROR attempted to take value of method\n }"}, {"sha": "251da2c6b3ee979c020bf7e21c55d490c5a4dadd", "filename": "src/test/compile-fail/issue-13853.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-trait Node : MarkerTrait {\n+trait Node {\n     fn zomg();\n }\n "}, {"sha": "51deb99a4f2cda7747feae6e2df16f83c0f80e9e", "filename": "src/test/compile-fail/issue-14853.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n use std::fmt::Debug;\n-use std::marker::MarkerTrait;\n \n-trait Str : MarkerTrait {}\n+trait Str {}\n \n trait Something {\n     fn yay<T: Debug>(_: Option<Self>, thing: &[T]);"}, {"sha": "a3529c9ea90b671d21d9274c51166f826da4aa34", "filename": "src/test/compile-fail/issue-16747.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-trait ListItem<'a> : MarkerTrait {\n+trait ListItem<'a> {\n     fn list_name() -> &'a str;\n }\n "}, {"sha": "6300a1dc15d6015cec6aea8b0c34743a529f13f4", "filename": "src/test/compile-fail/issue-18107.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-18107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-18107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18107.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-pub trait AbstractRenderer : MarkerTrait {}\n+pub trait AbstractRenderer {}\n \n fn _create_render(_: &()) ->\n     AbstractRenderer"}, {"sha": "41be78dd7b96eede5f0c9aa46bf702cad8fe9ca1", "filename": "src/test/compile-fail/issue-18389.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,14 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures)]\n-\n use std::any::Any;\n use std::any::TypeId;\n-use std::marker::MarkerTrait;\n \n-pub trait Pt : MarkerTrait {}\n-pub trait Rt : MarkerTrait {}\n+pub trait Pt {}\n+pub trait Rt {}\n \n trait Private<P: Pt, R: Rt> {\n     fn call(&self, p: P, r: R);"}, {"sha": "a662e9ca98ee812086e338e874234fd0a00a1f91", "filename": "src/test/compile-fail/issue-18611.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-18611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-18611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18611.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n fn add_state(op: <isize as HasState>::State) {\n //~^ ERROR the trait `HasState` is not implemented for the type `isize`\n }\n \n-trait HasState : MarkerTrait {\n+trait HasState {\n     type State;\n }\n "}, {"sha": "d89b2c6ce8cb0221e9a64a922e4e8f683909da57", "filename": "src/test/compile-fail/issue-18819.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {\n+trait Foo {\n     type Item;\n }\n "}, {"sha": "20bd8af7c3ef5ecf3e18cee657cfdc24276765e3", "filename": "src/test/compile-fail/issue-2063.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,11 +12,9 @@\n // cause compiler to loop.  Note that no instances\n // of such a type could ever be constructed.\n \n-use std::marker::MarkerTrait;\n-\n struct t(Box<t>); //~ ERROR this type cannot be instantiated\n \n-trait to_str_2 : MarkerTrait {\n+trait to_str_2 {\n     fn my_to_string() -> String;\n }\n "}, {"sha": "a38278eae2411f1c92871586e0d33d907f51faab", "filename": "src/test/compile-fail/issue-20831-debruijn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,10 +14,9 @@\n // away.\n \n use std::cell::RefCell;\n-use std::marker::MarkerTrait;\n use std::ops::{Shl, Shr};\n \n-pub trait Subscriber : MarkerTrait {\n+pub trait Subscriber {\n     type Input;\n }\n "}, {"sha": "b77230a8b340d1dfb145b608b7c034409b9eeec3", "filename": "src/test/compile-fail/issue-23080-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-23080-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-23080-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23080-2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,9 +12,7 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-unsafe trait Trait: MarkerTrait {\n+unsafe trait Trait {\n //~^ error: traits with default impls (`e.g. unsafe impl Trait for ..`) must have no methods or associated items\n     type Output;\n }"}, {"sha": "026ee89c0b2b5a4dd940e0ec690a6412891516aa", "filename": "src/test/compile-fail/issue-3702-2.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-3702-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-3702-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3702-2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,7 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num::ToPrimitive;\n+pub trait ToPrimitive {\n+    fn to_int(&self) -> isize { 0 }\n+}\n+\n+impl ToPrimitive for i32 {}\n+impl ToPrimitive for isize {}\n \n trait Add {\n     fn to_int(&self) -> isize;"}, {"sha": "9e324cdd61eb0e82f40308131b51c72d1d1ce360", "filename": "src/test/compile-fail/issue-5035-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-trait I : MarkerTrait {}\n+trait I {}\n type K = I+'static;\n \n fn foo(_x: K) {} //~ ERROR: the trait `core::marker::Sized` is not implemented"}, {"sha": "9ff957b6e6deac4904d0d5066390bd4dd53e2803", "filename": "src/test/compile-fail/issue-5883.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-trait A : MarkerTrait {}\n+trait A {}\n \n struct Struct {\n     r: A+'static\n@@ -22,6 +20,6 @@ fn new_struct(r: A+'static)\n     Struct { r: r }\n }\n \n-trait Curve : MarkerTrait {}\n+trait Curve {}\n enum E {X(Curve+'static)}\n fn main() {}"}, {"sha": "6b320f400a8091dcc9e8f5e31c1f7a26d009fe39", "filename": "src/test/compile-fail/issue-7575.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,14 +10,12 @@\n \n // Test the mechanism for warning about possible missing `self` declarations.\n \n-use std::marker::MarkerTrait;\n-\n trait CtxtFn {\n     fn f8(self, usize) -> usize;\n     fn f9(usize) -> usize; //~ NOTE candidate\n }\n \n-trait OtherTrait : MarkerTrait {\n+trait OtherTrait {\n     fn f9(usize) -> usize; //~ NOTE candidate\n }\n \n@@ -26,7 +24,7 @@ trait OtherTrait : MarkerTrait {\n // declaration to match against, so we wind up prisizeing it as a\n // candidate. This seems not unreasonable -- perhaps the user meant to\n // implement it, after all.\n-trait UnusedTrait : MarkerTrait {\n+trait UnusedTrait {\n     fn f9(usize) -> usize; //~ NOTE candidate\n }\n \n@@ -54,7 +52,7 @@ impl Myisize {\n     }\n }\n \n-trait ManyImplTrait : MarkerTrait {\n+trait ManyImplTrait {\n     fn is_str() -> bool { //~ NOTE candidate\n         false\n     }"}, {"sha": "d43ddff6b9500af1b7a8d0abcd056e7f9c418945", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,12 +10,11 @@\n \n // Test which of the builtin types are considered POD.\n \n-use std::marker::MarkerTrait;\n use std::rc::Rc;\n \n fn assert_copy<T:Copy>() { }\n \n-trait Dummy : MarkerTrait { }\n+trait Dummy { }\n \n #[derive(Copy, Clone)]\n struct MyStruct {"}, {"sha": "66297d70ef505cccb7e3f7f9f7c0a1dfa22bad8a", "filename": "src/test/compile-fail/kindck-impl-type-params-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,9 +10,7 @@\n \n #![feature(box_syntax)]\n \n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {\n+trait Foo {\n }\n \n impl<T:Copy> Foo for T {"}, {"sha": "570f7ad7fe3bf214adae00a7ac6644053305dd6c", "filename": "src/test/compile-fail/kindck-send-object.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,10 +12,8 @@\n // in this file all test the \"kind\" violates detected during kindck.\n // See all `regions-bounded-by-send.rs`\n \n-use std::marker::MarkerTrait;\n-\n fn assert_send<T:Send>() { }\n-trait Dummy : MarkerTrait { }\n+trait Dummy { }\n trait Message : Send { }\n \n // careful with object types, who knows what they close over..."}, {"sha": "48d5215b7085be78f389d72df0139f2efa25130e", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,10 +12,8 @@\n // is broken into two parts because some errors occur in distinct\n // phases in the compiler. See kindck-send-object2.rs as well!\n \n-use std::marker::MarkerTrait;\n-\n fn assert_send<T:Send+'static>() { }\n-trait Dummy : MarkerTrait { }\n+trait Dummy { }\n \n // careful with object types, who knows what they close over...\n fn test51<'a>() {"}, {"sha": "d3d166e2a6916181d24c32984ed212bca92a07e6", "filename": "src/test/compile-fail/kindck-send-object2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,10 +10,8 @@\n \n // Continue kindck-send-object1.rs.\n \n-use std::marker::MarkerTrait;\n-\n fn assert_send<T:Send>() { }\n-trait Dummy : MarkerTrait { }\n+trait Dummy { }\n \n fn test50() {\n     assert_send::<&'static Dummy>(); //~ ERROR the trait `core::marker::Sync` is not implemented"}, {"sha": "c6dc3b70bef37d881f3e12196ecb84b493cc0045", "filename": "src/test/compile-fail/lint-visible-private-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -105,7 +105,7 @@ impl PrivTrait for (Private<isize>,) {\n     fn bar(&self) -> Private<isize> { panic!() }\n }\n \n-pub trait ParamTrait<T> : marker::MarkerTrait {\n+pub trait ParamTrait<T> {\n     fn foo() -> T;\n }\n "}, {"sha": "efbf3782f9796a4b34ed979e293f60837032e67e", "filename": "src/test/compile-fail/object-does-not-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -11,9 +11,7 @@\n // Test that an object type `Box<Foo>` is not considered to implement the\n // trait `Foo`. Issue #5087.\n \n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {}\n+trait Foo {}\n fn take_foo<F:Foo>(f: F) {}\n fn take_object(f: Box<Foo>) { take_foo(f); }\n //~^ ERROR the trait `Foo` is not implemented"}, {"sha": "6a010d49692d26450a4d95225eb3695c4509b0cd", "filename": "src/test/compile-fail/object-safety-no-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -11,7 +11,7 @@\n // Check that we correctly prevent users from making trait objects\n // from traits with static methods.\n \n-trait Foo : ::std::marker::MarkerTrait {\n+trait Foo {\n     fn foo();\n }\n "}, {"sha": "071b4db40f86f5c7a60a4869093715f993a6d90f", "filename": "src/test/compile-fail/phantom-oibit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fphantom-oibit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fphantom-oibit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fphantom-oibit.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,9 +14,9 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::{MarkerTrait, PhantomData};\n+use std::marker::{PhantomData};\n \n-unsafe trait Zen: MarkerTrait {}\n+unsafe trait Zen {}\n \n unsafe impl Zen for .. {}\n "}, {"sha": "7fe0574ab7d9a663902dd9433fcc6a01145f3b4c", "filename": "src/test/compile-fail/privacy-ns2.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -17,9 +17,7 @@\n \n // public type, private value\n pub mod foo1 {\n-    use std::marker::MarkerTrait;\n-\n-    pub trait Bar : MarkerTrait {\n+    pub trait Bar {\n     }\n     pub struct Baz;\n \n@@ -41,7 +39,7 @@ fn test_list1() {\n \n // private type, public value\n pub mod foo2 {\n-    trait Bar : ::std::marker::MarkerTrait {\n+    trait Bar {\n     }\n     pub struct Baz;\n \n@@ -62,7 +60,7 @@ fn test_list2() {\n \n // neither public\n pub mod foo3 {\n-    trait Bar : ::std::marker::MarkerTrait {\n+    trait Bar {\n     }\n     pub struct Baz;\n "}, {"sha": "f95ee405895a9c78cd286b54e98e09ea255d2fc5", "filename": "src/test/compile-fail/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -11,7 +11,7 @@\n // Test that attempts to implicitly coerce a value into an\n // object respect the lifetime bound on the object type.\n \n-trait Foo : ::std::marker::MarkerTrait {}\n+trait Foo {}\n impl<'a> Foo for &'a [u8] {}\n \n // FIXME (#22405): Replace `Box::new` with `box` here when/if possible."}, {"sha": "fdc97ecaf21e271949bed51a125266d3cefb9781", "filename": "src/test/compile-fail/regions-close-associated-type-into-object.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,9 +12,7 @@\n \n // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n \n-use std::marker::MarkerTrait;\n-\n-trait X : MarkerTrait {}\n+trait X {}\n \n trait Iter {\n     type Item: X;"}, {"sha": "25b8137d29cade512868ecfdaa54e2a228611ea8", "filename": "src/test/compile-fail/regions-close-over-borrowed-ref-in-obj.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fregions-close-over-borrowed-ref-in-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Fregions-close-over-borrowed-ref-in-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-borrowed-ref-in-obj.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,9 +10,7 @@\n \n #![feature(box_syntax)]\n \n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait { }\n+trait Foo { }\n \n impl<'a> Foo for &'a isize { }\n "}, {"sha": "b864e6ca9578b7878d0b62a1bb6d7279a3173ad3", "filename": "src/test/compile-fail/trait-as-struct-constructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait TraitNotAStruct : ::std::marker::MarkerTrait { }\n+trait TraitNotAStruct {}\n \n fn main() {\n     TraitNotAStruct{ value: 0 };"}, {"sha": "c18c5b386e8b21816be1abd6ff4e38818ea86978", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-trait Trait : MarkerTrait {}\n+trait Trait {}\n \n struct Foo<T:Trait> {\n     x: T,"}, {"sha": "0a36fcbed690513e6137d88b715b87db25dd8de6", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,9 +10,7 @@\n \n // Tests for \"default\" bounds inferred for traits with no bounds list.\n \n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {}\n+trait Foo {}\n \n fn a(_x: Box<Foo+Send>) {\n }"}, {"sha": "dadcbd5bce710291c706ad4a4209374352549d1b", "filename": "src/test/compile-fail/trait-impl-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,9 +12,7 @@\n // trait impl is only applied to a trait object, not concrete types which implement\n // the trait.\n \n-use std::marker::MarkerTrait;\n-\n-trait T : MarkerTrait {}\n+trait T {}\n \n impl<'a> T+'a {\n     fn foo(&self) {}"}, {"sha": "155b835bbc6e0704d4e24657cb40398c6d7f7615", "filename": "src/test/compile-fail/type-params-in-different-spaces-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num::Int;\n+use std::ops::Add;\n \n-trait BrokenAdd: Int {\n+trait BrokenAdd: Copy + Add<Output=Self> {\n     fn broken_add<T>(&self, rhs: T) -> Self {\n         *self + rhs //~  ERROR mismatched types\n                     //~| expected `Self`\n@@ -20,7 +20,7 @@ trait BrokenAdd: Int {\n     }\n }\n \n-impl<T: Int> BrokenAdd for T {}\n+impl<T: Copy + Add<Output=T>> BrokenAdd for T {}\n \n pub fn main() {\n     let foo: u8 = 0;"}, {"sha": "a27f7f7ebbe0f4b405d5d701bbb8309bd9de464f", "filename": "src/test/compile-fail/typeck-default-trait-impl-constituent-types-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types-2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,9 +10,7 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-trait MyTrait: MarkerTrait {}\n+trait MyTrait {}\n \n impl MyTrait for .. {}\n "}, {"sha": "24819bb4f08d63a51f7db7752df8bfbdf14766f3", "filename": "src/test/compile-fail/typeck-default-trait-impl-constituent-types.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,9 +10,7 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-trait MyTrait: MarkerTrait {}\n+trait MyTrait {}\n \n impl MyTrait for .. {}\n impl<T> !MyTrait for *mut T {}"}, {"sha": "4b91d0b7a736c6f1c1f5d4b692c23fa854333894", "filename": "src/test/compile-fail/typeck-default-trait-impl-negation.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,13 +10,11 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-trait MyTrait: MarkerTrait {}\n+trait MyTrait {}\n \n impl MyTrait for .. {}\n \n-unsafe trait MyUnsafeTrait: MarkerTrait {}\n+unsafe trait MyUnsafeTrait {}\n \n unsafe impl MyUnsafeTrait for .. {}\n "}, {"sha": "c67fc92313c3a58d29e714db80e0b8003cb55419", "filename": "src/test/compile-fail/typeck-default-trait-impl-precedence.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-precedence.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -15,15 +15,13 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-trait Defaulted : MarkerTrait { }\n+trait Defaulted { }\n impl Defaulted for .. { }\n impl<'a,T:Signed> Defaulted for &'a T { }\n impl<'a,T:Signed> Defaulted for &'a mut T { }\n fn is_defaulted<T:Defaulted>() { }\n \n-trait Signed : MarkerTrait { }\n+trait Signed { }\n impl Signed for i32 { }\n \n fn main() {"}, {"sha": "aa918119fbceef87840dcd9cb859562c23a51442", "filename": "src/test/compile-fail/typeck-default-trait-impl-superregion.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-superregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-superregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-superregion.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,8 +13,6 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n trait MyTrait : 'static {}\n \n impl MyTrait for .. {}"}, {"sha": "c9bfdff6c0e495cd78a089e0d4b2d96fcc2fe421", "filename": "src/test/compile-fail/typeck-default-trait-impl-supertrait.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-supertrait.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,9 +13,7 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-trait NotImplemented: MarkerTrait { }\n+trait NotImplemented { }\n \n trait MyTrait : NotImplemented {}\n "}, {"sha": "4f572e87639f051208ba7efa78d14a961e8e35ab", "filename": "src/test/compile-fail/typeck-default-trait-impl-trait-where-clause.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -15,11 +15,9 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n+trait NotImplemented { }\n \n-trait NotImplemented: MarkerTrait { }\n-\n-trait MyTrait: MarkerTrait\n+trait MyTrait\n     where Option<Self> : NotImplemented\n {}\n "}, {"sha": "3f18f359d306e711ee4be2c654e0382d38a8d8c7", "filename": "src/test/compile-fail/unsized6.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized6.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,9 +10,7 @@\n \n // Test `?Sized` local variables.\n \n-use std::marker;\n-\n-trait T : marker::MarkerTrait { }\n+trait T {}\n \n fn f1<X: ?Sized>(x: &X) {\n     let _: X; // <-- this is OK, no bindings created, no initializer."}, {"sha": "0245a1b5cf2c8628e39abbf80b87c47d5c868b88", "filename": "src/test/compile-fail/unsized7.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized7.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,9 +10,7 @@\n \n // Test sized-ness checking in substitution in impls.\n \n-use std::marker::MarkerTrait;\n-\n-trait T : MarkerTrait {}\n+trait T {}\n \n // I would like these to fail eventually.\n // impl - bounded"}, {"sha": "a5246b9300c91ad2f1f4149e0d732ad6b19634c5", "filename": "src/test/pretty/default-trait-impl.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fpretty%2Fdefault-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Fpretty%2Fdefault-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdefault-trait-impl.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(optin_builtin_traits, core)]\n+#![feature(optin_builtin_traits)]\n \n // pp-exact\n \n-use std::marker::MarkerTrait;\n-\n-trait MyTrait: MarkerTrait { }\n+trait MyTrait { }\n \n impl MyTrait for .. { }\n "}, {"sha": "4d75e58aad938a05cb65590936ea8f9636c78e7c", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -25,8 +25,6 @@ use sub::sub2 as msalias;\n use sub::sub2;\n use sub::sub2::nested_struct as sub_struct;\n use std::num::One;\n-use std::num::cast;\n-use std::num::{from_int,from_i8,from_i32};\n \n use std::mem::size_of;\n \n@@ -42,7 +40,6 @@ fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n \n     // import tests\n     fn foo(x: &One) {}\n-    let _: Option<u8> = from_i32(45);\n \n     let x = 42;\n "}, {"sha": "2617a05fe24141e42a33e7aa438fff4e5a7807b1", "filename": "src/test/run-pass/associated-types-basic.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,12 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {\n+trait Foo {\n     type T;\n }\n "}, {"sha": "c93a0b76a95600c31ec10a6a7be9089f6f5de019", "filename": "src/test/run-pass/associated-types-issue-20371.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fassociated-types-issue-20371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fassociated-types-issue-20371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-issue-20371.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,10 +13,6 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n-\n impl X for f64 { type Y = isize; }\n-trait X : MarkerTrait { type Y; }\n+trait X { type Y; }\n fn main() {}"}, {"sha": "83f0d360e6122cd7b6f5572ecb8af8c1267efa01", "filename": "src/test/run-pass/associated-types-nested-projections.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fassociated-types-nested-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fassociated-types-nested-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-nested-projections.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -14,10 +14,9 @@\n \n #![feature(core)]\n \n-use std::marker::MarkerTrait;\n use std::slice;\n \n-trait Bound : MarkerTrait {}\n+trait Bound {}\n \n impl<'a> Bound for &'a i32 {}\n "}, {"sha": "7e2d1aa23149dea229d017bbac6c56951b5bc58a", "filename": "src/test/run-pass/associated-types-normalize-in-bounds-binding.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,12 +13,9 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n #![allow(dead_code)]\n \n-use std::marker::MarkerTrait;\n-\n-pub trait Integral : MarkerTrait {\n+pub trait Integral {\n     type Opposite;\n }\n "}, {"sha": "1830b41d0b50681ee7a986b259ae0ca1d7e4655a", "filename": "src/test/run-pass/associated-types-project-from-type-param-via-bound-in-where-clause.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,17 +12,14 @@\n // `Item` originates in a where-clause, not the declaration of\n // `T`. Issue #20300.\n \n-\n-#![feature(core)]\n-\n-use std::marker::{MarkerTrait, PhantomData};\n+use std::marker::{PhantomData};\n use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n use std::sync::atomic::Ordering::SeqCst;\n \n static COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n \n // Preamble.\n-trait Trait : MarkerTrait { type Item; }\n+trait Trait { type Item; }\n struct Struct;\n impl Trait for Struct {\n     type Item = u32;"}, {"sha": "a29953bea887bbb0869515b499ac1347c673639c", "filename": "src/test/run-pass/const-binops.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-binops.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -11,7 +11,6 @@\n \n macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({\n-        use std::num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);"}, {"sha": "0234d7b0b6376e06fa6d4982a597ee0ee8d5fb5a", "filename": "src/test/run-pass/derive-no-std.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fderive-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fderive-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderive-no-std.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -31,7 +31,6 @@ enum Bar {\n     Quux(u32),\n }\n \n-#[derive(FromPrimitive)]\n enum Baz { A=0, B=5, }\n \n fn main() {"}, {"sha": "4399d741cad1e104096c0b32851df7cde3005ca9", "filename": "src/test/run-pass/deriving-primitive.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/98e9765d973d46faa5c80fb37a48040ca9e87b28/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e9765d973d46faa5c80fb37a48040ca9e87b28/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs?ref=98e9765d973d46faa5c80fb37a48040ca9e87b28", "patch": "@@ -1,39 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(core)]\n-\n-use std::num::FromPrimitive;\n-use std::isize;\n-\n-#[derive(PartialEq, FromPrimitive, Debug)]\n-enum A {\n-    Foo = isize::MAX,\n-    Bar = 1,\n-    Baz = 3,\n-    Qux,\n-}\n-\n-pub fn main() {\n-    let x: Option<A> = FromPrimitive::from_int(isize::MAX);\n-    assert_eq!(x, Some(A::Foo));\n-\n-    let x: Option<A> = FromPrimitive::from_int(1);\n-    assert_eq!(x, Some(A::Bar));\n-\n-    let x: Option<A> = FromPrimitive::from_int(3);\n-    assert_eq!(x, Some(A::Baz));\n-\n-    let x: Option<A> = FromPrimitive::from_int(4);\n-    assert_eq!(x, Some(A::Qux));\n-\n-    let x: Option<A> = FromPrimitive::from_int(5);\n-    assert_eq!(x, None);\n-}"}, {"sha": "0a490466ef73b3f109b38b62e50ed2e7c9402fdc", "filename": "src/test/run-pass/early-ret-binop-add.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fearly-ret-binop-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fearly-ret-binop-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-ret-binop-add.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,8 +10,8 @@\n \n // pretty-expanded FIXME #23616\n \n-use std::num::Int;\n+use std::ops::Add;\n \n-fn wsucc<T:Int>(n: T) -> T { n + { return n } }\n+fn wsucc<T:Add<Output=T> + Copy>(n: T) -> T { n + { return n } }\n \n pub fn main() { }"}, {"sha": "4d54bb4ef7250170aa5027128919eecbcfd84a21", "filename": "src/test/run-pass/exponential-notation.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/98e9765d973d46faa5c80fb37a48040ca9e87b28/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e9765d973d46faa5c80fb37a48040ca9e87b28/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=98e9765d973d46faa5c80fb37a48040ca9e87b28", "patch": "@@ -1,39 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#![feature(std_misc)]\n-\n-use std::num::strconv::ExponentFormat::{ExpBin, ExpDec};\n-use std::num::strconv::SignificantDigits::DigMax;\n-use std::num::strconv::SignFormat::{SignAll, SignNeg};\n-use std::num::strconv::float_to_str_common as to_string;\n-\n-macro_rules! t {\n-    ($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_string()); } }\n-}\n-\n-pub fn main() {\n-    // Basic usage\n-    t!(to_string(1.2345678e-5f64, 10, true, SignNeg, DigMax(6), ExpDec, false),\n-             \"1.234568e-5\");\n-\n-    // Hexadecimal output\n-    t!(to_string(7.281738281250e+01f64, 16, true, SignAll, DigMax(6), ExpBin, false),\n-              \"+1.2345p+6\");\n-    t!(to_string(-1.777768135071e-02f64, 16, true, SignAll, DigMax(6), ExpBin, false),\n-             \"-1.2345p-6\");\n-\n-    // Some denormals\n-    t!(to_string(4.9406564584124654e-324f64, 10, true, SignNeg, DigMax(6), ExpBin, false),\n-             \"1p-1074\");\n-    t!(to_string(2.2250738585072009e-308f64, 10, true, SignNeg, DigMax(6), ExpBin, false),\n-             \"1p-1022\");\n-}"}, {"sha": "421b19f2864fe6050edbf81576e87640adba5567", "filename": "src/test/run-pass/extern-methods.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fextern-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fextern-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-methods.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,12 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n-\n-trait A : MarkerTrait {\n+trait A {\n     extern \"fastcall\" fn test1(i: i32);\n     extern fn test2(i: i32);\n }"}, {"sha": "856599431fd18149dfec2e84e1072f0c9076b45c", "filename": "src/test/run-pass/float-nan.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-nan.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,17 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(std_misc)]\n-\n-use std::num::Float;\n+use std::f64;\n \n pub fn main() {\n-  let nan: f64 = Float::nan();\n+  let nan: f64 = f64::NAN;\n   assert!((nan).is_nan());\n \n-  let inf: f64 = Float::infinity();\n-  let neg_inf: f64 = Float::neg_infinity();\n+  let inf: f64 = f64::INFINITY;\n+  let neg_inf: f64 = -f64::INFINITY;\n   assert_eq!(-inf, neg_inf);\n \n   assert!( nan !=  nan);"}, {"sha": "37ceaae373b9468a0c6392493be126d533b372af", "filename": "src/test/run-pass/intrinsics-math.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,7 +13,6 @@\n \n macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({\n-        use std::num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);"}, {"sha": "b4621a2d053b1de4dae9e8d12d889575b2b75115", "filename": "src/test/run-pass/issue-11736.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11736.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,10 +12,7 @@\n \n #![feature(collections)]\n \n-extern crate collections;\n-\n use std::collections::BitVec;\n-use std::num::Float;\n \n fn main() {\n     // Generate sieve of Eratosthenes for n up to 1e6"}, {"sha": "ca68272d2d0f295f605d6df8b89f22a0f664ec49", "filename": "src/test/run-pass/issue-13105.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fissue-13105.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fissue-13105.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13105.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,11 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {\n+trait Foo {\n     fn quux(u8) {}\n }\n "}, {"sha": "4ebc43163ede894d451b8a85d612a218ff334271", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,35 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(zero_one)]\n \n-#![feature(core)]\n-\n-use std::num::Int;\n+use std::num::Zero;\n use std::thread;\n \n-// Avoid using constants, which would trigger compile-time errors.\n-fn min_val<T: Int>() -> T { Int::min_value() }\n-fn zero<T: Int>() -> T { Int::zero() }\n-\n fn main() {\n-    assert!(thread::spawn(move|| { min_val::<isize>() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i8>() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i16>() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i32>() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i64>() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { 1isize / zero::<isize>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i8 / zero::<i8>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i16 / zero::<i16>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i32 / zero::<i32>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i64 / zero::<i64>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<isize>() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i8>() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i16>() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i32>() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i64>() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { 1isize % zero::<isize>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i8 % zero::<i8>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i16 % zero::<i16>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i32 % zero::<i32>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i64 % zero::<i64>(); }).join().is_err());\n+    assert!(thread::spawn(move|| { isize::min_value() / -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i8::min_value() / -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i16::min_value() / -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i32::min_value() / -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i64::min_value() / -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { 1isize / isize::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i8 / i8::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i16 / i16::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i32 / i32::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i64 / i64::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { isize::min_value() % -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i8::min_value() % -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i16::min_value() % -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i32::min_value() % -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i64::min_value() % -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { 1isize % isize::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i8 % i8::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i16 % i16::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i32 % i32::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i64 % i64::zero(); }).join().is_err());\n }"}, {"sha": "b7de1b5f4cbb536efd0a3276093f0bae9f24b05b", "filename": "src/test/run-pass/monomorphized-callees-with-ty-params-3314.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,11 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n-\n-trait Serializer : MarkerTrait {\n+trait Serializer {\n }\n \n trait Serializable {"}, {"sha": "b1d71abc78599c0bb908e08513fa12cedb0d6df9", "filename": "src/test/run-pass/numeric-method-autoexport.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -15,11 +15,7 @@\n // necessary. Testing the methods of the impls is done within the source\n // file for each numeric type.\n \n-\n-#![feature(core)]\n-\n use std::ops::Add;\n-use std::num::ToPrimitive;\n \n pub fn main() {\n // ints\n@@ -37,9 +33,4 @@ pub fn main() {\n     assert_eq!(15_u16.add(6u16), 21_u16);\n     assert_eq!(15_u32.add(6u32), 21_u32);\n     assert_eq!(15_u64.add(6u64), 21_u64);\n-\n-// floats\n-    // num\n-    assert_eq!(10_f32.to_i32().unwrap(), 10);\n-    assert_eq!(10_f64.to_i32().unwrap(), 10);\n }"}, {"sha": "5e924d015b619ca712aa6101f2c89794d21199a5", "filename": "src/test/run-pass/overloaded-autoderef.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,7 +13,6 @@\n \n use std::cell::RefCell;\n use std::rc::Rc;\n-use std::num::ToPrimitive;\n \n #[derive(PartialEq, Debug)]\n struct Point {\n@@ -23,9 +22,6 @@ struct Point {\n \n pub fn main() {\n     let box_5: Box<_> = box 5_usize;\n-    assert_eq!(Rc::new(5_usize).to_uint(), Some(5));\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-    assert_eq!((Box::new(&Box::new(&Rc::new(Box::new(Box::new(&box_5)))))).to_uint(), Some(5));\n     let point = Rc::new(Point {x: 2, y: 4});\n     assert_eq!(point.x, 2);\n     assert_eq!(point.y, 4);"}, {"sha": "f69b857981d788f735983ad3ebf87e70d129c181", "filename": "src/test/run-pass/syntax-trait-polarity.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fsyntax-trait-polarity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Fsyntax-trait-polarity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-trait-polarity.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,15 +10,13 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(optin_builtin_traits, core)]\n-\n-use std::marker::{MarkerTrait, Send};\n+#![feature(optin_builtin_traits)]\n \n struct TestType;\n \n impl TestType {}\n \n-trait TestTrait : MarkerTrait {}\n+trait TestTrait {}\n \n impl !Send for TestType {}\n "}, {"sha": "558e69664ecf9c840f74cd2f09f483ef929b9e0e", "filename": "src/test/run-pass/trait-bounds-basic.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,9 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-trait Foo : ::std::marker::MarkerTrait {\n+trait Foo {\n }\n \n fn b(_x: Box<Foo+Send>) {"}, {"sha": "bb8ae8247fa99abe9d4b36e1d0cbabde496af10a", "filename": "src/test/run-pass/trait-bounds-on-structs-and-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-on-structs-and-enums.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -12,10 +12,10 @@\n \n #![feature(core)]\n \n-trait U : ::std::marker::MarkerTrait {}\n+trait U {}\n trait T<X: U> { fn get(self) -> X; }\n \n-trait S2<Y: U> : ::std::marker::MarkerTrait {\n+trait S2<Y: U> {\n     fn m(x: Box<T<Y>+'static>) {}\n }\n "}, {"sha": "d984e9cdc990fb3cda395eb31f0d98b39af857a1", "filename": "src/test/run-pass/trait-bounds-recursion.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-bounds-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-bounds-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-recursion.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,21 +10,19 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n trait I { fn i(&self) -> Self; }\n \n-trait A<T:I> : ::std::marker::MarkerTrait {\n+trait A<T:I> {\n     fn id(x:T) -> T { x.i() }\n }\n \n trait J<T> { fn j(&self) -> T; }\n \n-trait B<T:J<T>> : ::std::marker::MarkerTrait {\n+trait B<T:J<T>> {\n     fn id(x:T) -> T { x.j() }\n }\n \n-trait C : ::std::marker::MarkerTrait {\n+trait C {\n     fn id<T:J<T>>(x:T) -> T { x.j() }\n }\n "}, {"sha": "e5390ac8a6256c96d5c238f7a6299be828696823", "filename": "src/test/run-pass/trait-inheritance-num.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,16 +10,11 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-use std::cmp::{PartialEq, PartialOrd};\n-use std::num::NumCast;\n-\n-pub trait NumExt: NumCast + PartialEq + PartialOrd {}\n+pub trait NumExt: PartialEq + PartialOrd {}\n \n pub trait FloatExt: NumExt {}\n \n-fn greater_than_one<T: NumExt>(n: &T) -> bool { *n > NumCast::from(1).unwrap() }\n-fn greater_than_one_float<T: FloatExt>(n: &T) -> bool { *n > NumCast::from(1).unwrap() }\n+fn greater_than_one<T: NumExt>(n: &T) -> bool { loop {} }\n+fn greater_than_one_float<T: FloatExt>(n: &T) -> bool { loop {} }\n \n pub fn main() {}"}, {"sha": "83c2a9ad33926281c369c1729ded5099dc684254", "filename": "src/test/run-pass/trait-inheritance-num0.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -15,7 +15,10 @@\n #![feature(core)]\n \n use std::cmp::PartialOrd;\n-use std::num::NumCast;\n+\n+pub trait NumCast {\n+    fn from(i: i32) -> Option<Self>;\n+}\n \n pub trait Num {\n     fn from_int(i: isize) -> Self;"}, {"sha": "14a6a9a0c664ce1fd1c5f61526db25c0ced5e6b3", "filename": "src/test/run-pass/trait-inheritance-num1.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,10 +10,9 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-use std::cmp::PartialOrd;\n-use std::num::NumCast;\n+pub trait NumCast {\n+    fn from(i: i32) -> Option<Self>;\n+}\n \n pub trait NumExt: NumCast + PartialOrd { }\n "}, {"sha": "5f8541a6da1e88c2a360eff74c0254a6389ee8d9", "filename": "src/test/run-pass/trait-inheritance-num2.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,12 +10,7 @@\n \n // A more complex example of numeric extensions\n \n-#![feature(core)]\n-\n-use std::cmp::{PartialEq, PartialOrd};\n-use std::num::NumCast;\n-\n-pub trait TypeExt : ::std::marker::MarkerTrait { }\n+pub trait TypeExt {}\n \n impl TypeExt for u8 {}\n impl TypeExt for u16 {}\n@@ -33,7 +28,7 @@ impl TypeExt for f32 {}\n impl TypeExt for f64 {}\n \n \n-pub trait NumExt: TypeExt + PartialEq + PartialOrd + NumCast {}\n+pub trait NumExt: TypeExt + PartialEq + PartialOrd {}\n \n impl NumExt for u8 {}\n impl NumExt for u16 {}"}, {"sha": "abf8d2baf8732154115bbe5e674c73c4e22bf512", "filename": "src/test/run-pass/trait-inheritance-num3.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,14 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n-\n-use std::cmp::{PartialEq, PartialOrd};\n-use std::num::NumCast;\n+pub trait NumCast {\n+    fn from(i: i32) -> Option<Self>;\n+}\n \n pub trait NumExt: PartialEq + PartialOrd + NumCast {}\n \n impl NumExt for f32 {}\n+impl NumCast for f32 {\n+    fn from(i: i32) -> Option<f32> { Some(i as f32) }\n+}\n \n fn num_eq_one<T: NumExt>(n: T) {\n     println!(\"{}\", n == NumCast::from(1).unwrap())"}, {"sha": "c6f8a5d4f1d99f98bda8a384088d0f6123528326", "filename": "src/test/run-pass/trait-inheritance-num5.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,16 +10,22 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-use std::cmp::PartialEq;\n-use std::num::NumCast;\n+pub trait NumCast {\n+    fn from(i: i32) -> Option<Self>;\n+}\n \n pub trait NumExt: PartialEq + NumCast {}\n \n impl NumExt for f32 {}\n impl NumExt for isize {}\n \n+impl NumCast for f32 {\n+    fn from(i: i32) -> Option<f32> { Some(i as f32) }\n+}\n+impl NumCast for isize {\n+    fn from(i: i32) -> Option<isize> { Some(i as isize) }\n+}\n+\n fn num_eq_one<T:NumExt>() -> T {\n     NumCast::from(1).unwrap()\n }"}, {"sha": "c7e206cb474b86d81d0dbf3f66484972faf09b26", "filename": "src/test/run-pass/trait-inheritance-self-in-supertype.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-self-in-supertype.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -10,9 +10,6 @@\n \n // Test for issue #4183: use of Self in supertraits.\n \n-\n-use std::num::Float as StdFloat;\n-\n pub static FUZZY_EPSILON: f64 = 0.1;\n \n pub trait FuzzyEq<Eps> {"}, {"sha": "67bea3864a7720ffac467765398ee852071c3665", "filename": "src/test/run-pass/trait-inheritance-static2.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static2.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -8,12 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub trait MyEq {}\n \n-#![feature(core)]\n-\n-pub trait MyEq : ::std::marker::MarkerTrait { }\n-\n-pub trait MyNum : ::std::marker::MarkerTrait {\n+pub trait MyNum {\n     fn from_int(isize) -> Self;\n }\n "}, {"sha": "c4944548e17f02c1eedf7113eaa4a107f4f24580", "filename": "src/test/run-pass/unboxed-closures-infer-argument-types-from-expected-bound.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-bound.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,14 +13,18 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(unboxed_closures, core)]\n+pub trait ToPrimitive {\n+    fn to_int(&self) {}\n+}\n \n-use std::num::ToPrimitive;\n+impl ToPrimitive for isize {}\n+impl ToPrimitive for i32 {}\n+impl ToPrimitive for usize {}\n \n fn doit<T,F>(val: T, f: &F)\n     where F : Fn(T)\n {\n-    f.call((val,))\n+    f(val)\n }\n \n pub fn main() {"}, {"sha": "9cad7d61e32c5e6d1977ee66be876b86190166bd", "filename": "src/test/run-pass/unboxed-closures-infer-argument-types-from-expected-object-type.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-object-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-object-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-from-expected-object-type.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,11 +13,15 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(unboxed_closures, core)]\n+pub trait ToPrimitive {\n+    fn to_int(&self) {}\n+}\n \n-use std::num::ToPrimitive;\n+impl ToPrimitive for isize {}\n+impl ToPrimitive for i32 {}\n+impl ToPrimitive for usize {}\n \n-fn doit<T>(val: T, f: &Fn(T)) { f.call((val,)) }\n+fn doit<T>(val: T, f: &Fn(T)) { f(val) }\n \n pub fn main() {\n     doit(0, &|x /*: isize*/ | { x.to_int(); });"}, {"sha": "bdd1932182bdcbc19507fef7bbb25abacbe81854", "filename": "src/test/run-pass/unboxed-closures-infer-argument-types-with-bound-regions-from-expected-bound.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-with-bound-regions-from-expected-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-with-bound-regions-from-expected-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-argument-types-with-bound-regions-from-expected-bound.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -13,14 +13,18 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(unboxed_closures, core)]\n+pub trait ToPrimitive {\n+    fn to_int(&self) {}\n+}\n \n-use std::num::ToPrimitive;\n+impl ToPrimitive for isize {}\n+impl ToPrimitive for i32 {}\n+impl ToPrimitive for usize {}\n \n fn doit<T,F>(val: T, f: &F)\n     where F : Fn(&T)\n {\n-    f.call((&val,))\n+    f(&val)\n }\n \n pub fn main() {"}, {"sha": "579070a295adf90a0f4c40b668701eef3ff6147d", "filename": "src/test/run-pass/utf8_idents.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Futf8_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1dd5ac78745a9f266573d539ba34bbd75b50277/src%2Ftest%2Frun-pass%2Futf8_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_idents.rs?ref=a1dd5ac78745a9f266573d539ba34bbd75b50277", "patch": "@@ -11,8 +11,6 @@\n \n #![feature(non_ascii_idents)]\n \n-use std::num::Float;\n-\n pub fn main() {\n     let \u03b5 = 0.00001f64;\n     let \u03a0 = 3.14f64;"}]}