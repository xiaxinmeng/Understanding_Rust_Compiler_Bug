{"sha": "c53064fb58ac170dbd93b9529d78fc324c1dae9f", "node_id": "C_kwDOAAsO6NoAKGM1MzA2NGZiNThhYzE3MGRiZDkzYjk1MjlkNzhmYzMyNGMxZGFlOWY", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-01-17T10:51:48Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-01-17T11:17:15Z"}, "message": "Enforce builtin binop expectations even without lang items", "tree": {"sha": "244719c55d4d4cdbe11941264632b836d45cd021", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/244719c55d4d4cdbe11941264632b836d45cd021"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c53064fb58ac170dbd93b9529d78fc324c1dae9f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmPGg7sACgkQ4laYqTBY\nYXHNcw/+JKIvy3Qxd+OqHLaOrKJKWVlTBsxzqYJy+lkTM6sIhTNAWJxYKsS3cqib\n/FAIzb5m7dWnOJ3aPLpVm6OTXIHrhU8y9c933HjRBLjM1a1qLL8C2jAeuEQK47Gm\nnmMdGQ0Zugyf3RXGc+xpHI0zm6yI4bqDxgC/qKxcm9mH1wsp4WvS/HfVjb1KDU13\n+XgZawe0x8Q8F3Hq5OFsj+scC/OS4/oR8viYBNEiAoJXqnB/4uAkmtx8A/FSXA3T\n7fvRSVKT4JamprsQ3FZRLHSjH96zxG8rqFceSyKa6lJI1OhaGDy+sXw+YzEkdHcn\nKpm7DmmANhXyW25ovMhNiWkw935CMaa+eWhXEZVfj02LH0BB5/MpblCarVRsDgHF\nDXL0iijysUUZpVSXt5f3du7SOourbqlpYgJ2a2JTSL+tnj6PSxDL0XE6iHyB+Jow\nS+Pi92sw/kdwxn+VAKu/5yiA1OMuQ0hkfgWj/s6D7JuwmtPSrQrtGG6QZBmGYoOx\n6gyI1Qjn0jDqcHpaoAGAh1fRhJSf3q2XHEYMFMB9uhrDwhDSN872M/5vV9vWOijS\nzglZulJuq8X76lK0YRk0q3J3IdZOj0FRWywp5U86hHORJFdxokEr5TRUpTP+o2Ku\nr62HWyg974racZGE8Wh3cs/OV+qVfsnTlUuyZ7iy7uxixEwj3uQ=\n=cEcS\n-----END PGP SIGNATURE-----", "payload": "tree 244719c55d4d4cdbe11941264632b836d45cd021\nparent 461435adabb7ddfb4eb65109db6c2fcc191d8049\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1673952708 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1673954235 +0900\n\nEnforce builtin binop expectations even without lang items\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c53064fb58ac170dbd93b9529d78fc324c1dae9f", "html_url": "https://github.com/rust-lang/rust/commit/c53064fb58ac170dbd93b9529d78fc324c1dae9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c53064fb58ac170dbd93b9529d78fc324c1dae9f/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "461435adabb7ddfb4eb65109db6c2fcc191d8049", "url": "https://api.github.com/repos/rust-lang/rust/commits/461435adabb7ddfb4eb65109db6c2fcc191d8049", "html_url": "https://github.com/rust-lang/rust/commit/461435adabb7ddfb4eb65109db6c2fcc191d8049"}], "stats": {"total": 118, "additions": 16, "deletions": 102}, "files": [{"sha": "0e177db7726a47b4242aa2681e3ae4030e644d16", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c53064fb58ac170dbd93b9529d78fc324c1dae9f/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53064fb58ac170dbd93b9529d78fc324c1dae9f/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=c53064fb58ac170dbd93b9529d78fc324c1dae9f", "patch": "@@ -1041,10 +1041,6 @@ impl Expectation {\n         }\n     }\n \n-    fn from_option(ty: Option<Ty>) -> Self {\n-        ty.map_or(Expectation::None, Expectation::HasType)\n-    }\n-\n     /// The following explanation is copied straight from rustc:\n     /// Provides an expectation for an rvalue expression given an *optional*\n     /// hint, which is not required for type safety (the resulting type might"}, {"sha": "6f347f6757b001e39a77dbe6e9ee687b4099f88e", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 16, "deletions": 98, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c53064fb58ac170dbd93b9529d78fc324c1dae9f/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53064fb58ac170dbd93b9529d78fc324c1dae9f/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=c53064fb58ac170dbd93b9529d78fc324c1dae9f", "patch": "@@ -10,8 +10,7 @@ use chalk_ir::{\n };\n use hir_def::{\n     expr::{\n-        ArithOp, Array, BinaryOp, ClosureKind, CmpOp, Expr, ExprId, LabelId, Literal, Statement,\n-        UnaryOp,\n+        ArithOp, Array, BinaryOp, ClosureKind, Expr, ExprId, LabelId, Literal, Statement, UnaryOp,\n     },\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n@@ -1017,11 +1016,21 @@ impl<'a> InferenceContext<'a> {\n         let (trait_, func) = match trait_func {\n             Some(it) => it,\n             None => {\n-                let rhs_ty = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone());\n-                let rhs_ty = self.infer_expr_coerce(rhs, &Expectation::from_option(rhs_ty));\n-                return self\n-                    .builtin_binary_op_return_ty(op, lhs_ty, rhs_ty)\n-                    .unwrap_or_else(|| self.err_ty());\n+                // HACK: `rhs_ty` is a general inference variable with no clue at all at this\n+                // point. Passing `lhs_ty` as both operands just to check if `lhs_ty` is a builtin\n+                // type applicable to `op`.\n+                let ret_ty = if self.is_builtin_binop(&lhs_ty, &lhs_ty, op) {\n+                    // Assume both operands are builtin so we can continue inference. No guarantee\n+                    // on the correctness, rustc would complain as necessary lang items don't seem\n+                    // to exist anyway.\n+                    self.enforce_builtin_binop_types(&lhs_ty, &rhs_ty, op)\n+                } else {\n+                    self.err_ty()\n+                };\n+\n+                self.infer_expr_coerce(rhs, &Expectation::has_type(rhs_ty));\n+\n+                return ret_ty;\n             }\n         };\n \n@@ -1475,97 +1484,6 @@ impl<'a> InferenceContext<'a> {\n         indices\n     }\n \n-    fn builtin_binary_op_return_ty(&mut self, op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Option<Ty> {\n-        let lhs_ty = self.resolve_ty_shallow(&lhs_ty);\n-        let rhs_ty = self.resolve_ty_shallow(&rhs_ty);\n-        match op {\n-            BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => {\n-                Some(TyKind::Scalar(Scalar::Bool).intern(Interner))\n-            }\n-            BinaryOp::Assignment { .. } => Some(TyBuilder::unit()),\n-            BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => {\n-                // all integer combinations are valid here\n-                if matches!(\n-                    lhs_ty.kind(Interner),\n-                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n-                        | TyKind::InferenceVar(_, TyVariableKind::Integer)\n-                ) && matches!(\n-                    rhs_ty.kind(Interner),\n-                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n-                        | TyKind::InferenceVar(_, TyVariableKind::Integer)\n-                ) {\n-                    Some(lhs_ty)\n-                } else {\n-                    None\n-                }\n-            }\n-            BinaryOp::ArithOp(_) => match (lhs_ty.kind(Interner), rhs_ty.kind(Interner)) {\n-                // (int, int) | (uint, uint) | (float, float)\n-                (TyKind::Scalar(Scalar::Int(_)), TyKind::Scalar(Scalar::Int(_)))\n-                | (TyKind::Scalar(Scalar::Uint(_)), TyKind::Scalar(Scalar::Uint(_)))\n-                | (TyKind::Scalar(Scalar::Float(_)), TyKind::Scalar(Scalar::Float(_))) => {\n-                    Some(rhs_ty)\n-                }\n-                // ({int}, int) | ({int}, uint)\n-                (\n-                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)),\n-                ) => Some(rhs_ty),\n-                // (int, {int}) | (uint, {int})\n-                (\n-                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)),\n-                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                ) => Some(lhs_ty),\n-                // ({float} | float)\n-                (\n-                    TyKind::InferenceVar(_, TyVariableKind::Float),\n-                    TyKind::Scalar(Scalar::Float(_)),\n-                ) => Some(rhs_ty),\n-                // (float, {float})\n-                (\n-                    TyKind::Scalar(Scalar::Float(_)),\n-                    TyKind::InferenceVar(_, TyVariableKind::Float),\n-                ) => Some(lhs_ty),\n-                // ({int}, {int}) | ({float}, {float})\n-                (\n-                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                )\n-                | (\n-                    TyKind::InferenceVar(_, TyVariableKind::Float),\n-                    TyKind::InferenceVar(_, TyVariableKind::Float),\n-                ) => Some(rhs_ty),\n-                _ => None,\n-            },\n-        }\n-    }\n-\n-    fn builtin_binary_op_rhs_expectation(&mut self, op: BinaryOp, lhs_ty: Ty) -> Option<Ty> {\n-        Some(match op {\n-            BinaryOp::LogicOp(..) => TyKind::Scalar(Scalar::Bool).intern(Interner),\n-            BinaryOp::Assignment { op: None } => {\n-                stdx::never!(\"Simple assignment operator is not binary op.\");\n-                return None;\n-            }\n-            BinaryOp::CmpOp(CmpOp::Eq { .. }) => match self\n-                .resolve_ty_shallow(&lhs_ty)\n-                .kind(Interner)\n-            {\n-                TyKind::Scalar(_) | TyKind::Str => lhs_ty,\n-                TyKind::InferenceVar(_, TyVariableKind::Integer | TyVariableKind::Float) => lhs_ty,\n-                _ => return None,\n-            },\n-            BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => return None,\n-            BinaryOp::CmpOp(CmpOp::Ord { .. })\n-            | BinaryOp::Assignment { op: Some(_) }\n-            | BinaryOp::ArithOp(_) => match self.resolve_ty_shallow(&lhs_ty).kind(Interner) {\n-                TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_) | Scalar::Float(_)) => lhs_ty,\n-                TyKind::InferenceVar(_, TyVariableKind::Integer | TyVariableKind::Float) => lhs_ty,\n-                _ => return None,\n-            },\n-        })\n-    }\n-\n     /// Dereferences a single level of immutable referencing.\n     fn deref_ty_if_possible(&mut self, ty: &Ty) -> Ty {\n         let ty = self.resolve_ty_shallow(ty);"}]}