{"sha": "1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MDJkMWUwZGUxNzk0OThkMGNiN2ZkNDg1NmQxZTBmZmNkNTIwOTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-22T15:04:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-22T15:04:50Z"}, "message": "Auto merge of #70275 - Dylan-DPC:rollup-1fbosob, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #68099 (Amend Rc/Arc::from_raw() docs regarding unsafety)\n - #70172 (parse/lexer: support `StringReader::retokenize` called on external files.)\n - #70209 (parser: recover on `for<'a> |...| body` closures)\n - #70223 (fix type of const params in associated types.)\n - #70229 (more clippy fixes)\n - #70240 (Return NonZeroU64 from ThreadId::as_u64.)\n - #70250 (Remove wrong entry from RELEASES.md)\n - #70253 (Remove another wrong entry from RELEASES.md)\n - #70254 (couple more clippy fixes (let_and_return, if_same_then_else))\n - #70266 (proc_macro_harness: Use item header spans for errors)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e74b5efb531451784c6ff326c4c1239851a28455", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e74b5efb531451784c6ff326c4c1239851a28455"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "html_url": "https://github.com/rust-lang/rust/commit/1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ae85f43f4eeaf177cd12f47958b7ff62786b612", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ae85f43f4eeaf177cd12f47958b7ff62786b612", "html_url": "https://github.com/rust-lang/rust/commit/5ae85f43f4eeaf177cd12f47958b7ff62786b612"}, {"sha": "69c0bcd3d5d65e508751af5e7cb1c35b7e9ec4c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/69c0bcd3d5d65e508751af5e7cb1c35b7e9ec4c9", "html_url": "https://github.com/rust-lang/rust/commit/69c0bcd3d5d65e508751af5e7cb1c35b7e9ec4c9"}], "stats": {"total": 576, "additions": 321, "deletions": 255}, "files": [{"sha": "9ff0d14b353cdcad6dfdd8eec43bcd5d488060bb", "filename": "RELEASES.md", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -4838,7 +4838,6 @@ Version 1.11.0 (2016-08-18)\n Language\n --------\n \n-* [`cfg_attr` works on `path` attributes](https://github.com/rust-lang/rust/pull/34546)\n * [Support nested `cfg_attr` attributes](https://github.com/rust-lang/rust/pull/34216)\n * [Allow statement-generating braced macro invocations at the end of blocks](https://github.com/rust-lang/rust/pull/34436)\n * [Macros can be expanded inside of trait definitions](https://github.com/rust-lang/rust/pull/34213)\n@@ -4957,8 +4956,6 @@ Version 1.10.0 (2016-07-07)\n Language\n --------\n \n-* [Allow `concat_idents!` in type positions as well as in expression\n-  positions](https://github.com/rust-lang/rust/pull/33735).\n * [`Copy` types are required to have a trivial implementation of `Clone`](https://github.com/rust-lang/rust/pull/33420).\n   [RFC 1521](https://github.com/rust-lang/rfcs/blob/master/text/1521-copy-clone-semantics.md).\n * [Single-variant enums support the `#[repr(..)]` attribute](https://github.com/rust-lang/rust/pull/33355)."}, {"sha": "e7f7608e676a203c30505b1004d5a2375656c4a3", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -259,6 +259,10 @@ use crate::vec::Vec;\n #[cfg(test)]\n mod tests;\n \n+// This is repr(C) to future-proof against possible field-reordering, which\n+// would interfere with otherwise safe [into|from]_raw() of transmutable\n+// inner types.\n+#[repr(C)]\n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n     weak: Cell<usize>,\n@@ -580,15 +584,24 @@ impl<T: ?Sized> Rc<T> {\n         }\n     }\n \n-    /// Constructs an `Rc` from a raw pointer.\n+    /// Constructs an `Rc<T>` from a raw pointer.\n     ///\n-    /// The raw pointer must have been previously returned by a call to a\n-    /// [`Rc::into_raw`][into_raw].\n+    /// The raw pointer must have been previously returned by a call to\n+    /// [`Rc<U>::into_raw`][into_raw] where `U` must have the same size\n+    /// and alignment as `T`. This is trivially true if `U` is `T`.\n+    /// Note that if `U` is not `T` but has the same size and alignment, this is\n+    /// basically like transmuting references of different types. See\n+    /// [`mem::transmute`][transmute] for more information on what\n+    /// restrictions apply in this case.\n     ///\n-    /// This function is unsafe because improper use may lead to memory problems. For example, a\n-    /// double-free may occur if the function is called twice on the same raw pointer.\n+    /// The user of `from_raw` has to make sure a specific value of `T` is only\n+    /// dropped once.\n+    ///\n+    /// This function is unsafe because improper use may lead to memory unsafety,\n+    /// even if the returned `Rc<T>` is never accessed.\n     ///\n     /// [into_raw]: struct.Rc.html#method.into_raw\n+    /// [transmute]: ../../std/mem/fn.transmute.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "d8fc1faca3a39c616fdd3d1a7d05ce7810c59d61", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -145,8 +145,7 @@ mod hack {\n         unsafe {\n             let len = b.len();\n             let b = Box::into_raw(b);\n-            let xs = Vec::from_raw_parts(b as *mut T, len, len);\n-            xs\n+            Vec::from_raw_parts(b as *mut T, len, len)\n         }\n     }\n "}, {"sha": "e8985e202567bcd4bd628cfaea34722d32a493f0", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -287,6 +287,10 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n     }\n }\n \n+// This is repr(C) to future-proof against possible field-reordering, which\n+// would interfere with otherwise safe [into|from]_raw() of transmutable\n+// inner types.\n+#[repr(C)]\n struct ArcInner<T: ?Sized> {\n     strong: atomic::AtomicUsize,\n \n@@ -577,15 +581,24 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Constructs an `Arc` from a raw pointer.\n+    /// Constructs an `Arc<T>` from a raw pointer.\n     ///\n-    /// The raw pointer must have been previously returned by a call to a\n-    /// [`Arc::into_raw`][into_raw].\n+    /// The raw pointer must have been previously returned by a call to\n+    /// [`Arc<U>::into_raw`][into_raw] where `U` must have the same size and\n+    /// alignment as `T`. This is trivially true if `U` is `T`.\n+    /// Note that if `U` is not `T` but has the same size and alignment, this is\n+    /// basically like transmuting references of different types. See\n+    /// [`mem::transmute`][transmute] for more information on what\n+    /// restrictions apply in this case.\n     ///\n-    /// This function is unsafe because improper use may lead to memory problems. For example, a\n-    /// double-free may occur if the function is called twice on the same raw pointer.\n+    /// The user of `from_raw` has to make sure a specific value of `T` is only\n+    /// dropped once.\n+    ///\n+    /// This function is unsafe because improper use may lead to memory unsafety,\n+    /// even if the returned `Arc<T>` is never accessed.\n     ///\n     /// [into_raw]: struct.Arc.html#method.into_raw\n+    /// [transmute]: ../../std/mem/fn.transmute.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "cd4b73a3d1ff6706cfe9f70834e387a7ff92c780", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -1044,9 +1044,7 @@ pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> &'tcx Indexe\n         collector.finalize_and_compute_crate_hash(crate_disambiguator, &*tcx.cstore, cmdline_args)\n     };\n \n-    let map = tcx.arena.alloc(IndexedHir { crate_hash, map });\n-\n-    map\n+    tcx.arena.alloc(IndexedHir { crate_hash, map })\n }\n \n /// Identical to the `PpAnn` implementation for `hir::Crate`,"}, {"sha": "d66fcd3a20db92017521bde7569f5340244cd8dc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -381,12 +381,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // Field 5 would be the first element, so memory_index is i:\n         // Note: if we didn't optimize, it's already right.\n \n-        let memory_index;\n-        if optimize {\n-            memory_index = invert_mapping(&inverse_memory_index);\n-        } else {\n-            memory_index = inverse_memory_index;\n-        }\n+        let memory_index =\n+            if optimize { invert_mapping(&inverse_memory_index) } else { inverse_memory_index };\n \n         let size = min_size.align_to(align.abi);\n         let mut abi = Abi::Aggregate { sized };\n@@ -944,33 +940,33 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             let offset = st[i].fields.offset(field_index) + niche.offset;\n                             let size = st[i].size;\n \n-                            let mut abi = match st[i].abi {\n-                                Abi::Scalar(_) => Abi::Scalar(niche_scalar.clone()),\n-                                Abi::ScalarPair(ref first, ref second) => {\n-                                    // We need to use scalar_unit to reset the\n-                                    // valid range to the maximal one for that\n-                                    // primitive, because only the niche is\n-                                    // guaranteed to be initialised, not the\n-                                    // other primitive.\n-                                    if offset.bytes() == 0 {\n-                                        Abi::ScalarPair(\n-                                            niche_scalar.clone(),\n-                                            scalar_unit(second.value),\n-                                        )\n-                                    } else {\n-                                        Abi::ScalarPair(\n-                                            scalar_unit(first.value),\n-                                            niche_scalar.clone(),\n-                                        )\n+                            let abi = if st.iter().all(|v| v.abi.is_uninhabited()) {\n+                                Abi::Uninhabited\n+                            } else {\n+                                match st[i].abi {\n+                                    Abi::Scalar(_) => Abi::Scalar(niche_scalar.clone()),\n+                                    Abi::ScalarPair(ref first, ref second) => {\n+                                        // We need to use scalar_unit to reset the\n+                                        // valid range to the maximal one for that\n+                                        // primitive, because only the niche is\n+                                        // guaranteed to be initialised, not the\n+                                        // other primitive.\n+                                        if offset.bytes() == 0 {\n+                                            Abi::ScalarPair(\n+                                                niche_scalar.clone(),\n+                                                scalar_unit(second.value),\n+                                            )\n+                                        } else {\n+                                            Abi::ScalarPair(\n+                                                scalar_unit(first.value),\n+                                                niche_scalar.clone(),\n+                                            )\n+                                        }\n                                     }\n+                                    _ => Abi::Aggregate { sized: true },\n                                 }\n-                                _ => Abi::Aggregate { sized: true },\n                             };\n \n-                            if st.iter().all(|v| v.abi.is_uninhabited()) {\n-                                abi = Abi::Uninhabited;\n-                            }\n-\n                             let largest_niche =\n                                 Niche::from_scalar(dl, offset, niche_scalar.clone());\n "}, {"sha": "80a4e552f02d6101cd7fbd413d30b29aa8951497", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -746,7 +746,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// side-effects -- e.g., in order to report errors for erroneous programs.\n     ///\n     /// Note: The optimization is only available during incr. comp.\n-    pub(super) fn ensure_query<Q: QueryDescription<'tcx> + 'tcx>(self, key: Q::Key) -> () {\n+    pub(super) fn ensure_query<Q: QueryDescription<'tcx> + 'tcx>(self, key: Q::Key) {\n         if Q::EVAL_ALWAYS {\n             let _ = self.get_query::<Q>(DUMMY_SP, key);\n             return;"}, {"sha": "9338f9afbbb3193d8ec906054c910695bb601581", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -1056,8 +1056,9 @@ impl<'a> MethodDef<'a> {\n                     self_: field,\n                     other: other_fields\n                         .iter_mut()\n-                        .map(|l| match l.next().unwrap() {\n-                            (.., ex, _) => ex,\n+                        .map(|l| {\n+                            let (.., ex, _) = l.next().unwrap();\n+                            ex\n                         })\n                         .collect(),\n                     attrs,"}, {"sha": "6540bcc415605336119598c32ebf7bcc84c617e0", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -10,6 +10,7 @@ use rustc_expand::base::{ExtCtxt, Resolver};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n use rustc_session::parse::ParseSess;\n use rustc_span::hygiene::AstPass;\n+use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::smallvec;\n@@ -44,6 +45,7 @@ struct CollectProcMacros<'a> {\n     macros: Vec<ProcMacro>,\n     in_root: bool,\n     handler: &'a rustc_errors::Handler,\n+    source_map: &'a SourceMap,\n     is_proc_macro_crate: bool,\n     is_test_crate: bool,\n }\n@@ -65,6 +67,7 @@ pub fn inject(\n         macros: Vec::new(),\n         in_root: true,\n         handler,\n+        source_map: sess.source_map(),\n         is_proc_macro_crate,\n         is_test_crate,\n     };\n@@ -195,7 +198,7 @@ impl<'a> CollectProcMacros<'a> {\n             } else {\n                 \"functions tagged with `#[proc_macro_derive]` must be `pub`\"\n             };\n-            self.handler.span_err(item.span, msg);\n+            self.handler.span_err(self.source_map.def_span(item.span), msg);\n         }\n     }\n \n@@ -214,7 +217,7 @@ impl<'a> CollectProcMacros<'a> {\n             } else {\n                 \"functions tagged with `#[proc_macro_attribute]` must be `pub`\"\n             };\n-            self.handler.span_err(item.span, msg);\n+            self.handler.span_err(self.source_map.def_span(item.span), msg);\n         }\n     }\n \n@@ -233,7 +236,7 @@ impl<'a> CollectProcMacros<'a> {\n             } else {\n                 \"functions tagged with `#[proc_macro]` must be `pub`\"\n             };\n-            self.handler.span_err(item.span, msg);\n+            self.handler.span_err(self.source_map.def_span(item.span), msg);\n         }\n     }\n }\n@@ -244,7 +247,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n-                self.handler.span_err(item.span, msg);\n+                self.handler.span_err(self.source_map.def_span(item.span), msg);\n             }\n         }\n \n@@ -295,7 +298,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n \n         let attr = match found_attr {\n             None => {\n-                self.check_not_pub_in_root(&item.vis, item.span);\n+                self.check_not_pub_in_root(&item.vis, self.source_map.def_span(item.span));\n                 let prev_in_root = mem::replace(&mut self.in_root, false);\n                 visit::walk_item(self, item);\n                 self.in_root = prev_in_root;"}, {"sha": "0a0e975e5a54c6fe113e4fc3422ac0845b18aa74", "filename": "src/librustc_codegen_ssa/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -81,9 +81,7 @@ fn get_rpaths(config: &mut RPathConfig<'_>, libs: &[PathBuf]) -> Vec<String> {\n     rpaths.extend_from_slice(&fallback_rpaths);\n \n     // Remove duplicates\n-    let rpaths = minimize_rpaths(&rpaths);\n-\n-    rpaths\n+    minimize_rpaths(&rpaths)\n }\n \n fn get_rpaths_relative_to_output(config: &mut RPathConfig<'_>, libs: &[PathBuf]) -> Vec<String> {"}, {"sha": "746ab34d2844d6cd631e4f242ad93c395be5bba7", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -288,7 +288,7 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n         B::run_thin_lto(cgcx, needs_thin_lto, import_only_modules).unwrap_or_else(|e| e.raise())\n     };\n \n-    let result = lto_modules\n+    lto_modules\n         .into_iter()\n         .map(|module| {\n             let cost = module.cost();\n@@ -303,9 +303,7 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n                 0,\n             )\n         }))\n-        .collect();\n-\n-    result\n+        .collect()\n }\n \n pub struct CompiledModules {"}, {"sha": "a7cdc48d60342f986c4e4a5e2ff3333bc2a3f3ac", "filename": "src/librustc_data_structures/profiling.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_data_structures%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_data_structures%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fprofiling.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -345,7 +345,7 @@ impl SelfProfilerRef {\n     ) {\n         drop(self.exec(event_filter, |profiler| {\n             let event_id = StringId::new_virtual(query_invocation_id.0);\n-            let thread_id = std::thread::current().id().as_u64() as u32;\n+            let thread_id = std::thread::current().id().as_u64().get() as u32;\n \n             profiler.profiler.record_instant_event(\n                 event_kind(profiler),\n@@ -522,7 +522,7 @@ impl<'a> TimingGuard<'a> {\n         event_kind: StringId,\n         event_id: EventId,\n     ) -> TimingGuard<'a> {\n-        let thread_id = std::thread::current().id().as_u64() as u32;\n+        let thread_id = std::thread::current().id().as_u64().get() as u32;\n         let raw_profiler = &profiler.profiler;\n         let timing_guard =\n             raw_profiler.start_recording_interval_event(event_kind, event_id, thread_id);"}, {"sha": "7b01f39d810b5572d343fa3f1ec4d1ed31979a7a", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -555,7 +555,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         // avoid allocations in those cases. We also don't use `indices` to\n         // determine if a kind has been seen before until the limit of 8 has\n         // been exceeded, to also avoid allocations for `indices`.\n-        let var = if !var_values.spilled() {\n+        if !var_values.spilled() {\n             // `var_values` is stack-allocated. `indices` isn't used yet. Do a\n             // direct linear search of `var_values`.\n             if let Some(idx) = var_values.iter().position(|&k| k == kind) {\n@@ -589,9 +589,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n                 assert_eq!(variables.len(), var_values.len());\n                 BoundVar::new(variables.len() - 1)\n             })\n-        };\n-\n-        var\n+        }\n     }\n \n     /// Shorthand helper that creates a canonical region variable for"}, {"sha": "06870ccc7dd5eca4503951203b34859f20d9756d", "filename": "src/librustc_infer/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -23,7 +23,7 @@ pub type NormalizedTy<'tcx> = Normalized<'tcx, Ty<'tcx>>;\n \n impl<'tcx, T> Normalized<'tcx, T> {\n     pub fn with<U>(self, value: U) -> Normalized<'tcx, U> {\n-        Normalized { value: value, obligations: self.obligations }\n+        Normalized { value, obligations: self.obligations }\n     }\n }\n "}, {"sha": "90f3cb1d24cccd68cb6d871493d035093bad20a7", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -47,7 +47,7 @@ struct PredicateSet<'tcx> {\n \n impl PredicateSet<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        Self { tcx: tcx, set: Default::default() }\n+        Self { tcx, set: Default::default() }\n     }\n \n     fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {"}, {"sha": "3e78a5852354f47ddad23cc9ad6ecf49584031da", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -94,14 +94,12 @@ mod dl {\n             let result = f();\n \n             let last_error = libc::dlerror() as *const _;\n-            let ret = if ptr::null() == last_error {\n+            if ptr::null() == last_error {\n                 Ok(result)\n             } else {\n                 let s = CStr::from_ptr(last_error).to_bytes();\n                 Err(str::from_utf8(s).unwrap().to_owned())\n-            };\n-\n-            ret\n+            }\n         }\n     }\n "}, {"sha": "7b65a5a10986ab22f7591ee5e9ebacbabfda1ac3", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -490,17 +490,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 {\n                     if pat_snippet.starts_with('&') {\n                         let pat_snippet = pat_snippet[1..].trim_start();\n-                        let suggestion;\n-                        let to_remove;\n-                        if pat_snippet.starts_with(\"mut\")\n+                        let (suggestion, to_remove) = if pat_snippet.starts_with(\"mut\")\n                             && pat_snippet[\"mut\".len()..].starts_with(rustc_lexer::is_whitespace)\n                         {\n-                            suggestion = pat_snippet[\"mut\".len()..].trim_start();\n-                            to_remove = \"&mut\";\n+                            (pat_snippet[\"mut\".len()..].trim_start(), \"&mut\")\n                         } else {\n-                            suggestion = pat_snippet;\n-                            to_remove = \"&\";\n-                        }\n+                            (pat_snippet, \"&\")\n+                        };\n                         suggestions.push((pat_span, to_remove, suggestion.to_owned()));\n                     }\n                 }"}, {"sha": "87d0424ece9443df86a7ae72be757cd41e631c80", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -335,9 +335,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     #[inline(always)]\n-    fn tag_static_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {\n-        ()\n-    }\n+    fn tag_static_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {}\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "276aabec13da0624a70bc6923ff909fcfdd6b461", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -184,14 +184,13 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             ..\n         } = self.builder;\n         *rev_lookup.projections.entry((base, elem.lift())).or_insert_with(move || {\n-            let path = MoveDataBuilder::new_move_path(\n+            MoveDataBuilder::new_move_path(\n                 move_paths,\n                 path_map,\n                 init_path_map,\n                 Some(base),\n                 mk_place(*tcx),\n-            );\n-            path\n+            )\n         })\n     }\n "}, {"sha": "ac593d0845a7df52051836a3379cc1181d84f888", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -581,7 +581,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// If `target` is `None`, that indicates the function cannot return, so we raise UB.\n     pub fn return_to_block(&mut self, target: Option<mir::BasicBlock>) -> InterpResult<'tcx> {\n         if let Some(target) = target {\n-            Ok(self.go_to_block(target))\n+            self.go_to_block(target);\n+            Ok(())\n         } else {\n             throw_ub!(Unreachable)\n         }"}, {"sha": "162387308040dd493dee00132bd3f3e74a96220e", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -192,7 +192,8 @@ impl PrettyPrinter<'tcx> for AbsolutePathPrinter<'tcx> {\n \n impl Write for AbsolutePathPrinter<'_> {\n     fn write_str(&mut self, s: &str) -> std::fmt::Result {\n-        Ok(self.path.push_str(s))\n+        self.path.push_str(s);\n+        Ok(())\n     }\n }\n "}, {"sha": "6b0bbe4f6e0bbd64c15ee09246cca772f6dd65e3", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -370,7 +370,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         self.stack.pop();\n                         Err(err)\n                     }\n-                    Ok(v) => Ok(v),\n+                    Ok(()) => Ok(()),\n                 }\n             }\n             // cannot use the shim here, because that will only result in infinite recursion"}, {"sha": "b41043ee5107591e5a4ad4d55e454ef02c7707aa", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -232,9 +232,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     }\n \n     #[inline(always)]\n-    fn tag_static_base_pointer(_memory_extra: &(), _id: AllocId) -> Self::PointerTag {\n-        ()\n-    }\n+    fn tag_static_base_pointer(_memory_extra: &(), _id: AllocId) -> Self::PointerTag {}\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -400,7 +398,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     where\n         F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n     {\n-        let r = match f(self) {\n+        match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n                 // Some errors shouldn't come up because creating them causes\n@@ -414,8 +412,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 );\n                 None\n             }\n-        };\n-        r\n+        }\n     }\n \n     fn eval_constant(&mut self, c: &Constant<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {"}, {"sha": "82183e6c96e9f5c6c48799e476386a36a8c97c4f", "filename": "src/librustc_mir_build/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -73,10 +73,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // they are never assigned.\n             ExprKind::Break { .. } | ExprKind::Continue { .. } | ExprKind::Return { .. } => (),\n             ExprKind::Block { body: hir::Block { expr: None, targeted_by_break: false, .. } }\n-                if expr_ty.is_never() =>\n-            {\n-                ()\n-            }\n+                if expr_ty.is_never() => {}\n             _ => {\n                 this.cfg\n                     .push(block, Statement { source_info, kind: StatementKind::StorageLive(temp) });"}, {"sha": "d66650329313b907e2fd390073a91c364d942ebf", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -637,11 +637,12 @@ where\n     );\n     assert_eq!(block, builder.return_block());\n \n-    let mut spread_arg = None;\n-    if abi == Abi::RustCall {\n+    let spread_arg = if abi == Abi::RustCall {\n         // RustCall pseudo-ABI untuples the last argument.\n-        spread_arg = Some(Local::new(arguments.len()));\n-    }\n+        Some(Local::new(arguments.len()))\n+    } else {\n+        None\n+    };\n     debug!(\"fn_id {:?} has attrs {:?}\", fn_def_id, tcx.get_attrs(fn_def_id));\n \n     let mut body = builder.finish();"}, {"sha": "ac58cbb9e8dae7bf45aa47d7209c8dd86e1eeabb", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -46,12 +46,20 @@ impl<'a> StringReader<'a> {\n         source_file: Lrc<rustc_span::SourceFile>,\n         override_span: Option<Span>,\n     ) -> Self {\n-        if source_file.src.is_none() {\n+        // Make sure external source is loaded first, before accessing it.\n+        // While this can't show up during normal parsing, `retokenize` may\n+        // be called with a source file from an external crate.\n+        sess.source_map().ensure_source_file_source_present(source_file.clone());\n+\n+        // FIXME(eddyb) use `Lrc<str>` or similar to avoid cloning the `String`.\n+        let src = if let Some(src) = &source_file.src {\n+            src.clone()\n+        } else if let Some(src) = source_file.external_src.borrow().get_source() {\n+            src.clone()\n+        } else {\n             sess.span_diagnostic\n                 .bug(&format!(\"cannot lex `source_file` without source: {}\", source_file.name));\n-        }\n-\n-        let src = (*source_file.src.as_ref().unwrap()).clone();\n+        };\n \n         StringReader {\n             sess,\n@@ -179,14 +187,12 @@ impl<'a> StringReader<'a> {\n             rustc_lexer::TokenKind::LineComment => {\n                 let string = self.str_from(start);\n                 // comments with only more \"/\"s are not doc comments\n-                let tok = if comments::is_line_doc_comment(string) {\n+                if comments::is_line_doc_comment(string) {\n                     self.forbid_bare_cr(start, string, \"bare CR not allowed in doc-comment\");\n                     token::DocComment(Symbol::intern(string))\n                 } else {\n                     token::Comment\n-                };\n-\n-                tok\n+                }\n             }\n             rustc_lexer::TokenKind::BlockComment { terminated } => {\n                 let string = self.str_from(start);\n@@ -204,14 +210,12 @@ impl<'a> StringReader<'a> {\n                     self.fatal_span_(start, last_bpos, msg).raise();\n                 }\n \n-                let tok = if is_doc_comment {\n+                if is_doc_comment {\n                     self.forbid_bare_cr(start, string, \"bare CR not allowed in block doc-comment\");\n                     token::DocComment(Symbol::intern(string))\n                 } else {\n                     token::Comment\n-                };\n-\n-                tok\n+                }\n             }\n             rustc_lexer::TokenKind::Whitespace => token::Whitespace,\n             rustc_lexer::TokenKind::Ident | rustc_lexer::TokenKind::RawIdent => {"}, {"sha": "b205a4b322229da9a3c352993047aff7e6e0d7fe", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -925,8 +925,17 @@ impl<'a> Parser<'a> {\n             self.parse_closure_expr(attrs)\n         } else if self.eat_keyword(kw::If) {\n             self.parse_if_expr(attrs)\n-        } else if self.eat_keyword(kw::For) {\n-            self.parse_for_expr(None, self.prev_token.span, attrs)\n+        } else if self.check_keyword(kw::For) {\n+            if self.choose_generics_over_qpath(1) {\n+                // NOTE(Centril, eddyb): DO NOT REMOVE! Beyond providing parser recovery,\n+                // this is an insurance policy in case we allow qpaths in (tuple-)struct patterns.\n+                // When `for <Foo as Bar>::Proj in $expr $block` is wanted,\n+                // you can disambiguate in favor of a pattern with `(...)`.\n+                self.recover_quantified_closure_expr(attrs)\n+            } else {\n+                assert!(self.eat_keyword(kw::For));\n+                self.parse_for_expr(None, self.prev_token.span, attrs)\n+            }\n         } else if self.eat_keyword(kw::While) {\n             self.parse_while_expr(None, self.prev_token.span, attrs)\n         } else if let Some(label) = self.eat_label() {\n@@ -1417,6 +1426,26 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(blk.span, ExprKind::Block(blk, opt_label), attrs))\n     }\n \n+    /// Recover on an explicitly quantified closure expression, e.g., `for<'a> |x: &'a u8| *x + 1`.\n+    fn recover_quantified_closure_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n+        let lo = self.token.span;\n+        let _ = self.parse_late_bound_lifetime_defs()?;\n+        let span_for = lo.to(self.prev_token.span);\n+        let closure = self.parse_closure_expr(attrs)?;\n+\n+        self.struct_span_err(span_for, \"cannot introduce explicit parameters for a closure\")\n+            .span_label(closure.span, \"the parameters are attached to this closure\")\n+            .span_suggestion(\n+                span_for,\n+                \"remove the parameters\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+\n+        Ok(self.mk_expr_err(lo.to(closure.span)))\n+    }\n+\n     /// Parses a closure expression (e.g., `move |args| expr`).\n     fn parse_closure_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;"}, {"sha": "3442c5081c18f879c07ddded71faf7cb3fe6f750", "filename": "src/librustc_parse/parser/generics.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -181,7 +181,7 @@ impl<'a> Parser<'a> {\n         // We are considering adding generics to the `where` keyword as an alternative higher-rank\n         // parameter syntax (as in `where<'a>` or `where<T>`. To avoid that being a breaking\n         // change we parse those generics now, but report an error.\n-        if self.choose_generics_over_qpath() {\n+        if self.choose_generics_over_qpath(0) {\n             let generics = self.parse_generics()?;\n             self.struct_span_err(\n                 generics.span,\n@@ -257,7 +257,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn choose_generics_over_qpath(&self) -> bool {\n+    pub(super) fn choose_generics_over_qpath(&self, start: usize) -> bool {\n         // There's an ambiguity between generic parameters and qualified paths in impls.\n         // If we see `<` it may start both, so we have to inspect some following tokens.\n         // The following combinations can only start generics,\n@@ -274,15 +274,12 @@ impl<'a> Parser<'a> {\n         // we disambiguate it in favor of generics (`impl<T> ::absolute::Path<T> { ... }`)\n         // because this is what almost always expected in practice, qualified paths in impls\n         // (`impl <Type>::AssocTy { ... }`) aren't even allowed by type checker at the moment.\n-        self.token == token::Lt\n-            && (self.look_ahead(1, |t| t == &token::Pound || t == &token::Gt)\n-                || self.look_ahead(1, |t| t.is_lifetime() || t.is_ident())\n-                    && self.look_ahead(2, |t| {\n-                        t == &token::Gt\n-                            || t == &token::Comma\n-                            || t == &token::Colon\n-                            || t == &token::Eq\n+        self.look_ahead(start, |t| t == &token::Lt)\n+            && (self.look_ahead(start + 1, |t| t == &token::Pound || t == &token::Gt)\n+                || self.look_ahead(start + 1, |t| t.is_lifetime() || t.is_ident())\n+                    && self.look_ahead(start + 2, |t| {\n+                        matches!(t.kind, token::Gt | token::Comma | token::Colon | token::Eq)\n                     })\n-                || self.is_keyword_ahead(1, &[kw::Const]))\n+                || self.is_keyword_ahead(start + 1, &[kw::Const]))\n     }\n }"}, {"sha": "7a4f76804157f56df3ae750df3b0f6d160777579", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -458,7 +458,7 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(kw::Impl)?;\n \n         // First, parse generic parameters if necessary.\n-        let mut generics = if self.choose_generics_over_qpath() {\n+        let mut generics = if self.choose_generics_over_qpath(0) {\n             self.parse_generics()?\n         } else {\n             let mut generics = Generics::default();"}, {"sha": "fddfe48bf86700969e5b5f431418f493a2b8b17d", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -217,13 +217,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses the RHS of a local variable declaration (e.g., '= 14;').\n     fn parse_initializer(&mut self, skip_eq: bool) -> PResult<'a, Option<P<Expr>>> {\n-        if self.eat(&token::Eq) {\n-            Ok(Some(self.parse_expr()?))\n-        } else if skip_eq {\n-            Ok(Some(self.parse_expr()?))\n-        } else {\n-            Ok(None)\n-        }\n+        if self.eat(&token::Eq) || skip_eq { Ok(Some(self.parse_expr()?)) } else { Ok(None) }\n     }\n \n     /// Parses a block. No inner attributes are allowed."}, {"sha": "77d6e4560ab9374960233e5dc814a713cfa92476", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -750,14 +750,16 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if let Some(ctor_node_id) = vdata.ctor_id() {\n-                    let mut ctor_vis = vis;\n                     // If the structure is marked as non_exhaustive then lower the visibility\n                     // to within the crate.\n-                    if vis == ty::Visibility::Public\n+                    let mut ctor_vis = if vis == ty::Visibility::Public\n                         && attr::contains_name(&item.attrs, sym::non_exhaustive)\n                     {\n-                        ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                    }\n+                        ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+                    } else {\n+                        vis\n+                    };\n+\n                     for field in vdata.fields() {\n                         // NOTE: The field may be an expansion placeholder, but expansion sets\n                         // correct visibilities for unnamed field placeholders specifically, so the\n@@ -1166,7 +1168,7 @@ macro_rules! method {\n                 visit::$walk(self, node);\n             }\n         }\n-    }\n+    };\n }\n \n impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {"}, {"sha": "9e5ff32391486e2279e8aa840de51b641119bdaf", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -59,8 +59,7 @@ crate struct ImportSuggestion {\n /// `source_map` functions and this function to something more robust.\n fn reduce_impl_span_to_impl_keyword(sm: &SourceMap, impl_span: Span) -> Span {\n     let impl_span = sm.span_until_char(impl_span, '<');\n-    let impl_span = sm.span_until_whitespace(impl_span);\n-    impl_span\n+    sm.span_until_whitespace(impl_span)\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "5b112677cf77fabd86ff7cd0e18579a1b78b7c5a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -1871,16 +1871,15 @@ impl<'a> Resolver<'a> {\n                 // No adjustments\n             }\n         }\n-        let result = self.resolve_ident_in_module_unadjusted_ext(\n+        self.resolve_ident_in_module_unadjusted_ext(\n             module,\n             ident,\n             ns,\n             adjusted_parent_scope,\n             false,\n             record_used,\n             path_span,\n-        );\n-        result\n+        )\n     }\n \n     fn resolve_crate_root(&mut self, ident: Ident) -> Module<'a> {"}, {"sha": "28864737072b291051012d2349b06587c0cd21bf", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -856,7 +856,7 @@ pub enum ExternalSource {\n #[derive(PartialEq, Eq, Clone, Debug)]\n pub enum ExternalSourceKind {\n     /// The external source has been loaded already.\n-    Present(String),\n+    Present(Lrc<String>),\n     /// No attempt has been made to load the external source.\n     AbsentOk,\n     /// A failed attempt has been made to load the external source.\n@@ -872,7 +872,7 @@ impl ExternalSource {\n         }\n     }\n \n-    pub fn get_source(&self) -> Option<&str> {\n+    pub fn get_source(&self) -> Option<&Lrc<String>> {\n         match self {\n             ExternalSource::Foreign { kind: ExternalSourceKind::Present(ref src), .. } => Some(src),\n             _ => None,\n@@ -1138,7 +1138,7 @@ impl SourceFile {\n                     hasher.write(src.as_bytes());\n \n                     if hasher.finish::<u128>() == self.src_hash {\n-                        *src_kind = ExternalSourceKind::Present(src);\n+                        *src_kind = ExternalSourceKind::Present(Lrc::new(src));\n                         return true;\n                     }\n                 } else {"}, {"sha": "8f806909f004731b527bc3d53a4460ff6e0f8b71", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -370,11 +370,11 @@ impl SourceMap {\n     pub fn doctest_offset_line(&self, file: &FileName, orig: usize) -> usize {\n         match file {\n             FileName::DocTest(_, offset) => {\n-                return if *offset >= 0 {\n-                    orig + *offset as usize\n-                } else {\n+                if *offset < 0 {\n                     orig - (-(*offset)) as usize\n-                };\n+                } else {\n+                    orig + *offset as usize\n+                }\n             }\n             _ => orig,\n         }"}, {"sha": "4ad65569e6a8a9ce93a0dd135c5aaf2b202848ba", "filename": "src/librustc_target/spec/apple_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_target%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_target%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_base.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -57,7 +57,7 @@ pub fn macos_link_env_remove() -> Vec<String> {\n     let mut env_remove = Vec::with_capacity(2);\n     // Remove the `SDKROOT` environment variable if it's clearly set for the wrong platform, which\n     // may occur when we're linking a custom build script while targeting iOS for example.\n-    if let Some(sdkroot) = env::var(\"SDKROOT\").ok() {\n+    if let Ok(sdkroot) = env::var(\"SDKROOT\") {\n         if sdkroot.contains(\"iPhoneOS.platform\") || sdkroot.contains(\"iPhoneSimulator.platform\") {\n             env_remove.push(\"SDKROOT\".to_string())\n         }"}, {"sha": "c7cff17b1544c8614e83da29150dec827137880e", "filename": "src/librustc_target/spec/apple_sdk_base.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_target%2Fspec%2Fapple_sdk_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_target%2Fspec%2Fapple_sdk_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fapple_sdk_base.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -43,40 +43,26 @@ pub fn get_sdk_root(sdk_name: &str) -> Result<String, String> {\n     // to allow the SDK path to be set. (For clang, xcrun sets\n     // SDKROOT; for rustc, the user or build system can set it, or we\n     // can fall back to checking for xcrun on PATH.)\n-    if let Some(sdkroot) = env::var(\"SDKROOT\").ok() {\n+    if let Ok(sdkroot) = env::var(\"SDKROOT\") {\n         let p = Path::new(&sdkroot);\n         match sdk_name {\n             // Ignore `SDKROOT` if it's clearly set for the wrong platform.\n             \"appletvos\"\n                 if sdkroot.contains(\"TVSimulator.platform\")\n-                    || sdkroot.contains(\"MacOSX.platform\") =>\n-            {\n-                ()\n-            }\n+                    || sdkroot.contains(\"MacOSX.platform\") => {}\n             \"appletvsimulator\"\n-                if sdkroot.contains(\"TVOS.platform\") || sdkroot.contains(\"MacOSX.platform\") =>\n-            {\n-                ()\n-            }\n+                if sdkroot.contains(\"TVOS.platform\") || sdkroot.contains(\"MacOSX.platform\") => {}\n             \"iphoneos\"\n                 if sdkroot.contains(\"iPhoneSimulator.platform\")\n-                    || sdkroot.contains(\"MacOSX.platform\") =>\n-            {\n-                ()\n-            }\n+                    || sdkroot.contains(\"MacOSX.platform\") => {}\n             \"iphonesimulator\"\n-                if sdkroot.contains(\"iPhoneOS.platform\") || sdkroot.contains(\"MacOSX.platform\") =>\n-            {\n-                ()\n+                if sdkroot.contains(\"iPhoneOS.platform\") || sdkroot.contains(\"MacOSX.platform\") => {\n             }\n             \"macosx10.15\"\n                 if sdkroot.contains(\"iPhoneOS.platform\")\n-                    || sdkroot.contains(\"iPhoneSimulator.platform\") =>\n-            {\n-                ()\n-            }\n+                    || sdkroot.contains(\"iPhoneSimulator.platform\") => {}\n             // Ignore `SDKROOT` if it's not a valid path.\n-            _ if !p.is_absolute() || p == Path::new(\"/\") || !p.exists() => (),\n+            _ if !p.is_absolute() || p == Path::new(\"/\") || !p.exists() => {}\n             _ => return Ok(sdkroot),\n         }\n     }"}, {"sha": "ca169d550e782031ba24a1179db596f8243b54ce", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -2792,7 +2792,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 trait_def_id, trait_obligations\n             );\n \n-            VtableTraitAliasData { alias_def_id, substs: substs, nested: trait_obligations }\n+            VtableTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n         })\n     }\n "}, {"sha": "7ed828c91679cc98c3222fbdd271e3e3f5376ac7", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -80,11 +80,11 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        Ok(self\n-            .infcx\n+        self.infcx\n             .at(&ObligationCause::dummy(), self.param_env)\n             .relate(a, variance, b)?\n-            .into_value_registering_obligations(self.infcx, self.fulfill_cx))\n+            .into_value_registering_obligations(self.infcx, self.fulfill_cx);\n+        Ok(())\n     }\n \n     fn prove_predicate(&mut self, predicate: Predicate<'tcx>) {\n@@ -165,10 +165,11 @@ fn type_op_eq<'tcx>(\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n         let (param_env, Eq { a, b }) = key.into_parts();\n-        Ok(infcx\n+        infcx\n             .at(&ObligationCause::dummy(), param_env)\n             .eq(a, b)?\n-            .into_value_registering_obligations(infcx, fulfill_cx))\n+            .into_value_registering_obligations(infcx, fulfill_cx);\n+        Ok(())\n     })\n }\n \n@@ -221,10 +222,11 @@ fn type_op_subtype<'tcx>(\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n         let (param_env, Subtype { sub, sup }) = key.into_parts();\n-        Ok(infcx\n+        infcx\n             .at(&ObligationCause::dummy(), param_env)\n             .sup(sup, sub)?\n-            .into_value_registering_obligations(infcx, fulfill_cx))\n+            .into_value_registering_obligations(infcx, fulfill_cx);\n+        Ok(())\n     })\n }\n "}, {"sha": "7203980b2388f482467b394208143abf973a4441", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -1069,16 +1069,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         });\n \n-        let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| {\n-            let t = match flds {\n-                Some(ref fs) if i < fs.len() => {\n-                    let ety = fs[i].expect_ty();\n-                    self.check_expr_coercable_to_type(&e, ety);\n-                    ety\n-                }\n-                _ => self.check_expr_with_expectation(&e, NoExpectation),\n-            };\n-            t\n+        let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| match flds {\n+            Some(ref fs) if i < fs.len() => {\n+                let ety = fs[i].expect_ty();\n+                self.check_expr_coercable_to_type(&e, ety);\n+                ety\n+            }\n+            _ => self.check_expr_with_expectation(&e, NoExpectation),\n         });\n         let tuple = self.tcx.mk_tup(elt_ts_iter);\n         if tuple.references_error() {"}, {"sha": "7068e3c521c81797695c0bd8e08ca36920b364b1", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -368,11 +368,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let fn_sig = tcx.fn_sig(def_id);\n         let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, &fn_sig).0;\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n-        let fn_sig = match self.normalize_associated_types_in_as_infer_ok(span, &fn_sig) {\n-            InferOk { value, obligations: o } => {\n-                obligations.extend(o);\n-                value\n-            }\n+\n+        let InferOk { value, obligations: o } =\n+            self.normalize_associated_types_in_as_infer_ok(span, &fn_sig);\n+        let fn_sig = {\n+            obligations.extend(o);\n+            value\n         };\n \n         // Register obligations for the parameters. This will include the\n@@ -384,12 +385,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Note that as the method comes from a trait, it should not have\n         // any late-bound regions appearing in its bounds.\n         let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n-        let bounds = match self.normalize_associated_types_in_as_infer_ok(span, &bounds) {\n-            InferOk { value, obligations: o } => {\n-                obligations.extend(o);\n-                value\n-            }\n+\n+        let InferOk { value, obligations: o } =\n+            self.normalize_associated_types_in_as_infer_ok(span, &bounds);\n+        let bounds = {\n+            obligations.extend(o);\n+            value\n         };\n+\n         assert!(!bounds.has_escaping_bound_vars());\n \n         let cause = traits::ObligationCause::misc(span, self.body_id);"}, {"sha": "32f0f578d057f3a25a0bccc2411a34c15d300ed7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -3654,14 +3654,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Otherwise, fall back to the immutable version.\n         let (imm_tr, imm_op) = self.resolve_place_op(op, false);\n-        let method = match (method, imm_tr) {\n+        match (method, imm_tr) {\n             (None, Some(trait_did)) => {\n                 self.lookup_method_in_trait(span, imm_op, trait_did, base_ty, Some(arg_tys))\n             }\n             (method, _) => method,\n-        };\n-\n-        method\n+        }\n     }\n \n     fn check_method_argument_types("}, {"sha": "d0a87e240da8936179ac47ed2e86a0ba3fcfa2ab", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -178,10 +178,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n             use ty::TyKind::*;\n             match (&source.kind, &target.kind) {\n                 (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n-                    if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok() && mutbl_a == *mutbl_b =>\n-                {\n-                    ()\n-                }\n+                    if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok() && mutbl_a == *mutbl_b => {}\n                 (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n                 (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n                     if def_a.is_struct() && def_b.is_struct() =>"}, {"sha": "55642dfb4557b3f6c073180f0030809f86080861", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -256,15 +256,18 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         // figure out which generic parameter it corresponds to and return\n                         // the relevant type.\n                         let generics = match path.res {\n-                            Res::Def(DefKind::Ctor(..), def_id) => {\n+                            Res::Def(DefKind::Ctor(..), def_id)\n+                            | Res::Def(DefKind::AssocTy, def_id) => {\n                                 tcx.generics_of(tcx.parent(def_id).unwrap())\n                             }\n                             Res::Def(_, def_id) => tcx.generics_of(def_id),\n-                            Res::Err => return tcx.types.err,\n                             res => {\n                                 tcx.sess.delay_span_bug(\n                                     DUMMY_SP,\n-                                    &format!(\"unexpected const parent path def {:?}\", res,),\n+                                    &format!(\n+                                        \"unexpected const parent path def, parent: {:?}, def: {:?}\",\n+                                        parent_node, res\n+                                    ),\n                                 );\n                                 return tcx.types.err;\n                             }\n@@ -284,7 +287,16 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                             .map(|param| tcx.type_of(param.def_id))\n                             // This is no generic parameter associated with the arg. This is\n                             // probably from an extra arg where one is not needed.\n-                            .unwrap_or(tcx.types.err)\n+                            .unwrap_or_else(|| {\n+                                tcx.sess.delay_span_bug(\n+                                    DUMMY_SP,\n+                                    &format!(\n+                                        \"missing generic parameter for `AnonConst`, parent {:?}\",\n+                                        parent_node\n+                                    ),\n+                                );\n+                                tcx.types.err\n+                            })\n                     } else {\n                         tcx.sess.delay_span_bug(\n                             DUMMY_SP,"}, {"sha": "82e34710f0cbf122c9d52dd71c458a13129d25b7", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -507,7 +507,7 @@ pub fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n }\n \n pub fn print_evaluated_const(cx: &DocContext<'_>, def_id: DefId) -> Option<String> {\n-    let value = cx.tcx.const_eval_poly(def_id).ok().and_then(|val| {\n+    cx.tcx.const_eval_poly(def_id).ok().and_then(|val| {\n         let ty = cx.tcx.type_of(def_id);\n         match (val, &ty.kind) {\n             (_, &ty::Ref(..)) => None,\n@@ -518,9 +518,7 @@ pub fn print_evaluated_const(cx: &DocContext<'_>, def_id: DefId) -> Option<Strin\n             }\n             _ => None,\n         }\n-    });\n-\n-    value\n+    })\n }\n \n fn format_integer_with_underscore_sep(num: &str) -> String {"}, {"sha": "b93738319a634841fecbb3b6f4ca3f3b39459985", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -666,13 +666,12 @@ fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n }\n \n fn get_index_type(clean_type: &clean::Type) -> RenderType {\n-    let t = RenderType {\n+    RenderType {\n         ty: clean_type.def_id(),\n         idx: None,\n         name: get_index_type_name(clean_type, true).map(|s| s.to_ascii_lowercase()),\n         generics: get_generics(clean_type),\n-    };\n-    t\n+    }\n }\n \n fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<String> {"}, {"sha": "9dd1d3706ffbd61347d58b304fb598ba916fe003", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -234,9 +234,7 @@ pub fn load_css_paths(v: &[u8]) -> CssPath {\n }\n \n pub fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n-    if against.name != other.name {\n-        return;\n-    } else {\n+    if against.name == other.name {\n         for child in &against.children {\n             let mut found = false;\n             let mut found_working = false;"}, {"sha": "282e268efd20686f35fba68a792d3f4f96ce432e", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -1082,8 +1082,8 @@ impl ThreadId {\n     /// it is not guaranteed which values new threads will return, and this may\n     /// change across Rust versions.\n     #[unstable(feature = \"thread_id_value\", issue = \"67939\")]\n-    pub fn as_u64(&self) -> u64 {\n-        self.0.get()\n+    pub fn as_u64(&self) -> NonZeroU64 {\n+        self.0\n     }\n }\n "}, {"sha": "461fe837dac44a105c8d55ab3cde18cbc9a9f660", "filename": "src/test/ui/const-generics/issues/issue-66906.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66906.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+pub struct Tuple;\n+\n+pub trait Trait<const I: usize> {\n+    type Input: From<<Self as Trait<I>>::Input>;\n+}\n+\n+fn main() {}"}, {"sha": "f8710b67b687e153308643a4875012731a8d168a", "filename": "src/test/ui/const-generics/issues/issue-66906.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66906.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66906.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66906.stderr?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-66906.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "58fac8e05114a68c8cb095f48a1cbdbbd02cdc26", "filename": "src/test/ui/const-generics/issues/issue-70167.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70167.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+pub trait Trait<const N: usize>: From<<Self as Trait<N>>::Item> {\n+  type Item;\n+}\n+\n+fn main() {}"}, {"sha": "4ba3c204097dcaf05595b7b6eab3edfef6aeaf77", "filename": "src/test/ui/const-generics/issues/issue-70167.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70167.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70167.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70167.stderr?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-70167.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "381324738f62b851d53160978a03f6d2541e0a13", "filename": "src/test/ui/parser/recover-quantified-closure.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fparser%2Frecover-quantified-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fparser%2Frecover-quantified-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-quantified-closure.rs?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    for<'a> |x: &'a u8| *x + 1;\n+    //~^ ERROR cannot introduce explicit parameters for a closure\n+}\n+\n+enum Foo { Bar }\n+fn foo(x: impl Iterator<Item = Foo>) {\n+    for <Foo>::Bar in x {}\n+    //~^ ERROR expected one of `move`, `static`, `|`\n+}"}, {"sha": "0f01132651648b95a7e9d81d98c8fb4de9c91e38", "filename": "src/test/ui/parser/recover-quantified-closure.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fparser%2Frecover-quantified-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fparser%2Frecover-quantified-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-quantified-closure.stderr?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -0,0 +1,16 @@\n+error: cannot introduce explicit parameters for a closure\n+  --> $DIR/recover-quantified-closure.rs:2:5\n+   |\n+LL |     for<'a> |x: &'a u8| *x + 1;\n+   |     ^^^^^^^ ------------------ the parameters are attached to this closure\n+   |     |\n+   |     help: remove the parameters\n+\n+error: expected one of `move`, `static`, `|`, or `||`, found `::`\n+  --> $DIR/recover-quantified-closure.rs:8:14\n+   |\n+LL |     for <Foo>::Bar in x {}\n+   |              ^^ expected one of `move`, `static`, `|`, or `||`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "36a6a9bb3e72ba07d653e867d74a3ecb3cc82666", "filename": "src/test/ui/proc-macro/export-macro.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fproc-macro%2Fexport-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fproc-macro%2Fexport-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexport-macro.stderr?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -1,10 +1,8 @@\n error: cannot export macro_rules! macros from a `proc-macro` crate type currently\n   --> $DIR/export-macro.rs:9:1\n    |\n-LL | / macro_rules! foo {\n-LL | |     ($e:expr) => ($e)\n-LL | | }\n-   | |_^\n+LL | macro_rules! foo {\n+   | ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "7b23d08f2a8a57bdcdefca923d4905ddb88360f9", "filename": "src/test/ui/proc-macro/exports.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fproc-macro%2Fexports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fproc-macro%2Fexports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexports.stderr?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -2,7 +2,7 @@ error: `proc-macro` crate types currently cannot export any items other than fun\n   --> $DIR/exports.rs:7:1\n    |\n LL | pub fn a() {}\n-   | ^^^^^^^^^^^^^\n+   | ^^^^^^^^^^\n \n error: `proc-macro` crate types currently cannot export any items other than functions tagged with `#[proc_macro]`, `#[proc_macro_derive]`, or `#[proc_macro_attribute]`\n   --> $DIR/exports.rs:8:1\n@@ -14,13 +14,13 @@ error: `proc-macro` crate types currently cannot export any items other than fun\n   --> $DIR/exports.rs:9:1\n    |\n LL | pub enum C {}\n-   | ^^^^^^^^^^^^^\n+   | ^^^^^^^^^^\n \n error: `proc-macro` crate types currently cannot export any items other than functions tagged with `#[proc_macro]`, `#[proc_macro_derive]`, or `#[proc_macro_attribute]`\n   --> $DIR/exports.rs:10:1\n    |\n LL | pub mod d {}\n-   | ^^^^^^^^^^^^\n+   | ^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "90f94b677e90f20206ea244f71404e920204c9e6", "filename": "src/test/ui/proc-macro/non-root.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fproc-macro%2Fnon-root.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fproc-macro%2Fnon-root.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnon-root.stderr?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -2,7 +2,7 @@ error: functions tagged with `#[proc_macro]` must currently reside in the root o\n   --> $DIR/non-root.rs:11:5\n    |\n LL |     pub fn foo(arg: TokenStream) -> TokenStream { arg }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "2e7536a0c4f09c9b5eb77e7dcd6cacaad3fba574", "filename": "src/test/ui/proc-macro/pub-at-crate-root.stderr", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fproc-macro%2Fpub-at-crate-root.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1902d1e0de179498d0cb7fd4856d1e0ffcd52095/src%2Ftest%2Fui%2Fproc-macro%2Fpub-at-crate-root.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fpub-at-crate-root.stderr?ref=1902d1e0de179498d0cb7fd4856d1e0ffcd52095", "patch": "@@ -1,32 +1,20 @@\n error: `proc-macro` crate types currently cannot export any items other than functions tagged with `#[proc_macro]`, `#[proc_macro_derive]`, or `#[proc_macro_attribute]`\n   --> $DIR/pub-at-crate-root.rs:8:1\n    |\n-LL | / pub mod a {\n-LL | |     use proc_macro::TokenStream;\n-LL | |\n-LL | |     #[proc_macro_derive(B)]\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n+LL | pub mod a {\n+   | ^^^^^^^^^\n \n error: functions tagged with `#[proc_macro_derive]` must currently reside in the root of the crate\n   --> $DIR/pub-at-crate-root.rs:12:5\n    |\n-LL | /     pub fn bar(a: TokenStream) -> TokenStream {\n-LL | |\n-LL | |         a\n-LL | |     }\n-   | |_____^\n+LL |     pub fn bar(a: TokenStream) -> TokenStream {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: functions tagged with `#[proc_macro_derive]` must be `pub`\n   --> $DIR/pub-at-crate-root.rs:19:1\n    |\n-LL | / fn bar(a: proc_macro::TokenStream) -> proc_macro::TokenStream {\n-LL | |\n-LL | |     a\n-LL | | }\n-   | |_^\n+LL | fn bar(a: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}]}