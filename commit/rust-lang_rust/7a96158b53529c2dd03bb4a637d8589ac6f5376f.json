{"sha": "7a96158b53529c2dd03bb4a637d8589ac6f5376f", "node_id": "C_kwDOAAsO6NoAKDdhOTYxNThiNTM1MjljMmRkMDNiYjRhNjM3ZDg1ODlhYzZmNTM3NmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-28T23:13:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-28T23:13:42Z"}, "message": "Auto merge of #110967 - matthiaskrgr:rollup-vfbl7gm, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #110877 (Provide better type hints when a type doesn't support a binary operator)\n - #110917 (only error combining +whole-archive and +bundle for rlibs)\n - #110921 (Use `NonNull::new_unchecked` and `NonNull::len` in `rustc_arena`.)\n - #110927 (Encoder/decoder cleanups)\n - #110944 (share BinOp::Offset between CTFE and Miri)\n - #110948 (run-make test: using single quotes to not trigger the shell)\n - #110957 (Fix an ICE in conflict error diagnostics)\n - #110960 (fix false negative for `unused_mut`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9217d20a1cd88242c8c51eb0e117e78b3e906576", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9217d20a1cd88242c8c51eb0e117e78b3e906576"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a96158b53529c2dd03bb4a637d8589ac6f5376f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a96158b53529c2dd03bb4a637d8589ac6f5376f", "html_url": "https://github.com/rust-lang/rust/commit/7a96158b53529c2dd03bb4a637d8589ac6f5376f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a96158b53529c2dd03bb4a637d8589ac6f5376f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4956053816439a5884cb2ad1247835858f92218", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4956053816439a5884cb2ad1247835858f92218", "html_url": "https://github.com/rust-lang/rust/commit/f4956053816439a5884cb2ad1247835858f92218"}, {"sha": "34ef13b15b0c88bfbc89d4404c2e3ea1b24bbc38", "url": "https://api.github.com/repos/rust-lang/rust/commits/34ef13b15b0c88bfbc89d4404c2e3ea1b24bbc38", "html_url": "https://github.com/rust-lang/rust/commit/34ef13b15b0c88bfbc89d4404c2e3ea1b24bbc38"}], "stats": {"total": 791, "additions": 449, "deletions": 342}, "files": [{"sha": "236bdb99709e82f814a6a280ebad0c223213b039", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -74,7 +74,7 @@ impl<T> ArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> ArenaChunk<T> {\n         ArenaChunk {\n-            storage: NonNull::new(Box::into_raw(Box::new_uninit_slice(capacity))).unwrap(),\n+            storage: NonNull::new_unchecked(Box::into_raw(Box::new_uninit_slice(capacity))),\n             entries: 0,\n         }\n     }\n@@ -85,7 +85,7 @@ impl<T> ArenaChunk<T> {\n         // The branch on needs_drop() is an -O1 performance optimization.\n         // Without the branch, dropping TypedArena<u8> takes linear time.\n         if mem::needs_drop::<T>() {\n-            let slice = &mut *(self.storage.as_mut());\n+            let slice = self.storage.as_mut();\n             ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut slice[..len]));\n         }\n     }\n@@ -104,7 +104,7 @@ impl<T> ArenaChunk<T> {\n                 // A pointer as large as possible for zero-sized elements.\n                 ptr::invalid_mut(!0)\n             } else {\n-                self.start().add((*self.storage.as_ptr()).len())\n+                self.start().add(self.storage.len())\n             }\n         }\n     }\n@@ -288,7 +288,7 @@ impl<T> TypedArena<T> {\n                 // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = (*last_chunk.storage.as_ptr()).len().min(HUGE_PAGE / elem_size / 2);\n+                new_cap = last_chunk.storage.len().min(HUGE_PAGE / elem_size / 2);\n                 new_cap *= 2;\n             } else {\n                 new_cap = PAGE / elem_size;\n@@ -396,7 +396,7 @@ impl DroplessArena {\n                 // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = (*last_chunk.storage.as_ptr()).len().min(HUGE_PAGE / 2);\n+                new_cap = last_chunk.storage.len().min(HUGE_PAGE / 2);\n                 new_cap *= 2;\n             } else {\n                 new_cap = PAGE;"}, {"sha": "7ab8c3eaba2273d96a6a4693dc53653f314eba36", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -360,7 +360,7 @@ impl Printer {\n \n     fn check_stack(&mut self, mut depth: usize) {\n         while let Some(&index) = self.scan_stack.back() {\n-            let mut entry = &mut self.buf[index];\n+            let entry = &mut self.buf[index];\n             match entry.token {\n                 Token::Begin(_) => {\n                     if depth == 0 {"}, {"sha": "ac84188a35fb1e3d43b34b68f8ad0178874fff96", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -1359,7 +1359,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         // Get closure's arguments\n-        let ty::Closure(_, substs) = typeck_results.expr_ty(closure_expr).kind() else { unreachable!() };\n+        let ty::Closure(_, substs) = typeck_results.expr_ty(closure_expr).kind() else { /* hir::Closure can be a generator too */ return };\n         let sig = substs.as_closure().sig();\n         let tupled_params =\n             tcx.erase_late_bound_regions(sig.inputs().iter().next().unwrap().map_bound(|&b| b));"}, {"sha": "6900729d671a07e04041a77b5133f7dab38e21b4", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -935,6 +935,7 @@ enum InitializationRequiringAction {\n     PartialAssignment,\n }\n \n+#[derive(Debug)]\n struct RootPlace<'tcx> {\n     place_local: Local,\n     place_projection: &'tcx [PlaceElem<'tcx>],\n@@ -1848,11 +1849,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // is allowed, remove this match arm.\n                         ty::Adt(..) | ty::Tuple(..) => {\n                             check_parent_of_field(self, location, place_base, span, flow_state);\n-\n-                            // rust-lang/rust#21232, #54499, #54986: during period where we reject\n-                            // partial initialization, do not complain about unnecessary `mut` on\n-                            // an attempt to do a partial initialization.\n-                            self.used_mut.insert(place.local);\n                         }\n \n                         _ => {}\n@@ -1940,6 +1936,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     (prefix, base, span),\n                     mpi,\n                 );\n+\n+                // rust-lang/rust#21232, #54499, #54986: during period where we reject\n+                // partial initialization, do not complain about unnecessary `mut` on\n+                // an attempt to do a partial initialization.\n+                this.used_mut.insert(base.local);\n             }\n         }\n     }"}, {"sha": "842e90080582f5b7f40bf4059e0c5634a12c2a7e", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -221,7 +221,7 @@ fn append_list(\n ) {\n     let mut p = target_list;\n     loop {\n-        let mut r = &mut constraints[p];\n+        let r = &mut constraints[p];\n         match r.next_constraint {\n             Some(q) => p = q,\n             None => {"}, {"sha": "eecfe13bb3eeff8c8ed8148b6f92fed095955ea9", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -349,7 +349,10 @@ fn link_rlib<'a>(\n         let NativeLibKind::Static { bundle: None | Some(true), whole_archive } = lib.kind else {\n             continue;\n         };\n-        if whole_archive == Some(true) && !codegen_results.crate_info.feature_packed_bundled_libs {\n+        if whole_archive == Some(true)\n+            && flavor == RlibFlavor::Normal\n+            && !codegen_results.crate_info.feature_packed_bundled_libs\n+        {\n             sess.emit_err(errors::IncompatibleLinkingModifiers);\n         }\n         if flavor == RlibFlavor::Normal && let Some(filename) = lib.filename {"}, {"sha": "814b67b46ec7a239e726a45add6304d62f662d03", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -559,20 +559,11 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn binary_ptr_op(\n-        ecx: &InterpCx<'mir, 'tcx, Self>,\n-        bin_op: mir::BinOp,\n-        left: &ImmTy<'tcx>,\n-        right: &ImmTy<'tcx>,\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _bin_op: mir::BinOp,\n+        _left: &ImmTy<'tcx>,\n+        _right: &ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        if bin_op == mir::BinOp::Offset {\n-            let ptr = left.to_scalar().to_pointer(ecx)?;\n-            let offset_count = right.to_scalar().to_target_isize(ecx)?;\n-            let pointee_ty = left.layout.ty.builtin_deref(true).unwrap().ty;\n-\n-            let offset_ptr = ecx.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n-            return Ok((Scalar::from_maybe_pointer(offset_ptr, ecx), false, left.layout.ty));\n-        }\n-\n         throw_unsup_format!(\"pointer arithmetic or comparison is not supported at compile-time\");\n     }\n "}, {"sha": "7186148daf0ba80c8f73abcf1abe28db2698a136", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -299,6 +299,30 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok((val, false, ty))\n     }\n \n+    fn binary_ptr_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: &ImmTy<'tcx, M::Provenance>,\n+        right: &ImmTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<M::Provenance>, bool, Ty<'tcx>)> {\n+        use rustc_middle::mir::BinOp::*;\n+\n+        match bin_op {\n+            // Pointer ops that are always supported.\n+            Offset => {\n+                let ptr = left.to_scalar().to_pointer(self)?;\n+                let offset_count = right.to_scalar().to_target_isize(self)?;\n+                let pointee_ty = left.layout.ty.builtin_deref(true).unwrap().ty;\n+\n+                let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n+                Ok((Scalar::from_maybe_pointer(offset_ptr, self), false, left.layout.ty))\n+            }\n+\n+            // Fall back to machine hook so Miri can support more pointer ops.\n+            _ => M::binary_ptr_op(self, bin_op, left, right),\n+        }\n+    }\n+\n     /// Returns the result of the specified operation, whether it overflowed, and\n     /// the result type.\n     pub fn overflowing_binary_op(\n@@ -368,7 +392,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     right.layout.ty\n                 );\n \n-                M::binary_ptr_op(self, bin_op, left, right)\n+                self.binary_ptr_op(bin_op, left, right)\n             }\n             _ => span_bug!(\n                 self.cur_span(),"}, {"sha": "e220a0293393e6b0de8c6efc20bd622d43ab8a8a", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -26,7 +26,7 @@ use rustc_target::spec::abi::Abi;\n use smallvec::SmallVec;\n use std::fmt;\n \n-#[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, HashStable_Generic)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n \n@@ -41,8 +41,7 @@ pub struct Lifetime {\n     pub res: LifetimeName,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Encodable, Hash, Copy)]\n-#[derive(HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, HashStable_Generic)]\n pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n     Plain(Ident),\n@@ -85,8 +84,7 @@ impl ParamName {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Encodable, Hash, Copy)]\n-#[derive(HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable_Generic)]\n pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(LocalDefId),\n@@ -243,13 +241,13 @@ impl<'hir> PathSegment<'hir> {\n     }\n }\n \n-#[derive(Encodable, Clone, Copy, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, Debug, HashStable_Generic)]\n pub struct ConstArg {\n     pub value: AnonConst,\n     pub span: Span,\n }\n \n-#[derive(Encodable, Clone, Copy, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, Debug, HashStable_Generic)]\n pub struct InferArg {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -422,8 +420,7 @@ impl<'hir> GenericArgs<'hir> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, HashStable_Generic)]\n pub enum GenericArgsParentheses {\n     No,\n     /// Bounds for `feature(return_type_notation)`, like `T: Trait<method(..): Send>`,\n@@ -435,8 +432,7 @@ pub enum GenericArgsParentheses {\n \n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum TraitBoundModifier {\n     None,\n     Maybe,\n@@ -474,7 +470,7 @@ impl GenericBound<'_> {\n \n pub type GenericBounds<'hir> = &'hir [GenericBound<'hir>];\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum LifetimeParamKind {\n     // Indicates that the lifetime definition was explicitly declared (e.g., in\n     // `fn foo<'a>(x: &'a u8) -> &'a u8 { x }`).\n@@ -539,7 +535,7 @@ impl<'hir> GenericParam<'hir> {\n /// early-bound (but can be a late-bound lifetime in functions, for example),\n /// or from a `for<...>` binder, in which case it's late-bound (and notably,\n /// does not show up in the parent item's generics).\n-#[derive(Debug, HashStable_Generic, PartialEq, Eq, Copy, Clone)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum GenericParamSource {\n     // Early or late-bound parameters defined on an item\n     Generics,\n@@ -1097,7 +1093,7 @@ pub struct PatField<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum RangeEnd {\n     Included,\n     Excluded,\n@@ -1197,7 +1193,7 @@ pub enum PatKind<'hir> {\n     Slice(&'hir [Pat<'hir>], Option<&'hir Pat<'hir>>, &'hir [Pat<'hir>]),\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1325,7 +1321,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum UnOp {\n     /// The `*` operator (dereferencing).\n     Deref,\n@@ -1450,19 +1446,19 @@ pub struct ExprField<'hir> {\n     pub is_shorthand: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct BodyId {\n     pub hir_id: HirId,\n }\n@@ -1506,7 +1502,7 @@ impl<'hir> Body<'hir> {\n }\n \n /// The type of source expression that caused this generator to be created.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Debug, Copy, Hash)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum GeneratorKind {\n     /// An explicit `async` block or the body of an async function.\n@@ -1539,7 +1535,7 @@ impl GeneratorKind {\n ///\n /// This helps error messages but is also used to drive coercions in\n /// type-checking (see #60424).\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, Copy)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum AsyncGeneratorKind {\n     /// An explicit `async` block written by the user.\n@@ -1649,7 +1645,7 @@ impl fmt::Display for ConstContext {\n /// A literal.\n pub type Lit = Spanned<LitKind>;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum ArrayLen {\n     Infer(HirId, Span),\n     Body(AnonConst),\n@@ -1671,7 +1667,7 @@ impl ArrayLen {\n ///\n /// You can check if this anon const is a default in a const param\n /// `const N: usize = { ... }` with `tcx.hir().opt_const_param_default_param_def_id(..)`\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub struct AnonConst {\n     pub hir_id: HirId,\n     pub def_id: LocalDefId,\n@@ -2105,7 +2101,7 @@ impl<'hir> QPath<'hir> {\n }\n \n /// Hints at the original code for a let statement.\n-#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum LocalSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -2158,7 +2154,7 @@ impl MatchSource {\n }\n \n /// The loop type that yielded an `ExprKind::Loop`.\n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop.\n     Loop,\n@@ -2178,7 +2174,7 @@ impl LoopSource {\n     }\n }\n \n-#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum LoopIdError {\n     OutsideLoopScope,\n     UnlabeledCfInWhileCondition,\n@@ -2197,7 +2193,7 @@ impl fmt::Display for LoopIdError {\n     }\n }\n \n-#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub struct Destination {\n     /// This is `Some(_)` iff there is an explicit user-specified 'label\n     pub label: Option<Label>,\n@@ -2208,7 +2204,7 @@ pub struct Destination {\n }\n \n /// The yield kind that caused an `ExprKind::Yield`.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Encodable, Decodable, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum YieldSource {\n     /// An `<expr>.await`.\n     Await { expr: Option<HirId> },\n@@ -2327,7 +2323,7 @@ impl<'hir> TraitItem<'hir> {\n }\n \n /// Represents a trait method's body (or just argument names).\n-#[derive(Encodable, Debug, Clone, Copy, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum TraitFn<'hir> {\n     /// No default body in the trait, just a signature.\n     Required(&'hir [Ident]),\n@@ -2658,7 +2654,7 @@ pub struct OpaqueTy<'hir> {\n }\n \n /// From whence the opaque type came.\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, HashStable_Generic)]\n pub enum OpaqueTyOrigin {\n     /// `-> impl Trait`\n     FnReturn(LocalDefId),\n@@ -2818,7 +2814,7 @@ impl ImplicitSelfKind {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Decodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug)]\n #[derive(HashStable_Generic)]\n pub enum IsAsync {\n     Async,\n@@ -2831,7 +2827,7 @@ impl IsAsync {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Encodable, Decodable, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Encodable, Decodable, HashStable_Generic)]\n pub enum Defaultness {\n     Default { has_value: bool },\n     Final,\n@@ -2887,13 +2883,13 @@ pub enum ClosureBinder {\n     For { span: Span },\n }\n \n-#[derive(Encodable, Debug, Clone, Copy, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Mod<'hir> {\n     pub spans: ModSpans,\n     pub item_ids: &'hir [ItemId],\n }\n \n-#[derive(Copy, Clone, Debug, HashStable_Generic, Encodable)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub struct ModSpans {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -2922,7 +2918,7 @@ pub struct Variant<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n@@ -3233,7 +3229,7 @@ impl fmt::Display for Unsafety {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n #[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum Constness {\n     Const,\n@@ -3249,7 +3245,7 @@ impl fmt::Display for Constness {\n     }\n }\n \n-#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub constness: Constness,\n@@ -3381,7 +3377,7 @@ impl ItemKind<'_> {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Encodable, Debug, Clone, Copy, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n     pub ident: Ident,\n@@ -3405,7 +3401,7 @@ pub struct ImplItemRef {\n     pub trait_item_def_id: Option<DefId>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum AssocItemKind {\n     Const,\n     Fn { has_self: bool },\n@@ -3474,7 +3470,7 @@ pub enum ForeignItemKind<'hir> {\n }\n \n /// A variable captured by a closure.\n-#[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, HashStable_Generic)]\n pub struct Upvar {\n     /// First span where it is accessed (there can be multiple).\n     pub span: Span,\n@@ -3483,7 +3479,7 @@ pub struct Upvar {\n // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used.\n-#[derive(Encodable, Decodable, Debug, Clone, HashStable_Generic)]\n+#[derive(Debug, Clone, HashStable_Generic)]\n pub struct TraitCandidate {\n     pub def_id: DefId,\n     pub import_ids: SmallVec<[LocalDefId; 1]>,"}, {"sha": "6ab5556e951d939a7704a6e239c9a800c664e27c", "filename": "compiler/rustc_hir_analysis/src/check/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -421,7 +421,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             let target_scopes = visitor.fixup_scopes.drain(start_point..);\n \n             for scope in target_scopes {\n-                let mut yield_data =\n+                let yield_data =\n                     visitor.scope_tree.yield_in_scope.get_mut(&scope).unwrap().last_mut().unwrap();\n                 let count = yield_data.expr_and_pat_count;\n                 let span = yield_data.span;"}, {"sha": "d50be47c915134d851315d36a904d581228e9259", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -455,15 +455,9 @@ fn fatally_break_rust(sess: &Session) {\n     ));\n }\n \n-fn has_expected_num_generic_args(\n-    tcx: TyCtxt<'_>,\n-    trait_did: Option<DefId>,\n-    expected: usize,\n-) -> bool {\n-    trait_did.map_or(true, |trait_did| {\n-        let generics = tcx.generics_of(trait_did);\n-        generics.count() == expected + if generics.has_self { 1 } else { 0 }\n-    })\n+fn has_expected_num_generic_args(tcx: TyCtxt<'_>, trait_did: DefId, expected: usize) -> bool {\n+    let generics = tcx.generics_of(trait_did);\n+    generics.count() == expected + if generics.has_self { 1 } else { 0 }\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "43f40ada5acb612a54fcf4ce9cc158cccff3023d", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -27,8 +27,8 @@ use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::{with_crate_prefix, with_forced_trimmed_paths};\n+use rustc_middle::ty::IsSuggestable;\n use rustc_middle::ty::{self, GenericArgKind, Ty, TyCtxt, TypeVisitableExt};\n-use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n use rustc_span::{edit_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n@@ -2068,7 +2068,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut derives = Vec::<(String, Span, Symbol)>::new();\n         let mut traits = Vec::new();\n         for (pred, _, _) in unsatisfied_predicates {\n-            let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = pred.kind().skip_binder() else { continue };\n+            let Some(ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))) =\n+                pred.kind().no_bound_vars()\n+            else {\n+                continue\n+            };\n             let adt = match trait_pred.self_ty().ty_adt_def() {\n                 Some(adt) if adt.did().is_local() => adt,\n                 _ => continue,\n@@ -2085,22 +2089,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     | sym::Hash\n                     | sym::Debug => true,\n                     _ => false,\n+                } && match trait_pred.trait_ref.substs.as_slice() {\n+                    // Only suggest deriving if lhs == rhs...\n+                    [lhs, rhs] => {\n+                        if let Some(lhs) = lhs.as_type()\n+                            && let Some(rhs) = rhs.as_type()\n+                        {\n+                            self.can_eq(self.param_env, lhs, rhs)\n+                        } else {\n+                            false\n+                        }\n+                    },\n+                    // Unary ops can always be derived\n+                    [_] => true,\n+                    _ => false,\n                 };\n                 if can_derive {\n                     let self_name = trait_pred.self_ty().to_string();\n                     let self_span = self.tcx.def_span(adt.did());\n-                    if let Some(poly_trait_ref) = pred.to_opt_poly_trait_pred() {\n-                        for super_trait in supertraits(self.tcx, poly_trait_ref.to_poly_trait_ref())\n+                    for super_trait in\n+                        supertraits(self.tcx, ty::Binder::dummy(trait_pred.trait_ref))\n+                    {\n+                        if let Some(parent_diagnostic_name) =\n+                            self.tcx.get_diagnostic_name(super_trait.def_id())\n                         {\n-                            if let Some(parent_diagnostic_name) =\n-                                self.tcx.get_diagnostic_name(super_trait.def_id())\n-                            {\n-                                derives.push((\n-                                    self_name.clone(),\n-                                    self_span,\n-                                    parent_diagnostic_name,\n-                                ));\n-                            }\n+                            derives.push((self_name.clone(), self_span, parent_diagnostic_name));\n                         }\n                     }\n                     derives.push((self_name, self_span, diagnostic_name));"}, {"sha": "e91ae4466eb87a20ef6a81e9301858c10c500c0d", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -408,14 +408,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 };\n \n-                let is_compatible = |lhs_ty, rhs_ty| {\n+                let is_compatible_after_call = |lhs_ty, rhs_ty| {\n                     self.lookup_op_method(\n                         lhs_ty,\n                         Some((rhs_expr, rhs_ty)),\n                         Op::Binary(op, is_assign),\n                         expected,\n                     )\n                     .is_ok()\n+                        // Suggest calling even if, after calling, the types don't\n+                        // implement the operator, since it'll lead to better\n+                        // diagnostics later.\n+                        || self.can_eq(self.param_env, lhs_ty, rhs_ty)\n                 };\n \n                 // We should suggest `a + b` => `*a + b` if `a` is copy, and suggest\n@@ -436,16 +440,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         suggest_deref_binop(*lhs_deref_ty);\n                     }\n                 } else if self.suggest_fn_call(&mut err, lhs_expr, lhs_ty, |lhs_ty| {\n-                    is_compatible(lhs_ty, rhs_ty)\n+                    is_compatible_after_call(lhs_ty, rhs_ty)\n                 }) || self.suggest_fn_call(&mut err, rhs_expr, rhs_ty, |rhs_ty| {\n-                    is_compatible(lhs_ty, rhs_ty)\n+                    is_compatible_after_call(lhs_ty, rhs_ty)\n                 }) || self.suggest_two_fn_call(\n                     &mut err,\n                     rhs_expr,\n                     rhs_ty,\n                     lhs_expr,\n                     lhs_ty,\n-                    |lhs_ty, rhs_ty| is_compatible(lhs_ty, rhs_ty),\n+                    |lhs_ty, rhs_ty| is_compatible_after_call(lhs_ty, rhs_ty),\n                 ) {\n                     // Cool\n                 }\n@@ -719,7 +723,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Op::Binary(op, _) => op.span,\n             Op::Unary(_, span) => span,\n         };\n-        let (opname, trait_did) = lang_item_for_op(self.tcx, op, span);\n+        let (opname, Some(trait_did)) = lang_item_for_op(self.tcx, op, span) else {\n+            // Bail if the operator trait is not defined.\n+            return Err(vec![]);\n+        };\n \n         debug!(\n             \"lookup_op_method(lhs_ty={:?}, op={:?}, opname={:?}, trait_did={:?})\",\n@@ -759,18 +766,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n         );\n \n-        let method = trait_did.and_then(|trait_did| {\n-            self.lookup_method_in_trait(cause.clone(), opname, trait_did, lhs_ty, Some(input_types))\n-        });\n-\n-        match (method, trait_did) {\n-            (Some(ok), _) => {\n+        let method = self.lookup_method_in_trait(\n+            cause.clone(),\n+            opname,\n+            trait_did,\n+            lhs_ty,\n+            Some(input_types),\n+        );\n+        match method {\n+            Some(ok) => {\n                 let method = self.register_infer_ok_obligations(ok);\n                 self.select_obligations_where_possible(|_| {});\n                 Ok(method)\n             }\n-            (None, None) => Err(vec![]),\n-            (None, Some(trait_did)) => {\n+            None => {\n+                // This path may do some inference, so make sure we've really\n+                // doomed compilation so as to not accidentally stabilize new\n+                // inference or something here...\n+                self.tcx.sess.delay_span_bug(span, \"this path really should be doomed...\");\n+                // Guide inference for the RHS expression if it's provided --\n+                // this will allow us to better error reporting, at the expense\n+                // of making some error messages a bit more specific.\n+                if let Some((rhs_expr, rhs_ty)) = opt_rhs\n+                    && rhs_ty.is_ty_var()\n+                {\n+                    self.check_expr_coercible_to_type(rhs_expr, rhs_ty, None);\n+                }\n+\n                 let (obligation, _) =\n                     self.obligation_for_method(cause, trait_did, lhs_ty, Some(input_types));\n                 // FIXME: This should potentially just add the obligation to the `FnCtxt`"}, {"sha": "1f7e7ba9f5b2d0ed900b3603ca70e1867d02bbca", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -200,9 +200,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(\"try_overloaded_place_op({:?},{:?},{:?})\", span, base_ty, op);\n \n-        let (imm_tr, imm_op) = match op {\n+        let (Some(imm_tr), imm_op) = (match op {\n             PlaceOp::Deref => (self.tcx.lang_items().deref_trait(), sym::deref),\n             PlaceOp::Index => (self.tcx.lang_items().index_trait(), sym::index),\n+        }) else {\n+            // Bail if `Deref` or `Index` isn't defined.\n+            return None;\n         };\n \n         // If the lang item was declared incorrectly, stop here so that we don't\n@@ -219,15 +222,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         }\n \n-        imm_tr.and_then(|trait_did| {\n-            self.lookup_method_in_trait(\n-                self.misc(span),\n-                Ident::with_dummy_span(imm_op),\n-                trait_did,\n-                base_ty,\n-                Some(arg_tys),\n-            )\n-        })\n+        self.lookup_method_in_trait(\n+            self.misc(span),\n+            Ident::with_dummy_span(imm_op),\n+            imm_tr,\n+            base_ty,\n+            Some(arg_tys),\n+        )\n     }\n \n     fn try_mutable_overloaded_place_op(\n@@ -239,9 +240,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(\"try_mutable_overloaded_place_op({:?},{:?},{:?})\", span, base_ty, op);\n \n-        let (mut_tr, mut_op) = match op {\n+        let (Some(mut_tr), mut_op) = (match op {\n             PlaceOp::Deref => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n             PlaceOp::Index => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n+        }) else {\n+            // Bail if `DerefMut` or `IndexMut` isn't defined.\n+            return None;\n         };\n \n         // If the lang item was declared incorrectly, stop here so that we don't\n@@ -258,15 +262,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         }\n \n-        mut_tr.and_then(|trait_did| {\n-            self.lookup_method_in_trait(\n-                self.misc(span),\n-                Ident::with_dummy_span(mut_op),\n-                trait_did,\n-                base_ty,\n-                Some(arg_tys),\n-            )\n-        })\n+        self.lookup_method_in_trait(\n+            self.misc(span),\n+            Ident::with_dummy_span(mut_op),\n+            mut_tr,\n+            base_ty,\n+            Some(arg_tys),\n+        )\n     }\n \n     /// Convert auto-derefs, indices, etc of an expression from `Deref` and `Index`"}, {"sha": "10712e1468679aa7f037849daf7ea2e4579c4033", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -203,7 +203,7 @@ impl Scope {\n pub type ScopeDepth = u32;\n \n /// The region scope tree encodes information about region relationships.\n-#[derive(TyEncodable, TyDecodable, Default, Debug)]\n+#[derive(Default, Debug)]\n pub struct ScopeTree {\n     /// If not empty, this body is the root of this region hierarchy.\n     pub root_body: Option<hir::HirId>,\n@@ -317,13 +317,13 @@ pub struct ScopeTree {\n /// candidates in general). In constants, the `lifetime` field is None\n /// to indicate that certain expressions escape into 'static and\n /// should have no local cleanup scope.\n-#[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Debug, Copy, Clone, HashStable)]\n pub enum RvalueCandidateType {\n     Borrow { target: hir::ItemLocalId, lifetime: Option<Scope> },\n     Pattern { target: hir::ItemLocalId, lifetime: Option<Scope> },\n }\n \n-#[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Debug, Copy, Clone, HashStable)]\n pub struct YieldData {\n     /// The `Span` of the yield.\n     pub span: Span,"}, {"sha": "d69d42bb5d389ca8f66da66ca223a6a1c0eb37bf", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -199,15 +199,15 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Lift, HashStable, TyEncodable, TyDecodable)]\n #[derive(TypeVisitable, TypeFoldable)]\n pub struct UnifyReceiverContext<'tcx> {\n     pub assoc_item: ty::AssocItem,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Lift, Default, HashStable)]\n+#[derive(Clone, PartialEq, Eq, Lift, Default, HashStable)]\n #[derive(TypeVisitable, TypeFoldable, TyEncodable, TyDecodable)]\n pub struct InternedObligationCauseCode<'tcx> {\n     /// `None` for `ObligationCauseCode::MiscObligation` (a common case, occurs ~60% of\n@@ -243,7 +243,7 @@ impl<'tcx> std::ops::Deref for InternedObligationCauseCode<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Lift, HashStable, TyEncodable, TyDecodable)]\n #[derive(TypeVisitable, TypeFoldable)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from the span.\n@@ -468,7 +468,7 @@ pub enum WellFormedLoc {\n     },\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Lift, HashStable, TyEncodable, TyDecodable)]\n #[derive(TypeVisitable, TypeFoldable)]\n pub struct ImplDerivedObligationCause<'tcx> {\n     pub derived: DerivedObligationCause<'tcx>,\n@@ -529,7 +529,7 @@ impl<'tcx> ty::Lift<'tcx> for StatementAsExpression {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Lift, HashStable, TyEncodable, TyDecodable)]\n #[derive(TypeVisitable, TypeFoldable)]\n pub struct MatchExpressionArmCause<'tcx> {\n     pub arm_block_id: Option<hir::HirId>,\n@@ -545,7 +545,7 @@ pub struct MatchExpressionArmCause<'tcx> {\n     pub opt_suggest_box_span: Option<Span>,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[derive(Lift, TypeFoldable, TypeVisitable, HashStable, TyEncodable, TyDecodable)]\n pub struct IfExpressionCause<'tcx> {\n     pub then_id: hir::HirId,\n@@ -556,7 +556,7 @@ pub struct IfExpressionCause<'tcx> {\n     pub opt_suggest_box_span: Option<Span>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Lift, HashStable, TyEncodable, TyDecodable)]\n #[derive(TypeVisitable, TypeFoldable)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait predicate of the parent obligation that led to the"}, {"sha": "6187fc43cf88b52befe1221c4cb9279e56318ba6", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -188,7 +188,7 @@ impl<'tcx> AdtDef<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, HashStable, TyEncodable, TyDecodable)]\n pub enum AdtKind {\n     Struct,\n     Union,"}, {"sha": "0f6e4b329b87e5d4b7dc70e4b048d86a9eac65d0", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 21, "deletions": 115, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -51,13 +51,6 @@ macro_rules! write_leb128 {\n     }};\n }\n \n-/// A byte that [cannot occur in UTF8 sequences][utf8]. Used to mark the end of a string.\n-/// This way we can skip validation and still be relatively sure that deserialization\n-/// did not desynchronize.\n-///\n-/// [utf8]: https://en.wikipedia.org/w/index.php?title=UTF-8&oldid=1058865525#Codepage_layout\n-const STR_SENTINEL: u8 = 0xC1;\n-\n impl Encoder for MemEncoder {\n     #[inline]\n     fn emit_usize(&mut self, v: usize) {\n@@ -114,28 +107,6 @@ impl Encoder for MemEncoder {\n         self.data.extend_from_slice(&v.to_le_bytes());\n     }\n \n-    #[inline]\n-    fn emit_i8(&mut self, v: i8) {\n-        self.emit_u8(v as u8);\n-    }\n-\n-    #[inline]\n-    fn emit_bool(&mut self, v: bool) {\n-        self.emit_u8(if v { 1 } else { 0 });\n-    }\n-\n-    #[inline]\n-    fn emit_char(&mut self, v: char) {\n-        self.emit_u32(v as u32);\n-    }\n-\n-    #[inline]\n-    fn emit_str(&mut self, v: &str) {\n-        self.emit_usize(v.len());\n-        self.emit_raw_bytes(v.as_bytes());\n-        self.emit_u8(STR_SENTINEL);\n-    }\n-\n     #[inline]\n     fn emit_raw_bytes(&mut self, s: &[u8]) {\n         self.data.extend_from_slice(s);\n@@ -480,28 +451,6 @@ impl Encoder for FileEncoder {\n         self.write_all(&v.to_le_bytes());\n     }\n \n-    #[inline]\n-    fn emit_i8(&mut self, v: i8) {\n-        self.emit_u8(v as u8);\n-    }\n-\n-    #[inline]\n-    fn emit_bool(&mut self, v: bool) {\n-        self.emit_u8(if v { 1 } else { 0 });\n-    }\n-\n-    #[inline]\n-    fn emit_char(&mut self, v: char) {\n-        self.emit_u32(v as u32);\n-    }\n-\n-    #[inline]\n-    fn emit_str(&mut self, v: &str) {\n-        self.emit_usize(v.len());\n-        self.emit_raw_bytes(v.as_bytes());\n-        self.emit_u8(STR_SENTINEL);\n-    }\n-\n     #[inline]\n     fn emit_raw_bytes(&mut self, s: &[u8]) {\n         self.write_all(s);\n@@ -555,40 +504,11 @@ impl<'a> MemDecoder<'a> {\n         panic!(\"MemDecoder exhausted\")\n     }\n \n-    #[inline]\n-    fn read_byte(&mut self) -> u8 {\n-        if self.current == self.end {\n-            Self::decoder_exhausted();\n-        }\n-        // SAFETY: This type guarantees current <= end, and we just checked current == end.\n-        unsafe {\n-            let byte = *self.current;\n-            self.current = self.current.add(1);\n-            byte\n-        }\n-    }\n-\n     #[inline]\n     fn read_array<const N: usize>(&mut self) -> [u8; N] {\n         self.read_raw_bytes(N).try_into().unwrap()\n     }\n \n-    // The trait method doesn't have a lifetime parameter, and we need a version of this\n-    // that definitely returns a slice based on the underlying storage as opposed to\n-    // the Decoder itself in order to implement read_str efficiently.\n-    #[inline]\n-    fn read_raw_bytes_inherent(&mut self, bytes: usize) -> &'a [u8] {\n-        if bytes > self.remaining() {\n-            Self::decoder_exhausted();\n-        }\n-        // SAFETY: We just checked if this range is in-bounds above.\n-        unsafe {\n-            let slice = std::slice::from_raw_parts(self.current, bytes);\n-            self.current = self.current.add(bytes);\n-            slice\n-        }\n-    }\n-\n     /// While we could manually expose manipulation of the decoder position,\n     /// all current users of that method would need to reset the position later,\n     /// incurring the bounds check of set_position twice.\n@@ -653,7 +573,15 @@ impl<'a> Decoder for MemDecoder<'a> {\n \n     #[inline]\n     fn read_u8(&mut self) -> u8 {\n-        self.read_byte()\n+        if self.current == self.end {\n+            Self::decoder_exhausted();\n+        }\n+        // SAFETY: This type guarantees current <= end, and we just checked current == end.\n+        unsafe {\n+            let byte = *self.current;\n+            self.current = self.current.add(1);\n+            byte\n+        }\n     }\n \n     #[inline]\n@@ -681,39 +609,22 @@ impl<'a> Decoder for MemDecoder<'a> {\n         i16::from_le_bytes(self.read_array())\n     }\n \n-    #[inline]\n-    fn read_i8(&mut self) -> i8 {\n-        self.read_byte() as i8\n-    }\n-\n     #[inline]\n     fn read_isize(&mut self) -> isize {\n         read_leb128!(self, read_isize_leb128)\n     }\n \n     #[inline]\n-    fn read_bool(&mut self) -> bool {\n-        let value = self.read_u8();\n-        value != 0\n-    }\n-\n-    #[inline]\n-    fn read_char(&mut self) -> char {\n-        let bits = self.read_u32();\n-        std::char::from_u32(bits).unwrap()\n-    }\n-\n-    #[inline]\n-    fn read_str(&mut self) -> &str {\n-        let len = self.read_usize();\n-        let bytes = self.read_raw_bytes_inherent(len + 1);\n-        assert!(bytes[len] == STR_SENTINEL);\n-        unsafe { std::str::from_utf8_unchecked(&bytes[..len]) }\n-    }\n-\n-    #[inline]\n-    fn read_raw_bytes(&mut self, bytes: usize) -> &[u8] {\n-        self.read_raw_bytes_inherent(bytes)\n+    fn read_raw_bytes(&mut self, bytes: usize) -> &'a [u8] {\n+        if bytes > self.remaining() {\n+            Self::decoder_exhausted();\n+        }\n+        // SAFETY: We just checked if this range is in-bounds above.\n+        unsafe {\n+            let slice = std::slice::from_raw_parts(self.current, bytes);\n+            self.current = self.current.add(bytes);\n+            slice\n+        }\n     }\n \n     #[inline]\n@@ -787,12 +698,7 @@ impl Encodable<FileEncoder> for IntEncodedWithFixedSize {\n impl<'a> Decodable<MemDecoder<'a>> for IntEncodedWithFixedSize {\n     #[inline]\n     fn decode(decoder: &mut MemDecoder<'a>) -> IntEncodedWithFixedSize {\n-        let _start_pos = decoder.position();\n-        let bytes = decoder.read_raw_bytes(IntEncodedWithFixedSize::ENCODED_SIZE);\n-        let value = u64::from_le_bytes(bytes.try_into().unwrap());\n-        let _end_pos = decoder.position();\n-        debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n-\n-        IntEncodedWithFixedSize(value)\n+        let bytes = decoder.read_array::<{ IntEncodedWithFixedSize::ENCODED_SIZE }>();\n+        IntEncodedWithFixedSize(u64::from_le_bytes(bytes))\n     }\n }"}, {"sha": "e1bc598736fee7fc8aba85d26904cd5e20588f2f", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -12,6 +12,13 @@ use std::path;\n use std::rc::Rc;\n use std::sync::Arc;\n \n+/// A byte that [cannot occur in UTF8 sequences][utf8]. Used to mark the end of a string.\n+/// This way we can skip validation and still be relatively sure that deserialization\n+/// did not desynchronize.\n+///\n+/// [utf8]: https://en.wikipedia.org/w/index.php?title=UTF-8&oldid=1058865525#Codepage_layout\n+const STR_SENTINEL: u8 = 0xC1;\n+\n /// A note about error handling.\n ///\n /// Encoders may be fallible, but in practice failure is rare and there are so\n@@ -40,10 +47,29 @@ pub trait Encoder {\n     fn emit_i64(&mut self, v: i64);\n     fn emit_i32(&mut self, v: i32);\n     fn emit_i16(&mut self, v: i16);\n-    fn emit_i8(&mut self, v: i8);\n-    fn emit_bool(&mut self, v: bool);\n-    fn emit_char(&mut self, v: char);\n-    fn emit_str(&mut self, v: &str);\n+\n+    #[inline]\n+    fn emit_i8(&mut self, v: i8) {\n+        self.emit_u8(v as u8);\n+    }\n+\n+    #[inline]\n+    fn emit_bool(&mut self, v: bool) {\n+        self.emit_u8(if v { 1 } else { 0 });\n+    }\n+\n+    #[inline]\n+    fn emit_char(&mut self, v: char) {\n+        self.emit_u32(v as u32);\n+    }\n+\n+    #[inline]\n+    fn emit_str(&mut self, v: &str) {\n+        self.emit_usize(v.len());\n+        self.emit_raw_bytes(v.as_bytes());\n+        self.emit_u8(STR_SENTINEL);\n+    }\n+\n     fn emit_raw_bytes(&mut self, s: &[u8]);\n \n     fn emit_enum_variant<F>(&mut self, v_id: usize, f: F)\n@@ -79,11 +105,38 @@ pub trait Decoder {\n     fn read_i64(&mut self) -> i64;\n     fn read_i32(&mut self) -> i32;\n     fn read_i16(&mut self) -> i16;\n-    fn read_i8(&mut self) -> i8;\n-    fn read_bool(&mut self) -> bool;\n-    fn read_char(&mut self) -> char;\n-    fn read_str(&mut self) -> &str;\n+\n+    #[inline]\n+    fn read_i8(&mut self) -> i8 {\n+        self.read_u8() as i8\n+    }\n+\n+    #[inline]\n+    fn read_bool(&mut self) -> bool {\n+        let value = self.read_u8();\n+        value != 0\n+    }\n+\n+    #[inline]\n+    fn read_char(&mut self) -> char {\n+        let bits = self.read_u32();\n+        std::char::from_u32(bits).unwrap()\n+    }\n+\n+    #[inline]\n+    fn read_str(&mut self) -> &str {\n+        let len = self.read_usize();\n+        let bytes = self.read_raw_bytes(len + 1);\n+        assert!(bytes[len] == STR_SENTINEL);\n+        unsafe { std::str::from_utf8_unchecked(&bytes[..len]) }\n+    }\n+\n     fn read_raw_bytes(&mut self, len: usize) -> &[u8];\n+\n+    // Although there is an `emit_enum_variant` method in `Encoder`, the code\n+    // patterns in decoding are different enough to encoding that there is no\n+    // need for a corresponding `read_enum_variant` method here.\n+\n     fn peek_byte(&self) -> u8;\n     fn position(&self) -> usize;\n }"}, {"sha": "775fad1a365c24e6c6074d84abe5b086d47c58d8", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -917,7 +917,7 @@ mod parse {\n             }\n         }\n \n-        let mut options = slot.get_or_insert_default();\n+        let options = slot.get_or_insert_default();\n         let mut seen_always = false;\n         let mut seen_never = false;\n         let mut seen_ignore_loops = false;"}, {"sha": "368aa2bacdc8ca4673473965cabf35dbcd03aa0a", "filename": "src/tools/miri/src/operator.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/src%2Ftools%2Fmiri%2Fsrc%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/src%2Ftools%2Fmiri%2Fsrc%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Foperator.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -53,17 +53,6 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriInterpCx<'mir, 'tcx> {\n                 (Scalar::from_bool(res), false, self.tcx.types.bool)\n             }\n \n-            Offset => {\n-                assert!(left.layout.ty.is_unsafe_ptr());\n-                let ptr = left.to_scalar().to_pointer(self)?;\n-                let offset = right.to_scalar().to_target_isize(self)?;\n-\n-                let pointee_ty =\n-                    left.layout.ty.builtin_deref(true).expect(\"Offset called on non-ptr type\").ty;\n-                let ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset)?;\n-                (Scalar::from_maybe_pointer(ptr, self), false, left.layout.ty)\n-            }\n-\n             // Some more operations are possible with atomics.\n             // The return value always has the provenance of the *left* operand.\n             Add | Sub | BitOr | BitAnd | BitXor => {"}, {"sha": "abdba4eb8614542078c6bf0f56914f3ebf49f3f0", "filename": "tests/run-make/inaccessible-temp-dir/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Frun-make%2Finaccessible-temp-dir%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Frun-make%2Finaccessible-temp-dir%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Finaccessible-temp-dir%2FMakefile?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -25,7 +25,7 @@ all:\n \t# Run rustc with `-Ztemps-dir` set to a directory \n \t# *inside* the inaccessible one, so that it can't create it\n \t$(RUSTC) program.rs -Ztemps-dir=$(TMPDIR)/inaccessible/tmp 2>&1 \\\n-\t\t| $(CGREP) \"failed to find or create the directory specified by `--temps-dir`\"\n+\t\t| $(CGREP) 'failed to find or create the directory specified by `--temps-dir`'\n \n \t# Make the inaccessible directory accessible,\n \t# so that compiletest can delete the temp dir"}, {"sha": "a77c4c5aabcddac8a560cc0b8df6f3ad7339ed79", "filename": "tests/ui/binop/eq-arr.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fbinop%2Feq-arr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fbinop%2Feq-arr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbinop%2Feq-arr.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    struct X;\n+    //~^ HELP consider annotating `X` with `#[derive(PartialEq)]`\n+    let xs = [X, X, X];\n+    let eq = xs == [X, X, X];\n+    //~^ ERROR binary operation `==` cannot be applied to type `[X; 3]`\n+}"}, {"sha": "a22f8e3ab0c7923fccdfa2218e4f1a4609abbc32", "filename": "tests/ui/binop/eq-arr.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fbinop%2Feq-arr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fbinop%2Feq-arr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbinop%2Feq-arr.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -0,0 +1,22 @@\n+error[E0369]: binary operation `==` cannot be applied to type `[X; 3]`\n+  --> $DIR/eq-arr.rs:5:17\n+   |\n+LL |     let eq = xs == [X, X, X];\n+   |              -- ^^ --------- [X; 3]\n+   |              |\n+   |              [X; 3]\n+   |\n+note: an implementation of `PartialEq` might be missing for `X`\n+  --> $DIR/eq-arr.rs:2:5\n+   |\n+LL |     struct X;\n+   |     ^^^^^^^^ must implement `PartialEq`\n+help: consider annotating `X` with `#[derive(PartialEq)]`\n+   |\n+LL +     #[derive(PartialEq)]\n+LL |     struct X;\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "17ce8df8564253b7757a25db2b870716fe793290", "filename": "tests/ui/binop/eq-vec.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fbinop%2Feq-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fbinop%2Feq-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbinop%2Feq-vec.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -0,0 +1,13 @@\n+fn main() {\n+    #[derive(Debug)]\n+    enum Foo {\n+        //~^ HELP consider annotating `Foo` with `#[derive(PartialEq)]`\n+        Bar,\n+        Qux,\n+    }\n+\n+    let vec1 = vec![Foo::Bar, Foo::Qux];\n+    let vec2 = vec![Foo::Bar, Foo::Qux];\n+    assert_eq!(vec1, vec2);\n+    //~^ ERROR binary operation `==` cannot be applied to type `Vec<Foo>`\n+}"}, {"sha": "0a98cddfe05a996f87f46abe316bc2a1939d5227", "filename": "tests/ui/binop/eq-vec.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fbinop%2Feq-vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fbinop%2Feq-vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbinop%2Feq-vec.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -0,0 +1,24 @@\n+error[E0369]: binary operation `==` cannot be applied to type `Vec<Foo>`\n+  --> $DIR/eq-vec.rs:11:5\n+   |\n+LL |     assert_eq!(vec1, vec2);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     Vec<Foo>\n+   |     Vec<Foo>\n+   |\n+note: an implementation of `PartialEq` might be missing for `Foo`\n+  --> $DIR/eq-vec.rs:3:5\n+   |\n+LL |     enum Foo {\n+   |     ^^^^^^^^ must implement `PartialEq`\n+   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `Foo` with `#[derive(PartialEq)]`\n+   |\n+LL +     #[derive(PartialEq)]\n+LL |     enum Foo {\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "6c98edd3af8e8032f29c8a413d019b79983760b6", "filename": "tests/ui/binop/issue-28837.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fbinop%2Fissue-28837.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fbinop%2Fissue-28837.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbinop%2Fissue-28837.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -6,11 +6,11 @@ LL |     a + a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Add<_>` might be missing for `A`\n+note: an implementation of `Add` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Add<_>`\n+   | ^^^^^^^^ must implement `Add`\n note: the trait `Add` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n \n@@ -22,11 +22,11 @@ LL |     a - a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Sub<_>` might be missing for `A`\n+note: an implementation of `Sub` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Sub<_>`\n+   | ^^^^^^^^ must implement `Sub`\n note: the trait `Sub` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n \n@@ -38,11 +38,11 @@ LL |     a * a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Mul<_>` might be missing for `A`\n+note: an implementation of `Mul` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Mul<_>`\n+   | ^^^^^^^^ must implement `Mul`\n note: the trait `Mul` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n \n@@ -54,11 +54,11 @@ LL |     a / a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Div<_>` might be missing for `A`\n+note: an implementation of `Div` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Div<_>`\n+   | ^^^^^^^^ must implement `Div`\n note: the trait `Div` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n \n@@ -70,11 +70,11 @@ LL |     a % a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Rem<_>` might be missing for `A`\n+note: an implementation of `Rem` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Rem<_>`\n+   | ^^^^^^^^ must implement `Rem`\n note: the trait `Rem` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n \n@@ -86,11 +86,11 @@ LL |     a & a;\n    |     |\n    |     A\n    |\n-note: an implementation of `BitAnd<_>` might be missing for `A`\n+note: an implementation of `BitAnd` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `BitAnd<_>`\n+   | ^^^^^^^^ must implement `BitAnd`\n note: the trait `BitAnd` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n \n@@ -102,11 +102,11 @@ LL |     a | a;\n    |     |\n    |     A\n    |\n-note: an implementation of `BitOr<_>` might be missing for `A`\n+note: an implementation of `BitOr` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `BitOr<_>`\n+   | ^^^^^^^^ must implement `BitOr`\n note: the trait `BitOr` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n \n@@ -118,11 +118,11 @@ LL |     a << a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Shl<_>` might be missing for `A`\n+note: an implementation of `Shl` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Shl<_>`\n+   | ^^^^^^^^ must implement `Shl`\n note: the trait `Shl` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n \n@@ -134,11 +134,11 @@ LL |     a >> a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Shr<_>` might be missing for `A`\n+note: an implementation of `Shr` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Shr<_>`\n+   | ^^^^^^^^ must implement `Shr`\n note: the trait `Shr` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n \n@@ -150,11 +150,11 @@ LL |     a == a;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `A`\n+note: an implementation of `PartialEq` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^ must implement `PartialEq`\n help: consider annotating `A` with `#[derive(PartialEq)]`\n    |\n LL + #[derive(PartialEq)]\n@@ -169,11 +169,11 @@ LL |     a != a;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `A`\n+note: an implementation of `PartialEq` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^ must implement `PartialEq`\n help: consider annotating `A` with `#[derive(PartialEq)]`\n    |\n LL + #[derive(PartialEq)]\n@@ -188,11 +188,11 @@ LL |     a < a;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialOrd<_>` might be missing for `A`\n+note: an implementation of `PartialOrd` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `PartialOrd<_>`\n+   | ^^^^^^^^ must implement `PartialOrd`\n help: consider annotating `A` with `#[derive(PartialEq, PartialOrd)]`\n    |\n LL + #[derive(PartialEq, PartialOrd)]\n@@ -207,11 +207,11 @@ LL |     a <= a;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialOrd<_>` might be missing for `A`\n+note: an implementation of `PartialOrd` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `PartialOrd<_>`\n+   | ^^^^^^^^ must implement `PartialOrd`\n help: consider annotating `A` with `#[derive(PartialEq, PartialOrd)]`\n    |\n LL + #[derive(PartialEq, PartialOrd)]\n@@ -226,11 +226,11 @@ LL |     a > a;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialOrd<_>` might be missing for `A`\n+note: an implementation of `PartialOrd` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `PartialOrd<_>`\n+   | ^^^^^^^^ must implement `PartialOrd`\n help: consider annotating `A` with `#[derive(PartialEq, PartialOrd)]`\n    |\n LL + #[derive(PartialEq, PartialOrd)]\n@@ -245,11 +245,11 @@ LL |     a >= a;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialOrd<_>` might be missing for `A`\n+note: an implementation of `PartialOrd` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `PartialOrd<_>`\n+   | ^^^^^^^^ must implement `PartialOrd`\n help: consider annotating `A` with `#[derive(PartialEq, PartialOrd)]`\n    |\n LL + #[derive(PartialEq, PartialOrd)]"}, {"sha": "cfa78a41dbf08a8047f5704555060f6ab0595b00", "filename": "tests/ui/binop/issue-3820.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fbinop%2Fissue-3820.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fbinop%2Fissue-3820.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbinop%2Fissue-3820.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -6,11 +6,11 @@ LL |     let w = u * 3;\n    |             |\n    |             Thing\n    |\n-note: an implementation of `Mul<_>` might be missing for `Thing`\n+note: an implementation of `Mul<{integer}>` might be missing for `Thing`\n   --> $DIR/issue-3820.rs:1:1\n    |\n LL | struct Thing {\n-   | ^^^^^^^^^^^^ must implement `Mul<_>`\n+   | ^^^^^^^^^^^^ must implement `Mul<{integer}>`\n note: the trait `Mul` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n "}, {"sha": "e3b17431f89af3d6fa481a3a19a8b4769109446b", "filename": "tests/ui/derives/derives-span-PartialEq-enum-struct-variant.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -7,11 +7,11 @@ LL | #[derive(PartialEq)]\n LL |      x: Error\n    |      ^^^^^^^^\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `Error`\n+note: an implementation of `PartialEq` might be missing for `Error`\n   --> $DIR/derives-span-PartialEq-enum-struct-variant.rs:4:1\n    |\n LL | struct Error;\n-   | ^^^^^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Error` with `#[derive(PartialEq)]`\n    |"}, {"sha": "d1631732a34f488adaedd3a455a2242ae2aa86be", "filename": "tests/ui/derives/derives-span-PartialEq-enum.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -7,11 +7,11 @@ LL | #[derive(PartialEq)]\n LL |      Error\n    |      ^^^^^\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `Error`\n+note: an implementation of `PartialEq` might be missing for `Error`\n   --> $DIR/derives-span-PartialEq-enum.rs:4:1\n    |\n LL | struct Error;\n-   | ^^^^^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Error` with `#[derive(PartialEq)]`\n    |"}, {"sha": "ab6c6951fc634bba8a039cc73bbe4e5666b6a4a6", "filename": "tests/ui/derives/derives-span-PartialEq-struct.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -7,11 +7,11 @@ LL | struct Struct {\n LL |     x: Error\n    |     ^^^^^^^^\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `Error`\n+note: an implementation of `PartialEq` might be missing for `Error`\n   --> $DIR/derives-span-PartialEq-struct.rs:4:1\n    |\n LL | struct Error;\n-   | ^^^^^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Error` with `#[derive(PartialEq)]`\n    |"}, {"sha": "865ecad0e8e6d2556f8b120df40f4d1758be6ccb", "filename": "tests/ui/derives/derives-span-PartialEq-tuple-struct.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -7,11 +7,11 @@ LL | struct Struct(\n LL |     Error\n    |     ^^^^^\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `Error`\n+note: an implementation of `PartialEq` might be missing for `Error`\n   --> $DIR/derives-span-PartialEq-tuple-struct.rs:4:1\n    |\n LL | struct Error;\n-   | ^^^^^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Error` with `#[derive(PartialEq)]`\n    |"}, {"sha": "ab99ba9fab5a693ff3bdc5120b9770d217c44ca0", "filename": "tests/ui/derives/deriving-no-inner-impl-error-message.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -7,11 +7,11 @@ LL | struct E {\n LL |     x: NoCloneOrEq\n    |     ^^^^^^^^^^^^^^\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `NoCloneOrEq`\n+note: an implementation of `PartialEq` might be missing for `NoCloneOrEq`\n   --> $DIR/deriving-no-inner-impl-error-message.rs:1:1\n    |\n LL | struct NoCloneOrEq;\n-   | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `NoCloneOrEq` with `#[derive(PartialEq)]`\n    |"}, {"sha": "f556330070cb1dcae9379829587d50edd08155b8", "filename": "tests/ui/destructuring-assignment/note-unsupported.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -44,11 +44,11 @@ LL |     S { x: a, y: b } += s;\n    |     |\n    |     cannot use `+=` on type `S`\n    |\n-note: an implementation of `AddAssign<_>` might be missing for `S`\n+note: an implementation of `AddAssign` might be missing for `S`\n   --> $DIR/note-unsupported.rs:1:1\n    |\n LL | struct S { x: u8, y: u8 }\n-   | ^^^^^^^^ must implement `AddAssign<_>`\n+   | ^^^^^^^^ must implement `AddAssign`\n note: the trait `AddAssign` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n "}, {"sha": "9408acc15f9659acbdc91e7b15333fef4fde8cf3", "filename": "tests/ui/generator/issue-110929-generator-conflict-error-ice.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fgenerator%2Fissue-110929-generator-conflict-error-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fgenerator%2Fissue-110929-generator-conflict-error-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgenerator%2Fissue-110929-generator-conflict-error-ice.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -0,0 +1,12 @@\n+// edition:2021\n+// compile-flags: -Zdrop-tracking-mir=yes\n+#![feature(generators)]\n+\n+fn main() {\n+    let x = &mut ();\n+    || {\n+        let _c = || yield *&mut *x;\n+        || _ = &mut *x;\n+        //~^ cannot borrow `*x` as mutable more than once at a time\n+    };\n+}"}, {"sha": "4d72ebe79eb494f6bfb2c2462fca3ad1c9f57f17", "filename": "tests/ui/generator/issue-110929-generator-conflict-error-ice.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fgenerator%2Fissue-110929-generator-conflict-error-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fgenerator%2Fissue-110929-generator-conflict-error-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgenerator%2Fissue-110929-generator-conflict-error-ice.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -0,0 +1,18 @@\n+error[E0499]: cannot borrow `*x` as mutable more than once at a time\n+  --> $DIR/issue-110929-generator-conflict-error-ice.rs:9:9\n+   |\n+LL |         let _c = || yield *&mut *x;\n+   |                  --             -- first borrow occurs due to use of `*x` in generator\n+   |                  |\n+   |                  first mutable borrow occurs here\n+LL |         || _ = &mut *x;\n+   |         ^^          -- second borrow occurs due to use of `*x` in closure\n+   |         |\n+   |         second mutable borrow occurs here\n+LL |\n+LL |     };\n+   |     - first borrow might be used here, when `_c` is dropped and runs the destructor for generator\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "cd632e64fe5fccf2c5b589f8820a82bb1e2f1c4b", "filename": "tests/ui/issues/issue-62375.stderr", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fissues%2Fissue-62375.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fissues%2Fissue-62375.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-62375.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -6,16 +6,17 @@ LL |     a == A::Value;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `A`\n+note: an implementation of `PartialEq<fn(()) -> A {A::Value}>` might be missing for `A`\n   --> $DIR/issue-62375.rs:1:1\n    |\n LL | enum A {\n-   | ^^^^^^ must implement `PartialEq<_>`\n-help: consider annotating `A` with `#[derive(PartialEq)]`\n-   |\n-LL + #[derive(PartialEq)]\n-LL | enum A {\n+   | ^^^^^^ must implement `PartialEq<fn(()) -> A {A::Value}>`\n+note: the trait `PartialEq` must be implemented\n+  --> $SRC_DIR/core/src/cmp.rs:LL:COL\n+help: use parentheses to construct this tuple variant\n    |\n+LL |     a == A::Value(/* () */);\n+   |                  ++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "5334ab5824d7ac5ef5927c2618f2e345a1b90c30", "filename": "tests/ui/lint/unused/lint-unused-mut-variables.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Flint%2Funused%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Flint%2Funused%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Flint-unused-mut-variables.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -205,3 +205,11 @@ fn bar() {\n     let mut b = vec![2]; //~ ERROR: variable does not need to be mutable\n \n }\n+\n+struct Arg(i32);\n+\n+// Regression test for https://github.com/rust-lang/rust/issues/110849\n+fn write_through_reference(mut arg: &mut Arg) {\n+    //~^ WARN: variable does not need to be mutable\n+    arg.0 = 1\n+}"}, {"sha": "5f66c031581784b3a619ec451340c577bf569812", "filename": "tests/ui/lint/unused/lint-unused-mut-variables.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Flint%2Funused%2Flint-unused-mut-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Flint%2Funused%2Flint-unused-mut-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Flint-unused-mut-variables.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -218,5 +218,13 @@ note: the lint level is defined here\n LL | #[deny(unused_mut)]\n    |        ^^^^^^^^^^\n \n-error: aborting due to previous error; 25 warnings emitted\n+warning: variable does not need to be mutable\n+  --> $DIR/lint-unused-mut-variables.rs:212:28\n+   |\n+LL | fn write_through_reference(mut arg: &mut Arg) {\n+   |                            ----^^^\n+   |                            |\n+   |                            help: remove this `mut`\n+\n+error: aborting due to previous error; 26 warnings emitted\n "}, {"sha": "66a85c4656af536677c42ccd9673b316b8b88da6", "filename": "tests/ui/mismatched_types/assignment-operator-unimplemented.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fmismatched_types%2Fassignment-operator-unimplemented.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fmismatched_types%2Fassignment-operator-unimplemented.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fassignment-operator-unimplemented.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -6,11 +6,11 @@ LL |   a += *b;\n    |   |\n    |   cannot use `+=` on type `Foo`\n    |\n-note: an implementation of `AddAssign<_>` might be missing for `Foo`\n+note: an implementation of `AddAssign` might be missing for `Foo`\n   --> $DIR/assignment-operator-unimplemented.rs:1:1\n    |\n LL | struct Foo;\n-   | ^^^^^^^^^^ must implement `AddAssign<_>`\n+   | ^^^^^^^^^^ must implement `AddAssign`\n note: the trait `AddAssign` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n "}, {"sha": "604bba417e6cc0c4698f2a947e42c86ad9cf2dc2", "filename": "tests/ui/or-patterns/or-patterns-syntactic-fail.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -30,11 +30,11 @@ LL |     let _ = |A | B: E| ();\n    |                  |\n    |                  E\n    |\n-note: an implementation of `BitOr<_>` might be missing for `E`\n+note: an implementation of `BitOr<()>` might be missing for `E`\n   --> $DIR/or-patterns-syntactic-fail.rs:6:1\n    |\n LL | enum E { A, B }\n-   | ^^^^^^ must implement `BitOr<_>`\n+   | ^^^^^^ must implement `BitOr<()>`\n note: the trait `BitOr` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n "}, {"sha": "bae936392717414e6adf33e70115c12928083a1b", "filename": "tests/ui/span/issue-39018.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fspan%2Fissue-39018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fspan%2Fissue-39018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fissue-39018.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -21,11 +21,11 @@ LL |     let y = World::Hello + World::Goodbye;\n    |             |\n    |             World\n    |\n-note: an implementation of `Add<_>` might be missing for `World`\n+note: an implementation of `Add` might be missing for `World`\n   --> $DIR/issue-39018.rs:15:1\n    |\n LL | enum World {\n-   | ^^^^^^^^^^ must implement `Add<_>`\n+   | ^^^^^^^^^^ must implement `Add`\n note: the trait `Add` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n "}, {"sha": "570afcea6434baba4803a1b970656475b79895a2", "filename": "tests/ui/suggestions/invalid-bin-op.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -6,11 +6,11 @@ LL |     let _ = s == t;\n    |             |\n    |             S<T>\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `S<T>`\n+note: an implementation of `PartialEq` might be missing for `S<T>`\n   --> $DIR/invalid-bin-op.rs:5:1\n    |\n LL | struct S<T>(T);\n-   | ^^^^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^^^^ must implement `PartialEq`\n help: consider annotating `S<T>` with `#[derive(PartialEq)]`\n    |\n LL + #[derive(PartialEq)]"}, {"sha": "3c7d42888d83342fe2625886cb127d7e67843ba8", "filename": "tests/ui/suggestions/restrict-type-not-param.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fsuggestions%2Frestrict-type-not-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fsuggestions%2Frestrict-type-not-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Frestrict-type-not-param.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -6,11 +6,11 @@ LL |     a + b\n    |     |\n    |     Wrapper<T>\n    |\n-note: an implementation of `Add<_>` might be missing for `Wrapper<T>`\n+note: an implementation of `Add<T>` might be missing for `Wrapper<T>`\n   --> $DIR/restrict-type-not-param.rs:3:1\n    |\n LL | struct Wrapper<T>(T);\n-   | ^^^^^^^^^^^^^^^^^ must implement `Add<_>`\n+   | ^^^^^^^^^^^^^^^^^ must implement `Add<T>`\n note: the trait `Add` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement"}, {"sha": "556c95438817e0b88c08110349869cfbf1bd90d9", "filename": "tests/ui/suggestions/suggest-mut-method-for-loop-hashmap.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.fixed?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     let mut map = HashMap::new();\n     map.insert(\"a\", Test { v: 0 });\n \n-    for (_k, mut v) in map.iter_mut() {\n+    for (_k, v) in map.iter_mut() {\n         //~^ HELP use mutable method\n         //~| NOTE this iterator yields `&` references\n         v.v += 1;"}, {"sha": "b9d49a074eadeafd8d004b4f375ec8b3eade1ad1", "filename": "tests/ui/suggestions/suggest-mut-method-for-loop-hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.rs?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     let mut map = HashMap::new();\n     map.insert(\"a\", Test { v: 0 });\n \n-    for (_k, mut v) in map.iter() {\n+    for (_k, v) in map.iter() {\n         //~^ HELP use mutable method\n         //~| NOTE this iterator yields `&` references\n         v.v += 1;"}, {"sha": "c442ed6377a8c1097833e9a900c4126250b6a2b4", "filename": "tests/ui/suggestions/suggest-mut-method-for-loop-hashmap.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -1,11 +1,11 @@\n error[E0594]: cannot assign to `v.v`, which is behind a `&` reference\n   --> $DIR/suggest-mut-method-for-loop-hashmap.rs:17:9\n    |\n-LL |     for (_k, mut v) in map.iter() {\n-   |                        ----------\n-   |                        |   |\n-   |                        |   help: use mutable method: `iter_mut()`\n-   |                        this iterator yields `&` references\n+LL |     for (_k, v) in map.iter() {\n+   |                    ----------\n+   |                    |   |\n+   |                    |   help: use mutable method: `iter_mut()`\n+   |                    this iterator yields `&` references\n ...\n LL |         v.v += 1;\n    |         ^^^^^^^^ `v` is a `&` reference, so the data it refers to cannot be written"}, {"sha": "0b76ba8eb7e837245a28f7ee7580b02829d57a90", "filename": "tests/ui/type/type-unsatisfiable.usage.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Ftype%2Ftype-unsatisfiable.usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a96158b53529c2dd03bb4a637d8589ac6f5376f/tests%2Fui%2Ftype%2Ftype-unsatisfiable.usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-unsatisfiable.usage.stderr?ref=7a96158b53529c2dd03bb4a637d8589ac6f5376f", "patch": "@@ -1,8 +1,8 @@\n-error[E0369]: cannot subtract `(dyn Vector2<ScalarType = i32> + 'static)` from `dyn Vector2<ScalarType = i32>`\n+error[E0369]: cannot subtract `dyn Vector2<ScalarType = i32>` from `dyn Vector2<ScalarType = i32>`\n   --> $DIR/type-unsatisfiable.rs:57:20\n    |\n LL |     let bar = *hey - *word;\n-   |               ---- ^ ----- (dyn Vector2<ScalarType = i32> + 'static)\n+   |               ---- ^ ----- dyn Vector2<ScalarType = i32>\n    |               |\n    |               dyn Vector2<ScalarType = i32>\n "}]}