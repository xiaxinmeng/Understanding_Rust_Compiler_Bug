{"sha": "cc2f46e55a3fe52affe0dd4aee2ececd75c78031", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMmY0NmU1NWEzZmU1MmFmZmUwZGQ0YWVlMmVjZWNkNzVjNzgwMzE=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-13T13:55:18Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-24T10:36:31Z"}, "message": "Reorder methods in `allocation.rs`", "tree": {"sha": "dec6decec05dd6ec0536ecc4fa49672073cf2881", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dec6decec05dd6ec0536ecc4fa49672073cf2881"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc2f46e55a3fe52affe0dd4aee2ececd75c78031", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc2f46e55a3fe52affe0dd4aee2ececd75c78031", "html_url": "https://github.com/rust-lang/rust/commit/cc2f46e55a3fe52affe0dd4aee2ececd75c78031", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc2f46e55a3fe52affe0dd4aee2ececd75c78031/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20dee47a66a802c0e7f0b8884632592ad9311357", "url": "https://api.github.com/repos/rust-lang/rust/commits/20dee47a66a802c0e7f0b8884632592ad9311357", "html_url": "https://github.com/rust-lang/rust/commit/20dee47a66a802c0e7f0b8884632592ad9311357"}], "stats": {"total": 170, "additions": 85, "deletions": 85}, "files": [{"sha": "2e08baa6f517111214c419075040800b2270b453", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/cc2f46e55a3fe52affe0dd4aee2ececd75c78031/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc2f46e55a3fe52affe0dd4aee2ececd75c78031/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=cc2f46e55a3fe52affe0dd4aee2ececd75c78031", "patch": "@@ -89,6 +89,91 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n+/// Byte accessors\n+impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n+    /// The last argument controls whether we error out when there are undefined\n+    /// or pointer bytes.  You should never call this, call `get_bytes` or\n+    /// `get_bytes_with_undef_and_ptr` instead,\n+    ///\n+    /// This function also guarantees that the resulting pointer will remain stable\n+    /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n+    /// on that.\n+    fn get_bytes_internal(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        align: Align,\n+        check_defined_and_ptr: bool,\n+    ) -> EvalResult<'tcx, &[u8]> {\n+        self.check_align(ptr.into(), align)?;\n+        self.check_bounds(cx, ptr, size)?;\n+\n+        if check_defined_and_ptr {\n+            self.check_defined(ptr, size)?;\n+            self.check_relocations(cx, ptr, size)?;\n+        } else {\n+            // We still don't want relocations on the *edges*\n+            self.check_relocation_edges(cx, ptr, size)?;\n+        }\n+\n+        AllocationExtra::memory_read(self, ptr, size)?;\n+\n+        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n+        let offset = ptr.offset.bytes() as usize;\n+        Ok(&self.bytes[offset..offset + size.bytes() as usize])\n+    }\n+\n+    #[inline]\n+    fn get_bytes(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        align: Align\n+    ) -> EvalResult<'tcx, &[u8]> {\n+        self.get_bytes_internal(cx, ptr, size, align, true)\n+    }\n+\n+    /// It is the caller's responsibility to handle undefined and pointer bytes.\n+    /// However, this still checks that there are no relocations on the *edges*.\n+    #[inline]\n+    pub fn get_bytes_with_undef_and_ptr(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        align: Align\n+    ) -> EvalResult<'tcx, &[u8]> {\n+        self.get_bytes_internal(cx, ptr, size, align, false)\n+    }\n+\n+    /// Just calling this already marks everything as defined and removes relocations,\n+    /// so be sure to actually put data there!\n+    pub fn get_bytes_mut(\n+        &mut self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        align: Align,\n+    ) -> EvalResult<'tcx, &mut [u8]> {\n+        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n+        self.check_align(ptr.into(), align)?;\n+        self.check_bounds(cx, ptr, size)?;\n+\n+        self.mark_definedness(ptr, size, true)?;\n+        self.clear_relocations(cx, ptr, size)?;\n+\n+        AllocationExtra::memory_written(self, ptr, size)?;\n+\n+        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n+        let offset = ptr.offset.bytes() as usize;\n+        Ok(&mut self.bytes[offset..offset + size.bytes() as usize])\n+    }\n+}\n+\n /// Reading and writing\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     pub fn read_c_str(\n@@ -291,91 +376,6 @@ fn int_align(\n     ity.align(cx).abi\n }\n \n-/// Byte accessors\n-impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n-    /// The last argument controls whether we error out when there are undefined\n-    /// or pointer bytes.  You should never call this, call `get_bytes` or\n-    /// `get_bytes_with_undef_and_ptr` instead,\n-    ///\n-    /// This function also guarantees that the resulting pointer will remain stable\n-    /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n-    /// on that.\n-    fn get_bytes_internal(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-        align: Align,\n-        check_defined_and_ptr: bool,\n-    ) -> EvalResult<'tcx, &[u8]> {\n-        self.check_align(ptr.into(), align)?;\n-        self.check_bounds(cx, ptr, size)?;\n-\n-        if check_defined_and_ptr {\n-            self.check_defined(ptr, size)?;\n-            self.check_relocations(cx, ptr, size)?;\n-        } else {\n-            // We still don't want relocations on the *edges*\n-            self.check_relocation_edges(cx, ptr, size)?;\n-        }\n-\n-        AllocationExtra::memory_read(self, ptr, size)?;\n-\n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n-        Ok(&self.bytes[offset..offset + size.bytes() as usize])\n-    }\n-\n-    #[inline]\n-    fn get_bytes(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-        align: Align\n-    ) -> EvalResult<'tcx, &[u8]> {\n-        self.get_bytes_internal(cx, ptr, size, align, true)\n-    }\n-\n-    /// It is the caller's responsibility to handle undefined and pointer bytes.\n-    /// However, this still checks that there are no relocations on the *edges*.\n-    #[inline]\n-    pub fn get_bytes_with_undef_and_ptr(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-        align: Align\n-    ) -> EvalResult<'tcx, &[u8]> {\n-        self.get_bytes_internal(cx, ptr, size, align, false)\n-    }\n-\n-    /// Just calling this already marks everything as defined and removes relocations,\n-    /// so be sure to actually put data there!\n-    pub fn get_bytes_mut(\n-        &mut self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-        align: Align,\n-    ) -> EvalResult<'tcx, &mut [u8]> {\n-        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n-        self.check_align(ptr.into(), align)?;\n-        self.check_bounds(cx, ptr, size)?;\n-\n-        self.mark_definedness(ptr, size, true)?;\n-        self.clear_relocations(cx, ptr, size)?;\n-\n-        AllocationExtra::memory_written(self, ptr, size)?;\n-\n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n-        Ok(&mut self.bytes[offset..offset + size.bytes() as usize])\n-    }\n-}\n-\n /// Relocations\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Return all relocations overlapping with the given ptr-offset pair."}]}