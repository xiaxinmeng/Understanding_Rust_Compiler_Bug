{"sha": "688cacbdd73427ec5bd86300cc75a07fa89ec310", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4OGNhY2JkZDczNDI3ZWM1YmQ4NjMwMGNjNzVhMDdmYTg5ZWMzMTA=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-16T20:32:40Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:26:36Z"}, "message": "Cleanup the implementation of adjust_global_const.", "tree": {"sha": "9adc72de5fd40ef8a077452a09b612559627355c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9adc72de5fd40ef8a077452a09b612559627355c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/688cacbdd73427ec5bd86300cc75a07fa89ec310", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/688cacbdd73427ec5bd86300cc75a07fa89ec310", "html_url": "https://github.com/rust-lang/rust/commit/688cacbdd73427ec5bd86300cc75a07fa89ec310", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/688cacbdd73427ec5bd86300cc75a07fa89ec310/comments", "author": null, "committer": null, "parents": [{"sha": "1d0eb93ebddd35126cc22f938ff9247ff0e27b0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d0eb93ebddd35126cc22f938ff9247ff0e27b0b", "html_url": "https://github.com/rust-lang/rust/commit/1d0eb93ebddd35126cc22f938ff9247ff0e27b0b"}], "stats": {"total": 156, "additions": 94, "deletions": 62}, "files": [{"sha": "a81273960d09f2f1ebfec44eda93a180c1f18bf2", "filename": "src/machine.rs", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/688cacbdd73427ec5bd86300cc75a07fa89ec310/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688cacbdd73427ec5bd86300cc75a07fa89ec310/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=688cacbdd73427ec5bd86300cc75a07fa89ec310", "patch": "@@ -14,11 +14,9 @@ use rand::rngs::StdRng;\n use rustc_ast::attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::{\n-    middle::codegen_fn_attrs::CodegenFnAttrFlags,\n     mir,\n     ty::{\n         self,\n-        Instance,\n         layout::{LayoutCx, LayoutError, TyAndLayout},\n         TyCtxt,\n     },\n@@ -422,53 +420,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         mut val: mir::interpret::ConstValue<'tcx>,\n     ) -> InterpResult<'tcx, mir::interpret::ConstValue<'tcx>> {\n-        match &mut val {\n-            mir::interpret::ConstValue::Scalar(Scalar::Ptr(ptr)) => {\n-                let alloc_id = ptr.alloc_id;\n-                let alloc = ecx.tcx.alloc_map.lock().get(alloc_id);\n-                let tcx = ecx.tcx;\n-                let is_thread_local = |def_id| {\n-                    tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n-                };\n-                match alloc {\n-                    Some(GlobalAlloc::Static(def_id)) if is_thread_local(def_id) => {\n-                        let new_alloc_id = if let Some(new_alloc_id) =\n-                            ecx.get_thread_local_alloc_id(alloc_id)\n-                        {\n-                            new_alloc_id\n-                        } else {\n-                            if tcx.is_foreign_item(def_id) {\n-                                throw_unsup_format!(\n-                                    \"Foreign thread-local statics are not supported.\"\n-                                )\n-                            }\n-                            let instance = Instance::mono(tcx.tcx, def_id);\n-                            let gid = GlobalId { instance, promoted: None };\n-                            let raw_const = tcx\n-                                .const_eval_raw(ty::ParamEnv::reveal_all().and(gid))\n-                                .map_err(|err| {\n-                                    // no need to report anything, the const_eval call takes care of that\n-                                    // for statics\n-                                    assert!(tcx.is_static(def_id));\n-                                    match err {\n-                                        ErrorHandled::Reported => err_inval!(ReferencedConstant),\n-                                        ErrorHandled::TooGeneric => err_inval!(TooGeneric),\n-                                    }\n-                                })?;\n-                            let id = raw_const.alloc_id;\n-                            let mut alloc_map = tcx.alloc_map.lock();\n-                            let allocation = alloc_map.unwrap_memory(id);\n-                            let new_alloc_id = alloc_map.create_memory_alloc(allocation);\n-                            ecx.set_thread_local_alloc_id(alloc_id, new_alloc_id);\n-                            new_alloc_id\n-                        };\n-                        ptr.alloc_id = new_alloc_id;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n+        ecx.remap_thread_local_alloc_ids(&mut val)?;\n         Ok(val)\n     }\n "}, {"sha": "c8348e262696afd6df184d70713670b8e6f33cf3", "filename": "src/threads.rs", "status": "modified", "additions": 93, "deletions": 13, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/688cacbdd73427ec5bd86300cc75a07fa89ec310/src%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688cacbdd73427ec5bd86300cc75a07fa89ec310/src%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthreads.rs?ref=688cacbdd73427ec5bd86300cc75a07fa89ec310", "patch": "@@ -7,7 +7,13 @@ use std::num::NonZeroU32;\n use log::trace;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::{\n+    middle::codegen_fn_attrs::CodegenFnAttrFlags,\n+    mir,\n+    ty::{self, Instance},\n+};\n \n use crate::*;\n \n@@ -124,9 +130,9 @@ pub struct ThreadManager<'mir, 'tcx> {\n     threads: IndexVec<ThreadId, Thread<'mir, 'tcx>>,\n     /// A counter used to generate unique identifiers for blocksets.\n     blockset_counter: u32,\n-    /// A mapping from an allocation id of a thread-local static to an\n-    /// allocation id of a thread specific allocation.\n-    thread_local_alloc_ids: RefCell<FxHashMap<(AllocId, ThreadId), AllocId>>,\n+    /// A mapping from a thread-local static to an allocation id of a thread\n+    /// specific allocation.\n+    thread_local_alloc_ids: RefCell<FxHashMap<(DefId, ThreadId), AllocId>>,\n }\n \n impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n@@ -145,19 +151,19 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     /// Check if we have an allocation for the given thread local static for the\n     /// active thread.\n-    pub fn get_thread_local_alloc_id(&self, static_alloc_id: AllocId) -> Option<AllocId> {\n-        self.thread_local_alloc_ids.borrow().get(&(static_alloc_id, self.active_thread)).cloned()\n+    pub fn get_thread_local_alloc_id(&self, def_id: DefId) -> Option<AllocId> {\n+        self.thread_local_alloc_ids.borrow().get(&(def_id, self.active_thread)).cloned()\n     }\n \n     /// Set the allocation id as the allocation id of the given thread local\n     /// static for the active thread.\n-    pub fn set_thread_local_alloc_id(&self, static_alloc_id: AllocId, new_alloc_id: AllocId) {\n+    pub fn set_thread_local_alloc_id(&self, def_id: DefId, new_alloc_id: AllocId) {\n         assert!(\n             self.thread_local_alloc_ids\n                 .borrow_mut()\n-                .insert((static_alloc_id, self.active_thread), new_alloc_id)\n+                .insert((def_id, self.active_thread), new_alloc_id)\n                 .is_none(),\n-            \"Bug: a thread local initialized twice for the same thread.\"\n+            \"a thread local initialized twice for the same thread\"\n         );\n     }\n \n@@ -291,14 +297,88 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn get_thread_local_alloc_id(&self, static_alloc_id: AllocId) -> Option<AllocId> {\n+    /// A workaround for thread-local statics until\n+    /// https://github.com/rust-lang/rust/issues/70685 is fixed: change the\n+    /// thread-local allocation id with a freshly generated allocation id for\n+    /// the currently active thread.\n+    fn remap_thread_local_alloc_ids(\n+        &self,\n+        val: &mut mir::interpret::ConstValue<'tcx>,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n-        this.machine.threads.get_thread_local_alloc_id(static_alloc_id)\n+        match val {\n+            mir::interpret::ConstValue::Scalar(Scalar::Ptr(ptr)) => {\n+                let alloc_id = ptr.alloc_id;\n+                let alloc = this.tcx.alloc_map.lock().get(alloc_id);\n+                let tcx = this.tcx;\n+                let is_thread_local = |def_id| {\n+                    tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n+                };\n+                match alloc {\n+                    Some(GlobalAlloc::Static(def_id)) if is_thread_local(def_id) => {\n+                        ptr.alloc_id = this.get_or_create_thread_local_alloc_id(def_id)?;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {\n+                // FIXME: Handling only `Scalar` seems to work for now, but at\n+                // least in principle thread-locals could be in any constant, so\n+                // we should also consider other cases. However, once\n+                // https://github.com/rust-lang/rust/issues/70685 gets fixed,\n+                // this code will have to be rewritten anyway.\n+            }\n+        }\n+        Ok(())\n     }\n-\n-    fn set_thread_local_alloc_id(&self, static_alloc_id: AllocId, thread_local_alloc_id: AllocId) {\n+    /// Get a thread-specific allocation id for the given thread-local static.\n+    /// If needed, allocate a new one.\n+    ///\n+    /// FIXME: This method should be replaced as soon as\n+    /// https://github.com/rust-lang/rust/issues/70685 gets fixed.\n+    fn get_or_create_thread_local_alloc_id(&self, def_id: DefId) -> InterpResult<'tcx, AllocId> {\n         let this = self.eval_context_ref();\n-        this.machine.threads.set_thread_local_alloc_id(static_alloc_id, thread_local_alloc_id)\n+        let tcx = this.tcx;\n+        if let Some(new_alloc_id) = this.machine.threads.get_thread_local_alloc_id(def_id) {\n+            // We already have a thread-specific allocation id for this\n+            // thread-local static.\n+            Ok(new_alloc_id)\n+        } else {\n+            // We need to allocate a thread-specific allocation id for this\n+            // thread-local static.\n+            //\n+            // At first, we invoke the `const_eval_raw` query and extract the\n+            // allocation from it. Unfortunately, we have to duplicate the code\n+            // from `Memory::get_global_alloc` that does this.\n+            //\n+            // Then we store the retrieved allocation back into the `alloc_map`\n+            // to get a fresh allocation id, which we can use as a\n+            // thread-specific allocation id for the thread-local static.\n+            if tcx.is_foreign_item(def_id) {\n+                throw_unsup_format!(\"foreign thread-local statics are not supported\");\n+            }\n+            // Invoke the `const_eval_raw` query.\n+            let instance = Instance::mono(tcx.tcx, def_id);\n+            let gid = GlobalId { instance, promoted: None };\n+            let raw_const =\n+                tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n+                    // no need to report anything, the const_eval call takes care of that\n+                    // for statics\n+                    assert!(tcx.is_static(def_id));\n+                    err\n+                })?;\n+            let id = raw_const.alloc_id;\n+            // Extract the allocation from the query result.\n+            let mut alloc_map = tcx.alloc_map.lock();\n+            let allocation = alloc_map.unwrap_memory(id);\n+            // Create a new allocation id for the same allocation in this hacky\n+            // way. Internally, `alloc_map` deduplicates allocations, but this\n+            // is fine because Miri will make a copy before a first mutable\n+            // access.\n+            let new_alloc_id = alloc_map.create_memory_alloc(allocation);\n+            this.machine.threads.set_thread_local_alloc_id(def_id, new_alloc_id);\n+            Ok(new_alloc_id)\n+        }\n     }\n \n     fn create_thread(&mut self) -> InterpResult<'tcx, ThreadId> {"}]}