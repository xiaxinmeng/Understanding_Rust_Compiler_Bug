{"sha": "c44d7a64865c5aa9507351be881e4c18ef38e4b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NGQ3YTY0ODY1YzVhYTk1MDczNTFiZTg4MWU0YzE4ZWYzOGU0YjA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-18T00:55:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-19T19:05:18Z"}, "message": "core::rt: Declare large parts of the I/O API", "tree": {"sha": "ef5364d56885a819c18711ced6ac349788b1d70c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef5364d56885a819c18711ced6ac349788b1d70c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c44d7a64865c5aa9507351be881e4c18ef38e4b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c44d7a64865c5aa9507351be881e4c18ef38e4b0", "html_url": "https://github.com/rust-lang/rust/commit/c44d7a64865c5aa9507351be881e4c18ef38e4b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c44d7a64865c5aa9507351be881e4c18ef38e4b0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10e6869a54b3d9e703ca6bc29f49f522ee25d865", "url": "https://api.github.com/repos/rust-lang/rust/commits/10e6869a54b3d9e703ca6bc29f49f522ee25d865", "html_url": "https://github.com/rust-lang/rust/commit/10e6869a54b3d9e703ca6bc29f49f522ee25d865"}], "stats": {"total": 1569, "additions": 1539, "deletions": 30}, "files": [{"sha": "8daf8adf387847e2987d05dcf426a1c55c97dc61", "filename": "src/libcore/rt/io/blocking/file.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fblocking%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fblocking%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fblocking%2Ffile.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Blocking posix-based file I/O\n+\n+use prelude::*;\n+use super::super::*;\n+use libc::{c_int, FILE};\n+\n+#[allow(non_camel_case_types)]\n+pub type fd_t = c_int;\n+\n+// Make this a newtype so we can't do I/O on arbitrary integers\n+pub struct FileDesc(fd_t);\n+\n+impl FileDesc {\n+    /// Create a `FileDesc` from an open C file descriptor.\n+    ///\n+    /// The `FileDesc` takes ownership of the file descriptor\n+    /// and will close it upon destruction.\n+    pub fn new(_fd: fd_t) -> FileDesc { fail!() }\n+}\n+\n+impl Reader for FileDesc {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Writer for FileDesc {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Closeable for FileDesc {\n+    fn close(&mut self) { fail!() }\n+}\n+\n+impl Seekable for FileDesc {\n+    fn tell(&self) -> u64 { fail!() }\n+\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}\n+\n+pub struct CFile(*FILE);\n+\n+impl CFile {\n+    /// Create a `CFile` from an open `FILE` pointer.\n+    ///\n+    /// The `CFile` takes ownership of the file descriptor\n+    /// and will close it upon destruction.\n+    pub fn new(_file: *FILE) -> CFile { fail!() }\n+}\n+\n+impl Reader for CFile {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Writer for CFile {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Closeable for CFile {\n+    fn close(&mut self) { fail!() }\n+}\n+\n+impl Seekable for CFile {\n+    fn tell(&self) -> u64 { fail!() }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}"}, {"sha": "1d6893b3ca6166edf340f171563525e633c0ff6a", "filename": "src/libcore/rt/io/comm_adapters.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fcomm_adapters.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use super::{Reader, Writer};\n+\n+struct PortReader<P>;\n+\n+impl<P: GenericPort<~[u8]>> PortReader<P> {\n+    pub fn new(_port: P) -> PortReader<P> { fail!() }\n+}\n+\n+impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+struct ChanWriter<C>;\n+\n+impl<C: GenericChan<~[u8]>> ChanWriter<C> {\n+    pub fn new(_chan: C) -> ChanWriter<C> { fail!() }\n+}\n+\n+impl<C: GenericChan<~[u8]>> Writer for ChanWriter<C> {\n+    pub fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    pub fn flush(&mut self) { fail!() }\n+}\n+\n+struct ReaderPort<R>;\n+\n+impl<R: Reader> ReaderPort<R> {\n+    pub fn new(_reader: R) -> ReaderPort<R> { fail!() }\n+}\n+\n+impl<R: Reader> GenericPort<~[u8]> for ReaderPort<R> {\n+    fn recv(&self) -> ~[u8] { fail!() }\n+\n+    fn try_recv(&self) -> Option<~[u8]> { fail!() }\n+}\n+\n+struct WriterChan<W>;\n+\n+impl<W: Writer> WriterChan<W> {\n+    pub fn new(_writer: W) -> WriterChan<W> { fail!() }\n+}\n+\n+impl<W: Writer> GenericChan<~[u8]> for WriterChan<W> {\n+    fn send(&self, _x: ~[u8]) { fail!() }\n+}\n+"}, {"sha": "0fa357f0ac9995248e7e279950264baa40892310", "filename": "src/libcore/rt/io/file.rs", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Ffile.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -9,35 +9,79 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::Stream;\n+use super::misc::PathLike;\n+use super::{Reader, Writer, Seekable, Closeable};\n+use super::{IoError, SeekStyle};\n+\n+/// Open a file with the default FileMode and FileAccess\n+/// # TODO are there sane defaults here?\n+pub fn open_file<P: PathLike>(_path: &P) -> FileStream { fail!() }\n+\n+/// # TODO\n+/// * Ugh, this is ridiculous. What is the best way to represent these options?\n+enum FileMode {\n+    /// Opens an existing file. IoError if file does not exist.\n+    Open,\n+    /// Creates a file. IoError if file exists.\n+    Create,\n+    /// Opens an existing file or creates a new one.\n+    OpenOrCreate,\n+    /// Opens an existing file or creates a new one, positioned at EOF.\n+    Append,\n+    /// Opens an existing file, truncating it to 0 bytes.\n+    Truncate,\n+    /// Opens an existing file or creates a new one, truncating it to 0 bytes.\n+    CreateOrTruncate,\n+}\n+ \n+enum FileAccess {\n+    Read,\n+    Write,\n+    ReadWrite\n+}\n \n pub struct FileStream;\n \n-pub impl FileStream {\n-    fn new(_path: Path) -> FileStream {\n+impl FileStream {\n+    pub fn open<P: PathLike>(_path: &P,\n+                             _mode: FileMode,\n+                             _access: FileAccess\n+                            ) -> Result<FileStream, IoError> {\n         fail!()\n     }\n }\n \n-impl Stream for FileStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> uint {\n+impl Reader for FileStream {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> {\n         fail!()\n     }\n \n     fn eof(&mut self) -> bool {\n         fail!()\n     }\n+}\n \n-    fn write(&mut self, _v: &const [u8]) {\n-        fail!()\n-    }\n+impl Writer for FileStream {\n+    fn write(&mut self, _v: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Seekable for FileStream {\n+    fn tell(&self) -> u64 { fail!() }\n+\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}\n+\n+impl Closeable for FileStream {\n+    fn close(&mut self) { fail!() }\n }\n \n #[test]\n #[ignore]\n fn super_simple_smoke_test_lets_go_read_some_files_and_have_a_good_time() {\n     let message = \"it's alright. have a good time\";\n-    let filename = Path(\"test.txt\");\n-    let mut outstream = FileStream::new(filename);\n+    let filename = &Path(\"test.txt\");\n+    let mut outstream = FileStream::open(filename, Create, Read).unwrap();\n     outstream.write(message.to_bytes());\n }"}, {"sha": "24537bef329abb35e0bfb09c215b91a761c345b6", "filename": "src/libcore/rt/io/flate.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fflate.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Some various other I/O types\n+\n+// NOTE: These ultimately belong somewhere else\n+\n+use prelude::*;\n+use super::*;\n+\n+/// A Writer decorator that compresses using the 'deflate' scheme\n+pub struct DeflateWriter<W> {\n+    inner_writer: W\n+}\n+\n+impl<W: Writer> DeflateWriter<W> {\n+    pub fn new(inner_writer: W) -> DeflateWriter<W> {\n+        DeflateWriter {\n+            inner_writer: inner_writer\n+        }\n+    }\n+}\n+\n+impl<W: Writer> Writer for DeflateWriter<W> {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl<W: Writer> Decorator<W> for DeflateWriter<W> {\n+    fn inner(self) -> W {\n+        match self {\n+            DeflateWriter { inner_writer: w } => w\n+        }\n+    }\n+\n+    fn inner_ref<'a>(&'a self) -> &'a W {\n+        match *self {\n+            DeflateWriter { inner_writer: ref w } => w\n+        }\n+    }\n+\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W {\n+        match *self {\n+            DeflateWriter { inner_writer: ref mut w } => w\n+        }\n+    }\n+}\n+\n+/// A Reader decorator that decompresses using the 'deflate' scheme\n+pub struct InflateReader<R> {\n+    inner_reader: R\n+}\n+\n+impl<R: Reader> InflateReader<R> {\n+    pub fn new(inner_reader: R) -> InflateReader<R> {\n+        InflateReader {\n+            inner_reader: inner_reader\n+        }\n+    }\n+}\n+\n+impl<R: Reader> Reader for InflateReader<R> {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl<R: Reader> Decorator<R> for InflateReader<R> {\n+    fn inner(self) -> R {\n+        match self {\n+            InflateReader { inner_reader: r } => r\n+        }\n+    }\n+\n+    fn inner_ref<'a>(&'a self) -> &'a R {\n+        match *self {\n+            InflateReader { inner_reader: ref r } => r\n+        }\n+    }\n+\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R {\n+        match *self {\n+            InflateReader { inner_reader: ref mut r } => r\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use super::*;\n+    use super::super::mem::*;\n+    use super::super::Decorator;\n+\n+    #[test]\n+    #[ignore]\n+    fn smoke_test() {\n+        let mem_writer = MemWriter::new();\n+        let mut deflate_writer = DeflateWriter::new(mem_writer);\n+        let in_msg = \"test\";\n+        let in_bytes = in_msg.to_bytes();\n+        deflate_writer.write(in_bytes);\n+        deflate_writer.flush();\n+        let buf = deflate_writer.inner().inner();\n+        let mem_reader = MemReader::new(buf);\n+        let mut inflate_reader = InflateReader::new(mem_reader);\n+        let mut out_bytes = [0, .. 100];\n+        let bytes_read = inflate_reader.read(out_bytes).get();\n+        assert!(bytes_read == in_bytes.len());\n+        let out_msg = str::from_bytes(out_bytes);\n+        assert!(in_msg == out_msg);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "04790c579137f9ae4c4365bcf322572269fe513c", "filename": "src/libcore/rt/io/mem.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmem.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,166 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Readers and Writers for in-memory buffers\n+//!\n+//! # TODO\n+//!\n+//! * Should probably have something like this for strings.\n+//! * Should they implement Closable? Would take extra state.\n+\n+use prelude::*;\n+use super::*;\n+\n+\n+/// Writes to an owned, growable byte vector\n+pub struct MemWriter {\n+    buf: ~[u8]\n+}\n+\n+impl MemWriter {\n+    pub fn new() -> MemWriter { MemWriter { buf: ~[] } }\n+}\n+\n+impl Writer for MemWriter {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { /* no-op */ }\n+}\n+\n+impl Seekable for MemWriter {\n+    fn tell(&self) -> u64 { fail!() }\n+\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}\n+\n+impl Decorator<~[u8]> for MemWriter {\n+\n+    fn inner(self) -> ~[u8] {\n+        match self {\n+            MemWriter { buf: buf } => buf\n+        }\n+    }\n+\n+    fn inner_ref<'a>(&'a self) -> &'a ~[u8] {\n+        match *self {\n+            MemWriter { buf: ref buf } => buf\n+        }\n+    }\n+\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] {\n+        match *self {\n+            MemWriter { buf: ref mut buf } => buf\n+        }\n+    }\n+}\n+\n+/// Reads from an owned byte vector \n+pub struct MemReader {\n+    buf: ~[u8],\n+    pos: uint\n+}\n+\n+impl MemReader {\n+    pub fn new(buf: ~[u8]) -> MemReader {\n+        MemReader {\n+            buf: buf,\n+            pos: 0\n+        }\n+    }\n+}\n+\n+impl Reader for MemReader {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Seekable for MemReader {\n+    fn tell(&self) -> u64 { fail!() }\n+\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}\n+\n+impl Decorator<~[u8]> for MemReader {\n+\n+    fn inner(self) -> ~[u8] {\n+        match self {\n+            MemReader { buf: buf, _ } => buf\n+        }\n+    }\n+\n+    fn inner_ref<'a>(&'a self) -> &'a ~[u8] {\n+        match *self {\n+            MemReader { buf: ref buf, _ } => buf\n+        }\n+    }\n+\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] {\n+        match *self {\n+            MemReader { buf: ref mut buf, _ } => buf\n+        }\n+    }\n+}\n+\n+ \n+/// Writes to a fixed-size byte slice\n+struct BufWriter<'self> {\n+    buf: &'self mut [u8],\n+    pos: uint\n+}\n+ \n+impl<'self> BufWriter<'self> {\n+    pub fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> {\n+        BufWriter {\n+            buf: buf,\n+            pos: 0\n+        }\n+    }\n+}\n+\n+impl<'self> Writer for BufWriter<'self> {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl<'self> Seekable for BufWriter<'self> {\n+    fn tell(&self) -> u64 { fail!() }\n+\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}\n+\n+\n+/// Reads from a fixed-size byte slice \n+struct BufReader<'self> {\n+    buf: &'self [u8],\n+    pos: uint\n+}\n+\n+impl<'self> BufReader<'self> {\n+    pub fn new<'a>(buf: &'a [u8]) -> BufReader<'a> {\n+        BufReader {\n+            buf: buf,\n+            pos: 0\n+        }\n+    }\n+}\n+\n+impl<'self> Reader for BufReader<'self> {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl<'self> Seekable for BufReader<'self> {\n+    fn tell(&self) -> u64 { fail!() }\n+\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}\n\\ No newline at end of file"}, {"sha": "7bace5d6df2ccfdba1cfe7538ab05cbed10da6cb", "filename": "src/libcore/rt/io/misc.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmisc.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use path::*;\n+\n+pub trait PathLike {\n+    fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T;\n+}\n+\n+impl<'self> PathLike for &'self str {\n+    fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T {\n+        f(*self)\n+    }\n+}\n+\n+impl PathLike for Path {\n+    fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T {\n+        let s = self.to_str();\n+        f(s)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use path::*;\n+    use super::PathLike;\n+\n+    #[test]\n+    fn path_like_smoke_test() {\n+        let expected = \"/home\";\n+        let path = Path(expected);\n+        path.path_as_str(|p| assert!(p == expected));\n+        path.path_as_str(|p| assert!(p == expected));\n+    }\n+}"}, {"sha": "e711c2ff66e3ca51d01e02d9ec7384307474cb25", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 255, "deletions": 14, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -8,35 +8,276 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*! Synchronous I/O\n+\n+This module defines the Rust interface for synchronous I/O.\n+It supports file access, \n+\n+This will likely live in core::io, not core::rt::io.\n+\n+# Examples\n+\n+Some examples of obvious things you might want to do\n+\n+* Read lines from stdin\n+\n+    for stdin().each_line |line| {\n+        println(line)\n+    }\n+\n+* Read a complete file to a string, (converting newlines?)\n+\n+    let contents = open(\"message.txt\").read_to_str(); // read_to_str??\n+\n+* Write a line to a file\n+\n+    let file = FileStream::open(\"message.txt\", Create, Write);\n+    file.write_line(\"hello, file!\");\n+\n+* Iterate over the lines of a file\n+\n+* Pull the lines of a file into a vector of strings\n+\n+* Connect based on URL? Requires thinking about where the URL type lives\n+  and how to make protocol handlers extensible, e.g. the \"tcp\" protocol\n+  yields a `TcpStream`.\n+\n+    connect(\"tcp://localhost:8080\").write_line(\"HTTP 1.0 GET /\");\n+\n+# Terms\n+\n+* reader\n+* writer\n+* stream\n+* Blocking vs. non-blocking\n+* synchrony and asynchrony\n+\n+I tend to call this implementation non-blocking, because performing I/O\n+doesn't block the progress of other tasks. Is that how we want to present\n+it, 'synchronous but non-blocking'?\n+\n+# Error Handling\n+\n+# Resource management\n+\n+* `close` vs. RAII\n+\n+# Paths and URLs\n+\n+# std\n+\n+Some I/O things don't belong in core\n+\n+  - url\n+  - net - `fn connect`\n+    - http\n+  - flate\n+\n+# TODO\n+\n+* Should default constructors take `Path` or `&str`? `Path` makes simple cases verbose.\n+  Overloading would be nice.\n+* Add overloading for Path and &str and Url &str\n+* stdin/err/out\n+* print, println, etc.\n+* fsync\n+* relationship with filesystem querying, Directory, File types etc.\n+* Rename Reader/Writer to ByteReader/Writer, make Reader/Writer generic?\n+* Trait for things that are both readers and writers, Stream?\n+* How to handle newline conversion\n+* String conversion\n+* File vs. FileStream? File is shorter but could also be used for getting file info\n+  - maybe File is for general file querying and *also* has a static `open` method\n+* open vs. connect for generic stream opening\n+* Do we need `close` at all? dtors might be good enough\n+* How does I/O relate to the Iterator trait?\n+* std::base64 filters\n+\n+*/\n+\n+use prelude::*;\n+\n+// Reexports\n+pub use self::stdio::stdin;\n+pub use self::stdio::stdout;\n+pub use self::stdio::stderr;\n+pub use self::stdio::print;\n+pub use self::stdio::println;\n+\n+pub use self::file::open_file;\n+pub use self::file::FileStream;\n+pub use self::net::Listener;\n+pub use self::net::ip::IpAddr;\n+pub use self::net::tcp::TcpListener;\n+pub use self::net::tcp::TcpStream;\n+pub use self::net::udp::UdpStream;\n+\n+// Some extension traits that all Readers and Writers get.\n+pub use self::util::ReaderUtil;\n+pub use self::util::ReaderByteConversions;\n+pub use self::util::WriterByteConversions;\n+\n+/// Synchronous, non-blocking file I/O.\n pub mod file;\n \n-// FIXME #5370 Strongly want this to be StreamError(&mut Stream)\n-pub struct StreamError;\n+/// Synchronous, non-blocking network I/O.\n+#[path = \"net/mod.rs\"]\n+pub mod net;\n+\n+/// Readers and Writers for memory buffers and strings.\n+#[cfg(not(stage0))] // XXX Using unsnapshotted features\n+pub mod mem;\n+\n+/// Non-blocking access to stdin, stdout, stderr\n+pub mod stdio;\n+\n+/// Basic stream compression. XXX: Belongs with other flate code\n+#[cfg(not(stage0))] // XXX Using unsnapshotted features\n+pub mod flate;\n+\n+/// Interop between byte streams and pipes. Not sure where it belongs\n+#[cfg(not(stage0))] // XXX \"\n+pub mod comm_adapters;\n+\n+/// Extension traits\n+mod util;\n+\n+/// Non-I/O things needed by the I/O module\n+mod misc;\n+\n+/// Thread-blocking implementations\n+pub mod blocking {\n+    /// Posix file I/O\n+    pub mod file;\n+    /// # TODO - implement this\n+    pub mod stdio { }\n+    /// Sockets\n+    /// # TODO - implement this\n+    pub mod net {\n+        pub mod tcp { }\n+        pub mod udp { }\n+        #[cfg(unix)]\n+        pub mod unix { }\n+    }\n+}\n+\n+\n+/// The type passed to I/O condition handlers to indicate error\n+///\n+/// # TODO\n+///\n+/// Is something like this sufficient? It's kind of archaic\n+pub struct IoError {\n+    kind: IoErrorKind,\n+    desc: &'static str,\n+    detail: Option<~str>\n+}\n+\n+pub enum IoErrorKind {\n+    FileNotFound,\n+    FilePermission,\n+    ConnectionFailed,\n+    Closed,\n+    OtherIoError\n+}\n \n // XXX: Can't put doc comments on macros\n-// Raised by `Stream` instances on error. Returning `true` from the handler\n-// indicates that the `Stream` should continue, `false` that it should fail.\n+// Raised by `I/O` operations on error.\n condition! {\n-    stream_error: super::StreamError -> bool;\n+    io_error: super::IoError -> ();\n }\n \n-pub trait Stream {\n-    /// Read bytes, up to the length of `buf` and place them in `buf`,\n-    /// returning the number of bytes read or an `IoError`. Reads\n-    /// 0 bytes on EOF.\n+pub trait Reader {\n+    /// Read bytes, up to the length of `buf` and place them in `buf`.\n+    /// Returns the number of bytes read, or `None` on EOF.\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `reader_error` condition on error\n-    fn read(&mut self, buf: &mut [u8]) -> uint;\n+    /// Raises the `io_error` condition on error, then returns `None`.\n+    ///\n+    /// # TODO\n+    ///\n+    /// This doesn't take a `len` argument like the old `read`.\n+    /// Will people often need to slice their vectors to call this\n+    /// and will that be annoying?\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint>;\n \n-    /// Return whether the Reader has reached the end of the stream\n+    /// Return whether the Reader has reached the end of the stream.\n+    ///\n+    /// # Example\n+    ///\n+    ///     let reader = FileStream::new()\n+    ///     while !reader.eof() {\n+    ///         println(reader.read_line());\n+    ///     }\n+    ///\n+    /// # TODO\n+    ///\n+    /// What does this return if the Reader is in an error state?\n     fn eof(&mut self) -> bool;\n+}\n \n+pub trait Writer {\n     /// Write the given buffer\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `writer_error` condition on error\n-    fn write(&mut self, v: &const [u8]);\n+    /// Raises the `io_error` condition on error\n+    fn write(&mut self, buf: &[u8]);\n+\n+    /// Flush output\n+    fn flush(&mut self);\n+}\n+\n+/// I/O types that may be closed\n+///\n+/// Any further operations performed on a closed resource will raise\n+/// on `io_error`\n+pub trait Closeable {\n+    /// Close the I/O resource\n+    fn close(&mut self);\n+}\n+\n+pub trait Stream: Reader + Writer + Closeable { }\n+\n+pub enum SeekStyle {\n+    /// Seek from the beginning of the stream\n+    SeekSet,\n+    /// Seek from the end of the stream\n+    SeekEnd,\n+    /// Seek from the current position\n+    SeekCur,\n+}\n+\n+/// # TODO\n+/// * Are `u64` and `i64` the right choices?\n+pub trait Seekable {\n+    fn tell(&self) -> u64;\n+    fn seek(&mut self, pos: i64, style: SeekStyle);\n+}\n+\n+/// Common trait for decorator types.\n+///\n+/// Provides accessors to get the inner, 'decorated' values. The I/O library\n+/// uses decorators to add functionality like compression and encryption to I/O\n+/// streams.\n+///\n+/// # TODO\n+///\n+/// Is this worth having a trait for? May be overkill\n+pub trait Decorator<T> {\n+    /// Destroy the decorator and extract the decorated value\n+    ///\n+    /// # TODO\n+    ///\n+    /// Because this takes `self' one could never 'undecorate' a Reader/Writer\n+    /// that has been boxed. Is that ok? This feature is mostly useful for\n+    /// extracting the buffer from MemWriter\n+    fn inner(self) -> T;\n+\n+    /// Take an immutable reference to the decorated value\n+    fn inner_ref<'a>(&'a self) -> &'a T;\n+\n+    /// Take a mutable reference to the decorated value\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut T;\n }"}, {"sha": "40f0b315e05b5292efd6e7fc046d1957d328d612", "filename": "src/libcore/rt/io/net/http.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fnet%2Fhttp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fnet%2Fhttp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fhttp.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Simple HTTP client and server\n+\n+// XXX This should not be in core\n+\n+struct HttpServer;\n+\n+#[cfg(test)]\n+mod test {\n+    use unstable::run_in_bare_thread;\n+    \n+    #[test] #[ignore]\n+    fn smoke_test() {\n+        do run_in_bare_thread {\n+        }\n+\n+        do run_in_bare_thread {\n+        }\n+    }\n+}"}, {"sha": "d9b7f4e6e40114bbcca565e5368775327dd63723", "filename": "src/libcore/rt/io/net/ip.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fip.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub enum IpAddr {\n+    Ipv4(u8, u8, u8, u8, u16),\n+    Ipv6\n+}\n+"}, {"sha": "130ff6b38fa82f3f1a8a8a8e06c4d8294e672d18", "filename": "src/libcore/rt/io/net/mod.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fmod.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+\n+pub mod tcp;\n+pub mod udp;\n+pub mod ip;\n+#[cfg(unix)]\n+pub mod unix;\n+pub mod http;\n+\n+/// A listener is a value that listens for connections\n+pub trait Listener<S> {\n+    /// Wait for and accept an incoming connection\n+    ///\n+    /// Returns `None` on timeout.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises `io_error` condition. If the condition is handled,\n+    /// then `accept` returns `None`.\n+    fn accept(&mut self) -> Option<S>;\n+}"}, {"sha": "ddd75cd8415f3c72dc2125259df545fa0f02697c", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use super::*;\n+use super::super::*;\n+use super::ip::IpAddr;\n+\n+pub struct TcpStream;\n+\n+impl TcpStream {\n+    pub fn connect(_addr: IpAddr) -> Result<TcpStream, IoError> {\n+        fail!()\n+    }\n+}\n+\n+impl Reader for TcpStream {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Writer for TcpStream {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Closeable for TcpStream {\n+    fn close(&mut self) { fail!() }\n+}\n+\n+pub struct TcpListener;\n+\n+impl TcpListener {\n+    pub fn new(_addr: IpAddr) -> TcpListener {\n+        fail!()\n+    }\n+}\n+\n+impl Listener<TcpStream> for TcpListener {\n+    fn accept(&mut self) -> Option<TcpStream> { fail!() }\n+}"}, {"sha": "a0f7aa819899e192b6ab78035aaa964596fbfc19", "filename": "src/libcore/rt/io/net/udp.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use super::*;\n+use super::super::*;\n+use super::ip::IpAddr;\n+\n+pub struct UdpStream;\n+\n+impl UdpStream {\n+    pub fn connect(_addr: IpAddr) -> Result<UdpStream, IoError> {\n+        fail!()\n+    }\n+}\n+\n+impl Reader for UdpStream {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Writer for UdpStream {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Closeable for UdpStream {\n+    fn close(&mut self) { fail!() }\n+}\n+\n+pub struct UdpListener;\n+\n+impl UdpListener {\n+    pub fn new(_addr: IpAddr) -> UdpListener {\n+        fail!()\n+    }\n+}\n+\n+impl Listener<UdpStream> for UdpListener {\n+    fn accept(&mut self) -> Option<UdpStream> { fail!() }\n+}\n+"}, {"sha": "fde87deef33f5e18d79aabddcd968e8717ee11d1", "filename": "src/libcore/rt/io/net/unix.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use super::*;\n+use super::super::*;\n+use super::super::misc::PathLike;\n+\n+pub struct UnixStream;\n+\n+impl UnixStream {\n+    pub fn connect<P: PathLike>(_path: &P) -> Result<UnixStream, IoError> {\n+        fail!()\n+    }\n+}\n+\n+impl Reader for UnixStream {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Writer for UnixStream {\n+    fn write(&mut self, _v: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Closeable for UnixStream {\n+    fn close(&mut self) { fail!() }\n+}\n+\n+pub struct UnixListener;\n+\n+impl UnixListener {\n+    pub fn new<P: PathLike>(_path: &P) -> UnixListener {\n+        fail!()\n+    }\n+}\n+\n+impl Listener<UnixStream> for UnixListener {\n+    fn accept(&mut self) -> Option<UnixStream> { fail!() }\n+}\n+"}, {"sha": "3a742266f81a4d5155b37f7878d1c1527a0064a4", "filename": "src/libcore/rt/io/stdio.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fstdio.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use super::{Reader, Writer, Closeable};\n+\n+pub fn stdin() -> StdReader { fail!() }\n+\n+pub fn stdout() -> StdWriter { fail!() }\n+\n+pub fn stderr() -> StdReader { fail!() }\n+\n+pub fn print(s: &str) { fail!() }\n+\n+pub fn println(s: &str) { fail!() }\n+\n+pub enum StdStream {\n+    StdIn,\n+    StdOut,\n+    StdErr\n+}\n+\n+pub struct StdReader;\n+\n+impl StdReader {\n+    pub fn new(_stream: StdStream) -> StdReader { fail!() }\n+}\n+\n+impl Reader for StdReader {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Closeable for StdReader {\n+    fn close(&mut self) { fail!() }\n+}\n+\n+pub struct StdWriter;\n+\n+impl StdWriter {\n+    pub fn new(_stream: StdStream) -> StdWriter { fail!() }\n+}\n+\n+impl Writer for StdWriter {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Closeable for StdWriter {\n+    fn close(&mut self) { fail!() }\n+}"}, {"sha": "d695815adcebc1486009cf6edb99203b55450fbb", "filename": "src/libcore/rt/io/util.rs", "status": "added", "additions": 469, "deletions": 0, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Futil.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -0,0 +1,469 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Utility mixins that apply to all Readers and Writers\n+\n+// TODO: Not sure how this should be structured\n+// TODO: Iteration should probably be considered seperately\n+\n+pub trait ReaderUtil {\n+\n+    /// Reads `len` bytes and gives you back a new vector\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns an empty\n+    /// vector if the condition is handled.\n+    fn read_bytes(&mut self, len: uint) -> ~[u8];\n+\n+    /// Reads all remaining bytes from the stream.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns an empty\n+    /// vector if the condition is handled.\n+    fn read_to_end(&mut self) -> ~[u8];\n+\n+}\n+\n+pub trait ReaderByteConversions {\n+    /// Reads `n` little-endian unsigned integer bytes.\n+    ///\n+    /// `n` must be between 1 and 8, inclusive.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_uint_n(&mut self, nbytes: uint) -> u64;\n+\n+    /// Reads `n` little-endian signed integer bytes.\n+    ///\n+    /// `n` must be between 1 and 8, inclusive.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_int_n(&mut self, nbytes: uint) -> i64;\n+\n+    /// Reads `n` big-endian unsigned integer bytes.\n+    ///\n+    /// `n` must be between 1 and 8, inclusive.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_uint_n(&mut self, nbytes: uint) -> u64;\n+\n+    /// Reads `n` big-endian signed integer bytes.\n+    ///\n+    /// `n` must be between 1 and 8, inclusive.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_int_n(&mut self, nbytes: uint) -> i64;\n+\n+    /// Reads a little-endian unsigned integer.\n+    ///\n+    /// The number of bytes returned is system-dependant.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_uint(&mut self) -> uint;\n+\n+    /// Reads a little-endian integer.\n+    ///\n+    /// The number of bytes returned is system-dependant.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_int(&mut self) -> int;\n+\n+    /// Reads a big-endian unsigned integer.\n+    ///\n+    /// The number of bytes returned is system-dependant.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_uint(&mut self) -> uint;\n+\n+    /// Reads a big-endian integer.\n+    ///\n+    /// The number of bytes returned is system-dependant.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_int(&mut self) -> int;\n+\n+    /// Reads a big-endian `u64`.\n+    ///\n+    /// `u64`s are 8 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_u64(&mut self) -> u64;\n+\n+    /// Reads a big-endian `u32`.\n+    ///\n+    /// `u32`s are 4 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_u32(&mut self) -> u32;\n+\n+    /// Reads a big-endian `u16`.\n+    ///\n+    /// `u16`s are 2 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_u16(&mut self) -> u16;\n+\n+    /// Reads a big-endian `i64`.\n+    ///\n+    /// `i64`s are 8 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_i64(&mut self) -> i64;\n+\n+    /// Reads a big-endian `i32`.\n+    ///\n+    /// `i32`s are 4 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_i32(&mut self) -> i32;\n+\n+    /// Reads a big-endian `i16`.\n+    ///\n+    /// `i16`s are 2 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_i16(&mut self) -> i16;\n+\n+    /// Reads a big-endian `f64`.\n+    ///\n+    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_f64(&mut self) -> f64;\n+\n+    /// Reads a big-endian `f32`.\n+    ///\n+    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_f32(&mut self) -> f32;\n+\n+    /// Reads a little-endian `u64`.\n+    ///\n+    /// `u64`s are 8 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_u64(&mut self) -> u64;\n+\n+    /// Reads a little-endian `u32`.\n+    ///\n+    /// `u32`s are 4 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_u32(&mut self) -> u32;\n+\n+    /// Reads a little-endian `u16`.\n+    ///\n+    /// `u16`s are 2 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_u16(&mut self) -> u16;\n+\n+    /// Reads a little-endian `i64`.\n+    ///\n+    /// `i64`s are 8 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_i64(&mut self) -> i64;\n+\n+    /// Reads a little-endian `i32`.\n+    ///\n+    /// `i32`s are 4 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_i32(&mut self) -> i32;\n+\n+    /// Reads a little-endian `i16`.\n+    ///\n+    /// `i16`s are 2 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_i16(&mut self) -> i16;\n+\n+    /// Reads a little-endian `f64`.\n+    ///\n+    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_f64(&mut self) -> f64;\n+\n+    /// Reads a little-endian `f32`.\n+    ///\n+    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_f32(&mut self) -> f32;\n+\n+    /// Read a u8.\n+    ///\n+    /// `u8`s are 1 byte.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_u8(&mut self) -> u8;\n+\n+    /// Read an i8.\n+    ///\n+    /// `i8`s are 1 byte.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_i8(&mut self) -> i8;\n+\n+}\n+\n+pub trait WriterByteConversions {\n+    /// Write the result of passing n through `int::to_str_bytes`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_int(&mut self, n: int);\n+\n+    /// Write the result of passing n through `uint::to_str_bytes`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_uint(&mut self, n: uint);\n+\n+    /// Write a little-endian uint (number of bytes depends on system).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_uint(&mut self, n: uint);\n+\n+    /// Write a little-endian int (number of bytes depends on system).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_int(&mut self, n: int);\n+\n+    /// Write a big-endian uint (number of bytes depends on system).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_uint(&mut self, n: uint);\n+\n+    /// Write a big-endian int (number of bytes depends on system).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_int(&mut self, n: int);\n+\n+    /// Write a big-endian u64 (8 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_u64(&mut self, n: u64);\n+\n+    /// Write a big-endian u32 (4 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_u32(&mut self, n: u32);\n+\n+    /// Write a big-endian u16 (2 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_u16(&mut self, n: u16);\n+\n+    /// Write a big-endian i64 (8 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_i64(&mut self, n: i64);\n+\n+    /// Write a big-endian i32 (4 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_i32(&mut self, n: i32);\n+\n+    /// Write a big-endian i16 (2 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_i16(&mut self, n: i16);\n+\n+    /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_f64(&mut self, f: f64);\n+\n+    /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_f32(&mut self, f: f32);\n+\n+    /// Write a little-endian u64 (8 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_u64(&mut self, n: u64);\n+\n+    /// Write a little-endian u32 (4 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_u32(&mut self, n: u32);\n+\n+    /// Write a little-endian u16 (2 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_u16(&mut self, n: u16);\n+\n+    /// Write a little-endian i64 (8 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_i64(&mut self, n: i64);\n+\n+    /// Write a little-endian i32 (4 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_i32(&mut self, n: i32);\n+\n+    /// Write a little-endian i16 (2 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_i16(&mut self, n: i16);\n+\n+    /// Write a little-endian IEEE754 double-precision floating-point\n+    /// (8 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_f64(&mut self, f: f64);\n+\n+    /// Write a litten-endian IEEE754 single-precision floating-point\n+    /// (4 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_f32(&mut self, f: f32);\n+\n+    /// Write a u8 (1 byte).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_u8(&mut self, n: u8);\n+\n+    /// Write a i8 (1 byte).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_i8(&mut self, n: i8);\n+}"}, {"sha": "66eb79ba6ae4ea2669c166545c64dbac140a7b97", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -11,6 +11,8 @@\n use option::*;\n use result::*;\n \n+use super::io::net::ip::IpAddr;\n+\n // XXX: ~object doesn't work currently so these are some placeholder\n // types to use instead\n pub type EventLoopObject = super::uvio::UvEventLoop;\n@@ -43,8 +45,3 @@ pub trait Stream {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()>;\n     fn write(&mut self, buf: &[u8]) -> Result<(), ()>;\n }\n-\n-pub enum IpAddr {\n-    Ipv4(u8, u8, u8, u8, u16),\n-    Ipv6\n-}"}, {"sha": "0dc1a4d86cbc95237dc287a3765d4eaefef856ed", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -17,7 +17,7 @@ use super::{Loop, Watcher, Request, UvError, Buf, Callback, NativeHandle, NullCa\n             loop_from_watcher, status_to_maybe_uv_error,\n             install_watcher_data, get_watcher_data, drop_watcher_data,\n             vec_to_uv_buf, vec_from_uv_buf};\n-use super::super::rtio::{IpAddr, Ipv4, Ipv6};\n+use super::super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n \n #[cfg(test)]\n use unstable::run_in_bare_thread;"}, {"sha": "b069c67a5f7f0a64bf50029b877ec4a4f8d06208", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c44d7a64865c5aa9507351be881e4c18ef38e4b0/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=c44d7a64865c5aa9507351be881e4c18ef38e4b0", "patch": "@@ -11,6 +11,7 @@\n use option::*;\n use result::*;\n \n+use super::io::net::ip::{IpAddr, Ipv4};\n use super::uv::*;\n use super::rtio::*;\n use ops::Drop;"}]}