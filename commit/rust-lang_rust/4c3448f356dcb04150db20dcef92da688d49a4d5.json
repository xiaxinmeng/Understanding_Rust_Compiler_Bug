{"sha": "4c3448f356dcb04150db20dcef92da688d49a4d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMzQ0OGYzNTZkY2IwNDE1MGRiMjBkY2VmOTJkYTY4OGQ0OWE0ZDU=", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2017-02-08T22:43:48Z"}, "committer": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2017-02-08T22:43:48Z"}, "message": "Add equivalents of C's <ctype.h> functions to AsciiExt.\n\n * `is_ascii_alphabetic`\n * `is_ascii_uppercase`\n * `is_ascii_lowercase`\n * `is_ascii_alphanumeric`\n * `is_ascii_digit`\n * `is_ascii_hexdigit`\n * `is_ascii_punctuation`\n * `is_ascii_graphic`\n * `is_ascii_whitespace`\n * `is_ascii_control`\n\nThis addresses issue #39658.", "tree": {"sha": "fdc90261f4b6be7cb5852585a4457ecb52c6d4b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdc90261f4b6be7cb5852585a4457ecb52c6d4b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c3448f356dcb04150db20dcef92da688d49a4d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c3448f356dcb04150db20dcef92da688d49a4d5", "html_url": "https://github.com/rust-lang/rust/commit/4c3448f356dcb04150db20dcef92da688d49a4d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c3448f356dcb04150db20dcef92da688d49a4d5/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10f6a5c4431e09d355a0ba319a630e02a1e38361", "url": "https://api.github.com/repos/rust-lang/rust/commits/10f6a5c4431e09d355a0ba319a630e02a1e38361", "html_url": "https://github.com/rust-lang/rust/commit/10f6a5c4431e09d355a0ba319a630e02a1e38361"}], "stats": {"total": 838, "additions": 838, "deletions": 0}, "files": [{"sha": "cf965291fa2a6ff78204c68f105d4999243a283c", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 838, "deletions": 0, "changes": 838, "blob_url": "https://github.com/rust-lang/rust/blob/4c3448f356dcb04150db20dcef92da688d49a4d5/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c3448f356dcb04150db20dcef92da688d49a4d5/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=4c3448f356dcb04150db20dcef92da688d49a4d5", "patch": "@@ -184,6 +184,348 @@ pub trait AsciiExt {\n     /// [`to_ascii_lowercase`]: #tymethod.to_ascii_lowercase\n     #[stable(feature = \"ascii\", since = \"1.9.0\")]\n     fn make_ascii_lowercase(&mut self);\n+\n+    /// Checks if the value is an ASCII alphabetic character:\n+    /// U+0041 'A' ... U+005A 'Z' or U+0061 'a' ... U+007A 'z'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII alphabetic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(A.is_ascii_alphabetic());\n+    /// assert!(G.is_ascii_alphabetic());\n+    /// assert!(a.is_ascii_alphabetic());\n+    /// assert!(g.is_ascii_alphabetic());\n+    /// assert!(!zero.is_ascii_alphabetic());\n+    /// assert!(!percent.is_ascii_alphabetic());\n+    /// assert!(!space.is_ascii_alphabetic());\n+    /// assert!(!lf.is_ascii_alphabetic());\n+    /// assert!(!esc.is_ascii_alphabetic());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_alphabetic(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII uppercase character:\n+    /// U+0041 'A' ... U+005A 'Z'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII uppercase.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(A.is_ascii_uppercase());\n+    /// assert!(G.is_ascii_uppercase());\n+    /// assert!(!a.is_ascii_uppercase());\n+    /// assert!(!g.is_ascii_uppercase());\n+    /// assert!(!zero.is_ascii_uppercase());\n+    /// assert!(!percent.is_ascii_uppercase());\n+    /// assert!(!space.is_ascii_uppercase());\n+    /// assert!(!lf.is_ascii_uppercase());\n+    /// assert!(!esc.is_ascii_uppercase());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_uppercase(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII lowercase character:\n+    /// U+0061 'a' ... U+007A 'z'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII lowercase.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(!A.is_ascii_lowercase());\n+    /// assert!(!G.is_ascii_lowercase());\n+    /// assert!(a.is_ascii_lowercase());\n+    /// assert!(g.is_ascii_lowercase());\n+    /// assert!(!zero.is_ascii_lowercase());\n+    /// assert!(!percent.is_ascii_lowercase());\n+    /// assert!(!space.is_ascii_lowercase());\n+    /// assert!(!lf.is_ascii_lowercase());\n+    /// assert!(!esc.is_ascii_lowercase());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_lowercase(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII alphanumeric character:\n+    /// U+0041 'A' ... U+005A 'Z', U+0061 'a' ... U+007A 'z', or\n+    /// U+0030 '0' ... U+0039 '9'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII alphanumeric.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(A.is_ascii_alphanumeric());\n+    /// assert!(G.is_ascii_alphanumeric());\n+    /// assert!(a.is_ascii_alphanumeric());\n+    /// assert!(g.is_ascii_alphanumeric());\n+    /// assert!(zero.is_ascii_alphanumeric());\n+    /// assert!(!percent.is_ascii_alphanumeric());\n+    /// assert!(!space.is_ascii_alphanumeric());\n+    /// assert!(!lf.is_ascii_alphanumeric());\n+    /// assert!(!esc.is_ascii_alphanumeric());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_alphanumeric(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII decimal digit:\n+    /// U+0030 '0' ... U+0039 '9'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII digits.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(!A.is_ascii_digit());\n+    /// assert!(!G.is_ascii_digit());\n+    /// assert!(!a.is_ascii_digit());\n+    /// assert!(!g.is_ascii_digit());\n+    /// assert!(zero.is_ascii_digit());\n+    /// assert!(!percent.is_ascii_digit());\n+    /// assert!(!space.is_ascii_digit());\n+    /// assert!(!lf.is_ascii_digit());\n+    /// assert!(!esc.is_ascii_digit());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_digit(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII hexadecimal digit:\n+    /// U+0030 '0' ... U+0039 '9', U+0041 'A' ... U+0046 'F', or\n+    /// U+0061 'a' ... U+0066 'f'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII hex digits.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(A.is_ascii_hexdigit());\n+    /// assert!(!G.is_ascii_hexdigit());\n+    /// assert!(a.is_ascii_hexdigit());\n+    /// assert!(!g.is_ascii_hexdigit());\n+    /// assert!(zero.is_ascii_hexdigit());\n+    /// assert!(!percent.is_ascii_hexdigit());\n+    /// assert!(!space.is_ascii_hexdigit());\n+    /// assert!(!lf.is_ascii_hexdigit());\n+    /// assert!(!esc.is_ascii_hexdigit());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_hexdigit(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII punctuation character:\n+    /// U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`\n+    /// U+003A ... U+0040 `: ; < = > ? @`\n+    /// U+005B ... U+0060 `[ \\\\ ] ^ _ \\``\n+    /// U+007B ... U+007E `{ | } ~`\n+    /// For strings, true if all characters in the string are\n+    /// ASCII punctuation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(!A.is_ascii_punctuation());\n+    /// assert!(!G.is_ascii_punctuation());\n+    /// assert!(!a.is_ascii_punctuation());\n+    /// assert!(!g.is_ascii_punctuation());\n+    /// assert!(!zero.is_ascii_punctuation());\n+    /// assert!(percent.is_ascii_punctuation());\n+    /// assert!(!space.is_ascii_punctuation());\n+    /// assert!(!lf.is_ascii_punctuation());\n+    /// assert!(!esc.is_ascii_punctuation());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_punctuation(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII graphic character:\n+    /// U+0021 '@' ... U+007E '~'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII punctuation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(A.is_ascii_graphic());\n+    /// assert!(G.is_ascii_graphic());\n+    /// assert!(a.is_ascii_graphic());\n+    /// assert!(g.is_ascii_graphic());\n+    /// assert!(zero.is_ascii_graphic());\n+    /// assert!(percent.is_ascii_graphic());\n+    /// assert!(!space.is_ascii_graphic());\n+    /// assert!(!lf.is_ascii_graphic());\n+    /// assert!(!esc.is_ascii_graphic());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_graphic(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII whitespace character:\n+    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n+    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII whitespace.\n+    ///\n+    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n+    /// whitespace][infra-aw].  There are several other definitions in\n+    /// wide use.  For instance, [the POSIX locale][posix-ctype]\n+    /// includes U+000B VERTICAL TAB as well as all the above\n+    /// characters, but\u2014from the very same specification\u2014[the default\n+    /// rule for \"field splitting\" in the Bourne shell][field-splitting]\n+    /// considers *only* SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n+    ///\n+    /// If you are writing a program that will process an existing\n+    /// file format, check what that format's definition of whitespace is\n+    /// before using this function.\n+    ///\n+    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n+    /// [posix-ctype]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n+    /// [field-splitting]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(!A.is_ascii_whitespace());\n+    /// assert!(!G.is_ascii_whitespace());\n+    /// assert!(!a.is_ascii_whitespace());\n+    /// assert!(!g.is_ascii_whitespace());\n+    /// assert!(!zero.is_ascii_whitespace());\n+    /// assert!(!percent.is_ascii_whitespace());\n+    /// assert!(space.is_ascii_whitespace());\n+    /// assert!(lf.is_ascii_whitespace());\n+    /// assert!(!esc.is_ascii_whitespace());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_whitespace(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII control character:\n+    /// U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n+    /// Note that most ASCII whitespace characters are control\n+    /// characters, but SPACE is not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(!A.is_ascii_control());\n+    /// assert!(!G.is_ascii_control());\n+    /// assert!(!a.is_ascii_control());\n+    /// assert!(!g.is_ascii_control());\n+    /// assert!(!zero.is_ascii_control());\n+    /// assert!(!percent.is_ascii_control());\n+    /// assert!(!space.is_ascii_control());\n+    /// assert!(lf.is_ascii_control());\n+    /// assert!(esc.is_ascii_control());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_control(&self) -> bool { unimplemented!(); }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -225,6 +567,56 @@ impl AsciiExt for str {\n         let me: &mut [u8] = unsafe { mem::transmute(self) };\n         me.make_ascii_lowercase()\n     }\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_digit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_control())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -268,6 +660,56 @@ impl AsciiExt for [u8] {\n             byte.make_ascii_lowercase();\n         }\n     }\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_digit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_control())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -287,6 +729,96 @@ impl AsciiExt for u8 {\n     fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }\n     #[inline]\n     fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            L|Lx|U|Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            U|Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            L|Lx => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D|L|Lx|U|Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D|Lx|Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            P => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            Ux|U|Lx|L|D|P => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            Cw|W => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            C|Cw => true,\n+            _ => false\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -324,6 +856,56 @@ impl AsciiExt for char {\n     fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }\n     #[inline]\n     fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_alphabetic()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_uppercase()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_lowercase()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_alphanumeric()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_digit()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_hexdigit()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_punctuation()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_graphic()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_whitespace()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_control()\n+    }\n }\n \n /// An iterator over the escaped version of a byte, constructed via\n@@ -485,6 +1067,30 @@ static ASCII_UPPERCASE_MAP: [u8; 256] = [\n     0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n ];\n \n+enum AsciiCharacterClass {\n+    C,  // control\n+    Cw, // control whitespace\n+    W,  // whitespace\n+    D,  // digit\n+    L,  // lowercase\n+    Lx, // lowercase hex digit\n+    U,  // uppercase\n+    Ux, // uppercase hex digit\n+    P,  // punctuation\n+}\n+use self::AsciiCharacterClass::*;\n+\n+static ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 128] = [\n+//  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n+    C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_\n+    C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, // 1_\n+    W, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, // 2_\n+    D, D, D, D, D, D, D, D, D, D, P, P, P, P, P, P, // 3_\n+    P, Ux,Ux,Ux,Ux,Ux,Ux,U, U, U, U, U, U, U, U, U, // 4_\n+    U, U, U, U, U, U, U, U, U, U, U, P, P, P, P, P, // 5_\n+    P, Lx,Lx,Lx,Lx,Lx,Lx,L, L, L, L, L, L, L, L, L, // 6_\n+    L, L, L, L, L, L, L, L, L, L, L, P, P, P, P, C, // 7_\n+];\n \n #[cfg(test)]\n mod tests {\n@@ -606,4 +1212,236 @@ mod tests {\n         let x = \"a\".to_string();\n         x.eq_ignore_ascii_case(\"A\");\n     }\n+\n+    // Shorthands used by the is_ascii_* tests.\n+    macro_rules! assert_all {\n+        ($what:ident, $($str:tt),+) => {{\n+            $(\n+                for b in $str.chars() {\n+                    if !b.$what() {\n+                        panic!(\"expected {}({}) but it isn't\",\n+                               stringify!($what), b);\n+                    }\n+                }\n+                for b in $str.as_bytes().iter() {\n+                    if !b.$what() {\n+                        panic!(\"expected {}(0x{:02x})) but it isn't\",\n+                               stringify!($what), b);\n+                    }\n+                }\n+                assert!($str.$what());\n+                assert!($str.as_bytes().$what());\n+            )+\n+        }};\n+        ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))\n+    }\n+    macro_rules! assert_none {\n+        ($what:ident, $($str:tt),+) => {{\n+            $(\n+                for b in $str.chars() {\n+                    if b.$what() {\n+                        panic!(\"expected not-{}({}) but it is\",\n+                               stringify!($what), b);\n+                    }\n+                }\n+                for b in $str.as_bytes().iter() {\n+                    if b.$what() {\n+                        panic!(\"expected not-{}(0x{:02x})) but it is\",\n+                               stringify!($what), b);\n+                    }\n+                }\n+            )*\n+        }};\n+        ($what:ident, $($str:tt),+,) => (assert_none!($what,$($str),+))\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_alphabetic() {\n+        assert_all!(is_ascii_alphabetic,\n+            \"\",\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        );\n+        assert_none!(is_ascii_alphabetic,\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_uppercase() {\n+        assert_all!(is_ascii_uppercase,\n+            \"\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        );\n+        assert_none!(is_ascii_uppercase,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_lowercase() {\n+        assert_all!(is_ascii_lowercase,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+        );\n+        assert_none!(is_ascii_lowercase,\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_alphanumeric() {\n+        assert_all!(is_ascii_alphanumeric,\n+            \"\",\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+        );\n+        assert_none!(is_ascii_alphanumeric,\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_digit() {\n+        assert_all!(is_ascii_digit,\n+            \"\",\n+            \"0123456789\",\n+        );\n+        assert_none!(is_ascii_digit,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_hexdigit() {\n+        assert_all!(is_ascii_hexdigit,\n+            \"\",\n+            \"0123456789\",\n+            \"abcdefABCDEF\",\n+        );\n+        assert_none!(is_ascii_hexdigit,\n+            \"ghijklmnopqrstuvwxyz\",\n+            \"GHIJKLMNOQPRSTUVWXYZ\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_punctuation() {\n+        assert_all!(is_ascii_punctuation,\n+            \"\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        );\n+        assert_none!(is_ascii_punctuation,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_graphic() {\n+        assert_all!(is_ascii_graphic,\n+            \"\",\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        );\n+        assert_none!(is_ascii_graphic,\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_whitespace() {\n+        assert_all!(is_ascii_whitespace,\n+            \"\",\n+            \" \\t\\n\\x0c\\r\",\n+        );\n+        assert_none!(is_ascii_whitespace,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x0b\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_control() {\n+        assert_all!(is_ascii_control,\n+            \"\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+        assert_none!(is_ascii_control,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \",\n+        );\n+    }\n }"}]}