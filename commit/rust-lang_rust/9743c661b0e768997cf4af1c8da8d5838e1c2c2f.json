{"sha": "9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NDNjNjYxYjBlNzY4OTk3Y2Y0YWYxYzhkYThkNTgzOGUxYzJjMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-18T12:04:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-18T12:04:26Z"}, "message": "Auto merge of #33710 - Manishearth:rollup, r=Manishearth\n\nRollup of 5 pull requests\n\n- Successful merges: #33656, #33666, #33673, #33675, #33695\n- Failed merges:", "tree": {"sha": "e8cfab86268a4efe3a54225e186c943d94f2a434", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8cfab86268a4efe3a54225e186c943d94f2a434"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "html_url": "https://github.com/rust-lang/rust/commit/9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "310d8996f40fceaa8d294577276cfb1b080c8bc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/310d8996f40fceaa8d294577276cfb1b080c8bc9", "html_url": "https://github.com/rust-lang/rust/commit/310d8996f40fceaa8d294577276cfb1b080c8bc9"}, {"sha": "07194a035089407e2706b543f29eba68f0e9abd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/07194a035089407e2706b543f29eba68f0e9abd5", "html_url": "https://github.com/rust-lang/rust/commit/07194a035089407e2706b543f29eba68f0e9abd5"}], "stats": {"total": 79, "additions": 55, "deletions": 24}, "files": [{"sha": "c5db2a8a7807b99c6729d9ae51a67ee9a423e10a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "patch": "@@ -38,6 +38,7 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::specialize::{OverlapError, specialization_graph, specializes, translate_substs};\n+pub use self::specialize::{SpecializesCache};\n pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;"}, {"sha": "b2d14dab9a0b0463ce6f623e8bec3cb150e389f4", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "patch": "@@ -20,6 +20,7 @@\n use super::{SelectionContext, FulfillmentContext};\n use super::util::{fresh_type_vars_for_impl, impl_trait_ref_and_oblig};\n \n+use rustc_data_structures::fnv::FnvHashMap;\n use hir::def_id::DefId;\n use infer::{InferCtxt, TypeOrigin};\n use middle::region;\n@@ -111,6 +112,10 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              impl1_def_id: DefId,\n                              impl2_def_id: DefId) -> bool {\n+    if let Some(r) = tcx.specializes_cache.borrow().check(impl1_def_id, impl2_def_id) {\n+        return r;\n+    }\n+\n     // The feature gate should prevent introducing new specializations, but not\n     // taking advantage of upstream ones.\n     if !tcx.sess.features.borrow().specialization &&\n@@ -146,7 +151,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              .unwrap()\n                              .subst(tcx, &penv.free_substs);\n \n-    tcx.normalizing_infer_ctxt(ProjectionMode::Topmost).enter(|mut infcx| {\n+    let result = tcx.normalizing_infer_ctxt(ProjectionMode::Topmost).enter(|mut infcx| {\n         // Normalize the trait reference, adding any obligations\n         // that arise into the impl1 assumptions.\n         let Normalized { value: impl1_trait_ref, obligations: normalization_obligations } = {\n@@ -167,7 +172,10 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Attempt to prove that impl2 applies, given all of the above.\n         fulfill_implication(&infcx, impl1_trait_ref, impl2_def_id).is_ok()\n-    })\n+    });\n+\n+    tcx.specializes_cache.borrow_mut().insert(impl1_def_id, impl2_def_id, result);\n+    result\n }\n \n /// Attempt to fulfill all obligations of `target_impl` after unification with\n@@ -225,3 +233,23 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n         }\n     })\n }\n+\n+pub struct SpecializesCache {\n+    map: FnvHashMap<(DefId, DefId), bool>\n+}\n+\n+impl SpecializesCache {\n+    pub fn new() -> Self {\n+        SpecializesCache {\n+            map: FnvHashMap()\n+        }\n+    }\n+\n+    pub fn check(&self, a: DefId, b: DefId) -> Option<bool> {\n+        self.map.get(&(a, b)).cloned()\n+    }\n+\n+    pub fn insert(&mut self, a: DefId, b: DefId, result: bool) {\n+        self.map.insert((a, b), result);\n+    }\n+}"}, {"sha": "aa50266977795ad642460b3db58293337b4c29c6", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "patch": "@@ -291,6 +291,8 @@ impl<'a, 'gcx, 'tcx> Deref for TyCtxt<'a, 'gcx, 'tcx> {\n pub struct GlobalCtxt<'tcx> {\n     global_interners: CtxtInterners<'tcx>,\n \n+    pub specializes_cache: RefCell<traits::SpecializesCache>,\n+\n     pub dep_graph: DepGraph,\n \n     /// Common types, pre-interned for your convenience.\n@@ -637,6 +639,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let dep_graph = map.dep_graph.clone();\n         let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n         tls::enter_global(GlobalCtxt {\n+            specializes_cache: RefCell::new(traits::SpecializesCache::new()),\n             global_interners: interners,\n             dep_graph: dep_graph.clone(),\n             types: common_types,"}, {"sha": "b5d8192b4dd2c89d37385167558ab33b86f1a810", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "patch": "@@ -391,6 +391,7 @@ fn you_know_nothing(jon_snow: &mut i32) {\n                        //        but it is already borrowed\n     };\n }\n+```\n \n In here, `jon_snow` is already borrowed by the `nights_watch` closure, so it\n cannot be borrowed by the `starks` closure at the same time. To fix this issue,"}, {"sha": "ca138168b2954207f5f4ec0af0b41d520214df11", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "patch": "@@ -795,7 +795,17 @@ impl Clean<Lifetime> for hir::Lifetime {\n \n impl Clean<Lifetime> for hir::LifetimeDef {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n-        Lifetime(self.lifetime.name.to_string())\n+        if self.bounds.len() > 0 {\n+            let mut s = format!(\"{}: {}\",\n+                                self.lifetime.name.to_string(),\n+                                self.bounds[0].name.to_string());\n+            for bound in self.bounds.iter().skip(1) {\n+                s.push_str(&format!(\" + {}\", bound.name.to_string()));\n+            }\n+            Lifetime(s)\n+        } else {\n+            Lifetime(self.lifetime.name.to_string())\n+        }\n     }\n }\n "}, {"sha": "a52a914fea680766853614fefe796a99163923ea", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "patch": "@@ -640,6 +640,10 @@ span.since {\n     margin-right: 5px;\n }\n \n+:target > code {\n+   background: #FDFFD3;\n+}\n+\n /* Media Queries */\n \n @media (max-width: 700px) {"}, {"sha": "abfa65580646dd51df6d8b8c49ce0e4c464cff72", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9743c661b0e768997cf4af1c8da8d5838e1c2c2f/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=9743c661b0e768997cf4af1c8da8d5838e1c2c2f", "patch": "@@ -67,8 +67,7 @@ struct Context<'a, 'b:'a> {\n \n     name_positions: HashMap<String, usize>,\n \n-    /// Updated as arguments are consumed or methods are entered\n-    nest_level: usize,\n+    /// Updated as arguments are consumed\n     next_arg: usize,\n }\n \n@@ -164,9 +163,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let pos = match arg.position {\n                     parse::ArgumentNext => {\n                         let i = self.next_arg;\n-                        if self.check_positional_ok() {\n-                            self.next_arg += 1;\n-                        }\n+                        self.next_arg += 1;\n                         Exact(i)\n                     }\n                     parse::ArgumentIs(i) => Exact(i),\n@@ -189,25 +186,13 @@ impl<'a, 'b> Context<'a, 'b> {\n                 self.verify_arg_type(Named(s.to_string()), Unsigned);\n             }\n             parse::CountIsNextParam => {\n-                if self.check_positional_ok() {\n-                    let next_arg = self.next_arg;\n-                    self.verify_arg_type(Exact(next_arg), Unsigned);\n-                    self.next_arg += 1;\n-                }\n+                let next_arg = self.next_arg;\n+                self.verify_arg_type(Exact(next_arg), Unsigned);\n+                self.next_arg += 1;\n             }\n         }\n     }\n \n-    fn check_positional_ok(&mut self) -> bool {\n-        if self.nest_level != 0 {\n-            self.ecx.span_err(self.fmtsp, \"cannot use implicit positional \\\n-                                           arguments nested inside methods\");\n-            false\n-        } else {\n-            true\n-        }\n-    }\n-\n     fn describe_num_args(&self) -> String {\n         match self.args.len() {\n             0 => \"no arguments given\".to_string(),\n@@ -655,7 +640,6 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         name_positions: HashMap::new(),\n         name_types: HashMap::new(),\n         name_ordering: name_ordering,\n-        nest_level: 0,\n         next_arg: 0,\n         literal: String::new(),\n         pieces: Vec::new(),"}]}