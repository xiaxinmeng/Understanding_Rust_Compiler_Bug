{"sha": "b1c357e0c366f5fb865151a9dd144413b4bf6911", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYzM1N2UwYzM2NmY1ZmI4NjUxNTFhOWRkMTQ0NDEzYjRiZjY5MTE=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-06-04T15:03:43Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-06-09T20:09:36Z"}, "message": "Introduce InnerSpan abstraction\n\nThis should be used when trying to get at subsets of a larger span,\nespecially when the larger span is not available in the code attempting\nto work with those subsets (especially common in the fmt_macros crate).\n\nThis is usually a good replacement for (BytePos, BytePos) and (usize,\nusize) tuples.\n\nThis commit also removes from_inner_byte_pos, since it took usize\narguments, which is error prone.", "tree": {"sha": "9c0c883525300d8ad063b6b3eba2f07f7740c7d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c0c883525300d8ad063b6b3eba2f07f7740c7d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1c357e0c366f5fb865151a9dd144413b4bf6911", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1c357e0c366f5fb865151a9dd144413b4bf6911", "html_url": "https://github.com/rust-lang/rust/commit/b1c357e0c366f5fb865151a9dd144413b4bf6911", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1c357e0c366f5fb865151a9dd144413b4bf6911/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8594400927c7363d24625ea1521b89c344ec03d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8594400927c7363d24625ea1521b89c344ec03d", "html_url": "https://github.com/rust-lang/rust/commit/a8594400927c7363d24625ea1521b89c344ec03d"}], "stats": {"total": 157, "additions": 82, "deletions": 75}, "files": [{"sha": "66355801b6c54d7acd6f3248379e3aeedf111b94", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b1c357e0c366f5fb865151a9dd144413b4bf6911/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c357e0c366f5fb865151a9dd144413b4bf6911/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=b1c357e0c366f5fb865151a9dd144413b4bf6911", "patch": "@@ -24,7 +24,16 @@ use std::str;\n use std::string;\n use std::iter;\n \n-use syntax_pos::Symbol;\n+use syntax_pos::{InnerSpan, Symbol};\n+\n+#[derive(Copy, Clone)]\n+struct InnerOffset(usize);\n+\n+impl InnerOffset {\n+    fn to(self, end: InnerOffset) -> InnerSpan {\n+        InnerSpan::new(self.0, end.0)\n+    }\n+}\n \n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n@@ -136,9 +145,8 @@ pub struct ParseError {\n     pub description: string::String,\n     pub note: Option<string::String>,\n     pub label: string::String,\n-    pub start: SpanIndex,\n-    pub end: SpanIndex,\n-    pub secondary_label: Option<(string::String, SpanIndex, SpanIndex)>,\n+    pub span: InnerSpan,\n+    pub secondary_label: Option<(string::String, InnerSpan)>,\n }\n \n /// The parser structure for interpreting the input format string. This is\n@@ -157,44 +165,36 @@ pub struct Parser<'a> {\n     /// `Some(raw count)` when the string is \"raw\", used to position spans correctly\n     style: Option<usize>,\n     /// Start and end byte offset of every successfully parsed argument\n-    pub arg_places: Vec<(SpanIndex, SpanIndex)>,\n+    pub arg_places: Vec<InnerSpan>,\n     /// Characters that need to be shifted\n     skips: Vec<usize>,\n-    /// Span offset of the last opening brace seen, used for error reporting\n-    last_opening_brace_pos: Option<SpanIndex>,\n+    /// Span of the last opening brace seen, used for error reporting\n+    last_opening_brace: Option<InnerSpan>,\n     /// Wether the source string is comes from `println!` as opposed to `format!` or `print!`\n     append_newline: bool,\n }\n \n-#[derive(Clone, Copy, Debug)]\n-pub struct SpanIndex(pub usize);\n-\n-impl SpanIndex {\n-    pub fn unwrap(self) -> usize {\n-        self.0\n-    }\n-}\n-\n impl<'a> Iterator for Parser<'a> {\n     type Item = Piece<'a>;\n \n     fn next(&mut self) -> Option<Piece<'a>> {\n         if let Some(&(pos, c)) = self.cur.peek() {\n             match c {\n                 '{' => {\n-                    let curr_last_brace = self.last_opening_brace_pos;\n-                    self.last_opening_brace_pos = Some(self.to_span_index(pos));\n+                    let curr_last_brace = self.last_opening_brace;\n+                    let byte_pos = self.to_span_index(pos);\n+                    self.last_opening_brace = Some(byte_pos.to(byte_pos));\n                     self.cur.next();\n                     if self.consume('{') {\n-                        self.last_opening_brace_pos = curr_last_brace;\n+                        self.last_opening_brace = curr_last_brace;\n \n                         Some(String(self.string(pos + 1)))\n                     } else {\n                         let arg = self.argument();\n-                        if let Some(arg_pos) = self.must_consume('}').map(|end| {\n-                            (self.to_span_index(pos), self.to_span_index(end + 1))\n-                        }) {\n-                            self.arg_places.push(arg_pos);\n+                        if let Some(end) = self.must_consume('}') {\n+                            let start = self.to_span_index(pos);\n+                            let end = self.to_span_index(end + 1);\n+                            self.arg_places.push(start.to(end));\n                         }\n                         Some(NextArgument(arg))\n                     }\n@@ -209,8 +209,7 @@ impl<'a> Iterator for Parser<'a> {\n                             \"unmatched `}` found\",\n                             \"unmatched `}`\",\n                             \"if you intended to print `}`, you can escape it using `}}`\",\n-                            err_pos,\n-                            err_pos,\n+                            err_pos.to(err_pos),\n                         );\n                         None\n                     }\n@@ -242,7 +241,7 @@ impl<'a> Parser<'a> {\n             style,\n             arg_places: vec![],\n             skips,\n-            last_opening_brace_pos: None,\n+            last_opening_brace: None,\n             append_newline,\n         }\n     }\n@@ -254,15 +253,13 @@ impl<'a> Parser<'a> {\n         &mut self,\n         description: S1,\n         label: S2,\n-        start: SpanIndex,\n-        end: SpanIndex,\n+        span: InnerSpan,\n     ) {\n         self.errors.push(ParseError {\n             description: description.into(),\n             note: None,\n             label: label.into(),\n-            start,\n-            end,\n+            span,\n             secondary_label: None,\n         });\n     }\n@@ -275,15 +272,13 @@ impl<'a> Parser<'a> {\n         description: S1,\n         label: S2,\n         note: S3,\n-        start: SpanIndex,\n-        end: SpanIndex,\n+        span: InnerSpan,\n     ) {\n         self.errors.push(ParseError {\n             description: description.into(),\n             note: Some(note.into()),\n             label: label.into(),\n-            start,\n-            end,\n+            span,\n             secondary_label: None,\n         });\n     }\n@@ -304,7 +299,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn to_span_index(&self, pos: usize) -> SpanIndex {\n+    fn to_span_index(&self, pos: usize) -> InnerOffset {\n         let mut pos = pos;\n         let raw = self.style.map(|raw| raw + 1).unwrap_or(0);\n         for skip in &self.skips {\n@@ -316,7 +311,7 @@ impl<'a> Parser<'a> {\n                 break;\n             }\n         }\n-        SpanIndex(raw + pos + 1)\n+        InnerOffset(raw + pos + 1)\n     }\n \n     /// Forces consumption of the specified character. If the character is not\n@@ -334,8 +329,8 @@ impl<'a> Parser<'a> {\n                 let label = \"expected `}`\".to_owned();\n                 let (note, secondary_label) = if c == '}' {\n                     (Some(\"if you intended to print `{`, you can escape it using `{{`\".to_owned()),\n-                     self.last_opening_brace_pos.map(|pos| {\n-                        (\"because of this opening brace\".to_owned(), pos, pos)\n+                     self.last_opening_brace.map(|sp| {\n+                        (\"because of this opening brace\".to_owned(), sp)\n                      }))\n                 } else {\n                     (None, None)\n@@ -344,8 +339,7 @@ impl<'a> Parser<'a> {\n                     description,\n                     note,\n                     label,\n-                    start: pos,\n-                    end: pos,\n+                    span: pos.to(pos),\n                     secondary_label,\n                 });\n                 None\n@@ -359,8 +353,8 @@ impl<'a> Parser<'a> {\n                 let label = format!(\"expected `{:?}`\", c);\n                 let (note, secondary_label) = if c == '}' {\n                     (Some(\"if you intended to print `{`, you can escape it using `{{`\".to_owned()),\n-                     self.last_opening_brace_pos.map(|pos| {\n-                        (\"because of this opening brace\".to_owned(), pos, pos)\n+                     self.last_opening_brace.map(|sp| {\n+                        (\"because of this opening brace\".to_owned(), sp)\n                      }))\n                 } else {\n                     (None, None)\n@@ -369,12 +363,11 @@ impl<'a> Parser<'a> {\n                     description,\n                     note,\n                     label,\n-                    start: pos,\n-                    end: pos,\n+                    span: pos.to(pos),\n                     secondary_label,\n                 });\n             } else {\n-                self.err(description, format!(\"expected `{:?}`\", c), pos, pos);\n+                self.err(description, format!(\"expected `{:?}`\", c), pos.to(pos));\n             }\n             None\n         }\n@@ -446,8 +439,10 @@ impl<'a> Parser<'a> {\n                     self.err_with_note(format!(\"invalid argument name `{}`\", invalid_name),\n                                        \"invalid argument name\",\n                                        \"argument names cannot start with an underscore\",\n-                                       self.to_span_index(pos),\n-                                       self.to_span_index(pos + invalid_name.len()));\n+                                        self.to_span_index(pos).to(\n+                                            self.to_span_index(pos + invalid_name.len())\n+                                        ),\n+                                        );\n                     Some(ArgumentNamed(Symbol::intern(invalid_name)))\n                 },\n "}, {"sha": "6d51278b4e5e88315e74c52248e1499aa8bdd6c2", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c357e0c366f5fb865151a9dd144413b4bf6911/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c357e0c366f5fb865151a9dd144413b4bf6911/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=b1c357e0c366f5fb865151a9dd144413b4bf6911", "patch": "@@ -2,7 +2,7 @@ use errors::Applicability;\n use syntax::parse::lexer::{StringReader as Lexer};\n use syntax::parse::{ParseSess, token};\n use syntax::source_map::FilePathMapping;\n-use syntax_pos::FileName;\n+use syntax_pos::{InnerSpan, FileName};\n \n use crate::clean;\n use crate::core::DocContext;\n@@ -63,7 +63,7 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n                 }\n \n                 if code_block.syntax.is_none() && code_block.is_fenced {\n-                    let sp = sp.from_inner_byte_pos(0, 3);\n+                    let sp = sp.from_inner(InnerSpan::new(0, 3));\n                     diag.span_suggestion(\n                         sp,\n                         \"mark blocks that do not contain Rust code as text\","}, {"sha": "8fc6b9fdbe6b93d9b4f99636d6f1e7f01375b2b6", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c357e0c366f5fb865151a9dd144413b4bf6911/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c357e0c366f5fb865151a9dd144413b4bf6911/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=b1c357e0c366f5fb865151a9dd144413b4bf6911", "patch": "@@ -6,7 +6,7 @@ use rustc::lint as lint;\n use rustc::middle::privacy::AccessLevels;\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::{DUMMY_SP, InnerSpan, Span};\n use std::ops::Range;\n \n use crate::clean::{self, GetDefId, Item};\n@@ -440,10 +440,10 @@ crate fn source_span_for_markdown_range(\n         }\n     }\n \n-    let sp = span_of_attrs(attrs).from_inner_byte_pos(\n+    let sp = span_of_attrs(attrs).from_inner(InnerSpan::new(\n         md_range.start + start_bytes,\n         md_range.end + start_bytes + end_bytes,\n-    );\n+    ));\n \n     Some(sp)\n }"}, {"sha": "85b524786b2f5d8eb572acabcaa0eac8c392d61a", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1c357e0c366f5fb865151a9dd144413b4bf6911/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c357e0c366f5fb865151a9dd144413b4bf6911/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=b1c357e0c366f5fb865151a9dd144413b4bf6911", "patch": "@@ -900,25 +900,23 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n \n     if !parser.errors.is_empty() {\n         let err = parser.errors.remove(0);\n-        let sp = fmt.span.from_inner_byte_pos(err.start.unwrap(), err.end.unwrap());\n+        let sp = fmt.span.from_inner(err.span);\n         let mut e = ecx.struct_span_err(sp, &format!(\"invalid format string: {}\",\n                                                      err.description));\n         e.span_label(sp, err.label + \" in format string\");\n         if let Some(note) = err.note {\n             e.note(&note);\n         }\n-        if let Some((label, start, end)) = err.secondary_label {\n-            let sp = fmt.span.from_inner_byte_pos(start.unwrap(), end.unwrap());\n+        if let Some((label, span)) = err.secondary_label {\n+            let sp = fmt.span.from_inner(span);\n             e.span_label(sp, label);\n         }\n         e.emit();\n         return DummyResult::raw_expr(sp, true);\n     }\n \n     let arg_spans = parser.arg_places.iter()\n-        .map(|&(parse::SpanIndex(start), parse::SpanIndex(end))| {\n-            fmt.span.from_inner_byte_pos(start, end)\n-        })\n+        .map(|span| fmt.span.from_inner(*span))\n         .collect();\n \n     let mut cx = Context {\n@@ -1065,8 +1063,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n                             show_doc_note = true;\n                         }\n \n-                        if let Some((start, end)) = pos {\n-                            let sp = fmt_sp.from_inner_byte_pos(start, end);\n+                        if let Some(inner_sp) = pos {\n+                            let sp = fmt_sp.from_inner(inner_sp);\n                             suggestions.push((sp, trn));\n                         } else {\n                             diag.help(&format!(\"`{}` should be written as `{}`\", sub, trn));"}, {"sha": "7ad5997bf2c097c0942bdb4f55615e0a78c14344", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b1c357e0c366f5fb865151a9dd144413b4bf6911/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c357e0c366f5fb865151a9dd144413b4bf6911/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=b1c357e0c366f5fb865151a9dd144413b4bf6911", "patch": "@@ -1,5 +1,6 @@\n pub mod printf {\n     use super::strcursor::StrCursor as Cur;\n+    use syntax_pos::InnerSpan;\n \n     /// Represents a single `printf`-style substitution.\n     #[derive(Clone, PartialEq, Debug)]\n@@ -18,7 +19,7 @@ pub mod printf {\n             }\n         }\n \n-        pub fn position(&self) -> Option<(usize, usize)> {\n+        pub fn position(&self) -> Option<InnerSpan> {\n             match *self {\n                 Substitution::Format(ref fmt) => Some(fmt.position),\n                 _ => None,\n@@ -28,7 +29,7 @@ pub mod printf {\n         pub fn set_position(&mut self, start: usize, end: usize) {\n             match self {\n                 Substitution::Format(ref mut fmt) => {\n-                    fmt.position = (start, end);\n+                    fmt.position = InnerSpan::new(start, end);\n                 }\n                 _ => {}\n             }\n@@ -65,7 +66,7 @@ pub mod printf {\n         /// Type of parameter being converted.\n         pub type_: &'a str,\n         /// Byte offset for the start and end of this formatting directive.\n-        pub position: (usize, usize),\n+        pub position: InnerSpan,\n     }\n \n     impl Format<'_> {\n@@ -282,9 +283,9 @@ pub mod printf {\n             let (mut sub, tail) = parse_next_substitution(self.s)?;\n             self.s = tail;\n             match sub {\n-                Substitution::Format(_) => if let Some((start, end)) = sub.position() {\n-                    sub.set_position(start + self.pos, end + self.pos);\n-                    self.pos += end;\n+                Substitution::Format(_) => if let Some(inner_span) = sub.position() {\n+                    sub.set_position(inner_span.start + self.pos, inner_span.end + self.pos);\n+                    self.pos += inner_span.end;\n                 }\n                 Substitution::Escape => self.pos += 2,\n             }\n@@ -373,7 +374,7 @@ pub mod printf {\n                     precision: None,\n                     length: None,\n                     type_: at.slice_between(next).unwrap(),\n-                    position: (start.at, next.at),\n+                    position: InnerSpan::new(start.at, next.at),\n                 }),\n                 next.slice_after()\n             ));\n@@ -560,7 +561,7 @@ pub mod printf {\n         drop(next);\n \n         end = at;\n-        let position = (start.at, end.at);\n+        let position = InnerSpan::new(start.at, end.at);\n \n         let f = Format {\n             span: start.slice_between(end).unwrap(),\n@@ -650,7 +651,7 @@ pub mod printf {\n                                 precision: $prec,\n                                 length: $len,\n                                 type_: $type_,\n-                                position: $pos,\n+                                position: syntax_pos::InnerSpan::new($pos.0, $pos.1),\n                             }),\n                             \"!\"\n                         ))\n@@ -761,6 +762,7 @@ pub mod printf {\n \n pub mod shell {\n     use super::strcursor::StrCursor as Cur;\n+    use syntax_pos::InnerSpan;\n \n     #[derive(Clone, PartialEq, Debug)]\n     pub enum Substitution<'a> {\n@@ -778,11 +780,11 @@ pub mod shell {\n             }\n         }\n \n-        pub fn position(&self) -> Option<(usize, usize)> {\n+        pub fn position(&self) -> Option<InnerSpan> {\n             match self {\n                 Substitution::Ordinal(_, pos) |\n                 Substitution::Name(_, pos) |\n-                Substitution::Escape(pos) => Some(*pos),\n+                Substitution::Escape(pos) => Some(InnerSpan::new(pos.0, pos.1)),\n             }\n         }\n \n@@ -823,7 +825,7 @@ pub mod shell {\n             match parse_next_substitution(self.s) {\n                 Some((mut sub, tail)) => {\n                     self.s = tail;\n-                    if let Some((start, end)) = sub.position() {\n+                    if let Some(InnerSpan { start, end }) = sub.position() {\n                         sub.set_position(start + self.pos, end + self.pos);\n                         self.pos += end;\n                     }"}, {"sha": "bf0ab5fae4e8734f25eea428db46b90c8a1cf12d", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1c357e0c366f5fb865151a9dd144413b4bf6911/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c357e0c366f5fb865151a9dd144413b4bf6911/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=b1c357e0c366f5fb865151a9dd144413b4bf6911", "patch": "@@ -504,10 +504,10 @@ impl Span {\n         )\n     }\n \n-    pub fn from_inner_byte_pos(self, start: usize, end: usize) -> Span {\n+    pub fn from_inner(self, inner: InnerSpan) -> Span {\n         let span = self.data();\n-        Span::new(span.lo + BytePos::from_usize(start),\n-                  span.lo + BytePos::from_usize(end),\n+        Span::new(span.lo + BytePos::from_usize(inner.start),\n+                  span.lo + BytePos::from_usize(inner.end),\n                   span.ctxt)\n     }\n \n@@ -1395,6 +1395,18 @@ pub struct MalformedSourceMapPositions {\n     pub end_pos: BytePos\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct InnerSpan {\n+    pub start: usize,\n+    pub end: usize,\n+}\n+\n+impl InnerSpan {\n+    pub fn new(start: usize, end: usize) -> InnerSpan {\n+        InnerSpan { start, end }\n+    }\n+}\n+\n // Given a slice of line start positions and a position, returns the index of\n // the line the position is on. Returns -1 if the position is located before\n // the first line."}]}