{"sha": "0a07db438be8ce8ce969b1244e8796d65a964d31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMDdkYjQzOGJlOGNlOGNlOTY5YjEyNDRlODc5NmQ2NWE5NjRkMzE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-22T20:53:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-22T20:53:23Z"}, "message": "rollup merge of #19964: pnkfelix/everybody-loops-pprint\n\nConflicts:\n\tsrc/librustc/session/config.rs\n\tsrc/librustc_driver/lib.rs\n\tsrc/librustc_driver/pretty.rs", "tree": {"sha": "2590e10665d97bcef90de92493cb6307c2206ff6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2590e10665d97bcef90de92493cb6307c2206ff6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a07db438be8ce8ce969b1244e8796d65a964d31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a07db438be8ce8ce969b1244e8796d65a964d31", "html_url": "https://github.com/rust-lang/rust/commit/0a07db438be8ce8ce969b1244e8796d65a964d31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a07db438be8ce8ce969b1244e8796d65a964d31/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de11710d807bed5c0a29cc0413d404552a42c89d", "url": "https://api.github.com/repos/rust-lang/rust/commits/de11710d807bed5c0a29cc0413d404552a42c89d", "html_url": "https://github.com/rust-lang/rust/commit/de11710d807bed5c0a29cc0413d404552a42c89d"}, {"sha": "34d43788e52763011b3a6559ac2dad6d6d350a06", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d43788e52763011b3a6559ac2dad6d6d350a06", "html_url": "https://github.com/rust-lang/rust/commit/34d43788e52763011b3a6559ac2dad6d6d350a06"}], "stats": {"total": 346, "additions": 277, "deletions": 69}, "files": [{"sha": "86f0655a3ad664cf963ef4cc55e63c4a6b9f8b0d", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 131, "deletions": 45, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/0a07db438be8ce8ce969b1244e8796d65a964d31/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a07db438be8ce8ce969b1244e8796d65a964d31/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0a07db438be8ce8ce969b1244e8796d65a964d31", "patch": "@@ -34,7 +34,6 @@ use syntax::parse::token::InternedString;\n \n use std::collections::HashMap;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n use std::cell::{RefCell};\n use std::fmt;\n@@ -278,7 +277,8 @@ debugging_opts! {\n         PRINT_REGION_GRAPH,\n         PARSE_ONLY,\n         NO_TRANS,\n-        NO_ANALYSIS\n+        NO_ANALYSIS,\n+        UNSTABLE_OPTIONS\n     ]\n     0\n }\n@@ -330,7 +330,8 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n      (\"no-trans\", \"Run all passes except translation; no output\", NO_TRANS),\n      (\"no-analysis\", \"Parse and expand the source, but run no analysis and\",\n       NO_TRANS),\n-    ]\n+     (\"unstable-options\", \"Adds unstable command line options to rustc interface\",\n+      UNSTABLE_OPTIONS)]\n }\n \n #[deriving(Clone)]\n@@ -653,95 +654,180 @@ pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n     }\n }\n \n+/// Returns the \"short\" subset of the stable rustc command line options.\n pub fn short_optgroups() -> Vec<getopts::OptGroup> {\n+    rustc_short_optgroups().into_iter()\n+        .filter(|g|g.is_stable())\n+        .map(|g|g.opt_group)\n+        .collect()\n+}\n+\n+/// Returns all of the stable rustc command line options.\n+pub fn optgroups() -> Vec<getopts::OptGroup> {\n+    rustc_optgroups().into_iter()\n+        .filter(|g|g.is_stable())\n+        .map(|g|g.opt_group)\n+        .collect()\n+}\n+\n+#[deriving(Copy, Clone, PartialEq, Eq, Show)]\n+pub enum OptionStability { Stable, Unstable }\n+\n+#[deriving(Clone, PartialEq, Eq)]\n+pub struct RustcOptGroup {\n+    pub opt_group: getopts::OptGroup,\n+    pub stability: OptionStability,\n+}\n+\n+impl RustcOptGroup {\n+    pub fn is_stable(&self) -> bool {\n+        self.stability == OptionStability::Stable\n+    }\n+\n+    fn stable(g: getopts::OptGroup) -> RustcOptGroup {\n+        RustcOptGroup { opt_group: g, stability: OptionStability::Stable }\n+    }\n+\n+    fn unstable(g: getopts::OptGroup) -> RustcOptGroup {\n+        RustcOptGroup { opt_group: g, stability: OptionStability::Unstable }\n+    }\n+}\n+\n+// The `opt` local module holds wrappers around the `getopts` API that\n+// adds extra rustc-specific metadata to each option; such metadata\n+// is exposed by .  The public\n+// functions below ending with `_u` are the functions that return\n+// *unstable* options, i.e. options that are only enabled when the\n+// user also passes the `-Z unstable-options` debugging flag.\n+mod opt {\n+    // The `fn opt_u` etc below are written so that we can use them\n+    // in the future; do not warn about them not being used right now.\n+    #![allow(dead_code)]\n+\n+    use getopts;\n+    use super::RustcOptGroup;\n+\n+    type R = RustcOptGroup;\n+    type S<'a> = &'a str;\n+\n+    fn stable(g: getopts::OptGroup) -> R { RustcOptGroup::stable(g) }\n+    fn unstable(g: getopts::OptGroup) -> R { RustcOptGroup::unstable(g) }\n+\n+    // FIXME (pnkfelix): We default to stable since the current set of\n+    // options is defacto stable.  However, it would be good to revise the\n+    // code so that a stable option is the thing that takes extra effort\n+    // to encode.\n+\n+    pub fn     opt(a: S, b: S, c: S, d: S) -> R { stable(getopts::optopt(a, b, c, d)) }\n+    pub fn   multi(a: S, b: S, c: S, d: S) -> R { stable(getopts::optmulti(a, b, c, d)) }\n+    pub fn    flag(a: S, b: S, c: S)       -> R { stable(getopts::optflag(a, b, c)) }\n+    pub fn flagopt(a: S, b: S, c: S, d: S) -> R { stable(getopts::optflagopt(a, b, c, d)) }\n+\n+    pub fn     opt_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optopt(a, b, c, d)) }\n+    pub fn   multi_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optmulti(a, b, c, d)) }\n+    pub fn    flag_u(a: S, b: S, c: S)       -> R { unstable(getopts::optflag(a, b, c)) }\n+    pub fn flagopt_u(a: S, b: S, c: S, d: S) -> R { unstable(getopts::optflagopt(a, b, c, d)) }\n+}\n+\n+/// Returns the \"short\" subset of the rustc command line options,\n+/// including metadata for each option, such as whether the option is\n+/// part of the stable long-term interface for rustc.\n+pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n     vec![\n-        optflag(\"h\", \"help\", \"Display this message\"),\n-        optmulti(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n-        optmulti(\"L\", \"\",   \"Add a directory to the library search path\", \"PATH\"),\n-        optmulti(\"l\", \"\",   \"Link the generated crate(s) to the specified native\n+        opt::flag(\"h\", \"help\", \"Display this message\"),\n+        opt::multi(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n+        opt::multi(\"L\", \"\",   \"Add a directory to the library search path\", \"PATH\"),\n+        opt::multi(\"l\", \"\",   \"Link the generated crate(s) to the specified native\n                              library NAME. The optional KIND can be one of,\n                              static, dylib, or framework. If omitted, dylib is\n                              assumed.\", \"NAME[:KIND]\"),\n-        optmulti(\"\", \"crate-type\", \"Comma separated list of types of crates\n+        opt::multi(\"\", \"crate-type\", \"Comma separated list of types of crates\n                                     for the compiler to emit\",\n                  \"[bin|lib|rlib|dylib|staticlib]\"),\n-        optopt(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n+        opt::opt(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n                \"NAME\"),\n-        optmulti(\"\", \"emit\", \"Comma separated list of types of output for \\\n+        opt::multi(\"\", \"emit\", \"Comma separated list of types of output for \\\n                               the compiler to emit\",\n                  \"[asm|llvm-bc|llvm-ir|obj|link|dep-info]\"),\n-        optmulti(\"\", \"print\", \"Comma separated list of compiler information to \\\n+                 \"[asm|llvm-bc|llvm-ir|obj|link]\"),\n+        opt::multi(\"\", \"print\", \"Comma separated list of compiler information to \\\n                                print on stdout\",\n                  \"[crate-name|output-file-names|sysroot]\"),\n-        optflag(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n-        optflag(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n-        optopt(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n-        optopt(\"\",  \"out-dir\", \"Write output to compiler-chosen filename \\\n+        opt::flag(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n+        opt::flag(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n+        opt::opt(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n+        opt::opt(\"\",  \"out-dir\", \"Write output to compiler-chosen filename \\\n                                 in <dir>\", \"DIR\"),\n-        optopt(\"\", \"explain\", \"Provide a detailed explanation of an error \\\n+        opt::opt(\"\", \"explain\", \"Provide a detailed explanation of an error \\\n                                message\", \"OPT\"),\n-        optflag(\"\", \"test\", \"Build a test harness\"),\n-        optopt(\"\", \"target\", \"Target triple cpu-manufacturer-kernel[-os] \\\n+        opt::flag(\"\", \"test\", \"Build a test harness\"),\n+        opt::opt(\"\", \"target\", \"Target triple cpu-manufacturer-kernel[-os] \\\n                               to compile for (see chapter 3.4 of \\\n                               http://www.sourceware.org/autobook/\n                               for details)\",\n                \"TRIPLE\"),\n-        optmulti(\"W\", \"warn\", \"Set lint warnings\", \"OPT\"),\n-        optmulti(\"A\", \"allow\", \"Set lint allowed\", \"OPT\"),\n-        optmulti(\"D\", \"deny\", \"Set lint denied\", \"OPT\"),\n-        optmulti(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n-        optmulti(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n-        optflag(\"V\", \"version\", \"Print version info and exit\"),\n-        optflag(\"v\", \"verbose\", \"Use verbose output\"),\n+        opt::multi(\"W\", \"warn\", \"Set lint warnings\", \"OPT\"),\n+        opt::multi(\"A\", \"allow\", \"Set lint allowed\", \"OPT\"),\n+        opt::multi(\"D\", \"deny\", \"Set lint denied\", \"OPT\"),\n+        opt::multi(\"F\", \"forbid\", \"Set lint forbidden\", \"OPT\"),\n+        opt::multi(\"C\", \"codegen\", \"Set a codegen option\", \"OPT[=VALUE]\"),\n+        opt::flag(\"V\", \"version\", \"Print version info and exit\"),\n+        opt::flag(\"v\", \"verbose\", \"Use verbose output\"),\n     ]\n }\n \n-// rustc command line options\n-pub fn optgroups() -> Vec<getopts::OptGroup> {\n-    let mut opts = short_optgroups();\n+/// Returns all rustc command line options, including metadata for\n+/// each option, such as whether the option is part of the stable\n+/// long-term interface for rustc.\n+pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n+    let mut opts = rustc_short_optgroups();\n     opts.push_all(&[\n-        optmulti(\"\", \"extern\", \"Specify where an external rust library is \\\n+        opt::multi(\"\", \"extern\", \"Specify where an external rust library is \\\n                                 located\",\n                  \"NAME=PATH\"),\n-        optopt(\"\", \"opt-level\", \"Optimize with possible levels 0-3\", \"LEVEL\"),\n-        optopt(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n-        optmulti(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n-        optopt(\"\", \"color\", \"Configure coloring of output:\n+        opt::opt(\"\", \"opt-level\", \"Optimize with possible levels 0-3\", \"LEVEL\"),\n+        opt::opt(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n+        opt::multi(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n+        opt::opt(\"\", \"color\", \"Configure coloring of output:\n             auto   = colorize, if output goes to a tty (default);\n             always = always colorize output;\n             never  = never colorize output\", \"auto|always|never\"),\n \n         // DEPRECATED\n-        optflag(\"\", \"print-crate-name\", \"Output the crate name and exit\"),\n-        optflag(\"\", \"print-file-name\", \"Output the file(s) that would be \\\n+        opt::flag(\"\", \"print-crate-name\", \"Output the crate name and exit\"),\n+        opt::flag(\"\", \"print-file-name\", \"Output the file(s) that would be \\\n                                         written if compilation \\\n                                         continued and exit\"),\n-        optopt(\"\",  \"debuginfo\",  \"Emit DWARF debug info to the objects created:\n+        opt::opt(\"\",  \"debuginfo\",  \"Emit DWARF debug info to the objects created:\n              0 = no debug info,\n              1 = line-tables only (for stacktraces and breakpoints),\n              2 = full debug info with variable and type information \\\n                     (same as -g)\", \"LEVEL\"),\n-        optflag(\"\", \"no-trans\", \"Run all passes except translation; no output\"),\n-        optflag(\"\", \"no-analysis\", \"Parse and expand the source, but run no \\\n+        opt::flag(\"\", \"no-trans\", \"Run all passes except translation; no output\"),\n+        opt::flag(\"\", \"no-analysis\", \"Parse and expand the source, but run no \\\n                                     analysis and produce no output\"),\n-        optflag(\"\", \"parse-only\", \"Parse only; do not compile, assemble, \\\n+        opt::flag(\"\", \"parse-only\", \"Parse only; do not compile, assemble, \\\n                                    or link\"),\n-        optflagopt(\"\", \"pretty\",\n+        opt::flagopt(\"\", \"pretty\",\n                    \"Pretty-print the input instead of compiling;\n                    valid types are: `normal` (un-annotated source),\n                    `expanded` (crates expanded),\n-                   `typed` (crates expanded, with type annotations),\n-                   `expanded,identified` (fully parenthesized, AST nodes with IDs), or\n-                   `flowgraph=<nodeid>` (graphviz formatted flowgraph for node)\",\n+                   `typed` (crates expanded, with type annotations), or\n+                   `expanded,identified` (fully parenthesized, AST nodes with IDs).\",\n                  \"TYPE\"),\n-        optflagopt(\"\", \"dep-info\",\n+        opt::flagopt_u(\"\", \"xpretty\",\n+                     \"Pretty-print the input instead of compiling, unstable variants;\n+                      valid types are any of the types for `--pretty`, as well as:\n+                      `flowgraph=<nodeid>` (graphviz formatted flowgraph for node), or\n+                      `everybody_loops` (all function bodies replaced with `loop {}`).\",\n+                     \"TYPE\"),\n+        opt::flagopt(\"\", \"dep-info\",\n                  \"Output dependency info to <filename> after compiling, \\\n                   in a format suitable for use by Makefiles\", \"FILENAME\"),\n     ]);\n     opts\n }\n \n-\n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n     cfgspecs.into_iter().map(|s| {"}, {"sha": "e2791aff14e49bcef25018d580f4a222263c7ee4", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0a07db438be8ce8ce969b1244e8796d65a964d31/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a07db438be8ce8ce969b1244e8796d65a964d31/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0a07db438be8ce8ce969b1244e8796d65a964d31", "patch": "@@ -139,8 +139,19 @@ fn run_compiler(args: &[String]) {\n     }\n \n     let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-        pretty::parse_pretty(&sess, a[])\n+        // stable pretty-print variants only\n+        pretty::parse_pretty(&sess, a.as_slice(), false)\n     });\n+    let pretty = if pretty.is_none() &&\n+        sess.debugging_opt(config::UNSTABLE_OPTIONS) {\n+            matches.opt_str(\"xpretty\").map(|a| {\n+                // extended with unstable pretty-print variants\n+                pretty::parse_pretty(&sess, a.as_slice(), true)\n+            })\n+        } else {\n+            pretty\n+        };\n+\n     match pretty.into_iter().next() {\n         Some((ppm, opt_uii)) => {\n             pretty::pretty_print_input(sess, cfg, &input, ppm, opt_uii, ofile);\n@@ -197,12 +208,16 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n     }\n }\n \n-fn usage(verbose: bool) {\n+fn usage(verbose: bool, include_unstable_options: bool) {\n     let groups = if verbose {\n-        config::optgroups()\n+        config::rustc_optgroups()\n     } else {\n-        config::short_optgroups()\n+        config::rustc_short_optgroups()\n     };\n+    let groups : Vec<_> = groups.into_iter()\n+        .filter(|x| include_unstable_options || x.is_stable())\n+        .map(|x|x.opt_group)\n+        .collect();\n     let message = format!(\"Usage: rustc [OPTIONS] INPUT\");\n     let extra_help = if verbose {\n         \"\"\n@@ -365,20 +380,45 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     let _binary = args.remove(0).unwrap();\n \n     if args.is_empty() {\n-        usage(false);\n+        // user did not write `-v` nor `-Z unstable-options`, so do not\n+        // include that extra information.\n+        usage(false, false);\n         return None;\n     }\n \n     let matches =\n         match getopts::getopts(args[], config::optgroups()[]) {\n             Ok(m) => m,\n-            Err(f) => {\n-                early_error(f.to_string()[]);\n+            Err(f_stable_attempt) => {\n+                // redo option parsing, including unstable options this time,\n+                // in anticipation that the mishandled option was one of the\n+                // unstable ones.\n+                let all_groups : Vec<getopts::OptGroup>\n+                    = config::rustc_optgroups().into_iter().map(|x|x.opt_group).collect();\n+                match getopts::getopts(args.as_slice(), all_groups.as_slice()) {\n+                    Ok(m_unstable) => {\n+                        let r = m_unstable.opt_strs(\"Z\");\n+                        let include_unstable_options = r.iter().any(|x| *x == \"unstable-options\");\n+                        if include_unstable_options {\n+                            m_unstable\n+                        } else {\n+                            early_error(f_stable_attempt.to_string().as_slice());\n+                        }\n+                    }\n+                    Err(_) => {\n+                        // ignore the error from the unstable attempt; just\n+                        // pass the error we got from the first try.\n+                        early_error(f_stable_attempt.to_string().as_slice());\n+                    }\n+                }\n             }\n         };\n \n+    let r = matches.opt_strs(\"Z\");\n+    let include_unstable_options = r.iter().any(|x| *x == \"unstable-options\");\n+\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        usage(matches.opt_present(\"verbose\"));\n+        usage(matches.opt_present(\"verbose\"), include_unstable_options);\n         return None;\n     }\n "}, {"sha": "9334c648a1f70b97a65d8d3d55ca8f69ef3cddc2", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 97, "deletions": 15, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0a07db438be8ce8ce969b1244e8796d65a964d31/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a07db438be8ce8ce969b1244e8796d65a964d31/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=0a07db438be8ce8ce969b1244e8796d65a964d31", "patch": "@@ -30,7 +30,10 @@ use rustc_borrowck::graphviz as borrowck_dot;\n \n use syntax::ast;\n use syntax::ast_map::{mod, blocks, NodePrinter};\n+use syntax::codemap;\n+use syntax::fold::{mod, Folder};\n use syntax::print::{pp, pprust};\n+use syntax::ptr::P;\n \n use graphviz as dot;\n \n@@ -42,6 +45,7 @@ use arena::TypedArena;\n #[deriving(Copy, PartialEq, Show)]\n pub enum PpSourceMode {\n     PpmNormal,\n+    PpmEveryBodyLoops,\n     PpmExpanded,\n     PpmTyped,\n     PpmIdentified,\n@@ -55,23 +59,33 @@ pub enum PpMode {\n     PpmFlowGraph,\n }\n \n-pub fn parse_pretty(sess: &Session, name: &str) -> (PpMode, Option<UserIdentifiedItem>) {\n+pub fn parse_pretty(sess: &Session,\n+                    name: &str,\n+                    extended: bool) -> (PpMode, Option<UserIdentifiedItem>) {\n     let mut split = name.splitn(1, '=');\n     let first = split.next().unwrap();\n     let opt_second = split.next();\n-    let first = match first {\n-        \"normal\"       => PpmSource(PpmNormal),\n-        \"expanded\"     => PpmSource(PpmExpanded),\n-        \"typed\"        => PpmSource(PpmTyped),\n-        \"expanded,identified\" => PpmSource(PpmExpandedIdentified),\n-        \"expanded,hygiene\" => PpmSource(PpmExpandedHygiene),\n-        \"identified\"   => PpmSource(PpmIdentified),\n-        \"flowgraph\"    => PpmFlowGraph,\n+    let first = match (first, extended) {\n+        (\"normal\", _)       => PpmSource(PpmNormal),\n+        (\"everybody_loops\", true) => PpmSource(PpmEveryBodyLoops),\n+        (\"expanded\", _)     => PpmSource(PpmExpanded),\n+        (\"typed\", _)        => PpmSource(PpmTyped),\n+        (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n+        (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n+        (\"identified\", _)   => PpmSource(PpmIdentified),\n+        (\"flowgraph\", true)    => PpmFlowGraph,\n         _ => {\n-            sess.fatal(format!(\n-                \"argument to `pretty` must be one of `normal`, \\\n-                 `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \\\n-                 or `expanded,identified`; got {}\", name)[]);\n+            if extended {\n+                sess.fatal(format!(\n+                    \"argument to `xpretty` must be one of `normal`, \\\n+                     `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \\\n+                     `expanded,identified`, or `everybody_loops`; got {}\", name).as_slice());\n+            } else {\n+                sess.fatal(format!(\n+                    \"argument to `pretty` must be one of `normal`, \\\n+                     `expanded`, `typed`, `identified`, \\\n+                     or `expanded,identified`; got {}\", name).as_slice());\n+            }\n         }\n     };\n     let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>());\n@@ -105,7 +119,7 @@ impl PpSourceMode {\n         F: FnOnce(&PrinterSupport, B) -> A,\n     {\n         match *self {\n-            PpmNormal | PpmExpanded => {\n+            PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n                 let annotation = NoAnn { sess: sess, ast_map: ast_map };\n                 f(&annotation, payload)\n             }\n@@ -384,6 +398,7 @@ impl UserIdentifiedItem {\n fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n     match *ppm {\n         PpmSource(PpmNormal) |\n+        PpmSource(PpmEveryBodyLoops) |\n         PpmSource(PpmIdentified) => opt_uii.is_some(),\n \n         PpmSource(PpmExpanded) |\n@@ -397,6 +412,7 @@ fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n fn needs_expansion(ppm: &PpMode) -> bool {\n     match *ppm {\n         PpmSource(PpmNormal) |\n+        PpmSource(PpmEveryBodyLoops) |\n         PpmSource(PpmIdentified) => false,\n \n         PpmSource(PpmExpanded) |\n@@ -407,14 +423,80 @@ fn needs_expansion(ppm: &PpMode) -> bool {\n     }\n }\n \n+struct ReplaceBodyWithLoop {\n+    within_static_or_const: bool,\n+}\n+\n+impl ReplaceBodyWithLoop {\n+    fn new() -> ReplaceBodyWithLoop {\n+        ReplaceBodyWithLoop { within_static_or_const: false }\n+    }\n+}\n+\n+impl fold::Folder for ReplaceBodyWithLoop {\n+    fn fold_item_underscore(&mut self, i: ast::Item_) -> ast::Item_ {\n+        match i {\n+            ast::ItemStatic(..) | ast::ItemConst(..) => {\n+                self.within_static_or_const = true;\n+                let ret = fold::noop_fold_item_underscore(i, self);\n+                self.within_static_or_const = false;\n+                return ret;\n+            }\n+            _ => {\n+                fold::noop_fold_item_underscore(i, self)\n+            }\n+        }\n+    }\n+\n+\n+    fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n+        fn expr_to_block(rules: ast::BlockCheckMode,\n+                         e: Option<P<ast::Expr>>) -> P<ast::Block> {\n+            P(ast::Block {\n+                expr: e,\n+                view_items: vec![], stmts: vec![], rules: rules,\n+                id: ast::DUMMY_NODE_ID, span: codemap::DUMMY_SP,\n+            })\n+        }\n+\n+        if !self.within_static_or_const {\n+\n+            let empty_block = expr_to_block(ast::DefaultBlock, None);\n+            let loop_expr = P(ast::Expr {\n+                node: ast::ExprLoop(empty_block, None),\n+                id: ast::DUMMY_NODE_ID, span: codemap::DUMMY_SP\n+            });\n+\n+            expr_to_block(b.rules, Some(loop_expr))\n+\n+        } else {\n+            fold::noop_fold_block(b, self)\n+        }\n+    }\n+\n+    // in general the pretty printer processes unexpanded code, so\n+    // we override the default `fold_mac` method which panics.\n+    fn fold_mac(&mut self, _macro: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(_macro, self)\n+    }\n+}\n+\n pub fn pretty_print_input(sess: Session,\n                           cfg: ast::CrateConfig,\n                           input: &Input,\n                           ppm: PpMode,\n                           opt_uii: Option<UserIdentifiedItem>,\n                           ofile: Option<Path>) {\n     let krate = driver::phase_1_parse_input(&sess, cfg, input);\n-    let id = link::find_crate_name(Some(&sess), krate.attrs[], input);\n+\n+    let krate = if let PpmSource(PpmEveryBodyLoops) = ppm {\n+        let mut fold = ReplaceBodyWithLoop::new();\n+        fold.fold_crate(krate)\n+    } else {\n+        krate\n+    };\n+\n+    let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);\n \n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);"}, {"sha": "0562e000e56e94beaf95079f8f6b5a35fc0dec70", "filename": "src/test/run-make/graphviz-flowgraph/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a07db438be8ce8ce969b1244e8796d65a964d31/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0a07db438be8ce8ce969b1244e8796d65a964d31/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile?ref=0a07db438be8ce8ce969b1244e8796d65a964d31", "patch": "@@ -28,7 +28,7 @@ $(TMPDIR)/%.pp: %.rs\n \n $(TMPDIR)/%.dot: %.rs\n \t$(eval $(call FIND_LAST_BLOCK,$<))\n-\t$(RUSTC_LIB) --pretty flowgraph=$(LASTBLOCKNUM_$<) $< -o $@.tmp\n+\t$(RUSTC_LIB) -Z unstable-options --xpretty flowgraph=$(LASTBLOCKNUM_$<) $< -o $@.tmp\n \tcat $@.tmp | sed -e 's@ (id=[0-9]*)@@g' \\\n                          -e 's@\\[label=\"\"\\]@@' \\\n                          -e 's@digraph [a-zA-Z0-9_]* @digraph block @' \\"}]}