{"sha": "dc4e4c7daab74612cf730028790a8ccd564a0168", "node_id": "C_kwDOAAsO6NoAKGRjNGU0YzdkYWFiNzQ2MTJjZjczMDAyODc5MGE4Y2NkNTY0YTAxNjg", "commit": {"author": {"name": "C\u00f4me ALLART", "email": "come.allart@etu.emse.fr", "date": "2021-12-07T22:34:53Z"}, "committer": {"name": "C\u00f4me ALLART", "email": "come.allart@etu.emse.fr", "date": "2021-12-07T22:34:53Z"}, "message": "fix: add mod files in path in generated examples", "tree": {"sha": "a616a7f57b9d51144fcf1e7ae33528a31d36cadb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a616a7f57b9d51144fcf1e7ae33528a31d36cadb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc4e4c7daab74612cf730028790a8ccd564a0168", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4e4c7daab74612cf730028790a8ccd564a0168", "html_url": "https://github.com/rust-lang/rust/commit/dc4e4c7daab74612cf730028790a8ccd564a0168", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc4e4c7daab74612cf730028790a8ccd564a0168/comments", "author": null, "committer": null, "parents": [{"sha": "220137f1cfd8ec1bf1f4d4e755a6ce4ea1421032", "url": "https://api.github.com/repos/rust-lang/rust/commits/220137f1cfd8ec1bf1f4d4e755a6ce4ea1421032", "html_url": "https://github.com/rust-lang/rust/commit/220137f1cfd8ec1bf1f4d4e755a6ce4ea1421032"}], "stats": {"total": 54, "additions": 27, "deletions": 27}, "files": [{"sha": "f7b68e398a132efcb32dca5de7792c5f0c6cb9d8", "filename": "crates/ide_assists/src/handlers/generate_documentation_template.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/dc4e4c7daab74612cf730028790a8ccd564a0168/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4e4c7daab74612cf730028790a8ccd564a0168/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs?ref=dc4e4c7daab74612cf730028790a8ccd564a0168", "patch": "@@ -1,3 +1,4 @@\n+use hir::ModuleDef;\n use ide_db::assists::{AssistId, AssistKind};\n use stdx::to_lower_snake_case;\n use syntax::{\n@@ -51,8 +52,6 @@ pub(crate) fn generate_documentation_template(\n     let parent_syntax = ast_func.syntax();\n     let text_range = parent_syntax.text_range();\n     let indent_level = IndentLevel::from_node(&parent_syntax);\n-    let krate_name =\n-        ctx.sema.scope(&parent_syntax).module()?.krate().display_name(ctx.db())?.to_string();\n \n     acc.add(\n         AssistId(\"generate_documentation_template\", AssistKind::Generate),\n@@ -63,7 +62,7 @@ pub(crate) fn generate_documentation_template(\n             // Introduction / short function description before the sections\n             doc_lines.push(introduction_builder(&ast_func));\n             // Then come the sections\n-            if let Some(mut lines) = examples_builder(&ast_func, krate_name) {\n+            if let Some(mut lines) = examples_builder(&ast_func, ctx) {\n                 doc_lines.push(\"\".into());\n                 doc_lines.append(&mut lines);\n             }\n@@ -94,16 +93,16 @@ fn introduction_builder(ast_func: &ast::Fn) -> String {\n }\n \n /// Builds an `# Examples` section. An option is returned to be able to manage an error in the AST.\n-fn examples_builder(ast_func: &ast::Fn, krate_name: String) -> Option<Vec<String>> {\n+fn examples_builder(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<Vec<String>> {\n     let (no_panic_ex, panic_ex) = if is_in_trait_def(ast_func) {\n         let message = \"// Example template not implemented for trait functions\";\n         (Some(vec![message.into()]), Some(vec![message.into()]))\n     } else {\n         let panic_ex = match can_panic(ast_func) {\n-            Some(true) => gen_panic_ex_template(ast_func, krate_name.clone()),\n+            Some(true) => gen_panic_ex_template(ast_func, ctx),\n             _ => None,\n         };\n-        let no_panic_ex = gen_ex_template(ast_func, krate_name);\n+        let no_panic_ex = gen_ex_template(ast_func, ctx);\n         (no_panic_ex, panic_ex)\n     };\n \n@@ -146,8 +145,8 @@ fn safety_builder(ast_func: &ast::Fn) -> Option<Vec<String>> {\n \n /// Generate an example template which should not panic\n /// `None` if the function has a `self` parameter but is not in an `impl`.\n-fn gen_ex_template(ast_func: &ast::Fn, krate_name: String) -> Option<Vec<String>> {\n-    let (mut lines, ex_helper) = gen_ex_start_helper(ast_func, krate_name)?;\n+fn gen_ex_template(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<Vec<String>> {\n+    let (mut lines, ex_helper) = gen_ex_start_helper(ast_func, ctx)?;\n     // Call the function, check result\n     if returns_a_value(ast_func) {\n         if count_parameters(&ex_helper.param_list) < 3 {\n@@ -171,8 +170,8 @@ fn gen_ex_template(ast_func: &ast::Fn, krate_name: String) -> Option<Vec<String>\n \n /// Generate an example template which should panic\n /// `None` if the function has a `self` parameter but is not in an `impl`.\n-fn gen_panic_ex_template(ast_func: &ast::Fn, krate_name: String) -> Option<Vec<String>> {\n-    let (mut lines, ex_helper) = gen_ex_start_helper(ast_func, krate_name)?;\n+fn gen_panic_ex_template(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<Vec<String>> {\n+    let (mut lines, ex_helper) = gen_ex_start_helper(ast_func, ctx)?;\n     match returns_a_value(ast_func) {\n         true => lines.push(format!(\"let _ = {}; // panics\", ex_helper.function_call)),\n         false => lines.push(format!(\"{}; // panics\", ex_helper.function_call)),\n@@ -190,14 +189,14 @@ struct ExHelper {\n \n /// Build the start of the example and transmit the useful intermediary results.\n /// `None` if the function has a `self` parameter but is not in an `impl`.\n-fn gen_ex_start_helper(ast_func: &ast::Fn, krate_name: String) -> Option<(Vec<String>, ExHelper)> {\n+fn gen_ex_start_helper(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<(Vec<String>, ExHelper)> {\n     let mut lines = Vec::new();\n     let is_unsafe = ast_func.unsafe_token().is_some();\n     let param_list = ast_func.param_list()?;\n     let ref_mut_params = ref_mut_params(&param_list);\n     let self_name: Option<String> = self_name(ast_func);\n \n-    lines.push(format!(\"use {};\", build_path(ast_func, krate_name)));\n+    lines.push(format!(\"use {};\", build_path(ast_func, ctx)?));\n     lines.push(\"\".into());\n     if let Some(self_definition) = self_definition(ast_func, self_name.as_deref()) {\n         lines.push(self_definition);\n@@ -220,6 +219,12 @@ fn is_public(ast_func: &ast::Fn) -> bool {\n             .all(|module| has_pub(&module))\n }\n \n+/// Get the name of the current crate\n+fn crate_name(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String> {\n+    let krate = ctx.sema.scope(&ast_func.syntax()).module()?.krate();\n+    Some(krate.display_name(ctx.db())?.to_string())\n+}\n+\n /// Check if visibility is exactly `pub` (not `pub(crate)` for instance)\n fn has_pub<T: HasVisibility>(item: &T) -> bool {\n     item.visibility().map(|v| v.path().is_none()).unwrap_or(false)\n@@ -377,21 +382,16 @@ fn string_vec_from(string_array: &[&str]) -> Vec<String> {\n }\n \n /// Helper function to build the path of the module in the which is the node\n-fn build_path(ast_func: &ast::Fn, krate_name: String) -> String {\n-    let mut path: Vec<String> = ast_func\n-        .syntax()\n-        .ancestors()\n-        .filter_map(|m| ast::Module::cast(m).and_then(|m| m.name()))\n-        .map(|m| m.to_string())\n-        .collect();\n-    path.push(krate_name);\n-    path.reverse();\n-    path.push(\n-        self_partial_type(ast_func)\n-            .or_else(|| ast_func.name().map(|n| n.to_string()))\n-            .unwrap_or_else(|| \"*\".into()),\n-    );\n-    intersperse_string(path.into_iter(), \"::\")\n+fn build_path(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String> {\n+    let crate_name = crate_name(ast_func, ctx)?;\n+    let leaf = self_partial_type(ast_func)\n+        .or_else(|| ast_func.name().map(|n| n.to_string()))\n+        .unwrap_or_else(|| \"*\".into());\n+    let func_module_def: ModuleDef = ctx.sema.to_def(ast_func)?.module(ctx.db()).into();\n+    match func_module_def.canonical_path(ctx.db()) {\n+        Some(path) => Some(format!(\"{}::{}::{}\", crate_name, path, leaf)),\n+        None => Some(format!(\"{}::{}\", crate_name, leaf)),\n+    }\n }\n \n /// Helper function to get the return type of a function"}]}