{"sha": "91153d5009d110e70768e3665212a880658a79ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMTUzZDUwMDlkMTEwZTcwNzY4ZTM2NjUyMTJhODgwNjU4YTc5ZWM=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-11-06T16:02:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-06T16:02:05Z"}, "message": "Rollup merge of #78167 - Nadrieril:fix-76836_, r=varkor\n\nFix unreachable sub-branch detection in or-patterns\n\nThe previous implementation was too eager to avoid unnecessary \"unreachable pattern\" warnings. I feel more confident about this implementation than I felt about the previous one.\nFixes https://github.com/rust-lang/rust/issues/76836.\n\n``@rustbot`` modify labels: +A-exhaustiveness-checking", "tree": {"sha": "3b633420ae15ce258b9db4e2ba5a80def0ea5070", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b633420ae15ce258b9db4e2ba5a80def0ea5070"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91153d5009d110e70768e3665212a880658a79ec", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfpXN9CRBK7hj4Ov3rIwAAdHIIAK3xHty0Nz24AcnJ5giqDKsV\nM0VrmqJ9SQ7OZ+7FLiqWrp2ddKulw2Y1rZR/GlBbERpIg/eDJt+54tc8/P5Rnsub\nuZOSslc13tHglc63dJUKbrnwn7UvRghbITNc48Tm3owJym65jK9w27t3Lld7qyOS\nh5Sv7e1Ro7/7U8deMEE1EOuhi/pz3caoKRtgLSRUHUvhoUioAai94FOMvBtqnfpv\nRbbFzDLm8PTC+4VgNWWOaSK46e9///KE/yOJzgvz/7nNw9vjjj9MPKVLnxr7KUvw\n8e/yD6LtqiQA8eScEQRZu1PK+7671bwoCRMatEHVcPUjDGzS38ptssLesJtHg7A=\n=aIzz\n-----END PGP SIGNATURE-----\n", "payload": "tree 3b633420ae15ce258b9db4e2ba5a80def0ea5070\nparent 0e71fc75ccfe577033345dcc478e98503d71831f\nparent 107a29a90146ac418c71f306691cd4857ce15c03\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1604678525 +0900\ncommitter GitHub <noreply@github.com> 1604678525 +0900\n\nRollup merge of #78167 - Nadrieril:fix-76836_, r=varkor\n\nFix unreachable sub-branch detection in or-patterns\n\nThe previous implementation was too eager to avoid unnecessary \"unreachable pattern\" warnings. I feel more confident about this implementation than I felt about the previous one.\nFixes https://github.com/rust-lang/rust/issues/76836.\n\n``@rustbot`` modify labels: +A-exhaustiveness-checking\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91153d5009d110e70768e3665212a880658a79ec", "html_url": "https://github.com/rust-lang/rust/commit/91153d5009d110e70768e3665212a880658a79ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91153d5009d110e70768e3665212a880658a79ec/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e71fc75ccfe577033345dcc478e98503d71831f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e71fc75ccfe577033345dcc478e98503d71831f", "html_url": "https://github.com/rust-lang/rust/commit/0e71fc75ccfe577033345dcc478e98503d71831f"}, {"sha": "107a29a90146ac418c71f306691cd4857ce15c03", "url": "https://api.github.com/repos/rust-lang/rust/commits/107a29a90146ac418c71f306691cd4857ce15c03", "html_url": "https://github.com/rust-lang/rust/commit/107a29a90146ac418c71f306691cd4857ce15c03"}], "stats": {"total": 150, "additions": 111, "deletions": 39}, "files": [{"sha": "5e7e81eba6273cb6ab2b8f20a37a2a54ffc3ec0e", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 88, "deletions": 32, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/91153d5009d110e70768e3665212a880658a79ec/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91153d5009d110e70768e3665212a880658a79ec/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=91153d5009d110e70768e3665212a880658a79ec", "patch": "@@ -1,5 +1,11 @@\n-//! Note: most of the tests relevant to this file can be found (at the time of writing) in\n-//! src/tests/ui/pattern/usefulness.\n+//! Note: tests specific to this file can be found in:\n+//!     - ui/pattern/usefulness\n+//!     - ui/or-patterns\n+//!     - ui/consts/const_in_pattern\n+//!     - ui/rfc-2008-non-exhaustive\n+//!     - probably many others\n+//! I (Nadrieril) prefer to put new tests in `ui/pattern/usefulness` unless there's a specific\n+//! reason not to, for example if they depend on a particular feature like or_patterns.\n //!\n //! This file includes the logic for exhaustiveness and usefulness checking for\n //! pattern-matching. Specifically, given a list of patterns for a type, we can\n@@ -1361,8 +1367,9 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n \n #[derive(Clone, Debug)]\n crate enum Usefulness<'tcx> {\n-    /// Carries a list of unreachable subpatterns. Used only in the presence of or-patterns.\n-    Useful(Vec<Span>),\n+    /// Carries, for each column in the matrix, a set of sub-branches that have been found to be\n+    /// unreachable. Used only in the presence of or-patterns, otherwise it stays empty.\n+    Useful(Vec<FxHashSet<Span>>),\n     /// Carries a list of witnesses of non-exhaustiveness.\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n     NotUseful,\n@@ -1410,6 +1417,23 @@ impl<'tcx> Usefulness<'tcx> {\n                 };\n                 UsefulWithWitness(new_witnesses)\n             }\n+            Useful(mut unreachables) => {\n+                if !unreachables.is_empty() {\n+                    // When we apply a constructor, there are `arity` columns of the matrix that\n+                    // corresponded to its arguments. All the unreachables found in these columns\n+                    // will, after `apply`, come from the first column. So we take the union of all\n+                    // the corresponding sets and put them in the first column.\n+                    // Note that `arity` may be 0, in which case we just push a new empty set.\n+                    let len = unreachables.len();\n+                    let arity = ctor_wild_subpatterns.len();\n+                    let mut unioned = FxHashSet::default();\n+                    for set in unreachables.drain((len - arity)..) {\n+                        unioned.extend(set)\n+                    }\n+                    unreachables.push(unioned);\n+                }\n+                Useful(unreachables)\n+            }\n             x => x,\n         }\n     }\n@@ -2091,55 +2115,87 @@ crate fn is_useful<'p, 'tcx>(\n \n     // If the first pattern is an or-pattern, expand it.\n     if let Some(vs) = v.expand_or_pat() {\n-        // We need to push the already-seen patterns into the matrix in order to detect redundant\n-        // branches like `Some(_) | Some(0)`. We also keep track of the unreachable subpatterns.\n-        let mut matrix = matrix.clone();\n-        // `Vec` of all the unreachable branches of the current or-pattern.\n-        let mut unreachable_branches = Vec::new();\n-        // Subpatterns that are unreachable from all branches. E.g. in the following case, the last\n-        // `true` is unreachable only from one branch, so it is overall reachable.\n+        // We expand the or pattern, trying each of its branches in turn and keeping careful track\n+        // of possible unreachable sub-branches.\n+        //\n+        // If two branches have detected some unreachable sub-branches, we need to be careful. If\n+        // they were detected in columns that are not the current one, we want to keep only the\n+        // sub-branches that were unreachable in _all_ branches. Eg. in the following, the last\n+        // `true` is unreachable in the second branch of the first or-pattern, but not otherwise.\n+        // Therefore we don't want to lint that it is unreachable.\n         //\n         // ```\n         // match (true, true) {\n         //     (true, true) => {}\n         //     (false | true, false | true) => {}\n         // }\n         // ```\n-        let mut unreachable_subpats = FxHashSet::default();\n-        // Whether any branch at all is useful.\n+        // If however the sub-branches come from the current column, they come from the inside of\n+        // the current or-pattern, and we want to keep them all. Eg. in the following, we _do_ want\n+        // to lint that the last `false` is unreachable.\n+        // ```\n+        // match None {\n+        //     Some(false) => {}\n+        //     None | Some(true | false) => {}\n+        // }\n+        // ```\n+\n+        let mut matrix = matrix.clone();\n+        // We keep track of sub-branches separately depending on whether they come from this column\n+        // or from others.\n+        let mut unreachables_this_column: FxHashSet<Span> = FxHashSet::default();\n+        let mut unreachables_other_columns: Vec<FxHashSet<Span>> = Vec::default();\n+        // Whether at least one branch is reachable.\n         let mut any_is_useful = false;\n \n         for v in vs {\n             let res = is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             match res {\n-                Useful(pats) => {\n-                    if !any_is_useful {\n-                        any_is_useful = true;\n-                        // Initialize with the first set of unreachable subpatterns encountered.\n-                        unreachable_subpats = pats.into_iter().collect();\n-                    } else {\n-                        // Keep the patterns unreachable from both this and previous branches.\n-                        unreachable_subpats =\n-                            pats.into_iter().filter(|p| unreachable_subpats.contains(p)).collect();\n+                Useful(unreachables) => {\n+                    if let Some((this_column, other_columns)) = unreachables.split_last() {\n+                        // We keep the union of unreachables found in the first column.\n+                        unreachables_this_column.extend(this_column);\n+                        // We keep the intersection of unreachables found in other columns.\n+                        if unreachables_other_columns.is_empty() {\n+                            unreachables_other_columns = other_columns.to_vec();\n+                        } else {\n+                            unreachables_other_columns = unreachables_other_columns\n+                                .into_iter()\n+                                .zip(other_columns)\n+                                .map(|(x, y)| x.intersection(&y).copied().collect())\n+                                .collect();\n+                        }\n                     }\n+                    any_is_useful = true;\n                 }\n-                NotUseful => unreachable_branches.push(v.head().span),\n-                UsefulWithWitness(_) => {\n-                    bug!(\"Encountered or-pat in `v` during exhaustiveness checking\")\n+                NotUseful => {\n+                    unreachables_this_column.insert(v.head().span);\n                 }\n+                UsefulWithWitness(_) => bug!(\n+                    \"encountered or-pat in the expansion of `_` during exhaustiveness checking\"\n+                ),\n             }\n-            // If pattern has a guard don't add it to the matrix\n+\n+            // If pattern has a guard don't add it to the matrix.\n             if !is_under_guard {\n+                // We push the already-seen patterns into the matrix in order to detect redundant\n+                // branches like `Some(_) | Some(0)`.\n                 matrix.push(v);\n             }\n         }\n-        if any_is_useful {\n-            // Collect all the unreachable patterns.\n-            unreachable_branches.extend(unreachable_subpats);\n-            return Useful(unreachable_branches);\n+\n+        return if any_is_useful {\n+            let mut unreachables = if unreachables_other_columns.is_empty() {\n+                let n_columns = v.len();\n+                (0..n_columns - 1).map(|_| FxHashSet::default()).collect()\n+            } else {\n+                unreachables_other_columns\n+            };\n+            unreachables.push(unreachables_this_column);\n+            Useful(unreachables)\n         } else {\n-            return NotUseful;\n-        }\n+            NotUseful\n+        };\n     }\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476)."}, {"sha": "205ad850c0c8011deb28c913dbf4d8c4281bdd3b", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91153d5009d110e70768e3665212a880658a79ec/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91153d5009d110e70768e3665212a880658a79ec/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=91153d5009d110e70768e3665212a880658a79ec", "patch": "@@ -389,8 +389,11 @@ fn check_arms<'p, 'tcx>(\n                     hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n                 }\n             }\n-            Useful(unreachable_subpatterns) => {\n-                for span in unreachable_subpatterns {\n+            Useful(unreachables) => {\n+                let mut unreachables: Vec<_> = unreachables.into_iter().flatten().collect();\n+                // Emit lints in the order in which they occur in the file.\n+                unreachables.sort_unstable();\n+                for span in unreachables {\n                     unreachable_pattern(cx.tcx, span, id, None);\n                 }\n             }"}, {"sha": "512f1e283cb462a0cff4ace899421714bd4c4d4d", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/91153d5009d110e70768e3665212a880658a79ec/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91153d5009d110e70768e3665212a880658a79ec/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs?ref=91153d5009d110e70768e3665212a880658a79ec", "patch": "@@ -77,10 +77,17 @@ fn main() {\n         (false | true, false | true) => {}\n     }\n     match (true, true) {\n-        (true, false) => {}\n-        (false, true) => {}\n+        (true, true) => {}\n+        (false, false) => {}\n         (false | true, false | true) => {}\n     }\n+    // https://github.com/rust-lang/rust/issues/76836\n+    match None {\n+        Some(false) => {}\n+        None | Some(true\n+                | false) => {} //~ ERROR unreachable\n+    }\n+\n     // A subpattern that is unreachable in all branches is overall unreachable.\n     match (true, true) {\n         (false, true) => {}"}, {"sha": "e968310d108dda3c8f817fbde18b53a310b40497", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91153d5009d110e70768e3665212a880658a79ec/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91153d5009d110e70768e3665212a880658a79ec/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr?ref=91153d5009d110e70768e3665212a880658a79ec", "patch": "@@ -101,16 +101,22 @@ LL |         Some(0\n    |              ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:89:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:88:19\n+   |\n+LL |                 | false) => {}\n+   |                   ^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:96:15\n    |\n LL |             | true) => {}\n    |               ^^^^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:95:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:102:15\n    |\n LL |             | true,\n    |               ^^^^\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 19 previous errors\n "}]}