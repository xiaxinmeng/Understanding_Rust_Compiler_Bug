{"sha": "66d60c78b3c31629b13202f3d2281b2674c7ec3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZDYwYzc4YjNjMzE2MjliMTMyMDJmM2QyMjgxYjI2NzRjN2VjM2U=", "commit": {"author": {"name": "Scott A Carr", "email": "s.carr1024@gmail.com", "date": "2016-06-09T22:49:07Z"}, "committer": {"name": "Scott A Carr", "email": "s.carr1024@gmail.com", "date": "2016-06-23T21:00:00Z"}, "message": "add control flow graph and algorithms. add dominator to mir", "tree": {"sha": "5b44deee85804c538b86ffb19418ec87e052243b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b44deee85804c538b86ffb19418ec87e052243b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66d60c78b3c31629b13202f3d2281b2674c7ec3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66d60c78b3c31629b13202f3d2281b2674c7ec3e", "html_url": "https://github.com/rust-lang/rust/commit/66d60c78b3c31629b13202f3d2281b2674c7ec3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66d60c78b3c31629b13202f3d2281b2674c7ec3e/comments", "author": {"login": "scottcarr", "id": 472477, "node_id": "MDQ6VXNlcjQ3MjQ3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/472477?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottcarr", "html_url": "https://github.com/scottcarr", "followers_url": "https://api.github.com/users/scottcarr/followers", "following_url": "https://api.github.com/users/scottcarr/following{/other_user}", "gists_url": "https://api.github.com/users/scottcarr/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottcarr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottcarr/subscriptions", "organizations_url": "https://api.github.com/users/scottcarr/orgs", "repos_url": "https://api.github.com/users/scottcarr/repos", "events_url": "https://api.github.com/users/scottcarr/events{/privacy}", "received_events_url": "https://api.github.com/users/scottcarr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottcarr", "id": 472477, "node_id": "MDQ6VXNlcjQ3MjQ3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/472477?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottcarr", "html_url": "https://github.com/scottcarr", "followers_url": "https://api.github.com/users/scottcarr/followers", "following_url": "https://api.github.com/users/scottcarr/following{/other_user}", "gists_url": "https://api.github.com/users/scottcarr/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottcarr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottcarr/subscriptions", "organizations_url": "https://api.github.com/users/scottcarr/orgs", "repos_url": "https://api.github.com/users/scottcarr/repos", "events_url": "https://api.github.com/users/scottcarr/events{/privacy}", "received_events_url": "https://api.github.com/users/scottcarr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe96928d7de991e527a7ed7b88bb30aa965c8a08", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe96928d7de991e527a7ed7b88bb30aa965c8a08", "html_url": "https://github.com/rust-lang/rust/commit/fe96928d7de991e527a7ed7b88bb30aa965c8a08"}], "stats": {"total": 874, "additions": 871, "deletions": 3}, "files": [{"sha": "1be7d00f072cd884b263ab2ae9208a3f2cce93a3", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -15,7 +15,7 @@ use mir::repr::{Mir, BasicBlock};\n \n use rustc_serialize as serialize;\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct Cache {\n     predecessors: RefCell<Option<IndexVec<BasicBlock, Vec<BasicBlock>>>>\n }"}, {"sha": "d39ff28841851d8a2539bb419a4e3e7eccf1730b", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -12,6 +12,9 @@ use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n+use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccessors};\n+use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n@@ -24,6 +27,7 @@ use std::cell::Ref;\n use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, u32};\n use std::ops::{Index, IndexMut};\n+use std::vec::IntoIter;\n use syntax::ast::{self, Name};\n use syntax::codemap::Span;\n \n@@ -54,7 +58,7 @@ macro_rules! newtype_index {\n }\n \n /// Lowered representation of a single function.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Mir<'tcx> {\n     /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n@@ -145,6 +149,11 @@ impl<'tcx> Mir<'tcx> {\n         Ref::map(self.predecessors(), |p| &p[bb])\n     }\n \n+    #[inline]\n+    pub fn dominators(&self) -> Dominators<BasicBlock> {\n+        dominators(self)\n+    }\n+\n     /// Maps locals (Arg's, Var's, Temp's and ReturnPointer, in that order)\n     /// to their index in the whole list of locals. This is useful if you\n     /// want to treat all locals the same instead of repeating yourself.\n@@ -1190,3 +1199,33 @@ fn node_to_string(node_id: ast::NodeId) -> String {\n fn item_path_str(def_id: DefId) -> String {\n     ty::tls::with(|tcx| tcx.item_path_str(def_id))\n }\n+\n+impl<'tcx> ControlFlowGraph for Mir<'tcx> {\n+\n+    type Node = BasicBlock;\n+\n+    fn num_nodes(&self) -> usize { self.basic_blocks.len() }\n+\n+    fn start_node(&self) -> Self::Node { START_BLOCK }\n+\n+    fn predecessors<'graph>(&'graph self, node: Self::Node)\n+                            -> <Self as GraphPredecessors<'graph>>::Iter\n+    {\n+        self.predecessors_for(node).clone().into_iter()\n+    }\n+    fn successors<'graph>(&'graph self, node: Self::Node)\n+                          -> <Self as GraphSuccessors<'graph>>::Iter\n+    {\n+        self.basic_blocks[node].terminator().successors().into_owned().into_iter()\n+    }\n+}\n+\n+impl<'a, 'b> GraphPredecessors<'b> for Mir<'a> {\n+    type Item = BasicBlock;\n+    type Iter = IntoIter<BasicBlock>;\n+}\n+\n+impl<'a, 'b>  GraphSuccessors<'b> for Mir<'a> {\n+    type Item = BasicBlock;\n+    type Iter = IntoIter<BasicBlock>;\n+}"}, {"sha": "250b89d12ed0510eb8774b2700eb62ef53fad833", "filename": "src/librustc_data_structures/control_flow_graph/dominators/mod.rs", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -0,0 +1,284 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Algorithm citation:\n+//! A Simple, Fast Dominance Algorithm.\n+//! Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy\n+//! Rice Computer Science TS-06-33870\n+//! https://www.cs.rice.edu/~keith/EMBED/dom.pdf\n+\n+use super::ControlFlowGraph;\n+use super::iterate::reverse_post_order;\n+use super::super::indexed_vec::{IndexVec, Idx};\n+\n+use std::fmt;\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub fn dominators<G: ControlFlowGraph>(graph: &G) -> Dominators<G::Node> {\n+    let start_node = graph.start_node();\n+    let rpo = reverse_post_order(graph, start_node);\n+    dominators_given_rpo(graph, &rpo)\n+}\n+\n+pub fn dominators_given_rpo<G: ControlFlowGraph>(graph: &G,\n+                                                 rpo: &[G::Node])\n+                                                 -> Dominators<G::Node> {\n+    let start_node = graph.start_node();\n+    assert_eq!(rpo[0], start_node);\n+\n+    // compute the post order index (rank) for each node\n+    let mut post_order_rank: IndexVec<G::Node, usize> = IndexVec::from_elem_n(usize::default(),\n+                                                                              graph.num_nodes());\n+    for (index, node) in rpo.iter().rev().cloned().enumerate() {\n+        post_order_rank[node] = index;\n+    }\n+\n+    let mut immediate_dominators: IndexVec<G::Node, Option<G::Node>> =\n+        IndexVec::from_elem_n(Option::default(), graph.num_nodes());\n+    immediate_dominators[start_node] = Some(start_node);\n+\n+    let mut changed = true;\n+    while changed {\n+        changed = false;\n+\n+        for &node in &rpo[1..] {\n+            let mut new_idom = None;\n+            for pred in graph.predecessors(node) {\n+                if immediate_dominators[pred].is_some() {\n+                    // (*)\n+                    // (*) dominators for `pred` have been calculated\n+                    new_idom = intersect_opt(&post_order_rank,\n+                                                  &immediate_dominators,\n+                                                  new_idom,\n+                                                  Some(pred));\n+                }\n+            }\n+\n+            if new_idom != immediate_dominators[node] {\n+                immediate_dominators[node] = new_idom;\n+                changed = true;\n+            }\n+        }\n+    }\n+\n+    Dominators {\n+        post_order_rank: post_order_rank,\n+        immediate_dominators: immediate_dominators,\n+    }\n+}\n+\n+fn intersect_opt<Node: Idx>(post_order_rank: &IndexVec<Node, usize>,\n+                                      immediate_dominators: &IndexVec<Node, Option<Node>>,\n+                                      node1: Option<Node>,\n+                                      node2: Option<Node>)\n+                                      -> Option<Node> {\n+    match (node1, node2) {\n+        (None, None) => None,\n+        (Some(n), None) | (None, Some(n)) => Some(n),\n+        (Some(n1), Some(n2)) => Some(intersect(post_order_rank, immediate_dominators, n1, n2)),\n+    }\n+}\n+\n+fn intersect<Node: Idx>(post_order_rank: &IndexVec<Node, usize>,\n+                                  immediate_dominators: &IndexVec<Node, Option<Node>>,\n+                                  mut node1: Node,\n+                                  mut node2: Node)\n+                                  -> Node {\n+    while node1 != node2 {\n+        while post_order_rank[node1] < post_order_rank[node2] {\n+            node1 = immediate_dominators[node1].unwrap();\n+        }\n+\n+        while post_order_rank[node2] < post_order_rank[node1] {\n+            node2 = immediate_dominators[node2].unwrap();\n+        }\n+    }\n+    return node1;\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Dominators<N: Idx> {\n+    post_order_rank: IndexVec<N, usize>,\n+    immediate_dominators: IndexVec<N, Option<N>>,\n+}\n+\n+impl<Node: Idx> Dominators<Node> {\n+    pub fn is_reachable(&self, node: Node) -> bool {\n+        self.immediate_dominators[node].is_some()\n+    }\n+\n+    pub fn immediate_dominator(&self, node: Node) -> Node {\n+        assert!(self.is_reachable(node), \"node {:?} is not reachable\", node);\n+        self.immediate_dominators[node].unwrap()\n+    }\n+\n+    pub fn dominators(&self, node: Node) -> Iter<Node> {\n+        assert!(self.is_reachable(node), \"node {:?} is not reachable\", node);\n+        Iter {\n+            dominators: self,\n+            node: Some(node),\n+        }\n+    }\n+\n+    pub fn is_dominated_by(&self, node: Node, dom: Node) -> bool {\n+        // FIXME -- could be optimized by using post-order-rank\n+        self.dominators(node).any(|n| n == dom)\n+    }\n+\n+    pub fn mutual_dominator_node(&self, node1: Node, node2: Node) -> Node {\n+        assert!(self.is_reachable(node1),\n+                \"node {:?} is not reachable\",\n+                node1);\n+        assert!(self.is_reachable(node2),\n+                \"node {:?} is not reachable\",\n+                node2);\n+        intersect::<Node>(&self.post_order_rank,\n+                  &self.immediate_dominators,\n+                  node1,\n+                  node2)\n+    }\n+\n+    pub fn mutual_dominator<I>(&self, iter: I) -> Option<Node>\n+        where I: IntoIterator<Item = Node>\n+    {\n+        let mut iter = iter.into_iter();\n+        iter.next()\n+            .map(|dom| iter.fold(dom, |dom, node| self.mutual_dominator_node(dom, node)))\n+    }\n+\n+    pub fn all_immediate_dominators(&self) -> &IndexVec<Node, Option<Node>> {\n+        &self.immediate_dominators\n+    }\n+\n+    pub fn dominator_tree(&self) -> DominatorTree<Node> {\n+        let elem: Vec<Node> = Vec::new();\n+        let mut children: IndexVec<Node, Vec<Node>> =\n+            IndexVec::from_elem_n(elem, self.immediate_dominators.len());\n+        let mut root = None;\n+        for (index, immed_dom) in self.immediate_dominators.iter().enumerate() {\n+            let node = Node::new(index);\n+            match *immed_dom {\n+                None => {\n+                    // node not reachable\n+                }\n+                Some(immed_dom) => {\n+                    if node == immed_dom {\n+                        root = Some(node);\n+                    } else {\n+                        children[immed_dom].push(node);\n+                    }\n+                }\n+            }\n+        }\n+        DominatorTree {\n+            root: root.unwrap(),\n+            children: children,\n+        }\n+    }\n+}\n+\n+pub struct Iter<'dom, Node: Idx + 'dom> {\n+    dominators: &'dom Dominators<Node>,\n+    node: Option<Node>,\n+}\n+\n+impl<'dom, Node: Idx> Iterator for Iter<'dom, Node> {\n+    type Item = Node;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(node) = self.node {\n+            let dom = self.dominators.immediate_dominator(node);\n+            if dom == node {\n+                self.node = None; // reached the root\n+            } else {\n+                self.node = Some(dom);\n+            }\n+            return Some(node);\n+        } else {\n+            return None;\n+        }\n+    }\n+}\n+\n+pub struct DominatorTree<N: Idx> {\n+    root: N,\n+    children: IndexVec<N, Vec<N>>,\n+}\n+\n+impl<Node: Idx> DominatorTree<Node> {\n+    pub fn root(&self) -> Node {\n+        self.root\n+    }\n+\n+    pub fn children(&self, node: Node) -> &[Node] {\n+        &self.children[node]\n+    }\n+\n+    pub fn iter_children_of(&self, node: Node) -> IterChildrenOf<Node> {\n+        IterChildrenOf {\n+            tree: self,\n+            stack: vec![node],\n+        }\n+    }\n+}\n+\n+pub struct IterChildrenOf<'iter, Node: Idx + 'iter> {\n+    tree: &'iter DominatorTree<Node>,\n+    stack: Vec<Node>,\n+}\n+\n+impl<'iter, Node: Idx> Iterator for IterChildrenOf<'iter, Node> {\n+    type Item = Node;\n+\n+    fn next(&mut self) -> Option<Node> {\n+        if let Some(node) = self.stack.pop() {\n+            self.stack.extend(self.tree.children(node));\n+            Some(node)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<Node: Idx> fmt::Debug for DominatorTree<Node> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        fmt::Debug::fmt(&DominatorTreeNode {\n+                            tree: self,\n+                            node: self.root,\n+                        },\n+                        fmt)\n+    }\n+}\n+\n+struct DominatorTreeNode<'tree, Node: Idx> {\n+    tree: &'tree DominatorTree<Node>,\n+    node: Node,\n+}\n+\n+impl<'tree, Node: Idx> fmt::Debug for DominatorTreeNode<'tree, Node> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        let subtrees: Vec<_> = self.tree\n+            .children(self.node)\n+            .iter()\n+            .map(|&child| {\n+                DominatorTreeNode {\n+                    tree: self.tree,\n+                    node: child,\n+                }\n+            })\n+            .collect();\n+        fmt.debug_tuple(\"\")\n+            .field(&self.node)\n+            .field(&subtrees)\n+            .finish()\n+    }\n+}"}, {"sha": "a6db5f2fe3ea1bdfbc58bbcd2042afc730bf3759", "filename": "src/librustc_data_structures/control_flow_graph/dominators/test.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Ftest.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::super::test::TestGraph;\n+\n+use super::*;\n+\n+#[test]\n+fn diamond() {\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (0, 2),\n+        (1, 3),\n+        (2, 3),\n+    ]);\n+\n+    let dominators = dominators(&graph);\n+    let immediate_dominators = dominators.all_immediate_dominators();\n+    assert_eq!(immediate_dominators[0], Some(0));\n+    assert_eq!(immediate_dominators[1], Some(0));\n+    assert_eq!(immediate_dominators[2], Some(0));\n+    assert_eq!(immediate_dominators[3], Some(0));\n+}\n+\n+#[test]\n+fn paper() {\n+    // example from the paper:\n+    let graph = TestGraph::new(6, &[\n+        (6, 5),\n+        (6, 4),\n+        (5, 1),\n+        (4, 2),\n+        (4, 3),\n+        (1, 2),\n+        (2, 3),\n+        (3, 2),\n+        (2, 1),\n+    ]);\n+\n+    let dominators = dominators(&graph);\n+    let immediate_dominators = dominators.all_immediate_dominators();\n+    assert_eq!(immediate_dominators[0], None); // <-- note that 0 is not in graph\n+    assert_eq!(immediate_dominators[1], Some(6));\n+    assert_eq!(immediate_dominators[2], Some(6));\n+    assert_eq!(immediate_dominators[3], Some(6));\n+    assert_eq!(immediate_dominators[4], Some(6));\n+    assert_eq!(immediate_dominators[5], Some(6));\n+    assert_eq!(immediate_dominators[6], Some(6));\n+}\n+"}, {"sha": "11b557cbcadb926f8f91c69a4a47dced996aed8d", "filename": "src/librustc_data_structures/control_flow_graph/iterate/mod.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::ControlFlowGraph;\n+use super::super::indexed_vec::IndexVec;\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub fn post_order_from<G: ControlFlowGraph>(graph: &G, start_node: G::Node) -> Vec<G::Node> {\n+    post_order_from_to(graph, start_node, None)\n+}\n+\n+pub fn post_order_from_to<G: ControlFlowGraph>(graph: &G,\n+                                               start_node: G::Node,\n+                                               end_node: Option<G::Node>)\n+                                               -> Vec<G::Node> {\n+    let mut visited: IndexVec<G::Node, bool> = IndexVec::from_elem_n(false, graph.num_nodes());\n+    let mut result: Vec<G::Node> = Vec::with_capacity(graph.num_nodes());\n+    if let Some(end_node) = end_node {\n+        visited[end_node] = true;\n+    }\n+    post_order_walk(graph, start_node, &mut result, &mut visited);\n+    result\n+}\n+\n+fn post_order_walk<G: ControlFlowGraph>(graph: &G,\n+                                        node: G::Node,\n+                                        result: &mut Vec<G::Node>,\n+                                        visited: &mut IndexVec<G::Node, bool>) {\n+    if visited[node] {\n+        return;\n+    }\n+    visited[node] = true;\n+\n+    for successor in graph.successors(node) {\n+        post_order_walk(graph, successor, result, visited);\n+    }\n+\n+    result.push(node);\n+}\n+\n+pub fn pre_order_walk<G: ControlFlowGraph>(graph: &G,\n+                                           node: G::Node,\n+                                           result: &mut Vec<G::Node>,\n+                                           visited: &mut IndexVec<G::Node, bool>) {\n+    if visited[node] {\n+        return;\n+    }\n+    visited[node] = true;\n+\n+    result.push(node);\n+\n+    for successor in graph.successors(node) {\n+        pre_order_walk(graph, successor, result, visited);\n+    }\n+}\n+\n+pub fn reverse_post_order<G: ControlFlowGraph>(graph: &G, start_node: G::Node) -> Vec<G::Node> {\n+    let mut vec = post_order_from(graph, start_node);\n+    vec.reverse();\n+    vec\n+}"}, {"sha": "28297d55bdf32a3839f3d5a91f864e686e9e8158", "filename": "src/librustc_data_structures/control_flow_graph/iterate/test.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::super::test::TestGraph;\n+use super::super::transpose::TransposedGraph;\n+\n+use super::*;\n+\n+#[test]\n+fn diamond_post_order() {\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (0, 2),\n+        (1, 3),\n+        (2, 3),\n+    ]);\n+\n+    let result = post_order_from(&graph, 0);\n+    assert_eq!(result, vec![3, 1, 2, 0]);\n+}\n+\n+\n+#[test]\n+fn rev_post_order_inner_loop() {\n+    // 0 -> 1 ->     2     -> 3 -> 5\n+    //      ^     ^    v      |\n+    //      |     6 <- 4      |\n+    //      +-----------------+\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (1, 2),\n+        (2, 3),\n+        (3, 5),\n+        (3, 1),\n+        (2, 4),\n+        (4, 6),\n+        (6, 2),\n+    ]);\n+\n+    let rev_graph = TransposedGraph::new(&graph);\n+\n+    let result = post_order_from_to(&rev_graph, 6, Some(2));\n+    assert_eq!(result, vec![4, 6]);\n+\n+    let result = post_order_from_to(&rev_graph, 3, Some(1));\n+    assert_eq!(result, vec![4, 6, 2, 3]);\n+}\n+"}, {"sha": "f9e75b12e0358628f4d93bf48243cf3808ed815a", "filename": "src/librustc_data_structures/control_flow_graph/mod.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::indexed_vec::Idx;\n+pub use std::slice::Iter;\n+\n+pub mod dominators;\n+pub mod iterate;\n+pub mod reachable;\n+mod reference;\n+pub mod transpose;\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub trait ControlFlowGraph\n+    where Self: for<'graph> GraphPredecessors<'graph, Item=<Self as ControlFlowGraph>::Node>,\n+          Self: for<'graph> GraphSuccessors<'graph, Item=<Self as ControlFlowGraph>::Node>\n+{\n+    type Node: Idx;\n+\n+    fn num_nodes(&self) -> usize;\n+    fn start_node(&self) -> Self::Node;\n+    fn predecessors<'graph>(&'graph self, node: Self::Node)\n+                            -> <Self as GraphPredecessors<'graph>>::Iter;\n+    fn successors<'graph>(&'graph self, node: Self::Node)\n+                            -> <Self as GraphSuccessors<'graph>>::Iter;\n+}\n+\n+pub trait GraphPredecessors<'graph> {\n+    type Item;\n+    type Iter: Iterator<Item=Self::Item>;\n+}\n+\n+pub trait GraphSuccessors<'graph> {\n+    type Item;\n+    type Iter: Iterator<Item=Self::Item>;\n+}\n\\ No newline at end of file"}, {"sha": "e520e23f3afb822e9738b0535f0e30a8623ed270", "filename": "src/librustc_data_structures/control_flow_graph/reachable/mod.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Compute reachability using a simple dataflow propagation.\n+//! Store end-result in a big NxN bit matrix.\n+\n+use super::ControlFlowGraph;\n+use super::super::bitvec::BitVector;\n+use super::iterate::reverse_post_order;\n+use super::super::indexed_vec::{IndexVec, Idx};\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub fn reachable<G: ControlFlowGraph>(graph: &G)\n+                                      -> Reachability<G::Node> {\n+    let reverse_post_order = reverse_post_order(graph, graph.start_node());\n+    reachable_given_rpo(graph, &reverse_post_order)\n+}\n+\n+pub fn reachable_given_rpo<G: ControlFlowGraph>(graph: &G,\n+                                                reverse_post_order: &[G::Node])\n+                                                -> Reachability<G::Node> {\n+    let mut reachability = Reachability::new(graph);\n+    let mut changed = true;\n+    while changed {\n+        changed = false;\n+        for &node in reverse_post_order.iter().rev() {\n+            // every node can reach itself\n+            changed |= reachability.bits[node].insert(node.index());\n+\n+            // and every pred can reach everything node can reach\n+            for pred in graph.predecessors(node) {\n+                let nodes_bits = reachability.bits[node].clone();\n+                changed |= reachability.bits[pred].insert_all(&nodes_bits);\n+            }\n+        }\n+    }\n+    reachability\n+}\n+\n+pub struct Reachability<Node: Idx> {\n+    bits: IndexVec<Node, BitVector>,\n+}\n+\n+impl<Node: Idx> Reachability<Node> {\n+    fn new<G: ControlFlowGraph>(graph: &G) -> Self {\n+        let num_nodes = graph.num_nodes();\n+        Reachability {\n+            bits: IndexVec::from_elem_n(BitVector::new(num_nodes), num_nodes),\n+        }\n+    }\n+\n+    pub fn can_reach(&self, source: Node, target: Node)-> bool {\n+        let bit: usize = target.index();\n+        self.bits[source].contains(bit)\n+    }\n+}"}, {"sha": "6aa906a0804e2707bd1e92bd1df81c6f34fee104", "filename": "src/librustc_data_structures/control_flow_graph/reachable/test.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::super::test::TestGraph;\n+\n+use super::*;\n+\n+#[test]\n+fn test1() {\n+    // 0 -> 1 -> 2 -> 3\n+    //      ^    v\n+    //      6 <- 4 -> 5\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (1, 2),\n+        (2, 3),\n+        (2, 4),\n+        (4, 5),\n+        (4, 6),\n+        (6, 1),\n+    ]);\n+    let reachable = reachable(&graph);\n+    assert!((0..6).all(|i| reachable.can_reach(0, i)));\n+    assert!((1..6).all(|i| reachable.can_reach(1, i)));\n+    assert!((1..6).all(|i| reachable.can_reach(2, i)));\n+    assert!((1..6).all(|i| reachable.can_reach(4, i)));\n+    assert!((1..6).all(|i| reachable.can_reach(6, i)));\n+    assert!(reachable.can_reach(3, 3));\n+    assert!(!reachable.can_reach(3, 5));\n+    assert!(!reachable.can_reach(5, 3));\n+}\n+\n+/// use bigger indices to cross between words in the bit set\n+#[test]\n+fn test2() {\n+    // 30 -> 31 -> 32 -> 33\n+    //       ^      v\n+    //       36 <- 34 -> 35\n+    let graph = TestGraph::new(30, &[\n+        (30, 31),\n+        (31, 32),\n+        (32, 33),\n+        (32, 34),\n+        (34, 35),\n+        (34, 36),\n+        (36, 31),\n+    ]);\n+    let reachable = reachable(&graph);\n+    assert!((30..36).all(|i| reachable.can_reach(30, i)));\n+    assert!((31..36).all(|i| reachable.can_reach(31, i)));\n+    assert!((31..36).all(|i| reachable.can_reach(32, i)));\n+    assert!((31..36).all(|i| reachable.can_reach(34, i)));\n+    assert!((31..36).all(|i| reachable.can_reach(36, i)));\n+    assert!(reachable.can_reach(33, 33));\n+    assert!(!reachable.can_reach(33, 35));\n+    assert!(!reachable.can_reach(35, 33));\n+}"}, {"sha": "d735be1ed2f543e39dbba62a4302693de7140b84", "filename": "src/librustc_data_structures/control_flow_graph/reference.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freference.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+impl<'graph, G: ControlFlowGraph> ControlFlowGraph for &'graph G {\n+    type Node = G::Node;\n+\n+    fn num_nodes(&self) -> usize {\n+        (**self).num_nodes()\n+    }\n+\n+    fn start_node(&self) -> Self::Node {\n+        (**self).start_node()\n+    }\n+\n+    fn predecessors<'iter>(&'iter self, node: Self::Node)\n+                            -> <Self as GraphPredecessors<'iter>>::Iter {\n+        (**self).predecessors(node)\n+    }\n+\n+    fn successors<'iter>(&'iter self, node: Self::Node)\n+                          -> <Self as GraphSuccessors<'iter>>::Iter {\n+        (**self).successors(node)\n+    }\n+}\n+\n+impl<'iter, 'graph, G: ControlFlowGraph> GraphPredecessors<'iter> for &'graph G {\n+    type Item = G::Node;\n+    type Iter = <G as GraphPredecessors<'iter>>::Iter;\n+}\n+\n+impl<'iter, 'graph, G: ControlFlowGraph> GraphSuccessors<'iter> for &'graph G {\n+    type Item = G::Node;\n+    type Iter = <G as GraphSuccessors<'iter>>::Iter;\n+}"}, {"sha": "57b2a858de56803e035d9aa268c3e2b9633f9583", "filename": "src/librustc_data_structures/control_flow_graph/test.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftest.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+use std::cmp::max;\n+use std::slice;\n+use std::iter;\n+\n+use super::{ControlFlowGraph, GraphPredecessors, GraphSuccessors};\n+\n+pub struct TestGraph {\n+    num_nodes: usize,\n+    start_node: usize,\n+    successors: HashMap<usize, Vec<usize>>,\n+    predecessors: HashMap<usize, Vec<usize>>,\n+}\n+\n+impl TestGraph {\n+    pub fn new(start_node: usize, edges: &[(usize, usize)]) -> Self {\n+        let mut graph = TestGraph {\n+            num_nodes: start_node + 1,\n+            start_node: start_node,\n+            successors: HashMap::new(),\n+            predecessors: HashMap::new()\n+        };\n+        for &(source, target) in edges {\n+            graph.num_nodes = max(graph.num_nodes, source + 1);\n+            graph.num_nodes = max(graph.num_nodes, target + 1);\n+            graph.successors.entry(source).or_insert(vec![]).push(target);\n+            graph.predecessors.entry(target).or_insert(vec![]).push(source);\n+        }\n+        for node in 0..graph.num_nodes {\n+            graph.successors.entry(node).or_insert(vec![]);\n+            graph.predecessors.entry(node).or_insert(vec![]);\n+        }\n+        graph\n+    }\n+}\n+\n+impl ControlFlowGraph for TestGraph {\n+    type Node = usize;\n+\n+    fn start_node(&self) -> usize {\n+        self.start_node\n+    }\n+\n+    fn num_nodes(&self) -> usize {\n+        self.num_nodes\n+    }\n+\n+    fn predecessors<'graph>(&'graph self, node: usize)\n+                            -> <Self as GraphPredecessors<'graph>>::Iter {\n+       self.predecessors[&node].iter().cloned()\n+    }\n+\n+    fn successors<'graph>(&'graph self, node: usize)\n+                            -> <Self as GraphSuccessors<'graph>>::Iter {\n+        self.successors[&node].iter().cloned()\n+    }\n+}\n+\n+impl<'graph> GraphPredecessors<'graph> for TestGraph {\n+    type Item = usize;\n+    type Iter = iter::Cloned<slice::Iter<'graph, usize>>;\n+}\n+\n+impl<'graph> GraphSuccessors<'graph> for TestGraph {\n+    type Item = usize;\n+    type Iter = iter::Cloned<slice::Iter<'graph, usize>>;\n+}\n+"}, {"sha": "792e079c28c85ad670046de4469af4d4d4f9668f", "filename": "src/librustc_data_structures/control_flow_graph/transpose.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+pub struct TransposedGraph<G: ControlFlowGraph> {\n+    base_graph: G,\n+    start_node: G::Node,\n+}\n+\n+impl<G: ControlFlowGraph> TransposedGraph<G> {\n+    pub fn new(base_graph: G) -> Self {\n+        let start_node = base_graph.start_node();\n+        Self::with_start(base_graph, start_node)\n+    }\n+\n+    pub fn with_start(base_graph: G, start_node: G::Node) -> Self {\n+        TransposedGraph { base_graph: base_graph, start_node: start_node }\n+    }\n+}\n+\n+impl<G: ControlFlowGraph> ControlFlowGraph for TransposedGraph<G> {\n+    type Node = G::Node;\n+\n+    fn num_nodes(&self) -> usize {\n+        self.base_graph.num_nodes()\n+    }\n+\n+    fn start_node(&self) -> Self::Node {\n+        self.start_node\n+    }\n+\n+    fn predecessors<'graph>(&'graph self, node: Self::Node)\n+                            -> <Self as GraphPredecessors<'graph>>::Iter {\n+        self.base_graph.successors(node)\n+    }\n+\n+    fn successors<'graph>(&'graph self, node: Self::Node)\n+                          -> <Self as GraphSuccessors<'graph>>::Iter {\n+        self.base_graph.predecessors(node)\n+    }\n+}\n+\n+impl<'graph, G: ControlFlowGraph> GraphPredecessors<'graph> for TransposedGraph<G> {\n+    type Item = G::Node;\n+    type Iter = <G as GraphSuccessors<'graph>>::Iter;\n+}\n+\n+impl<'graph, G: ControlFlowGraph> GraphSuccessors<'graph> for TransposedGraph<G> {\n+    type Item = G::Node;\n+    type Iter = <G as GraphPredecessors<'graph>>::Iter;\n+}"}, {"sha": "b3918f1e4bc8b271900f9ceb329374348885e93e", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::fmt::Debug;\n use std::iter::{self, FromIterator};\n use std::slice;\n use std::marker::PhantomData;\n@@ -20,7 +21,7 @@ use rustc_serialize as serialize;\n /// Represents some newtyped `usize` wrapper.\n ///\n /// (purpose: avoid mixing indexes for different bitvector domains.)\n-pub trait Idx: Copy + 'static {\n+pub trait Idx: Copy + 'static + Eq + Debug {\n     fn new(usize) -> Self;\n     fn index(self) -> usize;\n }\n@@ -76,6 +77,13 @@ impl<I: Idx, T> IndexVec<I, T> {\n         IndexVec { raw: vec![elem; universe.len()], _marker: PhantomData }\n     }\n \n+    #[inline]\n+    pub fn from_elem_n(elem: T, n: usize) -> Self\n+        where T: Clone\n+    {\n+        IndexVec { raw: vec![elem; n], _marker: PhantomData }\n+    }\n+\n     #[inline]\n     pub fn push(&mut self, d: T) -> I {\n         let idx = I::new(self.len());"}, {"sha": "34c3961d5b4c18980c4b2ea36f6729d06dd22f20", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d60c78b3c31629b13202f3d2281b2674c7ec3e/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=66d60c78b3c31629b13202f3d2281b2674c7ec3e", "patch": "@@ -50,6 +50,7 @@ pub mod unify;\n pub mod fnv;\n pub mod tuple_slice;\n pub mod veccell;\n+pub mod control_flow_graph;\n \n // See comments in src/librustc/lib.rs\n #[doc(hidden)]"}]}