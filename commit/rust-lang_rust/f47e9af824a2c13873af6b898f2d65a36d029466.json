{"sha": "f47e9af824a2c13873af6b898f2d65a36d029466", "node_id": "C_kwDOAAsO6NoAKGY0N2U5YWY4MjRhMmMxMzg3M2FmNmI4OThmMmQ2NWEzNmQwMjk0NjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-03T11:02:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-03T11:02:58Z"}, "message": "Auto merge of #102551 - bjorn3:cg_ssa_cleanup, r=davidtwco\n\nSome more cleanup for rustc_codegen_ssa\n\nWith the aim to make non-LLVM like backends, like Cranelift, easier to support using cg_ssa.", "tree": {"sha": "16e6fa4830447d1ab70fe65f685d1d16aff162eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16e6fa4830447d1ab70fe65f685d1d16aff162eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f47e9af824a2c13873af6b898f2d65a36d029466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f47e9af824a2c13873af6b898f2d65a36d029466", "html_url": "https://github.com/rust-lang/rust/commit/f47e9af824a2c13873af6b898f2d65a36d029466", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f47e9af824a2c13873af6b898f2d65a36d029466/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b139c5b3e2bad623bdbd8583bc4f2b0f763113a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b139c5b3e2bad623bdbd8583bc4f2b0f763113a", "html_url": "https://github.com/rust-lang/rust/commit/6b139c5b3e2bad623bdbd8583bc4f2b0f763113a"}, {"sha": "268e02c3875f8d0310a8eeb36007e7d80aa63cbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/268e02c3875f8d0310a8eeb36007e7d80aa63cbd", "html_url": "https://github.com/rust-lang/rust/commit/268e02c3875f8d0310a8eeb36007e7d80aa63cbd"}], "stats": {"total": 246, "additions": 115, "deletions": 131}, "files": [{"sha": "6fb1cbfad8cd3a422ef427b0797e8ac9af1b97cf", "filename": "compiler/rustc_codegen_gcc/src/abi.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -11,10 +11,6 @@ use crate::intrinsic::ArgAbiExt;\n use crate::type_of::LayoutGccExt;\n \n impl<'a, 'gcc, 'tcx> AbiBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn apply_attrs_callsite(&mut self, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>, _callsite: Self::Value) {\n-        // TODO(antoyo)\n-    }\n-\n     fn get_param(&mut self, index: usize) -> Self::Value {\n         let func = self.current_func();\n         let param = func.get_param(index as i32);"}, {"sha": "c346dbd63cca75e38052283f641e54a740f0f43d", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         if options.contains(InlineAsmOptions::NORETURN) {\n             let builtin_unreachable = self.context.get_builtin_function(\"__builtin_unreachable\");\n             let builtin_unreachable: RValue<'gcc> = unsafe { std::mem::transmute(builtin_unreachable) };\n-            self.call(self.type_void(), builtin_unreachable, &[], None);\n+            self.call(self.type_void(), None, builtin_unreachable, &[], None);\n         }\n \n         // Write results to outputs."}, {"sha": "a314b7cc2152ddf7d1a74ec5a16300e51e212d05", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -444,11 +444,23 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.block.end_with_switch(None, value, default_block, &gcc_cases);\n     }\n \n-    fn invoke(&mut self, typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn invoke(\n+        &mut self,\n+        typ: Type<'gcc>,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n+        func: RValue<'gcc>,\n+        args: &[RValue<'gcc>],\n+        then: Block<'gcc>,\n+        catch: Block<'gcc>,\n+        _funclet: Option<&Funclet>,\n+    ) -> RValue<'gcc> {\n         // TODO(bjorn3): Properly implement unwinding.\n-        let call_site = self.call(typ, func, args, None);\n+        let call_site = self.call(typ, None, func, args, None);\n         let condition = self.context.new_rvalue_from_int(self.bool_type, 1);\n         self.llbb().end_with_conditional(None, condition, then, catch);\n+        if let Some(_fn_abi) = fn_abi {\n+            // TODO(bjorn3): Apply function attributes\n+        }\n         call_site\n     }\n \n@@ -643,11 +655,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.current_func().new_local(None, aligned_type, &format!(\"stack_var_{}\", self.stack_var_count.get())).get_address(None)\n     }\n \n-    fn dynamic_alloca(&mut self, _ty: Type<'gcc>, _align: Align) -> RValue<'gcc> {\n-        unimplemented!();\n-    }\n-\n-    fn array_alloca(&mut self, _ty: Type<'gcc>, _len: RValue<'gcc>, _align: Align) -> RValue<'gcc> {\n+    fn byte_array_alloca(&mut self, _len: RValue<'gcc>, _align: Align) -> RValue<'gcc> {\n         unimplemented!();\n     }\n \n@@ -1227,16 +1235,27 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn call(&mut self, _typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn call(\n+        &mut self,\n+        _typ: Type<'gcc>,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n+        func: RValue<'gcc>,\n+        args: &[RValue<'gcc>],\n+        funclet: Option<&Funclet>,\n+    ) -> RValue<'gcc> {\n         // FIXME(antoyo): remove when having a proper API.\n         let gcc_func = unsafe { std::mem::transmute(func) };\n-        if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n+        let call = if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n             self.function_call(func, args, funclet)\n         }\n         else {\n             // If it's a not function that was defined, it's a function pointer.\n             self.function_ptr_call(func, args, funclet)\n+        };\n+        if let Some(_fn_abi) = fn_abi {\n+            // TODO(bjorn3): Apply function attributes\n         }\n+        call\n     }\n \n     fn zext(&mut self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {"}, {"sha": "62a61eb8548da6b9d2a662ddb3be71b139297424", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -416,10 +416,6 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         self.codegen_unit\n     }\n \n-    fn used_statics(&self) -> &RefCell<Vec<RValue<'gcc>>> {\n-        unimplemented!();\n-    }\n-\n     fn set_frame_pointer_type(&self, _llfn: RValue<'gcc>) {\n         // TODO(antoyo)\n     }\n@@ -428,10 +424,6 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn create_used_variable(&self) {\n-        unimplemented!();\n-    }\n-\n     fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function> {\n         if self.get_declared_value(\"main\").is_none() {\n             Some(self.declare_cfn(\"main\", fn_type))\n@@ -443,14 +435,6 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             None\n         }\n     }\n-\n-    fn compiler_used_statics(&self) -> &RefCell<Vec<RValue<'gcc>>> {\n-        unimplemented!()\n-    }\n-\n-    fn create_compiler_used_variable(&self) {\n-        unimplemented!()\n-    }\n }\n \n impl<'gcc, 'tcx> HasTyCtxt<'tcx> for CodegenCx<'gcc, 'tcx> {"}, {"sha": "49be6c649e6521801290099744b7edbe0535a988", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 _ if simple.is_some() => {\n                     // FIXME(antoyo): remove this cast when the API supports function.\n                     let func = unsafe { std::mem::transmute(simple.expect(\"simple\")) };\n-                    self.call(self.type_void(), func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n+                    self.call(self.type_void(), None, func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n                 },\n                 sym::likely => {\n                     self.expect(args[0].immediate(), true)\n@@ -341,7 +341,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn abort(&mut self) {\n         let func = self.context.get_builtin_function(\"abort\");\n         let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n-        self.call(self.type_void(), func, &[], None);\n+        self.call(self.type_void(), None, func, &[], None);\n     }\n \n     fn assume(&mut self, value: Self::Value) {\n@@ -1124,7 +1124,7 @@ fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<\n     // NOTE: the `|| true` here is to use the panic=abort strategy with panic=unwind too\n     if bx.sess().panic_strategy() == PanicStrategy::Abort || true {\n         // TODO(bjorn3): Properly implement unwinding and remove the `|| true` once this is done.\n-        bx.call(bx.type_void(), try_func, &[data], None);\n+        bx.call(bx.type_void(), None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx.data_layout.i32_align.abi;"}, {"sha": "12e416f62a4e084b49bb0425d526e2c41897057a", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -461,7 +461,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let function = intrinsic::llvm::intrinsic(llvm_name, &bx.cx);\n         let function: RValue<'gcc> = unsafe { std::mem::transmute(function) };\n-        let c = bx.call(fn_ty, function, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n+        let c = bx.call(fn_ty, None, function, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n         Ok(c)\n     }\n "}, {"sha": "accd02ab0026991fa389acd7e6e0c97ab748948a", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -171,15 +171,6 @@ impl ExtraBackendMethods for GccCodegenBackend {\n             Ok(())\n         })\n     }\n-\n-    fn target_cpu<'b>(&self, _sess: &'b Session) -> &'b str {\n-        unimplemented!();\n-    }\n-\n-    fn tune_cpu<'b>(&self, _sess: &'b Session) -> Option<&'b str> {\n-        None\n-        // TODO(antoyo)\n-    }\n }\n \n pub struct ModuleBuffer;\n@@ -210,7 +201,6 @@ impl WriteBackendMethods for GccCodegenBackend {\n     type Module = GccContext;\n     type TargetMachine = ();\n     type ModuleBuffer = ModuleBuffer;\n-    type Context = ();\n     type ThinData = ();\n     type ThinBuffer = ThinBuffer;\n "}, {"sha": "d478efc863a9e21fb7cb3863ed1bce2200e015b7", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -592,10 +592,6 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n }\n \n impl<'tcx> AbiBuilderMethods<'tcx> for Builder<'_, '_, 'tcx> {\n-    fn apply_attrs_callsite(&mut self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>, callsite: Self::Value) {\n-        fn_abi.apply_attrs_callsite(self, callsite)\n-    }\n-\n     fn get_param(&mut self, index: usize) -> Self::Value {\n         llvm::get_param(self.llfn(), index as c_uint)\n     }"}, {"sha": "e723187ff1f6d489a5ebcfdc0d62b6ea35160136", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -430,9 +430,9 @@ pub(crate) fn inline_asm_call<'ll>(\n             );\n \n             let call = if let Some((dest, catch, funclet)) = dest_catch_funclet {\n-                bx.invoke(fty, v, inputs, dest, catch, funclet)\n+                bx.invoke(fty, None, v, inputs, dest, catch, funclet)\n             } else {\n-                bx.call(fty, v, inputs, None)\n+                bx.call(fty, None, v, inputs, None)\n             };\n \n             // Store mark in a metadata node so we can map LLVM errors"}, {"sha": "5b2bbdb4bde1eb09605d6282c187692a4d54582e", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -19,6 +19,8 @@ use crate::context::CodegenCx;\n use crate::llvm;\n use crate::value::Value;\n \n+use cstr::cstr;\n+\n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n use rustc_codegen_ssa::mono_item::MonoItemExt;\n use rustc_codegen_ssa::traits::*;\n@@ -107,11 +109,14 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol) -> (ModuleCodegen\n             }\n \n             // Create the llvm.used and llvm.compiler.used variables.\n-            if !cx.used_statics().borrow().is_empty() {\n-                cx.create_used_variable()\n+            if !cx.used_statics.borrow().is_empty() {\n+                cx.create_used_variable_impl(cstr!(\"llvm.used\"), &*cx.used_statics.borrow());\n             }\n-            if !cx.compiler_used_statics().borrow().is_empty() {\n-                cx.create_compiler_used_variable()\n+            if !cx.compiler_used_statics.borrow().is_empty() {\n+                cx.create_used_variable_impl(\n+                    cstr!(\"llvm.compiler.used\"),\n+                    &*cx.compiler_used_statics.borrow(),\n+                );\n             }\n \n             // Run replace-all-uses-with for statics that need it. This must"}, {"sha": "fca43a0d86ddd5b8614424fd0aac1ddbf87daf6d", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -1,3 +1,4 @@\n+use crate::abi::FnAbiLlvmExt;\n use crate::attributes;\n use crate::common::Funclet;\n use crate::context::CodegenCx;\n@@ -214,6 +215,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn invoke(\n         &mut self,\n         llty: &'ll Type,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: &'ll Value,\n         args: &[&'ll Value],\n         then: &'ll BasicBlock,\n@@ -226,7 +228,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let bundle = funclet.map(|funclet| funclet.bundle());\n         let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n-        unsafe {\n+        let invoke = unsafe {\n             llvm::LLVMRustBuildInvoke(\n                 self.llbuilder,\n                 llty,\n@@ -238,7 +240,11 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 bundle,\n                 UNNAMED,\n             )\n+        };\n+        if let Some(fn_abi) = fn_abi {\n+            fn_abi.apply_attrs_callsite(self, invoke);\n         }\n+        invoke\n     }\n \n     fn unreachable(&mut self) {\n@@ -405,20 +411,17 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         let mut bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe { llvm::LLVMGetFirstBasicBlock(self.llfn()) });\n-        bx.dynamic_alloca(ty, align)\n-    }\n-\n-    fn dynamic_alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         unsafe {\n-            let alloca = llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED);\n+            let alloca = llvm::LLVMBuildAlloca(bx.llbuilder, ty, UNNAMED);\n             llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }\n     }\n \n-    fn array_alloca(&mut self, ty: &'ll Type, len: &'ll Value, align: Align) -> &'ll Value {\n+    fn byte_array_alloca(&mut self, len: &'ll Value, align: Align) -> &'ll Value {\n         unsafe {\n-            let alloca = llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED);\n+            let alloca =\n+                llvm::LLVMBuildArrayAlloca(self.llbuilder, self.cx().type_i8(), len, UNNAMED);\n             llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }\n@@ -1145,6 +1148,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn call(\n         &mut self,\n         llty: &'ll Type,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: &'ll Value,\n         args: &[&'ll Value],\n         funclet: Option<&Funclet<'ll>>,\n@@ -1155,7 +1159,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let bundle = funclet.map(|funclet| funclet.bundle());\n         let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n-        unsafe {\n+        let call = unsafe {\n             llvm::LLVMRustBuildCall(\n                 self.llbuilder,\n                 llty,\n@@ -1164,7 +1168,11 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 args.len() as c_uint,\n                 bundle,\n             )\n+        };\n+        if let Some(fn_abi) = fn_abi {\n+            fn_abi.apply_attrs_callsite(self, call);\n         }\n+        call\n     }\n \n     fn zext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n@@ -1397,7 +1405,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n \n     pub(crate) fn call_intrinsic(&mut self, intrinsic: &str, args: &[&'ll Value]) -> &'ll Value {\n         let (ty, f) = self.cx.get_intrinsic(intrinsic);\n-        self.call(ty, f, args, None)\n+        self.call(ty, None, f, args, None)\n     }\n \n     fn call_lifetime_intrinsic(&mut self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n@@ -1459,7 +1467,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n             format!(\"llvm.{}.sat.i{}.f{}\", instr, int_width, float_width)\n         };\n         let f = self.declare_cfn(&name, llvm::UnnamedAddr::No, self.type_func(&[src_ty], dest_ty));\n-        self.call(self.type_func(&[src_ty], dest_ty), f, &[val], None)\n+        self.call(self.type_func(&[src_ty], dest_ty), None, f, &[val], None)\n     }\n \n     pub(crate) fn landing_pad("}, {"sha": "79ddfd884dfac69f29fca10fed4063dda0c7c226", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -458,7 +458,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         self.coverage_cx.as_ref()\n     }\n \n-    fn create_used_variable_impl(&self, name: &'static CStr, values: &[&'ll Value]) {\n+    pub(crate) fn create_used_variable_impl(&self, name: &'static CStr, values: &[&'ll Value]) {\n         let section = cstr!(\"llvm.metadata\");\n         let array = self.const_array(self.type_ptr_to(self.type_i8()), values);\n \n@@ -556,14 +556,6 @@ impl<'ll, 'tcx> MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         self.codegen_unit\n     }\n \n-    fn used_statics(&self) -> &RefCell<Vec<&'ll Value>> {\n-        &self.used_statics\n-    }\n-\n-    fn compiler_used_statics(&self) -> &RefCell<Vec<&'ll Value>> {\n-        &self.compiler_used_statics\n-    }\n-\n     fn set_frame_pointer_type(&self, llfn: &'ll Value) {\n         if let Some(attr) = attributes::frame_pointer_type_attr(self) {\n             attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[attr]);\n@@ -577,17 +569,6 @@ impl<'ll, 'tcx> MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &attrs);\n     }\n \n-    fn create_used_variable(&self) {\n-        self.create_used_variable_impl(cstr!(\"llvm.used\"), &*self.used_statics.borrow());\n-    }\n-\n-    fn create_compiler_used_variable(&self) {\n-        self.create_used_variable_impl(\n-            cstr!(\"llvm.compiler.used\"),\n-            &*self.compiler_used_statics.borrow(),\n-        );\n-    }\n-\n     fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function> {\n         if self.get_declared_value(\"main\").is_none() {\n             Some(self.declare_cfn(\"main\", llvm::UnnamedAddr::Global, fn_type))"}, {"sha": "825011941a24117a00f65638cc53e5efc2100d27", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -108,6 +108,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 let (simple_ty, simple_fn) = simple.unwrap();\n                 self.call(\n                     simple_ty,\n+                    None,\n                     simple_fn,\n                     &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n                     None,\n@@ -435,7 +436,7 @@ fn try_intrinsic<'ll>(\n ) {\n     if bx.sess().panic_strategy() == PanicStrategy::Abort {\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.call(try_func_ty, try_func, &[data], None);\n+        bx.call(try_func_ty, None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx().data_layout.i32_align.abi;\n@@ -534,7 +535,7 @@ fn codegen_msvc_try<'ll>(\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let slot = bx.alloca(bx.type_i8p(), ptr_align);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], normal, catchswitch, None);\n+        bx.invoke(try_func_ty, None, try_func, &[data], normal, catchswitch, None);\n \n         bx.switch_to_block(normal);\n         bx.ret(bx.const_i32(0));\n@@ -578,15 +579,15 @@ fn codegen_msvc_try<'ll>(\n         let funclet = bx.catch_pad(cs, &[tydesc, flags, slot]);\n         let ptr = bx.load(bx.type_i8p(), slot, ptr_align);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, catch_func, &[data, ptr], Some(&funclet));\n+        bx.call(catch_ty, None, catch_func, &[data, ptr], Some(&funclet));\n         bx.catch_ret(&funclet, caught);\n \n         // The flag value of 64 indicates a \"catch-all\".\n         bx.switch_to_block(catchpad_foreign);\n         let flags = bx.const_i32(64);\n         let null = bx.const_null(bx.type_i8p());\n         let funclet = bx.catch_pad(cs, &[null, flags, null]);\n-        bx.call(catch_ty, catch_func, &[data, null], Some(&funclet));\n+        bx.call(catch_ty, None, catch_func, &[data, null], Some(&funclet));\n         bx.catch_ret(&funclet, caught);\n \n         bx.switch_to_block(caught);\n@@ -595,7 +596,7 @@ fn codegen_msvc_try<'ll>(\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -638,7 +639,7 @@ fn codegen_gnu_try<'ll>(\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n \n         bx.switch_to_block(then);\n         bx.ret(bx.const_i32(0));\n@@ -656,13 +657,13 @@ fn codegen_gnu_try<'ll>(\n         bx.add_clause(vals, tydesc);\n         let ptr = bx.extract_value(vals, 0);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, catch_func, &[data, ptr], None);\n+        bx.call(catch_ty, None, catch_func, &[data, ptr], None);\n         bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -702,7 +703,7 @@ fn codegen_emcc_try<'ll>(\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n \n         bx.switch_to_block(then);\n         bx.ret(bx.const_i32(0));\n@@ -741,13 +742,13 @@ fn codegen_emcc_try<'ll>(\n         let catch_data = bx.bitcast(catch_data, bx.type_i8p());\n \n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, catch_func, &[data, catch_data], None);\n+        bx.call(catch_ty, None, catch_func, &[data, catch_data], None);\n         bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -1217,8 +1218,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let f = bx.declare_cfn(llvm_name, llvm::UnnamedAddr::No, fn_ty);\n-        let c =\n-            bx.call(fn_ty, f, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n+        let c = bx.call(\n+            fn_ty,\n+            None,\n+            f,\n+            &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n+            None,\n+        );\n         Ok(c)\n     }\n \n@@ -1417,8 +1423,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             llvm_elem_vec_ty,\n         );\n         let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n-        let v =\n-            bx.call(fn_ty, f, &[args[1].immediate(), alignment, mask, args[0].immediate()], None);\n+        let v = bx.call(\n+            fn_ty,\n+            None,\n+            f,\n+            &[args[1].immediate(), alignment, mask, args[0].immediate()],\n+            None,\n+        );\n         return Ok(v);\n     }\n \n@@ -1543,8 +1554,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         let fn_ty =\n             bx.type_func(&[llvm_elem_vec_ty, llvm_pointer_vec_ty, alignment_ty, mask_ty], ret_t);\n         let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n-        let v =\n-            bx.call(fn_ty, f, &[args[0].immediate(), args[1].immediate(), alignment, mask], None);\n+        let v = bx.call(\n+            fn_ty,\n+            None,\n+            f,\n+            &[args[0].immediate(), args[1].immediate(), alignment, mask],\n+            None,\n+        );\n         return Ok(v);\n     }\n \n@@ -1992,7 +2008,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n \n         let fn_ty = bx.type_func(&[vec_ty, vec_ty], vec_ty);\n         let f = bx.declare_cfn(llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n-        let v = bx.call(fn_ty, f, &[lhs, rhs], None);\n+        let v = bx.call(fn_ty, None, f, &[lhs, rhs], None);\n         return Ok(v);\n     }\n "}, {"sha": "89c7e51d09ec1affd65e17bb73aa5317b5921723", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -131,12 +131,6 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n     ) -> TargetMachineFactoryFn<Self> {\n         back::write::target_machine_factory(sess, optlvl, target_features)\n     }\n-    fn target_cpu<'b>(&self, sess: &'b Session) -> &'b str {\n-        llvm_util::target_cpu(sess)\n-    }\n-    fn tune_cpu<'b>(&self, sess: &'b Session) -> Option<&'b str> {\n-        llvm_util::tune_cpu(sess)\n-    }\n \n     fn spawn_thread<F, T>(time_trace: bool, f: F) -> std::thread::JoinHandle<T>\n     where\n@@ -170,7 +164,6 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n impl WriteBackendMethods for LlvmCodegenBackend {\n     type Module = ModuleLlvm;\n     type ModuleBuffer = back::lto::ModuleBuffer;\n-    type Context = llvm::Context;\n     type TargetMachine = &'static mut llvm::TargetMachine;\n     type ThinData = back::lto::ThinData;\n     type ThinBuffer = back::lto::ThinBuffer;"}, {"sha": "cb5436fd61a16177d46c062f497f383353efe3e8", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -474,7 +474,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             (rust_main, start_ty, vec![arg_argc, arg_argv])\n         };\n \n-        let result = bx.call(start_ty, start_fn, &args, None);\n+        let result = bx.call(start_ty, None, start_fn, &args, None);\n         let cast = bx.intcast(result, cx.type_int(), true);\n         bx.ret(cast);\n "}, {"sha": "bd4f0cac7eb46dc9dc6d11e17fae9d0e748ca1e0", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -162,9 +162,15 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             } else {\n                 fx.unreachable_block()\n             };\n-            let invokeret =\n-                bx.invoke(fn_ty, fn_ptr, &llargs, ret_llbb, unwind_block, self.funclet(fx));\n-            bx.apply_attrs_callsite(&fn_abi, invokeret);\n+            let invokeret = bx.invoke(\n+                fn_ty,\n+                Some(&fn_abi),\n+                fn_ptr,\n+                &llargs,\n+                ret_llbb,\n+                unwind_block,\n+                self.funclet(fx),\n+            );\n             if fx.mir[self.bb].is_cleanup {\n                 bx.do_not_inline(invokeret);\n             }\n@@ -178,8 +184,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 fx.store_return(bx, ret_dest, &fn_abi.ret, invokeret);\n             }\n         } else {\n-            let llret = bx.call(fn_ty, fn_ptr, &llargs, self.funclet(fx));\n-            bx.apply_attrs_callsite(&fn_abi, llret);\n+            let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &llargs, self.funclet(fx));\n             if fx.mir[self.bb].is_cleanup {\n                 // Cleanup is always the cold path. Don't inline\n                 // drop glue. Also, when there is a deeply-nested\n@@ -1533,8 +1538,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let (fn_abi, fn_ptr) = common::build_langcall(&bx, None, LangItem::PanicNoUnwind);\n             let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n-            let llret = bx.call(fn_ty, fn_ptr, &[], None);\n-            bx.apply_attrs_callsite(&fn_abi, llret);\n+            let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &[], None);\n             bx.do_not_inline(llret);\n \n             bx.unreachable();"}, {"sha": "e6ba642a7ed0e969a1eb3d3e7bdc0ad6fc13d361", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -352,7 +352,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n-        let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, max_align);\n+        let lldst = bx.byte_array_alloca(llsize, max_align);\n         bx.memcpy(lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place."}, {"sha": "60d8f2a9ece4867900c4301ff5f895f8b7ad0c2a", "filename": "compiler/rustc_codegen_ssa/src/traits/abi.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fabi.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -1,8 +1,5 @@\n use super::BackendTypes;\n-use rustc_middle::ty::Ty;\n-use rustc_target::abi::call::FnAbi;\n \n pub trait AbiBuilderMethods<'tcx>: BackendTypes {\n-    fn apply_attrs_callsite(&mut self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>, callsite: Self::Value);\n     fn get_param(&mut self, index: usize) -> Self::Value;\n }"}, {"sha": "87e347c61e2b8b94f423472a0282dcacc779de3c", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -134,8 +134,6 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         opt_level: config::OptLevel,\n         target_features: &[String],\n     ) -> TargetMachineFactoryFn<Self>;\n-    fn target_cpu<'b>(&self, sess: &'b Session) -> &'b str;\n-    fn tune_cpu<'b>(&self, sess: &'b Session) -> Option<&'b str>;\n \n     fn spawn_thread<F, T>(_time_trace: bool, f: F) -> std::thread::JoinHandle<T>\n     where"}, {"sha": "01408f39fb30606a63b5a8b4a81be9a8d15ca610", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -17,6 +17,7 @@ use crate::MemFlags;\n use rustc_middle::ty::layout::{HasParamEnv, TyAndLayout};\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n+use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Abi, Align, Scalar, Size, WrappingRange};\n use rustc_target::spec::HasTargetSpec;\n \n@@ -71,6 +72,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn invoke(\n         &mut self,\n         llty: Self::Type,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: Self::Value,\n         args: &[Self::Value],\n         then: Self::BasicBlock,\n@@ -133,8 +135,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn to_immediate_scalar(&mut self, val: Self::Value, scalar: Scalar) -> Self::Value;\n \n     fn alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n-    fn dynamic_alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n-    fn array_alloca(&mut self, ty: Self::Type, len: Self::Value, align: Align) -> Self::Value;\n+    fn byte_array_alloca(&mut self, len: Self::Value, align: Align) -> Self::Value;\n \n     fn load(&mut self, ty: Self::Type, ptr: Self::Value, align: Align) -> Self::Value;\n     fn volatile_load(&mut self, ty: Self::Type, ptr: Self::Value) -> Self::Value;\n@@ -320,6 +321,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn call(\n         &mut self,\n         llty: Self::Type,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: Self::Value,\n         args: &[Self::Value],\n         funclet: Option<&Self::Funclet>,"}, {"sha": "04e2b8796c46a21d7b12a798919c27179cbeeecb", "filename": "compiler/rustc_codegen_ssa/src/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -15,12 +15,8 @@ pub trait MiscMethods<'tcx>: BackendTypes {\n     fn eh_personality(&self) -> Self::Value;\n     fn sess(&self) -> &Session;\n     fn codegen_unit(&self) -> &'tcx CodegenUnit<'tcx>;\n-    fn used_statics(&self) -> &RefCell<Vec<Self::Value>>;\n-    fn compiler_used_statics(&self) -> &RefCell<Vec<Self::Value>>;\n     fn set_frame_pointer_type(&self, llfn: Self::Function);\n     fn apply_target_cpu_attr(&self, llfn: Self::Function);\n-    fn create_used_variable(&self);\n-    fn create_compiler_used_variable(&self);\n     /// Declares the extern \"C\" main function for the entry point. Returns None if the symbol already exists.\n     fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function>;\n }"}, {"sha": "e0e8ffa89ed155d64a23e981f243900ba3e5516b", "filename": "compiler/rustc_codegen_ssa/src/traits/write.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e9af824a2c13873af6b898f2d65a36d029466/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs?ref=f47e9af824a2c13873af6b898f2d65a36d029466", "patch": "@@ -9,7 +9,6 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n     type Module: Send + Sync;\n     type TargetMachine;\n     type ModuleBuffer: ModuleBufferMethods;\n-    type Context: ?Sized;\n     type ThinData: Send + Sync;\n     type ThinBuffer: ThinBufferMethods;\n "}]}