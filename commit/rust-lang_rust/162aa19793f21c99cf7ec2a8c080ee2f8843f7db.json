{"sha": "162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "node_id": "C_kwDOAAsO6NoAKDE2MmFhMTk3OTNmMjFjOTljZjdlYzJhOGMwODBlZTJmODg0M2Y3ZGI", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-11-11T19:15:01Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-10-02T19:02:55Z"}, "message": "Fix and improve internal lint checking for `match_type` usages\n\n* Check for `const`s and `static`s from external crates\n* Check for `LangItem`s\n* Handle inherent functions which have the same name as a field\n* Also check the following functions:\n    * `match_trait_method`\n    * `match_def_path`\n    * `is_expr_path_def_path`\n    * `is_qpath_def_path`\n* Handle checking for a constructor to a diagnostic item or `LangItem`", "tree": {"sha": "996b5d40be199472d950c4fc9431bcedcba2bffd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/996b5d40be199472d950c4fc9431bcedcba2bffd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "html_url": "https://github.com/rust-lang/rust/commit/162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e7af6b42961d6a4b6857c06aa5139a985e0009d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e7af6b42961d6a4b6857c06aa5139a985e0009d", "html_url": "https://github.com/rust-lang/rust/commit/8e7af6b42961d6a4b6857c06aa5139a985e0009d"}], "stats": {"total": 710, "additions": 534, "deletions": 176}, "files": [{"sha": "24a3588ecf16f735215a4045cd8ca26d30c57dc1", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::{def::Res, AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::GeneratorInteriorTypeCause;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n use crate::utils::conf::DisallowedType;\n \n@@ -276,9 +276,9 @@ fn emit_invalid_type(cx: &LateContext<'_>, span: Span, disallowed: &DisallowedTy\n }\n \n fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n-    match_def_path(cx, def_id, &paths::MUTEX_GUARD)\n-        || match_def_path(cx, def_id, &paths::RWLOCK_READ_GUARD)\n-        || match_def_path(cx, def_id, &paths::RWLOCK_WRITE_GUARD)\n+    cx.tcx.is_diagnostic_item(sym::MutexGuard, def_id)\n+        || cx.tcx.is_diagnostic_item(sym::RwLockReadGuard, def_id)\n+        || cx.tcx.is_diagnostic_item(sym::RwLockWriteGuard, def_id)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_MUTEX_GUARD)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_READ_GUARD)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_WRITE_GUARD)"}, {"sha": "d1d2db27c6fc0acd6efa477769d5840722056f1b", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::higher;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{higher, match_def_path, path_def_id, paths};\n use rustc_hir::{BorrowKind, Closure, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -168,9 +168,16 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n         },\n         ExprKind::Block(block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n         ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) => is_infinite(cx, e),\n-        ExprKind::Call(path, _) => path_def_id(cx, path)\n-            .map_or(false, |id| match_def_path(cx, id, &paths::ITER_REPEAT))\n-            .into(),\n+        ExprKind::Call(path, _) => {\n+            if let ExprKind::Path(ref qpath) = path.kind {\n+                cx.qpath_res(qpath, path.hir_id)\n+                    .opt_def_id()\n+                    .map_or(false, |id| cx.tcx.is_diagnostic_item(sym::iter_repeat, id))\n+                    .into()\n+            } else {\n+                Finite\n+            }\n+        },\n         ExprKind::Struct(..) => higher::Range::hir(expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }"}, {"sha": "676136df572bd0dd7cff51bc4cc1d74945a3dd2c", "filename": "clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_to_string.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{get_trait_def_id, paths, return_ty, trait_ref_of_method};\n+use clippy_utils::{return_ty, trait_ref_of_method};\n use if_chain::if_chain;\n use rustc_hir::{GenericParamKind, ImplItem, ImplItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -118,7 +118,10 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n }\n \n fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n-    let display_trait_id = get_trait_def_id(cx, &paths::DISPLAY_TRAIT).expect(\"Failed to get trait ID of `Display`!\");\n+    let display_trait_id = cx\n+        .tcx\n+        .get_diagnostic_item(sym::Display)\n+        .expect(\"Failed to get trait ID of `Display`!\");\n \n     // Get the real type of 'self'\n     let self_type = cx.tcx.fn_sig(item.def_id).input(0);"}, {"sha": "71dfdab369b97e93228a82f1de68ea331b89639d", "filename": "clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_internal.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -13,10 +13,10 @@ store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n     LintId::of(utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE),\n     LintId::of(utils::internal_lints::INVALID_PATHS),\n     LintId::of(utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n-    LintId::of(utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n     LintId::of(utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n     LintId::of(utils::internal_lints::MISSING_MSRV_ATTR_IMPL),\n     LintId::of(utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n     LintId::of(utils::internal_lints::PRODUCE_ICE),\n+    LintId::of(utils::internal_lints::UNNECESSARY_DEF_PATH),\n     LintId::of(utils::internal_lints::UNNECESSARY_SYMBOL_STR),\n ])"}, {"sha": "307ec40f40b3b155ca7e5b17d9108a440e99d065", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -24,8 +24,6 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n-    #[cfg(feature = \"internal\")]\n     utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::MISSING_MSRV_ATTR_IMPL,\n@@ -34,6 +32,8 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::PRODUCE_ICE,\n     #[cfg(feature = \"internal\")]\n+    utils::internal_lints::UNNECESSARY_DEF_PATH,\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n     almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE,\n     approx_const::APPROX_CONSTANT,"}, {"sha": "3b78e492baa480fd12f0bb6b15575f8d5962f842", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -535,7 +535,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|_| Box::new(utils::internal_lints::InvalidPaths));\n         store.register_late_pass(|_| Box::<utils::internal_lints::InterningDefinedSymbol>::default());\n         store.register_late_pass(|_| Box::<utils::internal_lints::LintWithoutLintPass>::default());\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::MatchTypeOnDiagItem));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::UnnecessaryDefPath));\n         store.register_late_pass(|_| Box::new(utils::internal_lints::OuterExpnDataPass));\n         store.register_late_pass(|_| Box::new(utils::internal_lints::MsrvAttrImpl));\n     }"}, {"sha": "3181bc86d179362e0ed6d075837ef569c7094478", "filename": "clippy_lints/src/manual_retain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_retain.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -92,7 +92,7 @@ fn check_into_iter(\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n         && let hir::ExprKind::MethodCall(_, struct_expr, [], _) = &into_iter_expr.kind\n         && let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id)\n-        && match_def_path(cx, into_iter_def_id, &paths::CORE_ITER_INTO_ITER)\n+        && cx.tcx.lang_items().require(hir::LangItem::IntoIterIntoIter).ok() == Some(into_iter_def_id)\n         && match_acceptable_type(cx, left_expr, msrv)\n         && SpanlessEq::new(cx).eq_expr(left_expr, struct_expr) {\n         suggest(cx, parent_expr, left_expr, target_expr);"}, {"sha": "3fef53739fbde876c7114f2967c7ffc7231b730b", "filename": "clippy_lints/src/methods/filetype_is_file.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -1,17 +1,18 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::ty::match_type;\n-use clippy_utils::{get_parent_expr, paths};\n+use clippy_utils::get_parent_expr;\n+use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n use super::FILETYPE_IS_FILE;\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     let ty = cx.typeck_results().expr_ty(recv);\n \n-    if !match_type(cx, ty, &paths::FILE_TYPE) {\n+    if !is_type_diagnostic_item(cx, ty, sym::FileType) {\n         return;\n     }\n "}, {"sha": "ede3b8bb74e97c7353dcef5154a167057bceb612", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -65,7 +65,7 @@ fn specializes_tostring(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     }\n \n     if let ty::Adt(adt, substs) = ty.kind() {\n-        match_def_path(cx, adt.did(), &paths::COW) && substs.type_at(1).is_str()\n+        cx.tcx.is_diagnostic_item(sym::Cow, adt.did()) && substs.type_at(1).is_str()\n     } else {\n         false\n     }"}, {"sha": "8b6b8f1bf16cbbfcf6952c4dac6fd684448d85e3", "filename": "clippy_lints/src/methods/manual_str_repeat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_path_diagnostic_item;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n-use clippy_utils::{is_expr_path_def_path, paths};\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n@@ -38,7 +38,7 @@ fn parse_repeat_arg(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<RepeatKind> {\n         let ty = cx.typeck_results().expr_ty(e);\n         if is_type_diagnostic_item(cx, ty, sym::String)\n             || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, Ty::is_str))\n-            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, Ty::is_str))\n+            || (is_type_diagnostic_item(cx, ty, sym::Cow) && get_ty_param(ty).map_or(false, Ty::is_str))\n         {\n             Some(RepeatKind::String)\n         } else {\n@@ -57,7 +57,7 @@ pub(super) fn check(\n ) {\n     if_chain! {\n         if let ExprKind::Call(repeat_fn, [repeat_arg]) = take_self_arg.kind;\n-        if is_expr_path_def_path(cx, repeat_fn, &paths::ITER_REPEAT);\n+        if is_path_diagnostic_item(cx, repeat_fn, sym::iter_repeat);\n         if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(collect_expr), sym::String);\n         if let Some(collect_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id);\n         if let Some(take_id) = cx.typeck_results().type_dependent_def_id(take_expr.hir_id);"}, {"sha": "c1139d84e2f47eb1138e475a859b320db610dff2", "filename": "clippy_lints/src/methods/useless_asref.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -1,19 +1,20 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::walk_ptrs_ty_depth;\n-use clippy_utils::{get_parent_expr, match_trait_method, paths};\n+use clippy_utils::{get_parent_expr, is_trait_method};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n+use rustc_span::sym;\n \n use super::USELESS_ASREF;\n \n /// Checks for the `USELESS_ASREF` lint.\n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, recvr: &hir::Expr<'_>) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n     // check if the call is to the actual `AsRef` or `AsMut` trait\n-    if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n+    if is_trait_method(cx, expr, sym::AsRef) || is_trait_method(cx, expr, sym::AsMut) {\n         // check if the type after `as_ref` or `as_mut` is the same as before\n         let rcv_ty = cx.typeck_results().expr_ty(recvr);\n         let res_ty = cx.typeck_results().expr_ty(expr);"}, {"sha": "4f967755bfa1975d5781547dd1eaa89569dd1bec", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{match_trait_method, paths};\n+use clippy_utils::is_trait_method;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -83,7 +83,7 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n             }\n         },\n         ExprKind::MethodCall(path, receiver, args @ [_], _) => {\n-            if cx.typeck_results().expr_ty(receiver).is_floating_point() || match_trait_method(cx, expr, &paths::ORD) {\n+            if cx.typeck_results().expr_ty(receiver).is_floating_point() || is_trait_method(cx, expr, sym::Ord) {\n                 if path.ident.name == sym!(max) {\n                     fetch_const(cx, Some(receiver), args, MinMax::Max)\n                 } else if path.ident.name == sym!(min) {"}, {"sha": "1a765b14892f6fccba6e1f6b4a2c0ca52435e6f2", "filename": "clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -1,12 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n-use clippy_utils::ty::match_type;\n+use clippy_utils::ty::{is_type_diagnostic_item, match_type};\n use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -49,7 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n                 if_chain! {\n                     if (path.ident.name == sym!(mode)\n                         && (match_type(cx, obj_ty, &paths::OPEN_OPTIONS)\n-                            || match_type(cx, obj_ty, &paths::DIR_BUILDER)))\n+                            || is_type_diagnostic_item(cx, obj_ty, sym::DirBuilder)))\n                         || (path.ident.name == sym!(set_mode) && match_type(cx, obj_ty, &paths::PERMISSIONS));\n                     if let ExprKind::Lit(_) = param.kind;\n "}, {"sha": "760399231513f8a4b15668e35fb606f1745f313e", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n-    get_enclosing_block, is_expr_path_def_path, is_integer_literal, path_to_local, path_to_local_id, paths, SpanlessEq,\n+    get_enclosing_block, is_integer_literal, is_path_diagnostic_item, path_to_local, path_to_local_id, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -254,7 +254,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn is_repeat_zero(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n             if let ExprKind::Call(fn_expr, [repeat_arg]) = expr.kind;\n-            if is_expr_path_def_path(self.cx, fn_expr, &paths::ITER_REPEAT);\n+            if is_path_diagnostic_item(self.cx, fn_expr, sym::iter_repeat);\n             if is_integer_literal(repeat_arg, 0);\n             then {\n                 true"}, {"sha": "016aacbf9da37c10de4e684b428429f4db34efa9", "filename": "clippy_lints/src/unnecessary_owned_empty_strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, LangItem, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryOwnedEmptyStrings {\n                         );\n                 } else {\n                     if_chain! {\n-                        if match_def_path(cx, fun_def_id, &paths::FROM_FROM);\n+                        if cx.tcx.lang_items().require(LangItem::FromFrom).ok() == Some(fun_def_id);\n                         if let [.., last_arg] = args;\n                         if let ExprKind::Lit(spanned) = &last_arg.kind;\n                         if let LitKind::Str(symbol, _) = spanned.node;"}, {"sha": "8bcdff66331d162c44d06971af7f9774f09698a3", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n-use clippy_utils::{is_try, match_trait_method, paths};\n+use clippy_utils::{is_trait_method, is_try, match_trait_method, paths};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -116,13 +117,13 @@ fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Exp\n             match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCREADEXT)\n                 || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCREADEXT)\n         } else {\n-            match_trait_method(cx, call, &paths::IO_READ)\n+            is_trait_method(cx, call, sym::IoRead)\n         };\n         let write_trait = if is_await {\n             match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCWRITEEXT)\n                 || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCWRITEEXT)\n         } else {\n-            match_trait_method(cx, call, &paths::IO_WRITE)\n+            is_trait_method(cx, call, sym::IoWrite)\n         };\n \n         match (read_trait, write_trait, symbol, is_await) {"}, {"sha": "a82643a59f97bb11bc1c17c5ba62157073a5c753", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n use clippy_utils::{get_parent_expr, is_trait_method, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, HirId, MatchSource};\n+use rustc_hir::{Expr, ExprKind, HirId, LangItem, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -154,7 +154,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         }\n \n                         if_chain! {\n-                            if match_def_path(cx, def_id, &paths::FROM_FROM);\n+                            if cx.tcx.lang_items().require(LangItem::FromFrom).ok() == Some(def_id);\n                             if same_type_and_consts(a, b);\n \n                             then {"}, {"sha": "6309a04c73d5de9d3230b78e772007716853c9f2", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 208, "deletions": 69, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -2,11 +2,11 @@ use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::macros::root_macro_call_first_node;\n-use clippy_utils::source::snippet;\n+use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n-    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path,\n-    method_calls, paths, peel_blocks_with_stmt, SpanlessEq,\n+    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_any_def_paths,\n+    match_def_path, method_calls, paths, peel_blocks_with_stmt, peel_hir_expr_refs, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast as ast;\n@@ -20,21 +20,24 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{\n-    BinOpKind, Block, Closure, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind, Ty,\n+    BinOpKind, Block, Closure, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind,\n     TyKind, UnOp,\n };\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::mir::interpret::ConstValue;\n-use rustc_middle::ty::{self, fast_reject::SimplifiedTypeGen, subst::GenericArgKind, FloatTy};\n+use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n+use rustc_middle::ty::{\n+    self, fast_reject::SimplifiedTypeGen, subst::GenericArgKind, AssocKind, DefIdTree, FloatTy, Ty,\n+};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{sym, BytePos, Span};\n \n use std::borrow::{Borrow, Cow};\n+use std::str;\n \n #[cfg(feature = \"internal\")]\n pub mod metadata_collector;\n@@ -226,11 +229,11 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for calls to `utils::match_type()` on a type diagnostic item\n-    /// and suggests to use `utils::is_type_diagnostic_item()` instead.\n+    /// Checks for usages of def paths when a diagnostic item or a `LangItem` could be used.\n     ///\n     /// ### Why is this bad?\n-    /// `utils::is_type_diagnostic_item()` does not require hardcoded paths.\n+    /// The path for an item is subject to change and is less efficient to look up than a\n+    /// diagnostic item or a `LangItem`.\n     ///\n     /// ### Example\n     /// ```rust,ignore\n@@ -241,9 +244,9 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// utils::is_type_diagnostic_item(cx, ty, sym::Vec)\n     /// ```\n-    pub MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+    pub UNNECESSARY_DEF_PATH,\n     internal,\n-    \"using `utils::match_type()` instead of `utils::is_type_diagnostic_item()`\"\n+    \"using a def path when a diagnostic item or a `LangItem` is available\"\n }\n \n declare_clippy_lint! {\n@@ -537,7 +540,7 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n     }\n }\n \n-fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &Ty<'_>) -> bool {\n+fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &hir::Ty<'_>) -> bool {\n     if let TyKind::Rptr(\n         _,\n         MutTy {\n@@ -888,89 +891,225 @@ fn suggest_note(\n     );\n }\n \n-declare_lint_pass!(MatchTypeOnDiagItem => [MATCH_TYPE_ON_DIAGNOSTIC_ITEM]);\n+declare_lint_pass!(UnnecessaryDefPath => [UNNECESSARY_DEF_PATH]);\n \n-impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n+#[allow(clippy::too_many_lines)]\n+impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if is_lint_allowed(cx, MATCH_TYPE_ON_DIAGNOSTIC_ITEM, expr.hir_id) {\n+        enum Item {\n+            LangItem(Symbol),\n+            DiagnosticItem(Symbol),\n+        }\n+        static PATHS: &[&[&str]] = &[\n+            &[\"clippy_utils\", \"match_def_path\"],\n+            &[\"clippy_utils\", \"match_trait_method\"],\n+            &[\"clippy_utils\", \"ty\", \"match_type\"],\n+            &[\"clippy_utils\", \"is_expr_path_def_path\"],\n+        ];\n+\n+        if is_lint_allowed(cx, UNNECESSARY_DEF_PATH, expr.hir_id) {\n             return;\n         }\n \n         if_chain! {\n-            // Check if this is a call to utils::match_type()\n-            if let ExprKind::Call(fn_path, [context, ty, ty_path]) = expr.kind;\n-            if is_expr_path_def_path(cx, fn_path, &[\"clippy_utils\", \"ty\", \"match_type\"]);\n+            if let ExprKind::Call(func, [cx_arg, def_arg, args@..]) = expr.kind;\n+            if let ExprKind::Path(path) = &func.kind;\n+            if let Some(id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n+            if let Some(which_path) = match_any_def_paths(cx, id, PATHS);\n+            let item_arg = if which_path == 4 { &args[1] } else { &args[0] };\n             // Extract the path to the matched type\n-            if let Some(segments) = path_to_matched_type(cx, ty_path);\n-            let segments: Vec<&str> = segments.iter().map(Symbol::as_str).collect();\n-            if let Some(ty_did) = def_path_res(cx, &segments[..]).opt_def_id();\n-            // Check if the matched type is a diagnostic item\n-            if let Some(item_name) = cx.tcx.get_diagnostic_name(ty_did);\n+            if let Some(segments) = path_to_matched_type(cx, item_arg);\n+            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n+            if let Some(def_id) = def_path_res(cx, &segments[..]).opt_def_id();\n             then {\n-                // TODO: check paths constants from external crates.\n-                let cx_snippet = snippet(cx, context.span, \"_\");\n-                let ty_snippet = snippet(cx, ty.span, \"_\");\n+                // def_path_res will match field names before anything else, but for this we want to match\n+                // inherent functions first.\n+                let def_id = if cx.tcx.def_kind(def_id) == DefKind::Field {\n+                    let method_name = *segments.last().unwrap();\n+                    cx.tcx.def_key(def_id).parent\n+                        .and_then(|parent_idx|\n+                            cx.tcx.inherent_impls(DefId { index: parent_idx, krate: def_id.krate }).iter()\n+                                .find_map(|impl_id| cx.tcx.associated_items(*impl_id)\n+                                    .find_by_name_and_kind(\n+                                        cx.tcx,\n+                                        Ident::from_str(method_name),\n+                                        AssocKind::Fn,\n+                                        *impl_id,\n+                                    )\n+                                )\n+                        )\n+                        .map_or(def_id, |item| item.def_id)\n+                } else {\n+                    def_id\n+                };\n \n-                span_lint_and_sugg(\n+                // Check if the target item is a diagnostic item or LangItem.\n+                let (msg, item) = if let Some(item_name)\n+                    = cx.tcx.diagnostic_items(def_id.krate).id_to_name.get(&def_id)\n+                {\n+                    (\n+                        \"use of a def path to a diagnostic item\",\n+                        Item::DiagnosticItem(*item_name),\n+                    )\n+                } else if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n+                    let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"]).def_id();\n+                    let item_name = cx.tcx.adt_def(lang_items).variants().iter().nth(lang_item).unwrap().name;\n+                    (\n+                        \"use of a def path to a `LangItem`\",\n+                        Item::LangItem(item_name),\n+                    )\n+                } else {\n+                    return;\n+                };\n+\n+                let has_ctor = match cx.tcx.def_kind(def_id) {\n+                    DefKind::Struct => {\n+                        let variant = cx.tcx.adt_def(def_id).non_enum_variant();\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    }\n+                    DefKind::Variant => {\n+                        let variant = cx.tcx.adt_def(cx.tcx.parent(def_id)).variant_with_id(def_id);\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    }\n+                    _ => false,\n+                };\n+\n+                let mut app = Applicability::MachineApplicable;\n+                let cx_snip = snippet_with_applicability(cx, cx_arg.span, \"..\", &mut app);\n+                let def_snip = snippet_with_applicability(cx, def_arg.span, \"..\", &mut app);\n+                let (sugg, with_note) = match (which_path, item) {\n+                    // match_def_path\n+                    (0, Item::DiagnosticItem(item)) =>\n+                        (format!(\"{cx_snip}.tcx.is_diagnostic_item(sym::{item}, {def_snip})\"), has_ctor),\n+                    (0, Item::LangItem(item)) => (\n+                        format!(\"{cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some({def_snip})\"),\n+                        has_ctor\n+                    ),\n+                    // match_trait_method\n+                    (1, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_trait_method({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    // match_type\n+                    (2, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_type_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    (2, Item::LangItem(item)) =>\n+                        (format!(\"is_type_lang_item({cx_snip}, {def_snip}, LangItem::{item})\"), false),\n+                    // is_expr_path_def_path\n+                    (3, Item::DiagnosticItem(item)) if has_ctor => (\n+                        format!(\n+                            \"is_res_diag_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), sym::{item})\",\n+                        ),\n+                        false,\n+                    ),\n+                    (3, Item::LangItem(item)) if has_ctor => (\n+                        format!(\n+                            \"is_res_lang_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), LangItem::{item})\",\n+                        ),\n+                        false,\n+                    ),\n+                    (3, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_path_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    (3, Item::LangItem(item)) => (\n+                        format!(\n+                            \"path_res({cx_snip}, {def_snip}).opt_def_id()\\\n+                                .map_or(false, |id| {cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some(id))\",\n+                        ),\n+                        false,\n+                    ),\n+                    _ => return,\n+                };\n+\n+                span_lint_and_then(\n                     cx,\n-                    MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+                    UNNECESSARY_DEF_PATH,\n                     expr.span,\n-                    \"usage of `clippy_utils::ty::match_type()` on a type diagnostic item\",\n-                    \"try\",\n-                    format!(\"clippy_utils::ty::is_type_diagnostic_item({cx_snippet}, {ty_snippet}, sym::{item_name})\"),\n-                    Applicability::MaybeIncorrect,\n+                    msg,\n+                    |diag| {\n+                        diag.span_suggestion(expr.span, \"try\", sugg, app);\n+                        if with_note {\n+                            diag.help(\n+                                \"if this `DefId` came from a constructor expression or pattern then the \\\n+                                    parent `DefId` should be used instead\"\n+                            );\n+                        }\n+                    },\n                 );\n             }\n         }\n     }\n }\n \n-fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<Symbol>> {\n-    use rustc_hir::ItemKind;\n-\n-    match &expr.kind {\n-        ExprKind::AddrOf(.., expr) => return path_to_matched_type(cx, expr),\n-        ExprKind::Path(qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n+fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<String>> {\n+    match peel_hir_expr_refs(expr).0.kind {\n+        ExprKind::Path(ref qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n             Res::Local(hir_id) => {\n                 let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n-                if let Some(Node::Local(local)) = cx.tcx.hir().find(parent_id) {\n-                    if let Some(init) = local.init {\n-                        return path_to_matched_type(cx, init);\n-                    }\n+                if let Some(Node::Local(Local { init: Some(init), .. })) = cx.tcx.hir().find(parent_id) {\n+                    path_to_matched_type(cx, init)\n+                } else {\n+                    None\n                 }\n             },\n-            Res::Def(DefKind::Const | DefKind::Static(..), def_id) => {\n-                if let Some(Node::Item(item)) = cx.tcx.hir().get_if_local(def_id) {\n-                    if let ItemKind::Const(.., body_id) | ItemKind::Static(.., body_id) = item.kind {\n-                        let body = cx.tcx.hir().body(body_id);\n-                        return path_to_matched_type(cx, body.value);\n-                    }\n-                }\n+            Res::Def(DefKind::Static(_), def_id) => read_mir_alloc_def_path(\n+                cx,\n+                cx.tcx.eval_static_initializer(def_id).ok()?.inner(),\n+                cx.tcx.type_of(def_id),\n+            ),\n+            Res::Def(DefKind::Const, def_id) => match cx.tcx.const_eval_poly(def_id).ok()? {\n+                ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => {\n+                    read_mir_alloc_def_path(cx, alloc.inner(), cx.tcx.type_of(def_id))\n+                },\n+                _ => None,\n             },\n-            _ => {},\n+            _ => None,\n         },\n-        ExprKind::Array(exprs) => {\n-            let segments: Vec<Symbol> = exprs\n-                .iter()\n-                .filter_map(|expr| {\n-                    if let ExprKind::Lit(lit) = &expr.kind {\n-                        if let LitKind::Str(sym, _) = lit.node {\n-                            return Some(sym);\n-                        }\n+        ExprKind::Array(exprs) => exprs\n+            .iter()\n+            .map(|expr| {\n+                if let ExprKind::Lit(lit) = &expr.kind {\n+                    if let LitKind::Str(sym, _) = lit.node {\n+                        return Some((*sym.as_str()).to_owned());\n                     }\n+                }\n \n-                    None\n-                })\n-                .collect();\n-\n-            if segments.len() == exprs.len() {\n-                return Some(segments);\n-            }\n-        },\n-        _ => {},\n+                None\n+            })\n+            .collect(),\n+        _ => None,\n     }\n+}\n \n-    None\n+fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation, ty: Ty<'_>) -> Option<Vec<String>> {\n+    let (alloc, ty) = if let ty::Ref(_, ty, Mutability::Not) = *ty.kind() {\n+        let &alloc = alloc.provenance().values().next()?;\n+        if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+            (alloc.inner(), ty)\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        (alloc, ty)\n+    };\n+\n+    if let ty::Array(ty, _) | ty::Slice(ty) = *ty.kind()\n+        && let ty::Ref(_, ty, Mutability::Not) = *ty.kind()\n+        && ty.is_str()\n+    {\n+        alloc\n+            .provenance()\n+            .values()\n+            .map(|&alloc| {\n+                if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+                    let alloc = alloc.inner();\n+                    str::from_utf8(alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()))\n+                        .ok().map(ToOwned::to_owned)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect()\n+    } else {\n+        None\n+    }\n }\n \n // This is not a complete resolver for paths. It works on all the paths currently used in the paths"}, {"sha": "8f67fa109fc70f27090a37e6a0960cc905c2f79c", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -261,6 +261,46 @@ pub fn is_res_diagnostic_ctor(cx: &LateContext<'_>, res: Res, diag_item: Symbol)\n     }\n }\n \n+/// Checks if a `QPath` resolves to a constructor of a diagnostic item.\n+pub fn is_diagnostic_ctor(cx: &LateContext<'_>, qpath: &QPath<'_>, diagnostic_item: Symbol) -> bool {\n+    if let QPath::Resolved(_, path) = qpath {\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = path.res {\n+            return cx.tcx.is_diagnostic_item(diagnostic_item, cx.tcx.parent(ctor_id));\n+        }\n+    }\n+    false\n+}\n+\n+/// Checks if the `DefId` matches the given diagnostic item or it's constructor.\n+pub fn is_diagnostic_item_or_ctor(cx: &LateContext<'_>, did: DefId, item: Symbol) -> bool {\n+    let did = match cx.tcx.def_kind(did) {\n+        DefKind::Ctor(..) => cx.tcx.parent(did),\n+        // Constructors for types in external crates seem to have `DefKind::Variant`\n+        DefKind::Variant => match cx.tcx.opt_parent(did) {\n+            Some(did) if matches!(cx.tcx.def_kind(did), DefKind::Variant) => did,\n+            _ => did,\n+        },\n+        _ => did,\n+    };\n+\n+    cx.tcx.is_diagnostic_item(item, did)\n+}\n+\n+/// Checks if the `DefId` matches the given `LangItem` or it's constructor.\n+pub fn is_lang_item_or_ctor(cx: &LateContext<'_>, did: DefId, item: LangItem) -> bool {\n+    let did = match cx.tcx.def_kind(did) {\n+        DefKind::Ctor(..) => cx.tcx.parent(did),\n+        // Constructors for types in external crates seem to have `DefKind::Variant`\n+        DefKind::Variant => match cx.tcx.opt_parent(did) {\n+            Some(did) if matches!(cx.tcx.def_kind(did), DefKind::Variant) => did,\n+            _ => did,\n+        },\n+        _ => did,\n+    };\n+\n+    cx.tcx.lang_items().require(item).map_or(false, |id| id == did)\n+}\n+\n pub fn is_unit_expr(expr: &Expr<'_>) -> bool {\n     matches!(\n         expr.kind,\n@@ -496,6 +536,13 @@ pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n                 .copied()\n                 .find(|assoc_def_id| tcx.item_name(*assoc_def_id).as_str() == name)\n                 .map(|assoc_def_id| Res::Def(tcx.def_kind(assoc_def_id), assoc_def_id)),\n+            DefKind::Struct | DefKind::Union => tcx\n+                .adt_def(def_id)\n+                .non_enum_variant()\n+                .fields\n+                .iter()\n+                .find(|f| f.name.as_str() == name)\n+                .map(|f| Res::Def(DefKind::Field, f.did)),\n             _ => None,\n         }\n     }"}, {"sha": "13938645fc3e500047b8dc5c0f384d823f0d8737", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -34,7 +34,6 @@ pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"defa\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n /// Preferably use the diagnostic item `sym::deref_method` where possible\n pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n-pub const DIR_BUILDER: [&str; 3] = [\"std\", \"fs\", \"DirBuilder\"];\n pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n #[cfg(feature = \"internal\")]\n pub const EARLY_CONTEXT: [&str; 2] = [\"rustc_lint\", \"EarlyContext\"];\n@@ -64,8 +63,6 @@ pub const IDENT_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Ident\", \"as_str\"];\n pub const INDEX: [&str; 3] = [\"core\", \"ops\", \"Index\"];\n pub const INDEX_MUT: [&str; 3] = [\"core\", \"ops\", \"IndexMut\"];\n pub const INSERT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"insert_str\"];\n-pub const IO_READ: [&str; 3] = [\"std\", \"io\", \"Read\"];\n-pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n pub const ITER_COUNT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"count\"];\n pub const ITER_EMPTY: [&str; 5] = [\"core\", \"iter\", \"sources\", \"empty\", \"Empty\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];"}, {"sha": "52fcaec4df32e2e92d3ffbaf5d756d1e5640f112", "filename": "tests/ui-internal/auxiliary/paths.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/tests%2Fui-internal%2Fauxiliary%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/tests%2Fui-internal%2Fauxiliary%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fauxiliary%2Fpaths.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -0,0 +1,2 @@\n+pub static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];"}, {"sha": "4b41ff15e80f904c907cb5ce02732c5eb34da2a1", "filename": "tests/ui-internal/match_type_on_diag_item.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,39 +0,0 @@\n-#![deny(clippy::internal)]\n-#![allow(clippy::missing_clippy_version_attribute)]\n-#![feature(rustc_private)]\n-\n-extern crate clippy_utils;\n-extern crate rustc_hir;\n-extern crate rustc_lint;\n-extern crate rustc_middle;\n-\n-#[macro_use]\n-extern crate rustc_session;\n-use clippy_utils::{paths, ty::match_type};\n-use rustc_hir::Expr;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::Ty;\n-\n-declare_lint! {\n-    pub TEST_LINT,\n-    Warn,\n-    \"\"\n-}\n-\n-declare_lint_pass!(Pass => [TEST_LINT]);\n-\n-static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n-\n-impl<'tcx> LateLintPass<'tcx> for Pass {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr) {\n-        let ty = cx.typeck_results().expr_ty(expr);\n-\n-        let _ = match_type(cx, ty, &OPTION);\n-        let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n-\n-        let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n-        let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "e3cb6b6c22eada7f40fb0edeb61261104385a7a0", "filename": "tests/ui-internal/match_type_on_diag_item.stderr", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,27 +0,0 @@\n-error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:31:17\n-   |\n-LL |         let _ = match_type(cx, ty, &OPTION);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::Option)`\n-   |\n-note: the lint level is defined here\n-  --> $DIR/match_type_on_diag_item.rs:1:9\n-   |\n-LL | #![deny(clippy::internal)]\n-   |         ^^^^^^^^^^^^^^^^\n-   = note: `#[deny(clippy::match_type_on_diagnostic_item)]` implied by `#[deny(clippy::internal)]`\n-\n-error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:32:17\n-   |\n-LL |         let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::Result)`\n-\n-error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:35:17\n-   |\n-LL |         let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::Rc)`\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "4c050332f2cc938ce497ecb9c55b3738b0d186c1", "filename": "tests/ui-internal/unnecessary_def_path.fixed", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/tests%2Fui-internal%2Funnecessary_def_path.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/tests%2Fui-internal%2Funnecessary_def_path.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.fixed?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -0,0 +1,62 @@\n+// run-rustfix\n+// aux-build:paths.rs\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate clippy_utils;\n+extern crate paths;\n+extern crate rustc_hir;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+extern crate rustc_span;\n+\n+#[allow(unused)]\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n+#[allow(unused)]\n+use clippy_utils::{\n+    is_expr_path_def_path, is_path_diagnostic_item, is_res_diagnostic_ctor, is_res_lang_ctor, is_trait_method,\n+    match_def_path, match_trait_method, path_res,\n+};\n+\n+#[allow(unused)]\n+use rustc_hir::LangItem;\n+#[allow(unused)]\n+use rustc_span::sym;\n+\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+\n+#[allow(unused)]\n+static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+#[allow(unused)]\n+const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];\n+\n+fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Option);\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n+\n+    #[allow(unused)]\n+    let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Rc);\n+\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Option);\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n+\n+    let _ = is_type_lang_item(cx, ty, LangItem::OwnedBox);\n+    let _ = is_type_diagnostic_item(cx, ty, sym::maybe_uninit_uninit);\n+\n+    let _ = cx.tcx.lang_items().require(LangItem::OwnedBox).ok() == Some(did);\n+    let _ = cx.tcx.is_diagnostic_item(sym::Option, did);\n+    let _ = cx.tcx.lang_items().require(LangItem::OptionSome).ok() == Some(did);\n+\n+    let _ = is_trait_method(cx, expr, sym::AsRef);\n+\n+    let _ = is_path_diagnostic_item(cx, expr, sym::Option);\n+    let _ = path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().require(LangItem::IteratorNext).ok() == Some(id));\n+    let _ = is_res_lang_ctor(cx, path_res(cx, expr), LangItem::OptionSome);\n+}\n+\n+fn main() {}"}, {"sha": "6506f1f164ac6b47d82f66485284af19042292b9", "filename": "tests/ui-internal/unnecessary_def_path.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/tests%2Fui-internal%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/tests%2Fui-internal%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.rs?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -0,0 +1,62 @@\n+// run-rustfix\n+// aux-build:paths.rs\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate clippy_utils;\n+extern crate paths;\n+extern crate rustc_hir;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+extern crate rustc_span;\n+\n+#[allow(unused)]\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n+#[allow(unused)]\n+use clippy_utils::{\n+    is_expr_path_def_path, is_path_diagnostic_item, is_res_diagnostic_ctor, is_res_lang_ctor, is_trait_method,\n+    match_def_path, match_trait_method, path_res,\n+};\n+\n+#[allow(unused)]\n+use rustc_hir::LangItem;\n+#[allow(unused)]\n+use rustc_span::sym;\n+\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+\n+#[allow(unused)]\n+static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+#[allow(unused)]\n+const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];\n+\n+fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n+    let _ = match_type(cx, ty, &OPTION);\n+    let _ = match_type(cx, ty, RESULT);\n+    let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n+\n+    #[allow(unused)]\n+    let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n+    let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n+\n+    let _ = match_type(cx, ty, &paths::OPTION);\n+    let _ = match_type(cx, ty, paths::RESULT);\n+\n+    let _ = match_type(cx, ty, &[\"alloc\", \"boxed\", \"Box\"]);\n+    let _ = match_type(cx, ty, &[\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\", \"uninit\"]);\n+\n+    let _ = match_def_path(cx, did, &[\"alloc\", \"boxed\", \"Box\"]);\n+    let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\"]);\n+    let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\", \"Some\"]);\n+\n+    let _ = match_trait_method(cx, expr, &[\"core\", \"convert\", \"AsRef\"]);\n+\n+    let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"option\", \"Option\"]);\n+    let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"iter\", \"traits\", \"Iterator\", \"next\"]);\n+    let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"option\", \"Option\", \"Some\"]);\n+}\n+\n+fn main() {}"}, {"sha": "a99a8f71fa6a73aac3b1713ec2f7cb2ea1dcb9cb", "filename": "tests/ui-internal/unnecessary_def_path.stderr", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/tests%2Fui-internal%2Funnecessary_def_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/162aa19793f21c99cf7ec2a8c080ee2f8843f7db/tests%2Fui-internal%2Funnecessary_def_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.stderr?ref=162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "patch": "@@ -0,0 +1,101 @@\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:37:13\n+   |\n+LL |     let _ = match_type(cx, ty, &OPTION);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Option)`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unnecessary_def_path.rs:3:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::unnecessary_def_path)]` implied by `#[deny(clippy::internal)]`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:38:13\n+   |\n+LL |     let _ = match_type(cx, ty, RESULT);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Result)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:39:13\n+   |\n+LL |     let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Result)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:43:13\n+   |\n+LL |     let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Rc)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:45:13\n+   |\n+LL |     let _ = match_type(cx, ty, &paths::OPTION);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Option)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:46:13\n+   |\n+LL |     let _ = match_type(cx, ty, paths::RESULT);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Result)`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:48:13\n+   |\n+LL |     let _ = match_type(cx, ty, &[\"alloc\", \"boxed\", \"Box\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_lang_item(cx, ty, LangItem::OwnedBox)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:49:13\n+   |\n+LL |     let _ = match_type(cx, ty, &[\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\", \"uninit\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::maybe_uninit_uninit)`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:51:13\n+   |\n+LL |     let _ = match_def_path(cx, did, &[\"alloc\", \"boxed\", \"Box\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().require(LangItem::OwnedBox).ok() == Some(did)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:52:13\n+   |\n+LL |     let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.is_diagnostic_item(sym::Option, did)`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:53:13\n+   |\n+LL |     let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\", \"Some\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().require(LangItem::OptionSome).ok() == Some(did)`\n+   |\n+   = help: if this `DefId` came from a constructor expression or pattern then the parent `DefId` should be used instead\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:55:13\n+   |\n+LL |     let _ = match_trait_method(cx, expr, &[\"core\", \"convert\", \"AsRef\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_trait_method(cx, expr, sym::AsRef)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:57:13\n+   |\n+LL |     let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"option\", \"Option\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_path_diagnostic_item(cx, expr, sym::Option)`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:58:13\n+   |\n+LL |     let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"iter\", \"traits\", \"Iterator\", \"next\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().require(LangItem::IteratorNext).ok() == Some(id))`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:59:13\n+   |\n+LL |     let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"option\", \"Option\", \"Some\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_res_lang_ctor(cx, path_res(cx, expr), LangItem::OptionSome)`\n+\n+error: aborting due to 15 previous errors\n+"}]}