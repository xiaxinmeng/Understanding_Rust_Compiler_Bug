{"sha": "d130acc0d0e83bd0b4b94cda9d39dcbb67312526", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMzBhY2MwZDBlODNiZDBiNGI5NGNkYTlkMzlkY2JiNjczMTI1MjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-04T06:51:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-04T06:51:41Z"}, "message": "auto merge of #14635 : BurntSushi/rust/regex-doco-touchups, r=alexcrichton", "tree": {"sha": "2885cad62662cd406c312610fed09f4e006fead4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2885cad62662cd406c312610fed09f4e006fead4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d130acc0d0e83bd0b4b94cda9d39dcbb67312526", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d130acc0d0e83bd0b4b94cda9d39dcbb67312526", "html_url": "https://github.com/rust-lang/rust/commit/d130acc0d0e83bd0b4b94cda9d39dcbb67312526", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d130acc0d0e83bd0b4b94cda9d39dcbb67312526/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a6dc40a102cecdf73ddc9757afe7233e678cfeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a6dc40a102cecdf73ddc9757afe7233e678cfeb", "html_url": "https://github.com/rust-lang/rust/commit/5a6dc40a102cecdf73ddc9757afe7233e678cfeb"}, {"sha": "179fc6dbfd97eb59e92df84e80fa9354ce5eeea0", "url": "https://api.github.com/repos/rust-lang/rust/commits/179fc6dbfd97eb59e92df84e80fa9354ce5eeea0", "html_url": "https://github.com/rust-lang/rust/commit/179fc6dbfd97eb59e92df84e80fa9354ce5eeea0"}], "stats": {"total": 43, "additions": 24, "deletions": 19}, "files": [{"sha": "4b9d76a9e5de97c23e4676c65d00455711f61823", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d130acc0d0e83bd0b4b94cda9d39dcbb67312526/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d130acc0d0e83bd0b4b94cda9d39dcbb67312526/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=d130acc0d0e83bd0b4b94cda9d39dcbb67312526", "patch": "@@ -155,15 +155,16 @@\n //! # Unicode\n //!\n //! This implementation executes regular expressions **only** on sequences of\n-//! UTF8 codepoints while exposing match locations as byte indices.\n+//! Unicode code points while exposing match locations as byte indices into the\n+//! search string.\n //!\n //! Currently, only naive case folding is supported. Namely, when matching\n //! case insensitively, the characters are first converted to their uppercase\n //! forms and then compared.\n //!\n //! Regular expressions themselves are also **only** interpreted as a sequence\n-//! of UTF8 codepoints. This means you can embed Unicode characters directly\n-//! into your expression:\n+//! of Unicode code points. This means you can use Unicode characters\n+//! directly in your expression:\n //!\n //! ```rust\n //! # #![feature(phase)]\n@@ -229,10 +230,10 @@\n //! x*?       zero or more of x (ungreedy)\n //! x+?       one or more of x (ungreedy)\n //! x??       zero or one of x (ungreedy)\n-//! x{n,m}    at least n and at most x (greedy)\n+//! x{n,m}    at least n x and at most m x (greedy)\n //! x{n,}     at least n x (greedy)\n //! x{n}      exactly n x\n-//! x{n,m}?   at least n and at most x (ungreedy)\n+//! x{n,m}?   at least n x and at most m x (ungreedy)\n //! x{n,}?    at least n x (ungreedy)\n //! x{n}?     exactly n x\n //! </pre>\n@@ -300,7 +301,7 @@\n //! \\v         vertical tab (\\x0B)\n //! \\123       octal character code (up to three digits)\n //! \\x7F       hex character code (exactly two digits)\n-//! \\x{10FFFF} any hex character code corresponding to a valid UTF8 codepoint\n+//! \\x{10FFFF} any hex character code corresponding to a Unicode code point\n //! </pre>\n //!\n //! ## Perl character classes (Unicode friendly)\n@@ -390,7 +391,7 @@ mod vm;\n #[cfg(test, not(windows))]\n mod test;\n \n-/// The `program` module exists to support the `regex!` macro. Do not use.\n+/// The `native` module exists to support the `regex!` macro. Do not use.\n #[doc(hidden)]\n pub mod native {\n     // Exporting this stuff is bad form, but it's necessary for two reasons."}, {"sha": "3f62f16e0b12d654dd0788abcd9fd46b1fcd14af", "filename": "src/libregex/re.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d130acc0d0e83bd0b4b94cda9d39dcbb67312526/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d130acc0d0e83bd0b4b94cda9d39dcbb67312526/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=d130acc0d0e83bd0b4b94cda9d39dcbb67312526", "patch": "@@ -18,8 +18,10 @@ use parse;\n use vm;\n use vm::{CaptureLocs, MatchKind, Exists, Location, Submatches};\n \n-/// Escapes all regular expression meta characters in `text` so that it may be\n-/// safely used in a regular expression as a literal string.\n+/// Escapes all regular expression meta characters in `text`.\n+///\n+/// The string returned may be safely used as a literal in a regular\n+/// expression.\n pub fn quote(text: &str) -> String {\n     let mut quoted = String::with_capacity(text.len());\n     for c in text.chars() {\n@@ -45,17 +47,18 @@ pub fn is_match(regex: &str, text: &str) -> Result<bool, parse::Error> {\n     Regex::new(regex).map(|r| r.is_match(text))\n }\n \n-/// Regex is a compiled regular expression, represented as either a sequence\n-/// of bytecode instructions (dynamic) or as a specialized Rust function\n-/// (native). It can be used to search, split\n+/// A compiled regular expression\n+///\n+/// It is represented as either a sequence of bytecode instructions (dynamic)\n+/// or as a specialized Rust function (native). It can be used to search, split\n /// or replace text. All searching is done with an implicit `.*?` at the\n /// beginning and end of an expression. To force an expression to match the\n /// whole string (or a prefix or a suffix), you must use an anchor like `^` or\n /// `$` (or `\\A` and `\\z`).\n ///\n /// While this crate will handle Unicode strings (whether in the regular\n /// expression or in the search text), all positions returned are **byte\n-/// indices**. Every byte index is guaranteed to be at a UTF8 codepoint\n+/// indices**. Every byte index is guaranteed to be at a Unicode code point\n /// boundary.\n ///\n /// The lifetimes `'r` and `'t` in this crate correspond to the lifetime of a\n@@ -189,7 +192,7 @@ impl Regex {\n     ///\n     /// # Example\n     ///\n-    /// Find the start and end location of every word with exactly 13\n+    /// Find the start and end location of the first word with exactly 13\n     /// characters:\n     ///\n     /// ```rust\n@@ -216,7 +219,7 @@ impl Regex {\n     ///\n     /// # Example\n     ///\n-    /// Find the start and end location of the first word with exactly 13\n+    /// Find the start and end location of every word with exactly 13\n     /// characters:\n     ///\n     /// ```rust\n@@ -577,8 +580,8 @@ impl<'t> Replacer for &'t str {\n     }\n }\n \n-impl<'a> Replacer for |&Captures|: 'a -> String {\n-    fn reg_replace<'r>(&'r mut self, caps: &Captures) -> MaybeOwned<'r> {\n+impl<'t> Replacer for |&Captures|: 't -> String {\n+    fn reg_replace<'a>(&'a mut self, caps: &Captures) -> MaybeOwned<'a> {\n         Owned((*self)(caps))\n     }\n }\n@@ -823,8 +826,9 @@ impl<'t> Iterator<Option<(uint, uint)>> for SubCapturesPos<'t> {\n }\n \n /// An iterator that yields all non-overlapping capture groups matching a\n-/// particular regular expression. The iterator stops when no more matches can\n-/// be found.\n+/// particular regular expression.\n+///\n+/// The iterator stops when no more matches can be found.\n ///\n /// `'r` is the lifetime of the compiled expression and `'t` is the lifetime\n /// of the matched string."}]}