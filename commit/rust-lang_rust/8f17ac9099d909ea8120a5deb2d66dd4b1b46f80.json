{"sha": "8f17ac9099d909ea8120a5deb2d66dd4b1b46f80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMTdhYzkwOTlkOTA5ZWE4MTIwYTVkZWIyZDY2ZGQ0YjFiNDZmODA=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-08-23T20:11:44Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-08-27T02:15:11Z"}, "message": "Rewrote module tutorial", "tree": {"sha": "e5a2a803c2b5f70d7764dfa3b91bbf926f1dcbf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5a2a803c2b5f70d7764dfa3b91bbf926f1dcbf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f17ac9099d909ea8120a5deb2d66dd4b1b46f80", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f17ac9099d909ea8120a5deb2d66dd4b1b46f80", "html_url": "https://github.com/rust-lang/rust/commit/8f17ac9099d909ea8120a5deb2d66dd4b1b46f80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f17ac9099d909ea8120a5deb2d66dd4b1b46f80/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e311a1ee02af4309394f0b3195c4b6abfcf770a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e311a1ee02af4309394f0b3195c4b6abfcf770a2", "html_url": "https://github.com/rust-lang/rust/commit/e311a1ee02af4309394f0b3195c4b6abfcf770a2"}], "stats": {"total": 727, "additions": 576, "deletions": 151}, "files": [{"sha": "051de260a098c0d6b38b71fc5ad315ed39cb4519", "filename": "doc/tutorial.md", "status": "modified", "additions": 576, "deletions": 151, "changes": 727, "blob_url": "https://github.com/rust-lang/rust/blob/8f17ac9099d909ea8120a5deb2d66dd4b1b46f80/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/8f17ac9099d909ea8120a5deb2d66dd4b1b46f80/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=8f17ac9099d909ea8120a5deb2d66dd4b1b46f80", "patch": "@@ -2251,237 +2251,665 @@ The full list of derivable traits is `Eq`, `TotalEq`, `Ord`,\n `TotalOrd`, `Encodable` `Decodable`, `Clone`, `DeepClone`,\n `IterBytes`, `Rand`, `Zero`, and `ToStr`.\n \n-# Modules and crates\n+# Crates and the module system\n \n-The Rust namespace is arranged in a hierarchy of modules. Each source\n-(.rs) file represents a single module and may in turn contain\n-additional modules.\n+Rust's module system is very powerful, but because of that also somewhat complex.\n+Nevertheless, this section will try to explain every important aspect of it.\n+\n+## Crates\n+\n+In order to speak about the module system, we first need to define the medium it exists in:\n+\n+Let's say you've written a program or a library, compiled it, and got the resulting binary.\n+In Rust, the content of all source code that the compiler directly had to compile in order to end up with\n+that binary is collectively called a 'crate'.\n+\n+For example, for a simple hello world program your crate only consists of this code:\n+\n+~~~~\n+// main.rs\n+fn main() {\n+    println(\"Hello world!\");\n+}\n+~~~~\n+\n+A crate is also the unit of independent compilation in Rust: `rustc` always compiles a single crate at a time,\n+from which it produces either a library or an executable.\n+\n+Note that merely using an already compiled library in your code does not make it part of your crate.\n+\n+## The module hierarchy\n+\n+For every crate, all the code in it is arranged in a hierarchy of modules starting with a single\n+root module. That root module is called the 'crate root'.\n+\n+All modules in a crate below the crate root are declared with the `mod` keyword:\n \n ~~~~\n+// This is the crate root\n+\n mod farm {\n-    pub fn chicken() -> &str { \"cluck cluck\" }\n-    pub fn cow() -> &str { \"mooo\" }\n+    // This is the body of module 'farm' declared in the crate root.\n+\n+    fn chicken() { println(\"cluck cluck\"); }\n+    fn cow() { println(\"mooo\"); }\n+\n+    mod barn {\n+        // Body of module 'barn'\n+\n+        fn hay() { println(\"...\"); }\n+    }\n }\n \n fn main() {\n-    println(farm::chicken());\n+    println(\"Hello farm!\");\n }\n ~~~~\n \n-The contents of modules can be imported into the current scope\n-with the `use` keyword, optionally giving it an alias. `use`\n-may appear at the beginning of crates, `mod`s, `fn`s, and other\n-blocks.\n+As you can see, your module hierarchy is now three modules deep: There is the crate root, which contains your `main()`\n+function, and the module `farm`. The module `farm` also contains two functions and a third module `barn`,\n+which contains a function `hay`.\n \n-~~~\n-# mod farm { pub fn chicken() { } }\n-# fn main() {\n-// Bring `chicken` into scope\n-use farm::chicken;\n+(In case you already stumbled over `extern mod`: It isn't directly related to a bare `mod`, we'll get to it later. )\n+\n+## Paths and visibility\n \n-fn chicken_farmer() {\n-    // The same, but name it `my_chicken`\n-    use my_chicken = farm::chicken;\n-    ...\n-# my_chicken();\n+We've now defined a nice module hierarchy. But how do we access the items in it from our `main` function?\n+One way to do it is to simply fully qualifying it:\n+\n+~~~~ {.xfail-test}\n+mod farm {\n+    fn chicken() { println(\"cluck cluck\"); }\n+    // ...\n }\n-# chicken();\n-# }\n-~~~\n \n-These farm animal functions have a new keyword, `pub`, attached to\n-them. The `pub` keyword modifies an item's visibility, making it\n-visible outside its containing module. An expression with `::`, like\n-`farm::chicken`, can name an item outside of its containing\n-module. Items, such as those declared with `fn`, `struct`, `enum`,\n-`type`, or `static`, are module-private by default.\n+fn main() {\n+    println(\"Hello chicken!\");\n+\n+    ::farm::chicken(); // Won't compile yet, see further down\n+}\n+~~~~\n+\n+The `::farm::chicken` construct is what we call a 'path'.\n+\n+Because it's starting with a `::`, it's also a 'global path',\n+which qualifies an item by its full path in the module hierarchy\n+relative to the crate root.\n+\n+If the path were to start with a regular identifier, like `farm::chicken`, it would be\n+a 'local path' instead. We'll get to them later.\n+\n+Now, if you actually tried to compile this code example, you'll notice\n+that you get a `unresolved name: 'farm::chicken'` error. That's because per default,\n+items (`fn`, `struct`, `static`, `mod`, ...) are only visible inside the module\n+they are defined in.\n+\n+To make them visible outside their containing modules, you need to mark them _public_ with `pub`:\n+\n+~~~~\n+mod farm {\n+    pub fn chicken() { println(\"cluck cluck\"); }\n+    pub fn cow() { println(\"mooo\"); }\n+    // ...\n+}\n+\n+fn main() {\n+    println(\"Hello chicken!\");\n+    ::farm::chicken(); // This compiles now\n+}\n+~~~~\n \n Visibility restrictions in Rust exist only at module boundaries. This\n is quite different from most object-oriented languages that also\n enforce restrictions on objects themselves. That's not to say that\n Rust doesn't support encapsulation: both struct fields and methods can\n be private. But this encapsulation is at the module level, not the\n-struct level. Note that fields and methods are _public_ by default.\n+struct level.\n+\n+For convenience, fields are _public_ by default, and can be made _private_ with the `priv` keyword:\n \n ~~~\n-pub mod farm {\n+mod farm {\n # pub type Chicken = int;\n-# type Cow = int;\n # struct Human(int);\n # impl Human { fn rest(&self) { } }\n-# pub fn make_me_a_farm() -> Farm { Farm { chickens: ~[], cows: ~[], farmer: Human(0) } }\n+# pub fn make_me_a_farm() -> Farm { Farm { chickens: ~[], farmer: Human(0) } }\n     pub struct Farm {\n         priv chickens: ~[Chicken],\n-        priv cows: ~[Cow],\n         farmer: Human\n     }\n \n     impl Farm {\n         fn feed_chickens(&self) { ... }\n-        fn feed_cows(&self) { ... }\n         pub fn add_chicken(&self, c: Chicken) { ... }\n     }\n \n     pub fn feed_animals(farm: &Farm) {\n         farm.feed_chickens();\n-        farm.feed_cows();\n     }\n }\n \n fn main() {\n-     let f = make_me_a_farm();\n-     f.add_chicken(make_me_a_chicken());\n-     farm::feed_animals(&f);\n-     f.farmer.rest();\n+    let f = make_me_a_farm();\n+    f.add_chicken(make_me_a_chicken());\n+    farm::feed_animals(&f);\n+    f.farmer.rest();\n+\n+    // This wouldn't compile because both are private:\n+    // f.feed_chickens();\n+    // let chicken_counter = f.chickens.len();\n }\n # fn make_me_a_farm() -> farm::Farm { farm::make_me_a_farm() }\n # fn make_me_a_chicken() -> farm::Chicken { 0 }\n ~~~\n \n-## Crates\n+> ***Note:*** Visibility rules are currently buggy and not fully defined, you might have to add or remove `pub` along a path until it works.\n \n-The unit of independent compilation in Rust is the crate: rustc\n-compiles a single crate at a time, from which it produces either a\n-library or an executable.\n-\n-When compiling a single `.rs` source file, the file acts as the whole crate.\n-You can compile it with the `--lib` compiler switch to create a shared\n-library, or without, provided that your file contains a `fn main`\n-somewhere, to create an executable.\n-\n-Larger crates typically span multiple files and are, by convention,\n-compiled from a source file with the `.rc` extension, called a *crate file*.\n-The crate file extension distinguishes source files that represent\n-crates from those that do not, but otherwise source files and crate files are identical.\n-\n-A typical crate file declares attributes associated with the crate that\n-may affect how the compiler processes the source.\n-Crate attributes specify metadata used for locating and linking crates,\n-the type of crate (library or executable),\n-and control warning and error behavior,\n-among other things.\n-Crate files additionally declare the external crates they depend on\n-as well as any modules loaded from other files.\n-\n-~~~~ { .xfail-test }\n-// Crate linkage metadata\n-#[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n+## Files and modules\n \n-// Make a library (\"bin\" is the default)\n-#[crate_type = \"lib\"];\n+One important aspect about Rusts module system is that source files are not important:\n+You define a module hierarchy, populate it with all your definitions, define visibility,\n+maybe put in a `fn main()`, and that's it: No need to think about source files.\n \n-// Turn on a warning\n-#[warn(non_camel_case_types)]\n+The only file that's relevant is the one that contains the body of your crate root,\n+and it's only relevant because you have to pass that file to `rustc` to compile your crate.\n \n-// Link to the standard library\n-extern mod std;\n+And in principle, that's all you need: You can write any Rust program as one giant source file that contains your\n+crate root and everything below it in `mod ... { ... }` declarations.\n+\n+However, in practice you usually want to split you code up into multiple source files to make it more manageable.\n+In order to do that, Rust allows you to move the body of any module into it's own source file, which works like this:\n \n-// Load some modules from other files\n-mod cow;\n-mod chicken;\n-mod horse;\n+If you declare a module without its body, like `mod foo;`, the compiler will look for the\n+files `foo.rs` and `foo/mod.rs`. If it finds either, it uses the content of that file as the body of the module.\n+If it finds both, that's a compile error.\n+\n+So, if we want to move the content of `mod farm` into it's own file, it would look like this:\n+\n+~~~~ {.ignore}\n+// main.rs - contains body of the crate root\n+mod farm; // Compiler will look for 'farm.rs' and 'farm/mod.rs'\n \n fn main() {\n-    ...\n+    println(\"Hello farm!\");\n+    ::farm::cow();\n }\n ~~~~\n \n-Compiling this file will cause `rustc` to look for files named\n-`cow.rs`, `chicken.rs`, and `horse.rs` in the same directory as the\n-`.rc` file, compile them all together, and, based on the presence of\n-the `crate_type = \"lib\"` attribute, output a shared library or an\n-executable. (If the line `#[crate_type = \"lib\"];` was omitted,\n-`rustc` would create an executable.)\n+~~~~\n+// farm.rs - contains body of module 'farm' in the crate root\n+pub fn chicken() { println(\"cluck cluck\"); }\n+pub fn cow() { println(\"mooo\"); }\n \n-The `#[link(...)]` attribute provides meta information about the\n-module, which other crates can use to load the right module. More\n-about that later.\n+pub mod barn {\n+    pub fn hay() { println(\"...\"); }\n+}\n+# fn main() { }\n+~~~~\n \n-To have a nested directory structure for your source files, you can\n-nest mods:\n+So, in short `mod foo;` is just syntactic sugar for `mod foo { /* include content of foo.rs or foo/mod.rs here */ }`.\n \n-~~~~ {.ignore}\n-mod poultry {\n-    mod chicken;\n-    mod turkey;\n+This also means that having two or more identical `mod foo;` somewhere\n+in your crate hierarchy is generally a bad idea,\n+just like copy-and-paste-ing a module into two or more places is one.\n+Both will result in duplicate and mutually incompatible definitions.\n+\n+The directory the compiler looks in for those two files is determined by starting with\n+the same directory as the source file that contains the `mod foo;` declaration, and concatenating to that a\n+path equivalent to the relative path of all nested `mod { ... }` declarations the `mod foo;` is contained in, if any.\n+\n+For example, given a file with this module body:\n+\n+~~~ {.ignore}\n+// src/main.rs\n+mod plants;\n+mod fungi;\n+mod animals {\n+    mod fish;\n+    mod mammals {\n+        mod humans;\n+    }\n+}\n+~~~\n+\n+The compiler would then try all these files:\n+\n+~~~ {.notrust}\n+src/plants.rs\n+src/plants/mod.rs\n+\n+src/fungi.rs\n+src/fungi/mod.rs\n+\n+src/animals/fish.rs\n+src/animals/fish/mod.rs\n+\n+src/animals/mammals/humans.rs\n+src/animals/mammals/humans/mod.rs\n+~~~\n+\n+These rules per default result in any directory structure mirroring\n+the crates's module hierarchy, and allow you to have both small modules that only need\n+to consist of one source file, and big modules that group the source files of submodules together.\n+\n+If you need to circumvent those defaults, you can also overwrite the path a `mod foo;` would take:\n+\n+~~~ {.ignore}\n+#[path=\"../../area51/classified.rs\"]\n+mod alien;\n+~~~\n+\n+## Importing names into the local scope\n+\n+Always referring to definitions in other modules with their global\n+path gets old really fast, so Rust has a way to import\n+them into the local scope of your module: `use`-statements.\n+\n+They work like this: At the beginning of any module body, `fn` body, or any other block\n+you can write a list of `use`-statements, consisting of the keyword `use` and a __global path__ to an item\n+without the `::` prefix. For example, this imports `cow` into the local scope:\n+\n+~~~\n+use farm::cow;\n+# mod farm { pub fn cow() { println(\"I'm a hidden ninja cow!\") } }\n+# fn main() { cow() }\n+~~~\n+\n+The path you give to `use` is per default global, meaning relative to the crate root,\n+no matter how deep the module hierarchy is, or whether the module body it's written in\n+is contained in its own file (remember: files are irrelevant).\n+\n+This is different to other languages, where you often only find a single import construct that combines the semantic\n+of `mod foo;` and `use`-statements, and which tend to work relative to the source file or use an absolute file path\n+- Rubys `require` or C/C++'s `#include` come to mind.\n+\n+However, it's also possible to import things relative to the module of the `use`-statement:\n+Adding a `super::` in front of the path will start in the parent module,\n+while adding a `self::` prefix will start in the current module:\n+\n+~~~\n+# mod workaround {\n+# pub fn some_parent_item(){ println(\"...\") }\n+# mod foo {\n+use super::some_parent_item;\n+use self::some_child_module::some_item;\n+# pub fn bar() { some_parent_item(); some_item() }\n+# pub mod some_child_module { pub fn some_item() {} }\n+# }\n+# }\n+~~~\n+\n+Again - relative to the module, not to the file.\n+\n+Imports are also shadowed by local definitions:\n+For each name you mention in a module/block, `rust`\n+will first look at all items that are defined locally,\n+and only if that results in no match look at items you brought in\n+scope with corresponding `use` statements.\n+\n+~~~ {.ignore}\n+# // XXX: Allow unused import in doc test\n+use farm::cow;\n+// ...\n+# mod farm { pub fn cow() { println(\"Hidden ninja cow is hidden.\") } }\n+fn cow() { println(\"Mooo!\") }\n+\n+fn main() {\n+    cow() // resolves to the locally defined cow() function\n }\n+~~~\n+\n+To make this behavior more obvious, the rule has been made that `use`-statement always need to be written\n+before any declaration, like in the example above. This is a purely artificial rule introduced\n+because people always assumed they shadowed each other based on order, despite the fact that all items in rust are\n+mutually recursive, order independent definitions.\n+\n+One odd consequence of that rule is that `use` statements also go in front of any `mod` declaration,\n+even if they refer to things inside them:\n+\n+~~~\n+use farm::cow;\n+mod farm {\n+    pub fn cow() { println(\"Moooooo?\") }\n+}\n+\n+fn main() { cow() }\n+~~~\n+\n+This is what our `farm` example looks like with `use` statements:\n+\n ~~~~\n+use farm::chicken;\n+use farm::cow;\n+use farm::barn;\n \n-The compiler will now look for `poultry/chicken.rs` and\n-`poultry/turkey.rs`, and export their content in `poultry::chicken`\n-and `poultry::turkey`. You can also provide a `poultry.rs` to add\n-content to the `poultry` module itself.\n+mod farm {\n+    pub fn chicken() { println(\"cluck cluck\"); }\n+    pub fn cow() { println(\"mooo\"); }\n \n-## Using other crates\n+    pub mod barn {\n+        pub fn hay() { println(\"...\"); }\n+    }\n+}\n \n-The `extern mod` directive lets you use a crate (once it's been\n-compiled into a library) from inside another crate. `extern mod` can\n-appear at the top of a crate file or at the top of modules. It will\n-cause the compiler to look in the library search path (which you can\n-extend with the `-L` switch) for a compiled Rust library with the\n-right name, then add a module with that crate's name into the local\n-scope.\n+fn main() {\n+    println(\"Hello farm!\");\n \n-For example, `extern mod std` links the [standard library].\n+    // Can now refer to those names directly:\n+    chicken();\n+    cow();\n+    barn::hay();\n+}\n+~~~~\n \n-[standard library]: std/index.html\n+And here an example with multiple files:\n+~~~{.ignore}\n+// a.rs - crate root\n+use b::foo;\n+mod b;\n+fn main() { foo(); }\n+~~~\n+~~~{.ignore}\n+// b.rs\n+use b::c::bar;\n+pub mod c;\n+pub fn foo() { bar(); }\n+~~~\n+~~~\n+// c.rs\n+pub fn bar() { println(\"Baz!\"); }\n+~~~\n \n-When a comma-separated list of name/value pairs appears after `extern\n-mod`, the compiler front-end matches these pairs against the\n-attributes provided in the `link` attribute of the crate file. The\n-front-end will only select this crate for use if the actual pairs\n-match the declared attributes. You can provide a `name` value to\n-override the name used to search for the crate.\n+There also exist two short forms for importing multiple names at once:\n \n-Our example crate declared this set of `link` attributes:\n+1. Explicit mention multiple names as the last element of an `use` path:\n+~~~\n+use farm::{chicken, cow};\n+# mod farm {\n+#     pub fn cow() { println(\"Did I already mention how hidden and ninja I am?\") }\n+#     pub fn chicken() { println(\"I'm Bat-chicken, guardian of the hidden tutorial code.\") }\n+# }\n+# fn main() { cow(); chicken() }\n+~~~\n+\n+2. Import everything in a module with a wildcard:\n+~~~\n+use farm::*;\n+# mod farm {\n+#     pub fn cow() { println(\"Bat-chicken? What a stupid name!\") }\n+#     pub fn chicken() { println(\"Says the 'hidden ninja' cow.\") }\n+# }\n+# fn main() { cow(); chicken() }\n+~~~\n+\n+However, that's not all. You can also rename an item while you're bringing it into scope:\n+\n+~~~\n+use egg_layer = farm::chicken;\n+# mod farm { pub fn chicken() { println(\"Laying eggs is fun!\")  } }\n+// ...\n+\n+fn main() {\n+    egg_layer();\n+}\n+~~~\n+\n+In general, `use` creates an local alias:\n+An alternate path and a possibly different name to access the same item,\n+whiteout touching the original, and with both being interchangeable.\n+\n+## Reexporting names\n+\n+It is also possible to reexport items to be accessible under your module.\n+\n+For that, you write `pub use`:\n+\n+~~~\n+mod farm {\n+    pub use self::barn::hay;\n+\n+    pub fn chicken() { println(\"cluck cluck\"); }\n+    pub fn cow() { println(\"mooo\"); }\n+\n+    mod barn {\n+        pub fn hay() { println(\"...\"); }\n+    }\n+}\n+\n+fn main() {\n+    farm::chicken();\n+    farm::cow();\n+    farm::hay();\n+}\n+~~~\n+\n+Just like in normal `use` statements, the exported names\n+merely represent an alias to the same thing and can also be renamed.\n+\n+The above example also demonstrate what you can use `pub use` for:\n+The nested `barn` module is private, but the `pub use` allows users\n+of the module `farm` to access a function from `barn` without needing\n+to know that `barn` exists.\n+\n+In other words, you can use them to decouple an public api from their internal implementation.\n+\n+## Using libraries\n+\n+So far we've only talked about how to define and structure your own crate.\n+\n+However, most code out there will want to use preexisting libraries,\n+as there really is no reason to start from scratch each time you start a new project.\n+\n+In Rust terminology, we need a way to refer to other crates.\n+\n+For that, Rust offers you the `extern mod` declaration:\n+\n+~~~\n+extern mod extra;\n+// extra ships with Rust, you'll find more details further down.\n+\n+fn main() {\n+    // The rational number '1/2':\n+    let one_half = ::extra::rational::Ratio::new(1, 2);\n+}\n+~~~\n+\n+Despite its name, `extern mod` is a distinct construct from regular `mod` declarations:\n+A statement of the form `extern mod foo;` will cause `rustc` to search for the crate `foo`,\n+and if it finds a matching binary it lets you use it from inside your crate.\n+\n+The effect it has on your module hierarchy mirrors aspects of both `mod` and `use`:\n+\n+- Like `mod`, it causes `rustc` to actually emit code:\n+  The linkage information the binary needs to use the library `foo`.\n+\n+- But like `use`, all `extern mod` statements that refer to the same library are interchangeable,\n+  as each one really just presents an alias to an external module (the crate root of the library your linking against).\n+\n+Remember how `use`-statements have to go before local declarations because the latter shadows the former?\n+Well, `extern mod` statements also have their own rules in that regard:\n+Both `use` and local declarations can shadow them, so the rule is that `extern mod` has to go in front\n+of both `use` and local declarations.\n+\n+Which can result in something like this:\n+\n+~~~\n+extern mod extra;\n+\n+use farm::dog;\n+use extra::rational::Ratio;\n+\n+mod farm {\n+    pub fn dog() { println(\"woof\"); }\n+}\n+\n+fn main() {\n+    farm::dog();\n+    let a_third = Ratio::new(1, 3);\n+}\n+~~~\n+\n+It's a bit weird, but it's the result of shadowing rules that have been set that way because\n+they model most closely what people expect to shadow.\n+\n+## Package ids\n+\n+If you use `extern mod`, per default `rustc` will look for libraries in the the library search path (which you can\n+extend with the `-L` switch).\n+\n+However, Rust also ships with rustpkg, a package manager that is able to automatically download and build\n+libraries if you use it for building your crate. How it works is explained [here][rustpkg],\n+but for this tutorial it's only important to know that you can optionally annotate an\n+`extern mod` statement with an package id that rustpkg can use to identify it:\n+\n+~~~ {.ignore}\n+extern mod rust = \"github.com/mozilla/rust\"; // pretend Rust is an simple library\n+~~~\n+\n+[rustpkg]: rustpkg.html\n+\n+## Crate metadata and settings\n+\n+For every crate you can define a number of metadata items, such as link name, version or author.\n+You can also toggle settings that have crate-global consequences. Both mechanism\n+work by providing attributes in the crate root.\n+\n+For example, Rust uniquely identifies crates by their link metadate, which includes\n+the link name and the version. It also hashes the filename and the symbols in a binary\n+based on the link metadata, allowing you to use two different versions of the same library in a crate\n+without conflict.\n+\n+Therefor, if you plan to compile your crate as a library, you should annotate it with that information:\n \n ~~~~\n-#[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n+// lib.rs\n+\n+# #[crate_type = \"lib\"];\n+// Crate linkage metadata\n+#[link(name = \"farm\", vers = \"2.5\")];\n+\n+// ...\n+# pub fn farm() {}\n ~~~~\n \n-Which you can then link with any (or all) of the following:\n+You can also in turn require in a `extern mod` statement that certain link metadata items match some criteria.\n+For that, Rust currently parses a comma-separated list of name/value pairs that appear after\n+it, and ensures that they match the attributes provided in the `link` attribute of a crate file.\n+This enables you to, eg, pick a a crate based on it's version number, or to link an library under an\n+different name. For example, this two mod statements would both accept and select the crate define above:\n \n ~~~~ {.xfail-test}\n-extern mod farm;\n-extern mod my_farm (name = \"farm\", vers = \"2.5\");\n-extern mod my_auxiliary_farm (name = \"farm\", author = \"mjh\");\n+extern mod farm(vers = \"2.5\");\n+extern mod my_farm(name = \"farm\", vers = \"2.5\");\n+~~~~\n+\n+Other crate settings and metadata include things like enabling/disabling certain errors or warnings,\n+or setting the crate type (library or executable) explicitly:\n+\n ~~~~\n+// lib.rs\n+// ...\n \n-If any of the requested metadata do not match, then the crate\n-will not be compiled successfully.\n+// This crate is a library (\"bin\" is the default)\n+#[crate_type = \"lib\"];\n+\n+// Turn on a warning\n+#[warn(non_camel_case_types)]\n+# pub fn farm() {}\n+~~~~\n+\n+If you're compiling your crate with `rustpkg`,\n+link annotations will not be necessary, because they get\n+inferred by `rustpkg` based on the Package id and naming conventions.\n+\n+\n+> ***Note:*** The rules regarding link metadata, both as attributes and on `extern mod`,\n+              as well as their interaction with `rustpkg`\n+              are currently not clearly defined and will likely change in the future.\n \n ## A minimal example\n \n-Now for something that you can actually compile yourself, we have\n-these two files:\n+Now for something that you can actually compile yourself.\n+\n+We define two crates, and use one of them as a library in the other.\n \n ~~~~\n // world.rs\n-#[link(name = \"world\", vers = \"1.0\")];\n-pub fn explore() -> &str { \"world\" }\n+#[link(name = \"world\", vers = \"0.42\")];\n+pub fn explore() -> &'static str { \"world\" }\n ~~~~\n \n ~~~~ {.xfail-test}\n // main.rs\n extern mod world;\n-fn main() { println(~\"hello \" + world::explore()); }\n+fn main() { println(\"hello \" + world::explore()); }\n ~~~~\n \n Now compile and run like this (adjust to your platform if necessary):\n \n ~~~~ {.notrust}\n-> rustc --lib world.rs  # compiles libworld-94839cbfe144198-1.0.so\n+> rustc --lib world.rs  # compiles libworld-<HASH>-0.42.so\n > rustc main.rs -L .    # compiles main\n > ./main\n \"hello world\"\n ~~~~\n \n-Notice that the library produced contains the version in the filename\n-as well as an inscrutable string of alphanumerics. These are both\n-part of Rust's library versioning scheme. The alphanumerics are\n-a hash representing the crate metadata.\n+Notice that the library produced contains the version in the file name\n+as well as an inscrutable string of alphanumerics. As explained in the previous paragraph,\n+these are both part of Rust's library versioning scheme. The alphanumerics are\n+a hash representing the crates link metadata.\n+\n+## The standard library and the prelude\n+\n+While reading the examples in this tutorial, you might have asked yourself where all\n+those magical predefined items like `println()` are coming from.\n+\n+The truth is, there's nothing magical about them: They are all defined normally\n+in the `std` library, which is a crate that ships with Rust.\n+\n+The only magical thing that happens is that `rustc` automatically inserts this line into your crate root:\n+\n+~~~ {.ignore}\n+extern mod std;\n+~~~\n+\n+As well as this line into every module body:\n+\n+~~~ {.ignore}\n+use std::prelude::*;\n+~~~\n+\n+The role of the `prelude` module is to re-exports common definitions from `std`.\n+\n+This allows you to use common types and functions like `Option<T>` or `println`\n+without needing to import them. And if you need something from `std` that's not in the prelude,\n+you just have to import it with an `use` statement.\n+\n+For example, it re-exports `println` which is defined in `std::io::println`:\n+\n+~~~\n+use puts = std::io::println;\n+\n+fn main() {\n+    println(\"println is imported per default.\");\n+    puts(\"Doesn't hinder you from importing it under an different name yourself.\");\n+    ::std::io::println(\"Or from not using the automatic import.\");\n+}\n+~~~\n+\n+Both auto-insertions can be disabled with an attribute if necessary:\n+\n+~~~\n+// In the crate root:\n+#[no_std];\n+~~~\n+\n+~~~\n+// In any module:\n+#[no_implicit_prelude];\n+~~~\n \n-## The standard library\n+## The standard library in detail\n \n The Rust standard library provides runtime features required by the language,\n including the task scheduler and memory allocators, as well as library\n@@ -2499,24 +2927,9 @@ I/O abstractions ([`io`]), [containers] like [`hashmap`],\n common traits ([`kinds`], [`ops`], [`cmp`], [`num`],\n [`to_str`], [`clone`]), and complete bindings to the C standard library ([`libc`]).\n \n-### Standard Library injection and the Rust prelude\n-\n-`std` is imported at the topmost level of every crate by default, as\n-if the first line of each crate was\n-\n-    extern mod std;\n-\n-This means that the contents of std can be accessed from from any context\n-with the `std::` path prefix, as in `use std::vec`, `use std::task::spawn`,\n-etc.\n-\n-Additionally, `std` contains a `prelude` module that reexports many of the\n-most common standard modules, types and traits. The contents of the prelude are\n-imported into every *module* by default.  Implicitly, all modules behave as if\n-they contained the following prologue:\n-\n-    use std::prelude::*;\n+The full documentation for `std` can be found here: [standard library].\n \n+[standard library]: std/index.html\n [`std`]: std/index.html\n [`bool`]: std/bool.html\n [tuples]: std/tuple.html\n@@ -2543,6 +2956,18 @@ they contained the following prologue:\n [`clone`]: std/clone.html\n [`libc`]: std/libc.html\n \n+## The extra library\n+\n+Rust also ships with the [extra library], an accumulation of\n+useful things, that are however not important enough\n+to deserve a place in the standard library.\n+You can use them by linking to `extra` with an `extern mod extra;`.\n+\n+[extra library]: extra/index.html\n+\n+Right now `extra` contains those definitions directly, but in the future it will likely just\n+re-export a bunch of 'officially blessed' crates that get managed with `rustpkg`.\n+\n # What next?\n \n Now that you know the essentials, check out any of the additional\n@@ -2554,7 +2979,7 @@ tutorials on individual topics.\n * [The foreign function interface][ffi]\n * [Containers and iterators](tutorial-container.html)\n \n-There is further documentation on the [wiki].\n+There is further documentation on the [wiki], however those tend to be even more out of date as this document.\n \n [borrow]: tutorial-borrowed-ptr.html\n [tasks]: tutorial-tasks.html"}]}