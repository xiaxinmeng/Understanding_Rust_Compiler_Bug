{"sha": "c6133fe51c2cf31d776f16d520de4f78c709181c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MTMzZmU1MWMyY2YzMWQ3NzZmMTZkNTIwZGU0Zjc4YzcwOTE4MWM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-09T21:45:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-09T21:45:35Z"}, "message": "Merge #9195\n\n9195: minor: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "bf1feea9ea61990216ab09222c6b578bc29f9c84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf1feea9ea61990216ab09222c6b578bc29f9c84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6133fe51c2cf31d776f16d520de4f78c709181c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgwTZ/CRBK7hj4Ov3rIwAAT3QIAG0aJ9RTaYrthklfEhr/qEER\nYrIKOkmqH3DzLF7OjijXXWHVSc2ZT1tLdqI9l9RiDlAZYoq5Ytgy02FNChJYj+7T\n00sqCp2RIImXOs1Vyjw5SEN3VS830Je4O+TAMCAR5OoYtojUYgDDKC8qqesL2NSX\n/vm+7UxYPadhQkoKuj6KfiMapaYTfV0+aETUHrCOkDq/r1rkmsupy450afNSpIaa\n0IX7BMS/H80XVu+4KtIXR7o4KcgTvvcgXCg7/IWdp/UYj8bow26XZifdH1js7/TV\nlcISX53FeEksJYgqtuA8XBn6gpdY0+6/z456RuKyVuq5xDKvE9AGGfhx2yd/JOo=\n=5WCq\n-----END PGP SIGNATURE-----\n", "payload": "tree bf1feea9ea61990216ab09222c6b578bc29f9c84\nparent 85056423e3d14fc59bca06d3b2e0c44041653945\nparent 20d26bd109f9f405364842f95a69db2350fc0a42\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623275135 +0000\ncommitter GitHub <noreply@github.com> 1623275135 +0000\n\nMerge #9195\n\n9195: minor: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6133fe51c2cf31d776f16d520de4f78c709181c", "html_url": "https://github.com/rust-lang/rust/commit/c6133fe51c2cf31d776f16d520de4f78c709181c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6133fe51c2cf31d776f16d520de4f78c709181c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85056423e3d14fc59bca06d3b2e0c44041653945", "url": "https://api.github.com/repos/rust-lang/rust/commits/85056423e3d14fc59bca06d3b2e0c44041653945", "html_url": "https://github.com/rust-lang/rust/commit/85056423e3d14fc59bca06d3b2e0c44041653945"}, {"sha": "20d26bd109f9f405364842f95a69db2350fc0a42", "url": "https://api.github.com/repos/rust-lang/rust/commits/20d26bd109f9f405364842f95a69db2350fc0a42", "html_url": "https://github.com/rust-lang/rust/commit/20d26bd109f9f405364842f95a69db2350fc0a42"}], "stats": {"total": 386, "additions": 178, "deletions": 208}, "files": [{"sha": "902df46ca16e94cc16ab8d871ff24e4bca32bd9d", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 178, "deletions": 208, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/c6133fe51c2cf31d776f16d520de4f78c709181c/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6133fe51c2cf31d776f16d520de4f78c709181c/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=c6133fe51c2cf31d776f16d520de4f78c709181c", "patch": "@@ -24,34 +24,34 @@ use crate::{\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, CompletionRelevance,\n };\n \n-pub(crate) fn render_field<'a>(\n-    ctx: RenderContext<'a>,\n+pub(crate) fn render_field(\n+    ctx: RenderContext<'_>,\n     receiver: Option<hir::Name>,\n     field: hir::Field,\n     ty: &hir::Type,\n ) -> CompletionItem {\n-    Render::new(ctx).render_field(receiver, field, ty)\n+    render_field_(ctx, receiver, field, ty)\n }\n \n-pub(crate) fn render_tuple_field<'a>(\n-    ctx: RenderContext<'a>,\n+pub(crate) fn render_tuple_field(\n+    ctx: RenderContext<'_>,\n     receiver: Option<hir::Name>,\n     field: usize,\n     ty: &hir::Type,\n ) -> CompletionItem {\n-    Render::new(ctx).render_tuple_field(receiver, field, ty)\n+    render_tuple_field_(ctx, receiver, field, ty)\n }\n \n-pub(crate) fn render_resolution<'a>(\n-    ctx: RenderContext<'a>,\n+pub(crate) fn render_resolution(\n+    ctx: RenderContext<'_>,\n     local_name: hir::Name,\n     resolution: &hir::ScopeDef,\n ) -> Option<CompletionItem> {\n-    Render::new(ctx).render_resolution(local_name, None, resolution)\n+    render_resolution_(ctx, local_name, None, resolution)\n }\n \n-pub(crate) fn render_resolution_with_import<'a>(\n-    ctx: RenderContext<'a>,\n+pub(crate) fn render_resolution_with_import(\n+    ctx: RenderContext<'_>,\n     import_edit: ImportEdit,\n ) -> Option<CompletionItem> {\n     let resolution = hir::ScopeDef::from(import_edit.import.original_item);\n@@ -64,12 +64,10 @@ pub(crate) fn render_resolution_with_import<'a>(\n         hir::ScopeDef::ModuleDef(hir::ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db),\n         _ => item_name(ctx.db(), import_edit.import.original_item)?,\n     };\n-    Render::new(ctx).render_resolution(local_name, Some(import_edit), &resolution).map(\n-        |mut item| {\n-            item.completion_kind = CompletionKind::Magic;\n-            item\n-        },\n-    )\n+    render_resolution_(ctx, local_name, Some(import_edit), &resolution).map(|mut item| {\n+        item.completion_kind = CompletionKind::Magic;\n+        item\n+    })\n }\n \n /// Interface for data and methods required for items rendering.\n@@ -121,216 +119,188 @@ impl<'a> RenderContext<'a> {\n     }\n }\n \n-/// Generic renderer for completion items.\n-#[derive(Debug)]\n-struct Render<'a> {\n-    ctx: RenderContext<'a>,\n-}\n-\n-impl<'a> Render<'a> {\n-    fn new(ctx: RenderContext<'a>) -> Render<'a> {\n-        Render { ctx }\n+fn render_field_(\n+    ctx: RenderContext<'_>,\n+    receiver: Option<hir::Name>,\n+    field: hir::Field,\n+    ty: &hir::Type,\n+) -> CompletionItem {\n+    let is_deprecated = ctx.is_deprecated(field);\n+    let name = field.name(ctx.db()).to_string();\n+    let mut item = CompletionItem::new(\n+        CompletionKind::Reference,\n+        ctx.source_range(),\n+        receiver.map_or_else(|| name.clone(), |receiver| format!(\"{}.{}\", receiver, name)),\n+    );\n+    item.kind(SymbolKind::Field)\n+        .detail(ty.display(ctx.db()).to_string())\n+        .set_documentation(field.docs(ctx.db()))\n+        .set_deprecated(is_deprecated);\n+\n+    item.set_relevance(CompletionRelevance {\n+        type_match: compute_type_match(ctx.completion, ty),\n+        exact_name_match: compute_exact_name_match(ctx.completion, &name),\n+        ..CompletionRelevance::default()\n+    });\n+\n+    if let Some(_ref_match) = compute_ref_match(ctx.completion, ty) {\n+        // FIXME\n+        // For now we don't properly calculate the edits for ref match\n+        // completions on struct fields, so we've disabled them. See #8058.\n     }\n \n-    fn render_field(\n-        &self,\n-        receiver: Option<hir::Name>,\n-        field: hir::Field,\n-        ty: &hir::Type,\n-    ) -> CompletionItem {\n-        let is_deprecated = self.ctx.is_deprecated(field);\n-        let name = field.name(self.ctx.db()).to_string();\n-        let mut item = CompletionItem::new(\n-            CompletionKind::Reference,\n-            self.ctx.source_range(),\n-            receiver.map_or_else(|| name.clone(), |receiver| format!(\"{}.{}\", receiver, name)),\n-        );\n-        item.kind(SymbolKind::Field)\n-            .detail(ty.display(self.ctx.db()).to_string())\n-            .set_documentation(field.docs(self.ctx.db()))\n-            .set_deprecated(is_deprecated);\n-\n-        item.set_relevance(CompletionRelevance {\n-            type_match: compute_type_match(self.ctx.completion, ty),\n-            exact_name_match: compute_exact_name_match(self.ctx.completion, &name),\n-            ..CompletionRelevance::default()\n-        });\n-\n-        if let Some(_ref_match) = compute_ref_match(self.ctx.completion, ty) {\n-            // FIXME\n-            // For now we don't properly calculate the edits for ref match\n-            // completions on struct fields, so we've disabled them. See #8058.\n-        }\n+    item.build()\n+}\n \n-        item.build()\n-    }\n+fn render_tuple_field_(\n+    ctx: RenderContext<'_>,\n+    receiver: Option<hir::Name>,\n+    field: usize,\n+    ty: &hir::Type,\n+) -> CompletionItem {\n+    let mut item = CompletionItem::new(\n+        CompletionKind::Reference,\n+        ctx.source_range(),\n+        receiver.map_or_else(|| field.to_string(), |receiver| format!(\"{}.{}\", receiver, field)),\n+    );\n \n-    fn render_tuple_field(\n-        &self,\n-        receiver: Option<hir::Name>,\n-        field: usize,\n-        ty: &hir::Type,\n-    ) -> CompletionItem {\n-        let mut item = CompletionItem::new(\n-            CompletionKind::Reference,\n-            self.ctx.source_range(),\n-            receiver\n-                .map_or_else(|| field.to_string(), |receiver| format!(\"{}.{}\", receiver, field)),\n-        );\n+    item.kind(SymbolKind::Field).detail(ty.display(ctx.db()).to_string());\n \n-        item.kind(SymbolKind::Field).detail(ty.display(self.ctx.db()).to_string());\n+    item.build()\n+}\n \n-        item.build()\n-    }\n+fn render_resolution_(\n+    ctx: RenderContext<'_>,\n+    local_name: hir::Name,\n+    import_to_add: Option<ImportEdit>,\n+    resolution: &hir::ScopeDef,\n+) -> Option<CompletionItem> {\n+    let _p = profile::span(\"render_resolution\");\n+    use hir::ModuleDef::*;\n \n-    fn render_resolution(\n-        self,\n-        local_name: hir::Name,\n-        import_to_add: Option<ImportEdit>,\n-        resolution: &hir::ScopeDef,\n-    ) -> Option<CompletionItem> {\n-        let _p = profile::span(\"render_resolution\");\n-        use hir::ModuleDef::*;\n-\n-        let completion_kind = match resolution {\n-            hir::ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n-            _ => CompletionKind::Reference,\n-        };\n+    let completion_kind = match resolution {\n+        hir::ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n+        _ => CompletionKind::Reference,\n+    };\n \n-        let kind = match resolution {\n-            hir::ScopeDef::ModuleDef(Function(func)) => {\n-                return render_fn(self.ctx, import_to_add, Some(local_name), *func);\n-            }\n-            hir::ScopeDef::ModuleDef(Variant(_))\n-                if self.ctx.completion.is_pat_or_const.is_some() =>\n-            {\n-                CompletionItemKind::SymbolKind(SymbolKind::Variant)\n-            }\n-            hir::ScopeDef::ModuleDef(Variant(var)) => {\n-                let item = render_variant(self.ctx, import_to_add, Some(local_name), *var, None);\n-                return Some(item);\n-            }\n-            hir::ScopeDef::MacroDef(mac) => {\n-                let item = render_macro(self.ctx, import_to_add, local_name, *mac);\n-                return item;\n-            }\n+    let kind = match resolution {\n+        hir::ScopeDef::ModuleDef(Function(func)) => {\n+            return render_fn(ctx, import_to_add, Some(local_name), *func);\n+        }\n+        hir::ScopeDef::ModuleDef(Variant(_)) if ctx.completion.is_pat_or_const.is_some() => {\n+            CompletionItemKind::SymbolKind(SymbolKind::Variant)\n+        }\n+        hir::ScopeDef::ModuleDef(Variant(var)) => {\n+            let item = render_variant(ctx, import_to_add, Some(local_name), *var, None);\n+            return Some(item);\n+        }\n+        hir::ScopeDef::MacroDef(mac) => {\n+            let item = render_macro(ctx, import_to_add, local_name, *mac);\n+            return item;\n+        }\n \n-            hir::ScopeDef::ModuleDef(Module(..)) => {\n-                CompletionItemKind::SymbolKind(SymbolKind::Module)\n-            }\n-            hir::ScopeDef::ModuleDef(Adt(adt)) => CompletionItemKind::SymbolKind(match adt {\n-                hir::Adt::Struct(_) => SymbolKind::Struct,\n-                hir::Adt::Union(_) => SymbolKind::Union,\n-                hir::Adt::Enum(_) => SymbolKind::Enum,\n-            }),\n-            hir::ScopeDef::ModuleDef(Const(..)) => {\n-                CompletionItemKind::SymbolKind(SymbolKind::Const)\n-            }\n-            hir::ScopeDef::ModuleDef(Static(..)) => {\n-                CompletionItemKind::SymbolKind(SymbolKind::Static)\n-            }\n-            hir::ScopeDef::ModuleDef(Trait(..)) => {\n-                CompletionItemKind::SymbolKind(SymbolKind::Trait)\n-            }\n-            hir::ScopeDef::ModuleDef(TypeAlias(..)) => {\n-                CompletionItemKind::SymbolKind(SymbolKind::TypeAlias)\n-            }\n-            hir::ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n-            hir::ScopeDef::GenericParam(param) => CompletionItemKind::SymbolKind(match param {\n-                hir::GenericParam::TypeParam(_) => SymbolKind::TypeParam,\n-                hir::GenericParam::LifetimeParam(_) => SymbolKind::LifetimeParam,\n-                hir::GenericParam::ConstParam(_) => SymbolKind::ConstParam,\n-            }),\n-            hir::ScopeDef::Local(..) => CompletionItemKind::SymbolKind(SymbolKind::Local),\n-            hir::ScopeDef::Label(..) => CompletionItemKind::SymbolKind(SymbolKind::Label),\n-            hir::ScopeDef::AdtSelfType(..) | hir::ScopeDef::ImplSelfType(..) => {\n-                CompletionItemKind::SymbolKind(SymbolKind::SelfParam)\n-            }\n-            hir::ScopeDef::Unknown => {\n-                let mut item = CompletionItem::new(\n-                    CompletionKind::Reference,\n-                    self.ctx.source_range(),\n-                    local_name.to_string(),\n-                );\n-                item.kind(CompletionItemKind::UnresolvedReference).add_import(import_to_add);\n-                return Some(item.build());\n-            }\n-        };\n+        hir::ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::SymbolKind(SymbolKind::Module),\n+        hir::ScopeDef::ModuleDef(Adt(adt)) => CompletionItemKind::SymbolKind(match adt {\n+            hir::Adt::Struct(_) => SymbolKind::Struct,\n+            hir::Adt::Union(_) => SymbolKind::Union,\n+            hir::Adt::Enum(_) => SymbolKind::Enum,\n+        }),\n+        hir::ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::SymbolKind(SymbolKind::Const),\n+        hir::ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::SymbolKind(SymbolKind::Static),\n+        hir::ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::SymbolKind(SymbolKind::Trait),\n+        hir::ScopeDef::ModuleDef(TypeAlias(..)) => {\n+            CompletionItemKind::SymbolKind(SymbolKind::TypeAlias)\n+        }\n+        hir::ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n+        hir::ScopeDef::GenericParam(param) => CompletionItemKind::SymbolKind(match param {\n+            hir::GenericParam::TypeParam(_) => SymbolKind::TypeParam,\n+            hir::GenericParam::LifetimeParam(_) => SymbolKind::LifetimeParam,\n+            hir::GenericParam::ConstParam(_) => SymbolKind::ConstParam,\n+        }),\n+        hir::ScopeDef::Local(..) => CompletionItemKind::SymbolKind(SymbolKind::Local),\n+        hir::ScopeDef::Label(..) => CompletionItemKind::SymbolKind(SymbolKind::Label),\n+        hir::ScopeDef::AdtSelfType(..) | hir::ScopeDef::ImplSelfType(..) => {\n+            CompletionItemKind::SymbolKind(SymbolKind::SelfParam)\n+        }\n+        hir::ScopeDef::Unknown => {\n+            let mut item = CompletionItem::new(\n+                CompletionKind::Reference,\n+                ctx.source_range(),\n+                local_name.to_string(),\n+            );\n+            item.kind(CompletionItemKind::UnresolvedReference).add_import(import_to_add);\n+            return Some(item.build());\n+        }\n+    };\n \n-        let local_name = local_name.to_string();\n-        let mut item =\n-            CompletionItem::new(completion_kind, self.ctx.source_range(), local_name.clone());\n-        if let hir::ScopeDef::Local(local) = resolution {\n-            let ty = local.ty(self.ctx.db());\n-            if !ty.is_unknown() {\n-                item.detail(ty.display(self.ctx.db()).to_string());\n-            }\n+    let local_name = local_name.to_string();\n+    let mut item = CompletionItem::new(completion_kind, ctx.source_range(), local_name.clone());\n+    if let hir::ScopeDef::Local(local) = resolution {\n+        let ty = local.ty(ctx.db());\n+        if !ty.is_unknown() {\n+            item.detail(ty.display(ctx.db()).to_string());\n+        }\n \n-            item.set_relevance(CompletionRelevance {\n-                type_match: compute_type_match(self.ctx.completion, &ty),\n-                exact_name_match: compute_exact_name_match(self.ctx.completion, &local_name),\n-                is_local: true,\n-                ..CompletionRelevance::default()\n-            });\n+        item.set_relevance(CompletionRelevance {\n+            type_match: compute_type_match(ctx.completion, &ty),\n+            exact_name_match: compute_exact_name_match(ctx.completion, &local_name),\n+            is_local: true,\n+            ..CompletionRelevance::default()\n+        });\n \n-            if let Some(ref_match) = compute_ref_match(self.ctx.completion, &ty) {\n-                item.ref_match(ref_match);\n-            }\n-        };\n+        if let Some(ref_match) = compute_ref_match(ctx.completion, &ty) {\n+            item.ref_match(ref_match);\n+        }\n+    };\n \n-        // Add `<>` for generic types\n-        if matches!(\n-            self.ctx.completion.path_context,\n-            Some(PathCompletionContext { kind: Some(PathKind::Type), has_type_args: false, .. })\n-        ) && self.ctx.completion.config.add_call_parenthesis\n-        {\n-            if let Some(cap) = self.ctx.snippet_cap() {\n-                let has_non_default_type_params = match resolution {\n-                    hir::ScopeDef::ModuleDef(Adt(it)) => {\n-                        it.has_non_default_type_params(self.ctx.db())\n-                    }\n-                    hir::ScopeDef::ModuleDef(TypeAlias(it)) => {\n-                        it.has_non_default_type_params(self.ctx.db())\n-                    }\n-                    _ => false,\n-                };\n-                if has_non_default_type_params {\n-                    cov_mark::hit!(inserts_angle_brackets_for_generics);\n-                    item.lookup_by(local_name.clone())\n-                        .label(format!(\"{}<\u2026>\", local_name))\n-                        .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n-                }\n+    // Add `<>` for generic types\n+    if matches!(\n+        ctx.completion.path_context,\n+        Some(PathCompletionContext { kind: Some(PathKind::Type), has_type_args: false, .. })\n+    ) && ctx.completion.config.add_call_parenthesis\n+    {\n+        if let Some(cap) = ctx.snippet_cap() {\n+            let has_non_default_type_params = match resolution {\n+                hir::ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(ctx.db()),\n+                hir::ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(ctx.db()),\n+                _ => false,\n+            };\n+            if has_non_default_type_params {\n+                cov_mark::hit!(inserts_angle_brackets_for_generics);\n+                item.lookup_by(local_name.clone())\n+                    .label(format!(\"{}<\u2026>\", local_name))\n+                    .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n             }\n         }\n-        item.kind(kind)\n-            .add_import(import_to_add)\n-            .set_documentation(self.docs(resolution))\n-            .set_deprecated(self.is_deprecated(resolution));\n-        Some(item.build())\n     }\n+    item.kind(kind)\n+        .add_import(import_to_add)\n+        .set_documentation(scope_def_docs(ctx.db(), resolution))\n+        .set_deprecated(scope_def_is_deprecated(&ctx, resolution));\n+    Some(item.build())\n+}\n \n-    fn docs(&self, resolution: &hir::ScopeDef) -> Option<hir::Documentation> {\n-        use hir::ModuleDef::*;\n-        match resolution {\n-            hir::ScopeDef::ModuleDef(Module(it)) => it.docs(self.ctx.db()),\n-            hir::ScopeDef::ModuleDef(Adt(it)) => it.docs(self.ctx.db()),\n-            hir::ScopeDef::ModuleDef(Variant(it)) => it.docs(self.ctx.db()),\n-            hir::ScopeDef::ModuleDef(Const(it)) => it.docs(self.ctx.db()),\n-            hir::ScopeDef::ModuleDef(Static(it)) => it.docs(self.ctx.db()),\n-            hir::ScopeDef::ModuleDef(Trait(it)) => it.docs(self.ctx.db()),\n-            hir::ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(self.ctx.db()),\n-            _ => None,\n-        }\n+fn scope_def_docs(db: &RootDatabase, resolution: &hir::ScopeDef) -> Option<hir::Documentation> {\n+    use hir::ModuleDef::*;\n+    match resolution {\n+        hir::ScopeDef::ModuleDef(Module(it)) => it.docs(db),\n+        hir::ScopeDef::ModuleDef(Adt(it)) => it.docs(db),\n+        hir::ScopeDef::ModuleDef(Variant(it)) => it.docs(db),\n+        hir::ScopeDef::ModuleDef(Const(it)) => it.docs(db),\n+        hir::ScopeDef::ModuleDef(Static(it)) => it.docs(db),\n+        hir::ScopeDef::ModuleDef(Trait(it)) => it.docs(db),\n+        hir::ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(db),\n+        _ => None,\n     }\n+}\n \n-    fn is_deprecated(&self, resolution: &hir::ScopeDef) -> bool {\n-        match resolution {\n-            hir::ScopeDef::ModuleDef(it) => self.ctx.is_deprecated_assoc_item(*it),\n-            hir::ScopeDef::MacroDef(it) => self.ctx.is_deprecated(*it),\n-            hir::ScopeDef::GenericParam(it) => self.ctx.is_deprecated(*it),\n-            hir::ScopeDef::AdtSelfType(it) => self.ctx.is_deprecated(*it),\n-            _ => false,\n-        }\n+fn scope_def_is_deprecated(ctx: &RenderContext<'_>, resolution: &hir::ScopeDef) -> bool {\n+    match resolution {\n+        hir::ScopeDef::ModuleDef(it) => ctx.is_deprecated_assoc_item(*it),\n+        hir::ScopeDef::MacroDef(it) => ctx.is_deprecated(*it),\n+        hir::ScopeDef::GenericParam(it) => ctx.is_deprecated(*it),\n+        hir::ScopeDef::AdtSelfType(it) => ctx.is_deprecated(*it),\n+        _ => false,\n     }\n }\n "}]}