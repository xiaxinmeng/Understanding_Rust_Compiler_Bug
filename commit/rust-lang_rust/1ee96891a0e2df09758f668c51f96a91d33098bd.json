{"sha": "1ee96891a0e2df09758f668c51f96a91d33098bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlZTk2ODkxYTBlMmRmMDk3NThmNjY4YzUxZjk2YTkxZDMzMDk4YmQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-21T00:59:08Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-21T00:59:33Z"}, "message": "rustc: Create an item collection context during typechecking; move collection to a module", "tree": {"sha": "0499661c8faa186b1fd69b7aac191eab0c42318e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0499661c8faa186b1fd69b7aac191eab0c42318e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ee96891a0e2df09758f668c51f96a91d33098bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ee96891a0e2df09758f668c51f96a91d33098bd", "html_url": "https://github.com/rust-lang/rust/commit/1ee96891a0e2df09758f668c51f96a91d33098bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ee96891a0e2df09758f668c51f96a91d33098bd/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0d98cec458f22ee24f871c5b2e31ef934589655", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0d98cec458f22ee24f871c5b2e31ef934589655", "html_url": "https://github.com/rust-lang/rust/commit/c0d98cec458f22ee24f871c5b2e31ef934589655"}], "stats": {"total": 306, "additions": 136, "deletions": 170}, "files": [{"sha": "99cc6d6a8db51d1540206779db5542e9c2b9ca69", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 136, "deletions": 170, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/1ee96891a0e2df09758f668c51f96a91d33098bd/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ee96891a0e2df09758f668c51f96a91d33098bd/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=1ee96891a0e2df09758f668c51f96a91d33098bd", "patch": "@@ -341,175 +341,150 @@ fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty.t {\n // We then annotate the AST with the resulting types and return the annotated\n // AST, along with a table mapping item IDs to their types.\n \n-fn ty_of_fn_decl(@ty_item_table id_to_ty_item,\n-                 ty.type_cache type_cache,\n-                 fn(&@ast.ty ast_ty) -> @ty.t convert,\n-                 fn(&ast.arg a) -> arg ty_of_arg,\n-                 &ast.fn_decl decl,\n-                 ast.proto proto,\n-                 vec[ast.ty_param] ty_params,\n-                 ast.def_id def_id) -> ty.ty_param_count_and_ty {\n-    auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n-    auto output_ty = convert(decl.output);\n-    auto t_fn = ty.mk_fn(proto, input_tys, output_ty);\n-    auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n-    auto tpt = tup(ty_param_count, t_fn);\n-    type_cache.insert(def_id, tpt);\n-    ret tpt;\n-}\n-\n-fn ty_of_native_fn_decl(@ty_item_table id_to_ty_item,\n-                 ty.type_cache type_cache,\n-                 fn(&@ast.ty ast_ty) -> @ty.t convert,\n-                 fn(&ast.arg a) -> arg ty_of_arg,\n-                 &ast.fn_decl decl,\n-                 ast.native_abi abi,\n-                 vec[ast.ty_param] ty_params,\n-                 ast.def_id def_id) -> ty.ty_param_count_and_ty {\n-    auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n-    auto output_ty = convert(decl.output);\n-    auto t_fn = ty.mk_native_fn(abi, input_tys, output_ty);\n-    auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n-    auto tpt = tup(ty_param_count, t_fn);\n-    type_cache.insert(def_id, tpt);\n-    ret tpt;\n-}\n+mod Collect {\n+    type ctxt = rec(session.session sess,\n+                    @ty_item_table id_to_ty_item,\n+                    ty.type_cache type_cache);\n+    type env = rec(@ctxt cx, ast.native_abi abi);\n+\n+    fn ty_of_fn_decl(@ctxt cx,\n+                     fn(&@ast.ty ast_ty) -> @ty.t convert,\n+                     fn(&ast.arg a) -> arg ty_of_arg,\n+                     &ast.fn_decl decl,\n+                     ast.proto proto,\n+                     vec[ast.ty_param] ty_params,\n+                     ast.def_id def_id) -> ty.ty_param_count_and_ty {\n+        auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n+        auto output_ty = convert(decl.output);\n+        auto t_fn = ty.mk_fn(proto, input_tys, output_ty);\n+        auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n+        auto tpt = tup(ty_param_count, t_fn);\n+        cx.type_cache.insert(def_id, tpt);\n+        ret tpt;\n+    }\n \n-fn collect_item_types(session.session sess, @ast.crate crate)\n-    -> tup(@ast.crate, ty.type_cache, @ty_item_table) {\n+    fn ty_of_native_fn_decl(@ctxt cx,\n+                            fn(&@ast.ty ast_ty) -> @ty.t convert,\n+                            fn(&ast.arg a) -> arg ty_of_arg,\n+                            &ast.fn_decl decl,\n+                            ast.native_abi abi,\n+                            vec[ast.ty_param] ty_params,\n+                            ast.def_id def_id) -> ty.ty_param_count_and_ty {\n+        auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n+        auto output_ty = convert(decl.output);\n+        auto t_fn = ty.mk_native_fn(abi, input_tys, output_ty);\n+        auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n+        auto tpt = tup(ty_param_count, t_fn);\n+        cx.type_cache.insert(def_id, tpt);\n+        ret tpt;\n+    }\n \n-    fn getter(session.session sess,\n-              @ty_item_table id_to_ty_item,\n-              ty.type_cache type_cache,\n-              ast.def_id id) -> ty.ty_param_count_and_ty {\n+    fn getter(@ctxt cx, ast.def_id id) -> ty.ty_param_count_and_ty {\n \n-        if (id._0 != sess.get_targ_crate_num()) {\n+        if (id._0 != cx.sess.get_targ_crate_num()) {\n             // This is a type we need to load in from the crate reader.\n-            ret creader.get_type(sess, id);\n+            ret creader.get_type(cx.sess, id);\n         }\n \n-        check (id_to_ty_item.contains_key(id));\n+        check (cx.id_to_ty_item.contains_key(id));\n \n-        auto it = id_to_ty_item.get(id);\n+        auto it = cx.id_to_ty_item.get(id);\n         auto tpt;\n         alt (it) {\n-            case (any_item_rust(?item)) {\n-                tpt = ty_of_item(sess, id_to_ty_item, type_cache, item);\n-            }\n+            case (any_item_rust(?item)) { tpt = ty_of_item(cx, item); }\n             case (any_item_native(?native_item, ?abi)) {\n-                tpt = ty_of_native_item(sess, id_to_ty_item, type_cache,\n-                                        native_item, abi);\n+                tpt = ty_of_native_item(cx, native_item, abi);\n             }\n         }\n \n         ret tpt;\n     }\n \n-    fn ty_of_arg(session.session sess,\n-                 @ty_item_table id_to_ty_item,\n-                 ty.type_cache type_cache,\n-                 &ast.arg a) -> arg {\n-        auto f = bind getter(sess, id_to_ty_item, type_cache, _);\n+    fn ty_of_arg(@ctxt cx, &ast.arg a) -> arg {\n+        auto f = bind getter(cx, _);\n         ret rec(mode=a.mode, ty=ast_ty_to_ty(f, a.ty));\n     }\n \n-    fn ty_of_method(session.session sess,\n-                    @ty_item_table id_to_ty_item,\n-                    ty.type_cache type_cache,\n-                    &@ast.method m) -> method {\n-        auto get = bind getter(sess, id_to_ty_item, type_cache, _);\n+    fn ty_of_method(@ctxt cx, &@ast.method m) -> method {\n+        auto get = bind getter(cx, _);\n         auto convert = bind ast_ty_to_ty(get, _);\n-        auto f = bind ty_of_arg(sess, id_to_ty_item, type_cache, _);\n+        auto f = bind ty_of_arg(cx, _);\n         auto inputs = _vec.map[ast.arg,arg](f, m.node.meth.decl.inputs);\n         auto output = convert(m.node.meth.decl.output);\n         ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n                 inputs=inputs, output=output);\n     }\n \n-    fn ty_of_obj(session.session sess,\n-                 @ty_item_table id_to_ty_item,\n-                 ty.type_cache type_cache,\n-                 &ast.ident id,\n+    fn ty_of_obj(@ctxt cx,\n+                 ast.ident id,\n                  &ast._obj obj_info,\n                  vec[ast.ty_param] ty_params) -> ty.ty_param_count_and_ty {\n-        auto f = bind ty_of_method(sess, id_to_ty_item, type_cache, _);\n-        auto methods =\n-            _vec.map[@ast.method,method](f, obj_info.methods);\n+        auto f = bind ty_of_method(cx, _);\n+        auto methods = _vec.map[@ast.method,method](f, obj_info.methods);\n \n         auto t_obj = ty.mk_obj(ty.sort_methods(methods));\n         t_obj = ty.rename(t_obj, id);\n         auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n         ret tup(ty_param_count, t_obj);\n     }\n \n-    fn ty_of_obj_ctor(session.session sess,\n-                      @ty_item_table id_to_ty_item,\n-                      ty.type_cache type_cache,\n+    fn ty_of_obj_ctor(@ctxt cx,\n                       &ast.ident id,\n                       &ast._obj obj_info,\n                       ast.def_id obj_ty_id,\n                       vec[ast.ty_param] ty_params)\n             -> ty.ty_param_count_and_ty {\n-        auto t_obj = ty_of_obj(sess, id_to_ty_item, type_cache,\n-                               id, obj_info, ty_params);\n+        auto t_obj = ty_of_obj(cx, id, obj_info, ty_params);\n         let vec[arg] t_inputs = vec();\n         for (ast.obj_field f in obj_info.fields) {\n-            auto g = bind getter(sess, id_to_ty_item, type_cache, _);\n+            auto g = bind getter(cx, _);\n             auto t_field = ast_ty_to_ty(g, f.ty);\n             _vec.push[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n         }\n \n-        type_cache.insert(obj_ty_id, t_obj);\n+        cx.type_cache.insert(obj_ty_id, t_obj);\n \n         auto t_fn = ty.mk_fn(ast.proto_fn, t_inputs, t_obj._1);\n         ret tup(t_obj._0, t_fn);\n     }\n \n-    fn ty_of_item(session.session sess,\n-                  @ty_item_table id_to_ty_item,\n-                  ty.type_cache type_cache,\n-                  @ast.item it) -> ty.ty_param_count_and_ty {\n+    fn ty_of_item(@ctxt cx, @ast.item it) -> ty.ty_param_count_and_ty {\n \n-        auto get = bind getter(sess, id_to_ty_item, type_cache, _);\n+        auto get = bind getter(cx, _);\n         auto convert = bind ast_ty_to_ty(get, _);\n \n         alt (it.node) {\n \n             case (ast.item_const(?ident, ?t, _, ?def_id, _)) {\n                 auto typ = convert(t);\n-                type_cache.insert(def_id, tup(0u, typ));\n+                cx.type_cache.insert(def_id, tup(0u, typ));\n             }\n \n             case (ast.item_fn(?ident, ?fn_info, ?tps, ?def_id, _)) {\n-                auto f = bind ty_of_arg(sess, id_to_ty_item, type_cache, _);\n-                ret ty_of_fn_decl(id_to_ty_item, type_cache, convert, f,\n-                                  fn_info.decl, fn_info.proto, tps, def_id);\n+                auto f = bind ty_of_arg(cx, _);\n+                ret ty_of_fn_decl(cx, convert, f, fn_info.decl, fn_info.proto,\n+                                  tps, def_id);\n             }\n \n             case (ast.item_obj(?ident, ?obj_info, ?tps, ?odid, _)) {\n-                auto t_ctor = ty_of_obj_ctor(sess,\n-                                             id_to_ty_item,\n-                                             type_cache,\n-                                             ident,\n-                                             obj_info,\n-                                             odid.ty,\n+                auto t_ctor = ty_of_obj_ctor(cx, ident, obj_info, odid.ty,\n                                              tps);\n-                type_cache.insert(odid.ctor, t_ctor);\n-                ret type_cache.get(odid.ty);\n+                cx.type_cache.insert(odid.ctor, t_ctor);\n+                ret cx.type_cache.get(odid.ty);\n             }\n \n             case (ast.item_ty(?ident, ?ty, ?tps, ?def_id, _)) {\n-                if (type_cache.contains_key(def_id)) {\n+                if (cx.type_cache.contains_key(def_id)) {\n                     // Avoid repeating work.\n-                    ret type_cache.get(def_id);\n+                    ret cx.type_cache.get(def_id);\n                 }\n \n                 // Tell ast_ty_to_ty() that we want to perform a recursive\n                 // call to resolve any named types.\n                 auto typ = convert(ty);\n                 auto ty_param_count = _vec.len[ast.ty_param](tps);\n                 auto tpt = tup(ty_param_count, typ);\n-                type_cache.insert(def_id, tpt);\n+                cx.type_cache.insert(def_id, tpt);\n                 ret tpt;\n             }\n \n@@ -527,7 +502,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n                 auto ty_param_count = _vec.len[ast.ty_param](tps);\n                 auto tpt = tup(ty_param_count, t);\n-                type_cache.insert(def_id, tpt);\n+                cx.type_cache.insert(def_id, tpt);\n                 ret tpt;\n             }\n \n@@ -536,38 +511,32 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         }\n     }\n \n-    fn ty_of_native_item(session.session sess,\n-                         @ty_item_table id_to_ty_item,\n-                         ty.type_cache type_cache,\n-                         @ast.native_item it,\n-                         ast.native_abi abi) -> ty.ty_param_count_and_ty {\n+    fn ty_of_native_item(@ctxt cx, @ast.native_item it, ast.native_abi abi)\n+            -> ty.ty_param_count_and_ty {\n         alt (it.node) {\n             case (ast.native_item_fn(?ident, ?lname, ?fn_decl,\n                                      ?params, ?def_id, _)) {\n-                auto get = bind getter(sess, id_to_ty_item, type_cache, _);\n+                auto get = bind getter(cx, _);\n                 auto convert = bind ast_ty_to_ty(get, _);\n-                auto f = bind ty_of_arg(sess, id_to_ty_item, type_cache, _);\n-                ret ty_of_native_fn_decl(id_to_ty_item, type_cache, convert,\n-                                         f, fn_decl, abi, params, def_id);\n+                auto f = bind ty_of_arg(cx, _);\n+                ret ty_of_native_fn_decl(cx, convert, f, fn_decl, abi, params,\n+                                         def_id);\n             }\n             case (ast.native_item_ty(_, ?def_id)) {\n-                if (type_cache.contains_key(def_id)) {\n+                if (cx.type_cache.contains_key(def_id)) {\n                     // Avoid repeating work.\n-                    ret type_cache.get(def_id);\n+                    ret cx.type_cache.get(def_id);\n                 }\n \n                 auto t = ty.mk_native();\n                 auto tpt = tup(0u, t);\n-                type_cache.insert(def_id, tpt);\n+                cx.type_cache.insert(def_id, tpt);\n                 ret tpt;\n             }\n         }\n     }\n \n-    fn get_tag_variant_types(session.session sess,\n-                             @ty_item_table id_to_ty_item,\n-                             ty.type_cache type_cache,\n-                             &ast.def_id tag_id,\n+    fn get_tag_variant_types(@ctxt cx, &ast.def_id tag_id,\n                              &vec[ast.variant] variants,\n                              &vec[ast.ty_param] ty_params)\n             -> vec[ast.variant] {\n@@ -592,7 +561,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n-                auto f = bind getter(sess, id_to_ty_item, type_cache, _);\n+                auto f = bind getter(cx, _);\n \n                 let vec[arg] args = vec();\n                 for (ast.variant_arg va in variant.node.args) {\n@@ -604,7 +573,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             }\n \n             auto tpt = tup(ty_param_count, result_ty);\n-            type_cache.insert(variant.node.id, tpt);\n+            cx.type_cache.insert(variant.node.id, tpt);\n             auto variant_t = rec(ann=triv_ann(result_ty)\n                 with variant.node\n             );\n@@ -614,11 +583,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         ret result;\n     }\n \n-    // First pass: collect all type item IDs.\n-    auto module = crate.node.module;\n-    auto id_to_ty_item = @common.new_def_hash[any_item]();\n-    fn collect(&@ty_item_table id_to_ty_item, @ast.item i)\n-        -> @ty_item_table {\n+    fn collect(&@ty_item_table id_to_ty_item, @ast.item i) -> @ty_item_table {\n         alt (i.node) {\n             case (ast.item_ty(_, _, _, ?def_id, _)) {\n                 id_to_ty_item.insert(def_id, any_item_rust(i));\n@@ -633,6 +598,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         }\n         ret id_to_ty_item;\n     }\n+\n     fn collect_native(&@ty_item_table id_to_ty_item, @ast.native_item i)\n         -> @ty_item_table {\n         alt (i.node) {\n@@ -647,25 +613,6 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         }\n         ret id_to_ty_item;\n     }\n-    auto fld_1 = fold.new_identity_fold[@ty_item_table]();\n-    fld_1 = @rec(update_env_for_item = bind collect(_, _),\n-                 update_env_for_native_item = bind collect_native(_, _)\n-                 with *fld_1);\n-    fold.fold_crate[@ty_item_table](id_to_ty_item, fld_1, crate);\n-\n-\n-\n-    // Second pass: translate the types of all items.\n-    auto type_cache = common.new_def_hash[ty.ty_param_count_and_ty]();\n-\n-    type env = rec(session.session sess,\n-                   @ty_item_table id_to_ty_item,\n-                   ty.type_cache type_cache,\n-                   ast.native_abi abi);\n-    let @env e = @rec(sess=sess,\n-                      id_to_ty_item=id_to_ty_item,\n-                      type_cache=type_cache,\n-                      abi=ast.native_abi_cdecl);\n \n     fn convert(&@env e, @ast.item i) -> @env {\n         auto abi = e.abi;\n@@ -680,40 +627,40 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             case (_) {\n                 // This call populates the ty_table with the converted type of\n                 // the item in passing; we don't need to do anything else.\n-                ty_of_item(e.sess, e.id_to_ty_item, e.type_cache, i);\n+                ty_of_item(e.cx, i);\n             }\n         }\n         ret @rec(abi=abi with *e);\n     }\n \n     fn convert_native(&@env e, @ast.native_item i) -> @env {\n-        ty_of_native_item(e.sess, e.id_to_ty_item, e.type_cache, i, e.abi);\n+        ty_of_native_item(e.cx, i, e.abi);\n         ret e;\n     }\n \n     fn fold_item_const(&@env e, &span sp, ast.ident i,\n                        @ast.ty t, @ast.expr ex,\n                        ast.def_id id, ast.ann a) -> @ast.item {\n-        check (e.type_cache.contains_key(id));\n-        auto typ = e.type_cache.get(id)._1;\n+        check (e.cx.type_cache.contains_key(id));\n+        auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_const(i, t, ex, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n     fn fold_item_fn(&@env e, &span sp, ast.ident i,\n                     &ast._fn f, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n-        check (e.type_cache.contains_key(id));\n-        auto typ = e.type_cache.get(id)._1;\n+        check (e.cx.type_cache.contains_key(id));\n+        auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_fn(i, f, ty_params, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n     fn fold_native_item_fn(&@env e, &span sp, ast.ident i, option.t[str] ln,\n                            &ast.fn_decl d, vec[ast.ty_param] ty_params,\n                            ast.def_id id, ast.ann a) -> @ast.native_item {\n-        check (e.type_cache.contains_key(id));\n-        auto typ = e.type_cache.get(id)._1;\n+        check (e.cx.type_cache.contains_key(id));\n+        auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.native_item_fn(i, ln, d, ty_params, id,\n                                        triv_ann(typ));\n         ret @fold.respan[ast.native_item_](sp, item);\n@@ -743,14 +690,14 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n     fn fold_item_obj(&@env e, &span sp, ast.ident i,\n                     &ast._obj ob, vec[ast.ty_param] ty_params,\n                     ast.obj_def_ids odid, ast.ann a) -> @ast.item {\n-        check (e.type_cache.contains_key(odid.ctor));\n-        auto t = e.type_cache.get(odid.ctor)._1;\n+        check (e.cx.type_cache.contains_key(odid.ctor));\n+        auto t = e.cx.type_cache.get(odid.ctor)._1;\n         let vec[method] meth_tys = get_ctor_obj_methods(t);\n         let vec[@ast.method] methods = vec();\n         let vec[ast.obj_field] fields = vec();\n \n         for (@ast.method meth in ob.methods) {\n-            let uint ix = ty.method_idx(e.sess,\n+            let uint ix = ty.method_idx(e.cx.sess,\n                                         sp, meth.node.ident,\n                                         meth_tys);\n             let method meth_ty = meth_tys.(ix);\n@@ -765,7 +712,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             m = @rec(node=m_ with *meth);\n             _vec.push[@ast.method](methods, m);\n         }\n-        auto g = bind getter(e.sess, e.id_to_ty_item, e.type_cache, _);\n+        auto g = bind getter(e.cx, _);\n         for (ast.obj_field fld in ob.fields) {\n             let @ty.t fty = ast_ty_to_ty(g, fld.ty);\n             let ast.obj_field f = rec(ann=triv_ann(fty)\n@@ -797,8 +744,8 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n     fn fold_item_ty(&@env e, &span sp, ast.ident i,\n                     @ast.ty t, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n-        check (e.type_cache.contains_key(id));\n-        auto typ = e.type_cache.get(id)._1;\n+        check (e.cx.type_cache.contains_key(id));\n+        auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_ty(i, t, ty_params, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n@@ -807,32 +754,51 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                      vec[ast.variant] variants,\n                      vec[ast.ty_param] ty_params,\n                      ast.def_id id, ast.ann a) -> @ast.item {\n-        auto variants_t = get_tag_variant_types(e.sess,\n-                                                e.id_to_ty_item,\n-                                                e.type_cache,\n-                                                id,\n-                                                variants,\n+        auto variants_t = get_tag_variant_types(e.cx, id, variants,\n                                                 ty_params);\n-        auto typ = e.type_cache.get(id)._1;\n+        auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_tag(i, variants_t, ty_params, id,\n                                  ast.ann_type(typ, none[vec[@ty.t]],\n                                               none[@ts_ann]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n-    auto fld_2 = fold.new_identity_fold[@env]();\n-    fld_2 =\n-        @rec(update_env_for_item = bind convert(_,_),\n-             update_env_for_native_item = bind convert_native(_,_),\n-             fold_item_const = bind fold_item_const(_,_,_,_,_,_,_),\n-             fold_item_fn    = bind fold_item_fn(_,_,_,_,_,_,_),\n-             fold_native_item_fn = bind fold_native_item_fn(_,_,_,_,_,_,_,_),\n-             fold_item_obj   = bind fold_item_obj(_,_,_,_,_,_,_),\n-             fold_item_ty    = bind fold_item_ty(_,_,_,_,_,_,_),\n-             fold_item_tag   = bind fold_item_tag(_,_,_,_,_,_,_)\n-             with *fld_2);\n-    auto crate_ = fold.fold_crate[@env](e, fld_2, crate);\n-    ret tup(crate_, type_cache, id_to_ty_item);\n+    fn collect_item_types(session.session sess, @ast.crate crate)\n+            -> tup(@ast.crate, ty.type_cache, @ty_item_table) {\n+        // First pass: collect all type item IDs.\n+        auto module = crate.node.module;\n+        auto id_to_ty_item = @common.new_def_hash[any_item]();\n+\n+        auto fld_1 = fold.new_identity_fold[@ty_item_table]();\n+        fld_1 = @rec(update_env_for_item = bind collect(_, _),\n+                     update_env_for_native_item = bind collect_native(_, _)\n+                     with *fld_1);\n+        fold.fold_crate[@ty_item_table](id_to_ty_item, fld_1, crate);\n+\n+        // Second pass: translate the types of all items.\n+        auto type_cache = common.new_def_hash[ty.ty_param_count_and_ty]();\n+\n+        auto cx = @rec(sess=sess,\n+                       id_to_ty_item=id_to_ty_item,\n+                       type_cache=type_cache);\n+\n+        let @env e = @rec(cx=cx, abi=ast.native_abi_cdecl);\n+\n+        auto fld_2 = fold.new_identity_fold[@env]();\n+        fld_2 =\n+            @rec(update_env_for_item = bind convert(_,_),\n+                 update_env_for_native_item = bind convert_native(_,_),\n+                 fold_item_const = bind fold_item_const(_,_,_,_,_,_,_),\n+                 fold_item_fn    = bind fold_item_fn(_,_,_,_,_,_,_),\n+                 fold_native_item_fn =\n+                    bind fold_native_item_fn(_,_,_,_,_,_,_,_),\n+                 fold_item_obj   = bind fold_item_obj(_,_,_,_,_,_,_),\n+                 fold_item_ty    = bind fold_item_ty(_,_,_,_,_,_,_),\n+                 fold_item_tag   = bind fold_item_tag(_,_,_,_,_,_,_)\n+                 with *fld_2);\n+        auto crate_ = fold.fold_crate[@env](e, fld_2, crate);\n+        ret tup(crate_, type_cache, id_to_ty_item);\n+    }\n }\n \n \n@@ -2750,7 +2716,7 @@ fn eq_unify_cache_entry(&unify_cache_entry a, &unify_cache_entry b) -> bool {\n type typecheck_result = tup(@ast.crate, ty.type_cache);\n \n fn check_crate(session.session sess, @ast.crate crate) -> typecheck_result {\n-    auto result = collect_item_types(sess, crate);\n+    auto result = Collect.collect_item_types(sess, crate);\n \n     let vec[ast.obj_field] fields = vec();\n "}]}