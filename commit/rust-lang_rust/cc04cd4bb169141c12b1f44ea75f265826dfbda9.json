{"sha": "cc04cd4bb169141c12b1f44ea75f265826dfbda9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMDRjZDRiYjE2OTE0MWMxMmIxZjQ0ZWE3NWYyNjU4MjZkZmJkYTk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-29T22:48:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-29T22:48:38Z"}, "message": "rollup merge of #24873: alexcrichton/fix-windows-stdio\n\nConflicts:\n\tsrc/libstd/sys/windows/fs2.rs", "tree": {"sha": "20b1d1e8caf9b8c0525ddcdd46a5e83b467347c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20b1d1e8caf9b8c0525ddcdd46a5e83b467347c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc04cd4bb169141c12b1f44ea75f265826dfbda9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc04cd4bb169141c12b1f44ea75f265826dfbda9", "html_url": "https://github.com/rust-lang/rust/commit/cc04cd4bb169141c12b1f44ea75f265826dfbda9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc04cd4bb169141c12b1f44ea75f265826dfbda9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "873a4e366ddc4da5b9448347bca713bbd43fd578", "url": "https://api.github.com/repos/rust-lang/rust/commits/873a4e366ddc4da5b9448347bca713bbd43fd578", "html_url": "https://github.com/rust-lang/rust/commit/873a4e366ddc4da5b9448347bca713bbd43fd578"}, {"sha": "c1149edf7a448a89d0f38f2802b3201885e52649", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1149edf7a448a89d0f38f2802b3201885e52649", "html_url": "https://github.com/rust-lang/rust/commit/c1149edf7a448a89d0f38f2802b3201885e52649"}], "stats": {"total": 315, "additions": 138, "deletions": 177}, "files": [{"sha": "03a56e2958a6e9f485b050323ac42274b744b9eb", "filename": "src/libstd/sys/windows/fs2.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc04cd4bb169141c12b1f44ea75f265826dfbda9/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc04cd4bb169141c12b1f44ea75f265826dfbda9/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=cc04cd4bb169141c12b1f44ea75f265826dfbda9", "patch": "@@ -65,6 +65,7 @@ pub struct OpenOptions {\n     share_mode: Option<libc::DWORD>,\n     creation_disposition: Option<libc::DWORD>,\n     flags_and_attributes: Option<libc::DWORD>,\n+    security_attributes: usize, // *mut T doesn't have a Default impl\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -169,6 +170,9 @@ impl OpenOptions {\n     pub fn share_mode(&mut self, val: i32) {\n         self.share_mode = Some(val as libc::DWORD);\n     }\n+    pub fn security_attributes(&mut self, attrs: libc::LPSECURITY_ATTRIBUTES) {\n+        self.security_attributes = attrs as usize;\n+    }\n \n     fn get_desired_access(&self) -> libc::DWORD {\n         self.desired_access.unwrap_or({\n@@ -227,7 +231,7 @@ impl File {\n             libc::CreateFileW(path.as_ptr(),\n                               opts.get_desired_access(),\n                               opts.get_share_mode(),\n-                              ptr::null_mut(),\n+                              opts.security_attributes as *mut _,\n                               opts.get_creation_disposition(),\n                               opts.get_flags_and_attributes(),\n                               ptr::null_mut())\n@@ -344,6 +348,8 @@ impl File {\n             Ok(PathBuf::from(OsString::from_wide(subst)))\n         }\n     }\n+\n+    pub fn into_handle(self) -> Handle { self.handle }\n }\n \n impl FromInner<libc::HANDLE> for File {"}, {"sha": "9481e180ce5781a42219c79cd2b79b93ed574c4c", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc04cd4bb169141c12b1f44ea75f265826dfbda9/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc04cd4bb169141c12b1f44ea75f265826dfbda9/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=cc04cd4bb169141c12b1f44ea75f265826dfbda9", "patch": "@@ -12,6 +12,7 @@ use prelude::v1::*;\n \n use io::ErrorKind;\n use io;\n+use libc::funcs::extra::kernel32::{GetCurrentProcess, DuplicateHandle};\n use libc::{self, HANDLE};\n use mem;\n use ptr;\n@@ -65,6 +66,18 @@ impl Handle {\n         }));\n         Ok(amt as usize)\n     }\n+\n+    pub fn duplicate(&self, access: libc::DWORD, inherit: bool,\n+                     options: libc::DWORD) -> io::Result<Handle> {\n+        let mut ret = 0 as libc::HANDLE;\n+        try!(cvt(unsafe {\n+            let cur_proc = GetCurrentProcess();\n+            DuplicateHandle(cur_proc, self.0, cur_proc, &mut ret,\n+                            access, inherit as libc::BOOL,\n+                            options)\n+        }));\n+        Ok(Handle::new(ret))\n+    }\n }\n \n impl Drop for Handle {"}, {"sha": "5aad5f668dd418279642d6f5afd83fc935fabfbf", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 105, "deletions": 173, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/cc04cd4bb169141c12b1f44ea75f265826dfbda9/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc04cd4bb169141c12b1f44ea75f265826dfbda9/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=cc04cd4bb169141c12b1f44ea75f265826dfbda9", "patch": "@@ -13,17 +13,23 @@ use prelude::v1::*;\n use ascii::*;\n use collections::HashMap;\n use collections;\n+use env::split_paths;\n use env;\n use ffi::{OsString, OsStr};\n use fmt;\n use fs;\n use io::{self, Error};\n use libc::{self, c_void};\n+use mem;\n use os::windows::ffi::OsStrExt;\n+use path::Path;\n use ptr;\n use sync::{StaticMutex, MUTEX_INIT};\n+use sys::c;\n+use sys::fs2::{OpenOptions, File};\n use sys::handle::Handle;\n use sys::pipe2::AnonPipe;\n+use sys::stdio;\n use sys::{self, cvt};\n use sys_common::{AsInner, FromInner};\n \n@@ -90,18 +96,12 @@ impl Command {\n // Processes\n ////////////////////////////////////////////////////////////////////////////////\n \n-// `CreateProcess` is racy!\n-// http://support.microsoft.com/kb/315939\n-static CREATE_PROCESS_LOCK: StaticMutex = MUTEX_INIT;\n-\n /// A value representing a child process.\n ///\n /// The lifetime of this value is linked to the lifetime of the actual\n /// process - the Process destructor calls self.finish() which waits\n /// for the process to terminate.\n pub struct Process {\n-    /// A HANDLE to the process, which will prevent the pid being\n-    /// re-used until the handle is closed.\n     handle: Handle,\n }\n \n@@ -112,32 +112,17 @@ pub enum Stdio {\n }\n \n impl Process {\n-    #[allow(deprecated)]\n     pub fn spawn(cfg: &Command,\n-                 in_fd: Stdio,\n-                 out_fd: Stdio,\n-                 err_fd: Stdio) -> io::Result<Process>\n+                 in_handle: Stdio,\n+                 out_handle: Stdio,\n+                 err_handle: Stdio) -> io::Result<Process>\n     {\n-        use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n-        use libc::consts::os::extra::{\n-            TRUE, FALSE,\n-            STARTF_USESTDHANDLES,\n-            INVALID_HANDLE_VALUE,\n-            DUPLICATE_SAME_ACCESS\n-        };\n-        use libc::funcs::extra::kernel32::{\n-            GetCurrentProcess,\n-            DuplicateHandle,\n-            CloseHandle,\n-            CreateProcessW\n-        };\n-\n-        use env::split_paths;\n-        use mem;\n-        use iter::Iterator;\n-\n-        // To have the spawning semantics of unix/windows stay the same, we need to\n-        // read the *child's* PATH if one is provided. See #15149 for more details.\n+        use libc::{TRUE, STARTF_USESTDHANDLES};\n+        use libc::{DWORD, STARTUPINFO, CreateProcessW};\n+\n+        // To have the spawning semantics of unix/windows stay the same, we need\n+        // to read the *child's* PATH if one is provided. See #15149 for more\n+        // details.\n         let program = cfg.env.as_ref().and_then(|env| {\n             for (key, v) in env {\n                 if OsStr::new(\"PATH\") != &**key { continue }\n@@ -156,118 +141,51 @@ impl Process {\n             None\n         });\n \n-        unsafe {\n-            let mut si = zeroed_startupinfo();\n-            si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n-            si.dwFlags = STARTF_USESTDHANDLES;\n-\n-            let cur_proc = GetCurrentProcess();\n-\n-            let set_fd = |fd: &Stdio, slot: &mut HANDLE,\n-                          is_stdin: bool| {\n-                match *fd {\n-                    Stdio::Inherit => {}\n-\n-                    // Similarly to unix, we don't actually leave holes for the\n-                    // stdio file descriptors, but rather open up /dev/null\n-                    // equivalents. These equivalents are drawn from libuv's\n-                    // windows process spawning.\n-                    Stdio::None => {\n-                        let access = if is_stdin {\n-                            libc::FILE_GENERIC_READ\n-                        } else {\n-                            libc::FILE_GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES\n-                        };\n-                        let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n-                        let mut sa = libc::SECURITY_ATTRIBUTES {\n-                            nLength: size as libc::DWORD,\n-                            lpSecurityDescriptor: ptr::null_mut(),\n-                            bInheritHandle: 1,\n-                        };\n-                        let mut filename: Vec<u16> = \"NUL\".utf16_units().collect();\n-                        filename.push(0);\n-                        *slot = libc::CreateFileW(filename.as_ptr(),\n-                                                  access,\n-                                                  libc::FILE_SHARE_READ |\n-                                                      libc::FILE_SHARE_WRITE,\n-                                                  &mut sa,\n-                                                  libc::OPEN_EXISTING,\n-                                                  0,\n-                                                  ptr::null_mut());\n-                        if *slot == INVALID_HANDLE_VALUE {\n-                            return Err(Error::last_os_error())\n-                        }\n-                    }\n-                    Stdio::Piped(ref pipe) => {\n-                        let orig = pipe.handle().raw();\n-                        if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n-                                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-                            return Err(Error::last_os_error())\n-                        }\n-                    }\n-                }\n-                Ok(())\n-            };\n-\n-            try!(set_fd(&in_fd, &mut si.hStdInput, true));\n-            try!(set_fd(&out_fd, &mut si.hStdOutput, false));\n-            try!(set_fd(&err_fd, &mut si.hStdError, false));\n+        let mut si = zeroed_startupinfo();\n+        si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n+        si.dwFlags = STARTF_USESTDHANDLES;\n \n-            let mut cmd_str = make_command_line(program.as_ref().unwrap_or(&cfg.program),\n-                                            &cfg.args);\n-            cmd_str.push(0); // add null terminator\n+        let stdin = try!(in_handle.to_handle(c::STD_INPUT_HANDLE));\n+        let stdout = try!(out_handle.to_handle(c::STD_OUTPUT_HANDLE));\n+        let stderr = try!(err_handle.to_handle(c::STD_ERROR_HANDLE));\n \n-            let mut pi = zeroed_process_information();\n-            let mut create_err = None;\n-\n-            // stolen from the libuv code.\n-            let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n-            if cfg.detach {\n-                flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n-            }\n+        si.hStdInput = stdin.raw();\n+        si.hStdOutput = stdout.raw();\n+        si.hStdError = stderr.raw();\n \n-            with_envp(cfg.env.as_ref(), |envp| {\n-                with_dirp(cfg.cwd.as_ref(), |dirp| {\n-                    let _lock = CREATE_PROCESS_LOCK.lock().unwrap();\n-                    let created = CreateProcessW(ptr::null(),\n-                                                 cmd_str.as_mut_ptr(),\n-                                                 ptr::null_mut(),\n-                                                 ptr::null_mut(),\n-                                                 TRUE,\n-                                                 flags, envp, dirp,\n-                                                 &mut si, &mut pi);\n-                    if created == FALSE {\n-                        create_err = Some(Error::last_os_error());\n-                    }\n-                })\n-            });\n+        let program = program.as_ref().unwrap_or(&cfg.program);\n+        let mut cmd_str = make_command_line(program, &cfg.args);\n+        cmd_str.push(0); // add null terminator\n \n-            if !in_fd.inherited() {\n-                assert!(CloseHandle(si.hStdInput) != 0);\n-            }\n-            if !out_fd.inherited() {\n-                assert!(CloseHandle(si.hStdOutput) != 0);\n-            }\n-            if !err_fd.inherited() {\n-                assert!(CloseHandle(si.hStdError) != 0);\n-            }\n+        // stolen from the libuv code.\n+        let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n+        if cfg.detach {\n+            flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n+        }\n \n-            match create_err {\n-                Some(err) => return Err(err),\n-                None => {}\n-            }\n+        let (envp, _data) = make_envp(cfg.env.as_ref());\n+        let (dirp, _data) = make_dirp(cfg.cwd.as_ref());\n+        let mut pi = zeroed_process_information();\n+        try!(unsafe {\n+            // `CreateProcess` is racy!\n+            // http://support.microsoft.com/kb/315939\n+            static CREATE_PROCESS_LOCK: StaticMutex = MUTEX_INIT;\n+            let _lock = CREATE_PROCESS_LOCK.lock();\n+\n+            cvt(CreateProcessW(ptr::null(),\n+                               cmd_str.as_mut_ptr(),\n+                               ptr::null_mut(),\n+                               ptr::null_mut(),\n+                               TRUE, flags, envp, dirp,\n+                               &mut si, &mut pi))\n+        });\n \n-            // We close the thread handle because we don't care about keeping the\n-            // thread id valid, and we aren't keeping the thread handle around to be\n-            // able to close it later. We don't close the process handle however\n-            // because std::we want the process id to stay valid at least until the\n-            // calling code closes the process handle.\n-            assert!(CloseHandle(pi.hThread) != 0);\n+        // We close the thread handle because we don't care about keeping\n+        // the thread id valid, and we aren't keeping the thread handle\n+        // around to be able to close it later.\n+        drop(Handle::new(pi.hThread));\n \n-            Ok(Process {\n-                handle: Handle::new(pi.hProcess)\n-            })\n-        }\n+        Ok(Process { handle: Handle::new(pi.hProcess) })\n     }\n \n     pub unsafe fn kill(&self) -> io::Result<()> {\n@@ -276,45 +194,25 @@ impl Process {\n     }\n \n     pub fn wait(&self) -> io::Result<ExitStatus> {\n-        use libc::consts::os::extra::{\n-            FALSE,\n-            STILL_ACTIVE,\n-            INFINITE,\n-            WAIT_OBJECT_0,\n-        };\n-        use libc::funcs::extra::kernel32::{\n-            GetExitCodeProcess,\n-            WaitForSingleObject,\n-        };\n+        use libc::{STILL_ACTIVE, INFINITE, WAIT_OBJECT_0};\n+        use libc::{GetExitCodeProcess, WaitForSingleObject};\n \n         unsafe {\n             loop {\n                 let mut status = 0;\n-                if GetExitCodeProcess(self.handle.raw(), &mut status) == FALSE {\n-                    let err = Err(Error::last_os_error());\n-                    return err;\n-                }\n+                try!(cvt(GetExitCodeProcess(self.handle.raw(), &mut status)));\n                 if status != STILL_ACTIVE {\n                     return Ok(ExitStatus(status as i32));\n                 }\n                 match WaitForSingleObject(self.handle.raw(), INFINITE) {\n                     WAIT_OBJECT_0 => {}\n-                    _ => {\n-                        let err = Err(Error::last_os_error());\n-                        return err\n-                    }\n+                    _ => return Err(Error::last_os_error()),\n                 }\n             }\n         }\n     }\n }\n \n-impl Stdio {\n-    fn inherited(&self) -> bool {\n-        match *self { Stdio::Inherit => true, _ => false }\n-    }\n-}\n-\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub struct ExitStatus(i32);\n \n@@ -415,9 +313,8 @@ fn make_command_line(prog: &OsStr, args: &[OsString]) -> Vec<u16> {\n     }\n }\n \n-fn with_envp<F, T>(env: Option<&collections::HashMap<OsString, OsString>>, cb: F) -> T\n-    where F: FnOnce(*mut c_void) -> T,\n-{\n+fn make_envp(env: Option<&collections::HashMap<OsString, OsString>>)\n+             -> (*mut c_void, Vec<u16>) {\n     // On Windows we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n@@ -432,22 +329,57 @@ fn with_envp<F, T>(env: Option<&collections::HashMap<OsString, OsString>>, cb: F\n                 blk.push(0);\n             }\n             blk.push(0);\n-            cb(blk.as_mut_ptr() as *mut c_void)\n+            (blk.as_mut_ptr() as *mut c_void, blk)\n         }\n-        _ => cb(ptr::null_mut())\n+        _ => (ptr::null_mut(), Vec::new())\n     }\n }\n \n-fn with_dirp<T, F>(d: Option<&OsString>, cb: F) -> T where\n-    F: FnOnce(*const u16) -> T,\n-{\n+fn make_dirp(d: Option<&OsString>) -> (*const u16, Vec<u16>) {\n     match d {\n-      Some(dir) => {\n-          let mut dir_str: Vec<u16> = dir.encode_wide().collect();\n-          dir_str.push(0);\n-          cb(dir_str.as_ptr())\n-      },\n-      None => cb(ptr::null())\n+        Some(dir) => {\n+            let mut dir_str: Vec<u16> = dir.encode_wide().collect();\n+            dir_str.push(0);\n+            (dir_str.as_ptr(), dir_str)\n+        },\n+        None => (ptr::null(), Vec::new())\n+    }\n+}\n+\n+impl Stdio {\n+    fn to_handle(&self, stdio_id: libc::DWORD) -> io::Result<Handle> {\n+        use libc::DUPLICATE_SAME_ACCESS;\n+\n+        match *self {\n+            Stdio::Inherit => {\n+                stdio::get(stdio_id).and_then(|io| {\n+                    io.handle().duplicate(0, true, DUPLICATE_SAME_ACCESS)\n+                })\n+            }\n+            Stdio::Piped(ref pipe) => {\n+                pipe.handle().duplicate(0, true, DUPLICATE_SAME_ACCESS)\n+            }\n+\n+            // Similarly to unix, we don't actually leave holes for the\n+            // stdio file descriptors, but rather open up /dev/null\n+            // equivalents. These equivalents are drawn from libuv's\n+            // windows process spawning.\n+            Stdio::None => {\n+                let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n+                let mut sa = libc::SECURITY_ATTRIBUTES {\n+                    nLength: size as libc::DWORD,\n+                    lpSecurityDescriptor: ptr::null_mut(),\n+                    bInheritHandle: 1,\n+                };\n+                let mut opts = OpenOptions::new();\n+                opts.read(stdio_id == c::STD_INPUT_HANDLE);\n+                opts.write(stdio_id != c::STD_INPUT_HANDLE);\n+                opts.security_attributes(&mut sa);\n+                File::open(Path::new(\"NUL\"), &opts).map(|file| {\n+                    file.into_handle()\n+                })\n+            }\n+        }\n     }\n }\n "}, {"sha": "03547165f5d8700aa3f3939b8511db9cb237724e", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc04cd4bb169141c12b1f44ea75f265826dfbda9/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc04cd4bb169141c12b1f44ea75f265826dfbda9/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=cc04cd4bb169141c12b1f44ea75f265826dfbda9", "patch": "@@ -21,9 +21,9 @@ use sys::c;\n use sys::cvt;\n use sys::handle::Handle;\n \n-struct NoClose(Option<Handle>);\n+pub struct NoClose(Option<Handle>);\n \n-enum Output {\n+pub enum Output {\n     Console(NoClose),\n     Pipe(NoClose),\n }\n@@ -35,7 +35,7 @@ pub struct Stdin {\n pub struct Stdout(Output);\n pub struct Stderr(Output);\n \n-fn get(handle: libc::DWORD) -> io::Result<Output> {\n+pub fn get(handle: libc::DWORD) -> io::Result<Output> {\n     let handle = unsafe { c::GetStdHandle(handle) };\n     if handle == libc::INVALID_HANDLE_VALUE {\n         Err(io::Error::last_os_error())\n@@ -159,6 +159,16 @@ impl Drop for NoClose {\n     }\n }\n \n+impl Output {\n+    pub fn handle(&self) -> &Handle {\n+        let nc = match *self {\n+            Output::Console(ref c) => c,\n+            Output::Pipe(ref c) => c,\n+        };\n+        nc.0.as_ref().unwrap()\n+    }\n+}\n+\n fn invalid_encoding() -> io::Error {\n     io::Error::new(io::ErrorKind::InvalidInput, \"text was not valid unicode\")\n }"}]}