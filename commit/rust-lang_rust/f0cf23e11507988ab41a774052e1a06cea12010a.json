{"sha": "f0cf23e11507988ab41a774052e1a06cea12010a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwY2YyM2UxMTUwNzk4OGFiNDFhNzc0MDUyZTFhMDZjZWExMjAxMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-22T23:34:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-22T23:34:29Z"}, "message": "Auto merge of #46842 - michaelwoerister:fingerprint-vec, r=nikomatsakis\n\nincr.comp.: Use an array instead of a hashmap for storing result hashes.\n\nDoing so should result in some of the core tracking components being faster.\n\nr? @nikomatsakis", "tree": {"sha": "8bac33a9fcf6b325b6b0d785c8564e864e7044e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bac33a9fcf6b325b6b0d785c8564e864e7044e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0cf23e11507988ab41a774052e1a06cea12010a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0cf23e11507988ab41a774052e1a06cea12010a", "html_url": "https://github.com/rust-lang/rust/commit/f0cf23e11507988ab41a774052e1a06cea12010a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0cf23e11507988ab41a774052e1a06cea12010a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5165ee9e209e0e70d89946ccbb7e90b9c0c3a7ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/5165ee9e209e0e70d89946ccbb7e90b9c0c3a7ac", "html_url": "https://github.com/rust-lang/rust/commit/5165ee9e209e0e70d89946ccbb7e90b9c0c3a7ac"}, {"sha": "b2f72394ce4755cf145afc116077b32aaaed61b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2f72394ce4755cf145afc116077b32aaaed61b1", "html_url": "https://github.com/rust-lang/rust/commit/b2f72394ce4755cf145afc116077b32aaaed61b1"}], "stats": {"total": 202, "additions": 129, "deletions": 73}, "files": [{"sha": "29839bb565bb459dc2ac97dc06adbcb27e6c9361", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -279,7 +279,7 @@ macro_rules! define_dep_nodes {\n \n                             DepNode {\n                                 kind: DepKind::$variant,\n-                                hash: Fingerprint::zero(),\n+                                hash: Fingerprint::ZERO,\n                             }\n                         }\n                     )*\n@@ -308,7 +308,7 @@ macro_rules! define_dep_nodes {\n                 assert!(!kind.has_params());\n                 DepNode {\n                     kind,\n-                    hash: Fingerprint::zero(),\n+                    hash: Fingerprint::ZERO,\n                 }\n             }\n "}, {"sha": "7acb466e9f38b203a63d34efb78ea4424f3e7b03", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 73, "deletions": 37, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -34,14 +34,11 @@ use super::prev::PreviousDepGraph;\n pub struct DepGraph {\n     data: Option<Rc<DepGraphData>>,\n \n-    // At the moment we are using DepNode as key here. In the future it might\n-    // be possible to use an IndexVec<DepNodeIndex, _> here. At the moment there\n-    // are a few problems with that:\n-    // - Some fingerprints are needed even if incr. comp. is disabled -- yet\n-    //   we need to have a dep-graph to generate DepNodeIndices.\n-    // - The architecture is still in flux and it's not clear what how to best\n-    //   implement things.\n-    fingerprints: Rc<RefCell<FxHashMap<DepNode, Fingerprint>>>\n+    // A vector mapping depnodes from the current graph to their associated\n+    // result value fingerprints. Do not rely on the length of this vector\n+    // being the same as the number of nodes in the graph. The vector can\n+    // contain an arbitrary number of zero-entries at the end.\n+    fingerprints: Rc<RefCell<IndexVec<DepNodeIndex, Fingerprint>>>\n }\n \n \n@@ -97,6 +94,11 @@ struct DepGraphData {\n impl DepGraph {\n \n     pub fn new(prev_graph: PreviousDepGraph) -> DepGraph {\n+        // Pre-allocate the fingerprints array. We over-allocate a little so\n+        // that we hopefully don't have to re-allocate during this compilation\n+        // session.\n+        let fingerprints = IndexVec::from_elem_n(Fingerprint::ZERO,\n+                                                 (prev_graph.node_count() * 115) / 100);\n         DepGraph {\n             data: Some(Rc::new(DepGraphData {\n                 previous_work_products: RefCell::new(FxHashMap()),\n@@ -107,14 +109,14 @@ impl DepGraph {\n                 colors: RefCell::new(FxHashMap()),\n                 loaded_from_cache: RefCell::new(FxHashMap()),\n             })),\n-            fingerprints: Rc::new(RefCell::new(FxHashMap())),\n+            fingerprints: Rc::new(RefCell::new(fingerprints)),\n         }\n     }\n \n     pub fn new_disabled() -> DepGraph {\n         DepGraph {\n             data: None,\n-            fingerprints: Rc::new(RefCell::new(FxHashMap())),\n+            fingerprints: Rc::new(RefCell::new(IndexVec::new())),\n         }\n     }\n \n@@ -231,12 +233,16 @@ impl DepGraph {\n \n             // Store the current fingerprint\n             {\n-                let old_value = self.fingerprints\n-                                    .borrow_mut()\n-                                    .insert(key, current_fingerprint);\n-                debug_assert!(old_value.is_none(),\n+                let mut fingerprints = self.fingerprints.borrow_mut();\n+\n+                if dep_node_index.index() >= fingerprints.len() {\n+                    fingerprints.resize(dep_node_index.index() + 1, Fingerprint::ZERO);\n+                }\n+\n+                debug_assert!(fingerprints[dep_node_index] == Fingerprint::ZERO,\n                               \"DepGraph::with_task() - Duplicate fingerprint \\\n                                insertion for {:?}\", key);\n+                fingerprints[dep_node_index] = current_fingerprint;\n             }\n \n             // Determine the color of the new DepNode.\n@@ -262,13 +268,15 @@ impl DepGraph {\n                 let result = task(cx, arg);\n                 let mut stable_hasher = StableHasher::new();\n                 result.hash_stable(&mut hcx, &mut stable_hasher);\n-                let old_value = self.fingerprints\n-                                    .borrow_mut()\n-                                    .insert(key, stable_hasher.finish());\n-                debug_assert!(old_value.is_none(),\n-                              \"DepGraph::with_task() - Duplicate fingerprint \\\n-                               insertion for {:?}\", key);\n-                (result, DepNodeIndex::INVALID)\n+                let fingerprint = stable_hasher.finish();\n+\n+                let mut fingerprints = self.fingerprints.borrow_mut();\n+                let dep_node_index = DepNodeIndex::new(fingerprints.len());\n+                fingerprints.push(fingerprint);\n+                debug_assert!(fingerprints[dep_node_index] == fingerprint,\n+                              \"DepGraph::with_task() - Assigned fingerprint to \\\n+                               unexpected index for {:?}\", key);\n+                (result, dep_node_index)\n             } else {\n                 (task(cx, arg), DepNodeIndex::INVALID)\n             }\n@@ -328,11 +336,29 @@ impl DepGraph {\n     }\n \n     #[inline]\n-    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Fingerprint {\n-        match self.fingerprints.borrow().get(dep_node) {\n+    pub fn dep_node_index_of(&self, dep_node: &DepNode) -> DepNodeIndex {\n+        self.data\n+            .as_ref()\n+            .unwrap()\n+            .current\n+            .borrow_mut()\n+            .node_to_node_index\n+            .get(dep_node)\n+            .cloned()\n+            .unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n+        match self.fingerprints.borrow().get(dep_node_index) {\n             Some(&fingerprint) => fingerprint,\n             None => {\n-                bug!(\"Could not find current fingerprint for {:?}\", dep_node)\n+                if let Some(ref data) = self.data {\n+                    let dep_node = data.current.borrow().nodes[dep_node_index];\n+                    bug!(\"Could not find current fingerprint for {:?}\", dep_node)\n+                } else {\n+                    bug!(\"Could not find current fingerprint for {:?}\", dep_node_index)\n+                }\n             }\n         }\n     }\n@@ -420,14 +446,17 @@ impl DepGraph {\n     }\n \n     pub fn serialize(&self) -> SerializedDepGraph {\n-        let fingerprints = self.fingerprints.borrow();\n+        let mut fingerprints = self.fingerprints.borrow_mut();\n         let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n \n-        let nodes: IndexVec<_, _> = current_dep_graph.nodes.iter().map(|dep_node| {\n-            let fingerprint = fingerprints.get(dep_node)\n-                                          .cloned()\n-                                          .unwrap_or(Fingerprint::zero());\n-            (*dep_node, fingerprint)\n+        // Make sure we don't run out of bounds below.\n+        if current_dep_graph.nodes.len() > fingerprints.len() {\n+            fingerprints.resize(current_dep_graph.nodes.len(), Fingerprint::ZERO);\n+        }\n+\n+        let nodes: IndexVec<_, (DepNode, Fingerprint)> =\n+            current_dep_graph.nodes.iter_enumerated().map(|(idx, &dep_node)| {\n+            (dep_node, fingerprints[idx])\n         }).collect();\n \n         let total_edge_count: usize = current_dep_graph.edges.iter()\n@@ -610,13 +639,20 @@ impl DepGraph {\n \n         // ... copying the fingerprint from the previous graph too, so we don't\n         // have to recompute it ...\n-        let fingerprint = data.previous.fingerprint_by_index(prev_dep_node_index);\n-        let old_fingerprint = self.fingerprints\n-                                  .borrow_mut()\n-                                  .insert(*dep_node, fingerprint);\n-        debug_assert!(old_fingerprint.is_none(),\n-                      \"DepGraph::try_mark_green() - Duplicate fingerprint \\\n-                      insertion for {:?}\", dep_node);\n+        {\n+            let fingerprint = data.previous.fingerprint_by_index(prev_dep_node_index);\n+            let mut fingerprints = self.fingerprints.borrow_mut();\n+\n+            if dep_node_index.index() >= fingerprints.len() {\n+                fingerprints.resize(dep_node_index.index() + 1, Fingerprint::ZERO);\n+            }\n+\n+            debug_assert!(fingerprints[dep_node_index] == Fingerprint::ZERO,\n+                \"DepGraph::try_mark_green() - Duplicate fingerprint \\\n+                insertion for {:?}\", dep_node);\n+\n+            fingerprints[dep_node_index] = fingerprint;\n+        }\n \n         // ... emitting any stored diagnostic ...\n         {"}, {"sha": "50e1ee88a4614ce701f9ed34ad7ac02e483175da", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -62,4 +62,8 @@ impl PreviousDepGraph {\n                                 -> Fingerprint {\n         self.data.nodes[dep_node_index].1\n     }\n+\n+    pub fn node_count(&self) -> usize {\n+        self.index.len()\n+    }\n }"}, {"sha": "0e1c66277163ea6a19ffaee6a20c993aedeff7a2", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -12,6 +12,7 @@ use super::*;\n \n use dep_graph::{DepGraph, DepKind, DepNodeIndex};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n+use hir::svh::Svh;\n use middle::cstore::CrateStore;\n use session::CrateDisambiguator;\n use std::iter::repeat;\n@@ -44,7 +45,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n \n     // We are collecting DepNode::HirBody hashes here so we can compute the\n     // crate hash from then later on.\n-    hir_body_nodes: Vec<DefPathHash>,\n+    hir_body_nodes: Vec<(DefPathHash, DepNodeIndex)>,\n }\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n@@ -99,7 +100,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             );\n         }\n \n-        let hir_body_nodes = vec![root_mod_def_path_hash];\n+        let hir_body_nodes = vec![(root_mod_def_path_hash, root_mod_full_dep_index)];\n \n         let mut collector = NodeCollector {\n             krate,\n@@ -123,13 +124,12 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                                                   crate_disambiguator: CrateDisambiguator,\n                                                   cstore: &CrateStore,\n                                                   commandline_args_hash: u64)\n-                                                  -> Vec<MapEntry<'hir>> {\n+                                                  -> (Vec<MapEntry<'hir>>, Svh) {\n         let mut node_hashes: Vec<_> = self\n             .hir_body_nodes\n             .iter()\n-            .map(|&def_path_hash| {\n-                let dep_node = def_path_hash.to_dep_node(DepKind::HirBody);\n-                (def_path_hash, self.dep_graph.fingerprint_of(&dep_node))\n+            .map(|&(def_path_hash, dep_node_index)| {\n+                (def_path_hash, self.dep_graph.fingerprint_of(dep_node_index))\n             })\n             .collect();\n \n@@ -147,13 +147,19 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             (name1, dis1).cmp(&(name2, dis2))\n         });\n \n-        self.dep_graph.with_task(DepNode::new_no_params(DepKind::Krate),\n-                                 &self.hcx,\n-                                 ((node_hashes, upstream_crates),\n-                                  (commandline_args_hash,\n-                                   crate_disambiguator.to_fingerprint())),\n-                                 identity_fn);\n-        self.map\n+        let (_, crate_dep_node_index) = self\n+            .dep_graph\n+            .with_task(DepNode::new_no_params(DepKind::Krate),\n+                       &self.hcx,\n+                       ((node_hashes, upstream_crates),\n+                        (commandline_args_hash,\n+                         crate_disambiguator.to_fingerprint())),\n+                       identity_fn);\n+\n+        let svh = Svh::new(self.dep_graph\n+                               .fingerprint_of(crate_dep_node_index)\n+                               .to_smaller_hash());\n+        (self.map, svh)\n     }\n \n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'hir>) {\n@@ -255,7 +261,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             identity_fn\n         ).1;\n \n-        self.hir_body_nodes.push(def_path_hash);\n+        self.hir_body_nodes.push((def_path_hash, self.current_full_dep_index));\n \n         self.current_dep_node_owner = dep_node_owner;\n         self.currently_in_body = false;"}, {"sha": "33debf6aeb0dde53cdbd1e7bfe8e2a75acdd593f", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -26,6 +26,7 @@ use syntax_pos::Span;\n \n use hir::*;\n use hir::print::Nested;\n+use hir::svh::Svh;\n use util::nodemap::{DefIdMap, FxHashMap};\n \n use arena::TypedArena;\n@@ -241,6 +242,9 @@ pub struct Map<'hir> {\n     /// deref. This is a gratuitous micro-optimization.\n     pub dep_graph: DepGraph,\n \n+    /// The SVH of the local crate.\n+    pub crate_hash: Svh,\n+\n     /// NodeIds are sequential integers from 0, so we can be\n     /// super-compact by storing them in a vector. Not everything with\n     /// a NodeId is in the map, but empirically the occupancy is about\n@@ -1048,7 +1052,7 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n                        forest: &'hir mut Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {\n-    let map = {\n+    let (map, crate_hash) = {\n         let hcx = ::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n \n         let mut collector = NodeCollector::root(&forest.krate,\n@@ -1087,6 +1091,7 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n     let map = Map {\n         forest,\n         dep_graph: forest.dep_graph.clone(),\n+        crate_hash,\n         map,\n         hir_to_node_id,\n         definitions,"}, {"sha": "dc7b9dbe2ef1526e327e2ec6068157ccb7126533", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -14,10 +14,8 @@ use rustc_data_structures::stable_hasher;\n pub struct Fingerprint(u64, u64);\n \n impl Fingerprint {\n-    #[inline]\n-    pub fn zero() -> Fingerprint {\n-        Fingerprint(0, 0)\n-    }\n+\n+    pub const ZERO: Fingerprint = Fingerprint(0, 0);\n \n     #[inline]\n     pub fn from_smaller_hash(hash: u64) -> Fingerprint {"}, {"sha": "5d7a050267f2c6af766e730d4da378fd96984abe", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -438,7 +438,7 @@ macro_rules! define_maps {\n                     use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n                     use ich::Fingerprint;\n \n-                    assert!(Some(tcx.dep_graph.fingerprint_of(dep_node)) ==\n+                    assert!(Some(tcx.dep_graph.fingerprint_of(dep_node_index)) ==\n                             tcx.dep_graph.prev_fingerprint_of(dep_node),\n                             \"Fingerprint for green query instance not loaded \\\n                              from cache: {:?}\", dep_node);\n@@ -452,7 +452,7 @@ macro_rules! define_maps {\n                     let new_hash: Fingerprint = hasher.finish();\n                     debug!(\"END verify_ich({:?})\", dep_node);\n \n-                    let old_hash = tcx.dep_graph.fingerprint_of(dep_node);\n+                    let old_hash = tcx.dep_graph.fingerprint_of(dep_node_index);\n \n                     assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n                         for {:?}\", dep_node);"}, {"sha": "329dc6b502598524833f11f16e3a10f5bde50727", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -19,6 +19,7 @@ use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use hir::map::DefPathData;\n+use hir::svh::Svh;\n use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n@@ -2669,6 +2670,13 @@ fn original_crate_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.crate_name.clone()\n }\n \n+fn crate_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        crate_num: CrateNum)\n+                        -> Svh {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    tcx.hir.crate_hash\n+}\n+\n pub fn provide(providers: &mut ty::maps::Providers) {\n     context::provide(providers);\n     erase_regions::provide(providers);\n@@ -2684,6 +2692,7 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         trait_of_item,\n         crate_disambiguator,\n         original_crate_name,\n+        crate_hash,\n         trait_impls_of: trait_def::trait_impls_of_provider,\n         ..*providers\n     };"}, {"sha": "b17503137f508caf3979def53b0e47bcb238f1f9", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -480,7 +480,8 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     fn assert_dirty(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n-        let current_fingerprint = self.tcx.dep_graph.fingerprint_of(&dep_node);\n+        let dep_node_index = self.tcx.dep_graph.dep_node_index_of(&dep_node);\n+        let current_fingerprint = self.tcx.dep_graph.fingerprint_of(dep_node_index);\n         let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n \n         if Some(current_fingerprint) == prev_fingerprint {\n@@ -494,7 +495,8 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     fn assert_clean(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n-        let current_fingerprint = self.tcx.dep_graph.fingerprint_of(&dep_node);\n+        let dep_node_index = self.tcx.dep_graph.dep_node_index_of(&dep_node);\n+        let current_fingerprint = self.tcx.dep_graph.fingerprint_of(dep_node_index);\n         let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n \n         if Some(current_fingerprint) != prev_fingerprint {"}, {"sha": "fb4a73891a34e5bc5f2bcb3180b3c1845637a330", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -781,7 +781,7 @@ impl<'a, 'tcx> CrateMetadata {\n         } else {\n             ExternBodyNestedBodies {\n                 nested_bodies: Rc::new(BTreeMap::new()),\n-                fingerprint: Fingerprint::zero(),\n+                fingerprint: Fingerprint::ZERO,\n             }\n         }\n     }"}, {"sha": "0efe5f9a5cb6fc04d9c815c5788008c712ac0391", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -43,7 +43,7 @@ use rustc::middle::cstore::{EncodedMetadata};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n use rustc::ty::maps::Providers;\n-use rustc::dep_graph::{DepNode, DepKind, DepConstructor};\n+use rustc::dep_graph::{DepNode, DepConstructor};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo};\n@@ -709,8 +709,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let crate_hash = tcx.dep_graph\n-                        .fingerprint_of(&DepNode::new_no_params(DepKind::Krate));\n+    let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n     let link_meta = link::build_link_meta(crate_hash);\n     let exported_symbol_node_ids = find_exported_symbols(tcx);\n "}, {"sha": "643494e411d23ed410dd76482e59573e26dd3fcc", "filename": "src/librustc_trans_utils/link.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc_trans_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc_trans_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flink.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::ich::Fingerprint;\n use rustc::session::config::{self, OutputFilenames, Input, OutputType};\n use rustc::session::Session;\n use rustc::middle::cstore::{self, LinkMeta};\n@@ -50,9 +49,9 @@ fn is_writeable(p: &Path) -> bool {\n     }\n }\n \n-pub fn build_link_meta(crate_hash: Fingerprint) -> LinkMeta {\n+pub fn build_link_meta(crate_hash: Svh) -> LinkMeta {\n     let r = LinkMeta {\n-        crate_hash: Svh::new(crate_hash.to_smaller_hash()),\n+        crate_hash,\n     };\n     info!(\"{:?}\", r);\n     return r;"}, {"sha": "122914fa40b52e68ddc79c1fec2d1e083a9f4d01", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0cf23e11507988ab41a774052e1a06cea12010a/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=f0cf23e11507988ab41a774052e1a06cea12010a", "patch": "@@ -41,7 +41,7 @@ use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::cstore::MetadataLoader as MetadataLoaderTrait;\n-use rustc::dep_graph::{DepGraph, DepNode, DepKind};\n+use rustc::dep_graph::DepGraph;\n use rustc_back::target::Target;\n use link::{build_link_meta, out_filename};\n \n@@ -197,9 +197,7 @@ impl TransCrate for MetadataOnlyTransCrate {\n         let _ = tcx.native_libraries(LOCAL_CRATE);\n         tcx.sess.abort_if_errors();\n \n-        let crate_hash = tcx.dep_graph\n-                        .fingerprint_of(&DepNode::new_no_params(DepKind::Krate));\n-        let link_meta = build_link_meta(crate_hash);\n+        let link_meta = build_link_meta(tcx.crate_hash(LOCAL_CRATE));\n         let exported_symbols = ::find_exported_symbols(tcx);\n         let metadata = tcx.encode_metadata(&link_meta, &exported_symbols);\n "}]}