{"sha": "b03ccace573bb91e27625c190a0f7807045a1012", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwM2NjYWNlNTczYmI5MWUyNzYyNWMxOTBhMGY3ODA3MDQ1YTEwMTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-24T20:49:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-24T20:49:55Z"}, "message": "Auto merge of #88266 - nikomatsakis:issue-87879, r=jackh726\n\nresolve type variables after checking casts\n\nr? `@jackh726`\n\nFixes #87814\nFixes #88118\n\nSupercedes #87879 (cc `@ldm0)`", "tree": {"sha": "adc092773653dca60719e5f20a09d258c3d7a8db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adc092773653dca60719e5f20a09d258c3d7a8db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b03ccace573bb91e27625c190a0f7807045a1012", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b03ccace573bb91e27625c190a0f7807045a1012", "html_url": "https://github.com/rust-lang/rust/commit/b03ccace573bb91e27625c190a0f7807045a1012", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b03ccace573bb91e27625c190a0f7807045a1012/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0599f3403366d9c57f0625e6de3af214b5042a90", "url": "https://api.github.com/repos/rust-lang/rust/commits/0599f3403366d9c57f0625e6de3af214b5042a90", "html_url": "https://github.com/rust-lang/rust/commit/0599f3403366d9c57f0625e6de3af214b5042a90"}, {"sha": "ec9531bcb09e52c5fbbabbedc8927b99f7e6fd9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec9531bcb09e52c5fbbabbedc8927b99f7e6fd9c", "html_url": "https://github.com/rust-lang/rust/commit/ec9531bcb09e52c5fbbabbedc8927b99f7e6fd9c"}], "stats": {"total": 77, "additions": 69, "deletions": 8}, "files": [{"sha": "01227cad334fc783e12d0f79ef97b63a5150ae32", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=b03ccace573bb91e27625c190a0f7807045a1012", "patch": "@@ -14,6 +14,7 @@ use rustc_trait_selection::traits::{\n };\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn check_match(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n@@ -26,6 +27,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let acrb = arms_contain_ref_bindings(arms);\n         let scrutinee_ty = self.demand_scrutinee_type(scrut, acrb, arms.is_empty());\n+        debug!(?scrutinee_ty);\n \n         // If there are no arms, that is a diverging match; a special case.\n         if arms.is_empty() {"}, {"sha": "14550690e63e01e542cfab488bb84b2f480d1679", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=b03ccace573bb91e27625c190a0f7807045a1012", "patch": "@@ -51,6 +51,7 @@ use rustc_trait_selection::traits::error_reporting::report_object_safety_error;\n \n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n+#[derive(Debug)]\n pub struct CastCheck<'tcx> {\n     expr: &'tcx hir::Expr<'tcx>,\n     expr_ty: Ty<'tcx>,\n@@ -603,12 +604,11 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         });\n     }\n \n+    #[instrument(skip(fcx), level = \"debug\")]\n     pub fn check(mut self, fcx: &FnCtxt<'a, 'tcx>) {\n         self.expr_ty = fcx.structurally_resolved_type(self.expr.span, self.expr_ty);\n         self.cast_ty = fcx.structurally_resolved_type(self.cast_span, self.cast_ty);\n \n-        debug!(\"check_cast({}, {:?} as {:?})\", self.expr.hir_id, self.expr_ty, self.cast_ty);\n-\n         if !fcx.type_is_known_to_be_sized_modulo_regions(self.cast_ty, self.span) {\n             self.report_cast_to_unsized_type(fcx);\n         } else if self.expr_ty.references_error() || self.cast_ty.references_error() {"}, {"sha": "17a81486048ed1788cab6a1149234e5b898fead1", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=b03ccace573bb91e27625c190a0f7807045a1012", "patch": "@@ -1328,6 +1328,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     /// The inner coercion \"engine\". If `expression` is `None`, this\n     /// is a forced-unit case, and hence `expression_ty` must be\n     /// `Nil`.\n+    #[instrument(skip(self, fcx, augment_error, label_expression_as_expected), level = \"debug\")]\n     crate fn coerce_inner<'a>(\n         &mut self,\n         fcx: &FnCtxt<'a, 'tcx>,"}, {"sha": "eaf24552355d453d0ef42a97b1fd8875fe6c9561", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=b03ccace573bb91e27625c190a0f7807045a1012", "patch": "@@ -156,12 +156,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Note that inspecting a type's structure *directly* may expose the fact\n     /// that there are actually multiple representations for `Error`, so avoid\n     /// that when err needs to be handled differently.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub(super) fn check_expr_with_expectation(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        debug!(\">> type-checking: expected={:?}, expr={:?} \", expected, expr);\n+        if self.tcx().sess.verbose() {\n+            // make this code only run with -Zverbose because it is probably slow\n+            if let Ok(lint_str) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n+                if !lint_str.contains(\"\\n\") {\n+                    debug!(\"expr text: {}\", lint_str);\n+                } else {\n+                    let mut lines = lint_str.lines();\n+                    if let Some(line0) = lines.next() {\n+                        let remaining_lines = lines.count();\n+                        debug!(\"expr text: {}\", line0);\n+                        debug!(\"expr text: ...(and {} more lines)\", remaining_lines);\n+                    }\n+                }\n+            }\n+        }\n \n         // True if `expr` is a `Try::from_ok(())` that is a result of desugaring a try block\n         // without the final expr (e.g. `try { return; }`). We don't want to generate an\n@@ -1039,7 +1054,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let t_cast = self.to_ty_saving_user_provided_ty(t);\n         let t_cast = self.resolve_vars_if_possible(t_cast);\n         let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n-        let t_cast = self.resolve_vars_if_possible(t_cast);\n+        let t_expr = self.resolve_vars_if_possible(t_expr);\n \n         // Eagerly check for some obvious errors.\n         if t_expr.references_error() || t_cast.references_error() {\n@@ -1049,6 +1064,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n             match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n                 Ok(cast_check) => {\n+                    debug!(\n+                        \"check_expr_cast: deferring cast from {:?} to {:?}: {:?}\",\n+                        t_cast, t_expr, cast_check,\n+                    );\n                     deferred_cast_checks.push(cast_check);\n                     t_cast\n                 }"}, {"sha": "8f6cdc7bb12a7243ab97820e956a4e185c43330d", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=b03ccace573bb91e27625c190a0f7807045a1012", "patch": "@@ -3,7 +3,9 @@ use rustc_infer::infer::type_variable::Diverging;\n use rustc_middle::ty::{self, Ty};\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n-    pub(super) fn type_inference_fallback(&self) {\n+    /// Performs type inference fallback, returning true if any fallback\n+    /// occurs.\n+    pub(super) fn type_inference_fallback(&self) -> bool {\n         // All type checking constraints were added, try to fallback unsolved variables.\n         self.select_obligations_where_possible(false, |_| {});\n         let mut fallback_has_occurred = false;\n@@ -50,6 +52,8 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n \n         // See if we can make any more progress.\n         self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n+\n+        fallback_has_occurred\n     }\n \n     // Tries to apply a fallback to `ty` if it is an unsolved variable."}, {"sha": "b624e07374ec7b010e5af881b6d401618c5c8bd4", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=b03ccace573bb91e27625c190a0f7807045a1012", "patch": "@@ -29,6 +29,7 @@ use std::slice;\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&self) {\n         let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n+        debug!(\"FnCtxt::check_casts: {} deferred checks\", deferred_cast_checks.len());\n         for cast in deferred_cast_checks.drain(..) {\n             cast.check(self);\n         }"}, {"sha": "a88b1c7af5a96640f49b498fd536d0524ea57834", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=b03ccace573bb91e27625c190a0f7807045a1012", "patch": "@@ -446,11 +446,12 @@ fn typeck_with_fallback<'tcx>(\n             fcx\n         };\n \n-        fcx.type_inference_fallback();\n+        let fallback_has_occurred = fcx.type_inference_fallback();\n \n         // Even though coercion casts provide type hints, we check casts after fallback for\n         // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n         fcx.check_casts();\n+        fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n \n         // Closure and generator analysis may run after fallback\n         // because they don't constrain other type variables."}, {"sha": "cd00d181ed0464bb41020fa95fd3b8c1b7e4249a", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03ccace573bb91e27625c190a0f7807045a1012/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=b03ccace573bb91e27625c190a0f7807045a1012", "patch": "@@ -120,9 +120,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn consume_body(&mut self, body: &hir::Body<'_>) {\n-        debug!(\"consume_body(body={:?})\", body);\n-\n         for param in body.params {\n             let param_ty = return_if_err!(self.mc.pat_ty_adjusted(&param.pat));\n             debug!(\"consume_body: param_ty = {:?}\", param_ty);"}, {"sha": "453b7e04a369b48800a59cfaefd42476af364ca0", "filename": "src/test/ui/closures/2229_closure_analysis/issue_88118.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b03ccace573bb91e27625c190a0f7807045a1012/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue_88118.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03ccace573bb91e27625c190a0f7807045a1012/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue_88118.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fissue_88118.rs?ref=b03ccace573bb91e27625c190a0f7807045a1012", "patch": "@@ -0,0 +1,15 @@\n+// Regression test for #88118. Used to ICE.\n+//\n+// check-pass\n+\n+#![allow(incomplete_features)]\n+#![feature(capture_disjoint_fields)]\n+\n+fn foo<MsU>(handler: impl FnOnce() -> MsU + Clone + 'static) {\n+    Box::new(move |value| {\n+        (|_| handler.clone()())(value);\n+        None\n+    }) as Box<dyn Fn(i32) -> Option<i32>>;\n+}\n+\n+fn main() {}"}, {"sha": "5cf01ddf5d71b042024836aac473695c4ad01609", "filename": "src/test/ui/closures/issue-87814-1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b03ccace573bb91e27625c190a0f7807045a1012/src%2Ftest%2Fui%2Fclosures%2Fissue-87814-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03ccace573bb91e27625c190a0f7807045a1012/src%2Ftest%2Fui%2Fclosures%2Fissue-87814-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-87814-1.rs?ref=b03ccace573bb91e27625c190a0f7807045a1012", "patch": "@@ -0,0 +1,8 @@\n+// check-pass\n+fn main() {\n+    let mut schema_all = vec![];\n+    (0..42).for_each(|_x| match Err(()) as Result<(), _> {\n+        Ok(()) => schema_all.push(()),\n+        Err(_) => (),\n+    });\n+}"}, {"sha": "7a5facdac58c39147d66afa729b7d7476f0c66dc", "filename": "src/test/ui/closures/issue-87814-2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b03ccace573bb91e27625c190a0f7807045a1012/src%2Ftest%2Fui%2Fclosures%2Fissue-87814-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b03ccace573bb91e27625c190a0f7807045a1012/src%2Ftest%2Fui%2Fclosures%2Fissue-87814-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-87814-2.rs?ref=b03ccace573bb91e27625c190a0f7807045a1012", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+#![feature(try_reserve)]\n+\n+fn main() {\n+    let mut schema_all: (Vec<String>, Vec<String>) = (vec![], vec![]);\n+\n+    let _c = || match schema_all.0.try_reserve(1) as Result<(), _> {\n+        Ok(()) => (),\n+        Err(_) => (),\n+    };\n+}"}]}