{"sha": "4ded592f60c3f1a16db56fadcd7924121ed92ce8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkZWQ1OTJmNjBjM2YxYTE2ZGI1NmZhZGNkNzkyNDEyMWVkOTJjZTg=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-02-19T11:40:56Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-03-04T16:10:02Z"}, "message": "Use a more general approach for setting large definedness ranges", "tree": {"sha": "0101ad45deee73f3daf08eb071a4557f97834aa5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0101ad45deee73f3daf08eb071a4557f97834aa5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ded592f60c3f1a16db56fadcd7924121ed92ce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ded592f60c3f1a16db56fadcd7924121ed92ce8", "html_url": "https://github.com/rust-lang/rust/commit/4ded592f60c3f1a16db56fadcd7924121ed92ce8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ded592f60c3f1a16db56fadcd7924121ed92ce8/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d32b7e5b13ee833675c8fb3c905a4286690ceb15", "url": "https://api.github.com/repos/rust-lang/rust/commits/d32b7e5b13ee833675c8fb3c905a4286690ceb15", "html_url": "https://github.com/rust-lang/rust/commit/d32b7e5b13ee833675c8fb3c905a4286690ceb15"}], "stats": {"total": 70, "additions": 45, "deletions": 25}, "files": [{"sha": "6cbb611c1a3ec461c97b63d7add8775a12bce811", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4ded592f60c3f1a16db56fadcd7924121ed92ce8/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ded592f60c3f1a16db56fadcd7924121ed92ce8/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4ded592f60c3f1a16db56fadcd7924121ed92ce8", "patch": "@@ -20,7 +20,7 @@ use syntax::ast::Mutability;\n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n     EvalResult, Scalar, EvalErrorKind, AllocKind, PointerArithmetic,\n-    Machine, AllocMap, MayLeak, ErrorHandled, InboundsCheck, UndefMask,\n+    Machine, AllocMap, MayLeak, ErrorHandled, InboundsCheck,\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -789,38 +789,58 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n \n-        let undef_mask = self.get(src.alloc_id)?.undef_mask.clone();\n-        let get = |i| undef_mask.get(src.offset + Size::from_bytes(i));\n-        let dest_allocation = self.get_mut(dest.alloc_id)?;\n+        let undef_mask = &self.get(src.alloc_id)?.undef_mask;\n+\n+        // a precomputed cache for ranges of defined/undefined bits\n+        // 0000010010001110 will become\n+        // [5, 1, 2, 1, 3, 3, 1]\n+        // where each element toggles the state\n+        let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n+        let first = undef_mask.get(src.offset);\n+        let mut cur_len = 1;\n+        let mut cur = first;\n+        for i in 1..size.bytes() {\n+            // FIXME: optimize to bitshift the current undef block's bits and read the top bit\n+            if undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n+                cur_len += 1;\n+            } else {\n+                ranges.push(cur_len);\n+                cur_len = 1;\n+                cur = !cur;\n+            }\n+        }\n \n+        // now fill in all the data\n+        let dest_allocation = self.get_mut(dest.alloc_id)?;\n         // an optimization where we can just overwrite an entire range of definedness bits if\n         // they are going to be uniformly `1` or `0`.\n-        if size.bytes() * repeat > UndefMask::BLOCK_SIZE {\n-            let first = undef_mask.get(src.offset);\n-            // check that all bits are the same as the first bit\n-            // FIXME(oli-obk): consider making this a function on `UndefMask` and optimize it, too\n-            if (1..size.bytes()).all(|i| get(i) == first) {\n-                dest_allocation.undef_mask.set_range(\n-                    dest.offset,\n-                    dest.offset + size * repeat,\n-                    first,\n-                );\n-                return Ok(())\n-            }\n+        if ranges.is_empty() {\n+            dest_allocation.undef_mask.set_range(\n+                dest.offset,\n+                dest.offset + size * repeat,\n+                first,\n+            );\n+            return Ok(())\n         }\n \n-        // the default path\n-        for i in 0..size.bytes() {\n-            let defined = get(i);\n-\n-            for j in 0..repeat {\n-                dest_allocation.undef_mask.set(\n-                    dest.offset + Size::from_bytes(i + (size.bytes() * j)),\n-                    defined\n+        // remember to fill in the trailing bits\n+        ranges.push(cur_len);\n+\n+        for mut j in 0..repeat {\n+            j *= size.bytes();\n+            j += dest.offset.bytes();\n+            let mut cur = first;\n+            for range in &ranges {\n+                let old_j = j;\n+                j += range;\n+                dest_allocation.undef_mask.set_range_inbounds(\n+                    Size::from_bytes(old_j),\n+                    Size::from_bytes(j),\n+                    cur,\n                 );\n+                cur = !cur;\n             }\n         }\n-\n         Ok(())\n     }\n }"}]}