{"sha": "7931a61ebb689723526bf14857ff06b6b7db2cfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MzFhNjFlYmI2ODk3MjM1MjZiZjE0ODU3ZmYwNmI2YjdkYjJjZmQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-23T18:37:10Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-23T19:22:58Z"}, "message": "rustc: Redo region inference to be a bit less broken", "tree": {"sha": "3a1f7352ea511800a15e26e4b0436117d11c31e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a1f7352ea511800a15e26e4b0436117d11c31e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7931a61ebb689723526bf14857ff06b6b7db2cfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7931a61ebb689723526bf14857ff06b6b7db2cfd", "html_url": "https://github.com/rust-lang/rust/commit/7931a61ebb689723526bf14857ff06b6b7db2cfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7931a61ebb689723526bf14857ff06b6b7db2cfd/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84019aa0dcf8990a770764e99621568a39aeabd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/84019aa0dcf8990a770764e99621568a39aeabd3", "html_url": "https://github.com/rust-lang/rust/commit/84019aa0dcf8990a770764e99621568a39aeabd3"}], "stats": {"total": 720, "additions": 391, "deletions": 329}, "files": [{"sha": "80f830ce88dade42e1217b1e5539315e6b523e59", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=7931a61ebb689723526bf14857ff06b6b7db2cfd", "patch": "@@ -92,23 +92,23 @@ fn enc_mt(w: io::writer, cx: @ctxt, mt: ty::mt) {\n     }\n     enc_ty(w, cx, mt.ty);\n }\n-fn enc_region(w: io::writer, cx: @ctxt, r: ty::region) {\n+fn enc_region(w: io::writer, r: ty::region) {\n     alt r {\n-        ty::re_named(did) {\n-            w.write_char('n'); w.write_str(cx.ds(did)); w.write_char('|');\n-        }\n-        ty::re_caller(did) {\n-            w.write_char('c'); w.write_str(cx.ds(did)); w.write_char('|');\n-        }\n         ty::re_block(nid) {\n             w.write_char('b'); w.write_int(nid); w.write_char('|');\n         }\n-        ty::re_self(did) {\n-            w.write_char('s'); w.write_str(cx.ds(did)); w.write_char('|');\n+        ty::re_self {\n+            w.write_char('s');\n+        }\n+        ty::re_inferred {\n+            w.write_char('i');\n         }\n         ty::re_param(id) {\n             w.write_char('p'); w.write_uint(id); w.write_char('|');\n         }\n+        ty::re_var(id) {\n+            w.write_char('v'); w.write_uint(id); w.write_char('|');\n+        }\n     }\n }\n fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n@@ -167,7 +167,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_ptr(mt) { w.write_char('*'); enc_mt(w, cx, mt); }\n       ty::ty_rptr(r, mt) {\n         w.write_char('&');\n-        enc_region(w, cx, r);\n+        enc_region(w, r);\n         enc_mt(w, cx, mt);\n       }\n       ty::ty_vec(mt) { w.write_char('I'); enc_mt(w, cx, mt); }"}, {"sha": "3998c2525ac2f5433bd13ed0b3aa65a60c69f572", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 39, "deletions": 58, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=7931a61ebb689723526bf14857ff06b6b7db2cfd", "patch": "@@ -22,10 +22,10 @@ enum parent {\n     pa_crate\n }\n \n-/* Records the binding site of a region name. */\n+/* Records the parameter ID of a region name. */\n type binding = {\n     name: str,\n-    id: ast::def_id\n+    id: uint\n };\n \n type region_map = {\n@@ -35,12 +35,8 @@ type region_map = {\n     ast_type_to_region: hashmap<ast::node_id,ty::region>,\n     /* Mapping from a local variable to its containing block. */\n     local_blocks: hashmap<ast::node_id,ast::node_id>,\n-    /* Mapping from a region name to its function. */\n-    region_name_to_fn: hashmap<ast::def_id,ast::node_id>,\n     /* Mapping from an AST type node to the region that `&` resolves to. */\n     ast_type_to_inferred_region: hashmap<ast::node_id,ty::region>,\n-    /* Mapping from a call site (or `bind` site) to its containing block. */\n-    call_site_to_block: hashmap<ast::node_id,ast::node_id>,\n     /*\n      * Mapping from an address-of operator or alt expression to its containing\n      * block. This is used as the region if the operand is an rvalue.\n@@ -67,22 +63,12 @@ type ctxt = {\n     /* True if we're within the pattern part of an alt, false otherwise. */\n     in_alt: bool,\n \n-    /*\n-     * Points to the site of the current typeclass implementation, or none if\n-     * we're outside one.\n-     */\n-    self_binding: option<ast::def_id>\n-};\n+    /* True if we're within a typeclass implementation, false otherwise. */\n+    in_typeclass: bool,\n \n-fn region_to_scope(region_map: @region_map, region: ty::region)\n-        -> ast::node_id {\n-    ret alt region {\n-        ty::re_caller(def_id) | ty::re_self(def_id) { def_id.node }\n-        ty::re_named(def_id) { region_map.region_name_to_fn.get(def_id) }\n-        ty::re_block(node_id) { node_id }\n-        ty::re_param(_) { fail \"unresolved region in region_to_scope\" }\n-    };\n-}\n+    /* The next parameter ID. */\n+    mut next_param_id: uint\n+};\n \n // Returns true if `subscope` is equal to or is lexically nested inside\n // `superscope` and false otherwise.\n@@ -105,8 +91,10 @@ fn get_inferred_region(cx: ctxt, sp: syntax::codemap::span) -> ty::region {\n     // TODO: What do we do if we're in an alt?\n \n     ret alt cx.parent {\n-        pa_fn_item(item_id) | pa_nested_fn(item_id) {\n-            ty::re_caller({crate: ast::local_crate, node: item_id})\n+        pa_fn_item(_) | pa_nested_fn(_) {\n+            let id = cx.next_param_id;\n+            cx.next_param_id += 1u;\n+            ty::re_param(id)\n         }\n         pa_block(block_id) { ty::re_block(block_id) }\n         pa_item(_) { ty::re_param(0u) }\n@@ -123,17 +111,14 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n             alt node {\n                 ast::re_inferred { /* no-op */ }\n                 ast::re_self {\n-                    alt cx.self_binding {\n-                        some(def_id) {\n-                            let region = ty::re_self(def_id);\n-                            let rm = cx.region_map;\n-                            rm.ast_type_to_region.insert(region_id, region);\n-                        }\n-                        none {\n-                            cx.sess.span_err(ty.span,\n-                                             \"the `self` region is not \\\n-                                              allowed here\");\n-                        }\n+                    if cx.in_typeclass {\n+                        let r = ty::re_self;\n+                        let rm = cx.region_map;\n+                        rm.ast_type_to_region.insert(region_id, r);\n+                    } else {\n+                        cx.sess.span_err(ty.span,\n+                                         \"the `self` region is not allowed \\\n+                                          here\");\n                     }\n                 }\n                 ast::re_named(ident) {\n@@ -142,18 +127,18 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n                     let bindings = cx.bindings;\n                     let mut region;\n                     alt list::find(*bindings, {|b| ident == b.name}) {\n-                        some(binding) { region = ty::re_named(binding.id); }\n+                        some(binding) { region = ty::re_param(binding.id); }\n                         none {\n-                            let def_id = {crate: ast::local_crate,\n-                                          node: region_id};\n-                            let binding = {name: ident, id: def_id};\n+                            let id = cx.next_param_id;\n+                            let binding = {name: ident, id: id};\n+                            cx.next_param_id += 1u;\n+\n                             cx.bindings = @list::cons(binding, cx.bindings);\n-                            region = ty::re_named(def_id);\n+                            region = ty::re_param(id);\n \n                             alt cx.parent {\n                                 pa_fn_item(fn_id) | pa_nested_fn(fn_id) {\n-                                    let rf = cx.region_map.region_name_to_fn;\n-                                    rf.insert(def_id, fn_id);\n+                                    /* ok */\n                                 }\n                                 pa_item(_) {\n                                     cx.sess.span_err(ty.span,\n@@ -264,16 +249,6 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n                           in_alt: false with cx};\n             visit::visit_expr(expr, new_cx, visitor);\n         }\n-        ast::expr_call(_, _, _) | ast::expr_bind(_, _) {\n-            // Record the block that this call appears in.\n-            alt cx.parent {\n-                pa_block(blk_id) {\n-                    cx.region_map.call_site_to_block.insert(expr.id, blk_id);\n-                }\n-                _ { cx.sess.span_bug(expr.span, \"expr outside of block?!\"); }\n-            }\n-            visit::visit_expr(expr, cx, visitor);\n-        }\n         ast::expr_addr_of(_, subexpr) | ast::expr_alt(subexpr, _, _) {\n             // Record the block that this expression appears in, in case the\n             // operand is an rvalue.\n@@ -302,22 +277,29 @@ fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Items create a new outer block scope as far as we're concerned.\n     let mut parent;\n-    let mut self_binding = cx.self_binding;\n+    let mut in_typeclass;\n     alt item.node {\n         ast::item_fn(_, _, _) | ast::item_enum(_, _) {\n             parent = pa_fn_item(item.id);\n+            in_typeclass = false;\n         }\n         ast::item_impl(_, _, _, _) {\n-            self_binding = some({crate: ast::local_crate, node: item.id});\n             parent = pa_item(item.id);\n+            in_typeclass = true;\n+        }\n+        _ {\n+            parent = pa_item(item.id);\n+            in_typeclass = false;\n         }\n-        _ { parent = pa_item(item.id); }\n     };\n+\n     let new_cx: ctxt = {bindings: @list::nil,\n                         parent: parent,\n                         in_alt: false,\n-                        self_binding: self_binding\n+                        in_typeclass: in_typeclass,\n+                        mut next_param_id: 0u\n                         with cx};\n+\n     visit::visit_item(item, new_cx, visitor);\n }\n \n@@ -328,16 +310,15 @@ fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n                     region_map: @{parents: map::int_hash(),\n                                   ast_type_to_region: map::int_hash(),\n                                   local_blocks: map::int_hash(),\n-                                  region_name_to_fn: new_def_hash(),\n                                   ast_type_to_inferred_region:\n                                     map::int_hash(),\n-                                  call_site_to_block: map::int_hash(),\n                                   rvalue_to_block: map::int_hash()},\n                     mut bindings: @list::nil,\n                     mut queued_locals: [],\n                     parent: pa_crate,\n                     in_alt: false,\n-                    self_binding: none};\n+                    in_typeclass: false,\n+                    mut next_param_id: 0u};\n     let visitor = visit::mk_vt(@{\n         visit_block: resolve_block,\n         visit_item: resolve_item,"}, {"sha": "a969785cd2e1c0e42b68fe50336a4555ea2bb4e9", "filename": "src/rustc/middle/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Fmiddle%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Fmiddle%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregionck.rs?ref=7931a61ebb689723526bf14857ff06b6b7db2cfd", "patch": "@@ -28,7 +28,7 @@ fn check_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n             alt ty::get(t).struct {\n                 ty::ty_rptr(region, _) {\n                     alt region {\n-                        ty::re_named(_) | ty::re_caller(_) | ty::re_self(_) {\n+                        ty::re_self | ty::re_inferred | ty::re_param(_) {\n                             /* ok */\n                         }\n                         ty::re_block(rbi) {\n@@ -51,7 +51,7 @@ fn check_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n                                                      \"escapes its block\");\n                             }\n                         }\n-                        ty::re_param(_) {\n+                        ty::re_var(_) {\n                             cx.tcx.sess.span_bug(expr.span,\n                                                  \"unresolved region\");\n                         }"}, {"sha": "5a4c1ae1d7a18b845e79ef802342f68cd0da5756", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=7931a61ebb689723526bf14857ff06b6b7db2cfd", "patch": "@@ -2004,6 +2004,7 @@ fn check_exports(e: @env) {\n                         maybe_add_reexport(e, export_id, t);\n                         maybe_add_reexport(e, export_id, m);\n                       }\n+                      _ { e.sess.span_bug(vi.span, \"unresolved export\"); }\n                     }\n                   }\n                   mie_item(@{id, _}) | mie_native_item(@{id, _}) |"}, {"sha": "b3f6a565c7562877f49b52767a4830a2cbb821f7", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 188, "deletions": 128, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=7931a61ebb689723526bf14857ff06b6b7db2cfd", "patch": "@@ -91,7 +91,7 @@ export ty_uint, mk_uint, mk_mach_uint;\n export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n export ty_var, mk_var;\n export ty_self, mk_self;\n-export region, re_named, re_caller, re_block, re_param;\n+export region, re_block, re_param, re_var;\n export get, type_has_params, type_has_vars, type_has_rptrs, type_id;\n export same_type;\n export ty_var_id;\n@@ -139,7 +139,7 @@ export default_arg_mode_for_ty;\n export item_path;\n export item_path_str;\n export ast_ty_to_ty_cache_entry;\n-export atttce_unresolved, atttce_resolved, atttce_has_regions;\n+export atttce_unresolved, atttce_resolved;\n \n // Data types\n \n@@ -174,8 +174,7 @@ type intern_key = {struct: sty, o_def_id: option<ast::def_id>};\n \n enum ast_ty_to_ty_cache_entry {\n     atttce_unresolved,  /* not resolved yet */\n-    atttce_resolved(t), /* resolved to a type, irrespective of region */\n-    atttce_has_regions  /* has regions; cannot be cached */\n+    atttce_resolved(t)  /* resolved to a type, irrespective of region */\n }\n \n type ctxt =\n@@ -240,14 +239,19 @@ type fn_ty = {proto: ast::proto,\n               constraints: [@constr]};\n \n enum region {\n-    re_named(def_id),\n-    re_caller(def_id),\n-    re_self(def_id),\n+    // The region of a block.\n     re_block(node_id),\n+    // The self region. Only valid inside classes and typeclass\n+    // implementations.\n+    re_self,\n+    // The inferred region, which also corresponds to &self in typedefs.\n+    re_inferred,\n \n-    // A region parameter. Currently used only for typedefs.\n-    // TODO: Use this for caller and named regions as well.\n-    re_param(uint)\n+    // A region parameter.\n+    re_param(uint),\n+\n+    // A region variable.\n+    re_var(uint)\n }\n \n // NB: If you change this, you'll probably want to change the corresponding\n@@ -594,100 +598,123 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n enum fold_mode {\n     fm_var(fn@(int) -> t),\n     fm_param(fn@(uint, def_id) -> t),\n-    fm_rptr(fn@(region) -> region),\n+    fm_rptr(fn@(region, bool /* under & */) -> region),\n     fm_general(fn@(t) -> t),\n }\n \n fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n-    let mut ty = ty_0;\n-\n-    let tb = get(ty);\n-    alt fld {\n-      fm_var(_) { if !tb.has_vars { ret ty; } }\n-      fm_param(_) { if !tb.has_params { ret ty; } }\n-      fm_rptr(_) { if !tb.has_rptrs { ret ty; } }\n-      fm_general(_) {/* no fast path */ }\n-    }\n+    fn do_fold(cx: ctxt, fld: fold_mode, ty_0: t, under_rptr: bool) -> t {\n+        let mut ty = ty_0;\n+\n+        let tb = get(ty);\n+        alt fld {\n+          fm_var(_) { if !tb.has_vars { ret ty; } }\n+          fm_param(_) { if !tb.has_params { ret ty; } }\n+          fm_rptr(_) { if !tb.has_rptrs { ret ty; } }\n+          fm_general(_) {/* no fast path */ }\n+        }\n \n-    alt tb.struct {\n-      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str | ty_type | ty_opaque_closure_ptr(_) |\n-      ty_opaque_box {}\n-      ty_box(tm) {\n-        ty = mk_box(cx, {ty: fold_ty(cx, fld, tm.ty), mutbl: tm.mutbl});\n-      }\n-      ty_uniq(tm) {\n-        ty = mk_uniq(cx, {ty: fold_ty(cx, fld, tm.ty), mutbl: tm.mutbl});\n-      }\n-      ty_ptr(tm) {\n-        ty = mk_ptr(cx, {ty: fold_ty(cx, fld, tm.ty), mutbl: tm.mutbl});\n-      }\n-      ty_vec(tm) {\n-        ty = mk_vec(cx, {ty: fold_ty(cx, fld, tm.ty), mutbl: tm.mutbl});\n-      }\n-      ty_enum(tid, subtys) {\n-        ty = mk_enum(cx, tid, vec::map(subtys, {|t| fold_ty(cx, fld, t) }));\n-      }\n-      ty_iface(did, subtys) {\n-        ty = mk_iface(cx, did, vec::map(subtys, {|t| fold_ty(cx, fld, t) }));\n-      }\n-      ty_self(subtys) {\n-        ty = mk_self(cx, vec::map(subtys, {|t| fold_ty(cx, fld, t) }));\n-      }\n-      ty_rec(fields) {\n-        let mut new_fields: [field] = [];\n-        for fl: field in fields {\n-            let new_ty = fold_ty(cx, fld, fl.mt.ty);\n-            let new_mt = {ty: new_ty, mutbl: fl.mt.mutbl};\n-            new_fields += [{ident: fl.ident, mt: new_mt}];\n+        alt tb.struct {\n+          ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+          ty_str | ty_type | ty_opaque_closure_ptr(_) |\n+          ty_opaque_box {}\n+          ty_box(tm) {\n+            ty = mk_box(cx, {ty: do_fold(cx, fld, tm.ty, under_rptr),\n+                             mutbl: tm.mutbl});\n+          }\n+          ty_uniq(tm) {\n+            ty = mk_uniq(cx, {ty: do_fold(cx, fld, tm.ty, under_rptr),\n+                              mutbl: tm.mutbl});\n+          }\n+          ty_ptr(tm) {\n+            ty = mk_ptr(cx, {ty: do_fold(cx, fld, tm.ty, under_rptr),\n+                             mutbl: tm.mutbl});\n+          }\n+          ty_vec(tm) {\n+            ty = mk_vec(cx, {ty: do_fold(cx, fld, tm.ty, under_rptr),\n+                             mutbl: tm.mutbl});\n+          }\n+          ty_enum(tid, subtys) {\n+            ty = mk_enum(cx, tid,\n+                         vec::map(subtys, {|t|\n+                            do_fold(cx, fld, t, under_rptr)\n+                         }));\n+          }\n+          ty_iface(did, subtys) {\n+            ty = mk_iface(cx, did,\n+                          vec::map(subtys, {|t|\n+                              do_fold(cx, fld, t, under_rptr)\n+                          }));\n+          }\n+          ty_self(subtys) {\n+            ty = mk_self(cx, vec::map(subtys, {|t|\n+                                do_fold(cx, fld, t, under_rptr)\n+                             }));\n+          }\n+          ty_rec(fields) {\n+            let mut new_fields: [field] = [];\n+            for fl: field in fields {\n+                let new_ty = do_fold(cx, fld, fl.mt.ty, under_rptr);\n+                let new_mt = {ty: new_ty, mutbl: fl.mt.mutbl};\n+                new_fields += [{ident: fl.ident, mt: new_mt}];\n+            }\n+            ty = mk_rec(cx, new_fields);\n+          }\n+          ty_tup(ts) {\n+            let mut new_ts = [];\n+            for tt in ts { new_ts += [do_fold(cx, fld, tt, under_rptr)]; }\n+            ty = mk_tup(cx, new_ts);\n+          }\n+          ty_fn(f) {\n+            let mut new_args: [arg] = [];\n+            for a: arg in f.inputs {\n+                let new_ty = do_fold(cx, fld, a.ty, under_rptr);\n+                new_args += [{mode: a.mode, ty: new_ty}];\n+            }\n+            ty = mk_fn(cx, {inputs: new_args,\n+                            output: do_fold(cx, fld, f.output, under_rptr)\n+                            with f});\n+          }\n+          ty_res(did, subty, tps) {\n+            let mut new_tps = [];\n+            for tp: t in tps {\n+                new_tps += [do_fold(cx, fld, tp, under_rptr)];\n+            }\n+            ty = mk_res(cx, did, do_fold(cx, fld, subty, under_rptr),\n+                        new_tps);\n+          }\n+          ty_var(id) {\n+            alt fld { fm_var(folder) { ty = folder(id); } _ {/* no-op */ } }\n+          }\n+          ty_param(id, did) {\n+            alt fld { fm_param(folder) { ty = folder(id, did); } _ {} }\n+          }\n+          ty_rptr(r, tm) {\n+            let region = alt fld {\n+                fm_rptr(folder) { folder(r, under_rptr) }\n+                _ { r }\n+            };\n+            ty = mk_rptr(cx, region,\n+                         {ty: do_fold(cx, fld, tm.ty, true),\n+                          mutbl: tm.mutbl});\n+          }\n+          ty_constr(subty, cs) {\n+              ty = mk_constr(cx, do_fold(cx, fld, subty, under_rptr), cs);\n+          }\n+          _ {\n+              cx.sess.bug(\"unsupported sort of type in fold_ty\");\n+          }\n         }\n-        ty = mk_rec(cx, new_fields);\n-      }\n-      ty_tup(ts) {\n-        let mut new_ts = [];\n-        for tt in ts { new_ts += [fold_ty(cx, fld, tt)]; }\n-        ty = mk_tup(cx, new_ts);\n-      }\n-      ty_fn(f) {\n-        let mut new_args: [arg] = [];\n-        for a: arg in f.inputs {\n-            let new_ty = fold_ty(cx, fld, a.ty);\n-            new_args += [{mode: a.mode, ty: new_ty}];\n+        alt tb.o_def_id {\n+          some(did) { ty = mk_t_with_id(cx, get(ty).struct, some(did)); }\n+          _ {}\n         }\n-        ty = mk_fn(cx, {inputs: new_args,\n-                        output: fold_ty(cx, fld, f.output)\n-                        with f});\n-      }\n-      ty_res(did, subty, tps) {\n-        let mut new_tps = [];\n-        for tp: t in tps { new_tps += [fold_ty(cx, fld, tp)]; }\n-        ty = mk_res(cx, did, fold_ty(cx, fld, subty), new_tps);\n-      }\n-      ty_var(id) {\n-        alt fld { fm_var(folder) { ty = folder(id); } _ {/* no-op */ } }\n-      }\n-      ty_param(id, did) {\n-        alt fld { fm_param(folder) { ty = folder(id, did); } _ {} }\n-      }\n-      ty_rptr(r, tm) {\n-        let region = alt fld { fm_rptr(folder) { folder(r) } _ { r } };\n-        ty = mk_rptr(cx, region,\n-                     {ty: fold_ty(cx, fld, tm.ty), mutbl: tm.mutbl});\n-      }\n-      ty_constr(subty, cs) {\n-          ty = mk_constr(cx, fold_ty(cx, fld, subty), cs);\n-      }\n-      _ {\n-          cx.sess.bug(\"unsupported sort of type in fold_ty\");\n-      }\n-    }\n-    alt tb.o_def_id {\n-      some(did) { ty = mk_t_with_id(cx, get(ty).struct, some(did)); }\n-      _ {}\n+\n+        // If this is a general type fold, then we need to run it now.\n+        alt fld { fm_general(folder) { ret folder(ty); } _ { ret ty; } }\n     }\n \n-    // If this is a general type fold, then we need to run it now.\n-    alt fld { fm_general(folder) { ret folder(ty); } _ { ret ty; } }\n+    ret do_fold(cx, fld, ty_0, false);\n }\n \n \n@@ -1168,11 +1195,11 @@ fn hash_type_structure(st: sty) -> uint {\n     }\n     fn hash_region(r: region) -> uint {\n         alt r {\n-          re_named(_)   { 1u }\n-          re_caller(_)  { 2u }\n-          re_self(_)    { 3u }\n-          re_block(_)   { 4u }\n-          re_param(_)   { 5u }\n+          re_block(_)   { 0u }\n+          re_self       { 1u }\n+          re_inferred   { 2u }\n+          re_param(_)   { 3u }\n+          re_var(_)     { 4u }\n         }\n     }\n     alt st {\n@@ -1643,7 +1670,7 @@ mod unify {\n             fn@(rb: @region_bindings, r: region) {\n                 ufind::union(rb.sets, set_a, set_b);\n                 let root_c: uint = ufind::find(rb.sets, set_a);\n-                smallintmap::insert::<region>(rb.regions, root_c, r);\n+                smallintmap::insert(rb.regions, root_c, r);\n             }\n         );\n \n@@ -2013,39 +2040,69 @@ mod unify {\n         cx: @uctxt, e_region: region, a_region: region,\n         variance: variance,\n         nxt: fn(region) -> ures<T>) -> ures<T> {\n-        let {sub, super} = alt variance {\n-          covariant { {sub: a_region, super: e_region} }\n-          contravariant { {sub: e_region, super: a_region} }\n-          invariant {\n-            ret if e_region == a_region {\n-                  nxt(e_region)\n-              } else {\n-                  err(terr_regions_differ(true, e_region, a_region))\n-              };\n-            }\n-        };\n+        let mut sub, super;\n+        alt variance {\n+            covariant | invariant { super = e_region; sub = a_region; }\n+            contravariant { super = a_region; sub = e_region; }\n+        }\n \n-        // FIXME: This is wrong. We should be keeping a set of region bindings\n-        // around.\n-        alt (sub, super) {\n-            (ty::re_param(_), _) | (_, ty::re_param(_)) {\n-                ret if sub == super {\n-                    nxt(super)\n-                } else {\n-                    err(terr_regions_differ(true, super, sub))\n-                }\n+        // FIXME: Should have a way of unifying regions that relies on bounds,\n+        // not on unification.\n+        alt (super, sub) {\n+            (ty::re_var(superkey), ty::re_var(subkey)) {\n+                ret union_region_sets(cx, subkey, superkey, variance,\n+                                      {|| nxt(sub) });\n+            }\n+            (ty::re_var(superkey), _) {\n+                ret record_region_binding(cx, superkey, sub, variance, nxt);\n+            }\n+            (_, ty::re_var(subkey)) {\n+                ret record_region_binding(cx, subkey, super, variance, nxt);\n             }\n             _ { /* fall through */ }\n         }\n \n-        // Outer regions are subtypes of inner regions. (This is somewhat\n-        // surprising!)\n-        let superscope = region::region_to_scope(cx.tcx.region_map, super);\n-        let subscope = region::region_to_scope(cx.tcx.region_map, sub);\n-        if region::scope_contains(cx.tcx.region_map, subscope, superscope) {\n-            ret nxt(super);\n+        if variance == invariant {\n+          ret if e_region == a_region {\n+              nxt(e_region)\n+          } else {\n+              err(terr_regions_differ(true, e_region, a_region))\n+          };\n+        }\n+\n+        alt (super, sub) {\n+            (ty::re_var(_), _) | (_, ty::re_var(_)) {\n+                fail \"should have been handled above\";\n+            }\n+            (ty::re_inferred, _) | (_, ty::re_inferred) {\n+                fail \"tried to unify inferred regions\";\n+            }\n+            (ty::re_param(_), ty::re_param(_)) |\n+            (ty::re_self, ty::re_self) {\n+                ret if super == sub {\n+                    nxt(ty::re_self)\n+                } else {\n+                    err(terr_regions_differ(false, super, sub))\n+                };\n+            }\n+            (ty::re_param(_), ty::re_block(_)) |\n+            (ty::re_self, ty::re_block(_)) {\n+                ret nxt(super);\n+            }\n+            (ty::re_block(_), ty::re_param(_)) |\n+            (ty::re_block(_), ty::re_self) {\n+                ret err(terr_regions_differ(false, super, sub));\n+            }\n+            (ty::re_block(superblock), ty::re_block(subblock)) {\n+                // Outer regions are subtypes of inner regions. (This is\n+                // somewhat surprising!)\n+                let rm = cx.tcx.region_map;\n+                if region::scope_contains(rm, subblock, superblock) {\n+                    ret nxt(super);\n+                }\n+                ret err(terr_regions_differ(false, sub, super));\n+            }\n         }\n-        ret err(terr_regions_differ(false, sub, super));\n     }\n \n     fn unify_field<T:copy>(\n@@ -2074,6 +2131,9 @@ mod unify {\n         // Fast path.\n         if expected == actual { ret nxt(expected); }\n \n+        // FIXME: This is terribly wrong. We should be unifying type sets\n+        // using some sort of bound.\n+\n         alt (get(expected).struct, get(actual).struct) {\n           (ty_var(e_id), ty_var(a_id)) {\n             union(cx, e_id as uint, a_id as uint, variance) {||"}, {"sha": "19c3e2739491c79650fced1ddfb5de17481f81a5", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 147, "deletions": 116, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=7931a61ebb689723526bf14857ff06b6b7db2cfd", "patch": "@@ -253,21 +253,10 @@ enum mode { m_collect, m_check, m_check_tyvar(@fn_ctxt), }\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n-    fn subst_inferred_regions(tcx: ty::ctxt, use_site: ast::node_id,\n-                              ty: ty::t) -> ty::t {\n-        ret ty::fold_ty(tcx, ty::fm_rptr({|r|\n-            alt r {\n-                // FIXME: This is probably wrong for params.\n-                ty::re_param(_) | ty::re_self(_) {\n-                    tcx.region_map.ast_type_to_inferred_region.get(use_site)\n-                }\n-                _ { r }\n-            }\n-        }), ty);\n-    }\n-    fn getter(tcx: ty::ctxt, use_site: ast::node_id, mode: mode,\n-              id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-        let tpt = alt mode {\n+    fn getter(tcx: ty::ctxt, mode: mode, id: ast::def_id)\n+            -> ty::ty_param_bounds_and_ty {\n+\n+        alt mode {\n           m_check | m_check_tyvar(_) { ty::lookup_item_type(tcx, id) }\n           m_collect {\n             if id.crate != ast::local_crate { csearch::get_type(tcx, id) }\n@@ -285,23 +274,14 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                 }\n             }\n           }\n-        };\n-\n-        if ty::type_has_rptrs(tpt.ty) {\n-            ret {bounds: tpt.bounds,\n-                 ty: subst_inferred_regions(tcx, use_site, tpt.ty)};\n         }\n-        ret tpt;\n     }\n-    fn ast_mt_to_mt(tcx: ty::ctxt, use_site: ast::node_id, mode: mode,\n-                    mt: ast::mt) -> ty::mt {\n-        ret {ty: do_ast_ty_to_ty(tcx, use_site, mode, mt.ty),\n-             mutbl: mt.mutbl};\n+    fn ast_mt_to_mt(tcx: ty::ctxt, mode: mode, mt: ast::mt) -> ty::mt {\n+        ret {ty: do_ast_ty_to_ty(tcx, mode, mt.ty), mutbl: mt.mutbl};\n     }\n-    fn instantiate(tcx: ty::ctxt, use_site: ast::node_id, sp: span,\n-                   mode: mode, id: ast::def_id, path_id: ast::node_id,\n-                   args: [@ast::ty]) -> ty::t {\n-        let ty_param_bounds_and_ty = getter(tcx, use_site, mode, id);\n+    fn instantiate(tcx: ty::ctxt, sp: span, mode: mode, id: ast::def_id,\n+                   path_id: ast::node_id, args: [@ast::ty]) -> ty::t {\n+        let ty_param_bounds_and_ty = getter(tcx, mode, id);\n         if vec::len(*ty_param_bounds_and_ty.bounds) == 0u {\n             ret ty_param_bounds_and_ty.ty;\n         }\n@@ -313,7 +293,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                                      polymorphic type\");\n         }\n         for ast_ty: @ast::ty in args {\n-            param_bindings += [do_ast_ty_to_ty(tcx, use_site, mode, ast_ty)];\n+            param_bindings += [do_ast_ty_to_ty(tcx, mode, ast_ty)];\n         }\n         #debug(\"substituting(%s into %s)\",\n                str::concat(vec::map(param_bindings, {|t| ty_to_str(tcx, t)})),\n@@ -324,63 +304,55 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         write_substs(tcx, path_id, param_bindings);\n         ret typ;\n     }\n-    fn do_ast_ty_to_ty(tcx: ty::ctxt, use_site: ast::node_id, mode: mode,\n-                       &&ast_ty: @ast::ty) -> ty::t {\n+    fn do_ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty)\n+            -> ty::t {\n+\n         alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n           some(ty::atttce_resolved(ty)) { ret ty; }\n           some(ty::atttce_unresolved) {\n             tcx.sess.span_fatal(ast_ty.span, \"illegal recursive type. \\\n                                               insert a enum in the cycle, \\\n                                               if this is desired)\");\n           }\n-          some(ty::atttce_has_regions) | none { /* go on */ }\n+          none { /* go on */ }\n         }\n \n         tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_unresolved);\n         let typ = alt ast_ty.node {\n           ast::ty_nil { ty::mk_nil(tcx) }\n           ast::ty_bot { ty::mk_bot(tcx) }\n           ast::ty_box(mt) {\n-            ty::mk_box(tcx, ast_mt_to_mt(tcx, use_site, mode, mt))\n+            ty::mk_box(tcx, ast_mt_to_mt(tcx, mode, mt))\n           }\n           ast::ty_uniq(mt) {\n-            ty::mk_uniq(tcx, ast_mt_to_mt(tcx, use_site, mode, mt))\n+            ty::mk_uniq(tcx, ast_mt_to_mt(tcx, mode, mt))\n           }\n           ast::ty_vec(mt) {\n-            ty::mk_vec(tcx, ast_mt_to_mt(tcx, use_site, mode, mt))\n+            ty::mk_vec(tcx, ast_mt_to_mt(tcx, mode, mt))\n           }\n           ast::ty_ptr(mt) {\n-            ty::mk_ptr(tcx, ast_mt_to_mt(tcx, use_site, mode, mt))\n+            ty::mk_ptr(tcx, ast_mt_to_mt(tcx, mode, mt))\n           }\n           ast::ty_rptr(region, mt) {\n             let region = alt region.node {\n-                ast::re_inferred {\n-                    let attir = tcx.region_map.ast_type_to_inferred_region;\n-                    alt attir.find(ast_ty.id) {\n-                        some(resolved_region) { resolved_region }\n-                        none {\n-                            // FIXME: Shouldn't be 0u and should instead be\n-                            // a fresh variable.\n-                            ty::re_param(0u)\n-                        }\n-                    }\n-                }\n-                ast::re_named(_) | ast::re_self {\n+                ast::re_inferred { ty::re_inferred }\n+                ast::re_self { ty::re_self }\n+                ast::re_named(_) {\n                     tcx.region_map.ast_type_to_region.get(region.id)\n                 }\n             };\n-            ty::mk_rptr(tcx, region, ast_mt_to_mt(tcx, use_site, mode, mt))\n+            ty::mk_rptr(tcx, region, ast_mt_to_mt(tcx, mode, mt))\n           }\n           ast::ty_tup(fields) {\n-            let flds = vec::map(fields,\n-                                bind do_ast_ty_to_ty(tcx, use_site, mode, _));\n+            let flds = vec::map(fields, bind do_ast_ty_to_ty(tcx, mode, _));\n             ty::mk_tup(tcx, flds)\n           }\n           ast::ty_rec(fields) {\n-            let flds = vec::map(fields) {|f|\n-                let tm = ast_mt_to_mt(tcx, use_site, mode, f.node.mt);\n-                {ident: f.node.ident, mt: tm}\n-            };\n+            let mut flds: [field] = [];\n+            for f: ast::ty_field in fields {\n+                let tm = ast_mt_to_mt(tcx, mode, f.node.mt);\n+                flds += [{ident: f.node.ident, mt: tm}];\n+            }\n             ty::mk_rec(tcx, flds)\n           }\n           ast::ty_fn(proto, decl) {\n@@ -393,7 +365,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n               some(d) { d }};\n             alt a_def {\n               ast::def_ty(did) {\n-                instantiate(tcx, use_site, ast_ty.span, mode, did,\n+                instantiate(tcx, ast_ty.span, mode, did,\n                             id, path.node.types)\n               }\n               ast::def_prim_ty(nty) {\n@@ -421,7 +393,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                                                         self type\");\n                     }\n                     ty::mk_self(tcx, vec::map(path.node.types, {|ast_ty|\n-                        do_ast_ty_to_ty(tcx, use_site, mode, ast_ty)\n+                        do_ast_ty_to_ty(tcx, mode, ast_ty)\n                     }))\n                   }\n                 }\n@@ -445,7 +417,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                 }\n               }\n               else {\n-                  getter(tcx, use_site, mode, class_id).ty\n+                  getter(tcx, mode, class_id).ty\n               }\n              }\n              _ {\n@@ -455,11 +427,11 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n             }\n           }\n           ast::ty_constr(t, cs) {\n-            let out_cs = vec::map(cs) {|constr|\n-                ty::ast_constr_to_constr(tcx, constr)\n-            };\n-            ty::mk_constr(tcx, do_ast_ty_to_ty(tcx, use_site, mode, t),\n-                          out_cs)\n+            let mut out_cs = [];\n+            for constr: @ast::ty_constr in cs {\n+                out_cs += [ty::ast_constr_to_constr(tcx, constr)];\n+            }\n+            ty::mk_constr(tcx, do_ast_ty_to_ty(tcx, mode, t), out_cs)\n           }\n           ast::ty_infer {\n             alt mode {\n@@ -474,16 +446,11 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n           }\n         };\n \n-        if ty::type_has_rptrs(typ) {\n-            tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_has_regions);\n-        } else {\n-            tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_resolved(typ));\n-        }\n-\n+        tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_resolved(typ));\n         ret typ;\n     }\n \n-    ret do_ast_ty_to_ty(tcx, ast_ty.id, mode, ast_ty);\n+    ret do_ast_ty_to_ty(tcx, mode, ast_ty);\n }\n \n fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n@@ -571,6 +538,37 @@ fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n       }\n     }\n }\n+\n+type next_region_param_id = { mut id: uint };\n+\n+fn fixup_regions(tcx: ty::ctxt, next_region_param_id: next_region_param_id,\n+                 ty: ty::t) -> ty::t {\n+    let cur_region_param = @mut next_region_param_id.id;\n+    ret ty::fold_ty(tcx, ty::fm_rptr({|region, under_rptr|\n+        alt region {\n+            ty::re_inferred {\n+                if !under_rptr {\n+                    *cur_region_param = next_region_param_id.id;\n+                    next_region_param_id.id += 1u;\n+                }\n+                ty::re_param(*cur_region_param)\n+            }\n+            _ { region }\n+        }\n+    }), ty);\n+}\n+\n+fn fixup_regions_to_block(tcx: ty::ctxt, ty: ty::t, ast_ty: @ast::ty)\n+        -> ty::t {\n+    let region = tcx.region_map.ast_type_to_inferred_region.get(ast_ty.id);\n+    ret ty::fold_ty(tcx, ty::fm_rptr({|this_region, _under_rptr|\n+        alt this_region {\n+            ty::re_inferred { region }\n+            _ { this_region }\n+        }\n+    }), ty);\n+}\n+\n fn ty_of_arg(tcx: ty::ctxt, mode: mode, a: ast::arg) -> ty::arg {\n     fn arg_mode(tcx: ty::ctxt, m: ast::mode, ty: ty::t) -> ast::mode {\n         alt m {\n@@ -603,8 +601,38 @@ fn ty_of_fn_decl(tcx: ty::ctxt,\n                  mode: mode,\n                  proto: ast::proto,\n                  decl: ast::fn_decl) -> ty::fn_ty {\n-    let input_tys = vec::map(decl.inputs) {|a| ty_of_arg(tcx, mode, a) };\n-    let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n+    let mut has_regions: bool = false;\n+    let mut max_region_param: @mut uint = @mut 0u;\n+\n+    let mut input_tys = vec::map(decl.inputs) {|a|\n+        let arg_ty = ty_of_arg(tcx, mode, a);\n+\n+        if ty::type_has_rptrs(arg_ty.ty) {\n+            has_regions = true;\n+            let _ = ty::fold_ty(tcx, ty::fm_rptr({|r, _under_rptr|\n+                alt r {\n+                    ty::re_param(n) {\n+                        *max_region_param = uint::max(n, *max_region_param);\n+                    }\n+                    _ { /* no-op */ }\n+                };\n+                r\n+            }), arg_ty.ty);\n+        }\n+\n+        arg_ty\n+    };\n+\n+    let mut output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n+\n+    if has_regions {\n+        let next_region_param_id = { mut id: *max_region_param };\n+        input_tys = vec::map(input_tys, {|input_ty|\n+            {ty: fixup_regions(tcx, next_region_param_id, input_ty.ty)\n+             with input_ty}\n+        });\n+        output_ty = fixup_regions(tcx, next_region_param_id, output_ty);\n+    }\n \n     let out_constrs = vec::map(decl.constraints) {|constr|\n         ty::ast_constr_to_constr(tcx, constr)\n@@ -843,9 +871,9 @@ fn fixup_self_in_method_ty(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n fn fixup_self_region_in_method_ty(fcx: @fn_ctxt, mty: ty::t,\n                                   self_expr: @ast::expr) -> ty::t {\n     let self_region = region_of(fcx, self_expr);\n-    ty::fold_ty(fcx.ccx.tcx, ty::fm_rptr({|r|\n+    ty::fold_ty(fcx.ccx.tcx, ty::fm_rptr({|r, _under_rptr|\n         alt r {\n-            ty::re_self(_) { self_region }\n+            ty::re_self { self_region }\n             _ { r }\n         }\n     }), mty)\n@@ -876,7 +904,13 @@ mod collect {\n                 // should be called to resolve named types.\n                 let mut args: [arg] = [];\n                 for va: ast::variant_arg in variant.node.args {\n-                    let arg_ty = ast_ty_to_ty(tcx, m_collect, va.ty);\n+                    let mut arg_ty = ast_ty_to_ty(tcx, m_collect, va.ty);\n+                    if ty::type_has_rptrs(arg_ty) {\n+                        let next_region_param_id = { mut id: 0u };\n+                        arg_ty = fixup_regions(tcx, next_region_param_id,\n+                                               arg_ty);\n+                    }\n+\n                     args += [{mode: ast::expl(ast::by_copy), ty: arg_ty}];\n                 }\n                 // FIXME: this will be different for constrained types\n@@ -1504,8 +1538,16 @@ fn gather_locals(ccx: @crate_ctxt,\n \n     // Add explicitly-declared locals.\n     let visit_local = fn@(local: @ast::local, &&e: (), v: visit::vt<()>) {\n-        let local_ty = ast_ty_to_ty_crate_infer(ccx, local.node.ty);\n-        assign(local.node.id, local_ty);\n+        let mut local_ty_opt = ast_ty_to_ty_crate_infer(ccx, local.node.ty);\n+        alt local_ty_opt {\n+            some(local_ty) if ty::type_has_rptrs(local_ty) {\n+                local_ty_opt = some(fixup_regions_to_block(ccx.tcx, local_ty,\n+                                                           local.node.ty));\n+            }\n+            _ { /* nothing to do */ }\n+        }\n+\n+        assign(local.node.id, local_ty_opt);\n         visit::visit_local(local, e, v);\n     };\n \n@@ -1571,10 +1613,9 @@ type pat_ctxt = {\n fn instantiate_self_regions(tcx: ty::ctxt, region: ty::region, &&ty: ty::t)\n         -> ty::t {\n     if ty::type_has_rptrs(ty) {\n-        ty::fold_ty(tcx, ty::fm_rptr({|r|\n+        ty::fold_ty(tcx, ty::fm_rptr({|r, _under_rptr|\n             alt r {\n-                // FIXME: Should not happen for re_param.\n-                ty::re_param(_) | ty::re_caller(_) | ty::re_self(_) { region }\n+                ty::re_inferred | ty::re_self | ty::re_param(_) { region }\n                 _ { r }\n             }\n         }), ty)\n@@ -1588,9 +1629,9 @@ fn instantiate_self_regions(tcx: ty::ctxt, region: ty::region, &&ty: ty::t)\n // refer to inferred regions.\n fn universally_quantify_regions(tcx: ty::ctxt, ty: ty::t) -> ty::t {\n     if ty::type_has_rptrs(ty) {\n-        ty::fold_ty(tcx, ty::fm_rptr({|_r|\n-            // FIXME: Very wrong. Shouldn't be 0u.\n-            ty::re_param(0u)\n+        ty::fold_ty(tcx, ty::fm_rptr({|_r, _under_rptr|\n+            // FIXME: Should these all be different variables?\n+            ty::re_var(0u)\n         }), ty)\n     } else {\n         ty\n@@ -1606,7 +1647,7 @@ fn replace_region_params(tcx: ty::ctxt,\n         -> ty::t {\n \n     if ty::type_has_rptrs(ty) {\n-        ty::fold_ty(tcx, ty::fm_rptr({ |r|\n+        ty::fold_ty(tcx, ty::fm_rptr({ |r, _under_rptr|\n             alt r {\n                 ty::re_param(n) {\n                     if n < ufind::set_count(rb.sets) {\n@@ -2085,13 +2126,14 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n         for @{did, methods, _} in *impls {\n             alt vec::find(methods, {|m| m.ident == name}) {\n               some(m) {\n-                let {n_tps, ty: self_ty} = impl_self_ty(tcx, did);\n-                let {vars, ty: self_ty} = if n_tps > 0u {\n+                let mut {n_tps, ty: self_ty} = impl_self_ty(tcx, did);\n+                let mut {vars, ty: self_ty} = if n_tps > 0u {\n                     bind_params(fcx, self_ty, n_tps)\n                 } else {\n                     {vars: [], ty: self_ty}\n                 };\n \n+                self_ty = universally_quantify_regions(tcx, self_ty);\n                 let ty = universally_quantify_regions(tcx, ty);\n \n                 alt unify::unify(fcx, self_ty, ty) {\n@@ -2223,32 +2265,23 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n-    fn check_call_or_bind(fcx: @fn_ctxt, sp: span, id: ast::node_id,\n-                          fty: ty::t, args: [option<@ast::expr>])\n+    fn check_call_or_bind(fcx: @fn_ctxt, sp: span, fty: ty::t,\n+                          args: [option<@ast::expr>])\n             -> check_call_or_bind_result {\n+\n         // Replaces \"caller\" regions in the arguments with the local region.\n-        fn instantiate_caller_regions(fcx: @fn_ctxt, id: ast::node_id,\n-                                      args: [ty::arg]) -> [ty::arg] {\n-            let site_to_block = fcx.ccx.tcx.region_map.call_site_to_block;\n-            let block_id = alt site_to_block.find(id) {\n-                none {\n-                    // This can happen for those expressions that are\n-                    // synthesized during typechecking; e.g. during\n-                    // check_constraints().\n-                    ret args;\n-                }\n-                some(block_id) { block_id }\n-            };\n+        fn instantiate_caller_regions(fcx: @fn_ctxt, args: [ty::arg])\n+                -> [ty::arg] {\n \n-            let region = ty::re_block(block_id);\n             ret vec::map(args) {|arg|\n                 if ty::type_has_rptrs(arg.ty) {\n-                    let ty = ty::fold_ty(fcx.ccx.tcx, ty::fm_rptr({|r|\n+                    let ty = ty::fold_ty(fcx.ccx.tcx,\n+                                         ty::fm_rptr({|r, _under_rptr|\n                         alt r {\n-                            ty::re_caller(_) {\n+                            ty::re_param(param) {\n                                 // FIXME: We should not recurse into nested\n                                 // function types here.\n-                                region\n+                                ty::re_var(param)\n                             }\n                             _ { r }\n                         }\n@@ -2301,7 +2334,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         }\n \n         // FIXME: This should instantiate re_params instead.\n-        arg_tys = instantiate_caller_regions(fcx, id, arg_tys);\n+        arg_tys = instantiate_caller_regions(fcx, arg_tys);\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n@@ -2344,8 +2377,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     }\n \n     // A generic function for checking call expressions\n-    fn check_call(fcx: @fn_ctxt, sp: span, id: ast::node_id, f: @ast::expr,\n-                  args: [@ast::expr])\n+    fn check_call(fcx: @fn_ctxt, sp: span, f: @ast::expr, args: [@ast::expr])\n             -> check_call_or_bind_result {\n         let mut args_opt_0: [option<@ast::expr>] = [];\n         for arg: @ast::expr in args {\n@@ -2354,15 +2386,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         let bot = check_expr(fcx, f);\n         // Call the generic checker.\n-        let ccobr = check_call_or_bind(fcx, sp, id, expr_ty(fcx.ccx.tcx, f),\n+        let ccobr = check_call_or_bind(fcx, sp, expr_ty(fcx.ccx.tcx, f),\n                                        args_opt_0);\n         ret { bot: bot | ccobr.bot with ccobr };\n     }\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call_full(fcx: @fn_ctxt, sp: span, id: ast::node_id,\n                        f: @ast::expr, args: [@ast::expr]) -> bool {\n-        let ccobr = check_call(fcx, sp, id, f, args);\n+        let ccobr = check_call(fcx, sp, f, args);\n         let mut bot = ccobr.bot;\n         /* need to restrict oper to being an explicit expr_path if we're\n         inside a pure function */\n@@ -2443,7 +2475,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         alt lookup_method(fcx, op_ex, callee_id, opname, self_t, []) {\n           some(origin) {\n             let method_ty = ty::node_id_to_type(fcx.ccx.tcx, callee_id);\n-            check_call_or_bind(fcx, op_ex.span, op_ex.id, method_ty, args);\n+            check_call_or_bind(fcx, op_ex.span, method_ty, args);\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n             some(ty::ty_fn_ret(method_ty))\n           }\n@@ -2773,8 +2805,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_bind(f, args) {\n         // Call the generic checker.\n         bot = check_expr(fcx, f);\n-        let ccobr = check_call_or_bind(fcx, expr.span, expr.id,\n-                                       expr_ty(tcx, f), args);\n+        let ccobr = check_call_or_bind(fcx, expr.span, expr_ty(tcx, f), args);\n         bot |= ccobr.bot;\n \n         // TODO: Perform substitutions on the return type.\n@@ -3482,9 +3513,9 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         check_fn(ccx, ast::proto_bare, decl, body, dtor_id, none);\n       }\n       ast::item_impl(tps, _, ty, ms) {\n-        let self_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n-        let self_region = ty::re_self({crate: ast::local_crate, node: it.id});\n-        let self_ty = instantiate_self_regions(ccx.tcx, self_region, self_ty);\n+        let mut self_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n+        let self_region = ty::re_self;\n+        self_ty = instantiate_self_regions(ccx.tcx, self_region, self_ty);\n         ccx.self_infos += [self_impl(self_ty)];\n         for m in ms { check_method(ccx, m); }\n         vec::pop(ccx.self_infos);"}, {"sha": "032f3620631dfb03d505a27394a76167252f0346", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=7931a61ebb689723526bf14857ff06b6b7db2cfd", "patch": "@@ -12,20 +12,6 @@ import driver::session::session;\n \n fn region_to_str(cx: ctxt, region: region) -> str {\n     alt region {\n-      re_named(_)   { \"<name>\" }    // TODO: include name\n-      re_caller(def_id) {\n-        if def_id.crate == ast::local_crate {\n-            alt cx.items.get(def_id.node) {\n-              ast_map::node_item(item, path) {\n-                #fmt(\"<caller of %s::%s>\", ast_map::path_to_str(*path),\n-                     item.ident)\n-              }\n-              _ { \"<caller>\" }\n-            }\n-        } else {\n-            \"<caller>\"\n-        }\n-      }\n       re_block(node_id) {\n         alt cx.items.get(node_id) {\n             ast_map::node_block(blk) {\n@@ -35,8 +21,10 @@ fn region_to_str(cx: ctxt, region: region) -> str {\n             _ { cx.sess.bug(\"re_block refers to non-block\") }\n         }\n       }\n-      re_self(_)    { \"self\" }\n+      re_self       { \"self\" }\n       re_inferred   { \"\" }\n+      re_param(id)  { #fmt(\"<P%u>\", id) }    // TODO: do better than this\n+      re_var(id)    { #fmt(\"<R%u>\", id) }    // TODO: do better than this\n     }\n }\n "}, {"sha": "4e0cd5b1aee1fc907cd572f09b0ec79031be0a54", "filename": "src/test/run-pass/regions-self-impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7931a61ebb689723526bf14857ff06b6b7db2cfd/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs?ref=7931a61ebb689723526bf14857ff06b6b7db2cfd", "patch": "@@ -7,5 +7,6 @@ impl clam for clam {\n fn main() {\n     let clam = { chowder: &3 };\n     log(debug, *clam.get_chowder());\n+    clam.get_chowder();\n }\n "}]}