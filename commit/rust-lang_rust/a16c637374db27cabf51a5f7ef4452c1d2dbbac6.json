{"sha": "a16c637374db27cabf51a5f7ef4452c1d2dbbac6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNmM2MzczNzRkYjI3Y2FiZjUxYTVmN2VmNDQ1MmMxZDJkYmJhYzY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-04T05:24:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-04T05:24:37Z"}, "message": "Rollup merge of #65026 - petrochenkov:ice1, r=eddyb\n\nmetadata: Some crate loading cleanup\n\nSo, my goal was to fix caching of loaded crates which is broken and causes ICEs like #56935 or #64450.\nWhile investigating I found that the code is pretty messy and likes to confuse various things that look similar but are actually different.\nThis PR does some initial cleanup in that area, I hope to get to the caching itself a bit later.", "tree": {"sha": "43ea1d1d15235c483656afe278f059613c1d19f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43ea1d1d15235c483656afe278f059613c1d19f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a16c637374db27cabf51a5f7ef4452c1d2dbbac6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdlteWCRBK7hj4Ov3rIwAAdHIIAB+yvbtJX5Xm+qhTUrdaS0RL\nd1TUAzhSxU1AF81H7tCg4Ep8EyiyEkZFGKyqahOyzOkbI0+L0fZjZ5gs1aFFNAfw\nMgr5xdjMi9xj+f+igvVfgVwUZOfByGoGy0cQgQ++pTDZH/VSuN/H3cGu9Ilu/J5x\nNy61qUB/cWcv347fZ815ahHpQY5NNZv9XfjlK9btxiXY1e38HRgz1gTTJ/ByLU4b\nvStVpuSeqCxeolT2qGysuPEPsaPvhhfSsFD+xUHOos5+xvpZKsvol3VSTV8dUEYa\n23tpQrx1ViHr2STV3+910GLg+tDmoaY6aerO6aQ8LAtp6uQY553qLrQHj0tA6GU=\n=RxS6\n-----END PGP SIGNATURE-----\n", "payload": "tree 43ea1d1d15235c483656afe278f059613c1d19f0\nparent cb4145e7598108c239271fbdd50c4f5a0c6031e1\nparent 68aadcb2ae16cc9d6845eefde3ad49b214731954\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1570166677 +0200\ncommitter GitHub <noreply@github.com> 1570166677 +0200\n\nRollup merge of #65026 - petrochenkov:ice1, r=eddyb\n\nmetadata: Some crate loading cleanup\n\nSo, my goal was to fix caching of loaded crates which is broken and causes ICEs like #56935 or #64450.\nWhile investigating I found that the code is pretty messy and likes to confuse various things that look similar but are actually different.\nThis PR does some initial cleanup in that area, I hope to get to the caching itself a bit later.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a16c637374db27cabf51a5f7ef4452c1d2dbbac6", "html_url": "https://github.com/rust-lang/rust/commit/a16c637374db27cabf51a5f7ef4452c1d2dbbac6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb4145e7598108c239271fbdd50c4f5a0c6031e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb4145e7598108c239271fbdd50c4f5a0c6031e1", "html_url": "https://github.com/rust-lang/rust/commit/cb4145e7598108c239271fbdd50c4f5a0c6031e1"}, {"sha": "68aadcb2ae16cc9d6845eefde3ad49b214731954", "url": "https://api.github.com/repos/rust-lang/rust/commits/68aadcb2ae16cc9d6845eefde3ad49b214731954", "html_url": "https://github.com/rust-lang/rust/commit/68aadcb2ae16cc9d6845eefde3ad49b214731954"}], "stats": {"total": 214, "additions": 85, "deletions": 129}, "files": [{"sha": "510787998ad071c969f8cab544042737ecbb4418", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=a16c637374db27cabf51a5f7ef4452c1d2dbbac6", "patch": "@@ -148,9 +148,7 @@ pub enum ExternCrateSource {\n         /// such ids\n         DefId,\n     ),\n-    // Crate is loaded by `use`.\n-    Use,\n-    /// Crate is implicitly loaded by an absolute path.\n+    /// Crate is implicitly loaded by a path resolving through extern prelude.\n     Path,\n }\n "}, {"sha": "042252bc13e615c9a052a6328e6567f6b4445e1b", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 62, "deletions": 87, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=a16c637374db27cabf51a5f7ef4452c1d2dbbac6", "patch": "@@ -2,7 +2,7 @@\n \n use crate::cstore::{self, CStore, CrateSource, MetadataBlob};\n use crate::locator::{self, CratePaths};\n-use crate::schema::{CrateRoot};\n+use crate::schema::{CrateRoot, CrateDep};\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n use rustc::hir::def_id::CrateNum;\n@@ -20,7 +20,7 @@ use rustc::hir::map::Definitions;\n use rustc::hir::def_id::LOCAL_CRATE;\n \n use std::ops::Deref;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::{cmp, fs};\n \n use syntax::ast;\n@@ -112,7 +112,7 @@ impl<'a> CrateLoader<'a> {\n                       -> Option<CrateNum> {\n         let mut ret = None;\n         self.cstore.iter_crate_data(|cnum, data| {\n-            if data.name != name { return }\n+            if data.root.name != name { return }\n \n             match hash {\n                 Some(hash) if *hash == data.root.hash => { ret = Some(cnum); return }\n@@ -190,8 +190,7 @@ impl<'a> CrateLoader<'a> {\n     fn register_crate(\n         &mut self,\n         host_lib: Option<Library>,\n-        root: &Option<CratePaths>,\n-        ident: Symbol,\n+        root: Option<&CratePaths>,\n         span: Span,\n         lib: Library,\n         dep_kind: DepKind,\n@@ -204,40 +203,40 @@ impl<'a> CrateLoader<'a> {\n             .map(|e| e.is_private_dep)\n             .unwrap_or(false);\n \n-        info!(\"register crate `extern crate {} as {}` (private_dep = {})\",\n-            crate_root.name, ident, private_dep);\n-\n+        info!(\"register crate `{}` (private_dep = {})\", crate_root.name, private_dep);\n \n         // Claim this crate number and cache it\n         let cnum = self.cstore.alloc_new_crate_num();\n \n+        // Maintain a reference to the top most crate.\n         // Stash paths for top-most crate locally if necessary.\n-        let crate_paths = if root.is_none() {\n-            Some(CratePaths {\n-                ident: ident.to_string(),\n+        let crate_paths;\n+        let root = if let Some(root) = root {\n+            root\n+        } else {\n+            crate_paths = CratePaths {\n+                ident: crate_root.name.to_string(),\n                 dylib: lib.dylib.clone().map(|p| p.0),\n                 rlib:  lib.rlib.clone().map(|p| p.0),\n                 rmeta: lib.rmeta.clone().map(|p| p.0),\n-            })\n-        } else {\n-            None\n+            };\n+            &crate_paths\n         };\n-        // Maintain a reference to the top most crate.\n-        let root = if root.is_some() { root } else { &crate_paths };\n \n         let Library { dylib, rlib, rmeta, metadata } = lib;\n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n         let raw_proc_macros =  crate_root.proc_macro_data.map(|_| {\n-            if self.sess.opts.debugging_opts.dual_proc_macros {\n-                let host_lib = host_lib.as_ref().unwrap();\n-                self.dlsym_proc_macros(host_lib.dylib.as_ref().map(|p| p.0.clone()),\n-                                       &host_lib.metadata.get_root(), span)\n-            } else {\n-                self.dlsym_proc_macros(dylib.clone().map(|p| p.0), &crate_root, span)\n-            }\n+            let temp_root;\n+            let (dlsym_dylib, dlsym_root) = match &host_lib {\n+                Some(host_lib) =>\n+                    (&host_lib.dylib, { temp_root = host_lib.metadata.get_root(); &temp_root }),\n+                None => (&dylib, &crate_root),\n+            };\n+            let dlsym_dylib = dlsym_dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n+            self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator, span)\n         });\n \n         let interpret_alloc_index: Vec<u32> = crate_root.interpret_alloc_index\n@@ -254,8 +253,6 @@ impl<'a> CrateLoader<'a> {\n         });\n \n         let cmeta = cstore::CrateMetadata {\n-            name: crate_root.name,\n-            imported_name: ident,\n             extern_crate: Lock::new(None),\n             def_path_table: Lrc::new(def_path_table),\n             trait_impls,\n@@ -274,7 +271,6 @@ impl<'a> CrateLoader<'a> {\n             },\n             private_dep,\n             span,\n-            host_lib,\n             raw_proc_macros\n         };\n \n@@ -340,24 +336,34 @@ impl<'a> CrateLoader<'a> {\n \n     fn resolve_crate<'b>(\n         &'b mut self,\n-        root: &'b Option<CratePaths>,\n-        ident: Symbol,\n         name: Symbol,\n-        hash: Option<&'b Svh>,\n-        extra_filename: Option<&'b str>,\n         span: Span,\n-        path_kind: PathKind,\n+        dep_kind: DepKind,\n+        dep: Option<(&'b CratePaths, &'b CrateDep)>,\n+    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+        self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n+    }\n+\n+    fn maybe_resolve_crate<'b>(\n+        &'b mut self,\n+        name: Symbol,\n+        span: Span,\n         mut dep_kind: DepKind,\n+        dep: Option<(&'b CratePaths, &'b CrateDep)>,\n     ) -> Result<(CrateNum, Lrc<cstore::CrateMetadata>), LoadError<'b>> {\n-        info!(\"resolving crate `extern crate {} as {}`\", name, ident);\n+        info!(\"resolving crate `{}`\", name);\n+        let (root, hash, extra_filename, path_kind) = match dep {\n+            Some((root, dep)) =>\n+                (Some(root), Some(&dep.hash), Some(&dep.extra_filename[..]), PathKind::Dependency),\n+            None => (None, None, None, PathKind::Crate),\n+        };\n         let result = if let Some(cnum) = self.existing_match(name, hash, path_kind) {\n             (LoadResult::Previous(cnum), None)\n         } else {\n             info!(\"falling back to a load\");\n             let mut locate_ctxt = locator::Context {\n                 sess: self.sess,\n                 span,\n-                ident,\n                 crate_name: name,\n                 hash,\n                 extra_filename,\n@@ -393,7 +399,7 @@ impl<'a> CrateLoader<'a> {\n                 Ok((cnum, data))\n             }\n             (LoadResult::Loaded(library), host_library) => {\n-                Ok(self.register_crate(host_library, root, ident, span, library, dep_kind, name))\n+                Ok(self.register_crate(host_library, root, span, library, dep_kind, name))\n             }\n             _ => panic!()\n         }\n@@ -469,7 +475,7 @@ impl<'a> CrateLoader<'a> {\n \n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n-                          root: &Option<CratePaths>,\n+                          root: &CratePaths,\n                           crate_root: &CrateRoot<'_>,\n                           metadata: &MetadataBlob,\n                           krate: CrateNum,\n@@ -484,9 +490,7 @@ impl<'a> CrateLoader<'a> {\n         // The map from crate numbers in the crate we're resolving to local crate numbers.\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n-        std::iter::once(krate).chain(crate_root.crate_deps\n-                                                 .decode(metadata)\n-                                                 .map(|dep| {\n+        std::iter::once(krate).chain(crate_root.crate_deps.decode(metadata).map(|dep| {\n             info!(\"resolving dep crate {} hash: `{}` extra filename: `{}`\", dep.name, dep.hash,\n                   dep.extra_filename);\n             if dep.kind == DepKind::UnexportedMacrosOnly {\n@@ -496,32 +500,26 @@ impl<'a> CrateLoader<'a> {\n                 DepKind::MacrosOnly => DepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n-            let (local_cnum, ..) = self.resolve_crate(\n-                root, dep.name, dep.name, Some(&dep.hash), Some(&dep.extra_filename), span,\n-                PathKind::Dependency, dep_kind,\n-            ).unwrap_or_else(|err| err.report());\n-            local_cnum\n+            self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep))).0\n         })).collect()\n     }\n \n-    fn read_extension_crate(&mut self, span: Span, orig_name: Symbol, rename: Symbol)\n-                            -> ExtensionCrate {\n-        info!(\"read extension crate `extern crate {} as {}`\", orig_name, rename);\n+    fn read_extension_crate(&mut self, name: Symbol, span: Span) -> ExtensionCrate {\n+        info!(\"read extension crate `{}`\", name);\n         let target_triple = self.sess.opts.target_triple.clone();\n         let host_triple = TargetTriple::from_triple(config::host_triple());\n         let is_cross = target_triple != host_triple;\n         let mut target_only = false;\n         let mut locate_ctxt = locator::Context {\n             sess: self.sess,\n             span,\n-            ident: orig_name,\n-            crate_name: rename,\n+            crate_name: name,\n             hash: None,\n             extra_filename: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             target: &self.sess.host,\n             triple: host_triple,\n-            root: &None,\n+            root: None,\n             rejected_via_hash: vec![],\n             rejected_via_triple: vec![],\n             rejected_via_kind: vec![],\n@@ -570,25 +568,21 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn dlsym_proc_macros(&self,\n-                         dylib: Option<PathBuf>,\n-                         root: &CrateRoot<'_>,\n+                         path: &Path,\n+                         disambiguator: CrateDisambiguator,\n                          span: Span\n     ) -> &'static [ProcMacro] {\n         use std::env;\n         use crate::dynamic_lib::DynamicLibrary;\n \n-        let path = match dylib {\n-            Some(dylib) => dylib,\n-            None => span_bug!(span, \"proc-macro crate not dylib\"),\n-        };\n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(path);\n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,\n             Err(err) => self.sess.span_fatal(span, &err),\n         };\n \n-        let sym = self.sess.generate_proc_macro_decls_symbol(root.disambiguator);\n+        let sym = self.sess.generate_proc_macro_decls_symbol(disambiguator);\n         let decls = unsafe {\n             let sym = match lib.symbol(&sym) {\n                 Ok(f) => f,\n@@ -610,7 +604,7 @@ impl<'a> CrateLoader<'a> {\n                                  span: Span,\n                                  name: Symbol)\n                                  -> Option<(PathBuf, CrateDisambiguator)> {\n-        let ekrate = self.read_extension_crate(span, name, name);\n+        let ekrate = self.read_extension_crate(name, span);\n \n         if ekrate.target_only {\n             // Need to abort before syntax expansion.\n@@ -701,10 +695,7 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let dep_kind = DepKind::Implicit;\n-        let (cnum, data) =\n-            self.resolve_crate(&None, name, name, None, None, DUMMY_SP, PathKind::Crate, dep_kind)\n-                .unwrap_or_else(|err| err.report());\n+        let (cnum, data) = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n@@ -794,26 +785,21 @@ impl<'a> CrateLoader<'a> {\n \n             let mut uses_std = false;\n             self.cstore.iter_crate_data(|_, data| {\n-                if data.name == sym::std {\n+                if data.root.name == sym::std {\n                     uses_std = true;\n                 }\n             });\n \n             if uses_std {\n-                let name = match *sanitizer {\n+                let name = Symbol::intern(match sanitizer {\n                     Sanitizer::Address => \"rustc_asan\",\n                     Sanitizer::Leak => \"rustc_lsan\",\n                     Sanitizer::Memory => \"rustc_msan\",\n                     Sanitizer::Thread => \"rustc_tsan\",\n-                };\n+                });\n                 info!(\"loading sanitizer: {}\", name);\n \n-                let symbol = Symbol::intern(name);\n-                let dep_kind = DepKind::Explicit;\n-                let (_, data) =\n-                    self.resolve_crate(&None, symbol, symbol, None, None, DUMMY_SP,\n-                                       PathKind::Crate, dep_kind)\n-                        .unwrap_or_else(|err| err.report());\n+                let data = self.resolve_crate(name, DUMMY_SP, DepKind::Explicit, None).1;\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n                 if !data.root.sanitizer_runtime {\n@@ -832,12 +818,8 @@ impl<'a> CrateLoader<'a> {\n         {\n             info!(\"loading profiler\");\n \n-            let symbol = Symbol::intern(\"profiler_builtins\");\n-            let dep_kind = DepKind::Implicit;\n-            let (_, data) =\n-                self.resolve_crate(&None, symbol, symbol, None, None, DUMMY_SP,\n-                                   PathKind::Crate, dep_kind)\n-                    .unwrap_or_else(|err| err.report());\n+            let name = Symbol::intern(\"profiler_builtins\");\n+            let data = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None).1;\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n             if !data.root.profiler_runtime {\n@@ -1004,7 +986,7 @@ impl<'a> CrateLoader<'a> {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 debug!(\"resolving extern crate stmt. ident: {} orig_name: {:?}\",\n                        item.ident, orig_name);\n-                let orig_name = match orig_name {\n+                let name = match orig_name {\n                     Some(orig_name) => {\n                         crate::validate_crate_name(Some(self.sess), &orig_name.as_str(),\n                                             Some(item.span));\n@@ -1018,10 +1000,7 @@ impl<'a> CrateLoader<'a> {\n                     DepKind::Explicit\n                 };\n \n-                let (cnum, ..) = self.resolve_crate(\n-                    &None, item.ident.name, orig_name, None, None,\n-                    item.span, PathKind::Crate, dep_kind,\n-                ).unwrap_or_else(|err| err.report());\n+                let cnum = self.resolve_crate(name, item.span, dep_kind, None).0;\n \n                 let def_id = definitions.opt_local_def_id(item.id).unwrap();\n                 let path_len = definitions.def_path(def_id.index).data.len();\n@@ -1047,9 +1026,7 @@ impl<'a> CrateLoader<'a> {\n         name: Symbol,\n         span: Span,\n     ) -> CrateNum {\n-        let cnum = self.resolve_crate(\n-            &None, name, name, None, None, span, PathKind::Crate, DepKind::Explicit\n-        ).unwrap_or_else(|err| err.report()).0;\n+        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None).0;\n \n         self.update_extern_crate(\n             cnum,\n@@ -1071,9 +1048,7 @@ impl<'a> CrateLoader<'a> {\n         name: Symbol,\n         span: Span,\n     ) -> Option<CrateNum> {\n-        let cnum = self.resolve_crate(\n-            &None, name, name, None, None, span, PathKind::Crate, DepKind::Explicit\n-        ).ok()?.0;\n+        let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?.0;\n \n         self.update_extern_crate(\n             cnum,"}, {"sha": "833c846573f6339176a752d8b68cae94792921eb", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=a16c637374db27cabf51a5f7ef4452c1d2dbbac6", "patch": "@@ -12,7 +12,6 @@ use rustc::util::nodemap::{FxHashMap, NodeMap};\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n use syntax::ast;\n use syntax::ext::base::SyntaxExtension;\n-use syntax::symbol::Symbol;\n use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePreference};\n@@ -28,7 +27,6 @@ pub use crate::cstore_impl::{provide, provide_extern};\n pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n pub use rustc_data_structures::sync::MetadataRef;\n-use crate::creader::Library;\n use syntax_pos::Span;\n use proc_macro::bridge::client::ProcMacro;\n \n@@ -46,13 +44,6 @@ pub struct ImportedSourceFile {\n }\n \n pub struct CrateMetadata {\n-    /// Original name of the crate.\n-    pub name: Symbol,\n-\n-    /// Name of the crate as imported. I.e., if imported with\n-    /// `extern crate foo as bar;` this will be `bar`.\n-    pub imported_name: Symbol,\n-\n     /// Information about the extern crate that caused this crate to\n     /// be loaded. If this is `None`, then the crate was injected\n     /// (e.g., by the allocator)\n@@ -89,7 +80,6 @@ pub struct CrateMetadata {\n     /// for purposes of the 'exported_private_dependencies' lint\n     pub private_dep: bool,\n \n-    pub host_lib: Option<Library>,\n     pub span: Span,\n \n     pub raw_proc_macros: Option<&'static [ProcMacro]>,"}, {"sha": "91532d84473ab173338a8b120bc7e283388afb9c", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=a16c637374db27cabf51a5f7ef4452c1d2dbbac6", "patch": "@@ -217,7 +217,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         let r = *cdata.dep_kind.lock();\n         r\n     }\n-    crate_name => { cdata.name }\n+    crate_name => { cdata.root.name }\n     item_children => {\n         let mut result = SmallVec::<[_; 8]>::new();\n         cdata.each_child_of_item(def_id.index, |child| result.push(child), tcx.sess);\n@@ -450,8 +450,7 @@ impl cstore::CStore {\n         }\n \n         let def = data.get_macro(id.index);\n-        let macro_full_name = data.def_path(id.index)\n-            .to_string_friendly(|_| data.imported_name);\n+        let macro_full_name = data.def_path(id.index).to_string_friendly(|_| data.root.name);\n         let source_name = FileName::Macros(macro_full_name);\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);\n@@ -501,7 +500,7 @@ impl CrateStore for cstore::CStore {\n \n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol\n     {\n-        self.get_crate_data(cnum).name\n+        self.get_crate_data(cnum).root.name\n     }\n \n     fn crate_is_private_dep_untracked(&self, cnum: CrateNum) -> bool {"}, {"sha": "34f86707ad3222606bbb5960daf50db4c8d6fc28", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=a16c637374db27cabf51a5f7ef4452c1d2dbbac6", "patch": "@@ -473,7 +473,7 @@ impl<'a, 'tcx> CrateMetadata {\n             None => {\n                 bug!(\"entry: id not found: {:?} in crate {:?} with number {}\",\n                      item_id,\n-                     self.name,\n+                     self.root.name,\n                      self.cnum)\n             }\n             Some(d) => d.decode(self),\n@@ -543,18 +543,13 @@ impl<'a, 'tcx> CrateMetadata {\n                 name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n             )\n         };\n-        let edition = if sess.opts.debugging_opts.dual_proc_macros {\n-            self.host_lib.as_ref().unwrap().metadata.get_root().edition\n-        } else {\n-            self.root.edition\n-        };\n \n         SyntaxExtension::new(\n             &sess.parse_sess,\n             kind,\n             self.get_span(id, sess),\n             helper_attrs,\n-            edition,\n+            self.root.edition,\n             Symbol::intern(name),\n             &self.get_attributes(&self.entry(id), sess),\n         )"}, {"sha": "8df236c41cfb888a88bf0556bec35a2d1046ee1b", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=a16c637374db27cabf51a5f7ef4452c1d2dbbac6", "patch": "@@ -254,15 +254,14 @@ pub struct CrateMismatch {\n pub struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n-    pub ident: Symbol,\n     pub crate_name: Symbol,\n     pub hash: Option<&'a Svh>,\n     pub extra_filename: Option<&'a str>,\n     // points to either self.sess.target.target or self.sess.host, must match triple\n     pub target: &'a Target,\n     pub triple: TargetTriple,\n     pub filesearch: FileSearch<'a>,\n-    pub root: &'a Option<CratePaths>,\n+    pub root: Option<&'a CratePaths>,\n     pub rejected_via_hash: Vec<CrateMismatch>,\n     pub rejected_via_triple: Vec<CrateMismatch>,\n     pub rejected_via_kind: Vec<CrateMismatch>,\n@@ -323,25 +322,25 @@ impl<'a> Context<'a> {\n \n     pub fn report_errs(self) -> ! {\n         let add = match self.root {\n-            &None => String::new(),\n-            &Some(ref r) => format!(\" which `{}` depends on\", r.ident),\n+            None => String::new(),\n+            Some(r) => format!(\" which `{}` depends on\", r.ident),\n         };\n         let mut msg = \"the following crate versions were found:\".to_string();\n         let mut err = if !self.rejected_via_hash.is_empty() {\n             let mut err = struct_span_err!(self.sess,\n                                            self.span,\n                                            E0460,\n                                            \"found possibly newer version of crate `{}`{}\",\n-                                           self.ident,\n+                                           self.crate_name,\n                                            add);\n             err.note(\"perhaps that crate needs to be recompiled?\");\n             let mismatches = self.rejected_via_hash.iter();\n             for &CrateMismatch { ref path, .. } in mismatches {\n-                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.ident, path.display()));\n+                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.crate_name, path.display()));\n             }\n             match self.root {\n-                &None => {}\n-                &Some(ref r) => {\n+                None => {}\n+                Some(r) => {\n                     for path in r.paths().iter() {\n                         msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.ident, path.display()));\n                     }\n@@ -355,13 +354,13 @@ impl<'a> Context<'a> {\n                                            E0461,\n                                            \"couldn't find crate `{}` \\\n                                             with expected target triple {}{}\",\n-                                           self.ident,\n+                                           self.crate_name,\n                                            self.triple,\n                                            add);\n             let mismatches = self.rejected_via_triple.iter();\n             for &CrateMismatch { ref path, ref got } in mismatches {\n                 msg.push_str(&format!(\"\\ncrate `{}`, target triple {}: {}\",\n-                                      self.ident,\n+                                      self.crate_name,\n                                       got,\n                                       path.display()));\n             }\n@@ -372,12 +371,12 @@ impl<'a> Context<'a> {\n                                            self.span,\n                                            E0462,\n                                            \"found staticlib `{}` instead of rlib or dylib{}\",\n-                                           self.ident,\n+                                           self.crate_name,\n                                            add);\n             err.help(\"please recompile that crate using --crate-type lib\");\n             let mismatches = self.rejected_via_kind.iter();\n             for &CrateMismatch { ref path, .. } in mismatches {\n-                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.ident, path.display()));\n+                msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.crate_name, path.display()));\n             }\n             err.note(&msg);\n             err\n@@ -387,14 +386,14 @@ impl<'a> Context<'a> {\n                                            E0514,\n                                            \"found crate `{}` compiled by an incompatible version \\\n                                             of rustc{}\",\n-                                           self.ident,\n+                                           self.crate_name,\n                                            add);\n             err.help(&format!(\"please recompile that crate using this compiler ({})\",\n                               rustc_version()));\n             let mismatches = self.rejected_via_version.iter();\n             for &CrateMismatch { ref path, ref got } in mismatches {\n                 msg.push_str(&format!(\"\\ncrate `{}` compiled by {}: {}\",\n-                                      self.ident,\n+                                      self.crate_name,\n                                       got,\n                                       path.display()));\n             }\n@@ -405,10 +404,10 @@ impl<'a> Context<'a> {\n                                            self.span,\n                                            E0463,\n                                            \"can't find crate for `{}`{}\",\n-                                           self.ident,\n+                                           self.crate_name,\n                                            add);\n \n-            if (self.ident == sym::std || self.ident == sym::core)\n+            if (self.crate_name == sym::std || self.crate_name == sym::core)\n                 && self.triple != TargetTriple::from_triple(config::host_triple()) {\n                 err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n             }"}, {"sha": "975209efb0c1ba2c63d6646fb9d79e0c622bffdf", "filename": "src/test/ui/use/use-meta-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Ftest%2Fui%2Fuse%2Fuse-meta-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Ftest%2Fui%2Fuse%2Fuse-meta-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-meta-mismatch.rs?ref=a16c637374db27cabf51a5f7ef4452c1d2dbbac6", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:can't find crate for `extra`\n+// error-pattern:can't find crate for `fake_crate`\n \n extern crate fake_crate as extra;\n "}, {"sha": "62b71fe8e12f497809f8795a6f026f7f60ad7ea0", "filename": "src/test/ui/use/use-meta-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Ftest%2Fui%2Fuse%2Fuse-meta-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a16c637374db27cabf51a5f7ef4452c1d2dbbac6/src%2Ftest%2Fui%2Fuse%2Fuse-meta-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-meta-mismatch.stderr?ref=a16c637374db27cabf51a5f7ef4452c1d2dbbac6", "patch": "@@ -1,4 +1,4 @@\n-error[E0463]: can't find crate for `extra`\n+error[E0463]: can't find crate for `fake_crate`\n   --> $DIR/use-meta-mismatch.rs:3:1\n    |\n LL | extern crate fake_crate as extra;"}]}