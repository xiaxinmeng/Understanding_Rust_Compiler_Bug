{"sha": "8ba22504e8e5dcbbe136d97f63c1280dabc523d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYTIyNTA0ZThlNWRjYmJlMTM2ZDk3ZjYzYzEyODBkYWJjNTIzZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-25T18:52:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-25T18:52:11Z"}, "message": "Auto merge of #74275 - wesleywiser:break_up_partitioning_rs, r=pnkfelix\n\nRefactor the partitioning module to make it easier to introduce new algorithms\n\nI've split the `librustc_mir::monomorphize::partitioning` module into a few files and introduced a `Partitioner` trait which allows us to decouple the partitioning algorithm from the code which integrates it into the query system. This should allow us to introduce new partitioning algorithms much more easily. I've also gone ahead and added a `-Z` flag to control which algorithm is used (currently there is only the `default`).\n\nI left a few comments in places where things might be improved further.\n\nr? @pnkfelix cc @rust-lang/wg-incr-comp", "tree": {"sha": "29a5eca62b3f61c36570f5701fc89378ac8fef08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29a5eca62b3f61c36570f5701fc89378ac8fef08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ba22504e8e5dcbbe136d97f63c1280dabc523d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ba22504e8e5dcbbe136d97f63c1280dabc523d0", "html_url": "https://github.com/rust-lang/rust/commit/8ba22504e8e5dcbbe136d97f63c1280dabc523d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ba22504e8e5dcbbe136d97f63c1280dabc523d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba4c4468f5e77a46369968631677b5436f342c86", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba4c4468f5e77a46369968631677b5436f342c86", "html_url": "https://github.com/rust-lang/rust/commit/ba4c4468f5e77a46369968631677b5436f342c86"}, {"sha": "98b943e7d821aff17fefbf1a094503f9ae172a4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/98b943e7d821aff17fefbf1a094503f9ae172a4a", "html_url": "https://github.com/rust-lang/rust/commit/98b943e7d821aff17fefbf1a094503f9ae172a4a"}], "stats": {"total": 2109, "additions": 1097, "deletions": 1012}, "files": [{"sha": "6162651db14a0b8d8780a5fadd6e32351eaa5f74", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "removed", "additions": 0, "deletions": 1012, "changes": 1012, "blob_url": "https://github.com/rust-lang/rust/blob/ba4c4468f5e77a46369968631677b5436f342c86/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba4c4468f5e77a46369968631677b5436f342c86/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=ba4c4468f5e77a46369968631677b5436f342c86", "patch": "@@ -1,1012 +0,0 @@\n-//! Partitioning Codegen Units for Incremental Compilation\n-//! ======================================================\n-//!\n-//! The task of this module is to take the complete set of monomorphizations of\n-//! a crate and produce a set of codegen units from it, where a codegen unit\n-//! is a named set of (mono-item, linkage) pairs. That is, this module\n-//! decides which monomorphization appears in which codegen units with which\n-//! linkage. The following paragraphs describe some of the background on the\n-//! partitioning scheme.\n-//!\n-//! The most important opportunity for saving on compilation time with\n-//! incremental compilation is to avoid re-codegenning and re-optimizing code.\n-//! Since the unit of codegen and optimization for LLVM is \"modules\" or, how\n-//! we call them \"codegen units\", the particulars of how much time can be saved\n-//! by incremental compilation are tightly linked to how the output program is\n-//! partitioned into these codegen units prior to passing it to LLVM --\n-//! especially because we have to treat codegen units as opaque entities once\n-//! they are created: There is no way for us to incrementally update an existing\n-//! LLVM module and so we have to build any such module from scratch if it was\n-//! affected by some change in the source code.\n-//!\n-//! From that point of view it would make sense to maximize the number of\n-//! codegen units by, for example, putting each function into its own module.\n-//! That way only those modules would have to be re-compiled that were actually\n-//! affected by some change, minimizing the number of functions that could have\n-//! been re-used but just happened to be located in a module that is\n-//! re-compiled.\n-//!\n-//! However, since LLVM optimization does not work across module boundaries,\n-//! using such a highly granular partitioning would lead to very slow runtime\n-//! code since it would effectively prohibit inlining and other inter-procedure\n-//! optimizations. We want to avoid that as much as possible.\n-//!\n-//! Thus we end up with a trade-off: The bigger the codegen units, the better\n-//! LLVM's optimizer can do its work, but also the smaller the compilation time\n-//! reduction we get from incremental compilation.\n-//!\n-//! Ideally, we would create a partitioning such that there are few big codegen\n-//! units with few interdependencies between them. For now though, we use the\n-//! following heuristic to determine the partitioning:\n-//!\n-//! - There are two codegen units for every source-level module:\n-//! - One for \"stable\", that is non-generic, code\n-//! - One for more \"volatile\" code, i.e., monomorphized instances of functions\n-//!   defined in that module\n-//!\n-//! In order to see why this heuristic makes sense, let's take a look at when a\n-//! codegen unit can get invalidated:\n-//!\n-//! 1. The most straightforward case is when the BODY of a function or global\n-//! changes. Then any codegen unit containing the code for that item has to be\n-//! re-compiled. Note that this includes all codegen units where the function\n-//! has been inlined.\n-//!\n-//! 2. The next case is when the SIGNATURE of a function or global changes. In\n-//! this case, all codegen units containing a REFERENCE to that item have to be\n-//! re-compiled. This is a superset of case 1.\n-//!\n-//! 3. The final and most subtle case is when a REFERENCE to a generic function\n-//! is added or removed somewhere. Even though the definition of the function\n-//! might be unchanged, a new REFERENCE might introduce a new monomorphized\n-//! instance of this function which has to be placed and compiled somewhere.\n-//! Conversely, when removing a REFERENCE, it might have been the last one with\n-//! that particular set of generic arguments and thus we have to remove it.\n-//!\n-//! From the above we see that just using one codegen unit per source-level\n-//! module is not such a good idea, since just adding a REFERENCE to some\n-//! generic item somewhere else would invalidate everything within the module\n-//! containing the generic item. The heuristic above reduces this detrimental\n-//! side-effect of references a little by at least not touching the non-generic\n-//! code of the module.\n-//!\n-//! A Note on Inlining\n-//! ------------------\n-//! As briefly mentioned above, in order for LLVM to be able to inline a\n-//! function call, the body of the function has to be available in the LLVM\n-//! module where the call is made. This has a few consequences for partitioning:\n-//!\n-//! - The partitioning algorithm has to take care of placing functions into all\n-//!   codegen units where they should be available for inlining. It also has to\n-//!   decide on the correct linkage for these functions.\n-//!\n-//! - The partitioning algorithm has to know which functions are likely to get\n-//!   inlined, so it can distribute function instantiations accordingly. Since\n-//!   there is no way of knowing for sure which functions LLVM will decide to\n-//!   inline in the end, we apply a heuristic here: Only functions marked with\n-//!   `#[inline]` are considered for inlining by the partitioner. The current\n-//!   implementation will not try to determine if a function is likely to be\n-//!   inlined by looking at the functions definition.\n-//!\n-//! Note though that as a side-effect of creating a codegen units per\n-//! source-level module, functions from the same module will be available for\n-//! inlining, even when they are not marked `#[inline]`.\n-\n-use std::cmp;\n-use std::collections::hash_map::Entry;\n-\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync;\n-use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdSet, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n-use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, Linkage, Visibility};\n-use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n-use rustc_middle::ty::print::characteristic_def_id_of_type;\n-use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, DefIdTree, InstanceDef, TyCtxt};\n-use rustc_span::symbol::{Symbol, SymbolStr};\n-\n-use crate::monomorphize::collector::InliningMap;\n-use crate::monomorphize::collector::{self, MonoItemCollectionMode};\n-\n-// Anything we can't find a proper codegen unit for goes into this.\n-fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n-    name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n-}\n-\n-pub fn partition<'tcx, I>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_items: I,\n-    max_cgu_count: usize,\n-    inlining_map: &InliningMap<'tcx>,\n-) -> Vec<CodegenUnit<'tcx>>\n-where\n-    I: Iterator<Item = MonoItem<'tcx>>,\n-{\n-    let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n-\n-    // In the first step, we place all regular monomorphizations into their\n-    // respective 'home' codegen unit. Regular monomorphizations are all\n-    // functions and statics defined in the local crate.\n-    let mut initial_partitioning = {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n-        place_root_mono_items(tcx, mono_items)\n-    };\n-\n-    initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n-\n-    debug_dump(tcx, \"INITIAL PARTITIONING:\", initial_partitioning.codegen_units.iter());\n-\n-    // Merge until we have at most `max_cgu_count` codegen units.\n-    {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        merge_codegen_units(tcx, &mut initial_partitioning, max_cgu_count);\n-        debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n-    }\n-\n-    // In the next step, we use the inlining map to determine which additional\n-    // monomorphizations have to go into each codegen unit. These additional\n-    // monomorphizations can be drop-glue, functions from external crates, and\n-    // local functions the definition of which is marked with `#[inline]`.\n-    let mut post_inlining = {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        place_inlined_mono_items(initial_partitioning, inlining_map)\n-    };\n-\n-    post_inlining.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n-\n-    debug_dump(tcx, \"POST INLINING:\", post_inlining.codegen_units.iter());\n-\n-    // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n-    // more freedom to optimize.\n-    if tcx.sess.opts.cg.link_dead_code != Some(true) {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        internalize_symbols(tcx, &mut post_inlining, inlining_map);\n-    }\n-\n-    // Finally, sort by codegen unit name, so that we get deterministic results.\n-    let PostInliningPartitioning {\n-        codegen_units: mut result,\n-        mono_item_placements: _,\n-        internalization_candidates: _,\n-    } = post_inlining;\n-\n-    result.sort_by_cached_key(|cgu| cgu.name().as_str());\n-\n-    result\n-}\n-\n-struct PreInliningPartitioning<'tcx> {\n-    codegen_units: Vec<CodegenUnit<'tcx>>,\n-    roots: FxHashSet<MonoItem<'tcx>>,\n-    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-}\n-\n-/// For symbol internalization, we need to know whether a symbol/mono-item is\n-/// accessed from outside the codegen unit it is defined in. This type is used\n-/// to keep track of that.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-enum MonoItemPlacement {\n-    SingleCgu { cgu_name: Symbol },\n-    MultipleCgus,\n-}\n-\n-struct PostInliningPartitioning<'tcx> {\n-    codegen_units: Vec<CodegenUnit<'tcx>>,\n-    mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-}\n-\n-fn place_root_mono_items<'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I) -> PreInliningPartitioning<'tcx>\n-where\n-    I: Iterator<Item = MonoItem<'tcx>>,\n-{\n-    let mut roots = FxHashSet::default();\n-    let mut codegen_units = FxHashMap::default();\n-    let is_incremental_build = tcx.sess.opts.incremental.is_some();\n-    let mut internalization_candidates = FxHashSet::default();\n-\n-    // Determine if monomorphizations instantiated in this crate will be made\n-    // available to downstream crates. This depends on whether we are in\n-    // share-generics mode and whether the current crate can even have\n-    // downstream crates.\n-    let export_generics = tcx.sess.opts.share_generics() && tcx.local_crate_exports_generics();\n-\n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n-    let cgu_name_cache = &mut FxHashMap::default();\n-\n-    for mono_item in mono_items {\n-        match mono_item.instantiation_mode(tcx) {\n-            InstantiationMode::GloballyShared { .. } => {}\n-            InstantiationMode::LocalCopy => continue,\n-        }\n-\n-        let characteristic_def_id = characteristic_def_id_of_mono_item(tcx, mono_item);\n-        let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n-\n-        let codegen_unit_name = match characteristic_def_id {\n-            Some(def_id) => compute_codegen_unit_name(\n-                tcx,\n-                cgu_name_builder,\n-                def_id,\n-                is_volatile,\n-                cgu_name_cache,\n-            ),\n-            None => fallback_cgu_name(cgu_name_builder),\n-        };\n-\n-        let codegen_unit = codegen_units\n-            .entry(codegen_unit_name)\n-            .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n-\n-        let mut can_be_internalized = true;\n-        let (linkage, visibility) = mono_item_linkage_and_visibility(\n-            tcx,\n-            &mono_item,\n-            &mut can_be_internalized,\n-            export_generics,\n-        );\n-        if visibility == Visibility::Hidden && can_be_internalized {\n-            internalization_candidates.insert(mono_item);\n-        }\n-\n-        codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n-        roots.insert(mono_item);\n-    }\n-\n-    // Always ensure we have at least one CGU; otherwise, if we have a\n-    // crate with just types (for example), we could wind up with no CGU.\n-    if codegen_units.is_empty() {\n-        let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n-        codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n-    }\n-\n-    PreInliningPartitioning {\n-        codegen_units: codegen_units.into_iter().map(|(_, codegen_unit)| codegen_unit).collect(),\n-        roots,\n-        internalization_candidates,\n-    }\n-}\n-\n-fn mono_item_linkage_and_visibility(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: &MonoItem<'tcx>,\n-    can_be_internalized: &mut bool,\n-    export_generics: bool,\n-) -> (Linkage, Visibility) {\n-    if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n-        return (explicit_linkage, Visibility::Default);\n-    }\n-    let vis = mono_item_visibility(tcx, mono_item, can_be_internalized, export_generics);\n-    (Linkage::External, vis)\n-}\n-\n-fn mono_item_visibility(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: &MonoItem<'tcx>,\n-    can_be_internalized: &mut bool,\n-    export_generics: bool,\n-) -> Visibility {\n-    let instance = match mono_item {\n-        // This is pretty complicated; see below.\n-        MonoItem::Fn(instance) => instance,\n-\n-        // Misc handling for generics and such, but otherwise:\n-        MonoItem::Static(def_id) => {\n-            return if tcx.is_reachable_non_generic(*def_id) {\n-                *can_be_internalized = false;\n-                default_visibility(tcx, *def_id, false)\n-            } else {\n-                Visibility::Hidden\n-            };\n-        }\n-        MonoItem::GlobalAsm(hir_id) => {\n-            let def_id = tcx.hir().local_def_id(*hir_id);\n-            return if tcx.is_reachable_non_generic(def_id) {\n-                *can_be_internalized = false;\n-                default_visibility(tcx, def_id.to_def_id(), false)\n-            } else {\n-                Visibility::Hidden\n-            };\n-        }\n-    };\n-\n-    let def_id = match instance.def {\n-        InstanceDef::Item(def) => def.did,\n-        InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n-\n-        // These are all compiler glue and such, never exported, always hidden.\n-        InstanceDef::VtableShim(..)\n-        | InstanceDef::ReifyShim(..)\n-        | InstanceDef::FnPtrShim(..)\n-        | InstanceDef::Virtual(..)\n-        | InstanceDef::Intrinsic(..)\n-        | InstanceDef::ClosureOnceShim { .. }\n-        | InstanceDef::DropGlue(..)\n-        | InstanceDef::CloneShim(..) => return Visibility::Hidden,\n-    };\n-\n-    // The `start_fn` lang item is actually a monomorphized instance of a\n-    // function in the standard library, used for the `main` function. We don't\n-    // want to export it so we tag it with `Hidden` visibility but this symbol\n-    // is only referenced from the actual `main` symbol which we unfortunately\n-    // don't know anything about during partitioning/collection. As a result we\n-    // forcibly keep this symbol out of the `internalization_candidates` set.\n-    //\n-    // FIXME: eventually we don't want to always force this symbol to have\n-    //        hidden visibility, it should indeed be a candidate for\n-    //        internalization, but we have to understand that it's referenced\n-    //        from the `main` symbol we'll generate later.\n-    //\n-    //        This may be fixable with a new `InstanceDef` perhaps? Unsure!\n-    if tcx.lang_items().start_fn() == Some(def_id) {\n-        *can_be_internalized = false;\n-        return Visibility::Hidden;\n-    }\n-\n-    let is_generic = instance.substs.non_erasable_generics().next().is_some();\n-\n-    // Upstream `DefId` instances get different handling than local ones.\n-    if !def_id.is_local() {\n-        return if export_generics && is_generic {\n-            // If it is a upstream monomorphization and we export generics, we must make\n-            // it available to downstream crates.\n-            *can_be_internalized = false;\n-            default_visibility(tcx, def_id, true)\n-        } else {\n-            Visibility::Hidden\n-        };\n-    }\n-\n-    if is_generic {\n-        if export_generics {\n-            if tcx.is_unreachable_local_definition(def_id) {\n-                // This instance cannot be used from another crate.\n-                Visibility::Hidden\n-            } else {\n-                // This instance might be useful in a downstream crate.\n-                *can_be_internalized = false;\n-                default_visibility(tcx, def_id, true)\n-            }\n-        } else {\n-            // We are not exporting generics or the definition is not reachable\n-            // for downstream crates, we can internalize its instantiations.\n-            Visibility::Hidden\n-        }\n-    } else {\n-        // If this isn't a generic function then we mark this a `Default` if\n-        // this is a reachable item, meaning that it's a symbol other crates may\n-        // access when they link to us.\n-        if tcx.is_reachable_non_generic(def_id) {\n-            *can_be_internalized = false;\n-            debug_assert!(!is_generic);\n-            return default_visibility(tcx, def_id, false);\n-        }\n-\n-        // If this isn't reachable then we're gonna tag this with `Hidden`\n-        // visibility. In some situations though we'll want to prevent this\n-        // symbol from being internalized.\n-        //\n-        // There's two categories of items here:\n-        //\n-        // * First is weak lang items. These are basically mechanisms for\n-        //   libcore to forward-reference symbols defined later in crates like\n-        //   the standard library or `#[panic_handler]` definitions. The\n-        //   definition of these weak lang items needs to be referenceable by\n-        //   libcore, so we're no longer a candidate for internalization.\n-        //   Removal of these functions can't be done by LLVM but rather must be\n-        //   done by the linker as it's a non-local decision.\n-        //\n-        // * Second is \"std internal symbols\". Currently this is primarily used\n-        //   for allocator symbols. Allocators are a little weird in their\n-        //   implementation, but the idea is that the compiler, at the last\n-        //   minute, defines an allocator with an injected object file. The\n-        //   `alloc` crate references these symbols (`__rust_alloc`) and the\n-        //   definition doesn't get hooked up until a linked crate artifact is\n-        //   generated.\n-        //\n-        //   The symbols synthesized by the compiler (`__rust_alloc`) are thin\n-        //   veneers around the actual implementation, some other symbol which\n-        //   implements the same ABI. These symbols (things like `__rg_alloc`,\n-        //   `__rdl_alloc`, `__rde_alloc`, etc), are all tagged with \"std\n-        //   internal symbols\".\n-        //\n-        //   The std-internal symbols here **should not show up in a dll as an\n-        //   exported interface**, so they return `false` from\n-        //   `is_reachable_non_generic` above and we'll give them `Hidden`\n-        //   visibility below. Like the weak lang items, though, we can't let\n-        //   LLVM internalize them as this decision is left up to the linker to\n-        //   omit them, so prevent them from being internalized.\n-        let attrs = tcx.codegen_fn_attrs(def_id);\n-        if attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n-            *can_be_internalized = false;\n-        }\n-\n-        Visibility::Hidden\n-    }\n-}\n-\n-fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n-    if !tcx.sess.target.target.options.default_hidden_visibility {\n-        return Visibility::Default;\n-    }\n-\n-    // Generic functions never have export-level C.\n-    if is_generic {\n-        return Visibility::Hidden;\n-    }\n-\n-    // Things with export level C don't get instantiated in\n-    // downstream crates.\n-    if !id.is_local() {\n-        return Visibility::Hidden;\n-    }\n-\n-    // C-export level items remain at `Default`, all other internal\n-    // items become `Hidden`.\n-    match tcx.reachable_non_generics(id.krate).get(&id) {\n-        Some(SymbolExportLevel::C) => Visibility::Default,\n-        _ => Visibility::Hidden,\n-    }\n-}\n-\n-fn merge_codegen_units<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-    target_cgu_count: usize,\n-) {\n-    assert!(target_cgu_count >= 1);\n-    let codegen_units = &mut initial_partitioning.codegen_units;\n-\n-    // Note that at this point in time the `codegen_units` here may not be in a\n-    // deterministic order (but we know they're deterministically the same set).\n-    // We want this merging to produce a deterministic ordering of codegen units\n-    // from the input.\n-    //\n-    // Due to basically how we've implemented the merging below (merge the two\n-    // smallest into each other) we're sure to start off with a deterministic\n-    // order (sorted by name). This'll mean that if two cgus have the same size\n-    // the stable sort below will keep everything nice and deterministic.\n-    codegen_units.sort_by_cached_key(|cgu| cgu.name().as_str());\n-\n-    // This map keeps track of what got merged into what.\n-    let mut cgu_contents: FxHashMap<Symbol, Vec<SymbolStr>> =\n-        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name().as_str()])).collect();\n-\n-    // Merge the two smallest codegen units until the target size is reached.\n-    while codegen_units.len() > target_cgu_count {\n-        // Sort small cgus to the back\n-        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-        let mut smallest = codegen_units.pop().unwrap();\n-        let second_smallest = codegen_units.last_mut().unwrap();\n-\n-        // Move the mono-items from `smallest` to `second_smallest`\n-        second_smallest.modify_size_estimate(smallest.size_estimate());\n-        for (k, v) in smallest.items_mut().drain() {\n-            second_smallest.items_mut().insert(k, v);\n-        }\n-\n-        // Record that `second_smallest` now contains all the stuff that was in\n-        // `smallest` before.\n-        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n-        cgu_contents.get_mut(&second_smallest.name()).unwrap().extend(consumed_cgu_names.drain(..));\n-\n-        debug!(\n-            \"CodegenUnit {} merged into CodegenUnit {}\",\n-            smallest.name(),\n-            second_smallest.name()\n-        );\n-    }\n-\n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n-\n-    if tcx.sess.opts.incremental.is_some() {\n-        // If we are doing incremental compilation, we want CGU names to\n-        // reflect the path of the source level module they correspond to.\n-        // For CGUs that contain the code of multiple modules because of the\n-        // merging done above, we use a concatenation of the names of\n-        // all contained CGUs.\n-        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n-            .into_iter()\n-            // This `filter` makes sure we only update the name of CGUs that\n-            // were actually modified by merging.\n-            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n-            .map(|(current_cgu_name, cgu_contents)| {\n-                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| &s[..]).collect();\n-\n-                // Sort the names, so things are deterministic and easy to\n-                // predict.\n-                cgu_contents.sort();\n-\n-                (current_cgu_name, cgu_contents.join(\"--\"))\n-            })\n-            .collect();\n-\n-        for cgu in codegen_units.iter_mut() {\n-            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n-                    cgu.set_name(Symbol::intern(&new_cgu_name));\n-                } else {\n-                    // If we don't require CGU names to be human-readable, we\n-                    // use a fixed length hash of the composite CGU name\n-                    // instead.\n-                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n-                    cgu.set_name(Symbol::intern(&new_cgu_name));\n-                }\n-            }\n-        }\n-    } else {\n-        // If we are compiling non-incrementally we just generate simple CGU\n-        // names containing an index.\n-        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-            cgu.set_name(numbered_codegen_unit_name(cgu_name_builder, index));\n-        }\n-    }\n-}\n-\n-fn place_inlined_mono_items<'tcx>(\n-    initial_partitioning: PreInliningPartitioning<'tcx>,\n-    inlining_map: &InliningMap<'tcx>,\n-) -> PostInliningPartitioning<'tcx> {\n-    let mut new_partitioning = Vec::new();\n-    let mut mono_item_placements = FxHashMap::default();\n-\n-    let PreInliningPartitioning { codegen_units: initial_cgus, roots, internalization_candidates } =\n-        initial_partitioning;\n-\n-    let single_codegen_unit = initial_cgus.len() == 1;\n-\n-    for old_codegen_unit in initial_cgus {\n-        // Collect all items that need to be available in this codegen unit.\n-        let mut reachable = FxHashSet::default();\n-        for root in old_codegen_unit.items().keys() {\n-            follow_inlining(*root, inlining_map, &mut reachable);\n-        }\n-\n-        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n-\n-        // Add all monomorphizations that are not already there.\n-        for mono_item in reachable {\n-            if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n-                // This is a root, just copy it over.\n-                new_codegen_unit.items_mut().insert(mono_item, *linkage);\n-            } else {\n-                if roots.contains(&mono_item) {\n-                    bug!(\n-                        \"GloballyShared mono-item inlined into other CGU: \\\n-                          {:?}\",\n-                        mono_item\n-                    );\n-                }\n-\n-                // This is a CGU-private copy.\n-                new_codegen_unit\n-                    .items_mut()\n-                    .insert(mono_item, (Linkage::Internal, Visibility::Default));\n-            }\n-\n-            if !single_codegen_unit {\n-                // If there is more than one codegen unit, we need to keep track\n-                // in which codegen units each monomorphization is placed.\n-                match mono_item_placements.entry(mono_item) {\n-                    Entry::Occupied(e) => {\n-                        let placement = e.into_mut();\n-                        debug_assert!(match *placement {\n-                            MonoItemPlacement::SingleCgu { cgu_name } => {\n-                                cgu_name != new_codegen_unit.name()\n-                            }\n-                            MonoItemPlacement::MultipleCgus => true,\n-                        });\n-                        *placement = MonoItemPlacement::MultipleCgus;\n-                    }\n-                    Entry::Vacant(e) => {\n-                        e.insert(MonoItemPlacement::SingleCgu {\n-                            cgu_name: new_codegen_unit.name(),\n-                        });\n-                    }\n-                }\n-            }\n-        }\n-\n-        new_partitioning.push(new_codegen_unit);\n-    }\n-\n-    return PostInliningPartitioning {\n-        codegen_units: new_partitioning,\n-        mono_item_placements,\n-        internalization_candidates,\n-    };\n-\n-    fn follow_inlining<'tcx>(\n-        mono_item: MonoItem<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n-        visited: &mut FxHashSet<MonoItem<'tcx>>,\n-    ) {\n-        if !visited.insert(mono_item) {\n-            return;\n-        }\n-\n-        inlining_map.with_inlining_candidates(mono_item, |target| {\n-            follow_inlining(target, inlining_map, visited);\n-        });\n-    }\n-}\n-\n-fn internalize_symbols<'tcx>(\n-    _tcx: TyCtxt<'tcx>,\n-    partitioning: &mut PostInliningPartitioning<'tcx>,\n-    inlining_map: &InliningMap<'tcx>,\n-) {\n-    if partitioning.codegen_units.len() == 1 {\n-        // Fast path for when there is only one codegen unit. In this case we\n-        // can internalize all candidates, since there is nowhere else they\n-        // could be accessed from.\n-        for cgu in &mut partitioning.codegen_units {\n-            for candidate in &partitioning.internalization_candidates {\n-                cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n-            }\n-        }\n-\n-        return;\n-    }\n-\n-    // Build a map from every monomorphization to all the monomorphizations that\n-    // reference it.\n-    let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n-    inlining_map.iter_accesses(|accessor, accessees| {\n-        for accessee in accessees {\n-            accessor_map.entry(*accessee).or_default().push(accessor);\n-        }\n-    });\n-\n-    let mono_item_placements = &partitioning.mono_item_placements;\n-\n-    // For each internalization candidates in each codegen unit, check if it is\n-    // accessed from outside its defining codegen unit.\n-    for cgu in &mut partitioning.codegen_units {\n-        let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n-\n-        for (accessee, linkage_and_visibility) in cgu.items_mut() {\n-            if !partitioning.internalization_candidates.contains(accessee) {\n-                // This item is no candidate for internalizing, so skip it.\n-                continue;\n-            }\n-            debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n-\n-            if let Some(accessors) = accessor_map.get(accessee) {\n-                if accessors\n-                    .iter()\n-                    .filter_map(|accessor| {\n-                        // Some accessors might not have been\n-                        // instantiated. We can safely ignore those.\n-                        mono_item_placements.get(accessor)\n-                    })\n-                    .any(|placement| *placement != home_cgu)\n-                {\n-                    // Found an accessor from another CGU, so skip to the next\n-                    // item without marking this one as internal.\n-                    continue;\n-                }\n-            }\n-\n-            // If we got here, we did not find any accesses from other CGUs,\n-            // so it's fine to make this monomorphization internal.\n-            *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n-        }\n-    }\n-}\n-\n-fn characteristic_def_id_of_mono_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: MonoItem<'tcx>,\n-) -> Option<DefId> {\n-    match mono_item {\n-        MonoItem::Fn(instance) => {\n-            let def_id = match instance.def {\n-                ty::InstanceDef::Item(def) => def.did,\n-                ty::InstanceDef::VtableShim(..)\n-                | ty::InstanceDef::ReifyShim(..)\n-                | ty::InstanceDef::FnPtrShim(..)\n-                | ty::InstanceDef::ClosureOnceShim { .. }\n-                | ty::InstanceDef::Intrinsic(..)\n-                | ty::InstanceDef::DropGlue(..)\n-                | ty::InstanceDef::Virtual(..)\n-                | ty::InstanceDef::CloneShim(..) => return None,\n-            };\n-\n-            // If this is a method, we want to put it into the same module as\n-            // its self-type. If the self-type does not provide a characteristic\n-            // DefId, we use the location of the impl after all.\n-\n-            if tcx.trait_of_item(def_id).is_some() {\n-                let self_ty = instance.substs.type_at(0);\n-                // This is a default implementation of a trait method.\n-                return characteristic_def_id_of_type(self_ty).or(Some(def_id));\n-            }\n-\n-            if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n-                if tcx.sess.opts.incremental.is_some()\n-                    && tcx.trait_id_of_impl(impl_def_id) == tcx.lang_items().drop_trait()\n-                {\n-                    // Put `Drop::drop` into the same cgu as `drop_in_place`\n-                    // since `drop_in_place` is the only thing that can\n-                    // call it.\n-                    return None;\n-                }\n-                // This is a method within an impl, find out what the self-type is:\n-                let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n-                    instance.substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    &tcx.type_of(impl_def_id),\n-                );\n-                if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n-                    return Some(def_id);\n-                }\n-            }\n-\n-            Some(def_id)\n-        }\n-        MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(hir_id) => Some(tcx.hir().local_def_id(hir_id).to_def_id()),\n-    }\n-}\n-\n-type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n-\n-fn compute_codegen_unit_name(\n-    tcx: TyCtxt<'_>,\n-    name_builder: &mut CodegenUnitNameBuilder<'_>,\n-    def_id: DefId,\n-    volatile: bool,\n-    cache: &mut CguNameCache,\n-) -> Symbol {\n-    // Find the innermost module that is not nested within a function.\n-    let mut current_def_id = def_id;\n-    let mut cgu_def_id = None;\n-    // Walk backwards from the item we want to find the module for.\n-    loop {\n-        if current_def_id.index == CRATE_DEF_INDEX {\n-            if cgu_def_id.is_none() {\n-                // If we have not found a module yet, take the crate root.\n-                cgu_def_id = Some(DefId { krate: def_id.krate, index: CRATE_DEF_INDEX });\n-            }\n-            break;\n-        } else if tcx.def_kind(current_def_id) == DefKind::Mod {\n-            if cgu_def_id.is_none() {\n-                cgu_def_id = Some(current_def_id);\n-            }\n-        } else {\n-            // If we encounter something that is not a module, throw away\n-            // any module that we've found so far because we now know that\n-            // it is nested within something else.\n-            cgu_def_id = None;\n-        }\n-\n-        current_def_id = tcx.parent(current_def_id).unwrap();\n-    }\n-\n-    let cgu_def_id = cgu_def_id.unwrap();\n-\n-    *cache.entry((cgu_def_id, volatile)).or_insert_with(|| {\n-        let def_path = tcx.def_path(cgu_def_id);\n-\n-        let components = def_path.data.iter().map(|part| part.data.as_symbol());\n-\n-        let volatile_suffix = volatile.then_some(\"volatile\");\n-\n-        name_builder.build_cgu_name(def_path.krate, components, volatile_suffix)\n-    })\n-}\n-\n-fn numbered_codegen_unit_name(\n-    name_builder: &mut CodegenUnitNameBuilder<'_>,\n-    index: usize,\n-) -> Symbol {\n-    name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index))\n-}\n-\n-fn debug_dump<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, label: &str, cgus: I)\n-where\n-    I: Iterator<Item = &'a CodegenUnit<'tcx>>,\n-    'tcx: 'a,\n-{\n-    if cfg!(debug_assertions) {\n-        debug!(\"{}\", label);\n-        for cgu in cgus {\n-            debug!(\"CodegenUnit {} estimated size {} :\", cgu.name(), cgu.size_estimate());\n-\n-            for (mono_item, linkage) in cgu.items() {\n-                let symbol_name = mono_item.symbol_name(tcx).name;\n-                let symbol_hash_start = symbol_name.rfind('h');\n-                let symbol_hash =\n-                    symbol_hash_start.map(|i| &symbol_name[i..]).unwrap_or(\"<no hash>\");\n-\n-                debug!(\n-                    \" - {} [{:?}] [{}] estimated size {}\",\n-                    mono_item.to_string(tcx, true),\n-                    linkage,\n-                    symbol_hash,\n-                    mono_item.size_estimate(tcx)\n-                );\n-            }\n-\n-            debug!(\"\");\n-        }\n-    }\n-}\n-\n-#[inline(never)] // give this a place in the profiler\n-fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I)\n-where\n-    I: Iterator<Item = &'a MonoItem<'tcx>>,\n-    'tcx: 'a,\n-{\n-    let _prof_timer = tcx.prof.generic_activity(\"assert_symbols_are_distinct\");\n-\n-    let mut symbols: Vec<_> =\n-        mono_items.map(|mono_item| (mono_item, mono_item.symbol_name(tcx))).collect();\n-\n-    symbols.sort_by_key(|sym| sym.1);\n-\n-    for pair in symbols.windows(2) {\n-        let sym1 = &pair[0].1;\n-        let sym2 = &pair[1].1;\n-\n-        if sym1 == sym2 {\n-            let mono_item1 = pair[0].0;\n-            let mono_item2 = pair[1].0;\n-\n-            let span1 = mono_item1.local_span(tcx);\n-            let span2 = mono_item2.local_span(tcx);\n-\n-            // Deterministically select one of the spans for error reporting\n-            let span = match (span1, span2) {\n-                (Some(span1), Some(span2)) => {\n-                    Some(if span1.lo().0 > span2.lo().0 { span1 } else { span2 })\n-                }\n-                (span1, span2) => span1.or(span2),\n-            };\n-\n-            let error_message = format!(\"symbol `{}` is already defined\", sym1);\n-\n-            if let Some(span) = span {\n-                tcx.sess.span_fatal(span, &error_message)\n-            } else {\n-                tcx.sess.fatal(&error_message)\n-            }\n-        }\n-    }\n-}\n-\n-fn collect_and_partition_mono_items(\n-    tcx: TyCtxt<'tcx>,\n-    cnum: CrateNum,\n-) -> (&'tcx DefIdSet, &'tcx [CodegenUnit<'tcx>]) {\n-    assert_eq!(cnum, LOCAL_CRATE);\n-\n-    let collection_mode = match tcx.sess.opts.debugging_opts.print_mono_items {\n-        Some(ref s) => {\n-            let mode_string = s.to_lowercase();\n-            let mode_string = mode_string.trim();\n-            if mode_string == \"eager\" {\n-                MonoItemCollectionMode::Eager\n-            } else {\n-                if mode_string != \"lazy\" {\n-                    let message = format!(\n-                        \"Unknown codegen-item collection mode '{}'. \\\n-                                           Falling back to 'lazy' mode.\",\n-                        mode_string\n-                    );\n-                    tcx.sess.warn(&message);\n-                }\n-\n-                MonoItemCollectionMode::Lazy\n-            }\n-        }\n-        None => {\n-            if tcx.sess.opts.cg.link_dead_code == Some(true) {\n-                MonoItemCollectionMode::Eager\n-            } else {\n-                MonoItemCollectionMode::Lazy\n-            }\n-        }\n-    };\n-\n-    let (items, inlining_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n-\n-    tcx.sess.abort_if_errors();\n-\n-    let (codegen_units, _) = tcx.sess.time(\"partition_and_assert_distinct_symbols\", || {\n-        sync::join(\n-            || {\n-                &*tcx.arena.alloc_from_iter(partition(\n-                    tcx,\n-                    items.iter().cloned(),\n-                    tcx.sess.codegen_units(),\n-                    &inlining_map,\n-                ))\n-            },\n-            || assert_symbols_are_distinct(tcx, items.iter()),\n-        )\n-    });\n-\n-    let mono_items: DefIdSet = items\n-        .iter()\n-        .filter_map(|mono_item| match *mono_item {\n-            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n-            MonoItem::Static(def_id) => Some(def_id),\n-            _ => None,\n-        })\n-        .collect();\n-\n-    if tcx.sess.opts.debugging_opts.print_mono_items.is_some() {\n-        let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n-\n-        for cgu in codegen_units {\n-            for (&mono_item, &linkage) in cgu.items() {\n-                item_to_cgus.entry(mono_item).or_default().push((cgu.name(), linkage));\n-            }\n-        }\n-\n-        let mut item_keys: Vec<_> = items\n-            .iter()\n-            .map(|i| {\n-                let mut output = i.to_string(tcx, false);\n-                output.push_str(\" @@\");\n-                let mut empty = Vec::new();\n-                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n-                cgus.sort_by_key(|(name, _)| *name);\n-                cgus.dedup();\n-                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n-                    output.push_str(\" \");\n-                    output.push_str(&cgu_name.as_str());\n-\n-                    let linkage_abbrev = match linkage {\n-                        Linkage::External => \"External\",\n-                        Linkage::AvailableExternally => \"Available\",\n-                        Linkage::LinkOnceAny => \"OnceAny\",\n-                        Linkage::LinkOnceODR => \"OnceODR\",\n-                        Linkage::WeakAny => \"WeakAny\",\n-                        Linkage::WeakODR => \"WeakODR\",\n-                        Linkage::Appending => \"Appending\",\n-                        Linkage::Internal => \"Internal\",\n-                        Linkage::Private => \"Private\",\n-                        Linkage::ExternalWeak => \"ExternalWeak\",\n-                        Linkage::Common => \"Common\",\n-                    };\n-\n-                    output.push_str(\"[\");\n-                    output.push_str(linkage_abbrev);\n-                    output.push_str(\"]\");\n-                }\n-                output\n-            })\n-            .collect();\n-\n-        item_keys.sort();\n-\n-        for item in item_keys {\n-            println!(\"MONO_ITEM {}\", item);\n-        }\n-    }\n-\n-    (tcx.arena.alloc(mono_items), codegen_units)\n-}\n-\n-pub fn provide(providers: &mut Providers) {\n-    providers.collect_and_partition_mono_items = collect_and_partition_mono_items;\n-\n-    providers.is_codegened_item = |tcx, def_id| {\n-        let (all_mono_items, _) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n-        all_mono_items.contains(&def_id)\n-    };\n-\n-    providers.codegen_unit = |tcx, name| {\n-        let (_, all) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n-        all.iter()\n-            .find(|cgu| cgu.name() == name)\n-            .unwrap_or_else(|| panic!(\"failed to find cgu with name {:?}\", name))\n-    };\n-}"}, {"sha": "b48bae837877979462f3da9ce6b2d998df8d1da1", "filename": "src/librustc_mir/monomorphize/partitioning/default.rs", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/rust-lang/rust/blob/8ba22504e8e5dcbbe136d97f63c1280dabc523d0/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba22504e8e5dcbbe136d97f63c1280dabc523d0/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning%2Fdefault.rs?ref=8ba22504e8e5dcbbe136d97f63c1280dabc523d0", "patch": "@@ -0,0 +1,552 @@\n+use std::collections::hash_map::Entry;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n+use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, Linkage, Visibility};\n+use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n+use rustc_middle::ty::print::characteristic_def_id_of_type;\n+use rustc_middle::ty::{self, DefIdTree, InstanceDef, TyCtxt};\n+use rustc_span::symbol::Symbol;\n+\n+use crate::monomorphize::collector::InliningMap;\n+use crate::monomorphize::partitioning::merging;\n+use crate::monomorphize::partitioning::{\n+    MonoItemPlacement, Partitioner, PostInliningPartitioning, PreInliningPartitioning,\n+};\n+\n+pub struct DefaultPartitioning;\n+\n+impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n+    fn place_root_mono_items(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        mono_items: &mut dyn Iterator<Item = MonoItem<'tcx>>,\n+    ) -> PreInliningPartitioning<'tcx> {\n+        let mut roots = FxHashSet::default();\n+        let mut codegen_units = FxHashMap::default();\n+        let is_incremental_build = tcx.sess.opts.incremental.is_some();\n+        let mut internalization_candidates = FxHashSet::default();\n+\n+        // Determine if monomorphizations instantiated in this crate will be made\n+        // available to downstream crates. This depends on whether we are in\n+        // share-generics mode and whether the current crate can even have\n+        // downstream crates.\n+        let export_generics = tcx.sess.opts.share_generics() && tcx.local_crate_exports_generics();\n+\n+        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+        let cgu_name_cache = &mut FxHashMap::default();\n+\n+        for mono_item in mono_items {\n+            match mono_item.instantiation_mode(tcx) {\n+                InstantiationMode::GloballyShared { .. } => {}\n+                InstantiationMode::LocalCopy => continue,\n+            }\n+\n+            let characteristic_def_id = characteristic_def_id_of_mono_item(tcx, mono_item);\n+            let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n+\n+            let codegen_unit_name = match characteristic_def_id {\n+                Some(def_id) => compute_codegen_unit_name(\n+                    tcx,\n+                    cgu_name_builder,\n+                    def_id,\n+                    is_volatile,\n+                    cgu_name_cache,\n+                ),\n+                None => fallback_cgu_name(cgu_name_builder),\n+            };\n+\n+            let codegen_unit = codegen_units\n+                .entry(codegen_unit_name)\n+                .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n+\n+            let mut can_be_internalized = true;\n+            let (linkage, visibility) = mono_item_linkage_and_visibility(\n+                tcx,\n+                &mono_item,\n+                &mut can_be_internalized,\n+                export_generics,\n+            );\n+            if visibility == Visibility::Hidden && can_be_internalized {\n+                internalization_candidates.insert(mono_item);\n+            }\n+\n+            codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n+            roots.insert(mono_item);\n+        }\n+\n+        // Always ensure we have at least one CGU; otherwise, if we have a\n+        // crate with just types (for example), we could wind up with no CGU.\n+        if codegen_units.is_empty() {\n+            let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n+            codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n+        }\n+\n+        PreInliningPartitioning {\n+            codegen_units: codegen_units\n+                .into_iter()\n+                .map(|(_, codegen_unit)| codegen_unit)\n+                .collect(),\n+            roots,\n+            internalization_candidates,\n+        }\n+    }\n+\n+    fn merge_codegen_units(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        target_cgu_count: usize,\n+    ) {\n+        merging::merge_codegen_units(tcx, initial_partitioning, target_cgu_count);\n+    }\n+\n+    fn place_inlined_mono_items(\n+        &mut self,\n+        initial_partitioning: PreInliningPartitioning<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+    ) -> PostInliningPartitioning<'tcx> {\n+        let mut new_partitioning = Vec::new();\n+        let mut mono_item_placements = FxHashMap::default();\n+\n+        let PreInliningPartitioning {\n+            codegen_units: initial_cgus,\n+            roots,\n+            internalization_candidates,\n+        } = initial_partitioning;\n+\n+        let single_codegen_unit = initial_cgus.len() == 1;\n+\n+        for old_codegen_unit in initial_cgus {\n+            // Collect all items that need to be available in this codegen unit.\n+            let mut reachable = FxHashSet::default();\n+            for root in old_codegen_unit.items().keys() {\n+                follow_inlining(*root, inlining_map, &mut reachable);\n+            }\n+\n+            let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n+\n+            // Add all monomorphizations that are not already there.\n+            for mono_item in reachable {\n+                if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n+                    // This is a root, just copy it over.\n+                    new_codegen_unit.items_mut().insert(mono_item, *linkage);\n+                } else {\n+                    if roots.contains(&mono_item) {\n+                        bug!(\n+                            \"GloballyShared mono-item inlined into other CGU: \\\n+                              {:?}\",\n+                            mono_item\n+                        );\n+                    }\n+\n+                    // This is a CGU-private copy.\n+                    new_codegen_unit\n+                        .items_mut()\n+                        .insert(mono_item, (Linkage::Internal, Visibility::Default));\n+                }\n+\n+                if !single_codegen_unit {\n+                    // If there is more than one codegen unit, we need to keep track\n+                    // in which codegen units each monomorphization is placed.\n+                    match mono_item_placements.entry(mono_item) {\n+                        Entry::Occupied(e) => {\n+                            let placement = e.into_mut();\n+                            debug_assert!(match *placement {\n+                                MonoItemPlacement::SingleCgu { cgu_name } => {\n+                                    cgu_name != new_codegen_unit.name()\n+                                }\n+                                MonoItemPlacement::MultipleCgus => true,\n+                            });\n+                            *placement = MonoItemPlacement::MultipleCgus;\n+                        }\n+                        Entry::Vacant(e) => {\n+                            e.insert(MonoItemPlacement::SingleCgu {\n+                                cgu_name: new_codegen_unit.name(),\n+                            });\n+                        }\n+                    }\n+                }\n+            }\n+\n+            new_partitioning.push(new_codegen_unit);\n+        }\n+\n+        return PostInliningPartitioning {\n+            codegen_units: new_partitioning,\n+            mono_item_placements,\n+            internalization_candidates,\n+        };\n+\n+        fn follow_inlining<'tcx>(\n+            mono_item: MonoItem<'tcx>,\n+            inlining_map: &InliningMap<'tcx>,\n+            visited: &mut FxHashSet<MonoItem<'tcx>>,\n+        ) {\n+            if !visited.insert(mono_item) {\n+                return;\n+            }\n+\n+            inlining_map.with_inlining_candidates(mono_item, |target| {\n+                follow_inlining(target, inlining_map, visited);\n+            });\n+        }\n+    }\n+\n+    fn internalize_symbols(\n+        &mut self,\n+        _tcx: TyCtxt<'tcx>,\n+        partitioning: &mut PostInliningPartitioning<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+    ) {\n+        if partitioning.codegen_units.len() == 1 {\n+            // Fast path for when there is only one codegen unit. In this case we\n+            // can internalize all candidates, since there is nowhere else they\n+            // could be accessed from.\n+            for cgu in &mut partitioning.codegen_units {\n+                for candidate in &partitioning.internalization_candidates {\n+                    cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n+                }\n+            }\n+\n+            return;\n+        }\n+\n+        // Build a map from every monomorphization to all the monomorphizations that\n+        // reference it.\n+        let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n+        inlining_map.iter_accesses(|accessor, accessees| {\n+            for accessee in accessees {\n+                accessor_map.entry(*accessee).or_default().push(accessor);\n+            }\n+        });\n+\n+        let mono_item_placements = &partitioning.mono_item_placements;\n+\n+        // For each internalization candidates in each codegen unit, check if it is\n+        // accessed from outside its defining codegen unit.\n+        for cgu in &mut partitioning.codegen_units {\n+            let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n+\n+            for (accessee, linkage_and_visibility) in cgu.items_mut() {\n+                if !partitioning.internalization_candidates.contains(accessee) {\n+                    // This item is no candidate for internalizing, so skip it.\n+                    continue;\n+                }\n+                debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n+\n+                if let Some(accessors) = accessor_map.get(accessee) {\n+                    if accessors\n+                        .iter()\n+                        .filter_map(|accessor| {\n+                            // Some accessors might not have been\n+                            // instantiated. We can safely ignore those.\n+                            mono_item_placements.get(accessor)\n+                        })\n+                        .any(|placement| *placement != home_cgu)\n+                    {\n+                        // Found an accessor from another CGU, so skip to the next\n+                        // item without marking this one as internal.\n+                        continue;\n+                    }\n+                }\n+\n+                // If we got here, we did not find any accesses from other CGUs,\n+                // so it's fine to make this monomorphization internal.\n+                *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n+            }\n+        }\n+    }\n+}\n+\n+fn characteristic_def_id_of_mono_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: MonoItem<'tcx>,\n+) -> Option<DefId> {\n+    match mono_item {\n+        MonoItem::Fn(instance) => {\n+            let def_id = match instance.def {\n+                ty::InstanceDef::Item(def) => def.did,\n+                ty::InstanceDef::VtableShim(..)\n+                | ty::InstanceDef::ReifyShim(..)\n+                | ty::InstanceDef::FnPtrShim(..)\n+                | ty::InstanceDef::ClosureOnceShim { .. }\n+                | ty::InstanceDef::Intrinsic(..)\n+                | ty::InstanceDef::DropGlue(..)\n+                | ty::InstanceDef::Virtual(..)\n+                | ty::InstanceDef::CloneShim(..) => return None,\n+            };\n+\n+            // If this is a method, we want to put it into the same module as\n+            // its self-type. If the self-type does not provide a characteristic\n+            // DefId, we use the location of the impl after all.\n+\n+            if tcx.trait_of_item(def_id).is_some() {\n+                let self_ty = instance.substs.type_at(0);\n+                // This is a default implementation of a trait method.\n+                return characteristic_def_id_of_type(self_ty).or(Some(def_id));\n+            }\n+\n+            if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n+                if tcx.sess.opts.incremental.is_some()\n+                    && tcx.trait_id_of_impl(impl_def_id) == tcx.lang_items().drop_trait()\n+                {\n+                    // Put `Drop::drop` into the same cgu as `drop_in_place`\n+                    // since `drop_in_place` is the only thing that can\n+                    // call it.\n+                    return None;\n+                }\n+                // This is a method within an impl, find out what the self-type is:\n+                let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n+                    instance.substs,\n+                    ty::ParamEnv::reveal_all(),\n+                    &tcx.type_of(impl_def_id),\n+                );\n+                if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n+                    return Some(def_id);\n+                }\n+            }\n+\n+            Some(def_id)\n+        }\n+        MonoItem::Static(def_id) => Some(def_id),\n+        MonoItem::GlobalAsm(hir_id) => Some(tcx.hir().local_def_id(hir_id).to_def_id()),\n+    }\n+}\n+\n+fn compute_codegen_unit_name(\n+    tcx: TyCtxt<'_>,\n+    name_builder: &mut CodegenUnitNameBuilder<'_>,\n+    def_id: DefId,\n+    volatile: bool,\n+    cache: &mut CguNameCache,\n+) -> Symbol {\n+    // Find the innermost module that is not nested within a function.\n+    let mut current_def_id = def_id;\n+    let mut cgu_def_id = None;\n+    // Walk backwards from the item we want to find the module for.\n+    loop {\n+        if current_def_id.index == CRATE_DEF_INDEX {\n+            if cgu_def_id.is_none() {\n+                // If we have not found a module yet, take the crate root.\n+                cgu_def_id = Some(DefId { krate: def_id.krate, index: CRATE_DEF_INDEX });\n+            }\n+            break;\n+        } else if tcx.def_kind(current_def_id) == DefKind::Mod {\n+            if cgu_def_id.is_none() {\n+                cgu_def_id = Some(current_def_id);\n+            }\n+        } else {\n+            // If we encounter something that is not a module, throw away\n+            // any module that we've found so far because we now know that\n+            // it is nested within something else.\n+            cgu_def_id = None;\n+        }\n+\n+        current_def_id = tcx.parent(current_def_id).unwrap();\n+    }\n+\n+    let cgu_def_id = cgu_def_id.unwrap();\n+\n+    *cache.entry((cgu_def_id, volatile)).or_insert_with(|| {\n+        let def_path = tcx.def_path(cgu_def_id);\n+\n+        let components = def_path.data.iter().map(|part| part.data.as_symbol());\n+\n+        let volatile_suffix = volatile.then_some(\"volatile\");\n+\n+        name_builder.build_cgu_name(def_path.krate, components, volatile_suffix)\n+    })\n+}\n+\n+// Anything we can't find a proper codegen unit for goes into this.\n+fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n+    name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n+}\n+\n+fn mono_item_linkage_and_visibility(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    export_generics: bool,\n+) -> (Linkage, Visibility) {\n+    if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n+        return (explicit_linkage, Visibility::Default);\n+    }\n+    let vis = mono_item_visibility(tcx, mono_item, can_be_internalized, export_generics);\n+    (Linkage::External, vis)\n+}\n+\n+type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n+\n+fn mono_item_visibility(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    export_generics: bool,\n+) -> Visibility {\n+    let instance = match mono_item {\n+        // This is pretty complicated; see below.\n+        MonoItem::Fn(instance) => instance,\n+\n+        // Misc handling for generics and such, but otherwise:\n+        MonoItem::Static(def_id) => {\n+            return if tcx.is_reachable_non_generic(*def_id) {\n+                *can_be_internalized = false;\n+                default_visibility(tcx, *def_id, false)\n+            } else {\n+                Visibility::Hidden\n+            };\n+        }\n+        MonoItem::GlobalAsm(hir_id) => {\n+            let def_id = tcx.hir().local_def_id(*hir_id);\n+            return if tcx.is_reachable_non_generic(def_id) {\n+                *can_be_internalized = false;\n+                default_visibility(tcx, def_id.to_def_id(), false)\n+            } else {\n+                Visibility::Hidden\n+            };\n+        }\n+    };\n+\n+    let def_id = match instance.def {\n+        InstanceDef::Item(def) => def.did,\n+        InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n+\n+        // These are all compiler glue and such, never exported, always hidden.\n+        InstanceDef::VtableShim(..)\n+        | InstanceDef::ReifyShim(..)\n+        | InstanceDef::FnPtrShim(..)\n+        | InstanceDef::Virtual(..)\n+        | InstanceDef::Intrinsic(..)\n+        | InstanceDef::ClosureOnceShim { .. }\n+        | InstanceDef::DropGlue(..)\n+        | InstanceDef::CloneShim(..) => return Visibility::Hidden,\n+    };\n+\n+    // The `start_fn` lang item is actually a monomorphized instance of a\n+    // function in the standard library, used for the `main` function. We don't\n+    // want to export it so we tag it with `Hidden` visibility but this symbol\n+    // is only referenced from the actual `main` symbol which we unfortunately\n+    // don't know anything about during partitioning/collection. As a result we\n+    // forcibly keep this symbol out of the `internalization_candidates` set.\n+    //\n+    // FIXME: eventually we don't want to always force this symbol to have\n+    //        hidden visibility, it should indeed be a candidate for\n+    //        internalization, but we have to understand that it's referenced\n+    //        from the `main` symbol we'll generate later.\n+    //\n+    //        This may be fixable with a new `InstanceDef` perhaps? Unsure!\n+    if tcx.lang_items().start_fn() == Some(def_id) {\n+        *can_be_internalized = false;\n+        return Visibility::Hidden;\n+    }\n+\n+    let is_generic = instance.substs.non_erasable_generics().next().is_some();\n+\n+    // Upstream `DefId` instances get different handling than local ones.\n+    if !def_id.is_local() {\n+        return if export_generics && is_generic {\n+            // If it is a upstream monomorphization and we export generics, we must make\n+            // it available to downstream crates.\n+            *can_be_internalized = false;\n+            default_visibility(tcx, def_id, true)\n+        } else {\n+            Visibility::Hidden\n+        };\n+    }\n+\n+    if is_generic {\n+        if export_generics {\n+            if tcx.is_unreachable_local_definition(def_id) {\n+                // This instance cannot be used from another crate.\n+                Visibility::Hidden\n+            } else {\n+                // This instance might be useful in a downstream crate.\n+                *can_be_internalized = false;\n+                default_visibility(tcx, def_id, true)\n+            }\n+        } else {\n+            // We are not exporting generics or the definition is not reachable\n+            // for downstream crates, we can internalize its instantiations.\n+            Visibility::Hidden\n+        }\n+    } else {\n+        // If this isn't a generic function then we mark this a `Default` if\n+        // this is a reachable item, meaning that it's a symbol other crates may\n+        // access when they link to us.\n+        if tcx.is_reachable_non_generic(def_id) {\n+            *can_be_internalized = false;\n+            debug_assert!(!is_generic);\n+            return default_visibility(tcx, def_id, false);\n+        }\n+\n+        // If this isn't reachable then we're gonna tag this with `Hidden`\n+        // visibility. In some situations though we'll want to prevent this\n+        // symbol from being internalized.\n+        //\n+        // There's two categories of items here:\n+        //\n+        // * First is weak lang items. These are basically mechanisms for\n+        //   libcore to forward-reference symbols defined later in crates like\n+        //   the standard library or `#[panic_handler]` definitions. The\n+        //   definition of these weak lang items needs to be referenceable by\n+        //   libcore, so we're no longer a candidate for internalization.\n+        //   Removal of these functions can't be done by LLVM but rather must be\n+        //   done by the linker as it's a non-local decision.\n+        //\n+        // * Second is \"std internal symbols\". Currently this is primarily used\n+        //   for allocator symbols. Allocators are a little weird in their\n+        //   implementation, but the idea is that the compiler, at the last\n+        //   minute, defines an allocator with an injected object file. The\n+        //   `alloc` crate references these symbols (`__rust_alloc`) and the\n+        //   definition doesn't get hooked up until a linked crate artifact is\n+        //   generated.\n+        //\n+        //   The symbols synthesized by the compiler (`__rust_alloc`) are thin\n+        //   veneers around the actual implementation, some other symbol which\n+        //   implements the same ABI. These symbols (things like `__rg_alloc`,\n+        //   `__rdl_alloc`, `__rde_alloc`, etc), are all tagged with \"std\n+        //   internal symbols\".\n+        //\n+        //   The std-internal symbols here **should not show up in a dll as an\n+        //   exported interface**, so they return `false` from\n+        //   `is_reachable_non_generic` above and we'll give them `Hidden`\n+        //   visibility below. Like the weak lang items, though, we can't let\n+        //   LLVM internalize them as this decision is left up to the linker to\n+        //   omit them, so prevent them from being internalized.\n+        let attrs = tcx.codegen_fn_attrs(def_id);\n+        if attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n+            *can_be_internalized = false;\n+        }\n+\n+        Visibility::Hidden\n+    }\n+}\n+\n+fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n+    if !tcx.sess.target.target.options.default_hidden_visibility {\n+        return Visibility::Default;\n+    }\n+\n+    // Generic functions never have export-level C.\n+    if is_generic {\n+        return Visibility::Hidden;\n+    }\n+\n+    // Things with export level C don't get instantiated in\n+    // downstream crates.\n+    if !id.is_local() {\n+        return Visibility::Hidden;\n+    }\n+\n+    // C-export level items remain at `Default`, all other internal\n+    // items become `Hidden`.\n+    match tcx.reachable_non_generics(id.krate).get(&id) {\n+        Some(SymbolExportLevel::C) => Visibility::Default,\n+        _ => Visibility::Hidden,\n+    }\n+}"}, {"sha": "1787e6df1b9c720c79096e472d7b068a4046f90a", "filename": "src/librustc_mir/monomorphize/partitioning/merging.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8ba22504e8e5dcbbe136d97f63c1280dabc523d0/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning%2Fmerging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba22504e8e5dcbbe136d97f63c1280dabc523d0/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning%2Fmerging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning%2Fmerging.rs?ref=8ba22504e8e5dcbbe136d97f63c1280dabc523d0", "patch": "@@ -0,0 +1,110 @@\n+use std::cmp;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::symbol::{Symbol, SymbolStr};\n+\n+use crate::monomorphize::partitioning::PreInliningPartitioning;\n+\n+pub fn merge_codegen_units<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+    target_cgu_count: usize,\n+) {\n+    assert!(target_cgu_count >= 1);\n+    let codegen_units = &mut initial_partitioning.codegen_units;\n+\n+    // Note that at this point in time the `codegen_units` here may not be in a\n+    // deterministic order (but we know they're deterministically the same set).\n+    // We want this merging to produce a deterministic ordering of codegen units\n+    // from the input.\n+    //\n+    // Due to basically how we've implemented the merging below (merge the two\n+    // smallest into each other) we're sure to start off with a deterministic\n+    // order (sorted by name). This'll mean that if two cgus have the same size\n+    // the stable sort below will keep everything nice and deterministic.\n+    codegen_units.sort_by_cached_key(|cgu| cgu.name().as_str());\n+\n+    // This map keeps track of what got merged into what.\n+    let mut cgu_contents: FxHashMap<Symbol, Vec<SymbolStr>> =\n+        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name().as_str()])).collect();\n+\n+    // Merge the two smallest codegen units until the target size is reached.\n+    while codegen_units.len() > target_cgu_count {\n+        // Sort small cgus to the back\n+        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+        let mut smallest = codegen_units.pop().unwrap();\n+        let second_smallest = codegen_units.last_mut().unwrap();\n+\n+        // Move the mono-items from `smallest` to `second_smallest`\n+        second_smallest.modify_size_estimate(smallest.size_estimate());\n+        for (k, v) in smallest.items_mut().drain() {\n+            second_smallest.items_mut().insert(k, v);\n+        }\n+\n+        // Record that `second_smallest` now contains all the stuff that was in\n+        // `smallest` before.\n+        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n+        cgu_contents.get_mut(&second_smallest.name()).unwrap().extend(consumed_cgu_names.drain(..));\n+\n+        debug!(\n+            \"CodegenUnit {} merged into CodegenUnit {}\",\n+            smallest.name(),\n+            second_smallest.name()\n+        );\n+    }\n+\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+\n+    if tcx.sess.opts.incremental.is_some() {\n+        // If we are doing incremental compilation, we want CGU names to\n+        // reflect the path of the source level module they correspond to.\n+        // For CGUs that contain the code of multiple modules because of the\n+        // merging done above, we use a concatenation of the names of\n+        // all contained CGUs.\n+        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n+            .into_iter()\n+            // This `filter` makes sure we only update the name of CGUs that\n+            // were actually modified by merging.\n+            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n+            .map(|(current_cgu_name, cgu_contents)| {\n+                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| &s[..]).collect();\n+\n+                // Sort the names, so things are deterministic and easy to\n+                // predict.\n+                cgu_contents.sort();\n+\n+                (current_cgu_name, cgu_contents.join(\"--\"))\n+            })\n+            .collect();\n+\n+        for cgu in codegen_units.iter_mut() {\n+            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n+                if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                } else {\n+                    // If we don't require CGU names to be human-readable, we\n+                    // use a fixed length hash of the composite CGU name\n+                    // instead.\n+                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                }\n+            }\n+        }\n+    } else {\n+        // If we are compiling non-incrementally we just generate simple CGU\n+        // names containing an index.\n+        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n+            cgu.set_name(numbered_codegen_unit_name(cgu_name_builder, index));\n+        }\n+    }\n+}\n+\n+fn numbered_codegen_unit_name(\n+    name_builder: &mut CodegenUnitNameBuilder<'_>,\n+    index: usize,\n+) -> Symbol {\n+    name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index))\n+}"}, {"sha": "9dfbd65e1b1a81131cf961704f47ee8557dced06", "filename": "src/librustc_mir/monomorphize/partitioning/mod.rs", "status": "added", "additions": 433, "deletions": 0, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/8ba22504e8e5dcbbe136d97f63c1280dabc523d0/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba22504e8e5dcbbe136d97f63c1280dabc523d0/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning%2Fmod.rs?ref=8ba22504e8e5dcbbe136d97f63c1280dabc523d0", "patch": "@@ -0,0 +1,433 @@\n+//! Partitioning Codegen Units for Incremental Compilation\n+//! ======================================================\n+//!\n+//! The task of this module is to take the complete set of monomorphizations of\n+//! a crate and produce a set of codegen units from it, where a codegen unit\n+//! is a named set of (mono-item, linkage) pairs. That is, this module\n+//! decides which monomorphization appears in which codegen units with which\n+//! linkage. The following paragraphs describe some of the background on the\n+//! partitioning scheme.\n+//!\n+//! The most important opportunity for saving on compilation time with\n+//! incremental compilation is to avoid re-codegenning and re-optimizing code.\n+//! Since the unit of codegen and optimization for LLVM is \"modules\" or, how\n+//! we call them \"codegen units\", the particulars of how much time can be saved\n+//! by incremental compilation are tightly linked to how the output program is\n+//! partitioned into these codegen units prior to passing it to LLVM --\n+//! especially because we have to treat codegen units as opaque entities once\n+//! they are created: There is no way for us to incrementally update an existing\n+//! LLVM module and so we have to build any such module from scratch if it was\n+//! affected by some change in the source code.\n+//!\n+//! From that point of view it would make sense to maximize the number of\n+//! codegen units by, for example, putting each function into its own module.\n+//! That way only those modules would have to be re-compiled that were actually\n+//! affected by some change, minimizing the number of functions that could have\n+//! been re-used but just happened to be located in a module that is\n+//! re-compiled.\n+//!\n+//! However, since LLVM optimization does not work across module boundaries,\n+//! using such a highly granular partitioning would lead to very slow runtime\n+//! code since it would effectively prohibit inlining and other inter-procedure\n+//! optimizations. We want to avoid that as much as possible.\n+//!\n+//! Thus we end up with a trade-off: The bigger the codegen units, the better\n+//! LLVM's optimizer can do its work, but also the smaller the compilation time\n+//! reduction we get from incremental compilation.\n+//!\n+//! Ideally, we would create a partitioning such that there are few big codegen\n+//! units with few interdependencies between them. For now though, we use the\n+//! following heuristic to determine the partitioning:\n+//!\n+//! - There are two codegen units for every source-level module:\n+//! - One for \"stable\", that is non-generic, code\n+//! - One for more \"volatile\" code, i.e., monomorphized instances of functions\n+//!   defined in that module\n+//!\n+//! In order to see why this heuristic makes sense, let's take a look at when a\n+//! codegen unit can get invalidated:\n+//!\n+//! 1. The most straightforward case is when the BODY of a function or global\n+//! changes. Then any codegen unit containing the code for that item has to be\n+//! re-compiled. Note that this includes all codegen units where the function\n+//! has been inlined.\n+//!\n+//! 2. The next case is when the SIGNATURE of a function or global changes. In\n+//! this case, all codegen units containing a REFERENCE to that item have to be\n+//! re-compiled. This is a superset of case 1.\n+//!\n+//! 3. The final and most subtle case is when a REFERENCE to a generic function\n+//! is added or removed somewhere. Even though the definition of the function\n+//! might be unchanged, a new REFERENCE might introduce a new monomorphized\n+//! instance of this function which has to be placed and compiled somewhere.\n+//! Conversely, when removing a REFERENCE, it might have been the last one with\n+//! that particular set of generic arguments and thus we have to remove it.\n+//!\n+//! From the above we see that just using one codegen unit per source-level\n+//! module is not such a good idea, since just adding a REFERENCE to some\n+//! generic item somewhere else would invalidate everything within the module\n+//! containing the generic item. The heuristic above reduces this detrimental\n+//! side-effect of references a little by at least not touching the non-generic\n+//! code of the module.\n+//!\n+//! A Note on Inlining\n+//! ------------------\n+//! As briefly mentioned above, in order for LLVM to be able to inline a\n+//! function call, the body of the function has to be available in the LLVM\n+//! module where the call is made. This has a few consequences for partitioning:\n+//!\n+//! - The partitioning algorithm has to take care of placing functions into all\n+//!   codegen units where they should be available for inlining. It also has to\n+//!   decide on the correct linkage for these functions.\n+//!\n+//! - The partitioning algorithm has to know which functions are likely to get\n+//!   inlined, so it can distribute function instantiations accordingly. Since\n+//!   there is no way of knowing for sure which functions LLVM will decide to\n+//!   inline in the end, we apply a heuristic here: Only functions marked with\n+//!   `#[inline]` are considered for inlining by the partitioner. The current\n+//!   implementation will not try to determine if a function is likely to be\n+//!   inlined by looking at the functions definition.\n+//!\n+//! Note though that as a side-effect of creating a codegen units per\n+//! source-level module, functions from the same module will be available for\n+//! inlining, even when they are not marked `#[inline]`.\n+\n+mod default;\n+mod merging;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync;\n+use rustc_hir::def_id::{CrateNum, DefIdSet, LOCAL_CRATE};\n+use rustc_middle::mir::mono::MonoItem;\n+use rustc_middle::mir::mono::{CodegenUnit, Linkage};\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::symbol::Symbol;\n+\n+use crate::monomorphize::collector::InliningMap;\n+use crate::monomorphize::collector::{self, MonoItemCollectionMode};\n+\n+trait Partitioner<'tcx> {\n+    fn place_root_mono_items(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        mono_items: &mut dyn Iterator<Item = MonoItem<'tcx>>,\n+    ) -> PreInliningPartitioning<'tcx>;\n+\n+    fn merge_codegen_units(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        target_cgu_count: usize,\n+    );\n+\n+    fn place_inlined_mono_items(\n+        &mut self,\n+        initial_partitioning: PreInliningPartitioning<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+    ) -> PostInliningPartitioning<'tcx>;\n+\n+    fn internalize_symbols(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        partitioning: &mut PostInliningPartitioning<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+    );\n+}\n+\n+fn get_partitioner<'tcx>(tcx: TyCtxt<'tcx>) -> Box<dyn Partitioner<'tcx>> {\n+    let strategy = match &tcx.sess.opts.debugging_opts.cgu_partitioning_strategy {\n+        None => \"default\",\n+        Some(s) => &s[..],\n+    };\n+\n+    match strategy {\n+        \"default\" => Box::new(default::DefaultPartitioning),\n+        _ => tcx.sess.fatal(\"unknown partitioning strategy\"),\n+    }\n+}\n+\n+pub fn partition<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_items: &mut dyn Iterator<Item = MonoItem<'tcx>>,\n+    max_cgu_count: usize,\n+    inlining_map: &InliningMap<'tcx>,\n+) -> Vec<CodegenUnit<'tcx>> {\n+    let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n+\n+    let mut partitioner = get_partitioner(tcx);\n+    // In the first step, we place all regular monomorphizations into their\n+    // respective 'home' codegen unit. Regular monomorphizations are all\n+    // functions and statics defined in the local crate.\n+    let mut initial_partitioning = {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n+        partitioner.place_root_mono_items(tcx, mono_items)\n+    };\n+\n+    initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n+\n+    debug_dump(tcx, \"INITIAL PARTITIONING:\", initial_partitioning.codegen_units.iter());\n+\n+    // Merge until we have at most `max_cgu_count` codegen units.\n+    {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n+        partitioner.merge_codegen_units(tcx, &mut initial_partitioning, max_cgu_count);\n+        debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n+    }\n+\n+    // In the next step, we use the inlining map to determine which additional\n+    // monomorphizations have to go into each codegen unit. These additional\n+    // monomorphizations can be drop-glue, functions from external crates, and\n+    // local functions the definition of which is marked with `#[inline]`.\n+    let mut post_inlining = {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n+        partitioner.place_inlined_mono_items(initial_partitioning, inlining_map)\n+    };\n+\n+    post_inlining.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n+\n+    debug_dump(tcx, \"POST INLINING:\", post_inlining.codegen_units.iter());\n+\n+    // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n+    // more freedom to optimize.\n+    if tcx.sess.opts.cg.link_dead_code != Some(true) {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n+        partitioner.internalize_symbols(tcx, &mut post_inlining, inlining_map);\n+    }\n+\n+    // Finally, sort by codegen unit name, so that we get deterministic results.\n+    let PostInliningPartitioning {\n+        codegen_units: mut result,\n+        mono_item_placements: _,\n+        internalization_candidates: _,\n+    } = post_inlining;\n+\n+    result.sort_by_cached_key(|cgu| cgu.name().as_str());\n+\n+    result\n+}\n+\n+pub struct PreInliningPartitioning<'tcx> {\n+    codegen_units: Vec<CodegenUnit<'tcx>>,\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+}\n+\n+/// For symbol internalization, we need to know whether a symbol/mono-item is\n+/// accessed from outside the codegen unit it is defined in. This type is used\n+/// to keep track of that.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+enum MonoItemPlacement {\n+    SingleCgu { cgu_name: Symbol },\n+    MultipleCgus,\n+}\n+\n+struct PostInliningPartitioning<'tcx> {\n+    codegen_units: Vec<CodegenUnit<'tcx>>,\n+    mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+}\n+\n+fn debug_dump<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, label: &str, cgus: I)\n+where\n+    I: Iterator<Item = &'a CodegenUnit<'tcx>>,\n+    'tcx: 'a,\n+{\n+    if cfg!(debug_assertions) {\n+        debug!(\"{}\", label);\n+        for cgu in cgus {\n+            debug!(\"CodegenUnit {} estimated size {} :\", cgu.name(), cgu.size_estimate());\n+\n+            for (mono_item, linkage) in cgu.items() {\n+                let symbol_name = mono_item.symbol_name(tcx).name;\n+                let symbol_hash_start = symbol_name.rfind('h');\n+                let symbol_hash =\n+                    symbol_hash_start.map(|i| &symbol_name[i..]).unwrap_or(\"<no hash>\");\n+\n+                debug!(\n+                    \" - {} [{:?}] [{}] estimated size {}\",\n+                    mono_item.to_string(tcx, true),\n+                    linkage,\n+                    symbol_hash,\n+                    mono_item.size_estimate(tcx)\n+                );\n+            }\n+\n+            debug!(\"\");\n+        }\n+    }\n+}\n+\n+#[inline(never)] // give this a place in the profiler\n+fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I)\n+where\n+    I: Iterator<Item = &'a MonoItem<'tcx>>,\n+    'tcx: 'a,\n+{\n+    let _prof_timer = tcx.prof.generic_activity(\"assert_symbols_are_distinct\");\n+\n+    let mut symbols: Vec<_> =\n+        mono_items.map(|mono_item| (mono_item, mono_item.symbol_name(tcx))).collect();\n+\n+    symbols.sort_by_key(|sym| sym.1);\n+\n+    for pair in symbols.windows(2) {\n+        let sym1 = &pair[0].1;\n+        let sym2 = &pair[1].1;\n+\n+        if sym1 == sym2 {\n+            let mono_item1 = pair[0].0;\n+            let mono_item2 = pair[1].0;\n+\n+            let span1 = mono_item1.local_span(tcx);\n+            let span2 = mono_item2.local_span(tcx);\n+\n+            // Deterministically select one of the spans for error reporting\n+            let span = match (span1, span2) {\n+                (Some(span1), Some(span2)) => {\n+                    Some(if span1.lo().0 > span2.lo().0 { span1 } else { span2 })\n+                }\n+                (span1, span2) => span1.or(span2),\n+            };\n+\n+            let error_message = format!(\"symbol `{}` is already defined\", sym1);\n+\n+            if let Some(span) = span {\n+                tcx.sess.span_fatal(span, &error_message)\n+            } else {\n+                tcx.sess.fatal(&error_message)\n+            }\n+        }\n+    }\n+}\n+\n+fn collect_and_partition_mono_items<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cnum: CrateNum,\n+) -> (&'tcx DefIdSet, &'tcx [CodegenUnit<'tcx>]) {\n+    assert_eq!(cnum, LOCAL_CRATE);\n+\n+    let collection_mode = match tcx.sess.opts.debugging_opts.print_mono_items {\n+        Some(ref s) => {\n+            let mode_string = s.to_lowercase();\n+            let mode_string = mode_string.trim();\n+            if mode_string == \"eager\" {\n+                MonoItemCollectionMode::Eager\n+            } else {\n+                if mode_string != \"lazy\" {\n+                    let message = format!(\n+                        \"Unknown codegen-item collection mode '{}'. \\\n+                                           Falling back to 'lazy' mode.\",\n+                        mode_string\n+                    );\n+                    tcx.sess.warn(&message);\n+                }\n+\n+                MonoItemCollectionMode::Lazy\n+            }\n+        }\n+        None => {\n+            if tcx.sess.opts.cg.link_dead_code == Some(true) {\n+                MonoItemCollectionMode::Eager\n+            } else {\n+                MonoItemCollectionMode::Lazy\n+            }\n+        }\n+    };\n+\n+    let (items, inlining_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n+\n+    tcx.sess.abort_if_errors();\n+\n+    let (codegen_units, _) = tcx.sess.time(\"partition_and_assert_distinct_symbols\", || {\n+        sync::join(\n+            || {\n+                &*tcx.arena.alloc_from_iter(partition(\n+                    tcx,\n+                    &mut items.iter().cloned(),\n+                    tcx.sess.codegen_units(),\n+                    &inlining_map,\n+                ))\n+            },\n+            || assert_symbols_are_distinct(tcx, items.iter()),\n+        )\n+    });\n+\n+    let mono_items: DefIdSet = items\n+        .iter()\n+        .filter_map(|mono_item| match *mono_item {\n+            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n+            MonoItem::Static(def_id) => Some(def_id),\n+            _ => None,\n+        })\n+        .collect();\n+\n+    if tcx.sess.opts.debugging_opts.print_mono_items.is_some() {\n+        let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n+\n+        for cgu in codegen_units {\n+            for (&mono_item, &linkage) in cgu.items() {\n+                item_to_cgus.entry(mono_item).or_default().push((cgu.name(), linkage));\n+            }\n+        }\n+\n+        let mut item_keys: Vec<_> = items\n+            .iter()\n+            .map(|i| {\n+                let mut output = i.to_string(tcx, false);\n+                output.push_str(\" @@\");\n+                let mut empty = Vec::new();\n+                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n+                cgus.sort_by_key(|(name, _)| *name);\n+                cgus.dedup();\n+                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n+                    output.push_str(\" \");\n+                    output.push_str(&cgu_name.as_str());\n+\n+                    let linkage_abbrev = match linkage {\n+                        Linkage::External => \"External\",\n+                        Linkage::AvailableExternally => \"Available\",\n+                        Linkage::LinkOnceAny => \"OnceAny\",\n+                        Linkage::LinkOnceODR => \"OnceODR\",\n+                        Linkage::WeakAny => \"WeakAny\",\n+                        Linkage::WeakODR => \"WeakODR\",\n+                        Linkage::Appending => \"Appending\",\n+                        Linkage::Internal => \"Internal\",\n+                        Linkage::Private => \"Private\",\n+                        Linkage::ExternalWeak => \"ExternalWeak\",\n+                        Linkage::Common => \"Common\",\n+                    };\n+\n+                    output.push_str(\"[\");\n+                    output.push_str(linkage_abbrev);\n+                    output.push_str(\"]\");\n+                }\n+                output\n+            })\n+            .collect();\n+\n+        item_keys.sort();\n+\n+        for item in item_keys {\n+            println!(\"MONO_ITEM {}\", item);\n+        }\n+    }\n+\n+    (tcx.arena.alloc(mono_items), codegen_units)\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.collect_and_partition_mono_items = collect_and_partition_mono_items;\n+\n+    providers.is_codegened_item = |tcx, def_id| {\n+        let (all_mono_items, _) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+        all_mono_items.contains(&def_id)\n+    };\n+\n+    providers.codegen_unit = |tcx, name| {\n+        let (_, all) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+        all.iter()\n+            .find(|cgu| cgu.name() == name)\n+            .unwrap_or_else(|| panic!(\"failed to find cgu with name {:?}\", name))\n+    };\n+}"}, {"sha": "d05f1a3f34b78337d924ba78ca9e22880331517e", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ba22504e8e5dcbbe136d97f63c1280dabc523d0/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba22504e8e5dcbbe136d97f63c1280dabc523d0/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=8ba22504e8e5dcbbe136d97f63c1280dabc523d0", "patch": "@@ -807,6 +807,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"select which borrowck is used (`mir` or `migrate`) (default: `migrate`)\"),\n     borrowck_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather borrowck statistics (default: no)\"),\n+    cgu_partitioning_strategy: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"the codegen unit partitioning strategy to use\"),\n     chalk: bool = (false, parse_bool, [TRACKED],\n         \"enable the experimental Chalk-based trait solving engine\"),\n     codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],"}]}