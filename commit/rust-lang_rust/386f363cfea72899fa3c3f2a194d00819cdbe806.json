{"sha": "386f363cfea72899fa3c3f2a194d00819cdbe806", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NmYzNjNjZmVhNzI4OTlmYTNjM2YyYTE5NGQwMDgxOWNkYmU4MDY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-29T22:18:26Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-29T22:18:26Z"}, "message": "Change from bool to tag ast.mutability.", "tree": {"sha": "824eda78ba43562d964a78c62aa7e0c6d58873e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/824eda78ba43562d964a78c62aa7e0c6d58873e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/386f363cfea72899fa3c3f2a194d00819cdbe806", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/386f363cfea72899fa3c3f2a194d00819cdbe806", "html_url": "https://github.com/rust-lang/rust/commit/386f363cfea72899fa3c3f2a194d00819cdbe806", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/386f363cfea72899fa3c3f2a194d00819cdbe806/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38846e39c4be0f12241ab0df2e94cbb366ae34ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/38846e39c4be0f12241ab0df2e94cbb366ae34ba", "html_url": "https://github.com/rust-lang/rust/commit/38846e39c4be0f12241ab0df2e94cbb366ae34ba"}], "stats": {"total": 114, "additions": 65, "deletions": 49}, "files": [{"sha": "5e34d481e0ce751bbe816be8f582f55bf00aa284", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/386f363cfea72899fa3c3f2a194d00819cdbe806/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386f363cfea72899fa3c3f2a194d00819cdbe806/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=386f363cfea72899fa3c3f2a194d00819cdbe806", "patch": "@@ -48,6 +48,11 @@ tag pat_ {\n     pat_tag(ident, vec[@pat], ann);\n }\n \n+tag mutability {\n+    mut;\n+    imm;\n+}\n+\n tag binop {\n     add;\n     sub;\n@@ -105,7 +110,7 @@ type arm = rec(@pat pat, block block);\n type expr = spanned[expr_];\n tag expr_ {\n     expr_vec(vec[@expr], ann);\n-    expr_tup(vec[tup(bool /* mutability */, @expr)], ann);\n+    expr_tup(vec[tup(mutability, @expr)], ann);\n     expr_rec(vec[tup(ident,@expr)], ann);\n     expr_call(@expr, vec[@expr], ann);\n     expr_binary(binop, @expr, @expr, ann);\n@@ -147,7 +152,7 @@ tag ty_ {\n     ty_str;\n     ty_box(@ty);\n     ty_vec(@ty);\n-    ty_tup(vec[tup(bool /* mutability */, @ty)]);\n+    ty_tup(vec[tup(mutability, @ty)]);\n     ty_fn(vec[rec(mode mode, @ty ty)], @ty);        // TODO: effect\n     ty_path(path, option.t[def]);\n     ty_mutable(@ty);"}, {"sha": "e88760f6dca8dd324b6aa781f2d4fac078e952e0", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/386f363cfea72899fa3c3f2a194d00819cdbe806/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386f363cfea72899fa3c3f2a194d00819cdbe806/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=386f363cfea72899fa3c3f2a194d00819cdbe806", "patch": "@@ -96,13 +96,14 @@ impure fn parse_ident(parser p) -> ast.ident {\n     }\n }\n \n-impure fn parse_possibly_mutable_ty(parser p) -> tup(bool, @ast.ty) {\n+impure fn parse_possibly_mutable_ty(parser p)\n+    -> tup(ast.mutability, @ast.ty) {\n     auto mut;\n     if (p.peek() == token.MUTABLE) {\n         p.bump();\n-        mut = true;\n+        mut = ast.mut;\n     } else {\n-        mut = false;\n+        mut = ast.imm;\n     }\n \n     ret tup(mut, parse_ty(p));\n@@ -192,8 +193,10 @@ impure fn parse_ty(parser p) -> @ast.ty {\n         case (token.TUP) {\n             p.bump();\n             auto f = parse_possibly_mutable_ty; // FIXME: trans_const_lval bug\n-            auto elems = parse_seq[tup(bool, @ast.ty)](token.LPAREN,\n-                token.RPAREN, some(token.COMMA), f, p);\n+            auto elems =\n+                parse_seq[tup(ast.mutability, @ast.ty)]\n+                (token.LPAREN,\n+                 token.RPAREN, some(token.COMMA), f, p);\n             hi = p.get_span();\n             t = ast.ty_tup(elems.node);\n         }\n@@ -346,13 +349,14 @@ impure fn parse_name(parser p, ast.ident id) -> ast.name {\n     ret spanned(lo, tys.span, rec(ident=id, types=tys.node));\n }\n \n-impure fn parse_possibly_mutable_expr(parser p) -> tup(bool, @ast.expr) {\n+impure fn parse_possibly_mutable_expr(parser p)\n+    -> tup(ast.mutability, @ast.expr) {\n     auto mut;\n     if (p.peek() == token.MUTABLE) {\n         p.bump();\n-        mut = true;\n+        mut = ast.mut;\n     } else {\n-        mut = false;\n+        mut = ast.imm;\n     }\n \n     ret tup(mut, parse_expr(p));\n@@ -409,10 +413,12 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n         case (token.TUP) {\n             p.bump();\n             auto pf = parse_possibly_mutable_expr;\n-            auto es = parse_seq[tup(bool, @ast.expr)](token.LPAREN,\n-                                                      token.RPAREN,\n-                                                      some(token.COMMA),\n-                                                      pf, p);\n+            auto es =\n+                parse_seq[tup(ast.mutability, @ast.expr)]\n+                (token.LPAREN,\n+                 token.RPAREN,\n+                 some(token.COMMA),\n+                 pf, p);\n             hi = es.span;\n             ex = ast.expr_tup(es.node, ast.ann_none);\n         }"}, {"sha": "7b64738033bfef7e17ca9c359a7fc71bae0e6b61", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/386f363cfea72899fa3c3f2a194d00819cdbe806/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386f363cfea72899fa3c3f2a194d00819cdbe806/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=386f363cfea72899fa3c3f2a194d00819cdbe806", "patch": "@@ -13,6 +13,7 @@ import front.ast;\n import front.ast.ident;\n import front.ast.name;\n import front.ast.path;\n+import front.ast.mutability;\n import front.ast.ty;\n import front.ast.expr;\n import front.ast.stmt;\n@@ -46,7 +47,7 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_vec,\n \n      (fn(&ENV e, &span sp,\n-         vec[tup(bool, @ty)] elts) -> @ty)        fold_ty_tup,\n+         vec[tup(mutability, @ty)] elts) -> @ty)  fold_ty_tup,\n \n      (fn(&ENV e, &span sp,\n          vec[rec(ast.mode mode, @ty ty)] inputs,\n@@ -62,7 +63,7 @@ type ast_fold[ENV] =\n          vec[@expr] es, ann a) -> @expr)          fold_expr_vec,\n \n      (fn(&ENV e, &span sp,\n-         vec[tup(bool,@expr)] es,\n+         vec[tup(mutability,@expr)] es,\n          ann a) -> @expr)                         fold_expr_tup,\n \n      (fn(&ENV e, &span sp,\n@@ -245,8 +246,8 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n         }\n \n         case (ast.ty_tup(?elts)) {\n-            let vec[tup(bool, @ty)] elts_ = vec();\n-            for (tup(bool, @ty) elt in elts) {\n+            let vec[tup(mutability, @ty)] elts_ = vec();\n+            for (tup(mutability, @ty) elt in elts) {\n                 elts_ += tup(elt._0, fold_ty(env, fld, elt._1));\n             }\n             ret fld.fold_ty_tup(env_, t.span, elts);\n@@ -335,8 +336,8 @@ fn fold_exprs[ENV](&ENV env, ast_fold[ENV] fld, vec[@expr] es) -> vec[@expr] {\n     ret exprs;\n }\n \n-fn fold_tup_entry[ENV](&ENV env, ast_fold[ENV] fld, &tup(bool,@expr) e)\n-    -> tup(bool,@expr) {\n+fn fold_tup_entry[ENV](&ENV env, ast_fold[ENV] fld,\n+                       &tup(mutability,@expr) e) -> tup(mutability,@expr) {\n     ret tup(e._0, fold_expr(env, fld, e._1));\n }\n \n@@ -360,8 +361,8 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n         }\n \n         case (ast.expr_tup(?es, ?t)) {\n-            let vec[tup(bool,@expr)] entries = vec();\n-            for (tup(bool,@expr) entry in es) {\n+            let vec[tup(mutability,@expr)] entries = vec();\n+            for (tup(mutability,@expr) entry in es) {\n                 entries += fold_tup_entry[ENV](env, fld, entry);\n             }\n             ret fld.fold_expr_tup(env_, e.span, entries, t);\n@@ -650,8 +651,8 @@ fn identity_fold_ty_vec[ENV](&ENV env, &span sp, @ty t) -> @ty {\n     ret @respan(sp, ast.ty_vec(t));\n }\n \n-fn identity_fold_ty_tup[ENV](&ENV env, &span sp, vec[tup(bool,@ty)] elts)\n-    -> @ty {\n+fn identity_fold_ty_tup[ENV](&ENV env, &span sp,\n+                             vec[tup(mutability,@ty)] elts) -> @ty {\n     ret @respan(sp, ast.ty_tup(elts));\n }\n \n@@ -678,7 +679,8 @@ fn identity_fold_expr_vec[ENV](&ENV env, &span sp, vec[@expr] es,\n     ret @respan(sp, ast.expr_vec(es, a));\n }\n \n-fn identity_fold_expr_tup[ENV](&ENV env, &span sp, vec[tup(bool, @expr)] es,\n+fn identity_fold_expr_tup[ENV](&ENV env, &span sp,\n+                               vec[tup(mutability, @expr)] es,\n                                ann a) -> @expr {\n     ret @respan(sp, ast.expr_tup(es, a));\n }"}, {"sha": "01e73a6ef453aab750ee0313f0f4f692f7a2411a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/386f363cfea72899fa3c3f2a194d00819cdbe806/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386f363cfea72899fa3c3f2a194d00819cdbe806/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=386f363cfea72899fa3c3f2a194d00819cdbe806", "patch": "@@ -275,7 +275,7 @@ fn type_of_inner(@crate_ctxt cx, @typeck.ty t) -> TypeRef {\n         }\n         case (typeck.ty_tup(?elts)) {\n             let vec[TypeRef] tys = vec();\n-            for (tup(bool, @typeck.ty) elt in elts) {\n+            for (tup(ast.mutability, @typeck.ty) elt in elts) {\n                 tys += type_of(cx, elt._1);\n             }\n             ret T_struct(tys);\n@@ -493,7 +493,7 @@ fn iter_structural_ty(@block_ctxt cx,\n     alt (t.struct) {\n         case (typeck.ty_tup(?args)) {\n             let int i = 0;\n-            for (tup(bool, @typeck.ty) arg in args) {\n+            for (tup(ast.mutability, @typeck.ty) arg in args) {\n                 auto elt = r.bcx.build.GEP(v, vec(C_int(0), C_int(i)));\n                 r = f(r.bcx, elt, arg._1);\n                 i += 1;\n@@ -1184,13 +1184,13 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n             args_res._0.build.FastCall(f_res._0.val, args_res._1));\n }\n \n-impure fn trans_tup(@block_ctxt cx, vec[tup(bool, @ast.expr)] args,\n+impure fn trans_tup(@block_ctxt cx, vec[tup(ast.mutability, @ast.expr)] args,\n                     &ast.ann ann) -> result {\n     auto ty = node_type(cx.fcx.ccx, ann);\n     auto tup_val = cx.build.Alloca(ty);\n     let int i = 0;\n     auto r = res(cx, C_nil());\n-    for (tup(bool, @ast.expr) arg in args) {\n+    for (tup(ast.mutability, @ast.expr) arg in args) {\n         auto t = typeck.expr_ty(arg._1);\n         auto src_res = trans_expr(r.bcx, arg._1);\n         auto dst_elt = r.bcx.build.GEP(tup_val, vec(C_int(0), C_int(i)));"}, {"sha": "31917959d1c67dfa0db7bf67829eb16251a95e5c", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/386f363cfea72899fa3c3f2a194d00819cdbe806/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386f363cfea72899fa3c3f2a194d00819cdbe806/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=386f363cfea72899fa3c3f2a194d00819cdbe806", "patch": "@@ -1,5 +1,6 @@\n import front.ast;\n import front.ast.ann;\n+import front.ast.mutability;\n import middle.fold;\n import driver.session;\n import util.common;\n@@ -28,7 +29,7 @@ type arg = rec(ast.mode mode, @ty ty);\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast.rs as well.\n-type ty = rec(sty struct, bool mut, option.t[str] cname);\n+type ty = rec(sty struct, mutability mut, option.t[str] cname);\n tag sty {\n     ty_nil;\n     ty_bool;\n@@ -39,7 +40,7 @@ tag sty {\n     ty_str;\n     ty_box(@ty);\n     ty_vec(@ty);\n-    ty_tup(vec[tup(bool /* mutability */, @ty)]);\n+    ty_tup(vec[tup(mutability, @ty)]);\n     ty_fn(vec[arg], @ty);                           // TODO: effect\n     ty_var(int);                                    // ephemeral type var\n     ty_local(ast.def_id);                           // type of a local var\n@@ -65,9 +66,9 @@ type ty_getter = fn(ast.def_id) -> @ty;\n // Error-reporting utility functions\n \n fn ast_ty_to_str(&@ast.ty ty) -> str {\n-    fn ast_tup_elem_to_str(&tup(bool, @ast.ty) elem) -> str {\n+    fn ast_tup_elem_to_str(&tup(mutability, @ast.ty) elem) -> str {\n         auto s;\n-        if (elem._0) {\n+        if (elem._0 == ast.mut) {\n             s = \"mutable \";\n         } else {\n             s = \"\";\n@@ -102,7 +103,9 @@ fn ast_ty_to_str(&@ast.ty ty) -> str {\n         case (ast.ty_tup(?elems)) {\n             auto f = ast_tup_elem_to_str;\n             s = \"tup(\";\n-            s += _str.connect(_vec.map[tup(bool,@ast.ty),str](f, elems), \",\");\n+            s +=\n+                _str.connect(_vec.map[tup(mutability,@ast.ty),str](f, elems),\n+                             \",\");\n             s += \")\";\n         }\n \n@@ -151,9 +154,9 @@ fn path_to_str(&ast.path path) -> str {\n }\n \n fn ty_to_str(@ty typ) -> str {\n-    fn tup_elem_to_str(&tup(bool, @ty) elem) -> str {\n+    fn tup_elem_to_str(&tup(mutability, @ty) elem) -> str {\n         auto s;\n-        if (elem._0) {\n+        if (elem._0 == ast.mut) {\n             s = \"mutable \";\n         } else {\n             s = \"\";\n@@ -187,7 +190,7 @@ fn ty_to_str(@ty typ) -> str {\n \n         case (ty_tup(?elems)) {\n             auto f = tup_elem_to_str;\n-            auto strs = _vec.map[tup(bool,@ty),str](f, elems);\n+            auto strs = _vec.map[tup(mutability,@ty),str](f, elems);\n             s = \"tup(\" + _str.connect(strs, \",\") + \")\";\n         }\n \n@@ -217,7 +220,7 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n         ret rec(mode=arg.mode, ty=ast_ty_to_ty(getter, arg.ty));\n     }\n \n-    auto mut = false;\n+    auto mut = ast.imm;\n     auto sty;\n     auto cname = none[str];\n     alt (ast_ty.node) {\n@@ -231,8 +234,8 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n         case (ast.ty_box(?t))      { sty = ty_box(ast_ty_to_ty(getter, t)); }\n         case (ast.ty_vec(?t))      { sty = ty_vec(ast_ty_to_ty(getter, t)); }\n         case (ast.ty_tup(?fields)) {\n-            let vec[tup(bool,@ty)] flds = vec();\n-            for (tup(bool, @ast.ty) field in fields) {\n+            let vec[tup(mutability,@ty)] flds = vec();\n+            for (tup(mutability, @ast.ty) field in fields) {\n                 flds += tup(field._0, ast_ty_to_ty(getter, field._1));\n             }\n             sty = ty_tup(flds);\n@@ -258,7 +261,7 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n         }\n \n         case (ast.ty_mutable(?t)) {\n-            mut = true;\n+            mut = ast.mut;\n             auto t0 = ast_ty_to_ty(getter, t);\n             sty = t0.struct;\n             cname = t0.cname;\n@@ -534,7 +537,7 @@ fn type_is_signed(@ty t) -> bool {\n }\n \n fn plain_ty(&sty st) -> @ty {\n-    ret @rec(struct=st, mut=false, cname=none[str]);\n+    ret @rec(struct=st, mut=ast.imm, cname=none[str]);\n }\n \n fn ann_to_type(&ast.ann ann) -> @ty {\n@@ -708,9 +711,9 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                 alt (actual.struct) {\n                     case (ty_tup(?actual_elems)) {\n                         auto expected_len =\n-                            _vec.len[tup(bool,@ty)](expected_elems);\n+                            _vec.len[tup(mutability,@ty)](expected_elems);\n                         auto actual_len =\n-                            _vec.len[tup(bool,@ty)](actual_elems);\n+                            _vec.len[tup(mutability,@ty)](actual_elems);\n                         if (expected_len != actual_len) {\n                             auto err = terr_tuple_size(expected_len,\n                                                        actual_len);\n@@ -719,7 +722,7 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n \n                         // TODO: implement an iterator that can iterate over\n                         // two arrays simultaneously.\n-                        let vec[tup(bool, @ty)] result_elems = vec();\n+                        let vec[tup(mutability, @ty)] result_elems = vec();\n                         auto i = 0u;\n                         while (i < expected_len) {\n                             auto expected_elem = expected_elems.(i);\n@@ -1254,10 +1257,10 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_tup(?args, _)) {\n-            let vec[tup(bool, @ast.expr)] args_1 = vec();\n-            let vec[tup(bool, @ty)] args_t = vec();\n+            let vec[tup(mutability, @ast.expr)] args_1 = vec();\n+            let vec[tup(mutability, @ty)] args_t = vec();\n \n-            for (tup(bool, @ast.expr) arg in args) {\n+            for (tup(mutability, @ast.expr) arg in args) {\n                 auto expr_1 = check_expr(fcx, arg._1);\n                 args_1 += tup(arg._0, expr_1);\n                 args_t += tup(arg._0, expr_ty(expr_1));\n@@ -1275,7 +1278,7 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (ty_tup(?args)) {\n                     let uint ix = field_num(fcx.ccx.sess,\n                                             expr.span, field);\n-                    if (ix >= _vec.len[tup(bool,@ty)](args)) {\n+                    if (ix >= _vec.len[tup(mutability,@ty)](args)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }"}]}