{"sha": "7ca216d7500c8e7e0226aeb8baca7f0e588cd120", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjYTIxNmQ3NTAwYzhlN2UwMjI2YWViOGJhY2E3ZjBlNTg4Y2QxMjA=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-04-20T20:50:50Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-04-20T20:51:55Z"}, "message": "Added case functions to Ascii", "tree": {"sha": "602d95182f03eec25a8c410899b7a1bc73acd6e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/602d95182f03eec25a8c410899b7a1bc73acd6e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ca216d7500c8e7e0226aeb8baca7f0e588cd120", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ca216d7500c8e7e0226aeb8baca7f0e588cd120", "html_url": "https://github.com/rust-lang/rust/commit/7ca216d7500c8e7e0226aeb8baca7f0e588cd120", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ca216d7500c8e7e0226aeb8baca7f0e588cd120/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61ffee738d505328fae14ac7c53bc388c69c5938", "url": "https://api.github.com/repos/rust-lang/rust/commits/61ffee738d505328fae14ac7c53bc388c69c5938", "html_url": "https://github.com/rust-lang/rust/commit/61ffee738d505328fae14ac7c53bc388c69c5938"}], "stats": {"total": 52, "additions": 52, "deletions": 0}, "files": [{"sha": "22303ef0ddc21c125c8e697551cf3e625a2211bf", "filename": "src/libcore/str/ascii.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7ca216d7500c8e7e0226aeb8baca7f0e588cd120/src%2Flibcore%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca216d7500c8e7e0226aeb8baca7f0e588cd120/src%2Flibcore%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fascii.rs?ref=7ca216d7500c8e7e0226aeb8baca7f0e588cd120", "patch": "@@ -22,17 +22,46 @@ pub struct Ascii { priv chr: u8 }\n \n pub impl Ascii {\n     /// Converts a ascii character into a `u8`.\n+    #[inline(always)]\n     fn to_byte(self) -> u8 {\n         self.chr\n     }\n \n     /// Converts a ascii character into a `char`.\n+    #[inline(always)]\n     fn to_char(self) -> char {\n         self.chr as char\n     }\n+\n+    /// Convert to lowercase.\n+    #[inline(always)]\n+    fn to_lower(self) -> Ascii {\n+        if self.chr >= 65 && self.chr <= 90 {\n+            Ascii{chr: self.chr | 0x20 }\n+        } else {\n+            self\n+        }\n+    }\n+\n+    /// Convert to uppercase.\n+    #[inline(always)]\n+    fn to_upper(self) -> Ascii {\n+        if self.chr >= 97 && self.chr <= 122 {\n+            Ascii{chr: self.chr & !0x20 }\n+        } else {\n+            self\n+        }\n+    }\n+\n+    // Compares two ascii characters of equality, ignoring case.\n+    #[inline(always)]\n+    fn eq_ignore_case(self, other: Ascii) -> bool {\n+        self.to_lower().chr == other.to_lower().chr\n+    }\n }\n \n impl ToStr for Ascii {\n+    #[inline(always)]\n     fn to_str(&self) -> ~str { str::from_bytes(['\\'' as u8, self.chr, '\\'' as u8]) }\n }\n \n@@ -46,12 +75,14 @@ pub trait AsciiCast<T> {\n }\n \n impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n+    #[inline(always)]\n     fn to_ascii(&self) -> &'self[Ascii] {\n         assert!(self.is_ascii());\n \n         unsafe{ cast::transmute(*self) }\n     }\n \n+    #[inline(always)]\n     fn is_ascii(&self) -> bool {\n         for self.each |b| {\n             if !b.is_ascii() { return false; }\n@@ -61,13 +92,15 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n }\n \n impl<'self> AsciiCast<&'self[Ascii]> for &'self str {\n+    #[inline(always)]\n     fn to_ascii(&self) -> &'self[Ascii] {\n         assert!(self.is_ascii());\n \n         let (p,len): (*u8, uint) = unsafe{ cast::transmute(*self) };\n         unsafe{ cast::transmute((p, len - 1))}\n     }\n \n+    #[inline(always)]\n     fn is_ascii(&self) -> bool {\n         for self.each |b| {\n             if !b.is_ascii() { return false; }\n@@ -77,22 +110,27 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self str {\n }\n \n impl AsciiCast<Ascii> for u8 {\n+    #[inline(always)]\n     fn to_ascii(&self) -> Ascii {\n         assert!(self.is_ascii());\n         Ascii{ chr: *self }\n     }\n \n+    #[inline(always)]\n     fn is_ascii(&self) -> bool {\n         *self & 128 == 0u8\n     }\n }\n \n impl AsciiCast<Ascii> for char {\n+\n+    #[inline(always)]\n     fn to_ascii(&self) -> Ascii {\n         assert!(self.is_ascii());\n         Ascii{ chr: *self as u8 }\n     }\n \n+    #[inline(always)]\n     fn is_ascii(&self) -> bool {\n         *self - ('\\x7F' & *self) == '\\x00'\n     }\n@@ -105,6 +143,7 @@ pub trait OwnedAsciiCast {\n }\n \n impl OwnedAsciiCast for ~[u8] {\n+    #[inline(always)]\n     fn to_ascii_consume(self) -> ~[Ascii] {\n         assert!(self.is_ascii());\n \n@@ -113,6 +152,7 @@ impl OwnedAsciiCast for ~[u8] {\n }\n \n impl OwnedAsciiCast for ~str {\n+    #[inline(always)]\n     fn to_ascii_consume(self) -> ~[Ascii] {\n         let mut s = self;\n         unsafe {\n@@ -129,6 +169,7 @@ pub trait ToStrAscii {\n }\n \n impl<'self> ToStrAscii for &'self [Ascii] {\n+    #[inline(always)]\n     fn to_str_ascii(&self) -> ~str {\n         let mut cpy = self.to_owned();\n         cpy.push(0u8.to_ascii());\n@@ -137,6 +178,7 @@ impl<'self> ToStrAscii for &'self [Ascii] {\n }\n \n impl ToStrConsume for ~[Ascii] {\n+    #[inline(always)]\n     fn to_str_consume(self) -> ~str {\n         let mut cpy = self;\n         cpy.push(0u8.to_ascii());\n@@ -163,6 +205,16 @@ mod tests {\n         assert_eq!(65u8.to_ascii().to_char(), 'A');\n         assert_eq!('A'.to_ascii().to_char(), 'A');\n         assert_eq!('A'.to_ascii().to_byte(), 65u8);\n+\n+        assert_eq!('A'.to_ascii().to_lower().to_char, 'a');\n+        assert_eq!('Z'.to_ascii().to_lower().to_char, 'z');\n+        assert_eq!('a'.to_ascii().to_upper().to_char, 'A');\n+        assert_eq!('z'.to_ascii().to_upper().to_char, 'Z');\n+\n+        assert_eq!('@'.to_ascii().to_lower().to_char, '@');\n+        assert_eq!('['.to_ascii().to_lower().to_char, '[');\n+        assert_eq!('`'.to_ascii().to_upper().to_char, '`');\n+        assert_eq!('{'.to_ascii().to_upper().to_char, '{');\n     }\n \n     #[test]"}]}