{"sha": "1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ODBjY2NlMWVkMWI4OWJjNzQ2YzZjNzY0MTczZThmMGIyMzNjYTY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-06T16:02:13Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-16T22:28:05Z"}, "message": "Classes WIP\n\nCross-crate metadata for classes works well enough that programs with\nclasses in other crates compile successfully, but output wrong results.\nChecking in work so far to avoid merge hassles. (Tests are xfailed.)", "tree": {"sha": "48f5f3d13bd0d893df92266b6f13c7ecbf1a1f71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48f5f3d13bd0d893df92266b6f13c7ecbf1a1f71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "html_url": "https://github.com/rust-lang/rust/commit/1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47d468f08c770485baa61e3a353e83b85ba5037f", "url": "https://api.github.com/repos/rust-lang/rust/commits/47d468f08c770485baa61e3a353e83b85ba5037f", "html_url": "https://github.com/rust-lang/rust/commit/47d468f08c770485baa61e3a353e83b85ba5037f"}], "stats": {"total": 497, "additions": 381, "deletions": 116}, "files": [{"sha": "493166144f550c288bd56c2695ec38063745f8b2", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -78,6 +78,7 @@ const tag_path: uint = 0x40u;\n const tag_path_len: uint = 0x41u;\n const tag_path_elt_mod: uint = 0x42u;\n const tag_path_elt_name: uint = 0x43u;\n+const tag_items_class_member: uint = 0x44u;\n \n // used to encode crate_ctxt side tables\n enum astencode_tag { // Reserves 0x50 -- 0x6f"}, {"sha": "2451f9f37c721eaa73c533fb054210b995067c26", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -9,6 +9,7 @@ import middle::trans::common::maps;\n import std::map::hashmap;\n \n export get_symbol;\n+export get_class_items;\n export get_type_param_count;\n export lookup_defs;\n export lookup_method_purity;\n@@ -35,6 +36,7 @@ fn get_type_param_count(cstore: cstore::cstore, def: ast::def_id) -> uint {\n fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n                path: [ast::ident]) -> [ast::def] {\n     let result = [];\n+    #debug(\"lookup_defs: path = %? cnum = %?\", path, cnum);\n     for (c, data, def) in resolve_path(cstore, cnum, path) {\n         result += [decoder::lookup_def(c, data, def)];\n     }\n@@ -116,6 +118,12 @@ fn get_iface_methods(tcx: ty::ctxt, def: ast::def_id) -> @[ty::method] {\n     decoder::get_iface_methods(cdata, def.node, tcx)\n }\n \n+fn get_class_items(tcx: ty::ctxt, def: ast::def_id) -> [@ty::class_item_ty] {\n+    let cstore = tcx.sess.cstore;\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_class_items(cdata, def.node, tcx)\n+}\n+\n fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.sess.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);"}, {"sha": "1dc779232c934e2600db8f0dc17baed4f79799c0", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -162,10 +162,9 @@ fn get_dep_hashes(cstore: cstore) -> [str] {\n }\n \n fn get_path(cstore: cstore, d: ast::def_id) -> [str] {\n-    alt p(cstore).mod_path_map.find(d) {\n-      option::some(ds) { str::split_str(ds, \"::\") }\n-      option::none { [] }\n-    }\n+    // let f = bind str::split_str(_, \"::\");\n+    option::maybe([], p(cstore).mod_path_map.find(d),\n+                  {|ds| str::split_str(ds, \"::\")})\n }\n // Local Variables:\n // mode: rust"}, {"sha": "6effd8e2516b5ba16a39551937b607d8ef5d36cf", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -9,11 +9,13 @@ import front::attr;\n import middle::ty;\n import middle::ast_map;\n import common::*;\n-import tydecode::{parse_ty_data, parse_def_id, parse_bounds_data};\n+import tydecode::{parse_ty_data, parse_def_id, parse_bounds_data,\n+        parse_ident};\n import syntax::print::pprust;\n import cmd=cstore::crate_metadata;\n import middle::trans::common::maps;\n \n+export get_class_items;\n export get_symbol;\n export get_enum_variants;\n export get_type;\n@@ -84,7 +86,10 @@ fn find_item(item_id: int, items: ebml::doc) -> ebml::doc {\n // to the item data.\n fn lookup_item(item_id: int, data: @[u8]) -> ebml::doc {\n     let items = ebml::get_doc(ebml::doc(data), tag_items);\n-    ret find_item(item_id, items);\n+    alt maybe_find_item(item_id, items) {\n+       none { fail(#fmt(\"lookup_item: id not found: %d\", item_id)); }\n+       some(d) { d }\n+    }\n }\n \n fn item_family(item: ebml::doc) -> char {\n@@ -105,6 +110,11 @@ fn item_parent_item(d: ebml::doc) -> option<ast::def_id> {\n     found\n }\n \n+fn class_field_id(d: ebml::doc) -> ast::def_id {\n+    let tagdoc = ebml::get_doc(d, tag_def_id);\n+    ret parse_def_id(ebml::doc_data(tagdoc));\n+}\n+\n fn variant_disr_val(d: ebml::doc) -> option<int> {\n     option::chain(ebml::maybe_get_doc(d, tag_disr_val)) {|val_doc|\n         int::parse_buf(ebml::doc_data(val_doc), 10u)\n@@ -178,6 +188,7 @@ fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n     let paths = ebml::get_doc(md, tag_paths);\n     let eqer = bind eq_item(_, s);\n     let result: [ast::def_id] = [];\n+    #debug(\"resolve_path: looking up %s\", s);\n     for doc: ebml::doc in lookup_hash(paths, eqer, hash_path(s)) {\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n         result += [parse_def_id(ebml::doc_data(did_doc))];\n@@ -226,6 +237,7 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n     // We treat references to enums as references to types.\n     alt check fam_ch {\n       'c' { ast::def_const(did) }\n+      'C' { ast::def_class(did) }\n       'u' { ast::def_fn(did, ast::unsafe_fn) }\n       'f' { ast::def_fn(did, ast::impure_fn) }\n       'p' { ast::def_fn(did, ast::pure_fn) }\n@@ -393,10 +405,48 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     @result\n }\n \n+/*\n+  FIXME\n+  This is not working. metadata is broken -- fields get encoded correctly,\n+  but not decoded. look at this code, see what it's actually writing out\n+  also see what \"data\" is\n+ */\n+fn get_class_items(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+    -> [@ty::class_item_ty] {\n+    let data = cdata.data;\n+    let item = lookup_item(id, data), result = [];\n+    #debug(\"get_class_items: %s\", item_name(item));\n+    #debug(\"item: %?\", item);\n+    // right tag?\n+    ebml::tagged_docs(item, tag_items_class_member) {|an_item|\n+        let fam = item_family(an_item);\n+        let decl = alt check fam {\n+                'g' {\n+                    let name = item_name(an_item);\n+                    #debug(\"why hello there! %s\", name);\n+                    let ty = doc_type(an_item, tcx, cdata);\n+                    let did = class_field_id(an_item);\n+                    {ident: name,\n+                     id: did.node,\n+                     contents: ty::var_ty(ty)}\n+                }\n+                _ {\n+                    fail; // FIXME\n+                }\n+        };\n+        result += [@decl];\n+    }\n+    result\n+}\n+\n+\n+\n fn family_has_type_params(fam_ch: char) -> bool {\n     alt check fam_ch {\n-      'c' | 'T' | 'm' | 'n' { false }\n-      'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' { true }\n+      'c' | 'T' | 'm' | 'n' | 'g' | 'h' { false }\n+      'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' | 'C'\n+          | 'a'\n+          { true }\n     }\n }\n \n@@ -434,6 +484,7 @@ fn item_family_to_str(fam: char) -> str {\n       'v' { ret \"enum\"; }\n       'i' { ret \"impl\"; }\n       'I' { ret \"iface\"; }\n+      'C' { ret \"class\"; }\n     }\n }\n "}, {"sha": "fe2f01624ca172cc462ba830b2a7d0abad5fb45b", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 122, "deletions": 6, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -76,6 +76,23 @@ fn encode_native_module_item_paths(ebml_w: ebml::writer, nmod: native_mod,\n     }\n }\n \n+fn encode_class_item_paths(ebml_w: ebml::writer,\n+     items: [@class_item], path: [str], &index: [entry<str>]) {\n+    for it in items {\n+       alt it.node.privacy {\n+          priv { cont; }\n+          pub {\n+              let (id, ident) = alt it.node.decl {\n+                      instance_var(v, _, _, vid) { (vid, v) }\n+                      class_method(it) { (it.id, it.ident) }\n+              };\n+              add_to_index(ebml_w, path, index, ident);\n+              encode_named_def_id(ebml_w, ident, local_def(id));\n+          }\n+       }\n+    }\n+}\n+\n fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                             module: _mod, path: [str], &index: [entry<str>]) {\n     // FIXME factor out add_to_index/start/encode_name/encode_def_id/end ops\n@@ -128,8 +145,20 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml_w.end_tag();\n           }\n-          item_class(_,_,_) {\n-              fail \"encode: implement item_class\";\n+          item_class(tps,items,ctor) {\n+              add_to_index(ebml_w, path, index, it.ident);\n+              ebml_w.start_tag(tag_paths_data_item);\n+              encode_name(ebml_w, it.ident);\n+              encode_def_id(ebml_w, local_def(it.id));\n+              ebml_w.end_tag();\n+              ebml_w.start_tag(tag_paths);\n+              /* a bit confused -- adding the same ident twice\n+               (once for class, once for ctor) */\n+              add_to_index(ebml_w, path, index, it.ident);\n+              encode_named_def_id(ebml_w, it.ident, local_def(ctor.node.id));\n+              encode_class_item_paths(ebml_w, items, path + [it.ident],\n+                                      index);\n+              ebml_w.end_tag();\n           }\n           item_enum(variants, tps) {\n             add_to_index(ebml_w, path, index, it.ident);\n@@ -312,13 +341,80 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n             }\n         }\n       }\n-      _ { ecx.ccx.tcx.sess.bug(\"encode_info_for_mod: \\\n-             undocumented invariant\"); }\n+      _ { ecx.ccx.tcx.sess.bug(#fmt(\"encode_info_for_mod: empty impl_map \\\n+            entry for %?\", path)); }\n     }\n     encode_path(ebml_w, path, ast_map::path_mod(name));\n     ebml_w.end_tag();\n }\n \n+fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+                         id: node_id, path: ast_map::path, name: ident,\n+                         tps: [ty_param], items: [@class_item]) {\n+    let tcx = ecx.ccx.tcx;\n+    encode_def_id(ebml_w, local_def(id));\n+    encode_family(ebml_w, 'C');\n+    encode_type_param_bounds(ebml_w, ecx, tps);\n+    encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n+    encode_name(ebml_w, name);\n+\n+    for ci in items {\n+      alt ci.node.privacy {\n+        pub {\n+            ebml_w.start_tag(tag_items_class_member); // ???\n+            alt ci.node.decl {\n+               instance_var(nm, _, _, id) {\n+                   #debug(\"encode_info_for_class: doing %s\", nm);\n+                   encode_family(ebml_w, 'g');\n+                   encode_name(ebml_w, nm);\n+                   encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n+                   /* TODO: mutability */\n+                   encode_def_id(ebml_w, local_def(id));\n+               }\n+               class_method(it) {\n+                   encode_family(ebml_w, 'h');\n+                   encode_name(ebml_w, it.ident);\n+                   alt it.node {\n+                      item_fn(fdecl, tps, _) {\n+                          encode_info_for_fn(ecx, ebml_w, it.id, it.ident,\n+                                             path, none, tps, fdecl);\n+                      }\n+                      _ { fail; /* TODO */ }\n+                   }\n+               }\n+            }\n+            ebml_w.end_tag();\n+        }\n+        priv {\n+            /* don't export it, then! */\n+        }\n+      }\n+    }\n+}\n+\n+fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+                      id: node_id, ident: ident, path: ast_map::path,\n+                      item: option<@item>, tps: [ty_param], decl: fn_decl) {\n+        ebml_w.start_tag(tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(id));\n+        encode_family(ebml_w, purity_fn_family(decl.purity));\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n+        let its_ty = node_id_to_type(ecx.ccx.tcx, id);\n+        #debug(\"fn name = %s ty = %s\", ident,\n+               util::ppaux::ty_to_str(ecx.ccx.tcx, its_ty));\n+        encode_type(ecx, ebml_w, its_ty);\n+        encode_path(ebml_w, path, ast_map::path_name(ident));\n+        alt item {\n+           some(it) {\n+             astencode::encode_inlined_item(ecx, ebml_w, path, ii_item(it));\n+           }\n+           none {\n+             encode_symbol(ecx, ebml_w, id);\n+           }\n+        }\n+        ebml_w.end_tag();\n+}\n+\n fn purity_fn_family(p: purity) -> char {\n     alt p {\n       unsafe_fn { 'u' }\n@@ -404,8 +500,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n                                  path, index, tps);\n       }\n-      item_class(_,_,_) {\n-          fail \"encode: implement item_class\";\n+      item_class(tps,items,_) {\n+          /* We're not forgetting about the ctor here! It gets\n+           encoded elsewhere */\n+          ebml_w.start_tag(tag_items_data_item);\n+         encode_info_for_class(ecx, ebml_w, item.id, path, item.ident,\n+                               tps, items);\n+         ebml_w.end_tag();\n       }\n       item_res(_, tps, _, _, ctor_id) {\n         let fn_ty = node_id_to_type(tcx, ctor_id);\n@@ -539,6 +640,21 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n               ast_map::node_item(_, pt) {\n                 encode_info_for_item(ecx, ebml_w, i, index, *pt);\n               }\n+          /* TODO: encode info for class items! */\n+          /* encode ctor, then encode items */\n+          ast_map::node_ctor(i, path) {\n+            alt i.node {\n+               item_class(tps, _, ctor) {\n+                   #debug(\"class, encoding a fn: %d\", ctor.node.id);\n+                   /* this is assuming that ctors aren't inlined...\n+                      probably shouldn't assume that */\n+                   encode_info_for_fn(ecx, ebml_w, ctor.node.id, i.ident,\n+                                      *path, none, tps, ctor.node.dec)\n+               }\n+               _ { /* TODO: should handle item_res, probably */ }\n+            }\n+          }\n+\n             }\n         },\n         visit_native_item: {|ni, cx, v|"}, {"sha": "9b2a87d9e18bac6d6fee1ca827435f01e9c1e0be", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -7,7 +7,7 @@ import syntax::ast_util::respan;\n import middle::ty;\n import std::map::hashmap;\n \n-export parse_ty_data, parse_def_id;\n+export parse_ty_data, parse_def_id, parse_ident;\n export parse_bounds_data;\n \n // Compact string representation for ty::t values. API ty_str &\n@@ -303,6 +303,17 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         ty::mk_with_id(st.tcx, inner, def)\n       }\n       'B' { ty::mk_opaque_box(st.tcx) }\n+      'a' {\n+          #debug(\"saw a class\");\n+          assert (next(st) == '[');\n+          #debug(\"saw a [\");\n+          let did = parse_def(st, conv);\n+          #debug(\"parsed a def_id %?\", did);\n+          let params: [ty::t] = [];\n+          while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n+          assert (next(st) == ']');\n+          ret ty::mk_class(st.tcx, did, params);\n+      }\n       c { #error(\"unexpected char in type string: %c\", c); fail;}\n     }\n }\n@@ -387,8 +398,18 @@ fn parse_def_id(buf: [u8]) -> ast::def_id {\n     for b: u8 in crate_part { crate_part_vec += [b]; }\n     for b: u8 in def_part { def_part_vec += [b]; }\n \n-    let crate_num = option::get(uint::parse_buf(crate_part_vec, 10u)) as int;\n-    let def_num = option::get(uint::parse_buf(def_part_vec, 10u)) as int;\n+    let crate_num = alt uint::parse_buf(crate_part_vec, 10u) {\n+       some(cn) { cn as int }\n+       none { fail (#fmt(\"internal error: parse_def_id: error parsing %? \\\n+                         as crate\",\n+                         crate_part_vec)); }\n+    };\n+    let def_num = alt uint::parse_buf(def_part_vec, 10u) {\n+       some(dn) { dn as int }\n+       none { fail (#fmt(\"internal error: parse_def_id: error parsing %? \\\n+                         as id\",\n+                         def_part_vec)); }\n+    };\n     ret {crate: crate_num, node: def_num};\n }\n "}, {"sha": "7e16129846caef776a3ffecfbea3094c26d3a9e7", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -214,10 +214,15 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       }\n       ty::ty_opaque_box { w.write_char('B'); }\n       ty::ty_class(def, tys) {\n-          w.write_str(\"c[\");\n-          w.write_str(cx.ds(def));\n-          w.write_char('|');\n+          #debug(\"~~~~ %s\", \"a[\");\n+          w.write_str(\"a[\");\n+          let s = cx.ds(def);\n+          #debug(\"~~~~ %s\", s);\n+          w.write_str(s);\n+          #debug(\"~~~~ %s\", \"|\");\n+          w.write_str(\"|\");\n           for t: ty::t in tys { enc_ty(w, cx, t); }\n+          #debug(\"~~~~ %s\", \"]\");\n           w.write_char(']');\n       }\n     }"}, {"sha": "1b2dbaf9d58d0f55edb1bf7aa9454616b3952b8a", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -35,7 +35,7 @@ enum ast_node {\n     // order they are introduced.\n     node_arg(arg, uint),\n     node_local(uint),\n-    node_ctor(@item),\n+    node_ctor(@item, @path),\n     node_block(blk),\n }\n \n@@ -154,7 +154,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         }\n       }\n       item_res(_, _, _, dtor_id, ctor_id) {\n-        cx.map.insert(ctor_id, node_ctor(i));\n+        cx.map.insert(ctor_id, node_ctor(i, item_path));\n         cx.map.insert(dtor_id, node_item(i, item_path));\n       }\n       item_enum(vs, _) {\n@@ -173,7 +173,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         }\n       }\n       item_class(_, _, ctor) {\n-        cx.map.insert(ctor.node.id, node_ctor(i));\n+          cx.map.insert(ctor.node.id, node_ctor(i, item_path));\n       }\n       _ { }\n     }"}, {"sha": "b6a581728193c9e678ea43d273a8bfb91bcc8369", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -304,7 +304,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n         }\n     }\n \n-    // Note: a glob export works as an implict import, along with a\n+    // Note: a glob export works as an implicit import, along with a\n     // re-export of anything that was exported at the glob-target location.\n     // So we wind up reusing the glob-import machinery when looking at\n     // glob exports. They just do re-exporting in a later step."}, {"sha": "bcae9a03b29d058685ead25ed46cf5a0643f6028", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -1886,7 +1886,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n              must_cast: true,\n              intrinsic: abi == ast::native_abi_rust_intrinsic};\n       }\n-      ast_map::node_ctor(i) {\n+      ast_map::node_ctor(i, _) {\n         alt check ccx.tcx.items.get(i.id) {\n           ast_map::node_item(i, pt) { (pt, i.ident) }\n         }\n@@ -1926,7 +1926,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n         trans_fn(ccx, pt, mth.decl, mth.body, lldecl,\n                  impl_self(selfty), psubsts, fn_id.node, none);\n       }\n-      ast_map::node_ctor(i) {\n+      ast_map::node_ctor(i, _) {\n         alt check i.node {\n           ast::item_res(decl, _, _, _, _) {\n             set_inline_hint(lldecl);\n@@ -4378,7 +4378,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n           ast_map::node_native_item(ni, _, pth) {\n             native::decl_native_fn(ccx, ni, *pth + [path_name(ni.ident)])\n           }\n-          ast_map::node_ctor(i) {\n+          ast_map::node_ctor(i, _) {\n             alt check i.node {\n               ast::item_res(_, _, _, _, _) {\n                 let my_path = item_path(ccx, i);"}, {"sha": "38ca61230e3dff95f010a11ffbe98e30642bb38b", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -746,7 +746,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n       ast_map::node_method(method, _, _) {\n           (method.ident, method.decl.output, method.id)\n       }\n-      ast_map::node_ctor(item) {\n+      ast_map::node_ctor(item, _) {\n         alt item.node {\n             ast::item_res(decl, _, _, _, ctor_id) {\n               (item.ident, decl.output, ctor_id)"}, {"sha": "77cf5e578d4fef36bf3b38ed09e62bb1f60d7df3", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -83,13 +83,12 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_constr(subt,_) { type_of(cx, subt) }\n       ty::ty_class(did, _) {\n         let tys: [TypeRef] = [];\n-        // TODO: only handles local classes\n-        let cls_items = lookup_class_items(cx.tcx, did);\n+        let cls_items = lookup_class_item_tys(cx.tcx, did);\n         for ci in cls_items {\n             // only instance vars are record fields at runtime\n-            alt ci.node.decl {\n-                ast::instance_var(_,_,_,_) {\n-                  let fty = type_of(cx, class_item_type(cx.tcx, ci));\n+            alt ci.contents {\n+                var_ty(t) {\n+                  let fty = type_of(cx, t);\n                   tys += [fty];\n                 }\n                 _ {}"}, {"sha": "99ccdeeb70e441b2ded8658db5a63376c6ae0115", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -67,7 +67,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       ast_map::node_method(@{body, _}, _, _) {\n         handle_body(cx, body);\n       }\n-      ast_map::node_ctor(@{node: item_res(_, _, _, _, _), _}) |\n+      ast_map::node_ctor(@{node: item_res(_, _, _, _, _), _},_) |\n       ast_map::node_variant(_, _, _) {\n         uint::range(0u, n_tps) {|n| cx.uses[n] |= use_repr;}\n       }\n@@ -76,7 +76,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n             uint::range(0u, n_tps) {|n| cx.uses[n] |= use_tydesc;}\n         }\n       }\n-      ast_map::node_ctor(@{node: item_class(_, _, ctor), _}) {\n+      ast_map::node_ctor(@{node: item_class(_, _, ctor), _}, _) {\n         ccx.sess.unimpl(\"type uses in class constructor\");\n       }\n     }"}, {"sha": "8cb2b0f50fc4e58c40ed16ac8d7f8b73b757aa75", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 69, "deletions": 33, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -20,7 +20,8 @@ export arg;\n export args_eq;\n export ast_constr_to_constr;\n export block_ty;\n-export class_item_type;\n+export class_contents_ty;\n+export class_item_ty;\n export class_items_as_fields;\n export constr;\n export constr_general;\n@@ -40,7 +41,7 @@ export fm_general, fm_rptr;\n export get_element_type;\n export is_binopable;\n export is_pred_ty;\n-export lookup_class_items;\n+export lookup_class_item_tys;\n export lookup_item_type;\n export method;\n export method_idx;\n@@ -157,6 +158,16 @@ type constr_table = hashmap<ast::node_id, [constr]>;\n \n type mt = {ty: t, mutbl: ast::mutability};\n \n+type class_item_ty = {\n+  ident: ident,\n+  id: node_id,\n+  contents: class_contents_ty\n+};\n+\n+enum class_contents_ty {\n+  var_ty(t),   // FIXME: need mutability, too\n+  method_ty(fn_decl)\n+}\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n@@ -2331,8 +2342,8 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n             vec::init(*path) + [ast_map::path_name(variant.node.name)]\n           }\n \n-          ast_map::node_ctor(i) {\n-            item_path(cx, ast_util::local_def(i.id))\n+          ast_map::node_ctor(i, path) {\n+              *path + [ast_map::path_name(i.ident)]\n           }\n \n           ast_map::node_expr(_) | ast_map::node_arg(_, _) |\n@@ -2406,9 +2417,13 @@ fn enum_variant_with_id(cx: ctxt, enum_id: ast::def_id,\n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n+    /*\n+      Are we putting class ids in the tcache (where does that happen?)\n+     */\n     alt cx.tcache.find(did) {\n       some(tpt) { ret tpt; }\n       none {\n+          #debug(\"lookup_item_type: looking up %?\", did);\n         // The item is in this crate. The caller should have added it to the\n         // type cache already\n         assert did.crate != ast::local_crate;\n@@ -2419,54 +2434,75 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n     }\n }\n \n-// Look up the list of items for a given class (in the item map).\n+// Look up the list of item types for a given class\n // Fails if the id is not bound to a class.\n-fn lookup_class_items(cx: ctxt, did: ast::def_id) -> [@class_item] {\n+fn lookup_class_item_tys(cx: ctxt, did: ast::def_id) -> [@class_item_ty] {\n+    /*\n+      TODO: Check whether this is a local id or not; use csearch / tcache\n+      if it's external\n+     */\n+    if did.crate == ast::local_crate {\n     alt cx.items.find(did.node) {\n        some(ast_map::node_item(i,_)) {\n-           alt i.node {\n-              ast::item_class(_, items, _) {\n-                  items\n-              }\n-              _ { cx.sess.bug(\"class ID bound to non-class\"); }\n+         alt i.node {\n+           ast::item_class(_, items, _) {\n+               class_item_tys(cx, items)\n            }\n+           _ { cx.sess.bug(\"class ID bound to non-class\"); }\n+         }\n        }\n        _ { cx.sess.bug(\"class ID not bound to an item\"); }\n     }\n+        }\n+    else {\n+        ret csearch::get_class_items(cx, did);\n+    }\n+}\n+\n+// must be called after typechecking?\n+fn class_item_tys(cx: ctxt, items: [@class_item]) -> [@class_item_ty] {\n+    let rslt = [];\n+    for it in items {\n+       alt it.node.decl {\n+          instance_var(nm, _, _, id) {\n+              rslt += [@{ident: nm, id: id,\n+                        contents: var_ty(node_id_to_type(cx, id)) }];\n+          }\n+          class_method(it) {\n+              alt it.node {\n+                 item_fn(dec, _, _) {\n+                     rslt += [@{ident: it.ident, id: it.id,\n+                                 contents: method_ty(dec)}];\n+                 }\n+                 _ { fail; /* TODO */ }\n+               }\n+          }\n+       }\n+    }\n+    rslt\n }\n \n // Return a list of fields corresponding to the class's items\n // (as if the class was a record). trans uses this\n fn class_items_as_fields(cx:ctxt, did: ast::def_id) -> [field] {\n     let rslt = [];\n-    for ci in lookup_class_items(cx, did) {\n-       rslt += [alt ci.node.decl {\n-         instance_var(i, _, _, id) {\n+    for ci in lookup_class_item_tys(cx, did) {\n+       alt ci.contents {\n+          var_ty(t) {\n              // consider all instance vars mutable, because the\n              // constructor may mutate all vars\n-             {ident: i, mt: {ty: node_id_to_type(cx, id),\n-                         mutbl: m_mutbl}}\n-         }\n-         class_method(it) {\n-             {ident:it.ident, mt: {ty: node_id_to_type(cx, it.id),\n-                               mutbl: m_const}}\n-         }\n-       }];\n+             rslt += [{ident: ci.ident, mt: {ty: t,\n+                             mutbl: m_mutbl}}];\n+          }\n+         /* do nothing, since methods don't have a runtime\n+          representation? */\n+          method_ty(_) {\n+          }\n+       }\n     }\n     rslt\n }\n \n-// Looks up the type for a given class item. Must be called\n-// post-typechecking.\n-fn class_item_type(cx: ctxt, ci: @ast::class_item) -> t {\n-    alt ci.node.decl {\n-       ast::instance_var(_,_,_,id) { node_id_to_type(cx, id) }\n-       // TODO: only works for local classes\n-       ast::class_method(it) { lookup_item_type(cx,\n-                                 ast_util::local_def(it.id)).ty }\n-    }\n-}\n-\n fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     const tycat_other: int = 0;\n     const tycat_bool: int = 1;"}, {"sha": "1754625d5c90e979d82fd97382e698fc7a611338", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 33, "deletions": 48, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -11,7 +11,7 @@ import pat_util::*;\n import middle::ty;\n import middle::ty::{node_id_to_type, arg, block_ty,\n                     expr_ty, field, node_type_table, mk_nil,\n-                    ty_param_bounds_and_ty, lookup_class_items};\n+                    ty_param_bounds_and_ty, lookup_class_item_tys};\n import util::ppaux::ty_to_str;\n import std::smallintmap;\n import std::map::{hashmap, int_hash};\n@@ -419,29 +419,29 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                   }\n                 }\n               }\n-              ast::def_class(class_id) {\n-                  alt tcx.items.find(class_id.node) {\n-                     some(ast_map::node_item(\n-                      @{node: ast::item_class(tps, _, _), _}, _)) {\n-                         if vec::len(tps) != vec::len(path.node.types) {\n-                            tcx.sess.span_err(ast_ty.span, \"incorrect number \\\n-                               of type parameters to object type\");\n-                         }\n-                         ty::mk_class(tcx, class_id,\n-                                      vec::map(path.node.types, {|ast_ty|\n-                                                    do_ast_ty_to_ty(tcx,\n-                                                                    use_site,\n-                                                                    mode,\n-                                                                    ast_ty)\n-                                               }))\n-                     }\n-                     _ {\n-                         tcx.sess.span_bug(ast_ty.span, \"class id is unbound \\\n-                           in items\");\n+             ast::def_class(class_id) {\n+              if class_id.crate == ast::local_crate {\n+                 alt tcx.items.find(class_id.node) {\n+                   some(ast_map::node_item(\n+                     @{node: ast::item_class(tps, _, _), _}, _)) {\n+                        if vec::len(tps) != vec::len(path.node.types) {\n+                          tcx.sess.span_err(ast_ty.span, \"incorrect number \\\n+                            of type parameters to object type\");\n+                        }\n+                        ty::mk_class(tcx, class_id, vec::map(path.node.types,\n+                          {|ast_ty| ast_ty_to_ty(tcx, mode, ast_ty)}))\n                      }\n-                  }\n+                   _ {\n+                      tcx.sess.span_bug(ast_ty.span, #fmt(\"class id is \\\n+                        unbound in items\"));\n+                   }\n+                }\n               }\n-              _ {\n+              else {\n+                  getter(tcx, use_site, mode, class_id).ty\n+              }\n+             }\n+             _ {\n                 tcx.sess.span_fatal(ast_ty.span,\n                                     \"found type name used as a variable\");\n               }\n@@ -1003,18 +1003,15 @@ mod collect {\n           }\n           ast::item_class(tps, members, ctor) {\n               // Write the class type\n-              let {bounds,params} = mk_ty_params(tcx, tps);\n-              let class_ty = ty::mk_class(tcx, local_def(it.id), params);\n-              let tpt = {bounds: bounds, ty: class_ty};\n-              tcx.tcache.insert(local_def(it.id), tpt);\n-              write_ty(tcx, it.id, class_ty);\n+              let tpt = ty_of_item(tcx, m_collect, it);\n+              write_ty(tcx, it.id, tpt.ty);\n               // Write the ctor type\n               let t_ctor = ty::mk_fn(tcx,\n                                      ty_of_fn_decl(tcx, m_collect,\n                                              ast::proto_any, ctor.node.dec));\n               write_ty(tcx, ctor.node.id, t_ctor);\n               tcx.tcache.insert(local_def(ctor.node.id),\n-                                   {bounds: bounds, ty: t_ctor});\n+                                   {bounds: tpt.bounds, ty: t_ctor});\n               /* FIXME: check for proper public/privateness */\n               // Write the type of each of the members\n               for m in members {\n@@ -1941,25 +1938,16 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n     result\n }\n \n-fn lookup_field_ty(cx: ty::ctxt, items:[@ast::class_item],\n+// problem -- class_item_ty should really be only used for internal stuff.\n+// or should have a privacy field.\n+fn lookup_field_ty(cx: ty::ctxt, items:[@ty::class_item_ty],\n                    fieldname: ast::ident, sp: span)\n     -> ty::t {\n     for item in items {\n-      // this is an access outside the class, so accessing a private\n-      // field is an error\n-        alt item.node.decl {\n-          ast::instance_var(declname, t, _, _) if declname == fieldname {\n-             alt item.node.privacy {\n-                ast::priv {\n-                    cx.sess.span_fatal(sp, \"accessed private field outside \\\n-                       its enclosing class\");\n-                }\n-                ast::pub {\n-                    ret ast_ty_to_ty(cx, m_check, t);\n-                }\n-             }\n-          }\n-          _ { /* do nothing */ }\n+            #debug(\"%s $$$ %s\", fieldname, item.ident);\n+        alt item.contents {\n+          ty::var_ty(t) if item.ident == fieldname { ret t; }\n+          _ { }\n         }\n     }\n     cx.sess.span_fatal(sp, #fmt(\"unbound field %s\", fieldname));\n@@ -2763,10 +2751,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           ty::ty_class(base_id, _params) {\n               // (1) verify that the class id actually has a field called\n               // field\n-              // For now, this code assumes the class is defined in the local\n-              // crate\n-              // FIXME: handle field references to classes in external crate\n-              let cls_items = lookup_class_items(tcx, base_id);\n+              let cls_items = lookup_class_item_tys(tcx, base_id);\n               let field_ty = lookup_field_ty(fcx.ccx.tcx, cls_items, field,\n                                              expr.span);\n               // (2) look up what field's type is, and return it"}, {"sha": "a3984503fae5e02d8176ad0a60e959d525cd76f1", "filename": "src/test/auxiliary/cci_class.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Ftest%2Fauxiliary%2Fcci_class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Ftest%2Fauxiliary%2Fcci_class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -0,0 +1,13 @@\n+mod kitties {\n+\n+class cat {\n+  priv {\n+    let mutable meows : uint;\n+  }\n+\n+  let how_hungry : int;\n+\n+  new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n+}\n+\n+}"}, {"sha": "6bfe96186d8440ad9b4b6d32d184882967c7357c", "filename": "src/test/run-pass/classes-simple-cross-crate.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Ftest%2Frun-pass%2Fclasses-simple-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Ftest%2Frun-pass%2Fclasses-simple-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple-cross-crate.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -0,0 +1,12 @@\n+// xfail-test\n+// xfail-fast\n+// aux-build:cci_class.rs\n+use cci_class;\n+import cci_class::kitties::*;\n+\n+fn main() {\n+  let nyan : cat = cat(52u, 99);\n+  let kitty = cat(1000u, 2);\n+  assert(nyan.how_hungry == 99);\n+  assert(kitty.how_hungry == 2);\n+}"}, {"sha": "5d2eaf9d37e55d4fe7d8fdb21627c3e2f931ad99", "filename": "src/test/run-pass/classes-simple-method.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1680ccce1ed1b89bc746c6c764173e8f0b233ca6/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs?ref=1680ccce1ed1b89bc746c6c764173e8f0b233ca6", "patch": "@@ -0,0 +1,19 @@\n+// xfail-test\n+class cat {\n+  priv {\n+    let mutable meows : uint;\n+  }\n+\n+  let how_hungry : int;\n+\n+  new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n+\n+  fn speak() { fail; }\n+}\n+\n+fn main() {\n+  let nyan : cat = cat(52u, 99);\n+  let kitty = cat(1000u, 2);\n+  assert(nyan.how_hungry == 99);\n+  assert(kitty.how_hungry == 2);\n+}"}]}