{"sha": "45bdff01b2dd7232638b135b188226540b5e79ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1YmRmZjAxYjJkZDcyMzI2MzhiMTM1YjE4ODIyNjU0MGI1ZTc5ZWM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-13T11:09:58Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-13T11:23:32Z"}, "message": "Clean up copy bookkeeping in alias.rs", "tree": {"sha": "1937d3c6cbb986ae578cbf57f7584e0d4b432b36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1937d3c6cbb986ae578cbf57f7584e0d4b432b36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45bdff01b2dd7232638b135b188226540b5e79ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45bdff01b2dd7232638b135b188226540b5e79ec", "html_url": "https://github.com/rust-lang/rust/commit/45bdff01b2dd7232638b135b188226540b5e79ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45bdff01b2dd7232638b135b188226540b5e79ec/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f402343c9327ba3f3f442b26ccb58cd0e3a09e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f402343c9327ba3f3f442b26ccb58cd0e3a09e4", "html_url": "https://github.com/rust-lang/rust/commit/2f402343c9327ba3f3f442b26ccb58cd0e3a09e4"}], "stats": {"total": 70, "additions": 34, "deletions": 36}, "files": [{"sha": "7e6231a4647ea5e930c9f71cf2c27d7f28f3fba1", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/45bdff01b2dd7232638b135b188226540b5e79ec/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45bdff01b2dd7232638b135b188226540b5e79ec/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=45bdff01b2dd7232638b135b188226540b5e79ec", "patch": "@@ -13,18 +13,17 @@ import std::option::{some, none, is_none};\n // whether aliases are used in a safe way.\n \n tag valid { valid; overwritten(span, ast::path); val_taken(span, ast::path); }\n-\n-type restrict =\n-    @{root_var: option::t<node_id>,\n-      node_id: node_id,\n-      ty: ty::t,\n-      span: span,\n-      local_id: uint,\n-      bindings: [node_id],\n-      unsafe_tys: [ty::t],\n-      depends_on: [uint],\n-      mutable ok: valid,\n-      mutable given_up: bool};\n+tag copied { not_allowed; copied; not_copied; }\n+\n+type restrict = @{root_var: option::t<node_id>,\n+                  node_id: node_id,\n+                  span: span,\n+                  local_id: uint,\n+                  binding: option::t<node_id>,\n+                  unsafe_tys: [ty::t],\n+                  depends_on: [uint],\n+                  mutable ok: valid,\n+                  mutable copied: copied};\n \n type scope = @[restrict];\n \n@@ -143,19 +142,19 @@ fn visit_decl(cx: @ctx, d: @ast::decl, sc: scope, v: vt<scope>) {\n }\n \n fn cant_copy(cx: ctx, r: restrict) -> bool {\n-    if r.given_up { ret false; }\n-    // FIXME alt contexts copying not supported yet\n-    if r.node_id == 0 { ret true; }\n-\n-    // FIXME warn when copy is expensive\n-    if ty::type_allows_implicit_copy(cx.tcx, r.ty) {\n-        r.given_up = true;\n+    alt r.copied {\n+      not_allowed. { ret true; }\n+      copied. { ret false; }\n+      not_copied. {}\n+    }\n+    let ty = ty::node_id_to_type(cx.tcx, r.node_id);\n+    if ty::type_allows_implicit_copy(cx.tcx, ty) {\n+        r.copied = copied;\n         cx.copy_map.insert(r.node_id, ());\n-        if copy_is_expensive(cx.tcx, r.ty) {\n-            // FIXME better message\n+        if copy_is_expensive(cx.tcx, ty) {\n             cx.tcx.sess.span_warn(r.span,\n                                   \"inserting an implicit copy for type \" +\n-                                  util::ppaux::ty_to_str(cx.tcx, r.ty));\n+                                  util::ppaux::ty_to_str(cx.tcx, ty));\n         }\n         ret false;\n     } else { ret true; }\n@@ -182,16 +181,18 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr], sc: scope) ->\n         }\n         let root_var = path_def_id(cx, root.ex);\n         restricts += [@{root_var: root_var,\n-                        // FIXME kludge\n-                        node_id: arg_t.mode == ast::by_mut_ref ? 0 : arg.id,\n-                        ty: arg_t.ty,\n+                        node_id: arg.id,\n                         span: arg.span,\n                         local_id: cx.next_local,\n-                        bindings: [arg.id],\n+                        binding: none::<node_id>,\n                         unsafe_tys: inner_mut(root.ds),\n                         depends_on: deps(sc, root_var),\n                         mutable ok: valid,\n-                        mutable given_up: arg_t.mode == ast::by_move}];\n+                        mutable copied: alt arg_t.mode {\n+                          ast::by_move. { copied }\n+                          ast::by_ref. { not_copied }\n+                          ast::by_mut_ref. { not_allowed }\n+                        }}];\n         i += 1u;\n     }\n     let f_may_close =\n@@ -261,7 +262,6 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n     v.visit_expr(input, sc, v);\n     let root = expr_root(cx.tcx, input, true);\n     for a: ast::arm in arms {\n-        // FIXME handle other | patterns\n         let new_sc = *sc;\n         let root_var = path_def_id(cx, root.ex);\n         let pat_id_map = ast_util::pat_id_map(a.pats[0]);\n@@ -286,14 +286,13 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n         for info in binding_info {\n             new_sc += [@{root_var: root_var,\n                          node_id: info.id,\n-                         ty: ty::node_id_to_type(cx.tcx, info.id),\n                          span: info.span,\n                          local_id: cx.next_local,\n-                         bindings: [info.id],\n+                         binding: some(info.id),\n                          unsafe_tys: info.unsafe,\n                          depends_on: deps(sc, root_var),\n                          mutable ok: valid,\n-                         mutable given_up: false}];\n+                         mutable copied: not_copied}];\n         }\n         register_locals(cx, a.pats[0]);\n         visit::visit_arm(a, @new_sc, v);\n@@ -333,14 +332,13 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n     for proot in *pattern_roots(cx.tcx, ext_ds, local.node.pat) {\n         new_sc += [@{root_var: root_var,\n                      node_id: proot.id,\n-                     ty: ty::node_id_to_type(cx.tcx, proot.id),\n                      span: proot.span,\n                      local_id: cx.next_local,\n-                     bindings: [proot.id],\n+                     binding: some(proot.id),\n                      unsafe_tys: inner_mut(proot.ds),\n                      depends_on: deps(sc, root_var),\n                      mutable ok: valid,\n-                     mutable given_up: false}];\n+                     mutable copied: not_copied}];\n     }\n     register_locals(cx, local.node.pat);\n     visit::visit_block(blk, @new_sc, v);\n@@ -362,7 +360,7 @@ fn check_var(cx: ctx, ex: @ast::expr, p: ast::path, id: ast::node_id,\n                     r.ok = val_taken(ex.span, p);\n                 }\n             }\n-        } else if vec::member(my_defnum, r.bindings) {\n+        } else if r.binding == some(my_defnum) {\n             test_scope(cx, sc, r, p);\n         }\n     }\n@@ -417,7 +415,7 @@ fn deps(sc: scope, root: option::t<node_id>) -> [uint] {\n       some(dn) {\n         let i = 0u;\n         for r: restrict in *sc {\n-            if vec::member(dn, r.bindings) { result += [i]; }\n+            if r.binding == some(dn) { result += [i]; }\n             i += 1u;\n         }\n       }"}]}