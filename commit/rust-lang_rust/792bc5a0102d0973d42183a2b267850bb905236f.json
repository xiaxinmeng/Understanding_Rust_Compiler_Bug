{"sha": "792bc5a0102d0973d42183a2b267850bb905236f", "node_id": "C_kwDOAAsO6NoAKDc5MmJjNWEwMTAyZDA5NzNkNDIxODNhMmIyNjc4NTBiYjkwNTIzNmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-02T09:07:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-02T09:07:31Z"}, "message": "Auto merge of #99977 - BlackHoleFox:cfte-cstr, r=thomcc\n\nAdd validation to const fn CStr creation\n\nImproves upon the existing validation that only worked when building the stdlib from source. `CStr::from_bytes_with_nul_unchecked` now utilizes `const_eval_select` to validate the safety requirements of the function when used as `const FOO: &CStr = CStr::from_bytes_with_nul_unchecked(b\"Foobar\\0\");`.\n\nThis can help catch erroneous code written by accident and, assuming a new enough `rustc` in use, remove the need for boilerplate safety comments for this function in `const` contexts.\n\n~~I think this might need a UI test, but I don't know where to put it. If this is a worth change, a perf run would be nice to make sure the `O(n)` validation isn't too bad. I didn't notice a difference building the stdlib tests locally.~~", "tree": {"sha": "9943fa334b90e05c7664f3e2ee84148af5dd8bb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9943fa334b90e05c7664f3e2ee84148af5dd8bb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/792bc5a0102d0973d42183a2b267850bb905236f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/792bc5a0102d0973d42183a2b267850bb905236f", "html_url": "https://github.com/rust-lang/rust/commit/792bc5a0102d0973d42183a2b267850bb905236f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/792bc5a0102d0973d42183a2b267850bb905236f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca37a45232b41789b31caec9a71714855f66c477", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca37a45232b41789b31caec9a71714855f66c477", "html_url": "https://github.com/rust-lang/rust/commit/ca37a45232b41789b31caec9a71714855f66c477"}, {"sha": "0e54d71e157693226c3c5f67d9755daf885714e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e54d71e157693226c3c5f67d9755daf885714e2", "html_url": "https://github.com/rust-lang/rust/commit/0e54d71e157693226c3c5f67d9755daf885714e2"}], "stats": {"total": 47, "additions": 34, "deletions": 13}, "files": [{"sha": "82e63a7fe1ddb6611cf3dc727136d2d7b235723f", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/792bc5a0102d0973d42183a2b267850bb905236f/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792bc5a0102d0973d42183a2b267850bb905236f/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=792bc5a0102d0973d42183a2b267850bb905236f", "patch": "@@ -2,6 +2,7 @@ use crate::ascii;\n use crate::cmp::Ordering;\n use crate::ffi::c_char;\n use crate::fmt::{self, Write};\n+use crate::intrinsics;\n use crate::ops;\n use crate::slice;\n use crate::slice::memchr;\n@@ -384,21 +385,41 @@ impl CStr {\n     #[must_use]\n     #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n     #[rustc_const_stable(feature = \"const_cstr_unchecked\", since = \"1.59.0\")]\n+    #[rustc_allow_const_fn_unstable(const_eval_select)]\n     pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n-        // We're in a const fn, so this is the best we can do\n-        debug_assert!(!bytes.is_empty() && bytes[bytes.len() - 1] == 0);\n-        // SAFETY: Calling an inner function with the same prerequisites.\n-        unsafe { Self::_from_bytes_with_nul_unchecked(bytes) }\n-    }\n+        fn rt_impl(bytes: &[u8]) -> &CStr {\n+            // Chance at catching some UB at runtime with debug builds.\n+            debug_assert!(!bytes.is_empty() && bytes[bytes.len() - 1] == 0);\n \n-    #[inline]\n-    const unsafe fn _from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n-        // SAFETY: Casting to CStr is safe because its internal representation\n-        // is a [u8] too (safe only inside std).\n-        // Dereferencing the obtained pointer is safe because it comes from a\n-        // reference. Making a reference is then safe because its lifetime\n-        // is bound by the lifetime of the given `bytes`.\n-        unsafe { &*(bytes as *const [u8] as *const CStr) }\n+            // SAFETY: Casting to CStr is safe because its internal representation\n+            // is a [u8] too (safe only inside std).\n+            // Dereferencing the obtained pointer is safe because it comes from a\n+            // reference. Making a reference is then safe because its lifetime\n+            // is bound by the lifetime of the given `bytes`.\n+            unsafe { &*(bytes as *const [u8] as *const CStr) }\n+        }\n+\n+        const fn const_impl(bytes: &[u8]) -> &CStr {\n+            // Saturating so that an empty slice panics in the assert with a good\n+            // message, not here due to underflow.\n+            let mut i = bytes.len().saturating_sub(1);\n+            assert!(!bytes.is_empty() && bytes[i] == 0, \"input was not nul-terminated\");\n+\n+            // Ending null byte exists, skip to the rest.\n+            while i != 0 {\n+                i -= 1;\n+                let byte = bytes[i];\n+                assert!(byte != 0, \"input contained interior nul\");\n+            }\n+\n+            // SAFETY: See `rt_impl` cast.\n+            unsafe { &*(bytes as *const [u8] as *const CStr) }\n+        }\n+\n+        // SAFETY: The const and runtime versions have identical behavior\n+        // unless the safety contract of `from_bytes_with_nul_unchecked` is\n+        // violated, which is UB.\n+        unsafe { intrinsics::const_eval_select((bytes,), const_impl, rt_impl) }\n     }\n \n     /// Returns the inner pointer to this C string."}]}