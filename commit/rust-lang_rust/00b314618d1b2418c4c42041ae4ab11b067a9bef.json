{"sha": "00b314618d1b2418c4c42041ae4ab11b067a9bef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwYjMxNDYxOGQxYjI0MThjNGM0MjA0MWFlNGFiMTFiMDY3YTliZWY=", "commit": {"author": {"name": "Scyptnex", "email": "scyptnex@tzeidn.com", "date": "2015-09-28T23:38:19Z"}, "committer": {"name": "Scyptnex", "email": "scyptnex@tzeidn.com", "date": "2015-09-28T23:38:19Z"}, "message": "Refactoring configuration", "tree": {"sha": "780790b59874aa76b89f6ba38e1bf72352f5cd75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/780790b59874aa76b89f6ba38e1bf72352f5cd75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00b314618d1b2418c4c42041ae4ab11b067a9bef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00b314618d1b2418c4c42041ae4ab11b067a9bef", "html_url": "https://github.com/rust-lang/rust/commit/00b314618d1b2418c4c42041ae4ab11b067a9bef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00b314618d1b2418c4c42041ae4ab11b067a9bef/comments", "author": null, "committer": null, "parents": [{"sha": "10eb21d020016a79e89c137ae5fc24f2a3d59d8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/10eb21d020016a79e89c137ae5fc24f2a3d59d8b", "html_url": "https://github.com/rust-lang/rust/commit/10eb21d020016a79e89c137ae5fc24f2a3d59d8b"}], "stats": {"total": 330, "additions": 164, "deletions": 166}, "files": [{"sha": "01c292948dfdbe4b6a78fec8e9c8c45515ea1b20", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b314618d1b2418c4c42041ae4ab11b067a9bef/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b314618d1b2418c4c42041ae4ab11b067a9bef/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=00b314618d1b2418c4c42041ae4ab11b067a9bef", "patch": "@@ -85,13 +85,7 @@ fn print_usage<S: Into<String>>(reason: S) {\n     println!(\"{}\\n\\r usage: rustfmt [-h Help] [--write-mode=[replace|overwrite|display|diff]] \\\n               <file_name>\",\n              reason.into());\n-\n-    for option in Config::get_docs() {\n-        println!(\"{}, {}, Possible values: {}\",\n-                 option.option_name(),\n-                 option.doc_string(),\n-                 option.variant_names());\n-    }\n+    Config::print_docs();\n }\n \n fn determine_params<I>(args: I) -> Option<(Vec<String>, WriteMode)>"}, {"sha": "3a73867f873bbf785103bbdc15a1fd2076a52d3d", "filename": "src/config.rs", "status": "modified", "additions": 159, "deletions": 148, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/00b314618d1b2418c4c42041ae4ab11b067a9bef/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b314618d1b2418c4c42041ae4ab11b067a9bef/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=00b314618d1b2418c4c42041ae4ab11b067a9bef", "patch": "@@ -11,41 +11,41 @@\n extern crate toml;\n \n use lists::{SeparatorTactic, ListTactic};\n-pub use issues::ReportTactic;\n \n-#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-pub enum NewlineStyle {\n+macro_rules! configuration_option_enum{\n+    ($e:ident: $( $x:ident ),+ $(,)*) => {\n+        #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+        pub enum $e {\n+            $( $x ),+\n+        }\n+\n+        impl_enum_decodable!($e, $( $x ),+);\n+    }\n+}\n+\n+configuration_option_enum! { NewlineStyle:\n     Windows, // \\r\\n\n     Unix, // \\n\n }\n \n-impl_enum_decodable!(NewlineStyle, Windows, Unix);\n-\n-#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-pub enum BraceStyle {\n+configuration_option_enum! { BraceStyle:\n     AlwaysNextLine,\n     PreferSameLine,\n     // Prefer same line except where there is a where clause, in which case force\n     // the brace to the next line.\n     SameLineWhere,\n }\n \n-impl_enum_decodable!(BraceStyle, AlwaysNextLine, PreferSameLine, SameLineWhere);\n-\n // How to indent a function's return type.\n-#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-pub enum ReturnIndent {\n+configuration_option_enum! { ReturnIndent:\n     // Aligned with the arguments\n     WithArgs,\n     // Aligned with the where clause\n     WithWhereClause,\n }\n \n-impl_enum_decodable!(ReturnIndent, WithArgs, WithWhereClause);\n-\n // How to stle a struct literal.\n-#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-pub enum StructLitStyle {\n+configuration_option_enum! { StructLitStyle:\n     // First line on the same line as the opening brace, all lines aligned with\n     // the first line.\n     Visual,\n@@ -54,10 +54,7 @@ pub enum StructLitStyle {\n     // FIXME Maybe we should also have an option to align types.\n }\n \n-impl_enum_decodable!(StructLitStyle, Visual, Block);\n-\n-#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-pub enum BlockIndentStyle {\n+configuration_option_enum! { BlockIndentStyle:\n     // Same level as parent.\n     Inherit,\n     // One level deeper than parent.\n@@ -66,10 +63,7 @@ pub enum BlockIndentStyle {\n     Visual,\n }\n \n-impl_enum_decodable!(BlockIndentStyle, Inherit, Tabbed, Visual);\n-\n-#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-pub enum Density {\n+configuration_option_enum! { Density:\n     // Fit as much on one line as possible.\n     Compressed,\n     // Use more lines.\n@@ -78,8 +72,6 @@ pub enum Density {\n     CompressedIfEmpty,\n }\n \n-impl_enum_decodable!(Density, Compressed, Tall);\n-\n impl Density {\n     pub fn to_list_tactic(self) -> ListTactic {\n         match self {\n@@ -89,17 +81,22 @@ impl Density {\n     }\n }\n \n-#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-pub enum MultilineStyle {\n+configuration_option_enum! { LicensePolicy:\n+    // Do not place license text at top of files\n+    NoLicense,\n+    // Use the text in \"license\" field as the license\n+    TextLicense,\n+    // Use a text file as the license text\n+    FileLicense,\n+}\n+\n+configuration_option_enum! { MultilineStyle:\n     // Use horizontal layout if it fits in one line, fall back to vertical\n     PreferSingle,\n     // Use vertical layout\n     ForceMulti,\n }\n \n-\n-impl_enum_decodable!(MultilineStyle, PreferSingle, ForceMulti);\n-\n impl MultilineStyle {\n     pub fn to_list_tactic(self) -> ListTactic {\n         match self {\n@@ -109,8 +106,63 @@ impl MultilineStyle {\n     }\n }\n \n+configuration_option_enum! { ReportTactic:\n+    Always,\n+    Unnumbered,\n+    Never,\n+}\n+\n+// This trait and the following impl blocks are there so that we an use\n+// UCFS inside the get_docs() function on types for configs.\n+pub trait ConfigType {\n+    fn get_variant_names() -> String;\n+}\n+\n+impl ConfigType for bool {\n+    fn get_variant_names() -> String {\n+        String::from(\"<boolean>\")\n+    }\n+}\n+\n+impl ConfigType for usize {\n+    fn get_variant_names() -> String {\n+        String::from(\"<unsigned integer>\")\n+    }\n+}\n+\n+impl ConfigType for String {\n+    fn get_variant_names() -> String {\n+        String::from(\"<string>\")\n+    }\n+}\n+\n+pub struct ConfigHelpItem {\n+    option_name: &'static str,\n+    doc_string: &'static str,\n+    variant_names: String,\n+    default: &'static str,\n+}\n+\n+impl ConfigHelpItem {\n+    pub fn option_name(&self) -> &'static str {\n+        self.option_name\n+    }\n+\n+    pub fn doc_string(&self) -> &'static str {\n+        self.doc_string\n+    }\n+\n+    pub fn variant_names(&self) -> &String {\n+        &self.variant_names\n+    }\n+\n+    pub fn default(&self) -> &'static str {\n+        self.default\n+    }\n+}\n+\n macro_rules! create_config {\n-    ($($i:ident: $ty:ty, $dstring: tt),+ $(,)*) => (\n+    ($($i:ident: $ty:ty, $def:expr, $( $dstring:expr ),+ );+ $(;)*) => (\n         #[derive(RustcDecodable, Clone)]\n         pub struct Config {\n             $(pub $i: $ty),+\n@@ -126,47 +178,9 @@ macro_rules! create_config {\n             $(pub $i: Option<$ty>),+\n         }\n \n-        // This trait and the following impl blocks are there so that we an use\n-        // UCFS inside the get_docs() function on types for configs.\n-        pub trait ConfigType {\n-            fn get_variant_names() -> String;\n-        }\n-\n-        impl ConfigType for bool {\n-            fn get_variant_names() -> String {\n-                String::from(\"<boolean>\")\n-            }\n-        }\n-\n-        impl ConfigType for usize {\n-            fn get_variant_names() -> String {\n-                String::from(\"<unsigned integer>\")\n-            }\n-        }\n-\n-        pub struct ConfigHelpItem {\n-            option_name: &'static str,\n-            doc_string : &'static str,\n-            variant_names: String,\n-        }\n-\n-        impl ConfigHelpItem {\n-            pub fn option_name(&self) -> &'static str {\n-                self.option_name\n-            }\n-\n-            pub fn doc_string(&self) -> &'static str {\n-                self.doc_string\n-            }\n-\n-            pub fn variant_names(&self) -> &String {\n-                &self.variant_names\n-            }\n-        }\n-\n         impl Config {\n \n-            fn fill_from_parsed_config(mut self, parsed: &ParsedConfig) -> Config {\n+            fn fill_from_parsed_config(mut self, parsed: ParsedConfig) -> Config {\n             $(\n                 if let Some(val) = parsed.$i {\n                     self.$i = val;\n@@ -186,7 +200,7 @@ macro_rules! create_config {\n                         panic!();\n                     }\n                 };\n-                Config::default().fill_from_parsed_config(&parsed_config)\n+                Config::default().fill_from_parsed_config(parsed_config)\n             }\n \n             pub fn override_value(&mut self, key: &str, val: &str) {\n@@ -200,93 +214,90 @@ macro_rules! create_config {\n                 }\n             }\n \n-            pub fn get_docs() -> Vec<ConfigHelpItem> {\n-                let mut options: Vec<ConfigHelpItem> = Vec::new();\n+            pub fn print_docs() {\n+                use std::cmp;\n+                let max = 0;\n+                $( let max = cmp::max(max, stringify!($i).len()+1); )+\n+                let mut space_str = String::with_capacity(max);\n+                for _ in 0..max {\n+                    space_str.push(' ');\n+                }\n+                println!(\"\\nConfiguration Options:\");\n                 $(\n-                    options.push(ConfigHelpItem {\n-                        option_name: stringify!($i),\n-                        doc_string: stringify!($dstring),\n-                        variant_names: <$ty>::get_variant_names(),\n-                    });\n+                    let name_raw = stringify!($i);\n+                    let mut name_out = String::with_capacity(max);\n+                    for _ in name_raw.len()..max-1 {\n+                        name_out.push(' ')\n+                    }\n+                    name_out.push_str(name_raw);\n+                    name_out.push(' ');\n+                    println!(\"{}{} Default: {:?}\",\n+                             name_out,\n+                             <$ty>::get_variant_names(),\n+                             $def);\n+                    $(\n+                        println!(\"{}{}\", space_str, $dstring);\n+                    )+\n+                    println!(\"\");\n                 )+\n-                options\n+            }\n+        }\n+\n+        // Template for the default configuration\n+        impl Default for Config {\n+            fn default() -> Config {\n+                Config {\n+                    $(\n+                        $i: $def,\n+                    )+\n+                }\n             }\n         }\n     )\n }\n \n create_config! {\n-    max_width: usize, \"Maximum width of each line\",\n-    ideal_width: usize, \"Ideal width of each line (only used for comments)\",\n-    tab_spaces: usize, \"Number of spaces per tab\",\n-    fn_call_width: usize, \"Maximum width of the args of a function call\\\n-                           before faling back to vertical formatting\",\n-    struct_lit_width: usize, \"Maximum width in the body of a struct lit\\\n-                              before faling back to vertical formatting\",\n-    newline_style: NewlineStyle, \"Unix or Windows line endings\",\n-    fn_brace_style: BraceStyle, \"Brace style for functions\",\n-    fn_return_indent: ReturnIndent, \"Location of return type in function declaration\",\n-    fn_args_paren_newline: bool, \"If function argument parenthases goes on a newline\",\n-    fn_args_density: Density, \"Argument density in functions\",\n-    fn_args_layout: StructLitStyle, \"Layout of function arguments\",\n-    fn_arg_indent: BlockIndentStyle, \"Indent on function arguments\",\n+    max_width: usize, 100, \"Maximum width of each line\";\n+    ideal_width: usize, 80, \"Ideal width of each line\";\n+    tab_spaces: usize, 4, \"Number of spaces per tab\";\n+    fn_call_width: usize, 50,\n+        \"Maximum width of the args of a function call before faling back to vertical formatting\";\n+    struct_lit_width: usize, 12,\n+        \"Maximum width in the body of a struct lit before faling back to vertical formatting\";\n+    newline_style: NewlineStyle, NewlineStyle::Unix, \"Unix or Windows line endings\";\n+    fn_brace_style: BraceStyle, BraceStyle::SameLineWhere, \"Brace style for functions\";\n+    fn_return_indent: ReturnIndent, ReturnIndent::WithArgs,\n+        \"Location of return type in function declaration\";\n+    fn_args_paren_newline: bool, true, \"If function argument parenthases goes on a newline\";\n+    fn_args_density: Density, Density::Tall, \"Argument density in functions\";\n+    fn_args_layout: StructLitStyle, StructLitStyle::Visual, \"Layout of function arguments\";\n+    fn_arg_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indent on function arguments\";\n     // Should we at least try to put the where clause on the same line as the rest of the\n     // function decl?\n-    where_density: Density, \"Density of a where clause\",\n+    where_density: Density, Density::CompressedIfEmpty, \"Density of a where clause\";\n     // Visual will be treated like Tabbed\n-    where_indent: BlockIndentStyle, \"Indentation of a where clause\",\n-    where_layout: ListTactic, \"Element layout inside a where clause\",\n-    where_pred_indent: BlockIndentStyle, \"Indentation style of a where predicate\",\n-    generics_indent: BlockIndentStyle, \"Indentation of generics\",\n-    struct_trailing_comma: SeparatorTactic, \"If there is a trailing comma on structs\",\n-    struct_lit_trailing_comma: SeparatorTactic, \"If there is a trailing comma on literal structs\",\n-    struct_lit_style: StructLitStyle, \"Style of struct definition\",\n-    struct_lit_multiline_style: MultilineStyle, \"Multilline style on literal structs\",\n-    enum_trailing_comma: bool, \"Put a trailing comma on enum declarations\",\n-    report_todo: ReportTactic, \"Report all occurences of TODO in source file comments\",\n-    report_fixme: ReportTactic, \"Report all occurences of FIXME in source file comments\",\n+    where_indent: BlockIndentStyle, BlockIndentStyle::Tabbed, \"Indentation of a where clause\";\n+    where_layout: ListTactic, ListTactic::Vertical, \"Element layout inside a where clause\";\n+    where_pred_indent: BlockIndentStyle, BlockIndentStyle::Visual,\n+        \"Indentation style of a where predicate\";\n+    generics_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indentation of generics\";\n+    struct_trailing_comma: SeparatorTactic, SeparatorTactic::Vertical,\n+        \"If there is a trailing comma on structs\";\n+    struct_lit_trailing_comma: SeparatorTactic, SeparatorTactic::Vertical,\n+        \"If there is a trailing comma on literal structs\";\n+    struct_lit_style: StructLitStyle, StructLitStyle::Block, \"Style of struct definition\";\n+    struct_lit_multiline_style: MultilineStyle, MultilineStyle::PreferSingle,\n+        \"Multilline style on literal structs\";\n+    enum_trailing_comma: bool, true, \"Put a trailing comma on enum declarations\";\n+    report_todo: ReportTactic, ReportTactic::Always,\n+        \"Report all occurences of TODO in source file comments\";\n+    report_fixme: ReportTactic, ReportTactic::Never,\n+        \"Report all occurences of FIXME in source file comments\";\n     // Alphabetically, case sensitive.\n-    reorder_imports: bool, \"Reorder import statements alphabetically\",\n-    single_line_if_else: bool, \"Put else on same line as closing brace for if statements\",\n-    format_strings: bool, \"Format string literals, or leave as is\",\n-    chains_overflow_last: bool, \"Allow last call in method chain to break the line\",\n-    take_source_hints: bool, \"Retain some formatting characteristics from the source code\",\n-    hard_tabs: bool, \"Use tab characters for indentation, spaces for alignment\",\n-}\n-\n-impl Default for Config {\n-    fn default() -> Config {\n-        Config {\n-            max_width: 100,\n-            ideal_width: 80,\n-            tab_spaces: 4,\n-            fn_call_width: 50,\n-            struct_lit_width: 12,\n-            newline_style: NewlineStyle::Unix,\n-            fn_brace_style: BraceStyle::SameLineWhere,\n-            fn_return_indent: ReturnIndent::WithArgs,\n-            fn_args_paren_newline: true,\n-            fn_args_density: Density::Tall,\n-            fn_args_layout: StructLitStyle::Visual,\n-            fn_arg_indent: BlockIndentStyle::Visual,\n-            where_density: Density::CompressedIfEmpty,\n-            where_indent: BlockIndentStyle::Tabbed,\n-            where_layout: ListTactic::Vertical,\n-            where_pred_indent: BlockIndentStyle::Visual,\n-            generics_indent: BlockIndentStyle::Visual,\n-            struct_trailing_comma: SeparatorTactic::Vertical,\n-            struct_lit_trailing_comma: SeparatorTactic::Vertical,\n-            struct_lit_style: StructLitStyle::Block,\n-            struct_lit_multiline_style: MultilineStyle::PreferSingle,\n-            enum_trailing_comma: true,\n-            report_todo: ReportTactic::Always,\n-            report_fixme: ReportTactic::Never,\n-            reorder_imports: false,\n-            single_line_if_else: false,\n-            format_strings: true,\n-            chains_overflow_last: true,\n-            take_source_hints: true,\n-            hard_tabs: false,\n-        }\n-    }\n+    reorder_imports: bool, false, \"Reorder import statements alphabetically\";\n+    single_line_if_else: bool, false, \"Put else on same line as closing brace for if statements\";\n+    format_strings: bool, true, \"Format string literals, or leave as is\";\n+    chains_overflow_last: bool, true, \"Allow last call in method chain to break the line\";\n+    take_source_hints: bool, true, \"Retain some formatting characteristics from the source code\";\n+    hard_tabs: bool, false, \"Use tab characters for indentation, spaces for alignment\";\n }"}, {"sha": "6f64436bb52709bfb6f0c5dcefbdceead0f6ab7f", "filename": "src/issues.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00b314618d1b2418c4c42041ae4ab11b067a9bef/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b314618d1b2418c4c42041ae4ab11b067a9bef/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=00b314618d1b2418c4c42041ae4ab11b067a9bef", "patch": "@@ -13,17 +13,13 @@\n // associated issue number.\n \n use std::fmt;\n+pub use config::ReportTactic;\n \n static TO_DO_CHARS: &'static [char] = &['T', 'O', 'D', 'O'];\n static FIX_ME_CHARS: &'static [char] = &['F', 'I', 'X', 'M', 'E'];\n \n-#[derive(Clone, Copy)]\n-pub enum ReportTactic {\n-    Always,\n-    Unnumbered,\n-    Never,\n-}\n-\n+// Enabled implementation detail is here because it is\n+// irrelevant outside the issues module\n impl ReportTactic {\n     fn is_enabled(&self) -> bool {\n         match *self {\n@@ -34,8 +30,6 @@ impl ReportTactic {\n     }\n }\n \n-impl_enum_decodable!(ReportTactic, Always, Unnumbered, Never);\n-\n #[derive(Clone, Copy)]\n enum Seeking {\n     Issue {"}, {"sha": "b9da5b04c3b11df8d8032171e7a5ec2ce354b40e", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b314618d1b2418c4c42041ae4ab11b067a9bef/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b314618d1b2418c4c42041ae4ab11b067a9bef/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=00b314618d1b2418c4c42041ae4ab11b067a9bef", "patch": "@@ -160,8 +160,7 @@ macro_rules! impl_enum_decodable {\n                 $(\n                     variants.push(stringify!($x));\n                 )*\n-\n-                variants.join(\", \")\n+                format!(\"[{}]\", variants.join(\"|\"))\n             }\n         }\n     };"}]}