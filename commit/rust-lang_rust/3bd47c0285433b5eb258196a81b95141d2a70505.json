{"sha": "3bd47c0285433b5eb258196a81b95141d2a70505", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiZDQ3YzAyODU0MzNiNWViMjU4MTk2YTgxYjk1MTQxZDJhNzA1MDU=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-25T20:16:02Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-27T16:59:21Z"}, "message": "First attempt at generic type inference for fns", "tree": {"sha": "41bd19f6e95e4c22bd39c35702a1d2e048dd9cef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41bd19f6e95e4c22bd39c35702a1d2e048dd9cef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bd47c0285433b5eb258196a81b95141d2a70505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd47c0285433b5eb258196a81b95141d2a70505", "html_url": "https://github.com/rust-lang/rust/commit/3bd47c0285433b5eb258196a81b95141d2a70505", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bd47c0285433b5eb258196a81b95141d2a70505/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f4f50baaa21cb2d0f6c102f1ca521946071a8dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4f50baaa21cb2d0f6c102f1ca521946071a8dc", "html_url": "https://github.com/rust-lang/rust/commit/3f4f50baaa21cb2d0f6c102f1ca521946071a8dc"}], "stats": {"total": 102, "additions": 81, "deletions": 21}, "files": [{"sha": "82ebb275a756d4ae744ab88630bd003a78de31e3", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bd47c0285433b5eb258196a81b95141d2a70505/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd47c0285433b5eb258196a81b95141d2a70505/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=3bd47c0285433b5eb258196a81b95141d2a70505", "patch": "@@ -388,7 +388,7 @@ pub use crate::code_model_impl::function::ScopeEntryWithSyntax;\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FnSignature {\n     pub(crate) name: Name,\n-    pub(crate) params: Vec<TypeRef>,\n+    pub(crate) args: Vec<TypeRef>,\n     pub(crate) ret_type: TypeRef,\n     /// True if the first param is `self`. This is relevant to decide whether this\n     /// can be called as a method.\n@@ -400,8 +400,8 @@ impl FnSignature {\n         &self.name\n     }\n \n-    pub fn params(&self) -> &[TypeRef] {\n-        &self.params\n+    pub fn args(&self) -> &[TypeRef] {\n+        &self.args\n     }\n \n     pub fn ret_type(&self) -> &TypeRef {"}, {"sha": "b4aa18540e18af005f4f5e695c6c736abe50b624", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bd47c0285433b5eb258196a81b95141d2a70505/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd47c0285433b5eb258196a81b95141d2a70505/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=3bd47c0285433b5eb258196a81b95141d2a70505", "patch": "@@ -32,7 +32,7 @@ impl FnSignature {\n             .name()\n             .map(|n| n.as_name())\n             .unwrap_or_else(Name::missing);\n-        let mut params = Vec::new();\n+        let mut args = Vec::new();\n         let mut has_self_param = false;\n         if let Some(param_list) = node.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n@@ -50,12 +50,12 @@ impl FnSignature {\n                         }\n                     }\n                 };\n-                params.push(self_type);\n+                args.push(self_type);\n                 has_self_param = true;\n             }\n             for param in param_list.params() {\n                 let type_ref = TypeRef::from_ast_opt(param.type_ref());\n-                params.push(type_ref);\n+                args.push(type_ref);\n             }\n         }\n         let ret_type = if let Some(type_ref) = node.ret_type().and_then(|rt| rt.type_ref()) {\n@@ -66,7 +66,7 @@ impl FnSignature {\n \n         let sig = FnSignature {\n             name,\n-            params,\n+            args,\n             ret_type,\n             has_self_param,\n         };"}, {"sha": "a5501d5438818e04fd11e487cdf2702dfb1a26f1", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bd47c0285433b5eb258196a81b95141d2a70505/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd47c0285433b5eb258196a81b95141d2a70505/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=3bd47c0285433b5eb258196a81b95141d2a70505", "patch": "@@ -49,7 +49,8 @@ impl GenericParams {\n         Arc::new(generics)\n     }\n \n-    fn fill(&mut self, node: &impl TypeParamsOwner) {\n+    // FIXME: probably shouldnt be pub(crate)\n+    pub(crate) fn fill(&mut self, node: &impl TypeParamsOwner) {\n         if let Some(params) = node.type_param_list() {\n             self.fill_params(params)\n         }"}, {"sha": "95de916ee18582d1993adde86997c4e30a17f531", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3bd47c0285433b5eb258196a81b95141d2a70505/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd47c0285433b5eb258196a81b95141d2a70505/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=3bd47c0285433b5eb258196a81b95141d2a70505", "patch": "@@ -209,6 +209,18 @@ pub enum Ty {\n     /// `&'a mut T` or `&'a T`.\n     Ref(Arc<Ty>, Mutability),\n \n+    /// The anonymous type of a function declaration/definition. Each\n+    /// function has a unique type, which is output (for a function\n+    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar = foo; // bar: fn() -> i32 {foo}\n+    /// ```\n+    FnDef(Function, Substs),\n+\n     /// A pointer to a function.  Written as `fn() -> i32`.\n     ///\n     /// For example the type of `bar` here:\n@@ -485,7 +497,7 @@ impl Ty {\n                 }\n                 sig_mut.output.walk_mut(f);\n             }\n-            Ty::Adt { substs, .. } => {\n+            Ty::FnDef(_, substs) | Ty::Adt { substs, .. } => {\n                 // Without an Arc::make_mut_slice, we can't avoid the clone here:\n                 let mut v: Vec<_> = substs.0.iter().cloned().collect();\n                 for t in &mut v {\n@@ -524,6 +536,7 @@ impl Ty {\n                 name,\n                 substs,\n             },\n+            Ty::FnDef(func, _) => Ty::FnDef(func, substs),\n             _ => self,\n         }\n     }\n@@ -579,6 +592,7 @@ impl fmt::Display for Ty {\n                         .to_fmt(f)\n                 }\n             }\n+            Ty::FnDef(_func, _substs) => write!(f, \"FNDEF-IMPLEMENT-ME\"),\n             Ty::FnPtr(sig) => {\n                 join(sig.input.iter())\n                     .surround_with(\"fn(\", \")\")\n@@ -608,12 +622,18 @@ impl fmt::Display for Ty {\n /// Compute the declared type of a function. This should not need to look at the\n /// function body.\n fn type_for_fn(db: &impl HirDatabase, f: Function) -> Ty {\n+    let generics = f.generic_params(db);\n+    let substs = make_substs(&generics);\n+    Ty::FnDef(f.into(), substs)\n+}\n+\n+fn get_func_sig(db: &impl HirDatabase, f: Function) -> FnSig {\n     let signature = f.signature(db);\n     let module = f.module(db);\n     let impl_block = f.impl_block(db);\n     let generics = f.generic_params(db);\n     let input = signature\n-        .params()\n+        .args()\n         .iter()\n         .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), &generics, tr))\n         .collect::<Vec<_>>();\n@@ -624,8 +644,7 @@ fn type_for_fn(db: &impl HirDatabase, f: Function) -> Ty {\n         &generics,\n         signature.ret_type(),\n     );\n-    let sig = FnSig { input, output };\n-    Ty::FnPtr(Arc::new(sig))\n+    FnSig { input, output }\n }\n \n fn make_substs(generics: &GenericParams) -> Substs {\n@@ -1142,7 +1161,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n                 (ty, Some(var.into()))\n             }\n-            TypableDef::Enum(_) | TypableDef::Function(_) => (Ty::Unknown, None),\n+            TypableDef::Function(func) => {\n+                let ty = type_for_fn(self.db, func);\n+                let ty = self.insert_type_vars(ty.apply_substs(substs));\n+                // FIXME: is this right?\n+                (ty, None)\n+            }\n+            TypableDef::Enum(_) => (Ty::Unknown, None),\n         }\n     }\n \n@@ -1331,12 +1356,27 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n+                // FIXME: so manu unnecessary clones\n                 let (param_tys, ret_ty) = match &callee_ty {\n-                    Ty::FnPtr(sig) => (&sig.input[..], sig.output.clone()),\n+                    Ty::FnPtr(sig) => (sig.input.clone(), sig.output.clone()),\n+                    Ty::FnDef(func, substs) => {\n+                        let fn_sig = func.signature(self.db);\n+                        // TODO: get input and return types from the fn_sig.\n+                        // it contains typerefs which we can make into proper tys\n+\n+                        let sig = get_func_sig(self.db, *func);\n+                        (\n+                            sig.input\n+                                .iter()\n+                                .map(|ty| ty.clone().subst(&substs))\n+                                .collect(),\n+                            sig.output.clone().subst(&substs),\n+                        )\n+                    }\n                     _ => {\n                         // not callable\n                         // TODO report an error?\n-                        (&[][..], Ty::Unknown)\n+                        (Vec::new(), Ty::Unknown)\n                     }\n                 };\n                 for (i, arg) in args.iter().enumerate() {\n@@ -1604,15 +1644,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn collect_fn_signature(&mut self, signature: &FnSignature) {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        for (type_ref, pat) in signature.params().iter().zip(body.params()) {\n+        for (type_ref, pat) in signature.args().iter().zip(body.params()) {\n             let ty = self.make_ty(type_ref);\n \n             self.infer_pat(*pat, &ty);\n         }\n-        self.return_ty = {\n-            let ty = self.make_ty(signature.ret_type());\n-            ty\n-        };\n+        self.return_ty = self.make_ty(signature.ret_type());\n     }\n \n     fn infer_body(&mut self) {"}, {"sha": "40913b164ab8208be3774de595d27832fdd15a19", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3bd47c0285433b5eb258196a81b95141d2a70505/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd47c0285433b5eb258196a81b95141d2a70505/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=3bd47c0285433b5eb258196a81b95141d2a70505", "patch": "@@ -594,6 +594,28 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_type_param() {\n+    check_inference(\n+        \"generic_fn\",\n+        r#\"\n+fn id<T>(x: T) -> T {\n+    x\n+}\n+\n+fn clone<T>(x: &T) -> T {\n+    x\n+}\n+\n+fn test() {\n+    let y = 10u32;\n+    id(y);\n+    let x: bool = clone(z);\n+}\n+\"#,\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.parse(file_id);"}, {"sha": "6e9a68e40683224e3b8999eb311b880139f24e3a", "filename": "crates/ra_ide_api/src/completion/completion_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bd47c0285433b5eb258196a81b95141d2a70505/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd47c0285433b5eb258196a81b95141d2a70505/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=3bd47c0285433b5eb258196a81b95141d2a70505", "patch": "@@ -240,7 +240,7 @@ impl Builder {\n         if ctx.use_item_syntax.is_none() && !ctx.is_call {\n             tested_by!(inserts_parens_for_function_calls);\n             let sig = function.signature(ctx.db);\n-            if sig.params().is_empty() || sig.has_self_param() && sig.params().len() == 1 {\n+            if sig.args().is_empty() || sig.has_self_param() && sig.args().len() == 1 {\n                 self.insert_text = Some(format!(\"{}()$0\", self.label));\n             } else {\n                 self.insert_text = Some(format!(\"{}($0)\", self.label));"}]}