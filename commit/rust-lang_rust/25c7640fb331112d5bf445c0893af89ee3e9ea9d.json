{"sha": "25c7640fb331112d5bf445c0893af89ee3e9ea9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1Yzc2NDBmYjMzMTExMmQ1YmY0NDVjMDg5M2FmODllZTNlOWVhOWQ=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2020-12-06T05:36:33Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2020-12-14T05:00:02Z"}, "message": "Reenable ops and fix tests", "tree": {"sha": "905d9da82438f380842033bb3266c5c8fbc16455", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/905d9da82438f380842033bb3266c5c8fbc16455"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25c7640fb331112d5bf445c0893af89ee3e9ea9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25c7640fb331112d5bf445c0893af89ee3e9ea9d", "html_url": "https://github.com/rust-lang/rust/commit/25c7640fb331112d5bf445c0893af89ee3e9ea9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25c7640fb331112d5bf445c0893af89ee3e9ea9d/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22576bb6e0080fc8eb00d40168b3b608d3756735", "url": "https://api.github.com/repos/rust-lang/rust/commits/22576bb6e0080fc8eb00d40168b3b608d3756735", "html_url": "https://github.com/rust-lang/rust/commit/22576bb6e0080fc8eb00d40168b3b608d3756735"}], "stats": {"total": 316, "additions": 112, "deletions": 204}, "files": [{"sha": "d23e5ad21ba25e8b179f957d6777697fc58a52e4", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=25c7640fb331112d5bf445c0893af89ee3e9ea9d", "patch": "@@ -8,7 +8,7 @@ mod macros;\n \n mod fmt;\n mod intrinsics;\n-//mod ops;\n+mod ops;\n //mod round;\n \n //pub mod masks;"}, {"sha": "99adb669bc51b2cf4699d85cd81e964cf5b49fad", "filename": "crates/core_simd/src/macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmacros.rs?ref=25c7640fb331112d5bf445c0893af89ee3e9ea9d", "patch": "@@ -295,13 +295,13 @@ macro_rules! impl_float_vector {\n                 unsafe { core::mem::transmute_copy(&bits) }\n             }\n \n-//            /// Produces a vector where every lane has the absolute value of the\n-//            /// equivalently-indexed lane in `self`.\n-//            #[inline]\n-//            pub fn abs(self) -> Self {\n-//                let no_sign = <$bits_ty>::splat(!0 >> 1);\n-//                Self::from_bits(self.to_bits() & no_sign)\n-//            }\n+            /// Produces a vector where every lane has the absolute value of the\n+            /// equivalently-indexed lane in `self`.\n+            #[inline]\n+            pub fn abs(self) -> Self {\n+                let no_sign = crate::$bits_ty::splat(!0 >> 1);\n+                Self::from_bits(self.to_bits() & no_sign)\n+            }\n         }\n     };\n }"}, {"sha": "942d071de44de745893817724f103b7106dfd475", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 99, "deletions": 184, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=25c7640fb331112d5bf445c0893af89ee3e9ea9d", "patch": "@@ -12,21 +12,21 @@ where\n macro_rules! impl_ref_ops {\n     // binary op\n     {\n-        impl core::ops::$trait:ident<$rhs:ty> for $type:ty {\n+        impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty {\n             type Output = $output:ty;\n \n             $(#[$attrs:meta])*\n             fn $fn:ident($self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) -> Self::Output $body:tt\n         }\n     } => {\n-        impl core::ops::$trait<$rhs> for $type {\n+        impl<const $lanes: usize> core::ops::$trait<$rhs> for $type {\n             type Output = $output;\n \n             $(#[$attrs])*\n             fn $fn($self_tok, $rhs_arg: $rhs_arg_ty) -> Self::Output $body\n         }\n \n-        impl core::ops::$trait<&'_ $rhs> for $type {\n+        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n             $(#[$attrs])*\n@@ -35,7 +35,7 @@ macro_rules! impl_ref_ops {\n             }\n         }\n \n-        impl core::ops::$trait<$rhs> for &'_ $type {\n+        impl<const $lanes: usize> core::ops::$trait<$rhs> for &'_ $type {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n             $(#[$attrs])*\n@@ -44,7 +44,7 @@ macro_rules! impl_ref_ops {\n             }\n         }\n \n-        impl core::ops::$trait<&'_ $rhs> for &'_ $type {\n+        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for &'_ $type {\n             type Output = <$type as core::ops::$trait<$rhs>>::Output;\n \n             $(#[$attrs])*\n@@ -56,17 +56,17 @@ macro_rules! impl_ref_ops {\n \n     // binary assignment op\n     {\n-        impl core::ops::$trait:ident<$rhs:ty> for $type:ty {\n+        impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty {\n             $(#[$attrs:meta])*\n             fn $fn:ident(&mut $self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) $body:tt\n         }\n     } => {\n-        impl core::ops::$trait<$rhs> for $type {\n+        impl<const $lanes: usize> core::ops::$trait<$rhs> for $type {\n             $(#[$attrs])*\n             fn $fn(&mut $self_tok, $rhs_arg: $rhs_arg_ty) $body\n         }\n \n-        impl core::ops::$trait<&'_ $rhs> for $type {\n+        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type {\n             $(#[$attrs])*\n             fn $fn(&mut $self_tok, $rhs_arg: &$rhs_arg_ty) {\n                 core::ops::$trait::$fn($self_tok, *$rhs_arg)\n@@ -76,17 +76,17 @@ macro_rules! impl_ref_ops {\n \n     // unary op\n     {\n-        impl core::ops::$trait:ident for $type:ty {\n+        impl<const $lanes:ident: usize> core::ops::$trait:ident for $type:ty {\n             type Output = $output:ty;\n             fn $fn:ident($self_tok:ident) -> Self::Output $body:tt\n         }\n     } => {\n-        impl core::ops::$trait for $type {\n+        impl<const $lanes: usize> core::ops::$trait for $type {\n             type Output = $output;\n             fn $fn($self_tok) -> Self::Output $body\n         }\n \n-        impl core::ops::$trait for &'_ $type {\n+        impl<const $lanes: usize> core::ops::$trait for &'_ $type {\n             type Output = <$type as core::ops::$trait>::Output;\n             fn $fn($self_tok) -> Self::Output {\n                 core::ops::$trait::$fn(*$self_tok)\n@@ -95,152 +95,76 @@ macro_rules! impl_ref_ops {\n     }\n }\n \n-/// Implements op traits for masks\n-macro_rules! impl_mask_element_ops {\n-    { $($mask:ty),* } => {\n-        $(\n-            impl_ref_ops! {\n-                impl core::ops::BitAnd<$mask> for $mask {\n-                    type Output = Self;\n-                    fn bitand(self, rhs: Self) -> Self::Output {\n-                        Self(self.0 & rhs.0)\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl core::ops::BitAndAssign<$mask> for $mask {\n-                    fn bitand_assign(&mut self, rhs: Self) {\n-                        *self = *self & rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl core::ops::BitOr<$mask> for $mask {\n-                    type Output = Self;\n-                    fn bitor(self, rhs: Self) -> Self::Output {\n-                        Self(self.0 | rhs.0)\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl core::ops::BitOrAssign<$mask> for $mask {\n-                    fn bitor_assign(&mut self, rhs: Self) {\n-                        *self = *self | rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl core::ops::BitXor<$mask> for $mask {\n-                    type Output = Self;\n-                    fn bitxor(self, rhs: Self) -> Self::Output {\n-                        Self(self.0 ^ rhs.0)\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl core::ops::BitXorAssign<$mask> for $mask {\n-                    fn bitxor_assign(&mut self, rhs: Self) {\n-                        *self = *self ^ rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl core::ops::Not for $mask {\n-                    type Output = Self;\n-                    fn not(self) -> Self::Output {\n-                        Self(!self.0)\n-                    }\n-                }\n-            }\n-        )*\n-    }\n-}\n-\n-impl_mask_element_ops! {\n-    crate::masks::wide::m8,\n-    crate::masks::wide::m16,\n-    crate::masks::wide::m32,\n-    crate::masks::wide::m64,\n-    crate::masks::wide::m128,\n-    crate::masks::wide::msize\n-}\n-\n /// Automatically implements operators over vectors and scalars for a particular vector.\n macro_rules! impl_op {\n-    { impl Add for $type:ty, $scalar:ty } => {\n+    { impl Add for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Add::add, AddAssign::add_assign, simd_add }\n     };\n-    { impl Sub for $type:ty, $scalar:ty } => {\n+    { impl Sub for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Sub::sub, SubAssign::sub_assign, simd_sub }\n     };\n-    { impl Mul for $type:ty, $scalar:ty } => {\n+    { impl Mul for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Mul::mul, MulAssign::mul_assign, simd_mul }\n     };\n-    { impl Div for $type:ty, $scalar:ty } => {\n+    { impl Div for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Div::div, DivAssign::div_assign, simd_div }\n     };\n-    { impl Rem for $type:ty, $scalar:ty } => {\n+    { impl Rem for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Rem::rem, RemAssign::rem_assign, simd_rem }\n     };\n-    { impl Shl for $type:ty, $scalar:ty } => {\n+    { impl Shl for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Shl::shl, ShlAssign::shl_assign, simd_shl }\n     };\n-    { impl Shr for $type:ty, $scalar:ty } => {\n+    { impl Shr for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, Shr::shr, ShrAssign::shr_assign, simd_shr }\n     };\n-    { impl BitAnd for $type:ty, $scalar:ty } => {\n+    { impl BitAnd for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, BitAnd::bitand, BitAndAssign::bitand_assign, simd_and }\n     };\n-    { impl BitOr for $type:ty, $scalar:ty } => {\n+    { impl BitOr for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, BitOr::bitor, BitOrAssign::bitor_assign, simd_or }\n     };\n-    { impl BitXor for $type:ty, $scalar:ty } => {\n+    { impl BitXor for $type:ident, $scalar:ty } => {\n         impl_op! { @binary $type, $scalar, BitXor::bitxor, BitXorAssign::bitxor_assign, simd_xor }\n     };\n \n-    { impl Not for $type:ty, $scalar:ty } => {\n+    { impl Not for $type:ident, $scalar:ty } => {\n         impl_ref_ops! {\n-            impl core::ops::Not for $type {\n+            impl<const LANES: usize> core::ops::Not for crate::$type<LANES> {\n                 type Output = Self;\n                 fn not(self) -> Self::Output {\n-                    self ^ <$type>::splat(!<$scalar>::default())\n+                    self ^ Self::splat(!<$scalar>::default())\n                 }\n             }\n         }\n     };\n \n-    { impl Neg for $type:ty, $scalar:ty } => {\n+    { impl Neg for $type:ident, $scalar:ty } => {\n         impl_ref_ops! {\n-            impl core::ops::Neg for $type {\n+            impl<const LANES: usize> core::ops::Neg for crate::$type<LANES> {\n                 type Output = Self;\n                 fn neg(self) -> Self::Output {\n-                    <$type>::splat(0) - self\n+                    Self::splat(0) - self\n                 }\n             }\n         }\n     };\n \n-    { impl Neg for $type:ty, $scalar:ty, @float } => {\n+    { impl Neg for $type:ident, $scalar:ty, @float } => {\n         impl_ref_ops! {\n-            impl core::ops::Neg for $type {\n+            impl<const LANES: usize> core::ops::Neg for crate::$type<LANES> {\n                 type Output = Self;\n                 fn neg(self) -> Self::Output {\n                     // FIXME: Replace this with fneg intrinsic once available.\n                     // https://github.com/rust-lang/stdsimd/issues/32\n-                    Self::from_bits(<$type>::splat(-0.0).to_bits() ^ self.to_bits())\n+                    Self::from_bits(Self::splat(-0.0).to_bits() ^ self.to_bits())\n                 }\n             }\n         }\n     };\n \n-    { impl Index for $type:ty, $scalar:ty } => {\n-        impl<I> core::ops::Index<I> for $type\n+    { impl Index for $type:ident, $scalar:ty } => {\n+        impl<I, const LANES: usize> core::ops::Index<I> for crate::$type<LANES>\n         where\n             I: core::slice::SliceIndex<[$scalar]>,\n         {\n@@ -251,7 +175,7 @@ macro_rules! impl_op {\n             }\n         }\n \n-        impl<I> core::ops::IndexMut<I> for $type\n+        impl<I, const LANES: usize> core::ops::IndexMut<I> for crate::$type<LANES>\n         where\n             I: core::slice::SliceIndex<[$scalar]>,\n         {\n@@ -263,13 +187,13 @@ macro_rules! impl_op {\n     };\n \n     // generic binary op with assignment when output is `Self`\n-    { @binary $type:ty, $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n+    { @binary $type:ident, $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n         impl_ref_ops! {\n-            impl core::ops::$trait<$type> for $type {\n-                type Output = $type;\n+            impl<const LANES: usize> core::ops::$trait<Self> for crate::$type<LANES> {\n+                type Output = Self;\n \n                 #[inline]\n-                fn $trait_fn(self, rhs: $type) -> Self::Output {\n+                fn $trait_fn(self, rhs: Self) -> Self::Output {\n                     unsafe {\n                         crate::intrinsics::$intrinsic(self, rhs)\n                     }\n@@ -278,31 +202,31 @@ macro_rules! impl_op {\n         }\n \n         impl_ref_ops! {\n-            impl core::ops::$trait<$scalar> for $type {\n-                type Output = $type;\n+            impl<const LANES: usize> core::ops::$trait<$scalar> for crate::$type<LANES> {\n+                type Output = Self;\n \n                 #[inline]\n                 fn $trait_fn(self, rhs: $scalar) -> Self::Output {\n-                    core::ops::$trait::$trait_fn(self, <$type>::splat(rhs))\n+                    core::ops::$trait::$trait_fn(self, Self::splat(rhs))\n                 }\n             }\n         }\n \n         impl_ref_ops! {\n-            impl core::ops::$trait<$type> for $scalar {\n-                type Output = $type;\n+            impl<const LANES: usize> core::ops::$trait<crate::$type<LANES>> for $scalar {\n+                type Output = crate::$type<LANES>;\n \n                 #[inline]\n-                fn $trait_fn(self, rhs: $type) -> Self::Output {\n-                    core::ops::$trait::$trait_fn(<$type>::splat(self), rhs)\n+                fn $trait_fn(self, rhs: crate::$type<LANES>) -> Self::Output {\n+                    core::ops::$trait::$trait_fn(crate::$type::splat(self), rhs)\n                 }\n             }\n         }\n \n         impl_ref_ops! {\n-            impl core::ops::$assign_trait<$type> for $type {\n+            impl<const LANES: usize> core::ops::$assign_trait<Self> for crate::$type<LANES> {\n                 #[inline]\n-                fn $assign_trait_fn(&mut self, rhs: $type) {\n+                fn $assign_trait_fn(&mut self, rhs: Self) {\n                     unsafe {\n                         *self = crate::intrinsics::$intrinsic(*self, rhs);\n                     }\n@@ -311,10 +235,10 @@ macro_rules! impl_op {\n         }\n \n         impl_ref_ops! {\n-            impl core::ops::$assign_trait<$scalar> for $type {\n+            impl<const LANES: usize> core::ops::$assign_trait<$scalar> for crate::$type<LANES> {\n                 #[inline]\n                 fn $assign_trait_fn(&mut self, rhs: $scalar) {\n-                    core::ops::$assign_trait::$assign_trait_fn(self, <$type>::splat(rhs));\n+                    core::ops::$assign_trait::$assign_trait_fn(self, Self::splat(rhs));\n                 }\n             }\n         }\n@@ -323,7 +247,7 @@ macro_rules! impl_op {\n \n /// Implements floating-point operators for the provided types.\n macro_rules! impl_float_ops {\n-    { $($scalar:ty => $($vector:ty),*;)* } => {\n+    { $($scalar:ty => $($vector:ident),*;)* } => {\n         $( // scalar\n             $( // vector\n                 impl_op! { impl Add for $vector, $scalar }\n@@ -340,7 +264,7 @@ macro_rules! impl_float_ops {\n \n /// Implements mask operators for the provided types.\n macro_rules! impl_mask_ops {\n-    { $($scalar:ty => $($vector:ty),*;)* } => {\n+    { $($scalar:ty => $($vector:ident),*;)* } => {\n         $( // scalar\n             $( // vector\n                 impl_op! { impl BitAnd for $vector, $scalar }\n@@ -355,7 +279,7 @@ macro_rules! impl_mask_ops {\n \n /// Implements unsigned integer operators for the provided types.\n macro_rules! impl_unsigned_int_ops {\n-    { $($scalar:ty => $($vector:ty),*;)* } => {\n+    { $($scalar:ty => $($vector:ident),*;)* } => {\n         $( // scalar\n             $( // vector\n                 impl_op! { impl Add for $vector, $scalar }\n@@ -369,11 +293,11 @@ macro_rules! impl_unsigned_int_ops {\n \n                 // Integers panic on divide by 0\n                 impl_ref_ops! {\n-                    impl core::ops::Div<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::Div<Self> for crate::$vector<LANES> {\n                         type Output = Self;\n \n                         #[inline]\n-                        fn div(self, rhs: $vector) -> Self::Output {\n+                        fn div(self, rhs: Self) -> Self::Output {\n                             // TODO there is probably a better way of doing this\n                             if AsRef::<[$scalar]>::as_ref(&rhs)\n                                 .iter()\n@@ -387,8 +311,8 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Div<$scalar> for $vector {\n-                        type Output = $vector;\n+                    impl<const LANES: usize> core::ops::Div<$scalar> for crate::$vector<LANES> {\n+                        type Output = Self;\n \n                         #[inline]\n                         fn div(self, rhs: $scalar) -> Self::Output {\n@@ -402,18 +326,18 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Div<$vector> for $scalar {\n-                        type Output = $vector;\n+                    impl<const LANES: usize> core::ops::Div<crate::$vector<LANES>> for $scalar {\n+                        type Output = crate::$vector<LANES>;\n \n                         #[inline]\n-                        fn div(self, rhs: $vector) -> Self::Output {\n-                            <$vector>::splat(self) / rhs\n+                        fn div(self, rhs: crate::$vector<LANES>) -> Self::Output {\n+                            crate::$vector::splat(self) / rhs\n                         }\n                     }\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::DivAssign<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::DivAssign<Self> for crate::$vector<LANES> {\n                         #[inline]\n                         fn div_assign(&mut self, rhs: Self) {\n                             *self = *self / rhs;\n@@ -422,7 +346,7 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::DivAssign<$scalar> for $vector {\n+                    impl<const LANES: usize> core::ops::DivAssign<$scalar> for crate::$vector<LANES> {\n                         #[inline]\n                         fn div_assign(&mut self, rhs: $scalar) {\n                             *self = *self / rhs;\n@@ -432,11 +356,11 @@ macro_rules! impl_unsigned_int_ops {\n \n                 // remainder panics on zero divisor\n                 impl_ref_ops! {\n-                    impl core::ops::Rem<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::Rem<Self> for crate::$vector<LANES> {\n                         type Output = Self;\n \n                         #[inline]\n-                        fn rem(self, rhs: $vector) -> Self::Output {\n+                        fn rem(self, rhs: Self) -> Self::Output {\n                             // TODO there is probably a better way of doing this\n                             if AsRef::<[$scalar]>::as_ref(&rhs)\n                                 .iter()\n@@ -450,8 +374,8 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Rem<$scalar> for $vector {\n-                        type Output = $vector;\n+                    impl<const LANES: usize> core::ops::Rem<$scalar> for crate::$vector<LANES> {\n+                        type Output = Self;\n \n                         #[inline]\n                         fn rem(self, rhs: $scalar) -> Self::Output {\n@@ -465,18 +389,18 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Rem<$vector> for $scalar {\n-                        type Output = $vector;\n+                    impl<const LANES: usize> core::ops::Rem<crate::$vector<LANES>> for $scalar {\n+                        type Output = crate::$vector<LANES>;\n \n                         #[inline]\n-                        fn rem(self, rhs: $vector) -> Self::Output {\n-                            <$vector>::splat(self) % rhs\n+                        fn rem(self, rhs: crate::$vector<LANES>) -> Self::Output {\n+                            crate::$vector::splat(self) % rhs\n                         }\n                     }\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::RemAssign<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::RemAssign<Self> for crate::$vector<LANES> {\n                         #[inline]\n                         fn rem_assign(&mut self, rhs: Self) {\n                             *self = *self % rhs;\n@@ -485,7 +409,7 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::RemAssign<$scalar> for $vector {\n+                    impl<const LANES: usize> core::ops::RemAssign<$scalar> for crate::$vector<LANES> {\n                         #[inline]\n                         fn rem_assign(&mut self, rhs: $scalar) {\n                             *self = *self % rhs;\n@@ -495,11 +419,11 @@ macro_rules! impl_unsigned_int_ops {\n \n                 // shifts panic on overflow\n                 impl_ref_ops! {\n-                    impl core::ops::Shl<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::Shl<Self> for crate::$vector<LANES> {\n                         type Output = Self;\n \n                         #[inline]\n-                        fn shl(self, rhs: $vector) -> Self::Output {\n+                        fn shl(self, rhs: Self) -> Self::Output {\n                             // TODO there is probably a better way of doing this\n                             if AsRef::<[$scalar]>::as_ref(&rhs)\n                                 .iter()\n@@ -514,8 +438,8 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Shl<$scalar> for $vector {\n-                        type Output = $vector;\n+                    impl<const LANES: usize> core::ops::Shl<$scalar> for crate::$vector<LANES> {\n+                        type Output = Self;\n \n                         #[inline]\n                         fn shl(self, rhs: $scalar) -> Self::Output {\n@@ -530,7 +454,7 @@ macro_rules! impl_unsigned_int_ops {\n \n \n                 impl_ref_ops! {\n-                    impl core::ops::ShlAssign<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::ShlAssign<Self> for crate::$vector<LANES> {\n                         #[inline]\n                         fn shl_assign(&mut self, rhs: Self) {\n                             *self = *self << rhs;\n@@ -539,7 +463,7 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::ShlAssign<$scalar> for $vector {\n+                    impl<const LANES: usize> core::ops::ShlAssign<$scalar> for crate::$vector<LANES> {\n                         #[inline]\n                         fn shl_assign(&mut self, rhs: $scalar) {\n                             *self = *self << rhs;\n@@ -548,13 +472,13 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Shr<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::Shr<Self> for crate::$vector<LANES> {\n                         type Output = Self;\n \n                         #[inline]\n-                        fn shr(self, rhs: $vector) -> Self::Output {\n+                        fn shr(self, rhs: Self) -> Self::Output {\n                             // TODO there is probably a better way of doing this\n-                            if AsRef::<[$scalar]>::as_ref(&rhs)\n+                            if rhs.as_slice()\n                                 .iter()\n                                 .copied()\n                                 .any(invalid_shift_rhs)\n@@ -567,8 +491,8 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::Shr<$scalar> for $vector {\n-                        type Output = $vector;\n+                    impl<const LANES: usize> core::ops::Shr<$scalar> for crate::$vector<LANES> {\n+                        type Output = Self;\n \n                         #[inline]\n                         fn shr(self, rhs: $scalar) -> Self::Output {\n@@ -583,7 +507,7 @@ macro_rules! impl_unsigned_int_ops {\n \n \n                 impl_ref_ops! {\n-                    impl core::ops::ShrAssign<$vector> for $vector {\n+                    impl<const LANES: usize> core::ops::ShrAssign<Self> for crate::$vector<LANES> {\n                         #[inline]\n                         fn shr_assign(&mut self, rhs: Self) {\n                             *self = *self >> rhs;\n@@ -592,7 +516,7 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n \n                 impl_ref_ops! {\n-                    impl core::ops::ShrAssign<$scalar> for $vector {\n+                    impl<const LANES: usize> core::ops::ShrAssign<$scalar> for crate::$vector<LANES> {\n                         #[inline]\n                         fn shr_assign(&mut self, rhs: $scalar) {\n                             *self = *self >> rhs;\n@@ -606,7 +530,7 @@ macro_rules! impl_unsigned_int_ops {\n \n /// Implements unsigned integer operators for the provided types.\n macro_rules! impl_signed_int_ops {\n-    { $($scalar:ty => $($vector:ty),*;)* } => {\n+    { $($scalar:ty => $($vector:ident),*;)* } => {\n         impl_unsigned_int_ops! { $($scalar => $($vector),*;)* }\n         $( // scalar\n             $( // vector\n@@ -617,33 +541,24 @@ macro_rules! impl_signed_int_ops {\n }\n \n impl_unsigned_int_ops! {\n-    u8    => crate::u8x8,    crate::u8x16,   crate::u8x32,   crate::u8x64;\n-    u16   => crate::u16x4,   crate::u16x8,   crate::u16x16,  crate::u16x32;\n-    u32   => crate::u32x2,   crate::u32x4,   crate::u32x8,   crate::u32x16;\n-    u64   => crate::u64x2,   crate::u64x4,   crate::u64x8;\n-    u128  => crate::u128x2,  crate::u128x4;\n-    usize => crate::usizex2, crate::usizex4, crate::usizex8;\n+    u8 => SimdU8;\n+    u16 => SimdU16;\n+    u32 => SimdU32;\n+    u64 => SimdU64;\n+    u128 => SimdU128;\n+    usize => SimdUsize;\n }\n \n impl_signed_int_ops! {\n-    i8    => crate::i8x8,    crate::i8x16,   crate::i8x32,   crate::i8x64;\n-    i16   => crate::i16x4,   crate::i16x8,   crate::i16x16,  crate::i16x32;\n-    i32   => crate::i32x2,   crate::i32x4,   crate::i32x8,   crate::i32x16;\n-    i64   => crate::i64x2,   crate::i64x4,   crate::i64x8;\n-    i128  => crate::i128x2,  crate::i128x4;\n-    isize => crate::isizex2, crate::isizex4, crate::isizex8;\n+    i8 => SimdI8;\n+    i16 => SimdI16;\n+    i32 => SimdI32;\n+    i64 => SimdI64;\n+    i128 => SimdI128;\n+    isize => SimdIsize;\n }\n \n impl_float_ops! {\n-    f32 => crate::f32x2, crate::f32x4, crate::f32x8, crate::f32x16;\n-    f64 => crate::f64x2, crate::f64x4, crate::f64x8;\n-}\n-\n-impl_mask_ops! {\n-    crate::masks::wide::m8    => crate::masks::wide::m8x8,    crate::masks::wide::m8x16,   crate::masks::wide::m8x32,   crate::masks::wide::m8x64;\n-    crate::masks::wide::m16   => crate::masks::wide::m16x4,   crate::masks::wide::m16x8,   crate::masks::wide::m16x16,  crate::masks::wide::m16x32;\n-    crate::masks::wide::m32   => crate::masks::wide::m32x2,   crate::masks::wide::m32x4,   crate::masks::wide::m32x8,   crate::masks::wide::m32x16;\n-    crate::masks::wide::m64   => crate::masks::wide::m64x2,   crate::masks::wide::m64x4,   crate::masks::wide::m64x8;\n-    crate::masks::wide::m128  => crate::masks::wide::m128x2,  crate::masks::wide::m128x4;\n-    crate::masks::wide::msize => crate::masks::wide::msizex2, crate::masks::wide::msizex4, crate::masks::wide::msizex8;\n+    f32 => SimdF32;\n+    f64 => SimdF64;\n }"}, {"sha": "9da2bdfce42e90b9eb3dcb38bb104c043935259c", "filename": "crates/core_simd/tests/helpers/biteq.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs?ref=25c7640fb331112d5bf445c0893af89ee3e9ea9d", "patch": "@@ -70,12 +70,6 @@ impl_biteq! {\n     integer impl BitEq for\n         u8, u16, u32, u64, u128, usize,\n         i8, i16, i32, i64, i128, isize,\n-        core_simd::masks::wide::m8,\n-        core_simd::masks::wide::m16,\n-        core_simd::masks::wide::m32,\n-        core_simd::masks::wide::m64,\n-        core_simd::masks::wide::m128,\n-        core_simd::masks::wide::msize,\n }\n \n impl_biteq! {\n@@ -98,12 +92,6 @@ impl_biteq! {\n         core_simd::isizex2, core_simd::isizex4, core_simd::isizex8,\n         core_simd::f32x2, core_simd::f32x4, core_simd::f32x8, core_simd::f32x16,\n         core_simd::f64x2, core_simd::f64x4, core_simd::f64x8,\n-        core_simd::masks::wide::m8x8,    core_simd::masks::wide::m8x16,   core_simd::masks::wide::m8x32,   core_simd::masks::wide::m8x64,\n-        core_simd::masks::wide::m16x4,   core_simd::masks::wide::m16x8,   core_simd::masks::wide::m16x16,  core_simd::masks::wide::m16x32,\n-        core_simd::masks::wide::m32x2,   core_simd::masks::wide::m32x4,   core_simd::masks::wide::m32x8,   core_simd::masks::wide::m32x16,\n-        core_simd::masks::wide::m64x2,   core_simd::masks::wide::m64x4,   core_simd::masks::wide::m64x8,\n-        core_simd::masks::wide::m128x2,  core_simd::masks::wide::m128x4,\n-        core_simd::masks::wide::msizex2, core_simd::masks::wide::msizex4, core_simd::masks::wide::msizex8,\n }\n \n pub(crate) struct BitEqWrapper<'a, T>(pub(crate) &'a T);"}, {"sha": "a46367d0cc2f72f3a013c2296795ac9d9ea3e24a", "filename": "crates/core_simd/tests/ops_impl/float_macros.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs?ref=25c7640fb331112d5bf445c0893af89ee3e9ea9d", "patch": "@@ -335,6 +335,8 @@ macro_rules! float_tests {\n                 }\n             }\n \n+            // TODO reenable after converting float ops to platform intrinsics\n+            /*\n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn ceil_odd_floats() {\n@@ -413,6 +415,7 @@ macro_rules! float_tests {\n                     assert_biteq!(core_simd::$vector::round_from_int(v), expected);\n                 }\n             }\n+            */\n         }\n     }\n }"}, {"sha": "3aaa036b9940500749ddd8328fa8bd0dbb248f8a", "filename": "crates/core_simd/tests/ops_impl/mask_macros.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask_macros.rs?ref=25c7640fb331112d5bf445c0893af89ee3e9ea9d", "patch": "@@ -1,5 +1,6 @@\n macro_rules! mask_tests {\n     { $vector:ident, $lanes:literal } => {\n+        /*\n         #[cfg(test)]\n         mod $vector {\n             use core_simd::$vector as Vector;\n@@ -221,5 +222,6 @@ macro_rules! mask_tests {\n                 assert_eq!(!v, expected);\n             }\n         }\n+        */\n     }\n }"}]}