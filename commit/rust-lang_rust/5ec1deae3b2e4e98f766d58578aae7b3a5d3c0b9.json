{"sha": "5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYzFkZWFlM2IyZTRlOThmNzY2ZDU4NTc4YWFlN2IzYTVkM2MwYjk=", "commit": {"author": {"name": "Nick Hamann", "email": "nick@wabbo.org", "date": "2015-07-14T23:51:47Z"}, "committer": {"name": "Nick Hamann", "email": "nick@wabbo.org", "date": "2015-07-15T02:27:06Z"}, "message": "Change int/uint => isize/usize in compiler docs.", "tree": {"sha": "e4ddb8c7041e4168499a2488aea2b18dc88570c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4ddb8c7041e4168499a2488aea2b18dc88570c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9", "html_url": "https://github.com/rust-lang/rust/commit/5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9/comments", "author": null, "committer": null, "parents": [{"sha": "e4e93196e16030ebf7a20c473849534235d676f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4e93196e16030ebf7a20c473849534235d676f8", "html_url": "https://github.com/rust-lang/rust/commit/e4e93196e16030ebf7a20c473849534235d676f8"}], "stats": {"total": 106, "additions": 53, "deletions": 53}, "files": [{"sha": "57665b6d9392348833f973f4502273dc1d448608", "filename": "src/librustc/middle/infer/higher_ranked/README.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2FREADME.md?ref=5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9", "patch": "@@ -17,7 +17,7 @@ The problem we are addressing is that there is a kind of subtyping\n between functions with bound region parameters. Consider, for\n example, whether the following relation holds:\n \n-    for<'a> fn(&'a int) <: for<'b> fn(&'b int)? (Yes, a => b)\n+    for<'a> fn(&'a isize) <: for<'b> fn(&'b isize)? (Yes, a => b)\n \n The answer is that of course it does. These two types are basically\n the same, except that in one we used the name `a` and one we used\n@@ -27,14 +27,14 @@ In the examples that follow, it becomes very important to know whether\n a lifetime is bound in a function type (that is, is a lifetime\n parameter) or appears free (is defined in some outer scope).\n Therefore, from now on I will always write the bindings explicitly,\n-using the Rust syntax `for<'a> fn(&'a int)` to indicate that `a` is a\n+using the Rust syntax `for<'a> fn(&'a isize)` to indicate that `a` is a\n lifetime parameter.\n \n Now let's consider two more function types. Here, we assume that the\n `'b` lifetime is defined somewhere outside and hence is not a lifetime\n parameter bound by the function type (it \"appears free\"):\n \n-    for<'a> fn(&'a int) <: fn(&'b int)? (Yes, a => b)\n+    for<'a> fn(&'a isize) <: fn(&'b isize)? (Yes, a => b)\n \n This subtyping relation does in fact hold. To see why, you have to\n consider what subtyping means. One way to look at `T1 <: T2` is to\n@@ -51,7 +51,7 @@ to the same thing: a function that accepts pointers with any lifetime\n \n So, what if we reverse the order of the two function types, like this:\n \n-    fn(&'b int) <: for<'a> fn(&'a int)? (No)\n+    fn(&'b isize) <: for<'a> fn(&'a isize)? (No)\n \n Does the subtyping relationship still hold?  The answer of course is\n no. In this case, the function accepts *only the lifetime `'b`*,\n@@ -60,8 +60,8 @@ accepted any lifetime.\n \n What about these two examples:\n \n-    for<'a,'b> fn(&'a int, &'b int) <: for<'a>    fn(&'a int, &'a int)? (Yes)\n-    for<'a>    fn(&'a int, &'a int) <: for<'a,'b> fn(&'a int, &'b int)? (No)\n+    for<'a,'b> fn(&'a isize, &'b isize) <: for<'a>    fn(&'a isize, &'a isize)? (Yes)\n+    for<'a>    fn(&'a isize, &'a isize) <: for<'a,'b> fn(&'a isize, &'b isize)? (No)\n \n Here, it is true that functions which take two pointers with any two\n lifetimes can be treated as if they only accepted two pointers with"}, {"sha": "2dc16d4fa1dd419e0edacba3142cb00847adebe4", "filename": "src/librustc/middle/infer/region_inference/README.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md?ref=5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9", "patch": "@@ -121,7 +121,7 @@ every expression, block, and pattern (patterns are considered to\n \"execute\" by testing the value they are applied to and creating any\n relevant bindings).  So, for example:\n \n-    fn foo(x: int, y: int) { // -+\n+    fn foo(x: isize, y: isize) { // -+\n     //  +------------+       //  |\n     //  |      +-----+       //  |\n     //  |  +-+ +-+ +-+       //  |\n@@ -168,13 +168,13 @@ an error.\n Here is a more involved example (which is safe) so we can see what's\n going on:\n \n-    struct Foo { f: uint, g: uint }\n+    struct Foo { f: usize, g: usize }\n     ...\n-    fn add(p: &mut uint, v: uint) {\n+    fn add(p: &mut usize, v: usize) {\n         *p += v;\n     }\n     ...\n-    fn inc(p: &mut uint) -> uint {\n+    fn inc(p: &mut usize) -> usize {\n         *p += 1; *p\n     }\n     fn weird() {\n@@ -199,8 +199,8 @@ in a call expression:\n \n     'a: {\n         'a_arg1: let a_temp1: ... = add;\n-        'a_arg2: let a_temp2: &'a mut uint = &'a mut (*x).f;\n-        'a_arg3: let a_temp3: uint = {\n+        'a_arg2: let a_temp2: &'a mut usize = &'a mut (*x).f;\n+        'a_arg3: let a_temp3: usize = {\n             let b_temp1: ... = inc;\n             let b_temp2: &'b = &'b mut (*x).f;\n             'b_call: b_temp1(b_temp2)\n@@ -225,13 +225,13 @@ it will not be *dereferenced* during the evaluation of the second\n argument, it can still be *invalidated* by that evaluation. Consider\n this similar but unsound example:\n \n-    struct Foo { f: uint, g: uint }\n+    struct Foo { f: usize, g: usize }\n     ...\n-    fn add(p: &mut uint, v: uint) {\n+    fn add(p: &mut usize, v: usize) {\n         *p += v;\n     }\n     ...\n-    fn consume(x: Box<Foo>) -> uint {\n+    fn consume(x: Box<Foo>) -> usize {\n         x.f + x.g\n     }\n     fn weird() {"}, {"sha": "92982af92dcfe7ad772500cb809f66812070bafa", "filename": "src/librustc/middle/traits/README.md", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md?ref=5ec1deae3b2e4e98f766d58578aae7b3a5d3c0b9", "patch": "@@ -12,10 +12,10 @@ reference to a trait. So, for example, if there is a generic function like:\n \n and then a call to that function:\n \n-    let v: Vec<int> = clone_slice([1, 2, 3])\n+    let v: Vec<isize> = clone_slice([1, 2, 3])\n \n it is the job of trait resolution to figure out (in which case)\n-whether there exists an impl of `int : Clone`\n+whether there exists an impl of `isize : Clone`\n \n Note that in some cases, like generic functions, we may not be able to\n find a specific impl, but we can figure out that the caller must\n@@ -115,27 +115,27 @@ trait Convert<Target> {\n \n This trait just has one method. It's about as simple as it gets. It\n converts from the (implicit) `Self` type to the `Target` type. If we\n-wanted to permit conversion between `int` and `uint`, we might\n+wanted to permit conversion between `isize` and `usize`, we might\n implement `Convert` like so:\n \n ```rust\n-impl Convert<uint> for int { ... } // int -> uint\n-impl Convert<int> for uint { ... } // uint -> int\n+impl Convert<usize> for isize { ... } // isize -> usize\n+impl Convert<isize> for usize { ... } // usize -> isize\n ```\n \n Now imagine there is some code like the following:\n \n ```rust\n-let x: int = ...;\n+let x: isize = ...;\n let y = x.convert();\n ```\n \n The call to convert will generate a trait reference `Convert<$Y> for\n-int`, where `$Y` is the type variable representing the type of\n+isize`, where `$Y` is the type variable representing the type of\n `y`. When we match this against the two impls we can see, we will find\n-that only one remains: `Convert<uint> for int`. Therefore, we can\n+that only one remains: `Convert<usize> for isize`. Therefore, we can\n select this impl, which will cause the type of `$Y` to be unified to\n-`uint`. (Note that while assembling candidates, we do the initial\n+`usize`. (Note that while assembling candidates, we do the initial\n unifications in a transaction, so that they don't affect one another.)\n \n There are tests to this effect in src/test/run-pass:\n@@ -225,7 +225,7 @@ Confirmation unifies the output type parameters of the trait with the\n values found in the obligation, possibly yielding a type error.  If we\n return to our example of the `Convert` trait from the previous\n section, confirmation is where an error would be reported, because the\n-impl specified that `T` would be `uint`, but the obligation reported\n+impl specified that `T` would be `usize`, but the obligation reported\n `char`. Hence the result of selection would be an error.\n \n ### Selection during translation\n@@ -250,20 +250,20 @@ Here is an example:\n     trait Foo { ... }\n     impl<U,T:Bar<U>> Foo for Vec<T> { ... }\n \n-    impl Bar<uint> for int { ... }\n+    impl Bar<usize> for isize { ... }\n \n-After one shallow round of selection for an obligation like `Vec<int>\n+After one shallow round of selection for an obligation like `Vec<isize>\n : Foo`, we would know which impl we want, and we would know that\n-`T=int`, but we do not know the type of `U`.  We must select the\n-nested obligation `int : Bar<U>` to find out that `U=uint`.\n+`T=isize`, but we do not know the type of `U`.  We must select the\n+nested obligation `isize : Bar<U>` to find out that `U=usize`.\n \n It would be good to only do *just as much* nested resolution as\n necessary. Currently, though, we just do a full resolution.\n \n # Higher-ranked trait bounds\n \n One of the more subtle concepts at work are *higher-ranked trait\n-bounds*. An example of such a bound is `for<'a> MyTrait<&'a int>`.\n+bounds*. An example of such a bound is `for<'a> MyTrait<&'a isize>`.\n Let's walk through how selection on higher-ranked trait references\n works.\n \n@@ -279,21 +279,21 @@ trait Foo<X> {\n ```\n \n Let's say we have a function `want_hrtb` that wants a type which\n-implements `Foo<&'a int>` for any `'a`:\n+implements `Foo<&'a isize>` for any `'a`:\n \n ```rust\n-fn want_hrtb<T>() where T : for<'a> Foo<&'a int> { ... }\n+fn want_hrtb<T>() where T : for<'a> Foo<&'a isize> { ... }\n ```\n \n-Now we have a struct `AnyInt` that implements `Foo<&'a int>` for any\n+Now we have a struct `AnyInt` that implements `Foo<&'a isize>` for any\n `'a`:\n \n ```rust\n struct AnyInt;\n-impl<'a> Foo<&'a int> for AnyInt { }\n+impl<'a> Foo<&'a isize> for AnyInt { }\n ```\n \n-And the question is, does `AnyInt : for<'a> Foo<&'a int>`? We want the\n+And the question is, does `AnyInt : for<'a> Foo<&'a isize>`? We want the\n answer to be yes. The algorithm for figuring it out is closely related\n to the subtyping for higher-ranked types (which is described in\n `middle::infer::higher_ranked::doc`, but also in a [paper by SPJ] that\n@@ -306,12 +306,12 @@ I recommend you read).\n [paper by SPJ]: http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n \n So let's work through our example. The first thing we would do is to\n-skolemize the obligation, yielding `AnyInt : Foo<&'0 int>` (here `'0`\n+skolemize the obligation, yielding `AnyInt : Foo<&'0 isize>` (here `'0`\n represents skolemized region #0). Note that now have no quantifiers;\n in terms of the compiler type, this changes from a `ty::PolyTraitRef`\n to a `TraitRef`. We would then create the `TraitRef` from the impl,\n using fresh variables for it's bound regions (and thus getting\n-`Foo<&'$a int>`, where `'$a` is the inference variable for `'a`). Next\n+`Foo<&'$a isize>`, where `'$a` is the inference variable for `'a`). Next\n we relate the two trait refs, yielding a graph with the constraint\n that `'0 == '$a`. Finally, we check for skolemization \"leaks\" -- a\n leak is basically any attempt to relate a skolemized region to another\n@@ -327,13 +327,13 @@ Let's consider a failure case. Imagine we also have a struct\n \n ```rust\n struct StaticInt;\n-impl Foo<&'static int> for StaticInt;\n+impl Foo<&'static isize> for StaticInt;\n ```\n \n-We want the obligation `StaticInt : for<'a> Foo<&'a int>` to be\n+We want the obligation `StaticInt : for<'a> Foo<&'a isize>` to be\n considered unsatisfied. The check begins just as before. `'a` is\n skolemized to `'0` and the impl trait reference is instantiated to\n-`Foo<&'static int>`. When we relate those two, we get a constraint\n+`Foo<&'static isize>`. When we relate those two, we get a constraint\n like `'static == '0`. This means that the taint set for `'0` is `{'0,\n 'static}`, which fails the leak check.\n \n@@ -358,13 +358,13 @@ impl<X,F> Foo<X> for F\n }\n ```\n \n-Now let's say we have a obligation `for<'a> Foo<&'a int>` and we match\n+Now let's say we have a obligation `for<'a> Foo<&'a isize>` and we match\n this impl. What obligation is generated as a result? We want to get\n-`for<'a> Bar<&'a int>`, but how does that happen?\n+`for<'a> Bar<&'a isize>`, but how does that happen?\n \n After the matching, we are in a position where we have a skolemized\n-substitution like `X => &'0 int`. If we apply this substitution to the\n-impl obligations, we get `F : Bar<&'0 int>`. Obviously this is not\n+substitution like `X => &'0 isize`. If we apply this substitution to the\n+impl obligations, we get `F : Bar<&'0 isize>`. Obviously this is not\n directly usable because the skolemized region `'0` cannot leak out of\n our computation.\n \n@@ -375,7 +375,7 @@ leak check passed, so this taint set consists solely of the skolemized\n region itself plus various intermediate region variables. We then walk\n the trait-reference and convert every region in that taint set back to\n a late-bound region, so in this case we'd wind up with `for<'a> F :\n-Bar<&'a int>`.\n+Bar<&'a isize>`.\n \n # Caching and subtle considerations therewith\n \n@@ -391,8 +391,8 @@ but *replay* its effects on the type variables.\n \n The high-level idea of how the cache works is that we first replace\n all unbound inference variables with skolemized versions. Therefore,\n-if we had a trait reference `uint : Foo<$1>`, where `$n` is an unbound\n-inference variable, we might replace it with `uint : Foo<%0>`, where\n+if we had a trait reference `usize : Foo<$1>`, where `$n` is an unbound\n+inference variable, we might replace it with `usize : Foo<%0>`, where\n `%n` is a skolemized type. We would then look this up in the cache.\n If we found a hit, the hit would tell us the immediate next step to\n take in the selection process: i.e., apply impl #22, or apply where\n@@ -401,17 +401,17 @@ Therefore, we search through impls and where clauses and so forth, and\n we come to the conclusion that the only possible impl is this one,\n with def-id 22:\n \n-    impl Foo<int> for uint { ... } // Impl #22\n+    impl Foo<isize> for usize { ... } // Impl #22\n \n-We would then record in the cache `uint : Foo<%0> ==>\n+We would then record in the cache `usize : Foo<%0> ==>\n ImplCandidate(22)`. Next we would confirm `ImplCandidate(22)`, which\n-would (as a side-effect) unify `$1` with `int`.\n+would (as a side-effect) unify `$1` with `isize`.\n \n-Now, at some later time, we might come along and see a `uint :\n-Foo<$3>`.  When skolemized, this would yield `uint : Foo<%0>`, just as\n+Now, at some later time, we might come along and see a `usize :\n+Foo<$3>`.  When skolemized, this would yield `usize : Foo<%0>`, just as\n before, and hence the cache lookup would succeed, yielding\n `ImplCandidate(22)`. We would confirm `ImplCandidate(22)` which would\n-(as a side-effect) unify `$3` with `int`.\n+(as a side-effect) unify `$3` with `isize`.\n \n ## Where clauses and the local vs global cache\n "}]}