{"sha": "5dd94d86c64eb13382b3230c9a22c1e59d1e361a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZDk0ZDg2YzY0ZWIxMzM4MmIzMjMwYzlhMjJjMWU1OWQxZTM2MWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-14T08:41:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-14T08:41:48Z"}, "message": "auto merge of #13481 : huonw/rust/devec-path, r=alexcrichton\n\nRemove the use of ~[] from Path's internals.", "tree": {"sha": "807ba1b673118f2a9394e43868deaed5c6730bbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/807ba1b673118f2a9394e43868deaed5c6730bbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dd94d86c64eb13382b3230c9a22c1e59d1e361a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd94d86c64eb13382b3230c9a22c1e59d1e361a", "html_url": "https://github.com/rust-lang/rust/commit/5dd94d86c64eb13382b3230c9a22c1e59d1e361a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dd94d86c64eb13382b3230c9a22c1e59d1e361a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40a979775159176f15eb66617a89b9e1a43857f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/40a979775159176f15eb66617a89b9e1a43857f2", "html_url": "https://github.com/rust-lang/rust/commit/40a979775159176f15eb66617a89b9e1a43857f2"}, {"sha": "31074fdf2eb99b36100a04a7712ebf62df55d03a", "url": "https://api.github.com/repos/rust-lang/rust/commits/31074fdf2eb99b36100a04a7712ebf62df55d03a", "html_url": "https://github.com/rust-lang/rust/commit/31074fdf2eb99b36100a04a7712ebf62df55d03a"}], "stats": {"total": 392, "additions": 209, "deletions": 183}, "files": [{"sha": "6a1f9c1a4c78e9c60b65a009e4c2aadd3b5ba3bf", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5dd94d86c64eb13382b3230c9a22c1e59d1e361a/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd94d86c64eb13382b3230c9a22c1e59d1e361a/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=5dd94d86c64eb13382b3230c9a22c1e59d1e361a", "patch": "@@ -63,17 +63,20 @@ println!(\"path exists: {}\", path.exists());\n \n */\n \n+#![deny(deprecated_owned_vector)]\n+\n use container::Container;\n use c_str::CString;\n use clone::Clone;\n use fmt;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str;\n-use str::{MaybeOwned, OwnedStr, Str, StrSlice, from_utf8_lossy};\n-use slice;\n-use slice::{CloneableVector, OwnedCloneableVector, OwnedVector, Vector};\n+use str::{MaybeOwned, Str, StrSlice, from_utf8_lossy};\n+use strbuf::StrBuf;\n+use slice::{OwnedCloneableVector, OwnedVector, Vector};\n use slice::{ImmutableEqVector, ImmutableVector};\n+use vec::Vec;\n \n /// Typedef for POSIX file paths.\n /// See `posix::Path` for more info.\n@@ -184,7 +187,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     fn as_vec<'a>(&'a self) -> &'a [u8];\n \n     /// Converts the Path into an owned byte vector\n-    fn into_vec(self) -> ~[u8];\n+    fn into_vec(self) -> Vec<u8>;\n \n     /// Returns an object that implements `Show` for printing paths\n     ///\n@@ -293,15 +296,15 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(name.slice_to(idx).to_owned()),\n+                (Some(idx), 0) => Some(Vec::from_slice(name.slice_to(idx))),\n                 (idx, extlen) => {\n                     let idx = match idx {\n                         None | Some(0) => name.len(),\n                         Some(val) => val\n                     };\n \n                     let mut v;\n-                    v = slice::with_capacity(idx + extlen + 1);\n+                    v = Vec::with_capacity(idx + extlen + 1);\n                     v.push_all(name.slice_to(idx));\n                     v.push(dot);\n                     v.push_all(extension.container_as_bytes());\n@@ -441,10 +444,10 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n pub trait BytesContainer {\n     /// Returns a &[u8] representing the receiver\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8];\n-    /// Consumes the receiver and converts it into ~[u8]\n+    /// Consumes the receiver and converts it into Vec<u8>\n     #[inline]\n-    fn container_into_owned_bytes(self) -> ~[u8] {\n-        self.container_as_bytes().to_owned()\n+    fn container_into_owned_bytes(self) -> Vec<u8> {\n+        Vec::from_slice(self.container_as_bytes())\n     }\n     /// Returns the receiver interpreted as a utf-8 string, if possible\n     #[inline]\n@@ -522,15 +525,27 @@ impl BytesContainer for ~str {\n         self.as_bytes()\n     }\n     #[inline]\n-    fn container_into_owned_bytes(self) -> ~[u8] {\n+    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n+        Some(self.as_slice())\n+    }\n+    #[inline]\n+    fn is_str(_: Option<~str>) -> bool { true }\n+}\n+impl BytesContainer for StrBuf {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_bytes()\n+    }\n+    #[inline]\n+    fn container_into_owned_bytes(self) -> Vec<u8> {\n         self.into_bytes()\n     }\n     #[inline]\n     fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n         Some(self.as_slice())\n     }\n     #[inline]\n-    fn is_str(_: Option<~str>) -> bool { true }\n+    fn is_str(_: Option<StrBuf>) -> bool { true }\n }\n \n impl<'a> BytesContainer for &'a [u8] {\n@@ -545,8 +560,15 @@ impl BytesContainer for ~[u8] {\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.as_slice()\n     }\n+}\n+\n+impl BytesContainer for Vec<u8> {\n+    #[inline]\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.as_slice()\n+    }\n     #[inline]\n-    fn container_into_owned_bytes(self) -> ~[u8] {\n+    fn container_into_owned_bytes(self) -> Vec<u8> {\n         self\n     }\n }\n@@ -564,10 +586,6 @@ impl<'a> BytesContainer for str::MaybeOwned<'a> {\n         self.as_slice().as_bytes()\n     }\n     #[inline]\n-    fn container_into_owned_bytes(self) -> ~[u8] {\n-        self.into_owned().into_bytes()\n-    }\n-    #[inline]\n     fn container_as_str<'b>(&'b self) -> Option<&'b str> {\n         Some(self.as_slice())\n     }"}, {"sha": "1a80e52359d2453108875032a3d99b60dd674dd2", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/5dd94d86c64eb13382b3230c9a22c1e59d1e361a/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd94d86c64eb13382b3230c9a22c1e59d1e361a/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=5dd94d86c64eb13382b3230c9a22c1e59d1e361a", "patch": "@@ -20,9 +20,10 @@ use iter::{AdditiveIterator, Extendable, Iterator, Map};\n use option::{Option, None, Some};\n use str;\n use str::Str;\n-use slice;\n use slice::{CloneableVector, RevSplits, Splits, Vector, VectorVector,\n             ImmutableEqVector, OwnedVector, ImmutableVector, OwnedCloneableVector};\n+use vec::Vec;\n+\n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &[u8]\n@@ -40,7 +41,7 @@ pub type RevStrComponents<'a> = Map<'a, &'a [u8], Option<&'a str>,\n /// Represents a POSIX file path\n #[deriving(Clone)]\n pub struct Path {\n-    repr: ~[u8], // assumed to never be empty or contain NULs\n+    repr: Vec<u8>, // assumed to never be empty or contain NULs\n     sepidx: Option<uint> // index of the final separator in repr\n }\n \n@@ -103,7 +104,7 @@ impl BytesContainer for Path {\n         self.as_vec()\n     }\n     #[inline]\n-    fn container_into_owned_bytes(self) -> ~[u8] {\n+    fn container_into_owned_bytes(self) -> Vec<u8> {\n         self.into_vec()\n     }\n }\n@@ -119,38 +120,41 @@ impl GenericPathUnsafe for Path {\n     unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {\n         let path = Path::normalize(path.container_as_bytes());\n         assert!(!path.is_empty());\n-        let idx = path.rposition_elem(&SEP_BYTE);\n+        let idx = path.as_slice().rposition_elem(&SEP_BYTE);\n         Path{ repr: path, sepidx: idx }\n     }\n \n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_bytes();\n         match self.sepidx {\n-            None if bytes!(\"..\") == self.repr => {\n-                let mut v = slice::with_capacity(3 + filename.len());\n+            None if bytes!(\"..\") == self.repr.as_slice() => {\n+                let mut v = Vec::with_capacity(3 + filename.len());\n                 v.push_all(dot_dot_static);\n                 v.push(SEP_BYTE);\n                 v.push_all(filename);\n-                self.repr = Path::normalize(v);\n+                // FIXME: this is slow\n+                self.repr = Path::normalize(v.as_slice());\n             }\n             None => {\n                 self.repr = Path::normalize(filename);\n             }\n             Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n-                let mut v = slice::with_capacity(self.repr.len() + 1 + filename.len());\n-                v.push_all(self.repr);\n+                let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n+                v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n                 v.push_all(filename);\n-                self.repr = Path::normalize(v);\n+                // FIXME: this is slow\n+                self.repr = Path::normalize(v.as_slice());\n             }\n             Some(idx) => {\n-                let mut v = slice::with_capacity(idx + 1 + filename.len());\n+                let mut v = Vec::with_capacity(idx + 1 + filename.len());\n                 v.push_all(self.repr.slice_to(idx+1));\n                 v.push_all(filename);\n-                self.repr = Path::normalize(v);\n+                // FIXME: this is slow\n+                self.repr = Path::normalize(v.as_slice());\n             }\n         }\n-        self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n+        self.sepidx = self.repr.as_slice().rposition_elem(&SEP_BYTE);\n     }\n \n     unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {\n@@ -159,13 +163,14 @@ impl GenericPathUnsafe for Path {\n             if path[0] == SEP_BYTE {\n                 self.repr = Path::normalize(path);\n             }  else {\n-                let mut v = slice::with_capacity(self.repr.len() + path.len() + 1);\n-                v.push_all(self.repr);\n+                let mut v = Vec::with_capacity(self.repr.len() + path.len() + 1);\n+                v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n                 v.push_all(path);\n-                self.repr = Path::normalize(v);\n+                // FIXME: this is slow\n+                self.repr = Path::normalize(v.as_slice());\n             }\n-            self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n+            self.sepidx = self.repr.as_slice().rposition_elem(&SEP_BYTE);\n         }\n     }\n }\n@@ -176,13 +181,13 @@ impl GenericPath for Path {\n         self.repr.as_slice()\n     }\n \n-    fn into_vec(self) -> ~[u8] {\n+    fn into_vec(self) -> Vec<u8> {\n         self.repr\n     }\n \n     fn dirname<'a>(&'a self) -> &'a [u8] {\n         match self.sepidx {\n-            None if bytes!(\"..\") == self.repr => self.repr.as_slice(),\n+            None if bytes!(\"..\") == self.repr.as_slice() => self.repr.as_slice(),\n             None => dot_static,\n             Some(0) => self.repr.slice_to(1),\n             Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => self.repr.as_slice(),\n@@ -192,7 +197,8 @@ impl GenericPath for Path {\n \n     fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.sepidx {\n-            None if bytes!(\".\") == self.repr || bytes!(\"..\") == self.repr => None,\n+            None if bytes!(\".\") == self.repr.as_slice() ||\n+                bytes!(\"..\") == self.repr.as_slice() => None,\n             None => Some(self.repr.as_slice()),\n             Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => None,\n             Some(0) if self.repr.slice_from(1).is_empty() => None,\n@@ -202,20 +208,20 @@ impl GenericPath for Path {\n \n     fn pop(&mut self) -> bool {\n         match self.sepidx {\n-            None if bytes!(\".\") == self.repr => false,\n+            None if bytes!(\".\") == self.repr.as_slice() => false,\n             None => {\n-                self.repr = ~['.' as u8];\n+                self.repr = vec!['.' as u8];\n                 self.sepidx = None;\n                 true\n             }\n-            Some(0) if bytes!(\"/\") == self.repr => false,\n+            Some(0) if bytes!(\"/\") == self.repr.as_slice() => false,\n             Some(idx) => {\n                 if idx == 0 {\n                     self.repr.truncate(idx+1);\n                 } else {\n                     self.repr.truncate(idx);\n                 }\n-                self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n+                self.sepidx = self.repr.as_slice().rposition_elem(&SEP_BYTE);\n                 true\n             }\n         }\n@@ -231,7 +237,7 @@ impl GenericPath for Path {\n \n     #[inline]\n     fn is_absolute(&self) -> bool {\n-        self.repr[0] == SEP_BYTE\n+        *self.repr.get(0) == SEP_BYTE\n     }\n \n     fn is_ancestor_of(&self, other: &Path) -> bool {\n@@ -240,7 +246,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.components();\n             let mut itb = other.components();\n-            if bytes!(\".\") == self.repr {\n+            if bytes!(\".\") == self.repr.as_slice() {\n                 return match itb.next() {\n                     None => true,\n                     Some(b) => b != bytes!(\"..\")\n@@ -261,6 +267,7 @@ impl GenericPath for Path {\n         }\n     }\n \n+    #[allow(deprecated_owned_vector)]\n     fn path_relative_from(&self, base: &Path) -> Option<Path> {\n         if self.is_absolute() != base.is_absolute() {\n             if self.is_absolute() {\n@@ -271,7 +278,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.components();\n             let mut itb = base.components();\n-            let mut comps = ~[];\n+            let mut comps = vec![];\n             loop {\n                 match (ita.next(), itb.next()) {\n                     (None, None) => break,\n@@ -295,7 +302,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::new(comps.connect_vec(&SEP_BYTE)))\n+            Some(Path::new(comps.as_slice().connect_vec(&SEP_BYTE)))\n         }\n     }\n \n@@ -334,7 +341,7 @@ impl Path {\n \n     /// Returns a normalized byte vector representation of a path, by removing all empty\n     /// components, and unnecessary . and .. components.\n-    fn normalize<V: Vector<u8>+CloneableVector<u8>>(v: V) -> ~[u8] {\n+    fn normalize<V: Vector<u8>+CloneableVector<u8>>(v: V) -> Vec<u8> {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;\n@@ -344,11 +351,11 @@ impl Path {\n                 None => None,\n                 Some(comps) => {\n                     if is_abs && comps.is_empty() {\n-                        Some(~[SEP_BYTE])\n+                        Some(vec![SEP_BYTE])\n                     } else {\n                         let n = if is_abs { comps.len() } else { comps.len() - 1} +\n                                 comps.iter().map(|v| v.len()).sum();\n-                        let mut v = slice::with_capacity(n);\n+                        let mut v = Vec::with_capacity(n);\n                         let mut it = comps.move_iter();\n                         if !is_abs {\n                             match it.next() {\n@@ -366,7 +373,7 @@ impl Path {\n             }\n         };\n         match val {\n-            None => v.into_owned(),\n+            None => Vec::from_slice(v.as_slice()),\n             Some(val) => val\n         }\n     }\n@@ -376,7 +383,7 @@ impl Path {\n     /// /a/b/c and a/b/c yield the same set of components.\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn components<'a>(&'a self) -> Components<'a> {\n-        let v = if self.repr[0] == SEP_BYTE {\n+        let v = if *self.repr.get(0) == SEP_BYTE {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n         let mut ret = v.split(is_sep_byte);\n@@ -390,7 +397,7 @@ impl Path {\n     /// Returns an iterator that yields each component of the path in reverse.\n     /// See components() for details.\n     pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {\n-        let v = if self.repr[0] == SEP_BYTE {\n+        let v = if *self.repr.get(0) == SEP_BYTE {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n         let mut ret = v.rsplit(is_sep_byte);\n@@ -415,11 +422,11 @@ impl Path {\n }\n \n // None result means the byte vector didn't need normalizing\n-fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<~[&'a [u8]]> {\n+fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> {\n     if is_abs && v.as_slice().is_empty() {\n         return None;\n     }\n-    let mut comps: ~[&'a [u8]] = ~[];\n+    let mut comps: Vec<&'a [u8]> = vec![];\n     let mut n_up = 0u;\n     let mut changed = false;\n     for comp in v.split(is_sep_byte) {\n@@ -511,9 +518,9 @@ mod tests {\n         t!(s: Path::new(\"foo/../../..\"), \"../..\");\n         t!(s: Path::new(\"foo/../../bar\"), \"../bar\");\n \n-        assert!(Path::new(b!(\"foo/bar\")).into_vec() == b!(\"foo/bar\").to_owned());\n-        assert!(Path::new(b!(\"/foo/../../bar\")).into_vec() ==\n-                   b!(\"/bar\").to_owned());\n+        assert_eq!(Path::new(b!(\"foo/bar\")).into_vec().as_slice(), b!(\"foo/bar\"));\n+        assert_eq!(Path::new(b!(\"/foo/../../bar\")).into_vec().as_slice(),\n+                   b!(\"/bar\"));\n \n         let p = Path::new(b!(\"foo/bar\", 0x80));\n         assert!(p.as_str() == None);\n@@ -762,7 +769,7 @@ mod tests {\n         t!(s: \"a/b/c\", [~\"d\", ~\"e\"], \"a/b/c/d/e\");\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"/e\"), b!(\"f\")], b!(\"/e/f\"));\n-        t!(v: b!(\"a/b/c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a/b/c/d/e\"));\n+        t!(v: b!(\"a/b/c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))], b!(\"a/b/c/d/e\"));\n     }\n \n     #[test]\n@@ -866,7 +873,7 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n         t!(s: \"a/b/c\", [~\"d\", ~\"e\"], \"a/b/c/d/e\");\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n-        t!(v: b!(\"a/b/c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a/b/c/d/e\"));\n+        t!(v: b!(\"a/b/c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))], b!(\"a/b/c/d/e\"));\n     }\n \n     #[test]\n@@ -1179,29 +1186,26 @@ mod tests {\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    let comps = path.components().collect::<~[&[u8]]>();\n+                    let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&str] = $exp;\n-                    let exps = exp.iter().map(|x| x.as_bytes()).collect::<~[&[u8]]>();\n+                    let exps = exp.iter().map(|x| x.as_bytes()).collect::<Vec<&[u8]>>();\n                     assert!(comps == exps, \"components: Expected {:?}, found {:?}\",\n                             comps, exps);\n-                    let comps = path.rev_components().collect::<~[&[u8]]>();\n-                    let exps = exps.move_rev_iter().collect::<~[&[u8]]>();\n+                    let comps = path.rev_components().collect::<Vec<&[u8]>>();\n+                    let exps = exps.move_iter().rev().collect::<Vec<&[u8]>>();\n                     assert!(comps == exps, \"rev_components: Expected {:?}, found {:?}\",\n                             comps, exps);\n                 }\n             );\n             (v: [$($arg:expr),+], [$([$($exp:expr),*]),*]) => (\n                 {\n                     let path = Path::new(b!($($arg),+));\n-                    let comps = path.components().collect::<~[&[u8]]>();\n+                    let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&[u8]] = [$(b!($($exp),*)),*];\n-                    assert!(comps.as_slice() == exp, \"components: Expected {:?}, found {:?}\",\n-                            comps.as_slice(), exp);\n-                    let comps = path.rev_components().collect::<~[&[u8]]>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<~[&[u8]]>();\n-                    assert!(comps.as_slice() == exp,\n-                            \"rev_components: Expected {:?}, found {:?}\",\n-                            comps.as_slice(), exp);\n+                    assert_eq!(comps.as_slice(), exp);\n+                    let comps = path.rev_components().collect::<Vec<&[u8]>>();\n+                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<&[u8]>>();\n+                    assert_eq!(comps, exp)\n                 }\n             )\n         )\n@@ -1228,16 +1232,12 @@ mod tests {\n             (v: [$($arg:expr),+], $exp:expr) => (\n                 {\n                     let path = Path::new(b!($($arg),+));\n-                    let comps = path.str_components().collect::<~[Option<&str>]>();\n+                    let comps = path.str_components().collect::<Vec<Option<&str>>>();\n                     let exp: &[Option<&str>] = $exp;\n-                    assert!(comps.as_slice() == exp,\n-                            \"str_components: Expected {:?}, found {:?}\",\n-                            comps.as_slice(), exp);\n-                    let comps = path.rev_str_components().collect::<~[Option<&str>]>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<~[Option<&str>]>();\n-                    assert!(comps.as_slice() == exp,\n-                            \"rev_str_components: Expected {:?}, found {:?}\",\n-                            comps.as_slice(), exp);\n+                    assert_eq!(comps.as_slice(), exp);\n+                    let comps = path.rev_str_components().collect::<Vec<Option<&str>>>();\n+                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<Option<&str>>>();\n+                    assert_eq!(comps, exp);\n                 }\n             )\n         )"}, {"sha": "435b64e8d2afd82451395a47a268bc851947a371", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 103, "deletions": 105, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/5dd94d86c64eb13382b3230c9a22c1e59d1e361a/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd94d86c64eb13382b3230c9a22c1e59d1e361a/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=5dd94d86c64eb13382b3230c9a22c1e59d1e361a", "patch": "@@ -22,8 +22,9 @@ use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Rev, Iterator, Map\n use option::{Option, Some, None};\n use slice::{Vector, OwnedVector, ImmutableVector};\n use str::{CharSplits, OwnedStr, Str, StrVector, StrSlice};\n-use str;\n use strbuf::StrBuf;\n+use vec::Vec;\n+\n use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &str\n@@ -82,7 +83,7 @@ pub type RevComponents<'a> = Map<'a, Option<&'a str>, &'a [u8],\n // preserved by the data structure; let the Windows API error out on them.\n #[deriving(Clone)]\n pub struct Path {\n-    repr: ~str, // assumed to never be empty\n+    repr: StrBuf, // assumed to never be empty\n     prefix: Option<PathPrefix>,\n     sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr\n }\n@@ -128,7 +129,7 @@ impl BytesContainer for Path {\n         self.as_vec()\n     }\n     #[inline]\n-    fn container_into_owned_bytes(self) -> ~[u8] {\n+    fn container_into_owned_bytes(self) -> Vec<u8> {\n         self.into_vec()\n     }\n     #[inline]\n@@ -175,7 +176,7 @@ impl GenericPathUnsafe for Path {\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_str().unwrap();\n         match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr => {\n+            None if \"..\" == self.repr.as_slice() => {\n                 let mut s = StrBuf::with_capacity(3 + filename.len());\n                 s.push_str(\"..\");\n                 s.push_char(SEP);\n@@ -185,22 +186,22 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.update_normalized(filename);\n             }\n-            Some((_,idxa,end)) if self.repr.slice(idxa,end) == \"..\" => {\n+            Some((_,idxa,end)) if self.repr.as_slice().slice(idxa,end) == \"..\" => {\n                 let mut s = StrBuf::with_capacity(end + 1 + filename.len());\n-                s.push_str(self.repr.slice_to(end));\n+                s.push_str(self.repr.as_slice().slice_to(end));\n                 s.push_char(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n             Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n                 let mut s = StrBuf::with_capacity(idxb + filename.len());\n-                s.push_str(self.repr.slice_to(idxb));\n+                s.push_str(self.repr.as_slice().slice_to(idxb));\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n             Some((idxb,_,_)) => {\n                 let mut s = StrBuf::with_capacity(idxb + 1 + filename.len());\n-                s.push_str(self.repr.slice_to(idxb));\n+                s.push_str(self.repr.as_slice().slice_to(idxb));\n                 s.push_char(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n@@ -227,9 +228,10 @@ impl GenericPathUnsafe for Path {\n         }\n         fn shares_volume(me: &Path, path: &str) -> bool {\n             // path is assumed to have a prefix of Some(DiskPrefix)\n+            let repr = me.repr.as_slice();\n             match me.prefix {\n-                Some(DiskPrefix) => me.repr[0] == path[0].to_ascii().to_upper().to_byte(),\n-                Some(VerbatimDiskPrefix) => me.repr[4] == path[0].to_ascii().to_upper().to_byte(),\n+                Some(DiskPrefix) => repr[0] == path[0].to_ascii().to_upper().to_byte(),\n+                Some(VerbatimDiskPrefix) => repr[4] == path[0].to_ascii().to_upper().to_byte(),\n                 _ => false\n             }\n         }\n@@ -242,7 +244,7 @@ impl GenericPathUnsafe for Path {\n             let newpath = Path::normalize__(path, prefix);\n             me.repr = match newpath {\n                 Some(p) => p,\n-                None => path.to_owned()\n+                None => StrBuf::from_str(path)\n             };\n             me.prefix = prefix;\n             me.update_sepidx();\n@@ -254,19 +256,19 @@ impl GenericPathUnsafe for Path {\n                         else { None };\n             let pathlen = path_.as_ref().map_or(path.len(), |p| p.len());\n             let mut s = StrBuf::with_capacity(me.repr.len() + 1 + pathlen);\n-            s.push_str(me.repr);\n+            s.push_str(me.repr.as_slice());\n             let plen = me.prefix_len();\n             // if me is \"C:\" we don't want to add a path separator\n             match me.prefix {\n                 Some(DiskPrefix) if me.repr.len() == plen => (),\n-                _ if !(me.repr.len() > plen && me.repr[me.repr.len()-1] == SEP_BYTE) => {\n+                _ if !(me.repr.len() > plen && me.repr.as_slice()[me.repr.len()-1] == SEP_BYTE) => {\n                     s.push_char(SEP);\n                 }\n                 _ => ()\n             }\n             match path_ {\n                 None => s.push_str(path),\n-                Some(p) => s.push_str(p)\n+                Some(p) => s.push_str(p.as_slice())\n             };\n             me.update_normalized(s)\n         }\n@@ -331,8 +333,8 @@ impl GenericPath for Path {\n     }\n \n     #[inline]\n-    fn into_vec(self) -> ~[u8] {\n-        self.repr.into_bytes()\n+    fn into_vec(self) -> Vec<u8> {\n+        Vec::from_slice(self.repr.as_bytes())\n     }\n \n     #[inline]\n@@ -344,21 +346,21 @@ impl GenericPath for Path {\n     /// Always returns a `Some` value.\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n         Some(match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr => self.repr.as_slice(),\n+            None if \"..\" == self.repr.as_slice() => self.repr.as_slice(),\n             None => \".\",\n-            Some((_,idxa,end)) if self.repr.slice(idxa, end) == \"..\" => {\n+            Some((_,idxa,end)) if self.repr.as_slice().slice(idxa, end) == \"..\" => {\n                 self.repr.as_slice()\n             }\n-            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => {\n+            Some((idxb,_,end)) if self.repr.as_slice().slice(idxb, end) == \"\\\\\" => {\n                 self.repr.as_slice()\n             }\n-            Some((0,idxa,_)) => self.repr.slice_to(idxa),\n+            Some((0,idxa,_)) => self.repr.as_slice().slice_to(idxa),\n             Some((idxb,idxa,_)) => {\n                 match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) if idxb == self.prefix_len() => {\n-                        self.repr.slice_to(idxa)\n+                        self.repr.as_slice().slice_to(idxa)\n                     }\n-                    _ => self.repr.slice_to(idxb)\n+                    _ => self.repr.as_slice().slice_to(idxb)\n                 }\n             }\n         })\n@@ -372,12 +374,13 @@ impl GenericPath for Path {\n     /// See `GenericPath::filename_str` for info.\n     /// Always returns a `Some` value if `filename` returns a `Some` value.\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n+        let repr = self.repr.as_slice();\n         match self.sepidx_or_prefix_len() {\n-            None if \".\" == self.repr || \"..\" == self.repr => None,\n-            None => Some(self.repr.as_slice()),\n-            Some((_,idxa,end)) if self.repr.slice(idxa, end) == \"..\" => None,\n+            None if \".\" == repr || \"..\" == repr => None,\n+            None => Some(repr),\n+            Some((_,idxa,end)) if repr.slice(idxa, end) == \"..\" => None,\n             Some((_,idxa,end)) if idxa == end => None,\n-            Some((_,idxa,end)) => Some(self.repr.slice(idxa, end))\n+            Some((_,idxa,end)) => Some(repr.slice(idxa, end))\n         }\n     }\n \n@@ -402,14 +405,14 @@ impl GenericPath for Path {\n     #[inline]\n     fn pop(&mut self) -> bool {\n         match self.sepidx_or_prefix_len() {\n-            None if \".\" == self.repr => false,\n+            None if \".\" == self.repr.as_slice() => false,\n             None => {\n-                self.repr = ~\".\";\n+                self.repr = StrBuf::from_str(\".\");\n                 self.sepidx = None;\n                 true\n             }\n             Some((idxb,idxa,end)) if idxb == idxa && idxb == end => false,\n-            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => false,\n+            Some((idxb,_,end)) if self.repr.as_slice().slice(idxb, end) == \"\\\\\" => false,\n             Some((idxb,idxa,_)) => {\n                 let trunc = match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) | None => {\n@@ -429,15 +432,15 @@ impl GenericPath for Path {\n         if self.prefix.is_some() {\n             Some(Path::new(match self.prefix {\n                 Some(DiskPrefix) if self.is_absolute() => {\n-                    self.repr.slice_to(self.prefix_len()+1)\n+                    self.repr.as_slice().slice_to(self.prefix_len()+1)\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    self.repr.slice_to(self.prefix_len()+1)\n+                    self.repr.as_slice().slice_to(self.prefix_len()+1)\n                 }\n-                _ => self.repr.slice_to(self.prefix_len())\n+                _ => self.repr.as_slice().slice_to(self.prefix_len())\n             }))\n         } else if is_vol_relative(self) {\n-            Some(Path::new(self.repr.slice_to(1)))\n+            Some(Path::new(self.repr.as_slice().slice_to(1)))\n         } else {\n             None\n         }\n@@ -456,7 +459,7 @@ impl GenericPath for Path {\n     fn is_absolute(&self) -> bool {\n         match self.prefix {\n             Some(DiskPrefix) => {\n-                let rest = self.repr.slice_from(self.prefix_len());\n+                let rest = self.repr.as_slice().slice_from(self.prefix_len());\n                 rest.len() > 0 && rest[0] == SEP_BYTE\n             }\n             Some(_) => true,\n@@ -478,7 +481,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.str_components().map(|x|x.unwrap());\n             let mut itb = other.str_components().map(|x|x.unwrap());\n-            if \".\" == self.repr {\n+            if \".\" == self.repr.as_slice() {\n                 return itb.next() != Some(\"..\");\n             }\n             loop {\n@@ -526,7 +529,7 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.str_components().map(|x|x.unwrap());\n             let mut itb = base.str_components().map(|x|x.unwrap());\n-            let mut comps = ~[];\n+            let mut comps = vec![];\n \n             let a_verb = is_verbatim(self);\n             let b_verb = is_verbatim(base);\n@@ -613,15 +616,16 @@ impl Path {\n     /// Does not distinguish between absolute and cwd-relative paths, e.g.\n     /// C:\\foo and C:foo.\n     pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n+        let repr = self.repr.as_slice();\n         let s = match self.prefix {\n             Some(_) => {\n                 let plen = self.prefix_len();\n-                if self.repr.len() > plen && self.repr[plen] == SEP_BYTE {\n-                    self.repr.slice_from(plen+1)\n-                } else { self.repr.slice_from(plen) }\n+                if repr.len() > plen && repr[plen] == SEP_BYTE {\n+                    repr.slice_from(plen+1)\n+                } else { repr.slice_from(plen) }\n             }\n-            None if self.repr[0] == SEP_BYTE => self.repr.slice_from(1),\n-            None => self.repr.as_slice()\n+            None if repr[0] == SEP_BYTE => repr.slice_from(1),\n+            None => repr\n         };\n         let ret = s.split_terminator(SEP).map(Some);\n         ret\n@@ -654,54 +658,56 @@ impl Path {\n     }\n \n     fn equiv_prefix(&self, other: &Path) -> bool {\n+        let s_repr = self.repr.as_slice();\n+        let o_repr = other.repr.as_slice();\n         match (self.prefix, other.prefix) {\n             (Some(DiskPrefix), Some(VerbatimDiskPrefix)) => {\n                 self.is_absolute() &&\n-                    self.repr[0].to_ascii().eq_ignore_case(other.repr[4].to_ascii())\n+                    s_repr[0].to_ascii().eq_ignore_case(o_repr[4].to_ascii())\n             }\n             (Some(VerbatimDiskPrefix), Some(DiskPrefix)) => {\n                 other.is_absolute() &&\n-                    self.repr[4].to_ascii().eq_ignore_case(other.repr[0].to_ascii())\n+                    s_repr[4].to_ascii().eq_ignore_case(o_repr[0].to_ascii())\n             }\n             (Some(VerbatimDiskPrefix), Some(VerbatimDiskPrefix)) => {\n-                self.repr[4].to_ascii().eq_ignore_case(other.repr[4].to_ascii())\n+                s_repr[4].to_ascii().eq_ignore_case(o_repr[4].to_ascii())\n             }\n             (Some(UNCPrefix(_,_)), Some(VerbatimUNCPrefix(_,_))) => {\n-                self.repr.slice(2, self.prefix_len()) == other.repr.slice(8, other.prefix_len())\n+                s_repr.slice(2, self.prefix_len()) == o_repr.slice(8, other.prefix_len())\n             }\n             (Some(VerbatimUNCPrefix(_,_)), Some(UNCPrefix(_,_))) => {\n-                self.repr.slice(8, self.prefix_len()) == other.repr.slice(2, other.prefix_len())\n+                s_repr.slice(8, self.prefix_len()) == o_repr.slice(2, other.prefix_len())\n             }\n             (None, None) => true,\n             (a, b) if a == b => {\n-                self.repr.slice_to(self.prefix_len()) == other.repr.slice_to(other.prefix_len())\n+                s_repr.slice_to(self.prefix_len()) == o_repr.slice_to(other.prefix_len())\n             }\n             _ => false\n         }\n     }\n \n-    fn normalize_<S: Str>(s: S) -> (Option<PathPrefix>, ~str) {\n+    fn normalize_<S: Str>(s: S) -> (Option<PathPrefix>, StrBuf) {\n         // make borrowck happy\n         let (prefix, val) = {\n             let prefix = parse_prefix(s.as_slice());\n             let path = Path::normalize__(s.as_slice(), prefix);\n             (prefix, path)\n         };\n         (prefix, match val {\n-            None => s.into_owned(),\n+            None => s.into_strbuf(),\n             Some(val) => val\n         })\n     }\n \n-    fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<~str> {\n+    fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<StrBuf> {\n         if prefix_is_verbatim(prefix) {\n             // don't do any normalization\n             match prefix {\n                 Some(VerbatimUNCPrefix(x, 0)) if s.len() == 8 + x => {\n                     // the server component has no trailing '\\'\n-                    let mut s = StrBuf::from_owned_str(s.into_owned());\n+                    let mut s = StrBuf::from_str(s);\n                     s.push_char(SEP);\n-                    Some(s.into_owned())\n+                    Some(s)\n                 }\n                 _ => None\n             }\n@@ -711,12 +717,12 @@ impl Path {\n             match (comps.is_some(),prefix) {\n                 (false, Some(DiskPrefix)) => {\n                     if s[0] >= 'a' as u8 && s[0] <= 'z' as u8 {\n-                        comps = Some(~[]);\n+                        comps = Some(vec![]);\n                     }\n                 }\n                 (false, Some(VerbatimDiskPrefix)) => {\n                     if s[4] >= 'a' as u8 && s[0] <= 'z' as u8 {\n-                        comps = Some(~[]);\n+                        comps = Some(vec![]);\n                     }\n                 }\n                 _ => ()\n@@ -728,37 +734,37 @@ impl Path {\n                         match prefix.unwrap() {\n                             DiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = s.slice_to(len).to_owned();\n+                                let mut s = StrBuf::from_str(s.slice_to(len));\n                                 unsafe {\n-                                    str::raw::as_owned_vec(&mut s)[0] =\n-                                        s[0].to_ascii().to_upper().to_byte();\n+                                    let v = s.as_mut_vec();\n+                                    *v.get_mut(0) = v.get(0).to_ascii().to_upper().to_byte();\n                                 }\n                                 if is_abs {\n                                     // normalize C:/ to C:\\\n                                     unsafe {\n-                                        str::raw::as_owned_vec(&mut s)[2] = SEP_BYTE;\n+                                        *s.as_mut_vec().get_mut(2) = SEP_BYTE;\n                                     }\n                                 }\n                                 Some(s)\n                             }\n                             VerbatimDiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = s.slice_to(len).to_owned();\n+                                let mut s = StrBuf::from_str(s.slice_to(len));\n                                 unsafe {\n-                                    str::raw::as_owned_vec(&mut s)[4] =\n-                                        s[4].to_ascii().to_upper().to_byte();\n+                                    let v = s.as_mut_vec();\n+                                    *v.get_mut(4) = v.get(4).to_ascii().to_upper().to_byte();\n                                 }\n                                 Some(s)\n                             }\n                             _ => {\n                                 let plen = prefix_len(prefix);\n                                 if s.len() > plen {\n-                                    Some(s.slice_to(plen).to_owned())\n+                                    Some(StrBuf::from_str(s.slice_to(plen)))\n                                 } else { None }\n                             }\n                         }\n                     } else if is_abs && comps.is_empty() {\n-                        Some(str::from_char(SEP))\n+                        Some(StrBuf::from_char(1, SEP))\n                     } else {\n                         let prefix_ = s.slice_to(prefix_len(prefix));\n                         let n = prefix_.len() +\n@@ -795,7 +801,7 @@ impl Path {\n                             s.push_char(SEP);\n                             s.push_str(comp);\n                         }\n-                        Some(s.into_owned())\n+                        Some(s)\n                     }\n                 }\n             }\n@@ -804,7 +810,7 @@ impl Path {\n \n     fn update_sepidx(&mut self) {\n         let s = if self.has_nonsemantic_trailing_slash() {\n-                    self.repr.slice_to(self.repr.len()-1)\n+                    self.repr.as_slice().slice_to(self.repr.len()-1)\n                 } else { self.repr.as_slice() };\n         let idx = s.rfind(if !prefix_is_verbatim(self.prefix) { is_sep }\n                           else { is_sep_verbatim });\n@@ -834,7 +840,7 @@ impl Path {\n \n     fn has_nonsemantic_trailing_slash(&self) -> bool {\n         is_verbatim(self) && self.repr.len() > self.prefix_len()+1 &&\n-            self.repr[self.repr.len()-1] == SEP_BYTE\n+            self.repr.as_slice()[self.repr.len()-1] == SEP_BYTE\n     }\n \n     fn update_normalized<S: Str>(&mut self, s: S) {\n@@ -850,7 +856,7 @@ impl Path {\n /// but absolute within that volume.\n #[inline]\n pub fn is_vol_relative(path: &Path) -> bool {\n-    path.prefix.is_none() && is_sep_byte(&path.repr[0])\n+    path.prefix.is_none() && is_sep_byte(&path.repr.as_slice()[0])\n }\n \n /// Returns whether the path is considered \"cwd-relative\", which means a path\n@@ -880,16 +886,17 @@ pub fn is_verbatim(path: &Path) -> bool {\n /// non-verbatim, the non-verbatim version is returned.\n /// Otherwise, None is returned.\n pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n+    let repr = path.repr.as_slice();\n     let new_path = match path.prefix {\n         Some(VerbatimPrefix(_)) | Some(DeviceNSPrefix(_)) => return None,\n         Some(UNCPrefix(_,_)) | Some(DiskPrefix) | None => return Some(path.clone()),\n         Some(VerbatimDiskPrefix) => {\n             // \\\\?\\D:\\\n-            Path::new(path.repr.slice_from(4))\n+            Path::new(repr.slice_from(4))\n         }\n         Some(VerbatimUNCPrefix(_,_)) => {\n             // \\\\?\\UNC\\server\\share\n-            Path::new(format!(r\"\\\\{}\", path.repr.slice_from(7)))\n+            Path::new(format!(r\"\\\\{}\", repr.slice_from(7)))\n         }\n     };\n     if new_path.prefix.is_none() {\n@@ -898,7 +905,8 @@ pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n         return None;\n     }\n     // now ensure normalization didn't change anything\n-    if path.repr.slice_from(path.prefix_len()) == new_path.repr.slice_from(new_path.prefix_len()) {\n+    if repr.slice_from(path.prefix_len()) ==\n+        new_path.repr.as_slice().slice_from(new_path.prefix_len()) {\n         Some(new_path)\n     } else {\n         None\n@@ -1023,7 +1031,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n }\n \n // None result means the string didn't need normalizing\n-fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<~[&'a str]>) {\n+fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool, Option<Vec<&'a str>>) {\n     let f = if !prefix_is_verbatim(prefix) { is_sep } else { is_sep_verbatim };\n     let is_abs = s.len() > prefix_len(prefix) && f(s.char_at(prefix_len(prefix)));\n     let s_ = s.slice_from(prefix_len(prefix));\n@@ -1032,11 +1040,11 @@ fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<\n     if is_abs && s_.is_empty() {\n         return (is_abs, match prefix {\n             Some(DiskPrefix) | None => (if is_sep_verbatim(s.char_at(prefix_len(prefix))) { None }\n-                                        else { Some(~[]) }),\n-            Some(_) => Some(~[]), // need to trim the trailing separator\n+                                        else { Some(vec![]) }),\n+            Some(_) => Some(vec![]), // need to trim the trailing separator\n         });\n     }\n-    let mut comps: ~[&'a str] = ~[];\n+    let mut comps: Vec<&'a str> = vec![];\n     let mut n_up = 0u;\n     let mut changed = false;\n     for comp in s_.split(f) {\n@@ -1217,9 +1225,8 @@ mod tests {\n         t!(s: Path::new(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n         t!(s: Path::new(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n \n-        assert_eq!(Path::new(b!(\"foo\\\\bar\")).into_vec(), b!(\"foo\\\\bar\").to_owned());\n-        assert_eq!(Path::new(b!(\"\\\\foo\\\\..\\\\..\\\\bar\")).into_vec(),\n-                   b!(\"\\\\bar\").to_owned());\n+        assert_eq!(Path::new(b!(\"foo\\\\bar\")).into_vec().as_slice(), b!(\"foo\\\\bar\"));\n+        assert_eq!(Path::new(b!(\"\\\\foo\\\\..\\\\..\\\\bar\")).into_vec().as_slice(), b!(\"\\\\bar\"));\n \n         t!(s: Path::new(\"\\\\\\\\a\"), \"\\\\a\");\n         t!(s: Path::new(\"\\\\\\\\a\\\\\"), \"\\\\a\");\n@@ -1573,7 +1580,8 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [~\"d\", ~\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"\\\\e\"), b!(\"f\")], b!(\"\\\\e\\\\f\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n+        t!(v: b!(\"a\\\\b\\\\c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))],\n+           b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n     }\n \n     #[test]\n@@ -1712,7 +1720,8 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n         t!(s: \"a\\\\b\\\\c\", [~\"d\", ~\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n+        t!(v: b!(\"a\\\\b\\\\c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))],\n+           b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n     }\n \n     #[test]\n@@ -2227,33 +2236,25 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let comps = path.str_components().map(|x|x.unwrap())\n-                                .collect::<~[&str]>();\n+                                .collect::<Vec<&str>>();\n                     let exp: &[&str] = $exp;\n-                    assert!(comps.as_slice() == exp,\n-                            \"str_components: Expected {:?}, found {:?}\",\n-                            comps.as_slice(), exp);\n+                    assert_eq!(comps.as_slice(), exp);\n                     let comps = path.rev_str_components().map(|x|x.unwrap())\n-                                .collect::<~[&str]>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<~[&str]>();\n-                    assert!(comps.as_slice() == exp,\n-                            \"rev_str_components: Expected {:?}, found {:?}\",\n-                            comps.as_slice(), exp);\n+                                .collect::<Vec<&str>>();\n+                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<&str>>();\n+                    assert_eq!(comps, exp);\n                 }\n             );\n             (v: [$($arg:expr),+], $exp:expr) => (\n                 {\n                     let path = Path::new(b!($($arg),+));\n-                    let comps = path.str_components().map(|x|x.unwrap()).collect::<~[&str]>();\n+                    let comps = path.str_components().map(|x|x.unwrap()).collect::<Vec<&str>>();\n                     let exp: &[&str] = $exp;\n-                    assert!(comps.as_slice() == exp,\n-                            \"str_components: Expected {:?}, found {:?}\",\n-                            comps.as_slice(), exp);\n+                    assert_eq!(comps.as_slice(), exp);\n                     let comps = path.rev_str_components().map(|x|x.unwrap())\n-                                .collect::<~[&str]>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<~[&str]>();\n-                    assert!(comps.as_slice() == exp,\n-                            \"rev_str_components: Expected {:?}, found {:?}\",\n-                            comps.as_slice(), exp);\n+                                .collect::<Vec<&str>>();\n+                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<&str>>();\n+                    assert_eq!(comps, exp);\n                 }\n             )\n         )\n@@ -2304,15 +2305,12 @@ mod tests {\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    let comps = path.components().collect::<~[&[u8]]>();\n+                    let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&[u8]] = $exp;\n-                    assert!(comps.as_slice() == exp, \"components: Expected {:?}, found {:?}\",\n-                            comps.as_slice(), exp);\n-                    let comps = path.rev_components().collect::<~[&[u8]]>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<~[&[u8]]>();\n-                    assert!(comps.as_slice() == exp,\n-                            \"rev_components: Expected {:?}, found {:?}\",\n-                            comps.as_slice(), exp);\n+                    assert_eq!(comps.as_slice(), exp);\n+                    let comps = path.rev_components().collect::<Vec<&[u8]>>();\n+                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<&[u8]>>();\n+                    assert_eq!(comps, exp);\n                 }\n             )\n         )"}, {"sha": "873b7293032cf86ad3be42a2579fffe7dd6af054", "filename": "src/libstd/strbuf.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5dd94d86c64eb13382b3230c9a22c1e59d1e361a/src%2Flibstd%2Fstrbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd94d86c64eb13382b3230c9a22c1e59d1e361a/src%2Flibstd%2Fstrbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstrbuf.rs?ref=5dd94d86c64eb13382b3230c9a22c1e59d1e361a", "patch": "@@ -229,6 +229,13 @@ impl StrBuf {\n         *self = self.as_slice().slice(1, len).into_strbuf();\n         Some(byte)\n     }\n+\n+    /// Views the string buffer as a mutable sequence of bytes.\n+    ///\n+    /// Callers must preserve the valid UTF-8 property.\n+    pub unsafe fn as_mut_vec<'a>(&'a mut self) -> &'a mut Vec<u8> {\n+        &mut self.vec\n+    }\n }\n \n impl Container for StrBuf {\n@@ -271,6 +278,9 @@ impl Str for StrBuf {\n             cast::transmute::<~[u8],~str>(vec.move_iter().collect())\n         }\n     }\n+\n+    #[inline]\n+    fn into_strbuf(self) -> StrBuf { self }\n }\n \n impl fmt::Show for StrBuf {"}]}