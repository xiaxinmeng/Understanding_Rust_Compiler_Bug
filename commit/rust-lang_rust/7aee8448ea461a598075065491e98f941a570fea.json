{"sha": "7aee8448ea461a598075065491e98f941a570fea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhZWU4NDQ4ZWE0NjFhNTk4MDc1MDY1NDkxZTk4Zjk0MWE1NzBmZWE=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-14T18:07:00Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-14T18:07:00Z"}, "message": "fix all the doc tests", "tree": {"sha": "c8da74b3ad2128f5153e4449e390415809f38d23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8da74b3ad2128f5153e4449e390415809f38d23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7aee8448ea461a598075065491e98f941a570fea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7aee8448ea461a598075065491e98f941a570fea", "html_url": "https://github.com/rust-lang/rust/commit/7aee8448ea461a598075065491e98f941a570fea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7aee8448ea461a598075065491e98f941a570fea/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58f6f2d57a4d0a62f17003facd0d2406da75a035", "url": "https://api.github.com/repos/rust-lang/rust/commits/58f6f2d57a4d0a62f17003facd0d2406da75a035", "html_url": "https://github.com/rust-lang/rust/commit/58f6f2d57a4d0a62f17003facd0d2406da75a035"}], "stats": {"total": 297, "additions": 176, "deletions": 121}, "files": [{"sha": "65bffd7d09feab8ef9014abdeb4aee869c3b73e2", "filename": "src/doc/tarpl/checked-uninit.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -4,7 +4,7 @@ Like C, all stack variables in Rust are uninitialized until a value is\n explicitly assigned to them. Unlike C, Rust statically prevents you from ever\n reading them until you do:\n \n-```rust\n+```rust,ignore\n fn main() {\n     let x: i32;\n     println!(\"{}\", x);\n@@ -39,7 +39,7 @@ fn main() {\n \n but this doesn't:\n \n-```rust\n+```rust,ignore\n fn main() {\n     let x: i32;\n     if true {"}, {"sha": "df0fdfa57ca13939c3fccdebcd35b6e155c0ed4d", "filename": "src/doc/tarpl/coercions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fcoercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fcoercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fcoercions.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -51,7 +51,7 @@ receivers, see below). If there is an impl for some type `U` and `T` coerces to\n following will not type check, even though it is OK to coerce `t` to `&T` and\n there is an impl for `&T`:\n \n-```rust\n+```rust,ignore\n trait Trait {}\n \n fn foo<X: Trait>(t: X) {}"}, {"sha": "e146ae4a1dac39f23f1d8a4f6522a09866ccc6ac", "filename": "src/doc/tarpl/destructors.md", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdestructors.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -3,7 +3,7 @@\n What the language *does* provide is full-blown automatic destructors through the\n `Drop` trait, which provides the following method:\n \n-```rust\n+```rust,ignore\n fn drop(&mut self);\n ```\n \n@@ -23,13 +23,22 @@ this is totally fine.\n For instance, a custom implementation of `Box` might write `Drop` like this:\n \n ```rust\n-struct Box<T>{ ptr: *mut T }\n+#![feature(heap_api, core_intrinsics, unique)]\n+\n+use std::rt::heap;\n+use std::ptr::Unique;\n+use std::intrinsics::drop_in_place;\n+use std::mem;\n+\n+struct Box<T>{ ptr: Unique<T> }\n \n impl<T> Drop for Box<T> {\n     fn drop(&mut self) {\n         unsafe {\n-            (*self.ptr).drop();\n-            heap::deallocate(self.ptr);\n+            drop_in_place(*self.ptr);\n+            heap::deallocate((*self.ptr) as *mut u8,\n+                             mem::size_of::<T>(),\n+                             mem::align_of::<T>());\n         }\n     }\n }\n@@ -42,25 +51,36 @@ after-free the `ptr` because the Box is immediately marked as uninitialized.\n However this wouldn't work:\n \n ```rust\n-struct Box<T>{ ptr: *mut T }\n+#![feature(heap_api, core_intrinsics, unique)]\n+\n+use std::rt::heap;\n+use std::ptr::Unique;\n+use std::intrinsics::drop_in_place;\n+use std::mem;\n+\n+struct Box<T>{ ptr: Unique<T> }\n \n impl<T> Drop for Box<T> {\n     fn drop(&mut self) {\n         unsafe {\n-            (*self.ptr).drop();\n-            heap::deallocate(self.ptr);\n+            drop_in_place(*self.ptr);\n+            heap::deallocate((*self.ptr) as *mut u8,\n+                             mem::size_of::<T>(),\n+                             mem::align_of::<T>());\n         }\n     }\n }\n \n-struct SuperBox<T> { box: Box<T> }\n+struct SuperBox<T> { my_box: Box<T> }\n \n impl<T> Drop for SuperBox<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // Hyper-optimized: deallocate the box's contents for it\n             // without `drop`ing the contents\n-            heap::deallocate(self.box.ptr);\n+            heap::deallocate((*self.my_box.ptr) as *mut u8,\n+                             mem::size_of::<T>(),\n+                             mem::align_of::<T>());\n         }\n     }\n }\n@@ -106,26 +126,39 @@ The classic safe solution to overriding recursive drop and allowing moving out\n of Self during `drop` is to use an Option:\n \n ```rust\n-struct Box<T>{ ptr: *mut T }\n+#![feature(heap_api, core_intrinsics, unique)]\n+\n+use std::rt::heap;\n+use std::ptr::Unique;\n+use std::intrinsics::drop_in_place;\n+use std::mem;\n+\n+struct Box<T>{ ptr: Unique<T> }\n \n impl<T> Drop for Box<T> {\n     fn drop(&mut self) {\n         unsafe {\n-            (*self.ptr).drop();\n-            heap::deallocate(self.ptr);\n+            drop_in_place(*self.ptr);\n+            heap::deallocate((*self.ptr) as *mut u8,\n+                             mem::size_of::<T>(),\n+                             mem::align_of::<T>());\n         }\n     }\n }\n \n-struct SuperBox<T> { box: Option<Box<T>> }\n+struct SuperBox<T> { my_box: Option<Box<T>> }\n \n impl<T> Drop for SuperBox<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // Hyper-optimized: deallocate the box's contents for it\n             // without `drop`ing the contents. Need to set the `box`\n             // field as `None` to prevent Rust from trying to Drop it.\n-            heap::deallocate(self.box.take().unwrap().ptr);\n+            let my_box = self.my_box.take().unwrap();\n+            heap::deallocate((*my_box.ptr) as *mut u8,\n+                             mem::size_of::<T>(),\n+                             mem::align_of::<T>());\n+            mem::forget(my_box);\n         }\n     }\n }"}, {"sha": "e8c331cd05659cf4833257962278df507c4b14c9", "filename": "src/doc/tarpl/drop-flags.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fdrop-flags.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fdrop-flags.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdrop-flags.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -31,6 +31,7 @@ And even branched code where all branches have the same behaviour with respect\n to initialization:\n \n ```rust\n+# let condition = true;\n let mut x = Box::new(0);    // x was uninit; just overwrite.\n if condition {\n     drop(x)                 // x gets moved out; make x uninit.\n@@ -45,6 +46,7 @@ x = Box::new(0);            // x was uninit; just overwrite.\n However code like this *requires* runtime information to correctly Drop:\n \n ```rust\n+# let condition = true;\n let x;\n if condition {\n     x = Box::new(0);        // x was uninit; just overwrite.\n@@ -56,6 +58,7 @@ if condition {\n Of course, in this case it's trivial to retrieve static drop semantics:\n \n ```rust\n+# let condition = true;\n if condition {\n     let x = Box::new(0);\n     println!(\"{}\", x);"}, {"sha": "9a31934090340ada08849c8dec796ca19e0f59ea", "filename": "src/doc/tarpl/exception-safety.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fexception-safety.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fexception-safety.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fexception-safety.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -156,7 +156,7 @@ way to do this is to store the algorithm's state in a separate struct with a\n destructor for the \"finally\" logic. Whether we panic or not, that destructor\n will run and clean up after us.\n \n-```rust\n+```rust,ignore\n struct Hole<'a, T: 'a> {\n     data: &'a mut [T],\n     /// `elt` is always `Some` from new until drop."}, {"sha": "640742f9b1499589ae71141a01230fef04237737", "filename": "src/doc/tarpl/hrtb.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fhrtb.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fhrtb.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fhrtb.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -28,7 +28,7 @@ fn main() {\n If we try to naively desugar this code in the same way that we did in the\n lifetimes section, we run into some trouble:\n \n-```rust\n+```rust,ignore\n struct Closure<F> {\n     data: (u8, u16),\n     func: F,\n@@ -60,7 +60,7 @@ we enter the body of `call`! Also, that isn't some fixed lifetime; call works wi\n This job requires The Magic of Higher-Rank Trait Bounds. The way we desugar\n this is as follows:\n \n-```rust\n+```rust,ignore\n where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n ```\n \n@@ -69,4 +69,4 @@ where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n `for<'a>` can be read as \"for all choices of `'a`\", and basically produces an\n *inifinite list* of trait bounds that F must satisfy. Intense. There aren't many\n places outside of the Fn traits where we encounter HRTBs, and even for those we\n-have a nice magic sugar for the common cases.\n\\ No newline at end of file\n+have a nice magic sugar for the common cases."}, {"sha": "bb6f7bb4bda093ffc5c33931c4ab7d8acc650b4a", "filename": "src/doc/tarpl/leaking.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fleaking.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fleaking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fleaking.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -68,7 +68,7 @@ unwinding-safe! Easy!\n \n Now consider the following:\n \n-```\n+```rust,ignore\n let mut vec = vec![Box::new(0); 4];\n \n {\n@@ -118,7 +118,7 @@ Nope.\n \n Let's consider a simplified implementation of Rc:\n \n-```rust\n+```rust,ignore\n struct Rc<T> {\n     ptr: *mut RcBox<T>,\n }\n@@ -183,7 +183,7 @@ in memory.\n The thread::scoped API intends to allow threads to be spawned that reference\n data on the stack without any synchronization over that data. Usage looked like:\n \n-```rust\n+```rust,ignore\n let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n {\n     let guards = vec![];\n@@ -211,7 +211,7 @@ let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n In principle, this totally works! Rust's ownership system perfectly ensures it!\n ...except it relies on a destructor being called to be safe.\n \n-```\n+```rust,ignore\n let mut data = Box::new(0);\n {\n     let guard = thread::scoped(|| {"}, {"sha": "41014f46dd953827374f55791adf5f7d0ed7b135", "filename": "src/doc/tarpl/lifetime-elision.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Flifetime-elision.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Flifetime-elision.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetime-elision.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -5,7 +5,7 @@ In order to make common patterns more ergonomic, Rust allows lifetimes to be\n \n A *lifetime position* is anywhere you can write a lifetime in a type:\n \n-```rust\n+```rust,ignore\n &'a T\n &'a mut T\n T<'a>\n@@ -38,7 +38,7 @@ Elision rules are as follows:\n \n Examples:\n \n-```rust\n+```rust,ignore\n fn print(s: &str);                                      // elided\n fn print<'a>(s: &'a str);                               // expanded\n \n@@ -61,4 +61,4 @@ fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // exp\n fn new(buf: &mut [u8]) -> BufWriter;                    // elided\n fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>          // expanded\n \n-```\n\\ No newline at end of file\n+```"}, {"sha": "bd44bb6964af513fbf35bce9f4ba22f9c25ee7df", "filename": "src/doc/tarpl/lifetime-misc.md", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Flifetime-misc.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Flifetime-misc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetime-misc.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -10,8 +10,8 @@ types or lifetimes are logically associated with a struct, but not actually\n part of a field. This most commonly occurs with lifetimes. For instance, the `Iter`\n for `&'a [T]` is (approximately) defined as follows:\n \n-```rust\n-pub struct Iter<'a, T: 'a> {\n+```rust,ignore\n+struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n }\n@@ -33,7 +33,9 @@ Iter logically contains `&'a T`, so this is exactly what we tell\n the PhantomData to simulate:\n \n ```\n-pub struct Iter<'a, T: 'a> {\n+use std::marker;\n+\n+struct Iter<'a, T: 'a> {\n     ptr: *const T,\n     end: *const T,\n     _marker: marker::PhantomData<&'a T>,\n@@ -68,6 +70,8 @@ tell dropck that we *do* own values of type T, and may call destructors of that\n type, we must add extra PhantomData:\n \n ```\n+use std::marker;\n+\n struct Vec<T> {\n     data: *const T, // *const for covariance!\n     len: usize,\n@@ -115,7 +119,7 @@ println!(\"{} {} {} {}\", a, b, c, c2);\n However borrowck doesn't understand arrays or slices in any way, so this doesn't\n work:\n \n-```rust\n+```rust,ignore\n let x = [1, 2, 3];\n let a = &mut x[0];\n let b = &mut x[1];\n@@ -144,7 +148,7 @@ left of the index, and one for everything to the right. Intuitively we know this\n is safe because the slices don't alias. However the implementation requires some\n unsafety:\n \n-```rust\n+```rust,ignore\n fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n     unsafe {\n         let self2: &mut [T] = mem::transmute_copy(&self);\n@@ -189,8 +193,8 @@ Whether it's raw pointers, or safely composing on top of *another* IterMut.\n \n For instance, VecDeque's IterMut:\n \n-```rust\n-pub struct IterMut<'a, T:'a> {\n+```rust,ignore\n+struct IterMut<'a, T:'a> {\n     // The whole backing array. Some of these indices are initialized!\n     ring: &'a mut [T],\n     tail: usize,"}, {"sha": "7282e4d843cfd128286f1bd861ff9fcdbf56a600", "filename": "src/doc/tarpl/lifetimes.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetimes.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -38,7 +38,7 @@ let z = &y;\n The borrow checker always tries to minimize the extent of a lifetime, so it will\n likely desugar to the following:\n \n-```rust\n+```rust,ignore\n // NOTE: `'a: {` and `&'b x` is not valid syntax!\n 'a: {\n     let x: i32 = 0;\n@@ -69,8 +69,8 @@ z = y;\n The borrow checker always tries to minimize the extent of a lifetime, so it will\n likely desugar to something like the following:\n \n-```rust\n-// NOTE: `'a: {` and `&'b x` is not valid syntax!\n+```rust,ignore\n+// NOTE: `'a: {` and `foo = &'b x` is not valid syntax!\n 'a: {\n     let x: i32 = 0;\n     'b: {\n@@ -174,14 +174,14 @@ our implementation *just a bit*.)\n \n How about the other example:\n \n-```rust\n+```rust,ignore\n let mut data = vec![1, 2, 3];\n let x = &data[0];\n data.push(4);\n println!(\"{}\", x);\n ```\n \n-```rust\n+```rust,ignore\n 'a: {\n     let mut data: Vec<i32> = vec![1, 2, 3];\n     'b: {\n@@ -219,4 +219,4 @@ semantics we're actually interested in preserving. For the most part, *that's\n totally ok*, because it keeps us from spending all day explaining our program\n to the compiler. However it does mean that several programs that are *totally*\n correct with respect to Rust's *true* semantics are rejected because lifetimes\n-are too dumb.\n\\ No newline at end of file\n+are too dumb."}, {"sha": "200337a2256e300d4dbf504bc79b71b0bb374910", "filename": "src/doc/tarpl/ownership.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fownership.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -16,7 +16,7 @@ issue...). This is a pervasive problem that C and C++ need to deal with.\n Consider this simple mistake that all of us who have used a non-GC'd language\n have made at one point:\n \n-```rust\n+```rust,ignore\n fn as_str(data: &u32) -> &str {\n     // compute the string\n     let s = format!(\"{}\", data);\n@@ -45,7 +45,7 @@ verifying that references don't escape the scope of their referent. That's\n because ensuring pointers are always valid is much more complicated than this.\n For instance in this code,\n \n-```rust\n+```rust,ignore\n let mut data = vec![1, 2, 3];\n // get an internal reference\n let x = &data[0];"}, {"sha": "b3a5a1278c78c3e228c1c7b5d633938411b173ca", "filename": "src/doc/tarpl/repr-rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Frepr-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Frepr-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Frepr-rust.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -67,7 +67,7 @@ fields in the order specified, we expect it to *pad* the values in the struct to\n their *alignment* requirements. So if Rust didn't reorder fields, we would expect Rust to\n produce the following:\n \n-```rust\n+```rust,ignore\n struct Foo<u16, u32> {\n     count: u16,\n     data1: u16,"}, {"sha": "5b00709a1bf40d1045e7a33267ec066410d7b73b", "filename": "src/doc/tarpl/send-and-sync.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -56,6 +56,8 @@ In the *incredibly rare* case that a type is *inappropriately* automatically\n derived to be Send or Sync, then one can also *unimplement* Send and Sync:\n \n ```rust\n+#![feature(optin_builtin_traits)]\n+\n struct SpecialThreadToken(u8);\n \n impl !Send for SpecialThreadToken {}"}, {"sha": "e43c365bf4f71e90223577e727d617e598a9be6e", "filename": "src/doc/tarpl/subtyping.md", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsubtyping.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -104,7 +104,7 @@ However what should happen when passing *by-value* is less obvious. It turns out\n that, yes, you can use subtyping when passing by-value. That is, this works:\n \n ```rust\n-fn get_box<'a>(&'a u8) -> Box<&'a str> {\n+fn get_box<'a>(str: &'a u8) -> Box<&'a str> {\n     // string literals are `&'static str`s\n     Box::new(\"hello\")\n }\n@@ -123,15 +123,15 @@ must be invariant to avoid lifetime smuggling.\n `Fn(T) -> U` should be invariant over T, consider the following function\n signature:\n \n-```rust\n+```rust,ignore\n // 'a is derived from some parent scope\n fn foo(&'a str) -> usize;\n ```\n \n This signature claims that it can handle any `&str` that lives *at least* as long\n as `'a`. Now if this signature was variant with respect to `&str`, that would mean\n \n-```rust\n+```rust,ignore\n fn foo(&'static str) -> usize;\n ```\n \n@@ -142,15 +142,15 @@ and nothing else. Therefore functions are not variant over their arguments.\n To see why `Fn(T) -> U` should be *variant* over U, consider the following\n function signature:\n \n-```rust\n+```rust,ignore\n // 'a is derived from some parent scope\n fn foo(usize) -> &'a str;\n ```\n \n This signature claims that it will return something that outlives `'a`. It is\n therefore completely reasonable to provide\n \n-```rust\n+```rust,ignore\n fn foo(usize) -> &'static str;\n ```\n \n@@ -171,15 +171,17 @@ in multiple fields.\n * Otherwise, Foo is invariant over A\n \n ```rust\n-struct Foo<'a, 'b, A, B, C, D, E, F, G, H> {\n+use std::cell::Cell;\n+\n+struct Foo<'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H> {\n     a: &'a A,     // variant over 'a and A\n     b: &'b mut B, // invariant over 'b and B\n     c: *const C,  // variant over C\n     d: *mut D,    // invariant over D\n     e: Vec<E>,    // variant over E\n     f: Cell<F>,   // invariant over F\n-    g: G          // variant over G\n-    h1: H         // would also be variant over H except...\n-    h2: Cell<H>   // invariant over H, because invariance wins\n+    g: G,         // variant over G\n+    h1: H,        // would also be variant over H except...\n+    h2: Cell<H>,  // invariant over H, because invariance wins\n }\n-```\n\\ No newline at end of file\n+```"}, {"sha": "b540ab4ed5d999d5c70c972fc207bd3df7c76415", "filename": "src/doc/tarpl/unbounded-lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Funbounded-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Funbounded-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Funbounded-lifetimes.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -17,7 +17,7 @@ boundaries.\n Given a function, any output lifetimes that don't derive from inputs are\n unbounded. For instance:\n \n-```rust\n+```rust,ignore\n fn get_str<'a>() -> &'a str;\n ```\n "}, {"sha": "9ab97b9e2d2d23bdaace2ef2c744a4ea858e2d77", "filename": "src/doc/tarpl/unchecked-uninit.md", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Funchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Funchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Funchecked-uninit.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -46,27 +46,26 @@ locations of memory can break things are basically uncountable!\n Putting this all together, we get the following:\n \n ```rust\n-fn main() {\n-\tuse std::mem;\n-\n-\t// size of the array is hard-coded but easy to change. This means we can't\n-\t// use [a, b, c] syntax to initialize the array, though!\n-\tconst SIZE = 10;\n-\n-\tlet x: [Box<u32>; SIZE];\n-\n-\tunsafe {\n-\t\t// convince Rust that x is Totally Initialized\n-\t\tx = mem::uninitialized();\n-\t\tfor i in 0..SIZE {\n-\t\t\t// very carefully overwrite each index without reading it\n-\t\t\t// NOTE: exception safety is not a concern; Box can't panic\n-\t\t\tptr::write(&mut x[i], Box::new(i));\n-\t\t}\n+use std::mem;\n+use std::ptr;\n+\n+// size of the array is hard-coded but easy to change. This means we can't\n+// use [a, b, c] syntax to initialize the array, though!\n+const SIZE: usize = 10;\n+\n+let mut x: [Box<u32>; SIZE];\n+\n+unsafe {\n+\t// convince Rust that x is Totally Initialized\n+\tx = mem::uninitialized();\n+\tfor i in 0..SIZE {\n+\t\t// very carefully overwrite each index without reading it\n+\t\t// NOTE: exception safety is not a concern; Box can't panic\n+\t\tptr::write(&mut x[i], Box::new(i as u32));\n \t}\n-\n-\tprintln!(\"{}\", x);\n }\n+\n+println!(\"{:?}\", x);\n ```\n \n It's worth noting that you don't need to worry about ptr::write-style\n@@ -83,4 +82,4 @@ before it ends, if has a destructor.\n \n And that's about it for working with uninitialized memory! Basically nothing\n anywhere expects to be handed uninitialized memory, so if you're going to pass\n-it around at all, be sure to be *really* careful.\n\\ No newline at end of file\n+it around at all, be sure to be *really* careful."}, {"sha": "e9c9f681ed84a9a15f525f298f02ae11415cd111", "filename": "src/doc/tarpl/vec-alloc.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-alloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-alloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-alloc.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -2,7 +2,7 @@\n \n So:\n \n-```rust\n+```rust,ignore\n #![feature(heap_api)]\n \n use std::rt::heap::EMPTY;\n@@ -69,7 +69,7 @@ Anything else will use up too much space.\n However since this is a tutorial, we're not going to be particularly optimal here,\n and just unconditionally check, rather than use clever platform-specific `cfg`s.\n \n-```rust\n+```rust,ignore\n fn grow(&mut self) {\n     // this is all pretty delicate, so let's say it's all unsafe\n     unsafe {"}, {"sha": "2ae2477bbacdb0a7412ce23f0af8bea88153f185", "filename": "src/doc/tarpl/vec-dealloc.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-dealloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-dealloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-dealloc.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -11,13 +11,13 @@ We must not call `heap::deallocate` when `self.cap == 0`, as in this case we hav\n actually allocated any memory.\n \n \n-```rust\n+```rust,ignore\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         if self.cap != 0 {\n             while let Some(_) = self.pop() { }\n \n-            let align = mem::min_align_of::<T>();\n+            let align = mem::align_of::<T>();\n             let elem_size = mem::size_of::<T>();\n             let num_bytes = elem_size * self.cap;\n             unsafe {"}, {"sha": "826d763f5bbcb730b24d4e755c072ead37e98f11", "filename": "src/doc/tarpl/vec-deref.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-deref.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-deref.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-deref.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -9,7 +9,7 @@ conditions.\n \n All we need is `slice::from_raw_parts`.\n \n-```rust\n+```rust,ignore\n use std::ops::Deref;\n \n impl<T> Deref for Vec<T> {\n@@ -24,7 +24,7 @@ impl<T> Deref for Vec<T> {\n \n And let's do DerefMut too:\n \n-```rust\n+```rust,ignore\n use std::ops::DerefMut;\n \n impl<T> DerefMut for Vec<T> {"}, {"sha": "8dd085d6ebcd8763827c447c5d10b27b3891d961", "filename": "src/doc/tarpl/vec-drain.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-drain.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -51,7 +51,7 @@ impl<T> RawValIter<T> {\n \n And IntoIter becomes the following:\n \n-```\n+```rust,ignore\n pub struct IntoIter<T> {\n     _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n     iter: RawValIter<T>,\n@@ -96,7 +96,7 @@ We also take a slice to simplify Drain initialization.\n \n Alright, now Drain is really easy:\n \n-```rust\n+```rust,ignore\n use std::marker::PhantomData;\n \n pub struct Drain<'a, T: 'a> {\n@@ -174,7 +174,7 @@ overflow for zero-sized types.\n Due to our current architecture, all this means is writing 3 guards, one in each\n method of RawVec.\n \n-```rust\n+```rust,ignore\n impl<T> RawVec<T> {\n     fn new() -> Self {\n         unsafe {\n@@ -194,7 +194,7 @@ impl<T> RawVec<T> {\n             // 0, getting to here necessarily means the Vec is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            let align = mem::min_align_of::<T>();\n+            let align = mem::align_of::<T>();\n \n             let (new_cap, ptr) = if self.cap == 0 {\n                 let ptr = heap::allocate(elem_size, align);\n@@ -223,7 +223,7 @@ impl<T> Drop for RawVec<T> {\n \n         // don't free zero-sized allocations, as they were never allocated.\n         if self.cap != 0 && elem_size != 0 {\n-            let align = mem::min_align_of::<T>();\n+            let align = mem::align_of::<T>();\n \n             let num_bytes = elem_size * self.cap;\n             unsafe {\n@@ -247,7 +247,7 @@ initialize `start` and `end` as the same value, and our iterators will yield\n nothing. The current solution to this is to cast the pointers to integers,\n increment, and then cast them back:\n \n-```\n+```rust,ignore\n impl<T> RawValIter<T> {\n     unsafe fn new(slice: &[T]) -> Self {\n         RawValIter {\n@@ -270,7 +270,7 @@ Also, our size_hint computation code will divide by 0 for ZSTs. Since we'll\n basically be treating the two pointers as if they point to bytes, we'll just\n map size 0 to divide by 1.\n \n-```\n+```rust,ignore\n impl<T> Iterator for RawValIter<T> {\n     type Item = T;\n     fn next(&mut self) -> Option<T> {\n@@ -315,4 +315,4 @@ impl<T> DoubleEndedIterator for RawValIter<T> {\n }\n ```\n \n-And that's it. Iteration works!\n\\ No newline at end of file\n+And that's it. Iteration works!"}, {"sha": "847957e2ea977d048c1ab09c0a48c0801ce484bb", "filename": "src/doc/tarpl/vec-final.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-final.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-final.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-final.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -38,7 +38,7 @@ impl<T> RawVec<T> {\n             // 0, getting to here necessarily means the Vec is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            let align = mem::min_align_of::<T>();\n+            let align = mem::align_of::<T>();\n \n             let (new_cap, ptr) = if self.cap == 0 {\n                 let ptr = heap::allocate(elem_size, align);\n@@ -65,7 +65,7 @@ impl<T> Drop for RawVec<T> {\n     fn drop(&mut self) {\n         let elem_size = mem::size_of::<T>();\n         if self.cap != 0 && elem_size != 0 {\n-            let align = mem::min_align_of::<T>();\n+            let align = mem::align_of::<T>();\n \n             let num_bytes = elem_size * self.cap;\n             unsafe {\n@@ -306,4 +306,6 @@ impl<'a, T> Drop for Drain<'a, T> {\n fn oom() {\n     ::std::process::exit(-9999);\n }\n-```\n\\ No newline at end of file\n+\n+# fn main() {}\n+```"}, {"sha": "f21ed227d84ca10cc9353fc35e07bddd6cccab88", "filename": "src/doc/tarpl/vec-insert-remove.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -11,7 +11,7 @@ here).\n If we insert at index `i`, we want to shift the `[i .. len]` to `[i+1 .. len+1]`\n using the *old* len.\n \n-```rust\n+```rust,ignore\n pub fn insert(&mut self, index: usize, elem: T) {\n     // Note: `<=` because it's valid to insert after everything\n     // which would be equivalent to push.\n@@ -34,7 +34,7 @@ pub fn insert(&mut self, index: usize, elem: T) {\n Remove behaves in the opposite manner. We need to shift all the elements from\n `[i+1 .. len + 1]` to `[i .. len]` using the *new* len.\n \n-```rust\n+```rust,ignore\n pub fn remove(&mut self, index: usize) -> T {\n     // Note: `<` because it's *not* valid to remove after everything\n     assert!(index < self.len, \"index out of bounds\");\n@@ -47,4 +47,4 @@ pub fn remove(&mut self, index: usize) -> T {\n         result\n     }\n }\n-```\n\\ No newline at end of file\n+```"}, {"sha": "d21cf940fcc10814e50d2c872bffc2236813cc08", "filename": "src/doc/tarpl/vec-into-iter.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -37,7 +37,7 @@ indistinguishable from the case where there are no more elements to yield.\n \n So we're going to use the following struct:\n \n-```rust\n+```rust,ignore\n struct IntoIter<T> {\n     buf: Unique<T>,\n     cap: usize,\n@@ -63,7 +63,7 @@ cap or len being 0 to not do the offset.\n \n So this is what we end up with for initialization:\n \n-```rust\n+```rust,ignore\n impl<T> Vec<T> {\n     fn into_iter(self) -> IntoIter<T> {\n         // Can't destructure Vec since it's Drop\n@@ -93,7 +93,7 @@ impl<T> Vec<T> {\n \n Here's iterating forward:\n \n-```rust\n+```rust,ignore\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n     fn next(&mut self) -> Option<T> {\n@@ -118,7 +118,7 @@ impl<T> Iterator for IntoIter<T> {\n \n And here's iterating backwards.\n \n-```rust\n+```rust,ignore\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     fn next_back(&mut self) -> Option<T> {\n         if self.start == self.end {\n@@ -138,14 +138,14 @@ to free it. However it *also* wants to implement Drop to drop any elements it\n contains that weren't yielded.\n \n \n-```rust\n+```rust,ignore\n impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         if self.cap != 0 {\n             // drop any remaining elements\n             for _ in &mut *self {}\n \n-            let align = mem::min_align_of::<T>();\n+            let align = mem::align_of::<T>();\n             let elem_size = mem::size_of::<T>();\n             let num_bytes = elem_size * self.cap;\n             unsafe {\n@@ -164,7 +164,7 @@ compression.\n We're going to abstract out the `(ptr, cap)` pair and give them the logic for\n allocating, growing, and freeing:\n \n-```rust\n+```rust,ignore\n \n struct RawVec<T> {\n     ptr: Unique<T>,\n@@ -182,7 +182,7 @@ impl<T> RawVec<T> {\n     // unchanged from Vec\n     fn grow(&mut self) {\n         unsafe {\n-            let align = mem::min_align_of::<T>();\n+            let align = mem::align_of::<T>();\n             let elem_size = mem::size_of::<T>();\n \n             let (new_cap, ptr) = if self.cap == 0 {\n@@ -210,7 +210,7 @@ impl<T> RawVec<T> {\n impl<T> Drop for RawVec<T> {\n     fn drop(&mut self) {\n         if self.cap != 0 {\n-            let align = mem::min_align_of::<T>();\n+            let align = mem::align_of::<T>();\n             let elem_size = mem::size_of::<T>();\n             let num_bytes = elem_size * self.cap;\n             unsafe {\n@@ -223,7 +223,7 @@ impl<T> Drop for RawVec<T> {\n \n And change vec as follows:\n \n-```rust\n+```rust,ignore\n pub struct Vec<T> {\n     buf: RawVec<T>,\n     len: usize,\n@@ -254,14 +254,14 @@ impl<T> Drop for Vec<T> {\n \n And finally we can really simplify IntoIter:\n \n-```rust\n+```rust,ignore\n struct IntoIter<T> {\n     _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n     start: *const T,\n     end: *const T,\n }\n \n-// next and next_back litterally unchanged since they never referred to the buf\n+// next and next_back literally unchanged since they never referred to the buf\n \n impl<T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n@@ -290,4 +290,4 @@ impl<T> Vec<T> {\n }\n ```\n \n-Much better.\n\\ No newline at end of file\n+Much better."}, {"sha": "128ad15f7950f5b50a78ae55bb881cb76f1680ad", "filename": "src/doc/tarpl/vec-layout.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-layout.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-layout.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-layout.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -4,11 +4,13 @@ First off, we need to come up with the struct layout. Naively we want this\n design:\n \n ```rust\n-struct Vec<T> {\n+pub struct Vec<T> {\n     ptr: *mut T,\n     cap: usize,\n     len: usize,\n }\n+\n+# fn main() {}\n ```\n \n And indeed this would compile. Unfortunately, it would be incorrect. The compiler\n@@ -32,6 +34,8 @@ pub struct Vec<T> {\n     cap: usize,\n     len: usize,\n }\n+\n+# fn main() {}\n ```\n \n As a recap, Unique is a wrapper around a raw pointer that declares that:"}, {"sha": "2ef15e324b6e9ae2561d83788ca963fc4e7a1004", "filename": "src/doc/tarpl/vec-push-pop.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-push-pop.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fvec-push-pop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-push-pop.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -17,7 +17,7 @@ target address with the bits of the value we provide. No evaluation involved.\n For `push`, if the old len (before push was called) is 0, then we want to write\n to the 0th index. So we should offset by the old len.\n \n-```rust\n+```rust,ignore\n pub fn push(&mut self, elem: T) {\n     if self.len == self.cap { self.grow(); }\n \n@@ -41,7 +41,7 @@ of T there.\n For `pop`, if the old len is 1, we want to read out of the 0th index. So we\n should offset by the *new* len.\n \n-```rust\n+```rust,ignore\n pub fn pop(&mut self) -> Option<T> {\n     if self.len == 0 {\n         None\n@@ -52,4 +52,4 @@ pub fn pop(&mut self) -> Option<T> {\n         }\n     }\n }\n-```\n\\ No newline at end of file\n+```"}, {"sha": "0aeb2c0dc2580c6183c9099a65dbce0c9bf2e6c5", "filename": "src/doc/tarpl/working-with-unsafe.md", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fworking-with-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/7aee8448ea461a598075065491e98f941a570fea/src%2Fdoc%2Ftarpl%2Fworking-with-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fworking-with-unsafe.md?ref=7aee8448ea461a598075065491e98f941a570fea", "patch": "@@ -5,7 +5,7 @@ binary manner. Unfortunately, reality is significantly more complicated than tha\n For instance, consider the following toy function:\n \n ```rust\n-pub fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n+fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n     if idx < arr.len() {\n         unsafe {\n             Some(*arr.get_unchecked(idx))\n@@ -22,7 +22,7 @@ function, the scope of the unsafe block is questionable. Consider changing the\n `<` to a `<=`:\n \n ```rust\n-pub fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n+fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n     if idx <= arr.len() {\n         unsafe {\n             Some(*arr.get_unchecked(idx))\n@@ -44,7 +44,9 @@ Trickier than that is when we get into actual statefulness. Consider a simple\n implementation of `Vec`:\n \n ```rust\n-// Note this definition is insufficient. See the section on lifetimes.\n+use std::ptr;\n+\n+// Note this definition is insufficient. See the section on implementing Vec.\n pub struct Vec<T> {\n     ptr: *mut T,\n     len: usize,\n@@ -61,21 +63,25 @@ impl<T> Vec<T> {\n             self.reallocate();\n         }\n         unsafe {\n-            ptr::write(self.ptr.offset(len as isize), elem);\n+            ptr::write(self.ptr.offset(self.len as isize), elem);\n             self.len += 1;\n         }\n     }\n+\n+    # fn reallocate(&mut self) { }\n }\n+\n+# fn main() {}\n ```\n \n This code is simple enough to reasonably audit and verify. Now consider\n adding the following method:\n \n-```rust\n-    fn make_room(&mut self) {\n-        // grow the capacity\n-        self.cap += 1;\n-    }\n+```rust,ignore\n+fn make_room(&mut self) {\n+    // grow the capacity\n+    self.cap += 1;\n+}\n ```\n \n This code is safe, but it is also completely unsound. Changing the capacity"}]}