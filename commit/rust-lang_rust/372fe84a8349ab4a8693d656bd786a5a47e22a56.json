{"sha": "372fe84a8349ab4a8693d656bd786a5a47e22a56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3MmZlODRhODM0OWFiNGE4NjkzZDY1NmJkNzg2YTVhNDdlMjJhNTY=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-02-05T04:13:12Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-02-05T04:13:12Z"}, "message": "Streamline `Folder` some more.\n\nBy eliminating some unnecessary methods, and moving/renaming some\nfunctions that look like they might be methods but aren't.", "tree": {"sha": "c07eab1836e5b8c53ae621aed05891e68c2493cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c07eab1836e5b8c53ae621aed05891e68c2493cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/372fe84a8349ab4a8693d656bd786a5a47e22a56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/372fe84a8349ab4a8693d656bd786a5a47e22a56", "html_url": "https://github.com/rust-lang/rust/commit/372fe84a8349ab4a8693d656bd786a5a47e22a56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/372fe84a8349ab4a8693d656bd786a5a47e22a56/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "473095345b74b4d6b836d3ab2e3ace0c6719b20f", "url": "https://api.github.com/repos/rust-lang/rust/commits/473095345b74b4d6b836d3ab2e3ace0c6719b20f", "html_url": "https://github.com/rust-lang/rust/commit/473095345b74b4d6b836d3ab2e3ace0c6719b20f"}], "stats": {"total": 82, "additions": 39, "deletions": 43}, "files": [{"sha": "5fb0132ad4566a35b7a74b9216c00de18f4c9c57", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/372fe84a8349ab4a8693d656bd786a5a47e22a56/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/372fe84a8349ab4a8693d656bd786a5a47e22a56/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=372fe84a8349ab4a8693d656bd786a5a47e22a56", "patch": "@@ -125,10 +125,6 @@ pub trait Folder : Sized {\n         noop_fold_opt_expr(e, self)\n     }\n \n-    fn fold_exprs(&mut self, es: Vec<P<Expr>>) -> Vec<P<Expr>> {\n-        noop_fold_exprs(es, self)\n-    }\n-\n     fn fold_generic_arg(&mut self, arg: GenericArg) -> GenericArg {\n         match arg {\n             GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.fold_lifetime(lt)),\n@@ -257,10 +253,6 @@ pub trait Folder : Sized {\n         noop_fold_interpolated(nt, self)\n     }\n \n-    fn fold_bounds(&mut self, b: GenericBounds) -> GenericBounds {\n-        noop_fold_bounds(b, self)\n-    }\n-\n     fn fold_param_bound(&mut self, tpb: GenericBound) -> GenericBound {\n         noop_fold_param_bound(tpb, self)\n     }\n@@ -296,6 +288,34 @@ pub trait Folder : Sized {\n     }\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `Folder`.\n+fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n+    attrs.move_map(|x| fld.fold_attribute(x))\n+}\n+\n+// No `noop_` prefix because there isn't a corresponding method in `Folder`.\n+fn fold_thin_attrs<T: Folder>(attrs: ThinVec<Attribute>, fld: &mut T) -> ThinVec<Attribute> {\n+    fold_attrs(attrs.into(), fld).into()\n+}\n+\n+// No `noop_` prefix because there isn't a corresponding method in `Folder`.\n+fn fold_exprs<T: Folder>(es: Vec<P<Expr>>, fld: &mut T) -> Vec<P<Expr>> {\n+    es.move_flat_map(|e| fld.fold_opt_expr(e))\n+}\n+\n+// No `noop_` prefix because there isn't a corresponding method in `Folder`.\n+fn fold_bounds<T: Folder>(bounds: GenericBounds, folder: &mut T) -> GenericBounds {\n+    bounds.move_map(|bound| folder.fold_param_bound(bound))\n+}\n+\n+// No `noop_` prefix because there isn't a corresponding method in `Folder`.\n+fn fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n+    MethodSig {\n+        header: folder.fold_fn_header(sig.header),\n+        decl: folder.fold_fn_decl(sig.decl)\n+    }\n+}\n+\n pub fn noop_fold_use_tree<T: Folder>(use_tree: UseTree, fld: &mut T) -> UseTree {\n     UseTree {\n         span: fld.new_span(use_tree.span),\n@@ -312,14 +332,6 @@ pub fn noop_fold_use_tree<T: Folder>(use_tree: UseTree, fld: &mut T) -> UseTree\n     }\n }\n \n-pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n-    attrs.move_map(|x| fld.fold_attribute(x))\n-}\n-\n-pub fn fold_thin_attrs<T: Folder>(attrs: ThinVec<Attribute>, fld: &mut T) -> ThinVec<Attribute> {\n-    fold_attrs(attrs.into(), fld).into()\n-}\n-\n pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm,\n     fld: &mut T) -> Arm {\n     Arm {\n@@ -824,11 +836,6 @@ pub fn noop_fold_mt<T: Folder>(MutTy {ty, mutbl}: MutTy, folder: &mut T) -> MutT\n     }\n }\n \n-fn noop_fold_bounds<T: Folder>(bounds: GenericBounds, folder: &mut T)\n-                          -> GenericBounds {\n-    bounds.move_map(|bound| folder.fold_param_bound(bound))\n-}\n-\n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     b.map(|Block {id, stmts, rules, span}| Block {\n         id: folder.new_id(id),\n@@ -864,7 +871,7 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n             ItemKind::Ty(folder.fold_ty(t), folder.fold_generics(generics))\n         }\n         ItemKind::Existential(bounds, generics) => ItemKind::Existential(\n-            folder.fold_bounds(bounds),\n+            fold_bounds(bounds, folder),\n             folder.fold_generics(generics),\n         ),\n         ItemKind::Enum(enum_definition, generics) => {\n@@ -899,12 +906,12 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n             is_auto,\n             unsafety,\n             folder.fold_generics(generics),\n-            folder.fold_bounds(bounds),\n+            fold_bounds(bounds, folder),\n             items.move_flat_map(|item| folder.fold_trait_item(item)),\n         ),\n         ItemKind::TraitAlias(generics, bounds) => ItemKind::TraitAlias(\n             folder.fold_generics(generics),\n-            folder.fold_bounds(bounds)),\n+            fold_bounds(bounds, folder)),\n         ItemKind::Mac(m) => ItemKind::Mac(folder.fold_mac(m)),\n         ItemKind::MacroDef(def) => ItemKind::MacroDef(folder.fold_macro_def(def)),\n     }\n@@ -922,11 +929,11 @@ pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T) -> SmallVec\n                                default.map(|x| folder.fold_expr(x)))\n             }\n             TraitItemKind::Method(sig, body) => {\n-                TraitItemKind::Method(noop_fold_method_sig(sig, folder),\n+                TraitItemKind::Method(fold_method_sig(sig, folder),\n                                 body.map(|x| folder.fold_block(x)))\n             }\n             TraitItemKind::Type(bounds, default) => {\n-                TraitItemKind::Type(folder.fold_bounds(bounds),\n+                TraitItemKind::Type(fold_bounds(bounds, folder),\n                               default.map(|x| folder.fold_ty(x)))\n             }\n             TraitItemKind::Macro(mac) => {\n@@ -951,12 +958,12 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)-> SmallVec<[I\n                 ImplItemKind::Const(folder.fold_ty(ty), folder.fold_expr(expr))\n             }\n             ImplItemKind::Method(sig, body) => {\n-                ImplItemKind::Method(noop_fold_method_sig(sig, folder),\n+                ImplItemKind::Method(fold_method_sig(sig, folder),\n                                folder.fold_block(body))\n             }\n             ImplItemKind::Type(ty) => ImplItemKind::Type(folder.fold_ty(ty)),\n             ImplItemKind::Existential(bounds) => {\n-                ImplItemKind::Existential(folder.fold_bounds(bounds))\n+                ImplItemKind::Existential(fold_bounds(bounds, folder))\n             },\n             ImplItemKind::Macro(mac) => ImplItemKind::Macro(folder.fold_mac(mac))\n         },\n@@ -1047,13 +1054,6 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T)\n     }]\n }\n \n-pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n-    MethodSig {\n-        header: folder.fold_fn_header(sig.header),\n-        decl: folder.fold_fn_decl(sig.decl)\n-    }\n-}\n-\n pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n     p.map(|Pat {id, node, span}| Pat {\n         id: folder.new_id(id),\n@@ -1125,15 +1125,15 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 ExprKind::ObsoleteInPlace(folder.fold_expr(a), folder.fold_expr(b))\n             }\n             ExprKind::Array(exprs) => {\n-                ExprKind::Array(folder.fold_exprs(exprs))\n+                ExprKind::Array(fold_exprs(exprs, folder))\n             }\n             ExprKind::Repeat(expr, count) => {\n                 ExprKind::Repeat(folder.fold_expr(expr), folder.fold_anon_const(count))\n             }\n-            ExprKind::Tup(exprs) => ExprKind::Tup(folder.fold_exprs(exprs)),\n+            ExprKind::Tup(exprs) => ExprKind::Tup(fold_exprs(exprs, folder)),\n             ExprKind::Call(f, args) => {\n                 ExprKind::Call(folder.fold_expr(f),\n-                         folder.fold_exprs(args))\n+                         fold_exprs(args, folder))\n             }\n             ExprKind::MethodCall(seg, args) => {\n                 ExprKind::MethodCall(\n@@ -1144,7 +1144,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                             args.map(|args| folder.fold_generic_args(args))\n                         }),\n                     },\n-                    folder.fold_exprs(args))\n+                    fold_exprs(args, folder))\n             }\n             ExprKind::Binary(binop, lhs, rhs) => {\n                 ExprKind::Binary(binop,\n@@ -1294,10 +1294,6 @@ pub fn noop_fold_opt_expr<T: Folder>(e: P<Expr>, folder: &mut T) -> Option<P<Exp\n     Some(folder.fold_expr(e))\n }\n \n-pub fn noop_fold_exprs<T: Folder>(es: Vec<P<Expr>>, folder: &mut T) -> Vec<P<Expr>> {\n-    es.move_flat_map(|e| folder.fold_opt_expr(e))\n-}\n-\n pub fn noop_fold_stmt<T: Folder>(Stmt {node, span, id}: Stmt, folder: &mut T) -> SmallVec<[Stmt; 1]>\n {\n     let id = folder.new_id(id);"}]}