{"sha": "c42b03de17b2d0c567dc85417ec22518d69fd8ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MmIwM2RlMTdiMmQwYzU2N2RjODU0MTdlYzIyNTE4ZDY5ZmQ4YWU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-11T07:42:16Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-15T19:19:15Z"}, "message": "core::rt: Fix scheduling logic for enqueued tasks", "tree": {"sha": "3decf7f1d1334c8581e0a0a603c8f0a5ada3f267", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3decf7f1d1334c8581e0a0a603c8f0a5ada3f267"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c42b03de17b2d0c567dc85417ec22518d69fd8ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c42b03de17b2d0c567dc85417ec22518d69fd8ae", "html_url": "https://github.com/rust-lang/rust/commit/c42b03de17b2d0c567dc85417ec22518d69fd8ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c42b03de17b2d0c567dc85417ec22518d69fd8ae/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4724966b0656761da94e24e73b028cd0d3420a7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4724966b0656761da94e24e73b028cd0d3420a7e", "html_url": "https://github.com/rust-lang/rust/commit/4724966b0656761da94e24e73b028cd0d3420a7e"}], "stats": {"total": 314, "additions": 188, "deletions": 126}, "files": [{"sha": "fda48b6ffb7d9140c845846ab0b90fefb5d26651", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=c42b03de17b2d0c567dc85417ec22518d69fd8ae", "patch": "@@ -11,7 +11,7 @@\n #[macro_escape];\n \n // Some basic logging\n-macro_rules! rtdebug (\n+macro_rules! rtdebug_ (\n     ($( $arg:expr),+) => ( {\n         dumb_println(fmt!( $($arg),+ ));\n \n@@ -26,7 +26,7 @@ macro_rules! rtdebug (\n )\n \n // An alternate version with no output, for turning off logging\n-macro_rules! rtdebug_ (\n+macro_rules! rtdebug (\n     ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n )\n "}, {"sha": "4ed76003eeb605f141b0e054a2ce2c4696e65c15", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=c42b03de17b2d0c567dc85417ec22518d69fd8ae", "patch": "@@ -147,7 +147,7 @@ pub fn start(_argc: int, _argv: **u8, crate_map: *u8, main: ~fn()) -> int {\n     let mut sched = ~Scheduler::new(loop_);\n     let main_task = ~Task::new(&mut sched.stack_pool, main);\n \n-    sched.task_queue.push_back(main_task);\n+    sched.enqueue_task(main_task);\n     sched.run();\n \n     return 0;\n@@ -225,11 +225,11 @@ fn test_context() {\n                 assert!(context() == SchedulerContext);\n                 let task = Cell(task);\n                 do local_sched::borrow |sched| {\n-                    sched.task_queue.push_back(task.take());\n+                    sched.enqueue_task(task.take());\n                 }\n             }\n         };\n-        sched.task_queue.push_back(task);\n+        sched.enqueue_task(task);\n         sched.run();\n     }\n }"}, {"sha": "4b5eda22ff5de7999534237995f56ab875405dab", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=c42b03de17b2d0c567dc85417ec22518d69fd8ae", "patch": "@@ -25,6 +25,7 @@ pub type RtioTcpListenerObject = uvio::UvTcpListener;\n pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n+    fn callback_ms(&mut self, ms: u64, ~fn());\n     /// The asynchronous I/O services. Not all event loops may provide one\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject>;\n }"}, {"sha": "3469997833c5de4c78a304c67e276c7f3e6e8b19", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 161, "deletions": 114, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=c42b03de17b2d0c567dc85417ec22518d69fd8ae", "patch": "@@ -31,7 +31,7 @@ pub mod local_sched;\n /// thread local storage and the running task is owned by the\n /// scheduler.\n pub struct Scheduler {\n-    task_queue: WorkQueue<~Task>,\n+    priv task_queue: WorkQueue<~Task>,\n     stack_pool: StackPool,\n     /// The event loop used to drive the scheduler and perform I/O\n     event_loop: ~EventLoopObject,\n@@ -91,44 +91,56 @@ pub impl Scheduler {\n     fn run(~self) -> ~Scheduler {\n         assert!(!self.in_task_context());\n \n-        // Give ownership of the scheduler (self) to the thread\n-        local_sched::put(self);\n+        let mut self_sched = self;\n \n         unsafe {\n-            let scheduler = local_sched::unsafe_borrow();\n-            fn run_scheduler_once() {\n-                let scheduler = local_sched::take();\n-                if scheduler.resume_task_from_queue() {\n-                    // Ok, a task ran. Nice! We'll do it again later\n-                    do local_sched::borrow |scheduler| {\n-                        scheduler.event_loop.callback(run_scheduler_once);\n-                    }\n-                }\n-            }\n+            let event_loop: *mut ~EventLoopObject = {\n+                let event_loop: *mut ~EventLoopObject = &mut self_sched.event_loop;\n+                event_loop\n+            };\n \n-            let scheduler = &mut *scheduler;\n-            scheduler.event_loop.callback(run_scheduler_once);\n-            scheduler.event_loop.run();\n+            // Give ownership of the scheduler (self) to the thread\n+            local_sched::put(self_sched);\n+\n+            (*event_loop).run();\n         }\n \n-        return local_sched::take();\n+        let sched = local_sched::take();\n+        assert!(sched.task_queue.is_empty());\n+        return sched;\n+    }\n+\n+    /// Schedule a task to be executed later.\n+    ///\n+    /// Pushes the task onto the work stealing queue and tells the event loop\n+    /// to run it later. Always use this instead of pushing to the work queue\n+    /// directly.\n+    fn enqueue_task(&mut self, task: ~Task) {\n+        self.task_queue.push_front(task);\n+        self.event_loop.callback(resume_task_from_queue);\n+\n+        fn resume_task_from_queue() {\n+            let scheduler = local_sched::take();\n+            scheduler.resume_task_from_queue();\n+        }\n     }\n \n     // * Scheduler-context operations\n \n-    fn resume_task_from_queue(~self) -> bool {\n+    fn resume_task_from_queue(~self) {\n         assert!(!self.in_task_context());\n \n+        rtdebug!(\"looking in work queue for task to schedule\");\n+\n         let mut this = self;\n         match this.task_queue.pop_front() {\n             Some(task) => {\n+                rtdebug!(\"resuming task from work queue\");\n                 this.resume_task_immediately(task);\n-                return true;\n             }\n             None => {\n                 rtdebug!(\"no tasks in queue\");\n                 local_sched::put(this);\n-                return false;\n             }\n         }\n     }\n@@ -158,7 +170,7 @@ pub impl Scheduler {\n         do self.switch_running_tasks_and_then(task) |last_task| {\n             let last_task = Cell(last_task);\n             do local_sched::borrow |sched| {\n-                sched.task_queue.push_front(last_task.take());\n+                sched.enqueue_task(last_task.take());\n             }\n         }\n     }\n@@ -385,118 +397,153 @@ pub impl Task {\n     }\n }\n \n-#[test]\n-fn test_simple_scheduling() {\n-    do run_in_bare_thread {\n-        let mut task_ran = false;\n-        let task_ran_ptr: *mut bool = &mut task_ran;\n-\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n-            unsafe { *task_ran_ptr = true; }\n-        };\n-        sched.task_queue.push_back(task);\n-        sched.run();\n-        assert!(task_ran);\n+#[cfg(test)]\n+mod test {\n+    use int;\n+    use cell::Cell;\n+    use rt::uv::uvio::UvEventLoop;\n+    use unstable::run_in_bare_thread;\n+    use task::spawn;\n+    use rt::test::*;\n+    use super::*;\n+\n+    #[test]\n+    fn test_simple_scheduling() {\n+        do run_in_bare_thread {\n+            let mut task_ran = false;\n+            let task_ran_ptr: *mut bool = &mut task_ran;\n+\n+            let mut sched = ~UvEventLoop::new_scheduler();\n+            let task = ~do Task::new(&mut sched.stack_pool) {\n+                unsafe { *task_ran_ptr = true; }\n+            };\n+            sched.enqueue_task(task);\n+            sched.run();\n+            assert!(task_ran);\n+        }\n     }\n-}\n \n-#[test]\n-fn test_several_tasks() {\n-    do run_in_bare_thread {\n-        let total = 10;\n-        let mut task_count = 0;\n-        let task_count_ptr: *mut int = &mut task_count;\n+    #[test]\n+    fn test_several_tasks() {\n+        do run_in_bare_thread {\n+            let total = 10;\n+            let mut task_count = 0;\n+            let task_count_ptr: *mut int = &mut task_count;\n \n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        for int::range(0, total) |_| {\n-            let task = ~do Task::new(&mut sched.stack_pool) {\n-                unsafe { *task_count_ptr = *task_count_ptr + 1; }\n-            };\n-            sched.task_queue.push_back(task);\n+            let mut sched = ~UvEventLoop::new_scheduler();\n+            for int::range(0, total) |_| {\n+                let task = ~do Task::new(&mut sched.stack_pool) {\n+                    unsafe { *task_count_ptr = *task_count_ptr + 1; }\n+                };\n+                sched.enqueue_task(task);\n+            }\n+            sched.run();\n+            assert!(task_count == total);\n         }\n-        sched.run();\n-        assert!(task_count == total);\n     }\n-}\n \n-#[test]\n-fn test_swap_tasks_then() {\n-    do run_in_bare_thread {\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n-\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task1 = ~do Task::new(&mut sched.stack_pool) {\n-            unsafe { *count_ptr = *count_ptr + 1; }\n-            let mut sched = local_sched::take();\n-            let task2 = ~do Task::new(&mut sched.stack_pool) {\n+    #[test]\n+    fn test_swap_tasks_then() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+\n+            let mut sched = ~UvEventLoop::new_scheduler();\n+            let task1 = ~do Task::new(&mut sched.stack_pool) {\n                 unsafe { *count_ptr = *count_ptr + 1; }\n-            };\n-            // Context switch directly to the new task\n-            do sched.switch_running_tasks_and_then(task2) |task1| {\n-                let task1 = Cell(task1);\n-                do local_sched::borrow |sched| {\n-                    sched.task_queue.push_front(task1.take());\n+                let mut sched = local_sched::take();\n+                let task2 = ~do Task::new(&mut sched.stack_pool) {\n+                    unsafe { *count_ptr = *count_ptr + 1; }\n+                };\n+                // Context switch directly to the new task\n+                do sched.switch_running_tasks_and_then(task2) |task1| {\n+                    let task1 = Cell(task1);\n+                    do local_sched::borrow |sched| {\n+                        sched.enqueue_task(task1.take());\n+                    }\n                 }\n-            }\n-            unsafe { *count_ptr = *count_ptr + 1; }\n-        };\n-        sched.task_queue.push_back(task1);\n-        sched.run();\n-        assert!(count == 3);\n+                unsafe { *count_ptr = *count_ptr + 1; }\n+            };\n+            sched.enqueue_task(task1);\n+            sched.run();\n+            assert!(count == 3);\n+        }\n     }\n-}\n \n-#[bench] #[test] #[ignore(reason = \"long test\")]\n-fn test_run_a_lot_of_tasks_queued() {\n-    do run_in_bare_thread {\n-        static MAX: int = 1000000;\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n+    #[bench] #[test] #[ignore(reason = \"long test\")]\n+    fn test_run_a_lot_of_tasks_queued() {\n+        do run_in_bare_thread {\n+            static MAX: int = 1000000;\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n \n-        let mut sched = ~UvEventLoop::new_scheduler();\n+            let mut sched = ~UvEventLoop::new_scheduler();\n \n-        let start_task = ~do Task::new(&mut sched.stack_pool) {\n-            run_task(count_ptr);\n-        };\n-        sched.task_queue.push_back(start_task);\n-        sched.run();\n+            let start_task = ~do Task::new(&mut sched.stack_pool) {\n+                run_task(count_ptr);\n+            };\n+            sched.enqueue_task(start_task);\n+            sched.run();\n \n-        assert!(count == MAX);\n+            assert!(count == MAX);\n \n-        fn run_task(count_ptr: *mut int) {\n-            do local_sched::borrow |sched| {\n-                let task = ~do Task::new(&mut sched.stack_pool) {\n-                    unsafe {\n-                        *count_ptr = *count_ptr + 1;\n-                        if *count_ptr != MAX {\n-                            run_task(count_ptr);\n+            fn run_task(count_ptr: *mut int) {\n+                do local_sched::borrow |sched| {\n+                    let task = ~do Task::new(&mut sched.stack_pool) {\n+                        unsafe {\n+                            *count_ptr = *count_ptr + 1;\n+                            if *count_ptr != MAX {\n+                                run_task(count_ptr);\n+                            }\n                         }\n+                    };\n+                    sched.enqueue_task(task);\n+                }\n+            };\n+        }\n+    }\n+\n+    #[test]\n+    fn test_block_task() {\n+        do run_in_bare_thread {\n+            let mut sched = ~UvEventLoop::new_scheduler();\n+            let task = ~do Task::new(&mut sched.stack_pool) {\n+                let sched = local_sched::take();\n+                assert!(sched.in_task_context());\n+                do sched.deschedule_running_task_and_then() |task| {\n+                    let task = Cell(task);\n+                    do local_sched::borrow |sched| {\n+                        assert!(!sched.in_task_context());\n+                        sched.enqueue_task(task.take());\n                     }\n-                };\n-                sched.task_queue.push_back(task);\n-            }\n-        };\n+                }\n+            };\n+            sched.enqueue_task(task);\n+            sched.run();\n+        }\n     }\n-}\n \n-#[test]\n-fn test_block_task() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n-            let sched = local_sched::take();\n-            assert!(sched.in_task_context());\n-            do sched.deschedule_running_task_and_then() |task| {\n-                let task = Cell(task);\n-                do local_sched::borrow |sched| {\n-                    assert!(!sched.in_task_context());\n-                    sched.task_queue.push_back(task.take());\n+    #[test]\n+    fn test_io_callback() {\n+        // This is a regression test that when there are no schedulable tasks\n+        // in the work queue, but we are performing I/O, that once we do put\n+        // something in the work queue again the scheduler picks it up and doesn't\n+        // exit before emptying the work queue\n+        do run_in_newsched_task {\n+            do spawn {\n+                let sched = local_sched::take();\n+                do sched.deschedule_running_task_and_then |task| {\n+                    let mut sched = local_sched::take();\n+                    let task = Cell(task);\n+                    do sched.event_loop.callback_ms(10) {\n+                        rtdebug!(\"in callback\");\n+                        let mut sched = local_sched::take();\n+                        sched.enqueue_task(task.take());\n+                        local_sched::put(sched);\n+                    }\n+                    local_sched::put(sched);\n                 }\n             }\n-        };\n-        sched.task_queue.push_back(task);\n-        sched.run();\n+        }\n     }\n }"}, {"sha": "cfd1748ded35ac8970f721b42a2fbc1c64733a69", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=c42b03de17b2d0c567dc85417ec22518d69fd8ae", "patch": "@@ -28,7 +28,7 @@ pub fn run_in_newsched_task(f: ~fn()) {\n         let task = ~Task::with_local(&mut sched.stack_pool,\n                                      LocalServices::without_unwinding(),\n                                      f.take());\n-        sched.task_queue.push_back(task);\n+        sched.enqueue_task(task);\n         sched.run();\n     }\n }\n@@ -59,7 +59,7 @@ pub fn spawntask_immediately(f: ~fn()) {\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n         do local_sched::borrow |sched| {\n-            sched.task_queue.push_front(task.take());\n+            sched.enqueue_task(task.take());\n         }\n     }\n }\n@@ -73,7 +73,7 @@ pub fn spawntask_later(f: ~fn()) {\n                                  LocalServices::without_unwinding(),\n                                  f);\n \n-    sched.task_queue.push_front(task);\n+    sched.enqueue_task(task);\n     local_sched::put(sched);\n }\n \n@@ -94,11 +94,11 @@ pub fn spawntask_random(f: ~fn()) {\n         do sched.switch_running_tasks_and_then(task) |task| {\n             let task = Cell(task);\n             do local_sched::borrow |sched| {\n-                sched.task_queue.push_front(task.take());\n+                sched.enqueue_task(task.take());\n             }\n         }\n     } else {\n-        sched.task_queue.push_front(task);\n+        sched.enqueue_task(task);\n         local_sched::put(sched);\n     }\n }\n@@ -132,7 +132,7 @@ pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n                 do sched.switch_running_tasks_and_then(old_task.take()) |new_task| {\n                     let new_task = Cell(new_task);\n                     do local_sched::borrow |sched| {\n-                        sched.task_queue.push_front(new_task.take());\n+                        sched.enqueue_task(new_task.take());\n                     }\n                 }\n             }"}, {"sha": "a25d18101a7fdda2730d3c2d0e83f93fec00d7e0", "filename": "src/libcore/rt/uv/uvio.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs?ref=c42b03de17b2d0c567dc85417ec22518d69fd8ae", "patch": "@@ -73,6 +73,16 @@ impl EventLoop for UvEventLoop {\n         }\n     }\n \n+    fn callback_ms(&mut self, ms: u64, f: ~fn()) {\n+        let mut timer =  TimerWatcher::new(self.uvio.uv_loop());\n+        do timer.start(ms, 0) |timer, status| {\n+            assert!(status.is_none());\n+            let mut timer = timer;\n+            timer.close(||());\n+            f();\n+        }\n+    }\n+\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject> {\n         Some(&mut self.uvio)\n     }\n@@ -419,7 +429,7 @@ fn test_read_and_block() {\n                 do scheduler.deschedule_running_task_and_then |task| {\n                     let task = Cell(task);\n                     do local_sched::borrow |scheduler| {\n-                        scheduler.task_queue.push_back(task.take());\n+                        scheduler.enqueue_task(task.take());\n                     }\n                 }\n             }"}, {"sha": "f82b5847ef2b8a7562588357d39f2eee252721f6", "filename": "src/libcore/rt/work_queue.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c42b03de17b2d0c567dc85417ec22518d69fd8ae/src%2Flibcore%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fwork_queue.rs?ref=c42b03de17b2d0c567dc85417ec22518d69fd8ae", "patch": "@@ -46,4 +46,8 @@ pub impl<T> WorkQueue<T> {\n             None\n         }\n     }\n+\n+    fn is_empty(&self) -> bool {\n+        return self.queue.is_empty();\n+    }\n }"}]}