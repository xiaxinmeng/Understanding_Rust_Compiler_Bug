{"sha": "4a063e651f0ec0da852ce1f87589d5c0a893c59d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMDYzZTY1MWYwZWMwZGE4NTJjZTFmODc1ODlkNWMwYTg5M2M1OWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-09T15:58:15Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-09T15:58:15Z"}, "message": "Move the rest of the tokens to generated/tokens", "tree": {"sha": "1206b6185253043900f325b620997a7a648f82cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1206b6185253043900f325b620997a7a648f82cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a063e651f0ec0da852ce1f87589d5c0a893c59d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a063e651f0ec0da852ce1f87589d5c0a893c59d", "html_url": "https://github.com/rust-lang/rust/commit/4a063e651f0ec0da852ce1f87589d5c0a893c59d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a063e651f0ec0da852ce1f87589d5c0a893c59d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c80795e27491527487f97368be54b4467eb8b41e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c80795e27491527487f97368be54b4467eb8b41e", "html_url": "https://github.com/rust-lang/rust/commit/c80795e27491527487f97368be54b4467eb8b41e"}], "stats": {"total": 1489, "additions": 751, "deletions": 738}, "files": [{"sha": "18bf306577c063431fa1c07ea9a4006fe76b09b2", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 2, "deletions": 653, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/4a063e651f0ec0da852ce1f87589d5c0a893c59d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a063e651f0ec0da852ce1f87589d5c0a893c59d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=4a063e651f0ec0da852ce1f87589d5c0a893c59d", "patch": "@@ -2,9 +2,9 @@\n \n use super::tokens::*;\n use crate::{\n-    ast::{self, support, AstChildren, AstNode, AstToken},\n+    ast::{self, support, AstChildren, AstNode},\n     SyntaxKind::{self, *},\n-    SyntaxNode, SyntaxToken,\n+    SyntaxNode,\n };\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SourceFile {\n@@ -5877,657 +5877,6 @@ impl AstNode for Stmt {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum LeftDelimiter {\n-    LParen(LParen),\n-    LBrack(LBrack),\n-    LCurly(LCurly),\n-}\n-impl From<LParen> for LeftDelimiter {\n-    fn from(node: LParen) -> LeftDelimiter {\n-        LeftDelimiter::LParen(node)\n-    }\n-}\n-impl From<LBrack> for LeftDelimiter {\n-    fn from(node: LBrack) -> LeftDelimiter {\n-        LeftDelimiter::LBrack(node)\n-    }\n-}\n-impl From<LCurly> for LeftDelimiter {\n-    fn from(node: LCurly) -> LeftDelimiter {\n-        LeftDelimiter::LCurly(node)\n-    }\n-}\n-impl std::fmt::Display for LeftDelimiter {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for LeftDelimiter {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            L_PAREN | L_BRACK | L_CURLY => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            L_PAREN => LeftDelimiter::LParen(LParen { syntax }),\n-            L_BRACK => LeftDelimiter::LBrack(LBrack { syntax }),\n-            L_CURLY => LeftDelimiter::LCurly(LCurly { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            LeftDelimiter::LParen(it) => &it.syntax,\n-            LeftDelimiter::LBrack(it) => &it.syntax,\n-            LeftDelimiter::LCurly(it) => &it.syntax,\n-        }\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum RightDelimiter {\n-    RParen(RParen),\n-    RBrack(RBrack),\n-    RCurly(RCurly),\n-}\n-impl From<RParen> for RightDelimiter {\n-    fn from(node: RParen) -> RightDelimiter {\n-        RightDelimiter::RParen(node)\n-    }\n-}\n-impl From<RBrack> for RightDelimiter {\n-    fn from(node: RBrack) -> RightDelimiter {\n-        RightDelimiter::RBrack(node)\n-    }\n-}\n-impl From<RCurly> for RightDelimiter {\n-    fn from(node: RCurly) -> RightDelimiter {\n-        RightDelimiter::RCurly(node)\n-    }\n-}\n-impl std::fmt::Display for RightDelimiter {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for RightDelimiter {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            R_PAREN | R_BRACK | R_CURLY => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            R_PAREN => RightDelimiter::RParen(RParen { syntax }),\n-            R_BRACK => RightDelimiter::RBrack(RBrack { syntax }),\n-            R_CURLY => RightDelimiter::RCurly(RCurly { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            RightDelimiter::RParen(it) => &it.syntax,\n-            RightDelimiter::RBrack(it) => &it.syntax,\n-            RightDelimiter::RCurly(it) => &it.syntax,\n-        }\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum RangeSeparator {\n-    Dotdot(Dotdot),\n-    Dotdotdot(Dotdotdot),\n-    Dotdoteq(Dotdoteq),\n-}\n-impl From<Dotdot> for RangeSeparator {\n-    fn from(node: Dotdot) -> RangeSeparator {\n-        RangeSeparator::Dotdot(node)\n-    }\n-}\n-impl From<Dotdotdot> for RangeSeparator {\n-    fn from(node: Dotdotdot) -> RangeSeparator {\n-        RangeSeparator::Dotdotdot(node)\n-    }\n-}\n-impl From<Dotdoteq> for RangeSeparator {\n-    fn from(node: Dotdoteq) -> RangeSeparator {\n-        RangeSeparator::Dotdoteq(node)\n-    }\n-}\n-impl std::fmt::Display for RangeSeparator {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for RangeSeparator {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            DOTDOT | DOTDOTDOT | DOTDOTEQ => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            DOTDOT => RangeSeparator::Dotdot(Dotdot { syntax }),\n-            DOTDOTDOT => RangeSeparator::Dotdotdot(Dotdotdot { syntax }),\n-            DOTDOTEQ => RangeSeparator::Dotdoteq(Dotdoteq { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            RangeSeparator::Dotdot(it) => &it.syntax,\n-            RangeSeparator::Dotdotdot(it) => &it.syntax,\n-            RangeSeparator::Dotdoteq(it) => &it.syntax,\n-        }\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum BinOp {\n-    Pipepipe(Pipepipe),\n-    Ampamp(Ampamp),\n-    Eqeq(Eqeq),\n-    Neq(Neq),\n-    Lteq(Lteq),\n-    Gteq(Gteq),\n-    LAngle(LAngle),\n-    RAngle(RAngle),\n-    Plus(Plus),\n-    Star(Star),\n-    Minus(Minus),\n-    Slash(Slash),\n-    Percent(Percent),\n-    Shl(Shl),\n-    Shr(Shr),\n-    Caret(Caret),\n-    Pipe(Pipe),\n-    Amp(Amp),\n-    Eq(Eq),\n-    Pluseq(Pluseq),\n-    Slasheq(Slasheq),\n-    Stareq(Stareq),\n-    Percenteq(Percenteq),\n-    Shreq(Shreq),\n-    Shleq(Shleq),\n-    Minuseq(Minuseq),\n-    Pipeeq(Pipeeq),\n-    Ampeq(Ampeq),\n-    Careteq(Careteq),\n-}\n-impl From<Pipepipe> for BinOp {\n-    fn from(node: Pipepipe) -> BinOp {\n-        BinOp::Pipepipe(node)\n-    }\n-}\n-impl From<Ampamp> for BinOp {\n-    fn from(node: Ampamp) -> BinOp {\n-        BinOp::Ampamp(node)\n-    }\n-}\n-impl From<Eqeq> for BinOp {\n-    fn from(node: Eqeq) -> BinOp {\n-        BinOp::Eqeq(node)\n-    }\n-}\n-impl From<Neq> for BinOp {\n-    fn from(node: Neq) -> BinOp {\n-        BinOp::Neq(node)\n-    }\n-}\n-impl From<Lteq> for BinOp {\n-    fn from(node: Lteq) -> BinOp {\n-        BinOp::Lteq(node)\n-    }\n-}\n-impl From<Gteq> for BinOp {\n-    fn from(node: Gteq) -> BinOp {\n-        BinOp::Gteq(node)\n-    }\n-}\n-impl From<LAngle> for BinOp {\n-    fn from(node: LAngle) -> BinOp {\n-        BinOp::LAngle(node)\n-    }\n-}\n-impl From<RAngle> for BinOp {\n-    fn from(node: RAngle) -> BinOp {\n-        BinOp::RAngle(node)\n-    }\n-}\n-impl From<Plus> for BinOp {\n-    fn from(node: Plus) -> BinOp {\n-        BinOp::Plus(node)\n-    }\n-}\n-impl From<Star> for BinOp {\n-    fn from(node: Star) -> BinOp {\n-        BinOp::Star(node)\n-    }\n-}\n-impl From<Minus> for BinOp {\n-    fn from(node: Minus) -> BinOp {\n-        BinOp::Minus(node)\n-    }\n-}\n-impl From<Slash> for BinOp {\n-    fn from(node: Slash) -> BinOp {\n-        BinOp::Slash(node)\n-    }\n-}\n-impl From<Percent> for BinOp {\n-    fn from(node: Percent) -> BinOp {\n-        BinOp::Percent(node)\n-    }\n-}\n-impl From<Shl> for BinOp {\n-    fn from(node: Shl) -> BinOp {\n-        BinOp::Shl(node)\n-    }\n-}\n-impl From<Shr> for BinOp {\n-    fn from(node: Shr) -> BinOp {\n-        BinOp::Shr(node)\n-    }\n-}\n-impl From<Caret> for BinOp {\n-    fn from(node: Caret) -> BinOp {\n-        BinOp::Caret(node)\n-    }\n-}\n-impl From<Pipe> for BinOp {\n-    fn from(node: Pipe) -> BinOp {\n-        BinOp::Pipe(node)\n-    }\n-}\n-impl From<Amp> for BinOp {\n-    fn from(node: Amp) -> BinOp {\n-        BinOp::Amp(node)\n-    }\n-}\n-impl From<Eq> for BinOp {\n-    fn from(node: Eq) -> BinOp {\n-        BinOp::Eq(node)\n-    }\n-}\n-impl From<Pluseq> for BinOp {\n-    fn from(node: Pluseq) -> BinOp {\n-        BinOp::Pluseq(node)\n-    }\n-}\n-impl From<Slasheq> for BinOp {\n-    fn from(node: Slasheq) -> BinOp {\n-        BinOp::Slasheq(node)\n-    }\n-}\n-impl From<Stareq> for BinOp {\n-    fn from(node: Stareq) -> BinOp {\n-        BinOp::Stareq(node)\n-    }\n-}\n-impl From<Percenteq> for BinOp {\n-    fn from(node: Percenteq) -> BinOp {\n-        BinOp::Percenteq(node)\n-    }\n-}\n-impl From<Shreq> for BinOp {\n-    fn from(node: Shreq) -> BinOp {\n-        BinOp::Shreq(node)\n-    }\n-}\n-impl From<Shleq> for BinOp {\n-    fn from(node: Shleq) -> BinOp {\n-        BinOp::Shleq(node)\n-    }\n-}\n-impl From<Minuseq> for BinOp {\n-    fn from(node: Minuseq) -> BinOp {\n-        BinOp::Minuseq(node)\n-    }\n-}\n-impl From<Pipeeq> for BinOp {\n-    fn from(node: Pipeeq) -> BinOp {\n-        BinOp::Pipeeq(node)\n-    }\n-}\n-impl From<Ampeq> for BinOp {\n-    fn from(node: Ampeq) -> BinOp {\n-        BinOp::Ampeq(node)\n-    }\n-}\n-impl From<Careteq> for BinOp {\n-    fn from(node: Careteq) -> BinOp {\n-        BinOp::Careteq(node)\n-    }\n-}\n-impl std::fmt::Display for BinOp {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for BinOp {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            PIPEPIPE | AMPAMP | EQEQ | NEQ | LTEQ | GTEQ | L_ANGLE | R_ANGLE | PLUS | STAR\n-            | MINUS | SLASH | PERCENT | SHL | SHR | CARET | PIPE | AMP | EQ | PLUSEQ | SLASHEQ\n-            | STAREQ | PERCENTEQ | SHREQ | SHLEQ | MINUSEQ | PIPEEQ | AMPEQ | CARETEQ => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            PIPEPIPE => BinOp::Pipepipe(Pipepipe { syntax }),\n-            AMPAMP => BinOp::Ampamp(Ampamp { syntax }),\n-            EQEQ => BinOp::Eqeq(Eqeq { syntax }),\n-            NEQ => BinOp::Neq(Neq { syntax }),\n-            LTEQ => BinOp::Lteq(Lteq { syntax }),\n-            GTEQ => BinOp::Gteq(Gteq { syntax }),\n-            L_ANGLE => BinOp::LAngle(LAngle { syntax }),\n-            R_ANGLE => BinOp::RAngle(RAngle { syntax }),\n-            PLUS => BinOp::Plus(Plus { syntax }),\n-            STAR => BinOp::Star(Star { syntax }),\n-            MINUS => BinOp::Minus(Minus { syntax }),\n-            SLASH => BinOp::Slash(Slash { syntax }),\n-            PERCENT => BinOp::Percent(Percent { syntax }),\n-            SHL => BinOp::Shl(Shl { syntax }),\n-            SHR => BinOp::Shr(Shr { syntax }),\n-            CARET => BinOp::Caret(Caret { syntax }),\n-            PIPE => BinOp::Pipe(Pipe { syntax }),\n-            AMP => BinOp::Amp(Amp { syntax }),\n-            EQ => BinOp::Eq(Eq { syntax }),\n-            PLUSEQ => BinOp::Pluseq(Pluseq { syntax }),\n-            SLASHEQ => BinOp::Slasheq(Slasheq { syntax }),\n-            STAREQ => BinOp::Stareq(Stareq { syntax }),\n-            PERCENTEQ => BinOp::Percenteq(Percenteq { syntax }),\n-            SHREQ => BinOp::Shreq(Shreq { syntax }),\n-            SHLEQ => BinOp::Shleq(Shleq { syntax }),\n-            MINUSEQ => BinOp::Minuseq(Minuseq { syntax }),\n-            PIPEEQ => BinOp::Pipeeq(Pipeeq { syntax }),\n-            AMPEQ => BinOp::Ampeq(Ampeq { syntax }),\n-            CARETEQ => BinOp::Careteq(Careteq { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            BinOp::Pipepipe(it) => &it.syntax,\n-            BinOp::Ampamp(it) => &it.syntax,\n-            BinOp::Eqeq(it) => &it.syntax,\n-            BinOp::Neq(it) => &it.syntax,\n-            BinOp::Lteq(it) => &it.syntax,\n-            BinOp::Gteq(it) => &it.syntax,\n-            BinOp::LAngle(it) => &it.syntax,\n-            BinOp::RAngle(it) => &it.syntax,\n-            BinOp::Plus(it) => &it.syntax,\n-            BinOp::Star(it) => &it.syntax,\n-            BinOp::Minus(it) => &it.syntax,\n-            BinOp::Slash(it) => &it.syntax,\n-            BinOp::Percent(it) => &it.syntax,\n-            BinOp::Shl(it) => &it.syntax,\n-            BinOp::Shr(it) => &it.syntax,\n-            BinOp::Caret(it) => &it.syntax,\n-            BinOp::Pipe(it) => &it.syntax,\n-            BinOp::Amp(it) => &it.syntax,\n-            BinOp::Eq(it) => &it.syntax,\n-            BinOp::Pluseq(it) => &it.syntax,\n-            BinOp::Slasheq(it) => &it.syntax,\n-            BinOp::Stareq(it) => &it.syntax,\n-            BinOp::Percenteq(it) => &it.syntax,\n-            BinOp::Shreq(it) => &it.syntax,\n-            BinOp::Shleq(it) => &it.syntax,\n-            BinOp::Minuseq(it) => &it.syntax,\n-            BinOp::Pipeeq(it) => &it.syntax,\n-            BinOp::Ampeq(it) => &it.syntax,\n-            BinOp::Careteq(it) => &it.syntax,\n-        }\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum PrefixOp {\n-    Minus(Minus),\n-    Excl(Excl),\n-    Star(Star),\n-}\n-impl From<Minus> for PrefixOp {\n-    fn from(node: Minus) -> PrefixOp {\n-        PrefixOp::Minus(node)\n-    }\n-}\n-impl From<Excl> for PrefixOp {\n-    fn from(node: Excl) -> PrefixOp {\n-        PrefixOp::Excl(node)\n-    }\n-}\n-impl From<Star> for PrefixOp {\n-    fn from(node: Star) -> PrefixOp {\n-        PrefixOp::Star(node)\n-    }\n-}\n-impl std::fmt::Display for PrefixOp {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for PrefixOp {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            MINUS | EXCL | STAR => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            MINUS => PrefixOp::Minus(Minus { syntax }),\n-            EXCL => PrefixOp::Excl(Excl { syntax }),\n-            STAR => PrefixOp::Star(Star { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            PrefixOp::Minus(it) => &it.syntax,\n-            PrefixOp::Excl(it) => &it.syntax,\n-            PrefixOp::Star(it) => &it.syntax,\n-        }\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum RangeOp {\n-    Dotdot(Dotdot),\n-    Dotdoteq(Dotdoteq),\n-}\n-impl From<Dotdot> for RangeOp {\n-    fn from(node: Dotdot) -> RangeOp {\n-        RangeOp::Dotdot(node)\n-    }\n-}\n-impl From<Dotdoteq> for RangeOp {\n-    fn from(node: Dotdoteq) -> RangeOp {\n-        RangeOp::Dotdoteq(node)\n-    }\n-}\n-impl std::fmt::Display for RangeOp {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for RangeOp {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            DOTDOT | DOTDOTEQ => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            DOTDOT => RangeOp::Dotdot(Dotdot { syntax }),\n-            DOTDOTEQ => RangeOp::Dotdoteq(Dotdoteq { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            RangeOp::Dotdot(it) => &it.syntax,\n-            RangeOp::Dotdoteq(it) => &it.syntax,\n-        }\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum LiteralToken {\n-    IntNumber(IntNumber),\n-    FloatNumber(FloatNumber),\n-    String(String),\n-    RawString(RawString),\n-    TrueKw(TrueKw),\n-    FalseKw(FalseKw),\n-    ByteString(ByteString),\n-    RawByteString(RawByteString),\n-    Char(Char),\n-    Byte(Byte),\n-}\n-impl From<IntNumber> for LiteralToken {\n-    fn from(node: IntNumber) -> LiteralToken {\n-        LiteralToken::IntNumber(node)\n-    }\n-}\n-impl From<FloatNumber> for LiteralToken {\n-    fn from(node: FloatNumber) -> LiteralToken {\n-        LiteralToken::FloatNumber(node)\n-    }\n-}\n-impl From<String> for LiteralToken {\n-    fn from(node: String) -> LiteralToken {\n-        LiteralToken::String(node)\n-    }\n-}\n-impl From<RawString> for LiteralToken {\n-    fn from(node: RawString) -> LiteralToken {\n-        LiteralToken::RawString(node)\n-    }\n-}\n-impl From<TrueKw> for LiteralToken {\n-    fn from(node: TrueKw) -> LiteralToken {\n-        LiteralToken::TrueKw(node)\n-    }\n-}\n-impl From<FalseKw> for LiteralToken {\n-    fn from(node: FalseKw) -> LiteralToken {\n-        LiteralToken::FalseKw(node)\n-    }\n-}\n-impl From<ByteString> for LiteralToken {\n-    fn from(node: ByteString) -> LiteralToken {\n-        LiteralToken::ByteString(node)\n-    }\n-}\n-impl From<RawByteString> for LiteralToken {\n-    fn from(node: RawByteString) -> LiteralToken {\n-        LiteralToken::RawByteString(node)\n-    }\n-}\n-impl From<Char> for LiteralToken {\n-    fn from(node: Char) -> LiteralToken {\n-        LiteralToken::Char(node)\n-    }\n-}\n-impl From<Byte> for LiteralToken {\n-    fn from(node: Byte) -> LiteralToken {\n-        LiteralToken::Byte(node)\n-    }\n-}\n-impl std::fmt::Display for LiteralToken {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for LiteralToken {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            INT_NUMBER | FLOAT_NUMBER | STRING | RAW_STRING | TRUE_KW | FALSE_KW | BYTE_STRING\n-            | RAW_BYTE_STRING | CHAR | BYTE => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            INT_NUMBER => LiteralToken::IntNumber(IntNumber { syntax }),\n-            FLOAT_NUMBER => LiteralToken::FloatNumber(FloatNumber { syntax }),\n-            STRING => LiteralToken::String(String { syntax }),\n-            RAW_STRING => LiteralToken::RawString(RawString { syntax }),\n-            TRUE_KW => LiteralToken::TrueKw(TrueKw { syntax }),\n-            FALSE_KW => LiteralToken::FalseKw(FalseKw { syntax }),\n-            BYTE_STRING => LiteralToken::ByteString(ByteString { syntax }),\n-            RAW_BYTE_STRING => LiteralToken::RawByteString(RawByteString { syntax }),\n-            CHAR => LiteralToken::Char(Char { syntax }),\n-            BYTE => LiteralToken::Byte(Byte { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            LiteralToken::IntNumber(it) => &it.syntax,\n-            LiteralToken::FloatNumber(it) => &it.syntax,\n-            LiteralToken::String(it) => &it.syntax,\n-            LiteralToken::RawString(it) => &it.syntax,\n-            LiteralToken::TrueKw(it) => &it.syntax,\n-            LiteralToken::FalseKw(it) => &it.syntax,\n-            LiteralToken::ByteString(it) => &it.syntax,\n-            LiteralToken::RawByteString(it) => &it.syntax,\n-            LiteralToken::Char(it) => &it.syntax,\n-            LiteralToken::Byte(it) => &it.syntax,\n-        }\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum NameRefToken {\n-    Ident(Ident),\n-    IntNumber(IntNumber),\n-}\n-impl From<Ident> for NameRefToken {\n-    fn from(node: Ident) -> NameRefToken {\n-        NameRefToken::Ident(node)\n-    }\n-}\n-impl From<IntNumber> for NameRefToken {\n-    fn from(node: IntNumber) -> NameRefToken {\n-        NameRefToken::IntNumber(node)\n-    }\n-}\n-impl std::fmt::Display for NameRefToken {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for NameRefToken {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            IDENT | INT_NUMBER => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            IDENT => NameRefToken::Ident(Ident { syntax }),\n-            INT_NUMBER => NameRefToken::IntNumber(IntNumber { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            NameRefToken::Ident(it) => &it.syntax,\n-            NameRefToken::IntNumber(it) => &it.syntax,\n-        }\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum FieldDefList {\n     RecordFieldDefList(RecordFieldDefList),\n     TupleFieldDefList(TupleFieldDefList),"}, {"sha": "3aea5bef15760760b11eee582e278a0a86237353", "filename": "crates/ra_syntax/src/ast/generated/tokens.rs", "status": "modified", "additions": 651, "deletions": 0, "changes": 651, "blob_url": "https://github.com/rust-lang/rust/blob/4a063e651f0ec0da852ce1f87589d5c0a893c59d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a063e651f0ec0da852ce1f87589d5c0a893c59d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs?ref=4a063e651f0ec0da852ce1f87589d5c0a893c59d", "patch": "@@ -3056,3 +3056,654 @@ impl AstToken for RDollar {\n         &self.syntax\n     }\n }\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum LeftDelimiter {\n+    LParen(LParen),\n+    LBrack(LBrack),\n+    LCurly(LCurly),\n+}\n+impl From<LParen> for LeftDelimiter {\n+    fn from(node: LParen) -> LeftDelimiter {\n+        LeftDelimiter::LParen(node)\n+    }\n+}\n+impl From<LBrack> for LeftDelimiter {\n+    fn from(node: LBrack) -> LeftDelimiter {\n+        LeftDelimiter::LBrack(node)\n+    }\n+}\n+impl From<LCurly> for LeftDelimiter {\n+    fn from(node: LCurly) -> LeftDelimiter {\n+        LeftDelimiter::LCurly(node)\n+    }\n+}\n+impl std::fmt::Display for LeftDelimiter {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for LeftDelimiter {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            L_PAREN | L_BRACK | L_CURLY => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            L_PAREN => LeftDelimiter::LParen(LParen { syntax }),\n+            L_BRACK => LeftDelimiter::LBrack(LBrack { syntax }),\n+            L_CURLY => LeftDelimiter::LCurly(LCurly { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            LeftDelimiter::LParen(it) => &it.syntax,\n+            LeftDelimiter::LBrack(it) => &it.syntax,\n+            LeftDelimiter::LCurly(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum RightDelimiter {\n+    RParen(RParen),\n+    RBrack(RBrack),\n+    RCurly(RCurly),\n+}\n+impl From<RParen> for RightDelimiter {\n+    fn from(node: RParen) -> RightDelimiter {\n+        RightDelimiter::RParen(node)\n+    }\n+}\n+impl From<RBrack> for RightDelimiter {\n+    fn from(node: RBrack) -> RightDelimiter {\n+        RightDelimiter::RBrack(node)\n+    }\n+}\n+impl From<RCurly> for RightDelimiter {\n+    fn from(node: RCurly) -> RightDelimiter {\n+        RightDelimiter::RCurly(node)\n+    }\n+}\n+impl std::fmt::Display for RightDelimiter {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for RightDelimiter {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            R_PAREN | R_BRACK | R_CURLY => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            R_PAREN => RightDelimiter::RParen(RParen { syntax }),\n+            R_BRACK => RightDelimiter::RBrack(RBrack { syntax }),\n+            R_CURLY => RightDelimiter::RCurly(RCurly { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            RightDelimiter::RParen(it) => &it.syntax,\n+            RightDelimiter::RBrack(it) => &it.syntax,\n+            RightDelimiter::RCurly(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum RangeSeparator {\n+    Dotdot(Dotdot),\n+    Dotdotdot(Dotdotdot),\n+    Dotdoteq(Dotdoteq),\n+}\n+impl From<Dotdot> for RangeSeparator {\n+    fn from(node: Dotdot) -> RangeSeparator {\n+        RangeSeparator::Dotdot(node)\n+    }\n+}\n+impl From<Dotdotdot> for RangeSeparator {\n+    fn from(node: Dotdotdot) -> RangeSeparator {\n+        RangeSeparator::Dotdotdot(node)\n+    }\n+}\n+impl From<Dotdoteq> for RangeSeparator {\n+    fn from(node: Dotdoteq) -> RangeSeparator {\n+        RangeSeparator::Dotdoteq(node)\n+    }\n+}\n+impl std::fmt::Display for RangeSeparator {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for RangeSeparator {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            DOTDOT | DOTDOTDOT | DOTDOTEQ => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            DOTDOT => RangeSeparator::Dotdot(Dotdot { syntax }),\n+            DOTDOTDOT => RangeSeparator::Dotdotdot(Dotdotdot { syntax }),\n+            DOTDOTEQ => RangeSeparator::Dotdoteq(Dotdoteq { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            RangeSeparator::Dotdot(it) => &it.syntax,\n+            RangeSeparator::Dotdotdot(it) => &it.syntax,\n+            RangeSeparator::Dotdoteq(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum BinOp {\n+    Pipepipe(Pipepipe),\n+    Ampamp(Ampamp),\n+    Eqeq(Eqeq),\n+    Neq(Neq),\n+    Lteq(Lteq),\n+    Gteq(Gteq),\n+    LAngle(LAngle),\n+    RAngle(RAngle),\n+    Plus(Plus),\n+    Star(Star),\n+    Minus(Minus),\n+    Slash(Slash),\n+    Percent(Percent),\n+    Shl(Shl),\n+    Shr(Shr),\n+    Caret(Caret),\n+    Pipe(Pipe),\n+    Amp(Amp),\n+    Eq(Eq),\n+    Pluseq(Pluseq),\n+    Slasheq(Slasheq),\n+    Stareq(Stareq),\n+    Percenteq(Percenteq),\n+    Shreq(Shreq),\n+    Shleq(Shleq),\n+    Minuseq(Minuseq),\n+    Pipeeq(Pipeeq),\n+    Ampeq(Ampeq),\n+    Careteq(Careteq),\n+}\n+impl From<Pipepipe> for BinOp {\n+    fn from(node: Pipepipe) -> BinOp {\n+        BinOp::Pipepipe(node)\n+    }\n+}\n+impl From<Ampamp> for BinOp {\n+    fn from(node: Ampamp) -> BinOp {\n+        BinOp::Ampamp(node)\n+    }\n+}\n+impl From<Eqeq> for BinOp {\n+    fn from(node: Eqeq) -> BinOp {\n+        BinOp::Eqeq(node)\n+    }\n+}\n+impl From<Neq> for BinOp {\n+    fn from(node: Neq) -> BinOp {\n+        BinOp::Neq(node)\n+    }\n+}\n+impl From<Lteq> for BinOp {\n+    fn from(node: Lteq) -> BinOp {\n+        BinOp::Lteq(node)\n+    }\n+}\n+impl From<Gteq> for BinOp {\n+    fn from(node: Gteq) -> BinOp {\n+        BinOp::Gteq(node)\n+    }\n+}\n+impl From<LAngle> for BinOp {\n+    fn from(node: LAngle) -> BinOp {\n+        BinOp::LAngle(node)\n+    }\n+}\n+impl From<RAngle> for BinOp {\n+    fn from(node: RAngle) -> BinOp {\n+        BinOp::RAngle(node)\n+    }\n+}\n+impl From<Plus> for BinOp {\n+    fn from(node: Plus) -> BinOp {\n+        BinOp::Plus(node)\n+    }\n+}\n+impl From<Star> for BinOp {\n+    fn from(node: Star) -> BinOp {\n+        BinOp::Star(node)\n+    }\n+}\n+impl From<Minus> for BinOp {\n+    fn from(node: Minus) -> BinOp {\n+        BinOp::Minus(node)\n+    }\n+}\n+impl From<Slash> for BinOp {\n+    fn from(node: Slash) -> BinOp {\n+        BinOp::Slash(node)\n+    }\n+}\n+impl From<Percent> for BinOp {\n+    fn from(node: Percent) -> BinOp {\n+        BinOp::Percent(node)\n+    }\n+}\n+impl From<Shl> for BinOp {\n+    fn from(node: Shl) -> BinOp {\n+        BinOp::Shl(node)\n+    }\n+}\n+impl From<Shr> for BinOp {\n+    fn from(node: Shr) -> BinOp {\n+        BinOp::Shr(node)\n+    }\n+}\n+impl From<Caret> for BinOp {\n+    fn from(node: Caret) -> BinOp {\n+        BinOp::Caret(node)\n+    }\n+}\n+impl From<Pipe> for BinOp {\n+    fn from(node: Pipe) -> BinOp {\n+        BinOp::Pipe(node)\n+    }\n+}\n+impl From<Amp> for BinOp {\n+    fn from(node: Amp) -> BinOp {\n+        BinOp::Amp(node)\n+    }\n+}\n+impl From<Eq> for BinOp {\n+    fn from(node: Eq) -> BinOp {\n+        BinOp::Eq(node)\n+    }\n+}\n+impl From<Pluseq> for BinOp {\n+    fn from(node: Pluseq) -> BinOp {\n+        BinOp::Pluseq(node)\n+    }\n+}\n+impl From<Slasheq> for BinOp {\n+    fn from(node: Slasheq) -> BinOp {\n+        BinOp::Slasheq(node)\n+    }\n+}\n+impl From<Stareq> for BinOp {\n+    fn from(node: Stareq) -> BinOp {\n+        BinOp::Stareq(node)\n+    }\n+}\n+impl From<Percenteq> for BinOp {\n+    fn from(node: Percenteq) -> BinOp {\n+        BinOp::Percenteq(node)\n+    }\n+}\n+impl From<Shreq> for BinOp {\n+    fn from(node: Shreq) -> BinOp {\n+        BinOp::Shreq(node)\n+    }\n+}\n+impl From<Shleq> for BinOp {\n+    fn from(node: Shleq) -> BinOp {\n+        BinOp::Shleq(node)\n+    }\n+}\n+impl From<Minuseq> for BinOp {\n+    fn from(node: Minuseq) -> BinOp {\n+        BinOp::Minuseq(node)\n+    }\n+}\n+impl From<Pipeeq> for BinOp {\n+    fn from(node: Pipeeq) -> BinOp {\n+        BinOp::Pipeeq(node)\n+    }\n+}\n+impl From<Ampeq> for BinOp {\n+    fn from(node: Ampeq) -> BinOp {\n+        BinOp::Ampeq(node)\n+    }\n+}\n+impl From<Careteq> for BinOp {\n+    fn from(node: Careteq) -> BinOp {\n+        BinOp::Careteq(node)\n+    }\n+}\n+impl std::fmt::Display for BinOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for BinOp {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PIPEPIPE | AMPAMP | EQEQ | NEQ | LTEQ | GTEQ | L_ANGLE | R_ANGLE | PLUS | STAR\n+            | MINUS | SLASH | PERCENT | SHL | SHR | CARET | PIPE | AMP | EQ | PLUSEQ | SLASHEQ\n+            | STAREQ | PERCENTEQ | SHREQ | SHLEQ | MINUSEQ | PIPEEQ | AMPEQ | CARETEQ => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            PIPEPIPE => BinOp::Pipepipe(Pipepipe { syntax }),\n+            AMPAMP => BinOp::Ampamp(Ampamp { syntax }),\n+            EQEQ => BinOp::Eqeq(Eqeq { syntax }),\n+            NEQ => BinOp::Neq(Neq { syntax }),\n+            LTEQ => BinOp::Lteq(Lteq { syntax }),\n+            GTEQ => BinOp::Gteq(Gteq { syntax }),\n+            L_ANGLE => BinOp::LAngle(LAngle { syntax }),\n+            R_ANGLE => BinOp::RAngle(RAngle { syntax }),\n+            PLUS => BinOp::Plus(Plus { syntax }),\n+            STAR => BinOp::Star(Star { syntax }),\n+            MINUS => BinOp::Minus(Minus { syntax }),\n+            SLASH => BinOp::Slash(Slash { syntax }),\n+            PERCENT => BinOp::Percent(Percent { syntax }),\n+            SHL => BinOp::Shl(Shl { syntax }),\n+            SHR => BinOp::Shr(Shr { syntax }),\n+            CARET => BinOp::Caret(Caret { syntax }),\n+            PIPE => BinOp::Pipe(Pipe { syntax }),\n+            AMP => BinOp::Amp(Amp { syntax }),\n+            EQ => BinOp::Eq(Eq { syntax }),\n+            PLUSEQ => BinOp::Pluseq(Pluseq { syntax }),\n+            SLASHEQ => BinOp::Slasheq(Slasheq { syntax }),\n+            STAREQ => BinOp::Stareq(Stareq { syntax }),\n+            PERCENTEQ => BinOp::Percenteq(Percenteq { syntax }),\n+            SHREQ => BinOp::Shreq(Shreq { syntax }),\n+            SHLEQ => BinOp::Shleq(Shleq { syntax }),\n+            MINUSEQ => BinOp::Minuseq(Minuseq { syntax }),\n+            PIPEEQ => BinOp::Pipeeq(Pipeeq { syntax }),\n+            AMPEQ => BinOp::Ampeq(Ampeq { syntax }),\n+            CARETEQ => BinOp::Careteq(Careteq { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            BinOp::Pipepipe(it) => &it.syntax,\n+            BinOp::Ampamp(it) => &it.syntax,\n+            BinOp::Eqeq(it) => &it.syntax,\n+            BinOp::Neq(it) => &it.syntax,\n+            BinOp::Lteq(it) => &it.syntax,\n+            BinOp::Gteq(it) => &it.syntax,\n+            BinOp::LAngle(it) => &it.syntax,\n+            BinOp::RAngle(it) => &it.syntax,\n+            BinOp::Plus(it) => &it.syntax,\n+            BinOp::Star(it) => &it.syntax,\n+            BinOp::Minus(it) => &it.syntax,\n+            BinOp::Slash(it) => &it.syntax,\n+            BinOp::Percent(it) => &it.syntax,\n+            BinOp::Shl(it) => &it.syntax,\n+            BinOp::Shr(it) => &it.syntax,\n+            BinOp::Caret(it) => &it.syntax,\n+            BinOp::Pipe(it) => &it.syntax,\n+            BinOp::Amp(it) => &it.syntax,\n+            BinOp::Eq(it) => &it.syntax,\n+            BinOp::Pluseq(it) => &it.syntax,\n+            BinOp::Slasheq(it) => &it.syntax,\n+            BinOp::Stareq(it) => &it.syntax,\n+            BinOp::Percenteq(it) => &it.syntax,\n+            BinOp::Shreq(it) => &it.syntax,\n+            BinOp::Shleq(it) => &it.syntax,\n+            BinOp::Minuseq(it) => &it.syntax,\n+            BinOp::Pipeeq(it) => &it.syntax,\n+            BinOp::Ampeq(it) => &it.syntax,\n+            BinOp::Careteq(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum PrefixOp {\n+    Minus(Minus),\n+    Excl(Excl),\n+    Star(Star),\n+}\n+impl From<Minus> for PrefixOp {\n+    fn from(node: Minus) -> PrefixOp {\n+        PrefixOp::Minus(node)\n+    }\n+}\n+impl From<Excl> for PrefixOp {\n+    fn from(node: Excl) -> PrefixOp {\n+        PrefixOp::Excl(node)\n+    }\n+}\n+impl From<Star> for PrefixOp {\n+    fn from(node: Star) -> PrefixOp {\n+        PrefixOp::Star(node)\n+    }\n+}\n+impl std::fmt::Display for PrefixOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for PrefixOp {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MINUS | EXCL | STAR => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            MINUS => PrefixOp::Minus(Minus { syntax }),\n+            EXCL => PrefixOp::Excl(Excl { syntax }),\n+            STAR => PrefixOp::Star(Star { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            PrefixOp::Minus(it) => &it.syntax,\n+            PrefixOp::Excl(it) => &it.syntax,\n+            PrefixOp::Star(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum RangeOp {\n+    Dotdot(Dotdot),\n+    Dotdoteq(Dotdoteq),\n+}\n+impl From<Dotdot> for RangeOp {\n+    fn from(node: Dotdot) -> RangeOp {\n+        RangeOp::Dotdot(node)\n+    }\n+}\n+impl From<Dotdoteq> for RangeOp {\n+    fn from(node: Dotdoteq) -> RangeOp {\n+        RangeOp::Dotdoteq(node)\n+    }\n+}\n+impl std::fmt::Display for RangeOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for RangeOp {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            DOTDOT | DOTDOTEQ => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            DOTDOT => RangeOp::Dotdot(Dotdot { syntax }),\n+            DOTDOTEQ => RangeOp::Dotdoteq(Dotdoteq { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            RangeOp::Dotdot(it) => &it.syntax,\n+            RangeOp::Dotdoteq(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum LiteralToken {\n+    IntNumber(IntNumber),\n+    FloatNumber(FloatNumber),\n+    String(String),\n+    RawString(RawString),\n+    TrueKw(TrueKw),\n+    FalseKw(FalseKw),\n+    ByteString(ByteString),\n+    RawByteString(RawByteString),\n+    Char(Char),\n+    Byte(Byte),\n+}\n+impl From<IntNumber> for LiteralToken {\n+    fn from(node: IntNumber) -> LiteralToken {\n+        LiteralToken::IntNumber(node)\n+    }\n+}\n+impl From<FloatNumber> for LiteralToken {\n+    fn from(node: FloatNumber) -> LiteralToken {\n+        LiteralToken::FloatNumber(node)\n+    }\n+}\n+impl From<String> for LiteralToken {\n+    fn from(node: String) -> LiteralToken {\n+        LiteralToken::String(node)\n+    }\n+}\n+impl From<RawString> for LiteralToken {\n+    fn from(node: RawString) -> LiteralToken {\n+        LiteralToken::RawString(node)\n+    }\n+}\n+impl From<TrueKw> for LiteralToken {\n+    fn from(node: TrueKw) -> LiteralToken {\n+        LiteralToken::TrueKw(node)\n+    }\n+}\n+impl From<FalseKw> for LiteralToken {\n+    fn from(node: FalseKw) -> LiteralToken {\n+        LiteralToken::FalseKw(node)\n+    }\n+}\n+impl From<ByteString> for LiteralToken {\n+    fn from(node: ByteString) -> LiteralToken {\n+        LiteralToken::ByteString(node)\n+    }\n+}\n+impl From<RawByteString> for LiteralToken {\n+    fn from(node: RawByteString) -> LiteralToken {\n+        LiteralToken::RawByteString(node)\n+    }\n+}\n+impl From<Char> for LiteralToken {\n+    fn from(node: Char) -> LiteralToken {\n+        LiteralToken::Char(node)\n+    }\n+}\n+impl From<Byte> for LiteralToken {\n+    fn from(node: Byte) -> LiteralToken {\n+        LiteralToken::Byte(node)\n+    }\n+}\n+impl std::fmt::Display for LiteralToken {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for LiteralToken {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            INT_NUMBER | FLOAT_NUMBER | STRING | RAW_STRING | TRUE_KW | FALSE_KW | BYTE_STRING\n+            | RAW_BYTE_STRING | CHAR | BYTE => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            INT_NUMBER => LiteralToken::IntNumber(IntNumber { syntax }),\n+            FLOAT_NUMBER => LiteralToken::FloatNumber(FloatNumber { syntax }),\n+            STRING => LiteralToken::String(String { syntax }),\n+            RAW_STRING => LiteralToken::RawString(RawString { syntax }),\n+            TRUE_KW => LiteralToken::TrueKw(TrueKw { syntax }),\n+            FALSE_KW => LiteralToken::FalseKw(FalseKw { syntax }),\n+            BYTE_STRING => LiteralToken::ByteString(ByteString { syntax }),\n+            RAW_BYTE_STRING => LiteralToken::RawByteString(RawByteString { syntax }),\n+            CHAR => LiteralToken::Char(Char { syntax }),\n+            BYTE => LiteralToken::Byte(Byte { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            LiteralToken::IntNumber(it) => &it.syntax,\n+            LiteralToken::FloatNumber(it) => &it.syntax,\n+            LiteralToken::String(it) => &it.syntax,\n+            LiteralToken::RawString(it) => &it.syntax,\n+            LiteralToken::TrueKw(it) => &it.syntax,\n+            LiteralToken::FalseKw(it) => &it.syntax,\n+            LiteralToken::ByteString(it) => &it.syntax,\n+            LiteralToken::RawByteString(it) => &it.syntax,\n+            LiteralToken::Char(it) => &it.syntax,\n+            LiteralToken::Byte(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum NameRefToken {\n+    Ident(Ident),\n+    IntNumber(IntNumber),\n+}\n+impl From<Ident> for NameRefToken {\n+    fn from(node: Ident) -> NameRefToken {\n+        NameRefToken::Ident(node)\n+    }\n+}\n+impl From<IntNumber> for NameRefToken {\n+    fn from(node: IntNumber) -> NameRefToken {\n+        NameRefToken::IntNumber(node)\n+    }\n+}\n+impl std::fmt::Display for NameRefToken {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for NameRefToken {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            IDENT | INT_NUMBER => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            IDENT => NameRefToken::Ident(Ident { syntax }),\n+            INT_NUMBER => NameRefToken::IntNumber(IntNumber { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            NameRefToken::Ident(it) => &it.syntax,\n+            NameRefToken::IntNumber(it) => &it.syntax,\n+        }\n+    }\n+}"}, {"sha": "eba66ff4d90ff6052924769a9d6fa12d7a67a1b0", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4a063e651f0ec0da852ce1f87589d5c0a893c59d/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a063e651f0ec0da852ce1f87589d5c0a893c59d/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=4a063e651f0ec0da852ce1f87589d5c0a893c59d", "patch": "@@ -227,6 +227,7 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n pub(crate) struct AstSrc<'a> {\n     pub(crate) nodes: &'a [AstNodeSrc<'a>],\n     pub(crate) enums: &'a [AstEnumSrc<'a>],\n+    pub(crate) token_enums: &'a [AstEnumSrc<'a>],\n }\n \n pub(crate) struct AstNodeSrc<'a> {\n@@ -753,6 +754,13 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             // macro calls are parsed as expression statements */\n         }\n \n+        enum FieldDefList {\n+            RecordFieldDefList,\n+            TupleFieldDefList,\n+        }\n+    },\n+\n+    token_enums: &ast_enums! {\n         enum LeftDelimiter { LParen, LBrack, LCurly }\n         enum RightDelimiter { RParen, RBrack, RCurly }\n         enum RangeSeparator { Dotdot, Dotdotdot, Dotdoteq}\n@@ -817,10 +825,5 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             Ident,\n             IntNumber\n         }\n-\n-        enum FieldDefList {\n-            RecordFieldDefList,\n-            TupleFieldDefList,\n-        }\n     },\n };"}, {"sha": "9801a3dba58d53582fa1849d60739dba1259d9c2", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 90, "deletions": 80, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/4a063e651f0ec0da852ce1f87589d5c0a893c59d/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a063e651f0ec0da852ce1f87589d5c0a893c59d/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=4a063e651f0ec0da852ce1f87589d5c0a893c59d", "patch": "@@ -5,7 +5,7 @@\n \n use std::{\n     borrow::Cow,\n-    collections::{BTreeSet, HashMap, HashSet},\n+    collections::{BTreeSet, HashSet},\n };\n \n use proc_macro2::{Punct, Spacing};\n@@ -57,6 +57,7 @@ fn generate_tokens(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         .chain(kinds.literals.into_iter().copied().map(|x| x.into()))\n         .chain(kinds.tokens.into_iter().copied().map(|x| x.into()))\n         .collect();\n+\n     let tokens = all_token_kinds.iter().map(|kind_str| {\n         let kind_str = &**kind_str;\n         let kind = format_ident!(\"{}\", kind_str);\n@@ -88,10 +89,67 @@ fn generate_tokens(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         }\n     });\n \n+    let enums = grammar.token_enums.iter().map(|en| {\n+        let variants = en.variants.iter().map(|var| format_ident!(\"{}\", var)).collect::<Vec<_>>();\n+        let name = format_ident!(\"{}\", en.name);\n+        let kinds = variants\n+            .iter()\n+            .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.to_string())))\n+            .collect::<Vec<_>>();\n+        assert!(en.traits.is_empty());\n+\n+        quote! {\n+                #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+                pub enum #name {\n+                    #(#variants(#variants),)*\n+                }\n+\n+                #(\n+                impl From<#variants> for #name {\n+                    fn from(node: #variants) -> #name {\n+                        #name::#variants(node)\n+                    }\n+                }\n+                )*\n+\n+                impl std::fmt::Display for #name {\n+                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+                        std::fmt::Display::fmt(self.syntax(), f)\n+                    }\n+                }\n+\n+                impl AstToken for #name {\n+                    fn can_cast(kind: SyntaxKind) -> bool {\n+                        match kind {\n+                            #(#kinds)|* => true,\n+                            _ => false,\n+                        }\n+                    }\n+                    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+                        let res = match syntax.kind() {\n+                            #(\n+                            #kinds => #name::#variants(#variants { syntax }),\n+                            )*\n+                            _ => return None,\n+                        };\n+                        Some(res)\n+                    }\n+                    fn syntax(&self) -> &SyntaxToken {\n+                        match self {\n+                            #(\n+                            #name::#variants(it) => &it.syntax,\n+                            )*\n+                        }\n+                    }\n+                }\n+        }\n+    });\n+\n     crate::reformat(quote! {\n         use crate::{SyntaxToken, SyntaxKind::{self, *}, ast::AstToken};\n \n         #(#tokens)*\n+        #(#enums)*\n     })\n }\n \n@@ -113,44 +171,15 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         .chain(kinds.tokens.into_iter().copied().map(|x| x.into()))\n         .collect();\n \n-    let mut element_kinds_map = HashMap::new();\n+    let mut token_kinds = HashSet::new();\n     for kind in &all_token_kinds {\n         let kind = &**kind;\n         let name = to_pascal_case(kind);\n-        element_kinds_map.insert(\n-            name,\n-            ElementKinds {\n-                kinds: Some(format_ident!(\"{}\", kind)).into_iter().collect(),\n-                has_nodes: false,\n-                has_tokens: true,\n-            },\n-        );\n+        token_kinds.insert(name);\n     }\n \n-    for kind in kinds.nodes {\n-        let name = to_pascal_case(kind);\n-        element_kinds_map.insert(\n-            name,\n-            ElementKinds {\n-                kinds: Some(format_ident!(\"{}\", *kind)).into_iter().collect(),\n-                has_nodes: true,\n-                has_tokens: false,\n-            },\n-        );\n-    }\n-\n-    for en in grammar.enums {\n-        let mut element_kinds: ElementKinds = Default::default();\n-        for variant in en.variants {\n-            if let Some(variant_element_kinds) = element_kinds_map.get(*variant) {\n-                element_kinds.kinds.extend(variant_element_kinds.kinds.iter().cloned());\n-                element_kinds.has_tokens |= variant_element_kinds.has_tokens;\n-                element_kinds.has_nodes |= variant_element_kinds.has_nodes;\n-            } else {\n-                panic!(\"Enum variant has type that does not exist or was not declared before the enum: {}\", *variant);\n-            }\n-        }\n-        element_kinds_map.insert(en.name.to_string(), element_kinds);\n+    for en in grammar.token_enums {\n+        token_kinds.insert(en.name.to_string());\n     }\n \n     let nodes = grammar.nodes.iter().map(|node| {\n@@ -182,7 +211,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                     }\n                 }\n                 FieldSrc::Optional(_) | FieldSrc::Shorthand => {\n-                    let is_token = element_kinds_map[&ty.to_string()].has_tokens;\n+                    let is_token = token_kinds.contains(&ty.to_string());\n                     if is_token {\n                         quote! {\n                             pub fn #method_name(&self) -> Option<#ty> {\n@@ -245,48 +274,6 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             quote!(impl ast::#trait_name for #name {})\n         });\n \n-        let element_kinds = &element_kinds_map[&en.name.to_string()];\n-        assert!(\n-            element_kinds.has_nodes ^ element_kinds.has_tokens,\n-            \"{}: {:#?}\",\n-            name,\n-            element_kinds\n-        );\n-        let specific_ast_trait = {\n-            let (ast_trait, syntax_type) = if element_kinds.has_tokens {\n-                (quote!(AstToken), quote!(SyntaxToken))\n-            } else {\n-                (quote!(AstNode), quote!(SyntaxNode))\n-            };\n-\n-            quote! {\n-                impl #ast_trait for #name {\n-                    fn can_cast(kind: SyntaxKind) -> bool {\n-                        match kind {\n-                            #(#kinds)|* => true,\n-                            _ => false,\n-                        }\n-                    }\n-                    fn cast(syntax: #syntax_type) -> Option<Self> {\n-                        let res = match syntax.kind() {\n-                            #(\n-                            #kinds => #name::#variants(#variants { syntax }),\n-                            )*\n-                            _ => return None,\n-                        };\n-                        Some(res)\n-                    }\n-                    fn syntax(&self) -> &#syntax_type {\n-                        match self {\n-                            #(\n-                            #name::#variants(it) => &it.syntax,\n-                            )*\n-                        }\n-                    }\n-                }\n-            }\n-        };\n-\n         quote! {\n             #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n             pub enum #name {\n@@ -307,7 +294,30 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                 }\n             }\n \n-            #specific_ast_trait\n+            impl AstNode for #name {\n+                fn can_cast(kind: SyntaxKind) -> bool {\n+                    match kind {\n+                        #(#kinds)|* => true,\n+                        _ => false,\n+                    }\n+                }\n+                fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                    let res = match syntax.kind() {\n+                        #(\n+                        #kinds => #name::#variants(#variants { syntax }),\n+                        )*\n+                        _ => return None,\n+                    };\n+                    Some(res)\n+                }\n+                fn syntax(&self) -> &SyntaxNode {\n+                    match self {\n+                        #(\n+                        #name::#variants(it) => &it.syntax,\n+                        )*\n+                    }\n+                }\n+            }\n \n             #(#traits)*\n         }\n@@ -326,8 +336,8 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n \n     let ast = quote! {\n         use crate::{\n-            SyntaxNode, SyntaxToken, SyntaxKind::{self, *},\n-            ast::{self, AstNode, AstToken, AstChildren, support},\n+            SyntaxNode, SyntaxKind::{self, *},\n+            ast::{self, AstNode, AstChildren, support},\n         };\n \n         use super::tokens::*;"}]}