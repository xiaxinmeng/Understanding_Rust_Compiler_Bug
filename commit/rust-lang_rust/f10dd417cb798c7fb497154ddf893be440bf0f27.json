{"sha": "f10dd417cb798c7fb497154ddf893be440bf0f27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMGRkNDE3Y2I3OThjN2ZiNDk3MTU0ZGRmODkzYmU0NDBiZjBmMjc=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-06-23T05:18:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-23T05:18:26Z"}, "message": "Merge pull request #209 from RalfJung/ptrs\n\nMake HashMap insertion work", "tree": {"sha": "2956560f0a9178ee1564a5bbd5bd101ee1396609", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2956560f0a9178ee1564a5bbd5bd101ee1396609"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f10dd417cb798c7fb497154ddf893be440bf0f27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f10dd417cb798c7fb497154ddf893be440bf0f27", "html_url": "https://github.com/rust-lang/rust/commit/f10dd417cb798c7fb497154ddf893be440bf0f27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f10dd417cb798c7fb497154ddf893be440bf0f27/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a1d741df9bcad1ef55f97499a09187c992e0977", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a1d741df9bcad1ef55f97499a09187c992e0977", "html_url": "https://github.com/rust-lang/rust/commit/1a1d741df9bcad1ef55f97499a09187c992e0977"}, {"sha": "d5c031640f3835ae96f6dcf52a6845cddbc80eac", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c031640f3835ae96f6dcf52a6845cddbc80eac", "html_url": "https://github.com/rust-lang/rust/commit/d5c031640f3835ae96f6dcf52a6845cddbc80eac"}], "stats": {"total": 205, "additions": 172, "deletions": 33}, "files": [{"sha": "496cefad33d555715374bfc74cabe197d9b0829d", "filename": "src/error.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f10dd417cb798c7fb497154ddf893be440bf0f27/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10dd417cb798c7fb497154ddf893be440bf0f27/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=f10dd417cb798c7fb497154ddf893be440bf0f27", "patch": "@@ -33,6 +33,7 @@ pub enum EvalError<'tcx> {\n     ExecuteMemory,\n     ArrayIndexOutOfBounds(Span, u64, u64),\n     Math(Span, ConstMathErr),\n+    Intrinsic(String),\n     OverflowingMath,\n     InvalidChar(u128),\n     OutOfMemory {\n@@ -104,6 +105,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"array index out of bounds\",\n             EvalError::Math(..) =>\n                 \"mathematical operation failed\",\n+            EvalError::Intrinsic(..) =>\n+                \"intrinsic failed\",\n             EvalError::OverflowingMath =>\n                 \"attempted to do overflowing math\",\n             EvalError::NoMirFor(..) =>\n@@ -168,6 +171,8 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"index out of bounds: the len is {} but the index is {} at {:?}\", len, index, span),\n             EvalError::Math(span, ref err) =>\n                 write!(f, \"{:?} at {:?}\", err, span),\n+            EvalError::Intrinsic(ref err) =>\n+                write!(f, \"{}\", err),\n             EvalError::InvalidChar(c) =>\n                 write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c),\n             EvalError::OutOfMemory { allocation_size, memory_size, memory_usage } =>"}, {"sha": "4cb66f2acdc87bfd401256478a49200c0f0f5ff1", "filename": "src/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f10dd417cb798c7fb497154ddf893be440bf0f27/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10dd417cb798c7fb497154ddf893be440bf0f27/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=f10dd417cb798c7fb497154ddf893be440bf0f27", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 StaticKind::Immutable => \" (immutable)\",\n                 StaticKind::NotStatic => \"\",\n             };\n-            trace!(\"{}({} bytes){}\", msg, alloc.bytes.len(), immutable);\n+            trace!(\"{}({} bytes, alignment {}){}\", msg, alloc.bytes.len(), alloc.align, immutable);\n \n             if !relocations.is_empty() {\n                 msg.clear();"}, {"sha": "ed69c8043939b0a728a31a0ce93e0a91c477e5e2", "filename": "src/operator.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f10dd417cb798c7fb497154ddf893be440bf0f27/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10dd417cb798c7fb497154ddf893be440bf0f27/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=f10dd417cb798c7fb497154ddf893be440bf0f27", "patch": "@@ -13,7 +13,6 @@ use value::{\n     bytes_to_f64,\n     f32_to_bytes,\n     f64_to_bytes,\n-    bytes_to_bool,\n };\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n@@ -190,19 +189,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 }\n                 // These work if one operand is a pointer, the other an integer\n-                Add | Sub\n+                Add | BitAnd | Sub\n                 if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n                 && left.is_ptr() && right.is_bytes() => {\n                     // Cast to i128 is fine as we checked the kind to be ptr-sized\n-                    let (res, over) = self.ptr_int_arithmetic(bin_op, left.to_ptr()?, right.to_bytes()? as i128, left_kind == isize)?;\n-                    return Ok((PrimVal::Ptr(res), over));\n+                    return self.ptr_int_arithmetic(bin_op, left.to_ptr()?, right.to_bytes()? as i128, left_kind == isize);\n                 }\n-                Add\n+                Add | BitAnd\n                 if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n                 && left.is_bytes() && right.is_ptr() => {\n                     // This is a commutative operation, just swap the operands\n-                    let (res, over) = self.ptr_int_arithmetic(bin_op, right.to_ptr()?, left.to_bytes()? as i128, left_kind == isize)?;\n-                    return Ok((PrimVal::Ptr(res), over));\n+                    return self.ptr_int_arithmetic(bin_op, right.to_ptr()?, left.to_bytes()? as i128, left_kind == isize);\n                 }\n                 _ => {}\n             }\n@@ -287,18 +284,40 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         left: Pointer,\n         right: i128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (Pointer, bool)> {\n+    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n         use rustc::mir::BinOp::*;\n \n+        fn map_to_primval((res, over) : (Pointer, bool)) -> (PrimVal, bool) {\n+            (PrimVal::Ptr(res), over)\n+        }\n+\n         Ok(match bin_op {\n             Sub =>\n                 // The only way this can overflow is by underflowing, so signdeness of the right operands does not matter\n-                left.overflowing_signed_offset(-right, self.memory.layout),\n+                map_to_primval(left.overflowing_signed_offset(-right, self.memory.layout)),\n             Add if signed =>\n-                left.overflowing_signed_offset(right, self.memory.layout),\n+                map_to_primval(left.overflowing_signed_offset(right, self.memory.layout)),\n             Add if !signed =>\n-                left.overflowing_offset(right as u64, self.memory.layout),\n-            _ => bug!(\"ptr_int_arithmetic called on unsupported operation\")\n+                map_to_primval(left.overflowing_offset(right as u64, self.memory.layout)),\n+\n+            BitAnd if !signed => {\n+                let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align - 1);\n+                let right = right as u64;\n+                if right & base_mask == base_mask {\n+                    // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n+                    (PrimVal::Ptr(Pointer::new(left.alloc_id, left.offset & right)), false)\n+                } else if right & base_mask == 0 {\n+                    // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n+                    (PrimVal::from_u128((left.offset & right) as u128), false)\n+                } else {\n+                    return Err(EvalError::ReadPointerAsBytes);\n+                }\n+            }\n+\n+            _ => {\n+                let msg = format!(\"unimplemented binary op on pointer {:?}: {:?}, {:?} ({})\", bin_op, left, right, if signed { \"signed\" } else { \"unsigned\" });\n+                return Err(EvalError::Unimplemented(msg));\n+            }\n         })\n     }\n }\n@@ -314,7 +333,7 @@ pub fn unary_op<'tcx>(\n     let bytes = val.to_bytes()?;\n \n     let result_bytes = match (un_op, val_kind) {\n-        (Not, Bool) => !bytes_to_bool(bytes) as u128,\n+        (Not, Bool) => !val.to_bool()? as u128,\n \n         (Not, U8)  => !(bytes as u8) as u128,\n         (Not, U16) => !(bytes as u16) as u128,"}, {"sha": "5fd0cc58022033e58cce99fdffbd5b94a061e344", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f10dd417cb798c7fb497154ddf893be440bf0f27/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10dd417cb798c7fb497154ddf893be440bf0f27/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=f10dd417cb798c7fb497154ddf893be440bf0f27", "patch": "@@ -154,12 +154,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"ctpop\" |\n             \"cttz\" |\n+            \"cttz_nonzero\" |\n             \"ctlz\" |\n+            \"ctlz_nonzero\" |\n             \"bswap\" => {\n                 let ty = substs.type_at(0);\n-                let num = self.value_to_primval(arg_vals[0], ty)?;\n+                let num = self.value_to_primval(arg_vals[0], ty)?.to_bytes()?;\n                 let kind = self.ty_to_primval_kind(ty)?;\n-                let num = numeric_intrinsic(intrinsic_name, num, kind)?;\n+                let num = if intrinsic_name.ends_with(\"_nonzero\") {\n+                    if num == 0 {\n+                        return Err(EvalError::Intrinsic(format!(\"{} called on 0\", intrinsic_name)))\n+                    }\n+                    numeric_intrinsic(intrinsic_name.trim_right_matches(\"_nonzero\"), num, kind)?\n+                } else {\n+                    numeric_intrinsic(intrinsic_name, num, kind)?\n+                };\n                 self.write_primval(dest, num, ty)?;\n             }\n \n@@ -538,13 +547,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n fn numeric_intrinsic<'tcx>(\n     name: &str,\n-    val: PrimVal,\n+    bytes: u128,\n     kind: PrimValKind\n ) -> EvalResult<'tcx, PrimVal> {\n     macro_rules! integer_intrinsic {\n         ($method:ident) => ({\n-            let bytes = val.to_bytes()?;\n-\n             use value::PrimValKind::*;\n             let result_bytes = match kind {\n                 I8 => (bytes as i8).$method() as u128,\n@@ -557,7 +564,7 @@ fn numeric_intrinsic<'tcx>(\n                 U64 => (bytes as u64).$method() as u128,\n                 I128 => (bytes as i128).$method() as u128,\n                 U128 => bytes.$method() as u128,\n-                _ => bug!(\"invalid `{}` argument: {:?}\", name, val),\n+                _ => bug!(\"invalid `{}` argument: {:?}\", name, bytes),\n             };\n \n             PrimVal::Bytes(result_bytes)"}, {"sha": "9f7d3eafe1fb7133325be5dff96f6f7044dfcd9b", "filename": "src/value.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f10dd417cb798c7fb497154ddf893be440bf0f27/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10dd417cb798c7fb497154ddf893be440bf0f27/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=f10dd417cb798c7fb497154ddf893be440bf0f27", "patch": "@@ -23,12 +23,6 @@ pub(super) fn f64_to_bytes(f: f64) -> u128 {\n     unsafe { transmute::<f64, u64>(f) as u128 }\n }\n \n-pub(super) fn bytes_to_bool(n: u128) -> bool {\n-    // FIXME(solson): Can we reach here due to user error?\n-    debug_assert!(n == 0 || n == 1, \"bytes interpreted as bool were {}\", n);\n-    n & 1 == 1\n-}\n-\n /// A `Value` represents a single self-contained Rust value.\n ///\n /// A `Value` can either refer to a block of memory inside an allocation (`ByRef`) or to a primitve"}, {"sha": "a30c054ab5d0486fd57255dd86bebc03a2918c25", "filename": "tests/compile-fail/bitop-beyond-alignment.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f10dd417cb798c7fb497154ddf893be440bf0f27/tests%2Fcompile-fail%2Fbitop-beyond-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10dd417cb798c7fb497154ddf893be440bf0f27/tests%2Fcompile-fail%2Fbitop-beyond-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbitop-beyond-alignment.rs?ref=f10dd417cb798c7fb497154ddf893be440bf0f27", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+use std::mem;\n+\n+enum Tag<A> {\n+    Tag2(A)\n+}\n+\n+struct Rec {\n+    c8: u8,\n+    t: Tag<u64>\n+}\n+\n+fn mk_rec() -> Rec {\n+    return Rec { c8:0, t:Tag::Tag2(0) };\n+}\n+\n+fn is_u64_aligned(u: &Tag<u64>) -> bool {\n+    let p: usize = unsafe { mem::transmute(u) };\n+    let u64_align = std::mem::align_of::<u64>();\n+    return (p & (u64_align + 1)) == 0; //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n+}\n+\n+pub fn main() {\n+    let x = mk_rec();\n+    assert!(is_u64_aligned(&x.t));\n+}"}, {"sha": "704c4d4b7d462d79a86419ff50567374c7c49424", "filename": "tests/compile-fail/ctlz_nonzero.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f10dd417cb798c7fb497154ddf893be440bf0f27/tests%2Fcompile-fail%2Fctlz_nonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10dd417cb798c7fb497154ddf893be440bf0f27/tests%2Fcompile-fail%2Fctlz_nonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fctlz_nonzero.rs?ref=f10dd417cb798c7fb497154ddf893be440bf0f27", "patch": "@@ -0,0 +1,15 @@\n+#![feature(intrinsics)]\n+\n+mod rusti {\n+    extern \"rust-intrinsic\" {\n+        pub fn ctlz_nonzero<T>(x: T) -> T;\n+    }\n+}\n+\n+pub fn main() {\n+    unsafe {\n+        use rusti::*;\n+\n+        ctlz_nonzero(0u8); //~ ERROR: ctlz_nonzero called on 0\n+    }\n+}"}, {"sha": "eda25c66152146e3b482e98e5bb9af1688771303", "filename": "tests/compile-fail/cttz_nonzero.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f10dd417cb798c7fb497154ddf893be440bf0f27/tests%2Fcompile-fail%2Fcttz_nonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10dd417cb798c7fb497154ddf893be440bf0f27/tests%2Fcompile-fail%2Fcttz_nonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcttz_nonzero.rs?ref=f10dd417cb798c7fb497154ddf893be440bf0f27", "patch": "@@ -0,0 +1,15 @@\n+#![feature(intrinsics)]\n+\n+mod rusti {\n+    extern \"rust-intrinsic\" {\n+        pub fn cttz_nonzero<T>(x: T) -> T;\n+    }\n+}\n+\n+pub fn main() {\n+    unsafe {\n+        use rusti::*;\n+\n+        cttz_nonzero(0u8); //~ ERROR: cttz_nonzero called on 0\n+    }\n+}"}, {"sha": "f4a358174f555bce8e38d0a3f9427d52fe0e93b9", "filename": "tests/run-pass-fullmir/hashmap.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f10dd417cb798c7fb497154ddf893be440bf0f27/tests%2Frun-pass-fullmir%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10dd417cb798c7fb497154ddf893be440bf0f27/tests%2Frun-pass-fullmir%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fhashmap.rs?ref=f10dd417cb798c7fb497154ddf893be440bf0f27", "patch": "@@ -2,14 +2,24 @@ use std::collections::{self, HashMap};\n use std::hash::BuildHasherDefault;\n \n fn main() {\n-    let map : HashMap<String, i32, BuildHasherDefault<collections::hash_map::DefaultHasher>> = Default::default();\n+    let mut map : HashMap<i32, i32, BuildHasherDefault<collections::hash_map::DefaultHasher>> = Default::default();\n+    map.insert(0, 0);\n     assert_eq!(map.values().fold(0, |x, y| x+y), 0);\n \n-    // TODO: This performs bit operations on the least significant bit of a pointer\n-//     for i in 0..33 {\n-//         map.insert(format!(\"key_{}\", i), i);\n-//         assert_eq!(map.values().fold(0, |x, y| x+y), i*(i+1)/2);\n-//     }\n+    let table_base = map.get(&0).unwrap() as *const _;\n+\n+    let num = 22; // large enough to trigger a resize\n+    for i in 1..num {\n+        map.insert(i, i);\n+    }\n+    assert!(table_base != map.get(&0).unwrap() as *const _); // make sure relocation happened\n+    assert_eq!(map.values().fold(0, |x, y| x+y), num*(num-1)/2); // check the right things are in the table now\n+\n+    // Inserting again replaces the existing entries\n+    for i in 0..num {\n+        map.insert(i, num-1-i);\n+    }\n+    assert_eq!(map.values().fold(0, |x, y| x+y), num*(num-1)/2);\n \n     // TODO: Test Entry API\n }"}, {"sha": "4896f02da20b0b280e6fde0dbd555a4e5c4c8c1e", "filename": "tests/run-pass/intrinsics-integer.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f10dd417cb798c7fb497154ddf893be440bf0f27/tests%2Frun-pass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10dd417cb798c7fb497154ddf893be440bf0f27/tests%2Frun-pass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintrinsics-integer.rs?ref=f10dd417cb798c7fb497154ddf893be440bf0f27", "patch": "@@ -14,7 +14,9 @@ mod rusti {\n     extern \"rust-intrinsic\" {\n         pub fn ctpop<T>(x: T) -> T;\n         pub fn ctlz<T>(x: T) -> T;\n+        pub fn ctlz_nonzero<T>(x: T) -> T;\n         pub fn cttz<T>(x: T) -> T;\n+        pub fn cttz_nonzero<T>(x: T) -> T;\n         pub fn bswap<T>(x: T) -> T;\n     }\n }\n@@ -68,6 +70,21 @@ pub fn main() {\n         assert_eq!(ctlz(100u32), 25); assert_eq!(ctlz(100i32), 25);\n         assert_eq!(ctlz(100u64), 57); assert_eq!(ctlz(100i64), 57);\n \n+        assert_eq!(ctlz_nonzero(1u8), 7); assert_eq!(ctlz_nonzero(1i8), 7);\n+        assert_eq!(ctlz_nonzero(1u16), 15); assert_eq!(ctlz_nonzero(1i16), 15);\n+        assert_eq!(ctlz_nonzero(1u32), 31); assert_eq!(ctlz_nonzero(1i32), 31);\n+        assert_eq!(ctlz_nonzero(1u64), 63); assert_eq!(ctlz_nonzero(1i64), 63);\n+\n+        assert_eq!(ctlz_nonzero(10u8), 4); assert_eq!(ctlz_nonzero(10i8), 4);\n+        assert_eq!(ctlz_nonzero(10u16), 12); assert_eq!(ctlz_nonzero(10i16), 12);\n+        assert_eq!(ctlz_nonzero(10u32), 28); assert_eq!(ctlz_nonzero(10i32), 28);\n+        assert_eq!(ctlz_nonzero(10u64), 60); assert_eq!(ctlz_nonzero(10i64), 60);\n+\n+        assert_eq!(ctlz_nonzero(100u8), 1); assert_eq!(ctlz_nonzero(100i8), 1);\n+        assert_eq!(ctlz_nonzero(100u16), 9); assert_eq!(ctlz_nonzero(100i16), 9);\n+        assert_eq!(ctlz_nonzero(100u32), 25); assert_eq!(ctlz_nonzero(100i32), 25);\n+        assert_eq!(ctlz_nonzero(100u64), 57); assert_eq!(ctlz_nonzero(100i64), 57);\n+\n         assert_eq!(cttz(-1i8 as u8), 0); assert_eq!(cttz(-1i8), 0);\n         assert_eq!(cttz(-1i16 as u16), 0); assert_eq!(cttz(-1i16), 0);\n         assert_eq!(cttz(-1i32 as u32), 0); assert_eq!(cttz(-1i32), 0);\n@@ -93,6 +110,26 @@ pub fn main() {\n         assert_eq!(cttz(100u32), 2); assert_eq!(cttz(100i32), 2);\n         assert_eq!(cttz(100u64), 2); assert_eq!(cttz(100i64), 2);\n \n+        assert_eq!(cttz_nonzero(-1i8 as u8), 0); assert_eq!(cttz_nonzero(-1i8), 0);\n+        assert_eq!(cttz_nonzero(-1i16 as u16), 0); assert_eq!(cttz_nonzero(-1i16), 0);\n+        assert_eq!(cttz_nonzero(-1i32 as u32), 0); assert_eq!(cttz_nonzero(-1i32), 0);\n+        assert_eq!(cttz_nonzero(-1i64 as u64), 0); assert_eq!(cttz_nonzero(-1i64), 0);\n+\n+        assert_eq!(cttz_nonzero(1u8), 0); assert_eq!(cttz_nonzero(1i8), 0);\n+        assert_eq!(cttz_nonzero(1u16), 0); assert_eq!(cttz_nonzero(1i16), 0);\n+        assert_eq!(cttz_nonzero(1u32), 0); assert_eq!(cttz_nonzero(1i32), 0);\n+        assert_eq!(cttz_nonzero(1u64), 0); assert_eq!(cttz_nonzero(1i64), 0);\n+\n+        assert_eq!(cttz_nonzero(10u8), 1); assert_eq!(cttz_nonzero(10i8), 1);\n+        assert_eq!(cttz_nonzero(10u16), 1); assert_eq!(cttz_nonzero(10i16), 1);\n+        assert_eq!(cttz_nonzero(10u32), 1); assert_eq!(cttz_nonzero(10i32), 1);\n+        assert_eq!(cttz_nonzero(10u64), 1); assert_eq!(cttz_nonzero(10i64), 1);\n+\n+        assert_eq!(cttz_nonzero(100u8), 2); assert_eq!(cttz_nonzero(100i8), 2);\n+        assert_eq!(cttz_nonzero(100u16), 2); assert_eq!(cttz_nonzero(100i16), 2);\n+        assert_eq!(cttz_nonzero(100u32), 2); assert_eq!(cttz_nonzero(100i32), 2);\n+        assert_eq!(cttz_nonzero(100u64), 2); assert_eq!(cttz_nonzero(100i64), 2);\n+\n         assert_eq!(bswap(0x0Au8), 0x0A); // no-op\n         assert_eq!(bswap(0x0Ai8), 0x0A); // no-op\n         assert_eq!(bswap(0x0A0Bu16), 0x0B0A);"}, {"sha": "81c19022ab080c4f1aa1be0107c24819ab67f910", "filename": "tests/run-pass/tag-align-dyn-u64.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f10dd417cb798c7fb497154ddf893be440bf0f27/tests%2Frun-pass%2Ftag-align-dyn-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f10dd417cb798c7fb497154ddf893be440bf0f27/tests%2Frun-pass%2Ftag-align-dyn-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftag-align-dyn-u64.rs?ref=f10dd417cb798c7fb497154ddf893be440bf0f27", "patch": "@@ -28,7 +28,7 @@ fn mk_rec() -> Rec {\n fn is_u64_aligned(u: &Tag<u64>) -> bool {\n     let p: usize = unsafe { mem::transmute(u) };\n     let u64_align = std::mem::align_of::<u64>();\n-    return (p & (u64_align - 1)) == 0; //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n+    return (p & (u64_align - 1)) == 0;\n }\n \n pub fn main() {", "previous_filename": "tests/compile-fail/tag-align-dyn-u64.rs"}]}