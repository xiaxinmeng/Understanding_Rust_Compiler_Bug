{"sha": "3aa585e421a1c60626b339079b1aa420c1e3ab1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYTU4NWU0MjFhMWM2MDYyNmIzMzkwNzliMWFhNDIwYzFlM2FiMWQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-13T09:24:01Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-13T09:24:01Z"}, "message": "Merge remote-tracking branch 'origin/master' into function_pointers2", "tree": {"sha": "98711db92f5fd555d776f8c055825424a27a6586", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98711db92f5fd555d776f8c055825424a27a6586"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3aa585e421a1c60626b339079b1aa420c1e3ab1d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXXnuxAAoJEFbW7qD8Z6xGkmoP/2UAztpWe2wxviPbdfl1m4Bw\nh15SBPdRqYZtO5VFYRv892be/zSzjB6Hq43mnrmYokECT5jR5IjTLULFmpBkwr/Z\nN2R+TZS0JiawjOenQpEUxoG46pfmLYUt44COAOHeAFkwkxXEFO9BJKqzPY3iB83M\n9Ovs9atepVrobwvFcuVJfvwmlBArdxtnjxmzi6xm3go1cG58eYDuogO1zHaycECl\nrYpv5aTyKo5dV0vmu35DDVm7Zanq0NR4BIgFSlWIc7cLOjRwAonecy4n5OoyqItH\nCZlY/+GdDDpa44pXe0ZFHZd0b3XfrzaRkEBahfwCUOS5kjMYj1gGt/CN5zNKKgvn\neuPCHciUgJR++I0V5fqzPWofFH8enHkNt6ct/W8se3TT7/k0h9kwAd+Kmy1hSUbQ\n4OZP37vLmzWJr0Cq7tuwWOXdzbLFDOreokRPy98ldSute6WORElDQYaenyX0tBeF\nFa44vWqyfhGiSfi5zkDhE0GRC9Hd/LGrHQcpaQSo+n1ASIJLGS2mDsd6TWeD5NZ1\ngMXJzR0j1RhS22WQBVwf2D9MBwfkMq1PPLJUt1Cul4Pl7GPZpNHVjq60r2ZU/gWV\nWE/KoEjmp/A+/cWkA2nQgA23SuNVMq6fbDIirmVUSMmnHyFnbSMFc7AekCIfdEj3\nvLKPeQjbl3IXv1SGjDff\n=ndg7\n-----END PGP SIGNATURE-----", "payload": "tree 98711db92f5fd555d776f8c055825424a27a6586\nparent 4ae77b765a999610fc007bc4da43e48f6243d9bb\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465809841 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465809841 +0200\n\nMerge remote-tracking branch 'origin/master' into function_pointers2"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3aa585e421a1c60626b339079b1aa420c1e3ab1d", "html_url": "https://github.com/rust-lang/rust/commit/3aa585e421a1c60626b339079b1aa420c1e3ab1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3aa585e421a1c60626b339079b1aa420c1e3ab1d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ae77b765a999610fc007bc4da43e48f6243d9bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ae77b765a999610fc007bc4da43e48f6243d9bb", "html_url": "https://github.com/rust-lang/rust/commit/4ae77b765a999610fc007bc4da43e48f6243d9bb"}], "stats": {"total": 161, "additions": 109, "deletions": 52}, "files": [{"sha": "1b0b416e0e12c1097500479fbfecf59a0487c9cf", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 56, "deletions": 32, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3aa585e421a1c60626b339079b1aa420c1e3ab1d/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aa585e421a1c60626b339079b1aa420c1e3ab1d/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=3aa585e421a1c60626b339079b1aa420c1e3ab1d", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn alloc_ret_ptr(&mut self, output_ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<Pointer> {\n         match output_ty {\n             ty::FnConverging(ty) => {\n-                let size = self.type_size(ty, substs);\n+                let size = self.type_size_with_substs(ty, substs);\n                 Some(self.memory.allocate(size))\n             }\n             ty::FnDiverging => None,\n@@ -308,11 +308,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.tcx.normalize_associated_type(&substituted)\n     }\n \n-    fn type_size(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n-        self.type_layout(ty, substs).size(&self.tcx.data_layout).bytes() as usize\n+    fn type_size(&self, ty: Ty<'tcx>) -> usize {\n+        self.type_size_with_substs(ty, self.substs())\n     }\n \n-    fn type_layout(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> &'tcx Layout {\n+    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n+        self.type_layout_with_substs(ty, substs).size(&self.tcx.data_layout).bytes() as usize\n+    }\n+\n+    fn type_layout(&self, ty: Ty<'tcx>) -> &'tcx Layout {\n+        self.type_layout_with_substs(ty, self.substs())\n+    }\n+\n+    fn type_layout_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> &'tcx Layout {\n         // TODO(solson): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty, substs);\n \n@@ -335,7 +343,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ::log_settings::settings().indentation += 1;\n \n         let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n-            let size = self.type_size(ty, substs);\n+            let size = self.type_size_with_substs(ty, substs);\n             self.memory.allocate(size)\n         }).collect();\n \n@@ -378,7 +386,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n                 let discr_ptr = self.eval_lvalue(discr)?.to_ptr();\n                 let discr_size = self\n-                    .type_layout(self.lvalue_ty(discr), self.substs())\n+                    .type_layout(self.lvalue_ty(discr))\n                     .size(&self.tcx.data_layout)\n                     .bytes() as usize;\n                 let discr_val = self.memory.read_uint(discr_ptr, discr_size)?;\n@@ -479,7 +487,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let name = self.tcx.item_name(def_id).as_str();\n                 match fn_ty.sig.0.output {\n                     ty::FnConverging(ty) => {\n-                        let size = self.type_size(ty, self.substs());\n+                        let size = self.type_size(ty);\n                         let ret = return_ptr.unwrap();\n                         self.call_intrinsic(&name, substs, args, ret, size)\n                     }\n@@ -490,7 +498,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Abi::C => {\n                 match fn_ty.sig.0.output {\n                     ty::FnConverging(ty) => {\n-                        let size = self.type_size(ty, self.substs());\n+                        let size = self.type_size(ty);\n                         self.call_c_abi(def_id, args, return_ptr.unwrap(), size)\n                     }\n                     ty::FnDiverging => unimplemented!(),\n@@ -520,7 +528,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let last_arg = args.last().unwrap();\n                     let last = self.eval_operand(last_arg)?;\n                     let last_ty = self.operand_ty(last_arg);\n-                    let last_layout = self.type_layout(last_ty, self.substs());\n+                    let last_layout = self.type_layout(last_ty);\n                     match (&last_ty.sty, last_layout) {\n                         (&ty::TyTuple(fields),\n                          &Layout::Univariant { ref variant, .. }) => {\n@@ -587,15 +595,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         // Filling drop.\n         // FIXME(solson): Trait objects (with no static size) probably get filled, too.\n-        let size = self.type_size(ty, self.substs());\n+        let size = self.type_size(ty);\n         self.memory.drop_fill(ptr, size)?;\n \n         Ok(())\n     }\n \n     fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<u64> {\n         use rustc::ty::layout::Layout::*;\n-        let adt_layout = self.type_layout(adt_ty, self.substs());\n+        let adt_layout = self.type_layout(adt_ty);\n \n         let discr_val = match *adt_layout {\n             General { discr, .. } | CEnum { discr, .. } => {\n@@ -648,7 +656,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // FIXME(solson): Handle different integer types correctly.\n             \"add_with_overflow\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty, self.substs());\n+                let size = self.type_size(ty);\n                 let left = self.memory.read_int(args[0], size)?;\n                 let right = self.memory.read_int(args[1], size)?;\n                 let (n, overflowed) = unsafe {\n@@ -662,7 +670,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"copy_nonoverlapping\" => {\n                 let elem_ty = *substs.types.get(subst::FnSpace, 0);\n-                let elem_size = self.type_size(elem_ty, self.substs());\n+                let elem_size = self.type_size(elem_ty);\n                 let src = self.memory.read_ptr(args[0])?;\n                 let dest = self.memory.read_ptr(args[1])?;\n                 let count = self.memory.read_isize(args[2])?;\n@@ -678,7 +686,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"forget\" => {\n                 let arg_ty = *substs.types.get(subst::FnSpace, 0);\n-                let arg_size = self.type_size(arg_ty, self.substs());\n+                let arg_size = self.type_size(arg_ty);\n                 self.memory.drop_fill(args[0], arg_size)?;\n             }\n \n@@ -697,7 +705,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // FIXME(solson): Handle different integer types correctly.\n             \"mul_with_overflow\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty, self.substs());\n+                let size = self.type_size(ty);\n                 let left = self.memory.read_int(args[0], size)?;\n                 let right = self.memory.read_int(args[1], size)?;\n                 let (n, overflowed) = unsafe {\n@@ -709,7 +717,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"offset\" => {\n                 let pointee_ty = *substs.types.get(subst::FnSpace, 0);\n-                let pointee_size = self.type_size(pointee_ty, self.substs()) as isize;\n+                let pointee_size = self.type_size(pointee_ty) as isize;\n                 let ptr_arg = args[0];\n                 let offset = self.memory.read_isize(args[1])?;\n \n@@ -730,7 +738,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // FIXME(solson): Handle different integer types correctly. Use primvals?\n             \"overflowing_sub\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty, self.substs());\n+                let size = self.type_size(ty);\n                 let left = self.memory.read_int(args[0], size)?;\n                 let right = self.memory.read_int(args[1], size)?;\n                 let n = left.wrapping_sub(right);\n@@ -739,20 +747,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"size_of\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty, self.substs()) as u64;\n+                let size = self.type_size(ty) as u64;\n                 self.memory.write_uint(dest, size, dest_size)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 if self.type_is_sized(ty) {\n-                    let size = self.type_size(ty, self.substs()) as u64;\n+                    let size = self.type_size(ty) as u64;\n                     self.memory.write_uint(dest, size, dest_size)?;\n                 } else {\n                     match ty.sty {\n                         ty::TySlice(_) | ty::TyStr => {\n                             let elem_ty = ty.sequence_element_type(self.tcx);\n-                            let elem_size = self.type_size(elem_ty, self.substs()) as u64;\n+                            let elem_size = self.type_size(elem_ty) as u64;\n                             let ptr_size = self.memory.pointer_size as isize;\n                             let n = self.memory.read_usize(args[0].offset(ptr_size))?;\n                             self.memory.write_uint(dest, n * elem_size, dest_size)?;\n@@ -831,7 +839,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.write_int(dest, result, dest_size)?;\n             }\n \n-            _ => return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name))),\n+            _ => {\n+                return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n+            }\n         }\n \n         // Since we pushed no stack frame, the main loop will act\n@@ -860,7 +870,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     {\n         let dest = self.eval_lvalue(lvalue)?.to_ptr();\n         let dest_ty = self.lvalue_ty(lvalue);\n-        let dest_layout = self.type_layout(dest_ty, self.substs());\n+        let dest_layout = self.type_layout(dest_ty);\n \n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n@@ -897,7 +907,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 // FIXME(solson): Find the result type size properly. Perhaps refactor out\n                 // Projection calculations so we can do the equivalent of `dest.1` here.\n-                let s = self.type_size(left_ty, self.substs());\n+                let s = self.type_size(left_ty);\n                 self.memory.write_bool(dest.offset(s as isize), false)?;\n             }\n \n@@ -919,7 +929,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Array { .. } => {\n                         let elem_size = match dest_ty.sty {\n-                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty, self.substs()) as u64,\n+                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty) as u64,\n                             _ => panic!(\"tried to assign {:?} to non-array type {:?}\",\n                                         kind, dest_ty),\n                         };\n@@ -997,7 +1007,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Repeat(ref operand, _) => {\n                 let (elem_size, length) = match dest_ty.sty {\n-                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty, self.substs()), n),\n+                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty), n),\n                     _ => panic!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n                 };\n \n@@ -1038,7 +1048,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Box(ty) => {\n-                let size = self.type_size(ty, self.substs());\n+                let size = self.type_size(ty);\n                 let ptr = self.memory.allocate(size);\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n@@ -1065,9 +1075,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Misc => {\n                         let src = self.eval_operand(operand)?;\n+                        let src_ty = self.operand_ty(operand);\n                         // FIXME(solson): Wrong for almost everything.\n-                        let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n-                        self.memory.copy(src, dest, size)?;\n+                        warn!(\"misc cast from {:?} to {:?}\", src_ty, dest_ty);\n+                        let dest_size = self.type_size(dest_ty);\n+                        let src_size = self.type_size(src_ty);\n+\n+                        // Hack to support fat pointer -> thin pointer casts to keep tests for\n+                        // other things passing for now.\n+                        let is_fat_ptr_cast = pointee_type(src_ty).map(|ty| {\n+                            !self.type_is_sized(ty)\n+                        }).unwrap_or(false);\n+\n+                        if dest_size == src_size || is_fat_ptr_cast {\n+                            self.memory.copy(src, dest, dest_size)?;\n+                        } else {\n+                            return Err(EvalError::Unimplemented(format!(\"can't handle cast: {:?}\", rvalue)));\n+                        }\n                     }\n \n                     ReifyFnPointer => match self.operand_ty(operand).sty {\n@@ -1139,7 +1163,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<Size> {\n-        let layout = self.type_layout(ty, self.substs());\n+        let layout = self.type_layout(ty);\n \n         use rustc::ty::layout::Layout::*;\n         match *layout {\n@@ -1211,7 +1235,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Projection(ref proj) => {\n                 let base = self.eval_lvalue(&proj.base)?;\n                 let base_ty = self.lvalue_ty(&proj.base);\n-                let base_layout = self.type_layout(base_ty, self.substs());\n+                let base_layout = self.type_layout(base_ty);\n \n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n@@ -1272,7 +1296,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Index(ref operand) => {\n                         let elem_size = match base_ty.sty {\n                             ty::TyArray(elem_ty, _) |\n-                            ty::TySlice(elem_ty) => self.type_size(elem_ty, self.substs()),\n+                            ty::TySlice(elem_ty) => self.type_size(elem_ty),\n                             _ => panic!(\"indexing expected an array or slice, got {:?}\", base_ty),\n                         };\n                         let n_ptr = self.eval_operand(operand)?;\n@@ -1298,7 +1322,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n-        let size = self.type_size(ty, self.substs());\n+        let size = self.type_size(ty);\n         self.memory.copy(src, dest, size)?;\n         if self.type_needs_drop(ty) {\n             self.memory.drop_fill(src, size)?;"}, {"sha": "ad6c60ef517c6bd100799b1f53ec5785cb63a07e", "filename": "src/memory.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3aa585e421a1c60626b339079b1aa420c1e3ab1d/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aa585e421a1c60626b339079b1aa420c1e3ab1d/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=3aa585e421a1c60626b339079b1aa420c1e3ab1d", "patch": "@@ -99,17 +99,18 @@ impl<'tcx> Memory<'tcx> {\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n \n-        let alloc = self.get_mut(ptr.alloc_id)?;\n-        let size = alloc.bytes.len();\n+        let size = self.get_mut(ptr.alloc_id)?.bytes.len();\n+\n         if new_size > size {\n             let amount = new_size - size;\n+            let alloc = self.get_mut(ptr.alloc_id)?;\n             alloc.bytes.extend(iter::repeat(0).take(amount));\n             alloc.undef_mask.grow(amount, false);\n         } else if size > new_size {\n-            return Err(EvalError::Unimplemented(format!(\"unimplemented allocation relocation (from {} to {})\", size, new_size)));\n-            // alloc.bytes.truncate(new_size);\n-            // alloc.undef_mask.len = new_size;\n-            // TODO: potentially remove relocations\n+            self.clear_relocations(ptr.offset(new_size as isize), size - new_size)?;\n+            let alloc = self.get_mut(ptr.alloc_id)?;\n+            alloc.bytes.truncate(new_size);\n+            alloc.undef_mask.truncate(new_size);\n         }\n \n         Ok(())\n@@ -386,7 +387,7 @@ impl<'tcx> Memory<'tcx> {\n         -> EvalResult<btree_map::Range<usize, AllocId>>\n     {\n         let start = ptr.offset.saturating_sub(self.pointer_size - 1);\n-        let end = start + size;\n+        let end = ptr.offset + size;\n         Ok(self.get(ptr.alloc_id)?.relocations.range(Included(&start), Excluded(&end)))\n     }\n \n@@ -535,11 +536,12 @@ impl UndefMask {\n         self.len += amount;\n         self.set_range_inbounds(start, start + amount, new_state);\n     }\n-}\n \n-// fn uniform_block(state: bool) -> Block {\n-//     if state { !0 } else { 0 }\n-// }\n+    fn truncate(&mut self, length: usize) {\n+        self.len = length;\n+        self.blocks.truncate(self.len / BLOCK_SIZE + 1);\n+    }\n+}\n \n fn bit_index(bits: usize) -> (usize, usize) {\n     (bits / BLOCK_SIZE, bits % BLOCK_SIZE)"}, {"sha": "76b5b5f6e9638efe8628730e5b1574d3704002a7", "filename": "tests/compiletest.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3aa585e421a1c60626b339079b1aa420c1e3ab1d/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aa585e421a1c60626b339079b1aa420c1e3ab1d/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=3aa585e421a1c60626b339079b1aa420c1e3ab1d", "patch": "@@ -3,22 +3,32 @@ extern crate compiletest_rs as compiletest;\n use std::path::PathBuf;\n \n fn run_mode(mode: &'static str) {\n+    // Disable rustc's new error fomatting. It breaks these tests.\n+    std::env::remove_var(\"RUST_NEW_ERROR_FORMAT\");\n+\n+    // Taken from https://github.com/Manishearth/rust-clippy/pull/911.\n+    let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n+    let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n+    let sysroot = match (home, toolchain) {\n+        (Some(home), Some(toolchain)) => format!(\"{}/toolchains/{}\", home, toolchain),\n+        _ => option_env!(\"RUST_SYSROOT\")\n+            .expect(\"need to specify RUST_SYSROOT env var or use rustup or multirust\")\n+            .to_owned(),\n+    };\n+    let sysroot_flag = format!(\"--sysroot {}\", sysroot);\n+\n     // FIXME: read directories in sysroot/lib/rustlib and generate the test targets from that\n     let targets = &[\"x86_64-unknown-linux-gnu\", \"i686-unknown-linux-gnu\"];\n \n     for &target in targets {\n         let mut config = compiletest::default_config();\n+        config.host_rustcflags = Some(sysroot_flag.clone());\n+        config.mode = mode.parse().expect(\"Invalid mode\");\n+        config.run_lib_path = format!(\"{}/lib/rustlib/{}/lib\", sysroot, target);\n         config.rustc_path = \"target/debug/miri\".into();\n-        let path = std::env::var(\"RUST_SYSROOT\").expect(\"env variable `RUST_SYSROOT` not set\");\n-        config.run_lib_path = format!(\"{}/lib/rustlib/{}/lib\", path, target);\n-        let path = format!(\"--sysroot {}\", path);\n-        config.target_rustcflags = Some(path.clone());\n-        config.host_rustcflags = Some(path);\n-        let cfg_mode = mode.parse().ok().expect(\"Invalid mode\");\n-\n-        config.mode = cfg_mode;\n         config.src_base = PathBuf::from(format!(\"tests/{}\", mode));\n         config.target = target.to_owned();\n+        config.target_rustcflags = Some(sysroot_flag.clone());\n         compiletest::run_tests(&config);\n     }\n }"}, {"sha": "a7175969efac52e8a6f26c75ff8d8a9813bf1ec9", "filename": "tests/run-pass/heap.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3aa585e421a1c60626b339079b1aa420c1e3ab1d/tests%2Frun-pass%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aa585e421a1c60626b339079b1aa420c1e3ab1d/tests%2Frun-pass%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fheap.rs?ref=3aa585e421a1c60626b339079b1aa420c1e3ab1d", "patch": "@@ -11,6 +11,26 @@ fn make_box_syntax() -> Box<(i16, i16)> {\n     box (1, 2)\n }\n \n+#[miri_run]\n+fn allocate_reallocate() {\n+    let mut s = String::new();\n+\n+    // 6 byte heap alloc (__rust_allocate)\n+    s.push_str(\"foobar\");\n+    assert_eq!(s.len(), 6);\n+    assert_eq!(s.capacity(), 6);\n+\n+    // heap size doubled to 12 (__rust_reallocate)\n+    s.push_str(\"baz\");\n+    assert_eq!(s.len(), 9);\n+    assert_eq!(s.capacity(), 12);\n+\n+    // heap size reduced to 9  (__rust_reallocate)\n+    s.shrink_to_fit();\n+    assert_eq!(s.len(), 9);\n+    assert_eq!(s.capacity(), 9);\n+}\n+\n #[miri_run]\n fn main() {\n     assert_eq!(*make_box(), (1, 2));"}, {"sha": "120c196abe9759ec63e5b78d2de8d9cdf4be136b", "filename": "tests/run-pass/sums.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3aa585e421a1c60626b339079b1aa420c1e3ab1d/tests%2Frun-pass%2Fsums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aa585e421a1c60626b339079b1aa420c1e3ab1d/tests%2Frun-pass%2Fsums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsums.rs?ref=3aa585e421a1c60626b339079b1aa420c1e3ab1d", "patch": "@@ -55,7 +55,8 @@ fn two_nones() -> (Option<i16>, Option<i16>) {\n     (None, None)\n }\n \n-#[miri_run]\n+// FIXME(solson): Casts inside PartialEq fails on 32-bit.\n+#[cfg_attr(target_pointer_width = \"64\", miri_run)]\n fn main() {\n     assert_eq!(two_nones(), (None, None));\n     assert_eq!(match_opt_some(), 13);"}]}