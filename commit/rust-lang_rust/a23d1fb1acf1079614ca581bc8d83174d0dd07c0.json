{"sha": "a23d1fb1acf1079614ca581bc8d83174d0dd07c0", "node_id": "C_kwDOAAsO6NoAKGEyM2QxZmIxYWNmMTA3OTYxNGNhNTgxYmM4ZDgzMTc0ZDBkZDA3YzA", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-28T13:48:07Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-28T13:48:18Z"}, "message": "implement thread parking on Windows", "tree": {"sha": "5bd63f83c8a507e44e33fc7579455b37a0f4e9a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bd63f83c8a507e44e33fc7579455b37a0f4e9a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a23d1fb1acf1079614ca581bc8d83174d0dd07c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a23d1fb1acf1079614ca581bc8d83174d0dd07c0", "html_url": "https://github.com/rust-lang/rust/commit/a23d1fb1acf1079614ca581bc8d83174d0dd07c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4827d41466af1e9b5f3a38d55f8f99e66e3f6842", "url": "https://api.github.com/repos/rust-lang/rust/commits/4827d41466af1e9b5f3a38d55f8f99e66e3f6842", "html_url": "https://github.com/rust-lang/rust/commit/4827d41466af1e9b5f3a38d55f8f99e66e3f6842"}], "stats": {"total": 163, "additions": 155, "deletions": 8}, "files": [{"sha": "f55c0b43e39bc8d05f26592f2b8ef5c312afeceb", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=a23d1fb1acf1079614ca581bc8d83174d0dd07c0", "patch": "@@ -98,8 +98,8 @@ pub use crate::eval::{\n pub use crate::helpers::{CurrentSpan, EvalContextExt as _};\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n-    AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind, Provenance,\n-    ProvenanceExtra, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+    AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind,\n+    PrimitiveLayouts, Provenance, ProvenanceExtra, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as _;"}, {"sha": "231a99c1d034ed0ef9316dc82271b3c471b1a607", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=a23d1fb1acf1079614ca581bc8d83174d0dd07c0", "patch": "@@ -276,10 +276,14 @@ pub struct PrimitiveLayouts<'tcx> {\n     pub i8: TyAndLayout<'tcx>,\n     pub i16: TyAndLayout<'tcx>,\n     pub i32: TyAndLayout<'tcx>,\n+    pub i64: TyAndLayout<'tcx>,\n+    pub i128: TyAndLayout<'tcx>,\n     pub isize: TyAndLayout<'tcx>,\n     pub u8: TyAndLayout<'tcx>,\n     pub u16: TyAndLayout<'tcx>,\n     pub u32: TyAndLayout<'tcx>,\n+    pub u64: TyAndLayout<'tcx>,\n+    pub u128: TyAndLayout<'tcx>,\n     pub usize: TyAndLayout<'tcx>,\n     pub bool: TyAndLayout<'tcx>,\n     pub mut_raw_ptr: TyAndLayout<'tcx>,   // *mut ()\n@@ -296,16 +300,42 @@ impl<'mir, 'tcx: 'mir> PrimitiveLayouts<'tcx> {\n             i8: layout_cx.layout_of(tcx.types.i8)?,\n             i16: layout_cx.layout_of(tcx.types.i16)?,\n             i32: layout_cx.layout_of(tcx.types.i32)?,\n+            i64: layout_cx.layout_of(tcx.types.i64)?,\n+            i128: layout_cx.layout_of(tcx.types.i128)?,\n             isize: layout_cx.layout_of(tcx.types.isize)?,\n             u8: layout_cx.layout_of(tcx.types.u8)?,\n             u16: layout_cx.layout_of(tcx.types.u16)?,\n             u32: layout_cx.layout_of(tcx.types.u32)?,\n+            u64: layout_cx.layout_of(tcx.types.u64)?,\n+            u128: layout_cx.layout_of(tcx.types.u128)?,\n             usize: layout_cx.layout_of(tcx.types.usize)?,\n             bool: layout_cx.layout_of(tcx.types.bool)?,\n             mut_raw_ptr: layout_cx.layout_of(mut_raw_ptr)?,\n             const_raw_ptr: layout_cx.layout_of(const_raw_ptr)?,\n         })\n     }\n+\n+    pub fn uint(&self, size: Size) -> Option<TyAndLayout<'tcx>> {\n+        match size.bits() {\n+            8 => Some(self.u8),\n+            16 => Some(self.u16),\n+            32 => Some(self.u32),\n+            64 => Some(self.u64),\n+            128 => Some(self.u128),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn int(&self, size: Size) -> Option<TyAndLayout<'tcx>> {\n+        match size.bits() {\n+            8 => Some(self.i8),\n+            16 => Some(self.i16),\n+            32 => Some(self.i32),\n+            64 => Some(self.i64),\n+            128 => Some(self.i128),\n+            _ => None,\n+        }\n+    }\n }\n \n /// The machine itself."}, {"sha": "8ae94971f6a32a626b81e51aa1d6e41db07a1444", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=a23d1fb1acf1079614ca581bc8d83174d0dd07c0", "patch": "@@ -214,11 +214,10 @@ pub fn futex<'tcx>(\n                         }\n                     }\n \n-                    let dest = dest.clone();\n                     this.register_timeout_callback(\n                         thread,\n                         timeout_time,\n-                        Box::new(Callback { thread, addr_usize, dest }),\n+                        Box::new(Callback { thread, addr_usize, dest: dest.clone() }),\n                     );\n                 }\n             } else {"}, {"sha": "4b2a90723c79c44ff32e3bdcd4918be4053a2f36", "filename": "src/tools/miri/src/shims/windows/dlsym.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs?ref=a23d1fb1acf1079614ca581bc8d83174d0dd07c0", "patch": "@@ -6,12 +6,15 @@ use log::trace;\n \n use crate::helpers::check_arg_count;\n use crate::shims::windows::handle::{EvalContextExt as _, Handle, PseudoHandle};\n+use crate::shims::windows::sync::EvalContextExt as _;\n use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Dlsym {\n     NtWriteFile,\n     SetThreadDescription,\n+    WaitOnAddress,\n+    WakeByAddressSingle,\n }\n \n impl Dlsym {\n@@ -22,6 +25,8 @@ impl Dlsym {\n             \"GetSystemTimePreciseAsFileTime\" => None,\n             \"NtWriteFile\" => Some(Dlsym::NtWriteFile),\n             \"SetThreadDescription\" => Some(Dlsym::SetThreadDescription),\n+            \"WaitOnAddress\" => Some(Dlsym::WaitOnAddress),\n+            \"WakeByAddressSingle\" => Some(Dlsym::WakeByAddressSingle),\n             _ => throw_unsup_format!(\"unsupported Windows dlsym: {}\", name),\n         })\n     }\n@@ -127,6 +132,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n                 this.write_null(dest)?;\n             }\n+            Dlsym::WaitOnAddress => {\n+                let [ptr_op, compare_op, size_op, timeout_op] = check_arg_count(args)?;\n+\n+                this.WaitOnAddress(ptr_op, compare_op, size_op, timeout_op, dest)?;\n+            }\n+            Dlsym::WakeByAddressSingle => {\n+                let [ptr_op] = check_arg_count(args)?;\n+\n+                this.WakeByAddressSingle(ptr_op)?;\n+            }\n         }\n \n         trace!(\"{:?}\", this.dump_place(**dest));"}, {"sha": "336ba7db95f1f41a2d4b92d4c042e247f0b44a5c", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 107, "deletions": 1, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=a23d1fb1acf1079614ca581bc8d83174d0dd07c0", "patch": "@@ -1,3 +1,7 @@\n+use std::time::Duration;\n+\n+use rustc_target::abi::Size;\n+\n use crate::concurrency::init_once::InitOnceStatus;\n use crate::concurrency::thread::MachineCallback;\n use crate::*;\n@@ -6,7 +10,6 @@ const SRWLOCK_ID_OFFSET: u64 = 0;\n const INIT_ONCE_ID_OFFSET: u64 = 0;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n-\n #[allow(non_snake_case)]\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn AcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n@@ -221,4 +224,107 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         this.eval_windows(\"c\", \"TRUE\")\n     }\n+\n+    fn WaitOnAddress(\n+        &mut self,\n+        ptr_op: &OpTy<'tcx, Provenance>,\n+        compare_op: &OpTy<'tcx, Provenance>,\n+        size_op: &OpTy<'tcx, Provenance>,\n+        timeout_op: &OpTy<'tcx, Provenance>,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let ptr = this.read_pointer(ptr_op)?;\n+        let compare = this.read_pointer(compare_op)?;\n+        let size = this.read_scalar(size_op)?.to_machine_usize(this)?;\n+        let timeout_ms = this.read_scalar(timeout_op)?.to_u32()?;\n+\n+        let thread = this.get_active_thread();\n+        let addr = ptr.addr().bytes();\n+\n+        if size > 8 || !size.is_power_of_two() {\n+            let invalid_param = this.eval_windows(\"c\", \"ERROR_INVALID_PARAMETER\")?;\n+            this.set_last_error(invalid_param)?;\n+            this.write_scalar(Scalar::from_i32(0), dest)?;\n+            return Ok(());\n+        };\n+        let size = Size::from_bytes(size);\n+\n+        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+            None\n+        } else {\n+            this.check_no_isolation(\"`WaitOnAddress` with non-infinite timeout\")?;\n+\n+            let duration = Duration::from_millis(timeout_ms.into());\n+            Some(Time::Monotonic(this.machine.clock.now().checked_add(duration).unwrap()))\n+        };\n+\n+        // See the Linux futex implementation for why this fence exists.\n+        this.atomic_fence(AtomicFenceOrd::SeqCst)?;\n+\n+        let layout = this.machine.layouts.uint(size).unwrap();\n+        let futex_val = this\n+            .read_scalar_atomic(&MPlaceTy::from_aligned_ptr(ptr, layout), AtomicReadOrd::Relaxed)?;\n+        let compare_val = this.read_scalar(&MPlaceTy::from_aligned_ptr(compare, layout).into())?;\n+\n+        if futex_val == compare_val {\n+            // If the values are the same, we have to block.\n+            this.block_thread(thread);\n+            this.futex_wait(addr, thread, u32::MAX);\n+\n+            if let Some(timeout_time) = timeout_time {\n+                struct Callback<'tcx> {\n+                    thread: ThreadId,\n+                    addr: u64,\n+                    dest: PlaceTy<'tcx, Provenance>,\n+                }\n+\n+                impl<'tcx> VisitTags for Callback<'tcx> {\n+                    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                        let Callback { thread: _, addr: _, dest } = self;\n+                        dest.visit_tags(visit);\n+                    }\n+                }\n+\n+                impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+                    fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                        this.unblock_thread(self.thread);\n+                        this.futex_remove_waiter(self.addr, self.thread);\n+                        let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\")?;\n+                        this.set_last_error(error_timeout)?;\n+                        this.write_scalar(Scalar::from_i32(0), &self.dest)?;\n+\n+                        Ok(())\n+                    }\n+                }\n+\n+                this.register_timeout_callback(\n+                    thread,\n+                    timeout_time,\n+                    Box::new(Callback { thread, addr, dest: dest.clone() }),\n+                );\n+            }\n+        }\n+\n+        this.write_scalar(Scalar::from_i32(1), dest)?;\n+\n+        Ok(())\n+    }\n+\n+    fn WakeByAddressSingle(&mut self, ptr_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let ptr = this.read_pointer(ptr_op)?;\n+\n+        // See the Linux futex implementation for why this fence exists.\n+        this.atomic_fence(AtomicFenceOrd::SeqCst)?;\n+\n+        if let Some(thread) = this.futex_wake(ptr.addr().bytes(), u32::MAX) {\n+            this.unblock_thread(thread);\n+            this.unregister_timeout_callback_if_exists(thread);\n+        }\n+\n+        Ok(())\n+    }\n }"}, {"sha": "53b57942d76a4d27bb75e19fa4283bdb8bfc213f", "filename": "src/tools/miri/tests/pass/concurrency/channels.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fchannels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fchannels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fchannels.rs?ref=a23d1fb1acf1079614ca581bc8d83174d0dd07c0", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Channels on Windows are not supported yet.\n //@compile-flags: -Zmiri-strict-provenance\n \n use std::sync::mpsc::{channel, sync_channel};"}, {"sha": "44b16e1ac74d46b5efada9acf830bcbe9eea5738", "filename": "src/tools/miri/tests/pass/concurrency/spin_loops_nopreempt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs?ref=a23d1fb1acf1079614ca581bc8d83174d0dd07c0", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Channels on Windows are not supported yet.\n // This specifically tests behavior *without* preemption.\n //@compile-flags: -Zmiri-preemption-rate=0\n "}, {"sha": "6a10748ee95105977001fea0f2051fac82dbd148", "filename": "src/tools/miri/tests/pass/threadleak_ignored.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23d1fb1acf1079614ca581bc8d83174d0dd07c0/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.rs?ref=a23d1fb1acf1079614ca581bc8d83174d0dd07c0", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Channels on Windows are not supported yet.\n // FIXME: disallow preemption to work around https://github.com/rust-lang/rust/issues/55005\n //@compile-flags: -Zmiri-ignore-leaks -Zmiri-preemption-rate=0\n "}]}