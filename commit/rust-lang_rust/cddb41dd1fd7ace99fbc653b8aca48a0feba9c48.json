{"sha": "cddb41dd1fd7ace99fbc653b8aca48a0feba9c48", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkZGI0MWRkMWZkN2FjZTk5ZmJjNjUzYjhhY2E0OGEwZmViYTljNDg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-02T09:20:34Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-02T17:20:29Z"}, "message": "Do not ICE when projecting out of a value with type `ty::ty_err`", "tree": {"sha": "dfcd83a8c79f3678e36cfd30c724bf4700e5f68a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfcd83a8c79f3678e36cfd30c724bf4700e5f68a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cddb41dd1fd7ace99fbc653b8aca48a0feba9c48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cddb41dd1fd7ace99fbc653b8aca48a0feba9c48", "html_url": "https://github.com/rust-lang/rust/commit/cddb41dd1fd7ace99fbc653b8aca48a0feba9c48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cddb41dd1fd7ace99fbc653b8aca48a0feba9c48/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "64b7c22c46b204520a6fae1c5cd750a3d3c6a66a", "url": "https://api.github.com/repos/rust-lang/rust/commits/64b7c22c46b204520a6fae1c5cd750a3d3c6a66a", "html_url": "https://github.com/rust-lang/rust/commit/64b7c22c46b204520a6fae1c5cd750a3d3c6a66a"}], "stats": {"total": 81, "additions": 66, "deletions": 15}, "files": [{"sha": "125f39b1a43e5f5ae0799c791b1d5ae817d3a40b", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cddb41dd1fd7ace99fbc653b8aca48a0feba9c48/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cddb41dd1fd7ace99fbc653b8aca48a0feba9c48/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=cddb41dd1fd7ace99fbc653b8aca48a0feba9c48", "patch": "@@ -21,8 +21,10 @@ use super::VtableImplData;\n \n use middle::infer;\n use middle::subst::Subst;\n-use middle::ty::{mod, AsPredicate, RegionEscape, HasProjectionTypes, ToPolyTraitRef, Ty};\n+use middle::ty::{mod, AsPredicate, ReferencesError, RegionEscape,\n+                 HasProjectionTypes, ToPolyTraitRef, Ty};\n use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n+use std::rc::Rc;\n use util::ppaux::Repr;\n \n pub type PolyProjectionObligation<'tcx> =\n@@ -372,22 +374,34 @@ fn project_type<'cx,'tcx>(\n         return Err(ProjectionTyError::TraitSelectionError(Overflow));\n     }\n \n+    let obligation_trait_ref =\n+        selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n+\n+    debug!(\"project: obligation_trait_ref={}\", obligation_trait_ref.repr(selcx.tcx()));\n+\n+    if obligation_trait_ref.references_error() {\n+        return Ok(ProjectedTy::Progress(selcx.tcx().types.err, vec!()));\n+    }\n+\n     let mut candidates = ProjectionTyCandidateSet {\n         vec: Vec::new(),\n         ambiguous: false,\n     };\n \n     assemble_candidates_from_object_type(selcx,\n                                          obligation,\n+                                         &obligation_trait_ref,\n                                          &mut candidates);\n \n     if candidates.vec.is_empty() {\n         assemble_candidates_from_param_env(selcx,\n                                            obligation,\n+                                           &obligation_trait_ref,\n                                            &mut candidates);\n \n         if let Err(e) = assemble_candidates_from_impls(selcx,\n                                                        obligation,\n+                                                       &obligation_trait_ref,\n                                                        &mut candidates) {\n             return Err(ProjectionTyError::TraitSelectionError(e));\n         }\n@@ -421,17 +435,20 @@ fn project_type<'cx,'tcx>(\n /// there that can answer this question.\n fn assemble_candidates_from_param_env<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n     let env_predicates = selcx.param_env().caller_bounds.predicates.clone();\n     let env_predicates = env_predicates.iter().cloned().collect();\n-    assemble_candidates_from_predicates(selcx, obligation, candidate_set, env_predicates);\n+    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n+                                        candidate_set, env_predicates);\n }\n \n fn assemble_candidates_from_predicates<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     env_predicates: Vec<ty::Predicate<'tcx>>)\n {\n@@ -445,7 +462,7 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n                 let is_match = infcx.probe(|_| {\n                     let origin = infer::Misc(obligation.cause.span);\n                     let obligation_poly_trait_ref =\n-                        obligation.predicate.trait_ref.to_poly_trait_ref();\n+                        obligation_trait_ref.to_poly_trait_ref();\n                     let data_poly_trait_ref =\n                         data.to_poly_trait_ref();\n                     infcx.sub_poly_trait_refs(false,\n@@ -466,14 +483,14 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n \n fn assemble_candidates_from_object_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n-    obligation:  &ProjectionTyObligation<'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n     let infcx = selcx.infcx();\n-    let trait_ref = infcx.resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n     debug!(\"assemble_candidates_from_object_type(trait_ref={})\",\n-           trait_ref.repr(infcx.tcx));\n-    let self_ty = trait_ref.self_ty();\n+           obligation_trait_ref.repr(infcx.tcx));\n+    let self_ty = obligation_trait_ref.self_ty();\n     let data = match self_ty.sty {\n         ty::ty_trait(ref data) => data,\n         _ => { return; }\n@@ -482,21 +499,21 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n     let env_predicates = projection_bounds.iter()\n                                           .map(|p| p.as_predicate())\n                                           .collect();\n-    assemble_candidates_from_predicates(selcx, obligation, candidate_set, env_predicates)\n+    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n+                                        candidate_set, env_predicates)\n }\n \n fn assemble_candidates_from_impls<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n     -> Result<(), SelectionError<'tcx>>\n {\n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n-    let trait_ref =\n-        obligation.predicate.trait_ref.to_poly_trait_ref();\n-    let trait_obligation =\n-        obligation.with(trait_ref.to_poly_trait_predicate());\n+    let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+    let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n     let vtable = match selcx.select(&trait_obligation) {\n         Ok(Some(vtable)) => vtable,\n         Ok(None) => {"}, {"sha": "399d537088c7befb18f361db6057860ab5ce4c57", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cddb41dd1fd7ace99fbc653b8aca48a0feba9c48/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cddb41dd1fd7ace99fbc653b8aca48a0feba9c48/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cddb41dd1fd7ace99fbc653b8aca48a0feba9c48", "patch": "@@ -7269,7 +7269,7 @@ impl<T:ReferencesError> ReferencesError for Binder<T> {\n \n impl<T:ReferencesError> ReferencesError for Rc<T> {\n     fn references_error(&self) -> bool {\n-        (&*self).references_error()\n+        (&**self).references_error()\n     }\n }\n "}, {"sha": "5743216b6ca69e1ae98e757597f9dc3825a46b75", "filename": "src/test/compile-fail/associated-types-ICE-when-projecting-out-of-err.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cddb41dd1fd7ace99fbc653b8aca48a0feba9c48/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cddb41dd1fd7ace99fbc653b8aca48a0feba9c48/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs?ref=cddb41dd1fd7ace99fbc653b8aca48a0feba9c48", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do not ICE when the self type is `ty::err`, but rather\n+// just propagate the error.\n+\n+#![crate_type = \"lib\"]\n+#![feature(associated_types, default_type_params, lang_items)]\n+#![no_std]\n+\n+#[lang=\"sized\"]\n+pub trait Sized for Sized? {\n+    // Empty.\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS=Self> {\n+    type Output;\n+\n+    fn add(self, RHS) -> Self::Output;\n+}\n+\n+fn ice<A>(a: A) {\n+    let r = loop {};\n+    r = r + a; // here the type `r` is not yet inferred, hence `r+a` generates an error.\n+    //~^ ERROR type of this value must be known\n+}"}]}