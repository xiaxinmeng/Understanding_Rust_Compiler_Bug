{"sha": "2c19f51d52b596987d27f9c1b3fb8b79424296d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMTlmNTFkNTJiNTk2OTg3ZDI3ZjljMWIzZmI4Yjc5NDI0Mjk2ZDA=", "commit": {"author": {"name": "Adrien T\u00e9tar", "email": "adri-from-59@hotmail.fr", "date": "2014-01-17T18:55:08Z"}, "committer": {"name": "Adrien T\u00e9tar", "email": "adri-from-59@hotmail.fr", "date": "2014-01-17T18:59:37Z"}, "message": "doc: fix rust.md fallout", "tree": {"sha": "16ab90742bf7395ba34b91b7aed348a943d0ef10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16ab90742bf7395ba34b91b7aed348a943d0ef10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c19f51d52b596987d27f9c1b3fb8b79424296d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c19f51d52b596987d27f9c1b3fb8b79424296d0", "html_url": "https://github.com/rust-lang/rust/commit/2c19f51d52b596987d27f9c1b3fb8b79424296d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c19f51d52b596987d27f9c1b3fb8b79424296d0/comments", "author": {"login": "adrientetar", "id": 1250894, "node_id": "MDQ6VXNlcjEyNTA4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1250894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adrientetar", "html_url": "https://github.com/adrientetar", "followers_url": "https://api.github.com/users/adrientetar/followers", "following_url": "https://api.github.com/users/adrientetar/following{/other_user}", "gists_url": "https://api.github.com/users/adrientetar/gists{/gist_id}", "starred_url": "https://api.github.com/users/adrientetar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adrientetar/subscriptions", "organizations_url": "https://api.github.com/users/adrientetar/orgs", "repos_url": "https://api.github.com/users/adrientetar/repos", "events_url": "https://api.github.com/users/adrientetar/events{/privacy}", "received_events_url": "https://api.github.com/users/adrientetar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "adrientetar", "id": 1250894, "node_id": "MDQ6VXNlcjEyNTA4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1250894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adrientetar", "html_url": "https://github.com/adrientetar", "followers_url": "https://api.github.com/users/adrientetar/followers", "following_url": "https://api.github.com/users/adrientetar/following{/other_user}", "gists_url": "https://api.github.com/users/adrientetar/gists{/gist_id}", "starred_url": "https://api.github.com/users/adrientetar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adrientetar/subscriptions", "organizations_url": "https://api.github.com/users/adrientetar/orgs", "repos_url": "https://api.github.com/users/adrientetar/repos", "events_url": "https://api.github.com/users/adrientetar/events{/privacy}", "received_events_url": "https://api.github.com/users/adrientetar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e33b1dabd35685e586f85f3e53783e31871bc5b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e33b1dabd35685e586f85f3e53783e31871bc5b7", "html_url": "https://github.com/rust-lang/rust/commit/e33b1dabd35685e586f85f3e53783e31871bc5b7"}], "stats": {"total": 46, "additions": 25, "deletions": 21}, "files": [{"sha": "ad85275105e92cadae281a17dbf8a4829fa1b544", "filename": "doc/rust.md", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2c19f51d52b596987d27f9c1b3fb8b79424296d0/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/2c19f51d52b596987d27f9c1b3fb8b79424296d0/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=2c19f51d52b596987d27f9c1b3fb8b79424296d0", "patch": "@@ -2890,8 +2890,9 @@ match x {\n \n The first pattern matches lists constructed by applying `Cons` to any head value, and a\n tail value of `~Nil`. The second pattern matches _any_ list constructed with `Cons`,\n-ignoring the values of its arguments. The difference between `_` and `*` is that the pattern `C(_)` is only type-correct if\n-`C` has exactly one argument, while the pattern `C(..)` is type-correct for any enum variant `C`, regardless of how many arguments `C` has.\n+ignoring the values of its arguments. The difference between `_` and `*` is that the pattern\n+`C(_)` is only type-correct if `C` has exactly one argument, while the pattern `C(..)` is\n+type-correct for any enum variant `C`, regardless of how many arguments `C` has.\n \n A `match` behaves differently depending on whether or not the head expression\n is an [lvalue or an rvalue](#lvalues-rvalues-and-temporaries).\n@@ -2904,11 +2905,11 @@ variables in the arm's block, and control enters the block.\n \n When the head expression is an lvalue, the match does not allocate a\n temporary location (however, a by-value binding may copy or move from\n-the lvalue).  When possible, it is preferable to match on lvalues, as the\n+the lvalue). When possible, it is preferable to match on lvalues, as the\n lifetime of these matches inherits the lifetime of the lvalue, rather\n than being restricted to the inside of the match.\n \n-An example of an `match` expression:\n+An example of a `match` expression:\n \n ~~~~\n # fn process_pair(a: int, b: int) { }\n@@ -2938,28 +2939,31 @@ Patterns that bind variables\n default to binding to a copy or move of the matched value\n (depending on the matched value's type).\n This can be changed to bind to a reference by\n-using the ```ref``` keyword,\n-or to a mutable reference using ```ref mut```.\n+using the `ref` keyword,\n+or to a mutable reference using `ref mut`.\n \n-Patterns can also dereference pointers by using the ``&``,\n-``~`` or ``@`` symbols, as appropriate.  For example, these two matches\n-on ``x: &int`` are equivalent:\n+Patterns can also dereference pointers by using the `&`,\n+`~` or `@` symbols, as appropriate. For example, these two matches\n+on `x: &int` are equivalent:\n \n ~~~~\n-match *x { 0 => \"zero\", _ => \"some\" }\n-match x { &0 => \"zero\", _ => \"some\" }\n+# let x = &3;\n+let y = match *x { 0 => \"zero\", _ => \"some\" };\n+let z = match x { &0 => \"zero\", _ => \"some\" };\n+\n+assert_eq!(y, z);\n ~~~~\n \n-A pattern that's just an identifier,\n-like `Nil` in the previous answer,\n-could either refer to an enum variant that's in scope,\n-or bind a new variable.\n-The compiler resolves this ambiguity by forbidding variable bindings that occur in ```match``` patterns from shadowing names of variants that are in scope.\n-For example, wherever ```List``` is in scope,\n-a ```match``` pattern would not be able to bind ```Nil``` as a new name.\n-The compiler interprets a variable pattern `x` as a binding _only_ if there is no variant named `x` in scope.\n-A convention you can use to avoid conflicts is simply to name variants with upper-case letters,\n-and local variables with lower-case letters.\n+A pattern that's just an identifier, like `Nil` in the previous answer,\n+could either refer to an enum variant that's in scope, or bind a new variable.\n+The compiler resolves this ambiguity by forbidding variable bindings that occur\n+in `match` patterns from shadowing names of variants that are in scope.\n+For example, wherever `List` is in scope,\n+a `match` pattern would not be able to bind `Nil` as a new name.\n+The compiler interprets a variable pattern `x` as a binding _only_ if there is\n+no variant named `x` in scope.\n+A convention you can use to avoid conflicts is simply to name variants with\n+upper-case letters, and local variables with lower-case letters.\n \n Multiple match patterns may be joined with the `|` operator.\n A range of values may be specified with `..`."}]}