{"sha": "da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNDJhYTU0MDM2NTlhNmYxZjZmNGJjNGI2NWQxNzdmMTNmYjY1MzY=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-04-18T19:26:07Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-04-28T21:56:11Z"}, "message": "Begin reducing mask API", "tree": {"sha": "81a007da96625fcf5f06c3591d37740cd88493d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81a007da96625fcf5f06c3591d37740cd88493d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "html_url": "https://github.com/rust-lang/rust/commit/da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5751179dc636d53b0f2368e81f548c1c04a7b4f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5751179dc636d53b0f2368e81f548c1c04a7b4f2", "html_url": "https://github.com/rust-lang/rust/commit/5751179dc636d53b0f2368e81f548c1c04a7b4f2"}], "stats": {"total": 400, "additions": 59, "deletions": 341}, "files": [{"sha": "f3a1954fda2261bdc8adc7d038e55017b56fbf10", "filename": "crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "patch": "@@ -1,7 +1,7 @@\n use crate::LanesAtMost32;\n \n macro_rules! implement_mask_ops {\n-    { $($vector:ident => $mask:ident ($inner_mask_ty:ident, $inner_ty:ident),)* } => {\n+    { $($vector:ident => $mask:ident ($inner_ty:ident),)* } => {\n         $(\n             impl<const LANES: usize> crate::$vector<LANES>\n             where\n@@ -12,53 +12,47 @@ macro_rules! implement_mask_ops {\n                 #[inline]\n                 pub fn lanes_eq(self, other: Self) -> crate::$mask<LANES> {\n                     unsafe {\n-                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_eq(self, other))\n-                            .into()\n+                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_eq(self, other))\n                     }\n                 }\n \n                 /// Test if each lane is not equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_ne(self, other: Self) -> crate::$mask<LANES> {\n                     unsafe {\n-                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_ne(self, other))\n-                            .into()\n+                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_ne(self, other))\n                     }\n                 }\n \n                 /// Test if each lane is less than the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_lt(self, other: Self) -> crate::$mask<LANES> {\n                     unsafe {\n-                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_lt(self, other))\n-                            .into()\n+                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_lt(self, other))\n                     }\n                 }\n \n                 /// Test if each lane is greater than the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_gt(self, other: Self) -> crate::$mask<LANES> {\n                     unsafe {\n-                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_gt(self, other))\n-                            .into()\n+                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_gt(self, other))\n                     }\n                 }\n \n                 /// Test if each lane is less than or equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_le(self, other: Self) -> crate::$mask<LANES> {\n                     unsafe {\n-                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_le(self, other))\n-                            .into()\n+                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_le(self, other))\n                     }\n                 }\n \n                 /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_ge(self, other: Self) -> crate::$mask<LANES> {\n                     unsafe {\n-                        crate::$inner_mask_ty::from_int_unchecked(crate::intrinsics::simd_ge(self, other))\n-                            .into()\n+                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_ge(self, other))\n                     }\n                 }\n             }\n@@ -67,18 +61,18 @@ macro_rules! implement_mask_ops {\n }\n \n implement_mask_ops! {\n-    SimdI8 => Mask8 (SimdMask8, SimdI8),\n-    SimdI16 => Mask16 (SimdMask16, SimdI16),\n-    SimdI32 => Mask32 (SimdMask32, SimdI32),\n-    SimdI64 => Mask64 (SimdMask64, SimdI64),\n-    SimdIsize => MaskSize (SimdMaskSize, SimdIsize),\n+    SimdI8 => Mask8 (SimdI8),\n+    SimdI16 => Mask16 (SimdI16),\n+    SimdI32 => Mask32 (SimdI32),\n+    SimdI64 => Mask64 (SimdI64),\n+    SimdIsize => MaskSize (SimdIsize),\n \n-    SimdU8 => Mask8 (SimdMask8, SimdI8),\n-    SimdU16 => Mask16 (SimdMask16, SimdI16),\n-    SimdU32 => Mask32 (SimdMask32, SimdI32),\n-    SimdU64 => Mask64 (SimdMask64, SimdI64),\n-    SimdUsize => MaskSize (SimdMaskSize, SimdIsize),\n+    SimdU8 => Mask8 (SimdI8),\n+    SimdU16 => Mask16 (SimdI16),\n+    SimdU32 => Mask32 (SimdI32),\n+    SimdU64 => Mask64 (SimdI64),\n+    SimdUsize => MaskSize (SimdIsize),\n \n-    SimdF32 => Mask32 (SimdMask32, SimdI32),\n-    SimdF64 => Mask64 (SimdMask64, SimdI64),\n+    SimdF32 => Mask32 (SimdI32),\n+    SimdF64 => Mask64 (SimdI64),\n }"}, {"sha": "2fee9ca918910ebb92b35a1a16186e275e2da6b8", "filename": "crates/core_simd/src/lanes_at_most_32.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_32.rs?ref=da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "patch": "@@ -1,4 +1,4 @@\n-/// Implemented for bitmask sizes that are supported by the implementation.\n+/// Implemented for vectors that are supported by the implementation.\n pub trait LanesAtMost32 {}\n \n macro_rules! impl_for {\n@@ -28,5 +28,3 @@ impl_for! { SimdIsize }\n \n impl_for! { SimdF32 }\n impl_for! { SimdF64 }\n-\n-impl_for! { BitMask }"}, {"sha": "32e2ffb861536dc9bf31ac6335b8cc48d1f2d625", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "patch": "@@ -4,14 +4,12 @@ use crate::LanesAtMost32;\n #[derive(Copy, Clone, Debug, PartialOrd, PartialEq, Ord, Eq, Hash)]\n #[repr(transparent)]\n pub struct BitMask<const LANES: usize>(u64)\n-where\n-    BitMask<LANES>: LanesAtMost32;\n \n impl<const LANES: usize> BitMask<LANES>\n where\n     Self: LanesAtMost32,\n {\n-    /// Construct a mask by setting all lanes to the given value.\n+    #[inline]\n     pub fn splat(value: bool) -> Self {\n         if value {\n             Self(u64::MAX >> (64 - LANES))\n@@ -20,23 +18,13 @@ where\n         }\n     }\n \n-    /// Tests the value of the specified lane.\n-    ///\n-    /// # Panics\n-    /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n     #[inline]\n-    pub fn test(&self, lane: usize) -> bool {\n-        assert!(lane < LANES, \"lane index out of range\");\n+    pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n         (self.0 >> lane) & 0x1 > 0\n     }\n \n-    /// Sets the value of the specified lane.\n-    ///\n-    /// # Panics\n-    /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n     #[inline]\n-    pub fn set(&mut self, lane: usize, value: bool) {\n-        assert!(lane < LANES, \"lane index out of range\");\n+    pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n         self.0 ^= ((value ^ self.test(lane)) as u64) << lane\n     }\n }"}, {"sha": "6972a4216b683a2e2d93df4ed93c5123e90bff30", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 7, "deletions": 196, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "patch": "@@ -1,18 +1,5 @@\n //! Masks that take up full SIMD vector registers.\n \n-/// The error type returned when converting an integer to a mask fails.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub struct TryFromMaskError(());\n-\n-impl core::fmt::Display for TryFromMaskError {\n-    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        write!(\n-            f,\n-            \"mask vector must have all bits set or unset in each lane\"\n-        )\n-    }\n-}\n-\n macro_rules! define_mask {\n     {\n         $(#[$attr:meta])*\n@@ -27,6 +14,8 @@ macro_rules! define_mask {\n         where\n             crate::$type<LANES>: crate::LanesAtMost32;\n \n+        impl_full_mask_reductions! { $name, $type }\n+\n         impl<const LANES: usize> Copy for $name<LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n@@ -46,7 +35,6 @@ macro_rules! define_mask {\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n         {\n-            /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n                 Self(<crate::$type<LANES>>::splat(\n                     if value {\n@@ -57,20 +45,12 @@ macro_rules! define_mask {\n                 ))\n             }\n \n-            /// Tests the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n             #[inline]\n             pub fn test(&self, lane: usize) -> bool {\n                 assert!(lane < LANES, \"lane index out of range\");\n                 self.0[lane] == -1\n             }\n \n-            /// Sets the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n             #[inline]\n             pub fn set(&mut self, lane: usize, value: bool) {\n                 assert!(lane < LANES, \"lane index out of range\");\n@@ -81,56 +61,15 @@ macro_rules! define_mask {\n                 }\n             }\n \n-            /// Converts the mask to the equivalent integer representation, where -1 represents\n-            /// \"set\" and 0 represents \"unset\".\n             #[inline]\n             pub fn to_int(self) -> crate::$type<LANES> {\n                 self.0\n             }\n \n-            /// Creates a  mask from the equivalent integer representation, where -1 represents\n-            /// \"set\" and 0 represents \"unset\".\n-            ///\n-            /// Each provided lane must be either 0 or -1.\n             #[inline]\n             pub unsafe fn from_int_unchecked(value: crate::$type<LANES>) -> Self {\n                 Self(value)\n             }\n-\n-            /// Creates a mask from the equivalent integer representation, where -1 represents\n-            /// \"set\" and 0 represents \"unset\".\n-            ///\n-            /// # Panics\n-            /// Panics if any lane is not 0 or -1.\n-            #[inline]\n-            pub fn from_int(value: crate::$type<LANES>) -> Self {\n-                use core::convert::TryInto;\n-                value.try_into().unwrap()\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::convert::From<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            fn from(value: bool) -> Self {\n-                Self::splat(value)\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::convert::TryFrom<crate::$type<LANES>> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Error = TryFromMaskError;\n-            fn try_from(value: crate::$type<LANES>) -> Result<Self, Self::Error> {\n-                let valid = (value.lanes_eq(crate::$type::<LANES>::splat(0)) | value.lanes_eq(crate::$type::<LANES>::splat(-1))).all();\n-                if valid {\n-                    Ok(Self(value))\n-                } else {\n-                    Err(TryFromMaskError(()))\n-                }\n-            }\n         }\n \n         impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::$type<LANES>\n@@ -142,36 +81,6 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const LANES: usize> core::convert::From<crate::BitMask<LANES>> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-            crate::BitMask<LANES>: crate::LanesAtMost32,\n-        {\n-            fn from(value: crate::BitMask<LANES>) -> Self {\n-                // TODO use an intrinsic to do this efficiently (with LLVM's sext instruction)\n-                let mut mask = Self::splat(false);\n-                for lane in 0..LANES {\n-                    mask.set(lane, value.test(lane));\n-                }\n-                mask\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::BitMask<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-            crate::BitMask<LANES>: crate::LanesAtMost32,\n-        {\n-            fn from(value: $name<$lanes>) -> Self {\n-                // TODO use an intrinsic to do this efficiently (with LLVM's trunc instruction)\n-                let mut mask = Self::splat(false);\n-                for lane in 0..LANES {\n-                    mask.set(lane, value.test(lane));\n-                }\n-                mask\n-            }\n-        }\n-\n         impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n@@ -230,28 +139,6 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn bitand(self, rhs: bool) -> Self {\n-                self & Self::splat(rhs)\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Output = $name<LANES>;\n-            #[inline]\n-            fn bitand(self, rhs: $name<LANES>) -> $name<LANES> {\n-                $name::<LANES>::splat(self) & rhs\n-            }\n-        }\n-\n         impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n@@ -263,28 +150,6 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn bitor(self, rhs: bool) -> Self {\n-                self | Self::splat(rhs)\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Output = $name<LANES>;\n-            #[inline]\n-            fn bitor(self, rhs: $name<LANES>) -> $name<LANES> {\n-                $name::<LANES>::splat(self) | rhs\n-            }\n-        }\n-\n         impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n@@ -296,28 +161,6 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn bitxor(self, rhs: bool) -> Self::Output {\n-                self ^ Self::splat(rhs)\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            type Output = $name<LANES>;\n-            #[inline]\n-            fn bitxor(self, rhs: $name<LANES>) -> Self::Output {\n-                $name::<LANES>::splat(self) ^ rhs\n-            }\n-        }\n-\n         impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n@@ -339,16 +182,6 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            #[inline]\n-            fn bitand_assign(&mut self, rhs: bool) {\n-                *self &= Self::splat(rhs);\n-            }\n-        }\n-\n         impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n@@ -359,16 +192,6 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            #[inline]\n-            fn bitor_assign(&mut self, rhs: bool) {\n-                *self |= Self::splat(rhs);\n-            }\n-        }\n-\n         impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,\n@@ -378,47 +201,35 @@ macro_rules! define_mask {\n                 self.0 ^= rhs.0;\n             }\n         }\n-\n-        impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            #[inline]\n-            fn bitxor_assign(&mut self, rhs: bool) {\n-                *self ^= Self::splat(rhs);\n-            }\n-        }\n-\n-        impl_full_mask_reductions! { $name, $type }\n     }\n }\n \n define_mask! {\n     /// A mask equivalent to [SimdI8](crate::SimdI8), where all bits in the lane must be either set\n     /// or unset.\n-    struct SimdMask8<const LANES: usize>(crate::SimdI8<LANES>);\n+    struct Mask8<const LANES: usize>(crate::SimdI8<LANES>);\n }\n \n define_mask! {\n     /// A mask equivalent to [SimdI16](crate::SimdI16), where all bits in the lane must be either set\n     /// or unset.\n-    struct SimdMask16<const LANES: usize>(crate::SimdI16<LANES>);\n+    struct Mask16<const LANES: usize>(crate::SimdI16<LANES>);\n }\n \n define_mask! {\n     /// A mask equivalent to [SimdI32](crate::SimdI32), where all bits in the lane must be either set\n     /// or unset.\n-    struct SimdMask32<const LANES: usize>(crate::SimdI32<LANES>);\n+    struct Mask32<const LANES: usize>(crate::SimdI32<LANES>);\n }\n \n define_mask! {\n     /// A mask equivalent to [SimdI64](crate::SimdI64), where all bits in the lane must be either set\n     /// or unset.\n-    struct SimdMask64<const LANES: usize>(crate::SimdI64<LANES>);\n+    struct Mask64<const LANES: usize>(crate::SimdI64<LANES>);\n }\n \n define_mask! {\n     /// A mask equivalent to [SimdIsize](crate::SimdIsize), where all bits in the lane must be either set\n     /// or unset.\n-    struct SimdMaskSize<const LANES: usize>(crate::SimdIsize<LANES>);\n+    struct MaskSize<const LANES: usize>(crate::SimdIsize<LANES>);\n }"}, {"sha": "fbb934b96424624a9e0efa00caca9f7fe45dbd17", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 24, "deletions": 53, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "patch": "@@ -1,33 +1,32 @@\n //! Types and traits associated with masking lanes of vectors.\n+//! Types representing\n #![allow(non_camel_case_types)]\n \n-mod full_masks;\n-pub use full_masks::*;\n-\n-mod bitmask;\n-pub use bitmask::*;\n+#[cfg_attr(not(all(target_arch = \"x86_64\", target_feature = \"avx512f\")), path = \"full_masks.rs\")]\n+#[cfg_attr(all(target_arch = \"x86_64\", target_feature = \"avx512f\"), path = \"bitmask.rs\")]\n+mod mask_impl;\n \n use crate::{LanesAtMost32, SimdI16, SimdI32, SimdI64, SimdI8, SimdIsize};\n \n macro_rules! define_opaque_mask {\n     {\n         $(#[$attr:meta])*\n-        struct $name:ident<const $lanes:ident: usize>($inner_ty:ident<$lanes2:ident>);\n+        struct $name:ident<const $lanes:ident: usize>($inner_ty:ty);\n         @bits $bits_ty:ident\n     } => {\n         $(#[$attr])*\n         #[allow(non_camel_case_types)]\n-        pub struct $name<const LANES: usize>($inner_ty<LANES>) where $bits_ty<LANES>: LanesAtMost32;\n+        pub struct $name<const LANES: usize>($inner_ty) where $bits_ty<LANES>: LanesAtMost32;\n \n-        impl_opaque_mask_reductions! { $name, $inner_ty, $bits_ty }\n+        impl_opaque_mask_reductions! { $name, $bits_ty }\n \n         impl<const LANES: usize> $name<LANES>\n         where\n             $bits_ty<LANES>: LanesAtMost32\n         {\n             /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n-                Self(<$inner_ty<LANES>>::splat(value))\n+                Self(<$inner_ty>::splat(value))\n             }\n \n             /// Converts an array to a SIMD vector.\n@@ -52,6 +51,16 @@ macro_rules! define_opaque_mask {\n                 array\n             }\n \n+            /// Converts a vector of integers to a mask, where 0 represents `false` and -1\n+            /// represents `true`.\n+            ///\n+            /// # Safety\n+            /// All lanes must be either 0 or -1.\n+            #[inline]\n+            pub unsafe fn from_int_unchecked(value: $bits_ty<LANES>) -> Self {\n+                Self(<$inner_ty>::from_int_unchecked(value))\n+            }\n+\n             /// Tests the value of the specified lane.\n             ///\n             /// # Panics\n@@ -71,44 +80,6 @@ macro_rules! define_opaque_mask {\n             }\n         }\n \n-        impl<const LANES: usize> From<BitMask<LANES>> for $name<LANES>\n-        where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            BitMask<LANES>: LanesAtMost32,\n-        {\n-            fn from(value: BitMask<LANES>) -> Self {\n-                Self(value.into())\n-            }\n-        }\n-\n-        impl<const LANES: usize> From<$name<LANES>> for crate::BitMask<LANES>\n-        where\n-            $bits_ty<LANES>: LanesAtMost32,\n-            BitMask<LANES>: LanesAtMost32,\n-        {\n-            fn from(value: $name<LANES>) -> Self {\n-                value.0.into()\n-            }\n-        }\n-\n-        impl<const LANES: usize> From<$inner_ty<LANES>> for $name<LANES>\n-        where\n-            $bits_ty<LANES>: LanesAtMost32,\n-        {\n-            fn from(value: $inner_ty<LANES>) -> Self {\n-                Self(value)\n-            }\n-        }\n-\n-        impl<const LANES: usize> From<$name<LANES>> for $inner_ty<LANES>\n-        where\n-            $bits_ty<LANES>: LanesAtMost32,\n-        {\n-            fn from(value: $name<LANES>) -> Self {\n-                value.0\n-            }\n-        }\n-\n         // vector/array conversion\n         impl<const LANES: usize> From<[bool; LANES]> for $name<LANES>\n         where\n@@ -130,7 +101,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> Copy for $name<LANES>\n         where\n-            $inner_ty<LANES>: Copy,\n+            $inner_ty: Copy,\n             $bits_ty<LANES>: LanesAtMost32,\n         {}\n \n@@ -359,39 +330,39 @@ define_opaque_mask! {\n     /// Mask for vectors with `LANES` 8-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask8<const LANES: usize>(SimdMask8<LANES>);\n+    struct Mask8<const LANES: usize>(mask_impl::Mask8<LANES>);\n     @bits SimdI8\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 16-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask16<const LANES: usize>(SimdMask16<LANES>);\n+    struct Mask16<const LANES: usize>(mask_impl::Mask16<LANES>);\n     @bits SimdI16\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 32-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask32<const LANES: usize>(SimdMask32<LANES>);\n+    struct Mask32<const LANES: usize>(mask_impl::Mask32<LANES>);\n     @bits SimdI32\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 64-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask64<const LANES: usize>(SimdMask64<LANES>);\n+    struct Mask64<const LANES: usize>(mask_impl::Mask64<LANES>);\n     @bits SimdI64\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` pointer-width elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct MaskSize<const LANES: usize>(SimdMaskSize<LANES>);\n+    struct MaskSize<const LANES: usize>(mask_impl::MaskSize<LANES>);\n     @bits SimdIsize\n }\n "}, {"sha": "2d4f1bca2647009f8dde8eab750bd52f4ec13bbe", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "patch": "@@ -103,18 +103,16 @@ macro_rules! impl_float_reductions {\n }\n \n macro_rules! impl_full_mask_reductions {\n-    { $name:ident, $inner:ident } => {\n-        impl<const LANES: usize> crate::$name<LANES>\n+    { $name:ident, $bits_ty:ident } => {\n+        impl<const LANES: usize> $name<LANES>\n         where\n-            crate::$inner<LANES>: crate::LanesAtMost32\n+            crate::$bits_ty<LANES>: crate::LanesAtMost32\n         {\n-            /// Returns true if any lane is set, or false otherwise.\n             #[inline]\n             pub fn any(self) -> bool {\n                 unsafe { crate::intrinsics::simd_reduce_any(self.to_int()) }\n             }\n \n-            /// Returns true if all lanes are set, or false otherwise.\n             #[inline]\n             pub fn all(self) -> bool {\n                 unsafe { crate::intrinsics::simd_reduce_all(self.to_int()) }\n@@ -124,10 +122,10 @@ macro_rules! impl_full_mask_reductions {\n }\n \n macro_rules! impl_opaque_mask_reductions {\n-    { $name:ident, $inner:ident, $bits_ty:ident } => {\n+    { $name:ident, $bits_ty:ident } => {\n         impl<const LANES: usize> $name<LANES>\n         where\n-            $bits_ty<LANES>: crate::LanesAtMost32\n+            crate::$bits_ty<LANES>: crate::LanesAtMost32\n         {\n             /// Returns true if any lane is set, or false otherwise.\n             #[inline]\n@@ -143,20 +141,3 @@ macro_rules! impl_opaque_mask_reductions {\n         }\n     }\n }\n-\n-impl<const LANES: usize> crate::BitMask<LANES>\n-where\n-    crate::BitMask<LANES>: crate::LanesAtMost32,\n-{\n-    /// Returns true if any lane is set, or false otherwise.\n-    #[inline]\n-    pub fn any(self) -> bool {\n-        self != Self::splat(false)\n-    }\n-\n-    /// Returns true if all lanes are set, or false otherwise.\n-    #[inline]\n-    pub fn all(self) -> bool {\n-        self == Self::splat(true)\n-    }\n-}"}, {"sha": "6c3993e39a934ec3d8932febcafa2ea65d9ca841", "filename": "crates/core_simd/tests/masks.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "patch": "@@ -1,30 +1,9 @@\n-use core::convert::TryFrom;\n-use core_simd::{BitMask, Mask8, SimdI8, SimdMask8};\n-\n #[cfg(target_arch = \"wasm32\")]\n use wasm_bindgen_test::*;\n \n #[cfg(target_arch = \"wasm32\")]\n wasm_bindgen_test_configure!(run_in_browser);\n \n-#[test]\n-#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-fn mask_format_round_trip() {\n-    let ints = SimdI8::from_array([-1, 0, 0, -1]);\n-\n-    let simd_mask = SimdMask8::try_from(ints).unwrap();\n-\n-    let bitmask = BitMask::from(simd_mask);\n-\n-    let opaque_mask = Mask8::from(bitmask);\n-\n-    let simd_mask_returned = SimdMask8::from(opaque_mask);\n-\n-    let ints_returned = SimdI8::from(simd_mask_returned);\n-\n-    assert_eq!(ints_returned, ints);\n-}\n-\n macro_rules! test_mask_api {\n     { $name:ident } => {\n         #[allow(non_snake_case)]\n@@ -83,6 +62,4 @@ macro_rules! test_mask_api {\n \n mod mask_api {\n     test_mask_api! { Mask8 }\n-    test_mask_api! { SimdMask8 }\n-    test_mask_api! { BitMask }\n }"}, {"sha": "8b56877967cb59d88dfff40e52fda547ffa5b616", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da42aa5403659a6f1f6f4bc4b65d177f13fb6536/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "patch": "@@ -281,7 +281,6 @@ macro_rules! test_lanes {\n                     core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost32,\n                     core_simd::SimdF32<$lanes>: core_simd::LanesAtMost32,\n                     core_simd::SimdF64<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::BitMask<$lanes>: core_simd::LanesAtMost32,\n                 $body\n \n                 #[cfg(target_arch = \"wasm32\")]\n@@ -351,7 +350,6 @@ macro_rules! test_lanes_panic {\n                     core_simd::SimdIsize<$lanes>: core_simd::LanesAtMost32,\n                     core_simd::SimdF32<$lanes>: core_simd::LanesAtMost32,\n                     core_simd::SimdF64<$lanes>: core_simd::LanesAtMost32,\n-                    core_simd::BitMask<$lanes>: core_simd::LanesAtMost32,\n                 $body\n \n                 #[test]"}]}