{"sha": "58002b0e3725f81842b0ecb9651c8f1328d7f8af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MDAyYjBlMzcyNWY4MTg0MmIwZWNiOTY1MWM4ZjEzMjhkN2Y4YWY=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-10-11T06:21:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-10-11T06:21:28Z"}, "message": "Merge pull request #2119 from camsteffen/never_loop\n\nAnother never_loop fix", "tree": {"sha": "1cbb3dd026f9562c0f434844d2a80c967e4c1b2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cbb3dd026f9562c0f434844d2a80c967e4c1b2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58002b0e3725f81842b0ecb9651c8f1328d7f8af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58002b0e3725f81842b0ecb9651c8f1328d7f8af", "html_url": "https://github.com/rust-lang/rust/commit/58002b0e3725f81842b0ecb9651c8f1328d7f8af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58002b0e3725f81842b0ecb9651c8f1328d7f8af/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b491d5bb3f3e0a95720504daac141a979cf2512", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b491d5bb3f3e0a95720504daac141a979cf2512", "html_url": "https://github.com/rust-lang/rust/commit/2b491d5bb3f3e0a95720504daac141a979cf2512"}, {"sha": "752900ca3b4224437995e49b5b8481bddf4e190f", "url": "https://api.github.com/repos/rust-lang/rust/commits/752900ca3b4224437995e49b5b8481bddf4e190f", "html_url": "https://github.com/rust-lang/rust/commit/752900ca3b4224437995e49b5b8481bddf4e190f"}], "stats": {"total": 199, "additions": 99, "deletions": 100}, "files": [{"sha": "97925b0bd0c82578af633a83d493caf2653da176", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 73, "deletions": 100, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/58002b0e3725f81842b0ecb9651c8f1328d7f8af/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58002b0e3725f81842b0ecb9651c8f1328d7f8af/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=58002b0e3725f81842b0ecb9651c8f1328d7f8af", "patch": "@@ -16,6 +16,7 @@ use rustc::ty::{self, Ty};\n use rustc::ty::subst::{Subst, Substs};\n use rustc_const_eval::ConstContext;\n use std::collections::{HashMap, HashSet};\n+use std::iter::{Iterator, once};\n use syntax::ast;\n use syntax::codemap::Span;\n use utils::sugg;\n@@ -378,7 +379,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         match expr.node {\n             ExprWhile(_, ref block, _) |\n             ExprLoop(ref block, _, _) => {\n-                if never_loop(block, expr.id) {\n+                let mut state = NeverLoopState {\n+                    breaks: HashSet::new(),\n+                    continues: HashSet::new(),\n+                };\n+                let may_complete = never_loop_block(block, &mut state);\n+                if !may_complete && !state.continues.contains(&expr.id) {\n                     span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\");\n                 }\n             },\n@@ -485,140 +491,107 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn never_loop(block: &Block, id: NodeId) -> bool {\n-    !contains_continue_block(block, Some(id)) && loop_exit_block(block, &mut vec![id])\n+struct NeverLoopState {\n+    breaks: HashSet<NodeId>,\n+    continues: HashSet<NodeId>,\n }\n \n-fn contains_continue_block(block: &Block, dest: Option<NodeId>) -> bool {\n-    block.stmts.iter().any(|e| contains_continue_stmt(e, dest)) ||\n-        block.expr.as_ref().map_or(\n-            false,\n-            |e| contains_continue_expr(e, dest),\n-        )\n+fn never_loop_block(block: &Block, state: &mut NeverLoopState) -> bool {\n+    let stmts = block.stmts.iter().map(stmt_to_expr);\n+    let expr = once(block.expr.as_ref().map(|p| &**p));\n+    let mut iter = stmts.chain(expr).filter_map(|e| e);\n+    never_loop_expr_seq(&mut iter, state)\n }\n \n-fn contains_continue_stmt(stmt: &Stmt, dest: Option<NodeId>) -> bool {\n+fn stmt_to_expr(stmt: &Stmt) -> Option<&Expr> {\n     match stmt.node {\n-        StmtSemi(ref e, _) |\n-        StmtExpr(ref e, _) => contains_continue_expr(e, dest),\n-        StmtDecl(ref d, _) => contains_continue_decl(d, dest),\n+        StmtSemi(ref e, ..) |\n+        StmtExpr(ref e, ..) => Some(e),\n+        StmtDecl(ref d, ..) => decl_to_expr(d),\n     }\n }\n \n-fn contains_continue_decl(decl: &Decl, dest: Option<NodeId>) -> bool {\n+fn decl_to_expr(decl: &Decl) -> Option<&Expr> {\n     match decl.node {\n-        DeclLocal(ref local) => {\n-            local.init.as_ref().map_or(\n-                false,\n-                |e| contains_continue_expr(e, dest),\n-            )\n-        },\n-        _ => false,\n+        DeclLocal(ref local) => local.init.as_ref().map(|p| &**p),\n+        _ => None,\n     }\n }\n \n-fn contains_continue_expr(expr: &Expr, dest: Option<NodeId>) -> bool {\n+fn never_loop_expr(expr: &Expr, state: &mut NeverLoopState) -> bool {\n     match expr.node {\n-        ExprRet(Some(ref e)) |\n         ExprBox(ref e) |\n         ExprUnary(_, ref e) |\n         ExprCast(ref e, _) |\n         ExprType(ref e, _) |\n         ExprField(ref e, _) |\n         ExprTupField(ref e, _) |\n         ExprAddrOf(_, ref e) |\n-        ExprRepeat(ref e, _) => contains_continue_expr(e, dest),\n+        ExprRepeat(ref e, _) => never_loop_expr(e, state),\n         ExprArray(ref es) |\n         ExprMethodCall(_, _, ref es) |\n-        ExprTup(ref es) => es.iter().any(|e| contains_continue_expr(e, dest)),\n-        ExprCall(ref e, ref es) => {\n-            contains_continue_expr(e, dest) || es.iter().any(|e| contains_continue_expr(e, dest))\n-        },\n+        ExprTup(ref es) => never_loop_expr_seq(&mut es.iter(), state),\n+        ExprCall(ref e, ref es) => never_loop_expr_seq(&mut once(&**e).chain(es.iter()), state),\n         ExprBinary(_, ref e1, ref e2) |\n         ExprAssign(ref e1, ref e2) |\n         ExprAssignOp(_, ref e1, ref e2) |\n-        ExprIndex(ref e1, ref e2) => [e1, e2].iter().any(|e| contains_continue_expr(e, dest)),\n+        ExprIndex(ref e1, ref e2) => never_loop_expr_seq(&mut [&**e1, &**e2].iter().cloned(), state),\n         ExprIf(ref e, ref e2, ref e3) => {\n-            [e, e2].iter().chain(e3.as_ref().iter()).any(|e| {\n-                contains_continue_expr(e, dest)\n-            })\n+            let e1 = never_loop_expr(e, state);\n+            let e2 = never_loop_expr(e2, state);\n+            match *e3 {\n+                Some(ref e3) => {\n+                    let e3 = never_loop_expr(e3, state);\n+                    e1 && (e2 || e3)\n+                },\n+                None => e1,\n+            }\n+        },\n+        ExprLoop(ref b, _, _) => {\n+            let block_may_complete = never_loop_block(b, state);\n+            let has_break = state.breaks.remove(&expr.id);\n+            state.continues.remove(&expr.id);\n+            block_may_complete || has_break\n+        },\n+        ExprWhile(ref e, ref b, _) => {\n+            let e = never_loop_expr(e, state);\n+            let block_may_complete = never_loop_block(b, state);\n+            let has_break = state.breaks.remove(&expr.id);\n+            let has_continue = state.continues.remove(&expr.id);\n+            e && (block_may_complete || has_break || has_continue)\n         },\n-        ExprWhile(ref e, ref b, _) => contains_continue_expr(e, dest) || contains_continue_block(b, dest),\n         ExprMatch(ref e, ref arms, _) => {\n-            contains_continue_expr(e, dest) || arms.iter().any(|a| contains_continue_expr(&a.body, dest))\n+            let e = never_loop_expr(e, state);\n+            let arms = never_loop_expr_branch(&mut arms.iter().map(|a| &*a.body), state);\n+            e && arms\n         },\n-        ExprBlock(ref block) |\n-        ExprLoop(ref block, ..) => contains_continue_block(block, dest),\n-        ExprStruct(_, _, ref base) => {\n-            base.as_ref().map_or(\n-                false,\n-                |e| contains_continue_expr(e, dest),\n-            )\n+        ExprBlock(ref b) => never_loop_block(b, state),\n+        ExprAgain(d) => {\n+            let id = d.target_id.opt_id().expect(\"target id can only be missing in the presence of compilation errors\");\n+            state.continues.insert(id);\n+            false\n         },\n-        ExprAgain(d) => dest.map_or(true, |dest| d.target_id.opt_id().map_or(false, |id| id == dest)),\n-        _ => false,\n-    }\n-}\n-\n-fn loop_exit_block(block: &Block, loops: &mut Vec<NodeId>) -> bool {\n-    block.stmts.iter().take_while(|s| !contains_continue_stmt(s, None)).any(|s| loop_exit_stmt(s, loops))\n-        || block.expr.as_ref().map_or(false, |e| loop_exit_expr(e, loops))\n-}\n-\n-fn loop_exit_stmt(stmt: &Stmt, loops: &mut Vec<NodeId>) -> bool {\n-    match stmt.node {\n-        StmtSemi(ref e, _) |\n-        StmtExpr(ref e, _) => loop_exit_expr(e, loops),\n-        StmtDecl(ref d, _) => loop_exit_decl(d, loops),\n+        ExprBreak(d, _) => {\n+            let id = d.target_id.opt_id().expect(\"target id can only be missing in the presence of compilation errors\");\n+            state.breaks.insert(id);\n+            false\n+        },\n+        ExprRet(ref e) => {\n+            if let Some(ref e) = *e {\n+                never_loop_expr(e, state);\n+            }\n+            false\n+        },\n+        _ => true,\n     }\n }\n \n-fn loop_exit_decl(decl: &Decl, loops: &mut Vec<NodeId>) -> bool {\n-    match decl.node {\n-        DeclLocal(ref local) => local.init.as_ref().map_or(false, |e| loop_exit_expr(e, loops)),\n-        _ => false,\n-    }\n+fn never_loop_expr_seq<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, state: &mut NeverLoopState) -> bool {\n+    es.map(|e| never_loop_expr(e, state)).fold(true, |a, b| a && b)\n }\n \n-fn loop_exit_expr(expr: &Expr, loops: &mut Vec<NodeId>) -> bool {\n-    match expr.node {\n-        ExprBox(ref e) |\n-        ExprUnary(_, ref e) |\n-        ExprCast(ref e, _) |\n-        ExprType(ref e, _) |\n-        ExprField(ref e, _) |\n-        ExprTupField(ref e, _) |\n-        ExprAddrOf(_, ref e) |\n-        ExprRepeat(ref e, _) => loop_exit_expr(e, loops),\n-        ExprArray(ref es) |\n-        ExprMethodCall(_, _, ref es) |\n-        ExprTup(ref es) => es.iter().any(|e| loop_exit_expr(e, loops)),\n-        ExprCall(ref e, ref es) => loop_exit_expr(e, loops) || es.iter().any(|e| loop_exit_expr(e, loops)),\n-        ExprBinary(_, ref e1, ref e2) |\n-        ExprAssign(ref e1, ref e2) |\n-        ExprAssignOp(_, ref e1, ref e2) |\n-        ExprIndex(ref e1, ref e2) => [e1, e2].iter().any(|e| loop_exit_expr(e, loops)),\n-        ExprIf(ref e, ref e2, ref e3) => loop_exit_expr(e, loops)\n-            || e3.as_ref().map_or(false, |e3| loop_exit_expr(e3, loops)) && loop_exit_expr(e2, loops),\n-        ExprLoop(ref b, _, _) => {\n-            loops.push(expr.id);\n-            let val = loop_exit_block(b, loops);\n-            loops.pop();\n-            val\n-        },\n-        ExprWhile(ref e, ref b, _) => {\n-            loops.push(expr.id);\n-            let val = loop_exit_expr(e, loops) || loop_exit_block(b, loops);\n-            loops.pop();\n-            val\n-        },\n-        ExprMatch(ref e, ref arms, _) => loop_exit_expr(e, loops) || arms.iter().all(|a| loop_exit_expr(&a.body, loops)),\n-        ExprBlock(ref b) => loop_exit_block(b, loops),\n-        ExprAgain(d) => d.target_id.opt_id().map_or(false, |id| loops.iter().skip(1).all(|&id2| id != id2)),\n-        ExprBreak(d, _) => d.target_id.opt_id().map_or(false, |id| loops[0] == id),\n-        ExprRet(_) => true,\n-        _ => false,\n-    }\n+fn never_loop_expr_branch<'a, T: Iterator<Item=&'a Expr>>(e: &mut T, state: &mut NeverLoopState) -> bool {\n+    e.map(|e| never_loop_expr(e, state)).fold(false, |a, b| a || b)\n }\n \n fn check_for_loop<'a, 'tcx>("}, {"sha": "3bb25f688407b22e07aa883b4173188cafe21d44", "filename": "tests/ui/never_loop.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58002b0e3725f81842b0ecb9651c8f1328d7f8af/tests%2Fui%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58002b0e3725f81842b0ecb9651c8f1328d7f8af/tests%2Fui%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_loop.rs?ref=58002b0e3725f81842b0ecb9651c8f1328d7f8af", "patch": "@@ -139,6 +139,19 @@ pub fn test13() {\n     }\n }\n \n+pub fn test14() {\n+    let mut a = true;\n+    'outer: while a { // never loops\n+        while a {\n+            if a {\n+                a = false;\n+                continue\n+            }\n+        }\n+        break 'outer;\n+    }\n+}\n+\n fn main() {\n     test1();\n     test2();\n@@ -153,5 +166,6 @@ fn main() {\n     test11(|| 0);\n     test12(true, false);\n     test13();\n+    test14();\n }\n "}, {"sha": "80eeb6c28882d2b2c99e567d5da2ef3b43b07a8b", "filename": "tests/ui/never_loop.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58002b0e3725f81842b0ecb9651c8f1328d7f8af/tests%2Fui%2Fnever_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58002b0e3725f81842b0ecb9651c8f1328d7f8af/tests%2Fui%2Fnever_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_loop.stderr?ref=58002b0e3725f81842b0ecb9651c8f1328d7f8af", "patch": "@@ -68,3 +68,15 @@ error: this loop never actually loops\n 103 | |     }\n     | |_____^\n \n+error: this loop never actually loops\n+   --> $DIR/never_loop.rs:144:5\n+    |\n+144 | /     'outer: while a { // never loops\n+145 | |         while a {\n+146 | |             if a {\n+147 | |                 a = false;\n+...   |\n+151 | |         break 'outer;\n+152 | |     }\n+    | |_____^\n+"}]}