{"sha": "a216e847272ddbd3033037b606eaf2d801c250b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMTZlODQ3MjcyZGRiZDMwMzMwMzdiNjA2ZWFmMmQ4MDFjMjUwYjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-04T02:13:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-04T02:13:05Z"}, "message": "Auto merge of #29217 - nikomatsakis:mir-trans, r=dotdash\n\nThis branch implements a variant of trans that is based on MIR. It is very incomplete (intentionally), and had only the goal of laying out enough work to enable more incremental follow-on patches. Currently, only fns tagged with `#[rustc_mir]` use the new trans code. I plan to build up a meta-issue as well that tracks the various \"not-yet-implemented\" points. The only fn that has been tested so far is this amazingly complex \"spike\" fn:\r\n\r\n```rust\r\n#[rustc_mir]\r\nfn sum(x: i32, y: i32) -> i32 {\r\n    x + y\r\n}\r\n```\r\n\r\nIn general, the most interesting commit is the last one. There are some points on which I would like feedback from @rust-lang/compiler:\r\n\r\n- I did not use `Datum`. Originally, I thought that maybe just a `ValueRef` would be enough but I wound up with two very simple structures, `LvalueRef` and `OperandRef`, that just package up a `ValueRef` and a type. Because of MIR's structure, you don't wind up mixing by-ref and by-value so much, and I tend to think that a thinner abstraction layer is better here, but I'm not sure.\r\n- Related to the above, I expect that sooner or later we will analyze temps (and maybe variables too) to find those whose address is never taken and which are word-sized and which perhaps meet a few other criteria. For those, we'll probably want to avoid the alloca, just because it means prettier code.\r\n- I generally tried to re-use data structures from elsewhere in trans, though I'm sure we can trim these down.\r\n- I didn't do any debuginfo primarily because it seems to want node-ids and we have only spans. I haven't really read into that code so I don't know what's going on there.\r\n\r\nr? @nrc", "tree": {"sha": "d76ae5cc3c8c4c3f20746ae4d09c1eb67f694a39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d76ae5cc3c8c4c3f20746ae4d09c1eb67f694a39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a216e847272ddbd3033037b606eaf2d801c250b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a216e847272ddbd3033037b606eaf2d801c250b9", "html_url": "https://github.com/rust-lang/rust/commit/a216e847272ddbd3033037b606eaf2d801c250b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a216e847272ddbd3033037b606eaf2d801c250b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c340ea1de5dba6d0184103b9d67e290e3ea02981", "url": "https://api.github.com/repos/rust-lang/rust/commits/c340ea1de5dba6d0184103b9d67e290e3ea02981", "html_url": "https://github.com/rust-lang/rust/commit/c340ea1de5dba6d0184103b9d67e290e3ea02981"}, {"sha": "e78786315b44037258970ee9187f3fd6f89fc61b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e78786315b44037258970ee9187f3fd6f89fc61b", "html_url": "https://github.com/rust-lang/rust/commit/e78786315b44037258970ee9187f3fd6f89fc61b"}], "stats": {"total": 2411, "additions": 2023, "deletions": 388}, "files": [{"sha": "2a627a6da2bd6257321214573b36bde19927cc4e", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -103,7 +103,7 @@ DEPS_rustc_mir := rustc rustc_front syntax\n DEPS_rustc_resolve := rustc rustc_front log syntax\n DEPS_rustc_platform_intrinsics := rustc rustc_llvm\n DEPS_rustc_privacy := rustc rustc_front log syntax\n-DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n+DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back rustc_mir \\\n                     log syntax serialize rustc_llvm rustc_front rustc_platform_intrinsics\n DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics\n "}, {"sha": "a8f045074bd72df54be8268e51073161ca0cc27e", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -121,6 +121,13 @@ pub struct Tables<'tcx> {\n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n     pub closure_kinds: DefIdMap<ty::ClosureKind>,\n+\n+    /// For each fn, records the \"liberated\" types of its arguments\n+    /// and return type. Liberated means that all bound regions\n+    /// (including late-bound regions) are replaced with free\n+    /// equivalents. This table is not used in trans (since regions\n+    /// are erased there) and hence is not serialized to metadata.\n+    pub liberated_fn_sigs: NodeMap<ty::FnSig<'tcx>>,\n }\n \n impl<'tcx> Tables<'tcx> {\n@@ -133,6 +140,7 @@ impl<'tcx> Tables<'tcx> {\n             upvar_capture_map: FnvHashMap(),\n             closure_tys: DefIdMap(),\n             closure_kinds: DefIdMap(),\n+            liberated_fn_sigs: NodeMap(),\n         }\n     }\n "}, {"sha": "aa189744701784d53abbcff6633d00869079c901", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -1731,6 +1731,13 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n         self.fields.iter().find(|f| f.name == name)\n     }\n \n+    #[inline]\n+    pub fn index_of_field_named(&self,\n+                                name: ast::Name)\n+                                -> Option<usize> {\n+        self.fields.iter().position(|f| f.name == name)\n+    }\n+\n     #[inline]\n     pub fn field_named(&self, name: ast::Name) -> &FieldDefData<'tcx, 'container> {\n         self.find_field_named(name).unwrap()"}, {"sha": "06708a5127f342ee642e9cbb660a3162b6c09c11", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -11,6 +11,7 @@\n use rustc::front;\n use rustc::front::map as hir_map;\n use rustc_mir as mir;\n+use rustc_mir::mir_map::MirMap;\n use rustc::session::Session;\n use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n@@ -22,6 +23,7 @@ use rustc::middle::dependency_format;\n use rustc::middle;\n use rustc::plugin::registry::Registry;\n use rustc::plugin;\n+use rustc::util::nodemap::NodeMap;\n use rustc::util::common::time;\n use rustc_borrowck as borrowck;\n use rustc_resolve as resolve;\n@@ -146,7 +148,7 @@ pub fn compile_input(sess: Session,\n                                     &arenas,\n                                     &id,\n                                     control.make_glob_map,\n-                                    |tcx, analysis| {\n+                                    |tcx, mir_map, analysis| {\n \n             {\n                 let state = CompileState::state_after_analysis(input,\n@@ -170,7 +172,7 @@ pub fn compile_input(sess: Session,\n                 println!(\"Pre-trans\");\n                 tcx.print_debug_stats();\n             }\n-            let trans = phase_4_translate_to_llvm(tcx, analysis);\n+            let trans = phase_4_translate_to_llvm(tcx, &mir_map, analysis);\n \n             if log_enabled!(::log::INFO) {\n                 println!(\"Post-trans\");\n@@ -670,6 +672,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                f: F)\n                                                -> R\n                                                where F: for<'a> FnOnce(&'a ty::ctxt<'tcx>,\n+                                                                       MirMap<'tcx>,\n                                                                        ty::CrateAnalysis) -> R\n {\n     let time_passes = sess.time_passes();\n@@ -751,18 +754,18 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         time(time_passes, \"match checking\", ||\n             middle::check_match::check_crate(tcx));\n \n-        match tcx.sess.opts.unstable_features {\n+        let mir_map = match tcx.sess.opts.unstable_features {\n             UnstableFeatures::Disallow => {\n                 // use this as a shorthand for beta/stable, and skip\n                 // MIR construction there until known regressions are\n                 // addressed\n+                NodeMap()\n             }\n             UnstableFeatures::Allow | UnstableFeatures::Cheat => {\n-                let _mir_map =\n-                    time(time_passes, \"MIR dump\", ||\n-                            mir::mir_map::build_mir_for_crate(tcx));\n+                time(time_passes, \"MIR dump\", ||\n+                     mir::mir_map::build_mir_for_crate(tcx))\n             }\n-        }\n+        };\n \n         time(time_passes, \"liveness checking\", ||\n             middle::liveness::check_crate(tcx));\n@@ -804,7 +807,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         // The above three passes generate errors w/o aborting\n         tcx.sess.abort_if_errors();\n \n-        f(tcx, ty::CrateAnalysis {\n+        f(tcx, mir_map, ty::CrateAnalysis {\n             export_map: export_map,\n             exported_items: exported_items,\n             public_items: public_items,\n@@ -817,16 +820,18 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n-pub fn phase_4_translate_to_llvm(tcx: &ty::ctxt, analysis: ty::CrateAnalysis)\n-                                 -> trans::CrateTranslation {\n+pub fn phase_4_translate_to_llvm<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                       mir_map: &MirMap<'tcx>,\n+                                       analysis: ty::CrateAnalysis)\n+                                       -> trans::CrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n \n     time(time_passes, \"resolving dependency formats\", ||\n          dependency_format::calculate(&tcx.sess));\n \n     // Option dance to work around the lack of stack once closures.\n     time(time_passes, \"translation\", move ||\n-         trans::trans_crate(tcx, analysis))\n+         trans::trans_crate(tcx, mir_map, analysis))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file"}, {"sha": "f53822d2400b49eb4af34ba9f81993b08015e44e", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -182,7 +182,7 @@ impl PpSourceMode {\n                                                     arenas,\n                                                     id,\n                                                     resolve::MakeGlobMap::No,\n-                                                    |tcx, _| {\n+                                                    |tcx, _, _| {\n                     let annotation = TypedAnnotation { tcx: tcx };\n                     f(&annotation, payload, &ast_map.forest.krate)\n                 })\n@@ -782,7 +782,7 @@ pub fn pretty_print_input(sess: Session,\n                                                         &arenas,\n                                                         &id,\n                                                         resolve::MakeGlobMap::No,\n-                                                        |tcx, _| {\n+                                                        |tcx, _, _| {\n                         print_flowgraph(variants, tcx, code, mode, out)\n                     })\n                 }"}, {"sha": "23ca22129fdc0f99606fdba618d99e7048f8e1a1", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -71,7 +71,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n                 // schedule a shallow free of that memory, lest we unwind:\n                 let extent = this.extent_of_innermost_scope().unwrap();\n-                this.schedule_drop(expr_span, extent, DropKind::Shallow, &result, value_ty);\n+                this.schedule_drop(expr_span, extent, DropKind::Free, &result, value_ty);\n \n                 // initialize the box contents:\n                 let contents = result.clone().deref();\n@@ -149,16 +149,19 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 block.and(Rvalue::Aggregate(AggregateKind::Closure(closure_id, substs), upvars))\n             }\n             ExprKind::Adt { adt_def, variant_index, substs, fields, base } => { // see (*) above\n-                // first process the set of fields\n+                // first process the set of fields that were provided\n+                // (evaluating them in order given by user)\n                 let fields_map: FnvHashMap<_, _> =\n                     fields.into_iter()\n                           .map(|f| (f.name, unpack!(block = this.as_operand(block, f.expr))))\n                           .collect();\n \n-                let field_names = this.hir.fields(adt_def, variant_index);\n-\n+                // if base expression is given, evaluate it now\n                 let base = base.map(|base| unpack!(block = this.as_lvalue(block, base)));\n \n+                // get list of all fields that we will need\n+                let field_names = this.hir.all_fields(adt_def, variant_index);\n+\n                 // for the actual values we use, take either the\n                 // expr the user specified or, if they didn't\n                 // specify something for this field name, create a"}, {"sha": "57c6db79c5271ac8e89f1132263d9aae92468c5d", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -211,10 +211,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 this.cfg.start_new_block().unit()\n             }\n             ExprKind::Call { fun, args } => {\n-                let fun = unpack!(block = this.as_lvalue(block, fun));\n+                let fun = unpack!(block = this.as_operand(block, fun));\n                 let args: Vec<_> =\n                     args.into_iter()\n-                        .map(|arg| unpack!(block = this.as_lvalue(block, arg)))\n+                        .map(|arg| unpack!(block = this.as_operand(block, arg)))\n                         .collect();\n                 let success = this.cfg.start_new_block();\n                 let panic = this.diverge_cleanup();"}, {"sha": "e035f53dacf41130eadca00fe304c8f67a95ead9", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -92,34 +92,36 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                           .collect();\n                 self.cfg.terminate(block, Terminator::Switch {\n                     discr: lvalue.clone(),\n+                    adt_def: adt_def,\n                     targets: target_blocks.clone()\n                 });\n                 target_blocks\n             }\n \n             TestKind::Eq { value, ty } => {\n                 // call PartialEq::eq(discrim, constant)\n-                let constant = self.push_literal(block, test.span, ty.clone(), value);\n+                let constant = self.literal_operand(test.span, ty.clone(), value);\n                 let item_ref = self.hir.partial_eq(ty);\n-                self.call_comparison_fn(block, test.span, item_ref, lvalue.clone(), constant)\n+                self.call_comparison_fn(block, test.span, item_ref,\n+                                        Operand::Consume(lvalue.clone()), constant)\n             }\n \n             TestKind::Range { lo, hi, ty } => {\n                 // Test `v` by computing `PartialOrd::le(lo, v) && PartialOrd::le(v, hi)`.\n-                let lo = self.push_literal(block, test.span, ty.clone(), lo);\n-                let hi = self.push_literal(block, test.span, ty.clone(), hi);\n+                let lo = self.literal_operand(test.span, ty.clone(), lo);\n+                let hi = self.literal_operand(test.span, ty.clone(), hi);\n                 let item_ref = self.hir.partial_le(ty);\n \n                 let lo_blocks = self.call_comparison_fn(block,\n                                                         test.span,\n                                                         item_ref.clone(),\n                                                         lo,\n-                                                        lvalue.clone());\n+                                                        Operand::Consume(lvalue.clone()));\n \n                 let hi_blocks = self.call_comparison_fn(lo_blocks[0],\n                                                         test.span,\n                                                         item_ref,\n-                                                        lvalue.clone(),\n+                                                        Operand::Consume(lvalue.clone()),\n                                                         hi);\n \n                 let failure = self.cfg.start_new_block();\n@@ -164,14 +166,14 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                           block: BasicBlock,\n                           span: Span,\n                           item_ref: ItemRef<'tcx>,\n-                          lvalue1: Lvalue<'tcx>,\n-                          lvalue2: Lvalue<'tcx>)\n+                          lvalue1: Operand<'tcx>,\n+                          lvalue2: Operand<'tcx>)\n                           -> Vec<BasicBlock> {\n         let target_blocks = vec![self.cfg.start_new_block(), self.cfg.start_new_block()];\n \n         let bool_ty = self.hir.bool_ty();\n         let eq_result = self.temp(bool_ty);\n-        let func = self.push_item_ref(block, span, item_ref);\n+        let func = self.item_ref_operand(span, item_ref);\n         let call_blocks = [self.cfg.start_new_block(), self.diverge_cleanup()];\n         self.cfg.terminate(block,\n                            Terminator::Call {"}, {"sha": "41274f3f3736eb5834fe12aa013ac38885269a72", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -34,20 +34,17 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         lvalue\n     }\n \n-    pub fn push_literal(&mut self,\n-                        block: BasicBlock,\n-                        span: Span,\n-                        ty: Ty<'tcx>,\n-                        literal: Literal<'tcx>)\n-                        -> Lvalue<'tcx> {\n-        let temp = self.temp(ty.clone());\n+    pub fn literal_operand(&mut self,\n+                           span: Span,\n+                           ty: Ty<'tcx>,\n+                           literal: Literal<'tcx>)\n+                           -> Operand<'tcx> {\n         let constant = Constant {\n             span: span,\n             ty: ty,\n             literal: literal,\n         };\n-        self.cfg.push_assign_constant(block, span, &temp, constant);\n-        temp\n+        Operand::Constant(constant)\n     }\n \n     pub fn push_usize(&mut self, block: BasicBlock, span: Span, value: usize) -> Lvalue<'tcx> {\n@@ -63,15 +60,14 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         temp\n     }\n \n-    pub fn push_item_ref(&mut self,\n-                         block: BasicBlock,\n-                         span: Span,\n-                         item_ref: ItemRef<'tcx>)\n-                         -> Lvalue<'tcx> {\n+    pub fn item_ref_operand(&mut self,\n+                            span: Span,\n+                            item_ref: ItemRef<'tcx>)\n+                            -> Operand<'tcx> {\n         let literal = Literal::Item {\n             def_id: item_ref.def_id,\n             substs: item_ref.substs,\n         };\n-        self.push_literal(block, span, item_ref.ty, literal)\n+        self.literal_operand(span, item_ref.ty, literal)\n     }\n }"}, {"sha": "56a20167b794271acf6be8455116e46b4ec393dc", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n \n use hair;\n+use hair::cx::{Cx, PatNode};\n use rustc::middle::region::CodeExtent;\n-use rustc::middle::ty::Ty;\n+use rustc::middle::ty::{FnOutput, Ty};\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_front::hir;\n use repr::*;\n use syntax::ast;\n use syntax::codemap::Span;\n-use tcx::{Cx, PatNode};\n \n struct Builder<'a, 'tcx: 'a> {\n     hir: Cx<'a, 'tcx>,\n@@ -75,13 +75,14 @@ macro_rules! unpack {\n ///////////////////////////////////////////////////////////////////////////\n // construct() -- the main entry point for building MIR for a function\n \n-pub fn construct<'a, 'tcx>(mut hir: Cx<'a, 'tcx>,\n-                           _span: Span,\n-                           implicit_arguments: Vec<Ty<'tcx>>,\n-                           explicit_arguments: Vec<(Ty<'tcx>, PatNode<'tcx>)>,\n-                           argument_extent: CodeExtent,\n-                           ast_block: &'tcx hir::Block)\n-                           -> Mir<'tcx> {\n+pub fn construct<'a,'tcx>(mut hir: Cx<'a,'tcx>,\n+                          _span: Span,\n+                          implicit_arguments: Vec<Ty<'tcx>>,\n+                          explicit_arguments: Vec<(Ty<'tcx>, PatNode<'tcx>)>,\n+                          argument_extent: CodeExtent,\n+                          return_ty: FnOutput<'tcx>,\n+                          ast_block: &'tcx hir::Block)\n+                          -> Mir<'tcx> {\n     let cfg = CFG { basic_blocks: vec![] };\n \n     // it's handy to have a temporary of type `()` sometimes, so make\n@@ -121,6 +122,7 @@ pub fn construct<'a, 'tcx>(mut hir: Cx<'a, 'tcx>,\n         var_decls: builder.var_decls,\n         arg_decls: arg_decls,\n         temp_decls: builder.temp_decls,\n+        return_ty: return_ty,\n     }\n }\n "}, {"sha": "a407c42372a81daefd654f22b4f80acdace6fb0c", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "renamed", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n use hair::*;\n-\n-use tcx::Cx;\n-use tcx::pattern::PatNode;\n-use tcx::to_ref::ToRef;\n+use hair::cx::Cx;\n+use hair::cx::pattern::PatNode;\n+use hair::cx::to_ref::ToRef;\n use rustc::middle::region::{BlockRemainder, CodeExtentData};\n use rustc_front::hir;\n use syntax::ast;\n@@ -34,22 +33,11 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     }\n }\n \n-impl<'tcx> Mirror<'tcx> for &'tcx hir::Stmt {\n-    type Output = Stmt<'tcx>;\n-\n-    fn make_mirror<'a>(self, _cx: &mut Cx<'a, 'tcx>) -> Stmt<'tcx> {\n-        // In order to get the scoping correct, we eagerly mirror\n-        // statements when we translate the enclosing block, so we\n-        // should in fact never get to this point.\n-        panic!(\"statements are eagerly mirrored\");\n-    }\n-}\n-\n-fn mirror_stmts<'a, 'tcx: 'a, STMTS>(cx: &mut Cx<'a, 'tcx>,\n-                                     block_id: ast::NodeId,\n-                                     mut stmts: STMTS)\n-                                     -> Vec<StmtRef<'tcx>>\n-    where STMTS: Iterator<Item = (usize, &'tcx P<hir::Stmt>)>\n+fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n+                                  block_id: ast::NodeId,\n+                                  mut stmts: STMTS)\n+                                  -> Vec<StmtRef<'tcx>>\n+    where STMTS: Iterator<Item=(usize, &'tcx P<hir::Stmt>)>\n {\n     let mut result = vec![];\n     while let Some((index, stmt)) = stmts.next() {", "previous_filename": "src/librustc_mir/tcx/block.rs"}, {"sha": "847d76f7d17a9f18f7259befa2b3f9f6159c79b0", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "renamed", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -12,16 +12,16 @@ use hair::*;\n use repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::rc::Rc;\n-use tcx::Cx;\n-use tcx::block;\n-use tcx::pattern::PatNode;\n-use tcx::to_ref::ToRef;\n+use hair::cx::Cx;\n+use hair::cx::block;\n+use hair::cx::pattern::PatNode;\n+use hair::cx::to_ref::ToRef;\n use rustc::front::map;\n use rustc::middle::const_eval;\n use rustc::middle::def;\n use rustc::middle::region::CodeExtent;\n use rustc::middle::pat_util;\n-use rustc::middle::ty::{self, Ty};\n+use rustc::middle::ty::{self, VariantDef, Ty};\n use rustc_front::hir;\n use rustc_front::util as hir_util;\n use syntax::parse::token;\n@@ -170,11 +170,12 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             hir::ExprStruct(_, ref fields, ref base) => {\n                 match expr_ty.sty {\n                     ty::TyStruct(adt, substs) => {\n+                        let field_refs = field_refs(&adt.variants[0], fields);\n                         ExprKind::Adt {\n                             adt_def: adt,\n                             variant_index: 0,\n                             substs: substs,\n-                            fields: fields.to_ref(),\n+                            fields: field_refs,\n                             base: base.to_ref(),\n                         }\n                     }\n@@ -183,11 +184,12 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                             def::DefVariant(enum_id, variant_id, true) => {\n                                 debug_assert!(adt.did == enum_id);\n                                 let index = adt.variant_index_with_id(variant_id);\n+                                let field_refs = field_refs(&adt.variants[index], fields);\n                                 ExprKind::Adt {\n                                     adt_def: adt,\n                                     variant_index: index,\n                                     substs: substs,\n-                                    fields: fields.to_ref(),\n+                                    fields: field_refs,\n                                     base: base.to_ref(),\n                                 }\n                             }\n@@ -238,11 +240,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     }\n                 };\n \n-                let field_expr_ref = |s: &'tcx P<hir::Expr>, nm: &str| {\n-                    FieldExprRef {\n-                        name: Field::Named(token::intern(nm)),\n-                        expr: s.to_ref(),\n-                    }\n+                let field_expr_ref = |s: &'tcx P<hir::Expr>, name: &str| {\n+                    let name = token::intern(name);\n+                    let index = adt_def.variants[0].index_of_field_named(name).unwrap();\n+                    FieldExprRef { name: Field::new(index), expr: s.to_ref() }\n                 };\n \n                 let start_field = start.as_ref()\n@@ -293,12 +294,25 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             hir::ExprLoop(ref body, _) =>\n                 ExprKind::Loop { condition: None,\n                                  body: block::to_expr_ref(cx, body) },\n-            hir::ExprField(ref source, name) =>\n-                ExprKind::Field { lhs: source.to_ref(),\n-                                  name: Field::Named(name.node) },\n+            hir::ExprField(ref source, name) => {\n+                let index = match cx.tcx.expr_ty_adjusted(source).sty {\n+                    ty::TyStruct(adt_def, _) =>\n+                        adt_def.variants[0].index_of_field_named(name.node),\n+                    ref ty =>\n+                        cx.tcx.sess.span_bug(\n+                            self.span,\n+                            &format!(\"field of non-struct: {:?}\", ty)),\n+                };\n+                let index = index.unwrap_or_else(|| {\n+                    cx.tcx.sess.span_bug(\n+                        self.span,\n+                        &format!(\"no index found for field `{}`\", name.node));\n+                });\n+                ExprKind::Field { lhs: source.to_ref(), name: Field::new(index) }\n+            }\n             hir::ExprTupField(ref source, index) =>\n                 ExprKind::Field { lhs: source.to_ref(),\n-                                  name: Field::Indexed(index.node) },\n+                                  name: Field::new(index.node as usize) },\n             hir::ExprCast(ref source, _) =>\n                 ExprKind::Cast { source: source.to_ref() },\n             hir::ExprBox(ref value) =>\n@@ -616,7 +630,7 @@ fn convert_var<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n             // at this point we have `self.n`, which loads up the upvar\n             let field_kind = ExprKind::Field {\n                 lhs: self_expr.to_ref(),\n-                name: Field::Indexed(index),\n+                name: Field::new(index),\n             };\n \n             // ...but the upvar might be an `&T` or `&mut T` capture, at which\n@@ -814,3 +828,15 @@ fn loop_label<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> Cod\n         }\n     }\n }\n+\n+fn field_refs<'tcx>(variant: VariantDef<'tcx>,\n+                    fields: &'tcx [hir::Field])\n+                    -> Vec<FieldExprRef<'tcx>>\n+{\n+    fields.iter()\n+          .map(|field| FieldExprRef {\n+              name: Field::new(variant.index_of_field_named(field.name.node).unwrap()),\n+              expr: field.expr.to_ref(),\n+          })\n+          .collect()\n+}", "previous_filename": "src/librustc_mir/tcx/expr.rs"}, {"sha": "8d4b05afcb6e6f77b790ad87617a60d7ce040615", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -0,0 +1,149 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * This module contains the code to convert from the wacky tcx data\n+ * structures into the hair. The `builder` is generally ignorant of\n+ * the tcx etc, and instead goes through the `Cx` for most of its\n+ * work.\n+ */\n+\n+use hair::*;\n+use repr::*;\n+\n+use rustc::middle::const_eval::ConstVal;\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::infer::InferCtxt;\n+use rustc::middle::subst::{Subst, Substs};\n+use rustc::middle::ty::{self, Ty};\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+\n+#[derive(Copy, Clone)]\n+pub struct Cx<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+}\n+\n+impl<'a,'tcx> Cx<'a,'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Cx<'a, 'tcx> {\n+        Cx {\n+            tcx: infcx.tcx,\n+            infcx: infcx,\n+        }\n+    }\n+}\n+\n+pub use self::pattern::PatNode;\n+\n+impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n+    /// Normalizes `ast` into the appropriate `mirror` type.\n+    pub fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n+        ast.make_mirror(self)\n+    }\n+\n+    pub fn unit_ty(&mut self) -> Ty<'tcx> {\n+        self.tcx.mk_nil()\n+    }\n+\n+    pub fn usize_ty(&mut self) -> Ty<'tcx> {\n+        self.tcx.types.usize\n+    }\n+\n+    pub fn usize_literal(&mut self, value: usize) -> Literal<'tcx> {\n+        Literal::Value { value: ConstVal::Uint(value as u64) }\n+    }\n+\n+    pub fn bool_ty(&mut self) -> Ty<'tcx> {\n+        self.tcx.types.bool\n+    }\n+\n+    pub fn true_literal(&mut self) -> Literal<'tcx> {\n+        Literal::Value { value: ConstVal::Bool(true) }\n+    }\n+\n+    pub fn false_literal(&mut self) -> Literal<'tcx> {\n+        Literal::Value { value: ConstVal::Bool(false) }\n+    }\n+\n+    pub fn partial_eq(&mut self, ty: Ty<'tcx>) -> ItemRef<'tcx> {\n+        let eq_def_id = self.tcx.lang_items.eq_trait().unwrap();\n+        self.cmp_method_ref(eq_def_id, \"eq\", ty)\n+    }\n+\n+    pub fn partial_le(&mut self, ty: Ty<'tcx>) -> ItemRef<'tcx> {\n+        let ord_def_id = self.tcx.lang_items.ord_trait().unwrap();\n+        self.cmp_method_ref(ord_def_id, \"le\", ty)\n+    }\n+\n+    pub fn num_variants(&mut self, adt_def: ty::AdtDef<'tcx>) -> usize {\n+        adt_def.variants.len()\n+    }\n+\n+    pub fn all_fields(&mut self, adt_def: ty::AdtDef<'tcx>, variant_index: usize) -> Vec<Field> {\n+        (0..adt_def.variants[variant_index].fields.len())\n+            .map(Field::new)\n+            .collect()\n+    }\n+\n+    pub fn needs_drop(&mut self, ty: Ty<'tcx>, span: Span) -> bool {\n+        if self.infcx.type_moves_by_default(ty, span) {\n+            // FIXME(#21859) we should do an add'l check here to determine if\n+            // any dtor will execute, but the relevant fn\n+            // (`type_needs_drop`) is currently factored into\n+            // `librustc_trans`, so we can't easily do so.\n+            true\n+        } else {\n+            // if type implements Copy, cannot require drop\n+            false\n+        }\n+    }\n+\n+    pub fn span_bug(&mut self, span: Span, message: &str) -> ! {\n+        self.tcx.sess.span_bug(span, message)\n+    }\n+\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn cmp_method_ref(&mut self,\n+                      trait_def_id: DefId,\n+                      method_name: &str,\n+                      arg_ty: Ty<'tcx>)\n+                      -> ItemRef<'tcx> {\n+        let method_name = token::intern(method_name);\n+        let substs = Substs::new_trait(vec![arg_ty], vec![], arg_ty);\n+        for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n+            match *trait_item {\n+                ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n+                    if method.name == method_name {\n+                        let method_ty = self.tcx.lookup_item_type(method.def_id);\n+                        let method_ty = method_ty.ty.subst(self.tcx, &substs);\n+                        return ItemRef {\n+                            ty: method_ty,\n+                            def_id: method.def_id,\n+                            substs: self.tcx.mk_substs(substs),\n+                        };\n+                    }\n+                }\n+                ty::ImplOrTraitItem::ConstTraitItem(..) |\n+                ty::ImplOrTraitItem::TypeTraitItem(..) => {}\n+            }\n+        }\n+\n+        self.tcx.sess.bug(&format!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id));\n+    }\n+}\n+\n+mod block;\n+mod expr;\n+mod pattern;\n+mod to_ref;"}, {"sha": "31dbffa0ae348a336d91e97f9fb806d303417a7c", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "renamed", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -9,12 +9,11 @@\n // except according to those terms.\n \n use hair::*;\n+use hair::cx::Cx;\n+use hair::cx::to_ref::ToRef;\n use repr::*;\n-\n use rustc_data_structures::fnv::FnvHashMap;\n use std::rc::Rc;\n-use tcx::Cx;\n-use tcx::to_ref::ToRef;\n use rustc::middle::const_eval;\n use rustc::middle::def;\n use rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n@@ -223,7 +222,7 @@ impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n                     subpatterns.iter()\n                                .enumerate()\n                                .map(|(i, subpattern)| FieldPatternRef {\n-                                   field: Field::Indexed(i),\n+                                   field: Field::new(i),\n                                    pattern: self.pat_ref(subpattern),\n                                })\n                                .collect();\n@@ -273,21 +272,43 @@ impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n                                    .flat_map(|v| v.iter())\n                                    .enumerate()\n                                    .map(|(i, field)| FieldPatternRef {\n-                                       field: Field::Indexed(i),\n+                                       field: Field::new(i),\n                                        pattern: self.pat_ref(field),\n                                    })\n                                    .collect();\n                 self.variant_or_leaf(cx, subpatterns)\n             }\n \n             hir::PatStruct(_, ref fields, _) => {\n+                let pat_ty = cx.tcx.node_id_to_type(self.pat.id);\n+                let adt_def = match pat_ty.sty {\n+                    ty::TyStruct(adt_def, _) | ty::TyEnum(adt_def, _) => adt_def,\n+                    _ => {\n+                        cx.tcx.sess.span_bug(\n+                            self.pat.span,\n+                            \"struct pattern not applied to struct or enum\");\n+                    }\n+                };\n+\n+                let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n+                let variant_def = adt_def.variant_of_def(def);\n+\n                 let subpatterns =\n                     fields.iter()\n-                          .map(|field| FieldPatternRef {\n-                              field: Field::Named(field.node.name),\n-                              pattern: self.pat_ref(&field.node.pat),\n+                          .map(|field| {\n+                              let index = variant_def.index_of_field_named(field.node.name);\n+                              let index = index.unwrap_or_else(|| {\n+                                  cx.tcx.sess.span_bug(\n+                                      self.pat.span,\n+                                      &format!(\"no field with name {:?}\", field.node.name));\n+                              });\n+                              FieldPatternRef {\n+                                  field: Field::new(index),\n+                                  pattern: self.pat_ref(&field.node.pat),\n+                              }\n                           })\n                           .collect();\n+\n                 self.variant_or_leaf(cx, subpatterns)\n             }\n ", "previous_filename": "src/librustc_mir/tcx/pattern.rs"}, {"sha": "e0b8abfbd9ce3dcc45ed360fc142d591780fdb84", "filename": "src/librustc_mir/hair/cx/to_ref.rs", "status": "renamed", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n use hair::*;\n-use repr::*;\n \n-use tcx::pattern::PatNode;\n+use hair::cx::pattern::PatNode;\n use rustc_front::hir;\n use syntax::ptr::P;\n \n@@ -79,14 +78,3 @@ impl<'a,'tcx:'a,T,U> ToRef for &'tcx Vec<T>\n         self.iter().map(|expr| expr.to_ref()).collect()\n     }\n }\n-\n-impl<'a,'tcx:'a> ToRef for &'tcx hir::Field {\n-    type Output = FieldExprRef<'tcx>;\n-\n-    fn to_ref(self) -> FieldExprRef<'tcx> {\n-        FieldExprRef {\n-            name: Field::Named(self.name.node),\n-            expr: self.expr.to_ref(),\n-        }\n-    }\n-}", "previous_filename": "src/librustc_mir/tcx/to_ref.rs"}, {"sha": "becaa19974d8e216dea9f5ec837bad3c1a6d35ab", "filename": "src/librustc_mir/hair/mod.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -22,7 +22,9 @@ use rustc::middle::ty::{AdtDef, ClosureSubsts, Region, Ty};\n use rustc_front::hir;\n use syntax::ast;\n use syntax::codemap::Span;\n-use tcx::{Cx, PatNode};\n+use self::cx::{Cx, PatNode};\n+\n+pub mod cx;\n \n #[derive(Clone, Debug)]\n pub struct ItemRef<'tcx> {\n@@ -41,7 +43,6 @@ pub struct Block<'tcx> {\n \n #[derive(Clone, Debug)]\n pub enum StmtRef<'tcx> {\n-    Hair(&'tcx hir::Stmt),\n     Mirror(Box<Stmt<'tcx>>),\n }\n \n@@ -392,9 +393,8 @@ impl<'tcx> Mirror<'tcx> for Stmt<'tcx> {\n impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n     type Output = Stmt<'tcx>;\n \n-    fn make_mirror<'a>(self, hir: &mut Cx<'a, 'tcx>) -> Stmt<'tcx> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a,'tcx>) -> Stmt<'tcx> {\n         match self {\n-            StmtRef::Hair(h) => h.make_mirror(hir),\n             StmtRef::Mirror(m) => *m,\n         }\n     }", "previous_filename": "src/librustc_mir/hair.rs"}, {"sha": "ed5df21d911935daa99b6efddae4927f319180e6", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -31,7 +31,9 @@ extern crate syntax;\n \n pub mod build;\n pub mod mir_map;\n-pub mod hair;\n+mod hair;\n pub mod repr;\n mod graphviz;\n-mod tcx;\n+pub mod tcx;\n+pub mod visit;\n+"}, {"sha": "ebcb1db1151eed8e8670b3432f58aa51423b1c59", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -23,8 +23,8 @@ extern crate rustc_front;\n use build;\n use dot;\n use repr::Mir;\n+use hair::cx::{PatNode, Cx};\n use std::fs::File;\n-use tcx::{PatNode, Cx};\n \n use self::rustc::middle::infer;\n use self::rustc::middle::region::CodeExtentData;\n@@ -189,26 +189,42 @@ impl<'a, 'm, 'tcx> visit::Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n     }\n }\n \n-fn build_mir<'a, 'tcx: 'a>(cx: Cx<'a, 'tcx>,\n-                           implicit_arg_tys: Vec<Ty<'tcx>>,\n-                           fn_id: ast::NodeId,\n-                           span: Span,\n-                           decl: &'tcx hir::FnDecl,\n-                           body: &'tcx hir::Block)\n-                           -> Result<Mir<'tcx>, ErrorReported> {\n-    let arguments = decl.inputs\n-                        .iter()\n-                        .map(|arg| {\n-                            let ty = cx.tcx().node_id_to_type(arg.id);\n-                            (ty, PatNode::irrefutable(&arg.pat))\n-                        })\n-                        .collect();\n-\n-    let parameter_scope = cx.tcx().region_maps.lookup_code_extent(CodeExtentData::ParameterScope {\n-        fn_id: fn_id,\n-        body_id: body.id,\n-    });\n-    Ok(build::construct(cx, span, implicit_arg_tys, arguments, parameter_scope, body))\n+fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n+                         implicit_arg_tys: Vec<Ty<'tcx>>,\n+                         fn_id: ast::NodeId,\n+                         span: Span,\n+                         decl: &'tcx hir::FnDecl,\n+                         body: &'tcx hir::Block)\n+                         -> Result<Mir<'tcx>, ErrorReported> {\n+    // fetch the fully liberated fn signature (that is, all bound\n+    // types/lifetimes replaced)\n+    let fn_sig = match cx.tcx().tables.borrow().liberated_fn_sigs.get(&fn_id) {\n+        Some(f) => f.clone(),\n+        None => {\n+            cx.tcx().sess.span_bug(span,\n+                                   &format!(\"no liberated fn sig for {:?}\", fn_id));\n+        }\n+    };\n+\n+    let arguments =\n+        decl.inputs\n+            .iter()\n+            .enumerate()\n+            .map(|(index, arg)| {\n+                (fn_sig.inputs[index], PatNode::irrefutable(&arg.pat))\n+            })\n+            .collect();\n+\n+    let parameter_scope =\n+        cx.tcx().region_maps.lookup_code_extent(\n+            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.id });\n+    Ok(build::construct(cx,\n+                        span,\n+                        implicit_arg_tys,\n+                        arguments,\n+                        parameter_scope,\n+                        fn_sig.output,\n+                        body))\n }\n \n fn closure_self_ty<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,"}, {"sha": "89b1afa8723811d881bc9d4962be9b7816f53256", "filename": "src/librustc_mir/repr.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Frepr.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -12,7 +12,7 @@ use rustc::middle::const_eval::ConstVal;\n use rustc::middle::def_id::DefId;\n use rustc::middle::region::CodeExtent;\n use rustc::middle::subst::Substs;\n-use rustc::middle::ty::{AdtDef, ClosureSubsts, Region, Ty};\n+use rustc::middle::ty::{AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n use rustc_back::slice;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_front::hir::InlineAsm;\n@@ -25,6 +25,8 @@ use std::u32;\n pub struct Mir<'tcx> {\n     pub basic_blocks: Vec<BasicBlockData<'tcx>>,\n \n+    pub return_ty: FnOutput<'tcx>,\n+\n     // for every node id\n     pub extents: FnvHashMap<CodeExtent, Vec<GraphExtent>>,\n \n@@ -245,6 +247,7 @@ pub enum Terminator<'tcx> {\n     /// lvalue evaluates to some enum; jump depending on the branch\n     Switch {\n         discr: Lvalue<'tcx>,\n+        adt_def: AdtDef<'tcx>,\n         targets: Vec<BasicBlock>,\n     },\n \n@@ -277,7 +280,7 @@ impl<'tcx> Terminator<'tcx> {\n             Goto { target: ref b } => slice::ref_slice(b),\n             Panic { target: ref b } => slice::ref_slice(b),\n             If { cond: _, targets: ref b } => b,\n-            Switch { discr: _, targets: ref b } => b,\n+            Switch { discr: _, adt_def: _, targets: ref b } => b,\n             Diverge => &[],\n             Return => &[],\n             Call { data: _, targets: ref b } => b,\n@@ -291,10 +294,10 @@ pub struct CallData<'tcx> {\n     pub destination: Lvalue<'tcx>,\n \n     /// the fn being called\n-    pub func: Lvalue<'tcx>,\n+    pub func: Operand<'tcx>,\n \n     /// the arguments\n-    pub args: Vec<Lvalue<'tcx>>,\n+    pub args: Vec<Operand<'tcx>>,\n }\n \n impl<'tcx> BasicBlockData<'tcx> {\n@@ -316,7 +319,7 @@ impl<'tcx> Debug for Terminator<'tcx> {\n                 write!(fmt, \"panic -> {:?}\", target),\n             If { cond: ref lv, ref targets } =>\n                 write!(fmt, \"if({:?}) -> {:?}\", lv, targets),\n-            Switch { discr: ref lv, ref targets } =>\n+            Switch { discr: ref lv, adt_def: _, ref targets } =>\n                 write!(fmt, \"switch({:?}) -> {:?}\", lv, targets),\n             Diverge =>\n                 write!(fmt, \"diverge\"),\n@@ -353,16 +356,16 @@ pub enum StatementKind<'tcx> {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum DropKind {\n-    Shallow,\n-    Deep,\n+    Free, // free a partially constructed box, should go away eventually\n+    Deep\n }\n \n impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n         use self::StatementKind::*;\n         match self.kind {\n             Assign(ref lv, ref rv) => write!(fmt, \"{:?} = {:?}\", lv, rv),\n-            Drop(DropKind::Shallow, ref lv) => write!(fmt, \"shallow_drop {:?}\", lv),\n+            Drop(DropKind::Free, ref lv) => write!(fmt, \"free {:?}\", lv),\n             Drop(DropKind::Deep, ref lv) => write!(fmt, \"drop {:?}\", lv),\n         }\n     }\n@@ -441,10 +444,19 @@ pub type LvalueProjection<'tcx> =\n pub type LvalueElem<'tcx> =\n     ProjectionElem<'tcx,Operand<'tcx>>;\n \n+/// Index into the list of fields found in a `VariantDef`\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum Field {\n-    Named(Name),\n-    Indexed(usize),\n+pub struct Field(u32);\n+\n+impl Field {\n+    pub fn new(value: usize) -> Field {\n+        assert!(value < (u32::MAX) as usize);\n+        Field(value as u32)\n+    }\n+\n+    pub fn index(self) -> usize {\n+        self.0 as usize\n+    }\n }\n \n impl<'tcx> Lvalue<'tcx> {\n@@ -489,10 +501,8 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n                         write!(fmt,\"({:?} as {:?})\", data.base, variant_index),\n                     ProjectionElem::Deref =>\n                         write!(fmt,\"(*{:?})\", data.base),\n-                    ProjectionElem::Field(Field::Named(name)) =>\n-                        write!(fmt,\"{:?}.{:?}\", data.base, name),\n-                    ProjectionElem::Field(Field::Indexed(index)) =>\n-                        write!(fmt,\"{:?}.{:?}\", data.base, index),\n+                    ProjectionElem::Field(field) =>\n+                        write!(fmt,\"{:?}.{:?}\", data.base, field.index()),\n                     ProjectionElem::Index(ref index) =>\n                         write!(fmt,\"{:?}[{:?}]\", data.base, index),\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>"}, {"sha": "3b9d9228a1680ff5f59ffcc996d1f2bd882ef313", "filename": "src/librustc_mir/tcx/mod.rs", "status": "modified", "additions": 97, "deletions": 130, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fmod.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -9,150 +9,117 @@\n // except according to those terms.\n \n /*!\n- * This module contains the code to convert from the wacky tcx data\n- * structures into the hair. The `builder` is generally ignorant of\n- * the tcx etc, and instead goes through the `Cx` for most of its\n- * work.\n+ * Methods for the various MIR types. These are intended for use after\n+ * building is complete.\n  */\n \n-use hair::*;\n use repr::*;\n-\n-use rustc::middle::const_eval::ConstVal;\n-use rustc::middle::def_id::DefId;\n-use rustc::middle::infer::InferCtxt;\n-use rustc::middle::subst::{Subst, Substs};\n-use rustc::middle::ty::{self, Ty};\n-use syntax::codemap::Span;\n-use syntax::parse::token::{self, special_idents};\n-\n-#[derive(Copy, Clone)]\n-pub struct Cx<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-}\n-\n-impl<'a,'tcx> Cx<'a,'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Cx<'a, 'tcx> {\n-        Cx {\n-            tcx: infcx.tcx,\n-            infcx: infcx,\n-        }\n-    }\n+use rustc::middle::subst::Substs;\n+use rustc::middle::ty::{self, AdtDef, Ty};\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum LvalueTy<'tcx> {\n+    /// Normal type.\n+    Ty { ty: Ty<'tcx> },\n+\n+    /// Downcast to a particular variant of an enum.\n+    Downcast { adt_def: AdtDef<'tcx>,\n+               substs: &'tcx Substs<'tcx>,\n+               variant_index: usize },\n }\n \n-pub use self::pattern::PatNode;\n-\n-impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n-    /// Normalizes `ast` into the appropriate `mirror` type.\n-    pub fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n-        ast.make_mirror(self)\n-    }\n-\n-    pub fn unit_ty(&mut self) -> Ty<'tcx> {\n-        self.tcx.mk_nil()\n-    }\n-\n-    pub fn usize_ty(&mut self) -> Ty<'tcx> {\n-        self.tcx.types.usize\n-    }\n-\n-    pub fn usize_literal(&mut self, value: usize) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Uint(value as u64) }\n-    }\n-\n-    pub fn bool_ty(&mut self) -> Ty<'tcx> {\n-        self.tcx.types.bool\n-    }\n-\n-    pub fn true_literal(&mut self) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Bool(true) }\n-    }\n-\n-    pub fn false_literal(&mut self) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Bool(false) }\n+impl<'tcx> LvalueTy<'tcx> {\n+    pub fn from_ty(ty: Ty<'tcx>) -> LvalueTy<'tcx> {\n+        LvalueTy::Ty { ty: ty }\n     }\n \n-    pub fn partial_eq(&mut self, ty: Ty<'tcx>) -> ItemRef<'tcx> {\n-        let eq_def_id = self.tcx.lang_items.eq_trait().unwrap();\n-        self.cmp_method_ref(eq_def_id, \"eq\", ty)\n-    }\n-\n-    pub fn partial_le(&mut self, ty: Ty<'tcx>) -> ItemRef<'tcx> {\n-        let ord_def_id = self.tcx.lang_items.ord_trait().unwrap();\n-        self.cmp_method_ref(ord_def_id, \"le\", ty)\n-    }\n-\n-    pub fn num_variants(&mut self, adt_def: ty::AdtDef<'tcx>) -> usize {\n-        adt_def.variants.len()\n-    }\n-\n-    pub fn fields(&mut self, adt_def: ty::AdtDef<'tcx>, variant_index: usize) -> Vec<Field> {\n-        adt_def.variants[variant_index]\n-            .fields\n-            .iter()\n-            .enumerate()\n-            .map(|(index, field)| {\n-                if field.name == special_idents::unnamed_field.name {\n-                    Field::Indexed(index)\n-                } else {\n-                    Field::Named(field.name)\n-                }\n-            })\n-            .collect()\n-    }\n-\n-    pub fn needs_drop(&mut self, ty: Ty<'tcx>, span: Span) -> bool {\n-        if self.infcx.type_moves_by_default(ty, span) {\n-            // FIXME(#21859) we should do an add'l check here to determine if\n-            // any dtor will execute, but the relevant fn\n-            // (`type_needs_drop`) is currently factored into\n-            // `librustc_trans`, so we can't easily do so.\n-            true\n-        } else {\n-            // if type implements Copy, cannot require drop\n-            false\n+    pub fn to_ty(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            LvalueTy::Ty { ty } =>\n+                ty,\n+            LvalueTy::Downcast { adt_def, substs, variant_index: _ } =>\n+                tcx.mk_enum(adt_def, substs),\n         }\n     }\n \n-    pub fn span_bug(&mut self, span: Span, message: &str) -> ! {\n-        self.tcx.sess.span_bug(span, message)\n+    pub fn projection_ty(self,\n+                         tcx: &ty::ctxt<'tcx>,\n+                         elem: &LvalueElem<'tcx>)\n+                         -> LvalueTy<'tcx>\n+    {\n+        match *elem {\n+            ProjectionElem::Deref =>\n+                LvalueTy::Ty {\n+                    ty: self.to_ty(tcx).builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                                          .unwrap()\n+                                          .ty\n+                },\n+            ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } =>\n+                LvalueTy::Ty {\n+                    ty: self.to_ty(tcx).builtin_index().unwrap()\n+                },\n+            ProjectionElem::Downcast(adt_def1, index) =>\n+                match self.to_ty(tcx).sty {\n+                    ty::TyEnum(adt_def, substs) => {\n+                        assert!(index < adt_def.variants.len());\n+                        assert_eq!(adt_def, adt_def1);\n+                        LvalueTy::Downcast { adt_def: adt_def,\n+                                             substs: substs,\n+                                             variant_index: index }\n+                    }\n+                    _ => {\n+                        tcx.sess.bug(&format!(\"cannot downcast non-enum type: `{:?}`\", self))\n+                    }\n+                },\n+            ProjectionElem::Field(field) => {\n+                let field_ty = match self {\n+                    LvalueTy::Ty { ty } => match ty.sty {\n+                        ty::TyStruct(adt_def, substs) =>\n+                            adt_def.struct_variant().fields[field.index()].ty(tcx, substs),\n+                        ty::TyTuple(ref tys) =>\n+                            tys[field.index()],\n+                        _ =>\n+                            tcx.sess.bug(&format!(\"cannot get field of type: `{:?}`\", ty)),\n+                    },\n+                    LvalueTy::Downcast { adt_def, substs, variant_index } =>\n+                        adt_def.variants[variant_index].fields[field.index()].ty(tcx, substs),\n+                };\n+                LvalueTy::Ty { ty: field_ty }\n+            }\n+        }\n     }\n+}\n \n-    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n-        self.tcx\n+impl<'tcx> Mir<'tcx> {\n+    pub fn operand_ty(&self,\n+                      tcx: &ty::ctxt<'tcx>,\n+                      operand: &Operand<'tcx>)\n+                      -> Ty<'tcx>\n+    {\n+        match *operand {\n+            Operand::Consume(ref l) => self.lvalue_ty(tcx, l).to_ty(tcx),\n+            Operand::Constant(ref c) => c.ty,\n+        }\n     }\n \n-    fn cmp_method_ref(&mut self,\n-                      trait_def_id: DefId,\n-                      method_name: &str,\n-                      arg_ty: Ty<'tcx>)\n-                      -> ItemRef<'tcx> {\n-        let method_name = token::intern(method_name);\n-        let substs = Substs::new_trait(vec![arg_ty], vec![], arg_ty);\n-        for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n-            match *trait_item {\n-                ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n-                    if method.name == method_name {\n-                        let method_ty = self.tcx.lookup_item_type(method.def_id);\n-                        let method_ty = method_ty.ty.subst(self.tcx, &substs);\n-                        return ItemRef {\n-                            ty: method_ty,\n-                            def_id: method.def_id,\n-                            substs: self.tcx.mk_substs(substs),\n-                        };\n-                    }\n-                }\n-                ty::ImplOrTraitItem::ConstTraitItem(..) |\n-                ty::ImplOrTraitItem::TypeTraitItem(..) => {}\n-            }\n+    pub fn lvalue_ty(&self,\n+                     tcx: &ty::ctxt<'tcx>,\n+                     lvalue: &Lvalue<'tcx>)\n+                     -> LvalueTy<'tcx>\n+    {\n+        match *lvalue {\n+            Lvalue::Var(index) =>\n+                LvalueTy::Ty { ty: self.var_decls[index as usize].ty },\n+            Lvalue::Temp(index) =>\n+                LvalueTy::Ty { ty: self.temp_decls[index as usize].ty },\n+            Lvalue::Arg(index) =>\n+                LvalueTy::Ty { ty: self.arg_decls[index as usize].ty },\n+            Lvalue::Static(def_id) =>\n+                LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n+            Lvalue::ReturnPointer =>\n+                LvalueTy::Ty { ty: self.return_ty.unwrap() },\n+            Lvalue::Projection(ref proj) =>\n+                self.lvalue_ty(tcx, &proj.base).projection_ty(tcx, &proj.elem)\n         }\n-\n-        self.tcx.sess.bug(&format!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id));\n     }\n }\n-\n-mod block;\n-mod expr;\n-mod pattern;\n-mod to_ref;"}, {"sha": "b4d6075d0adb7a23d5f5cee5493c6a8e0506d6ee", "filename": "src/librustc_mir/visit.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_mir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fvisit.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -0,0 +1,239 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::middle::ty::Region;\n+use repr::*;\n+\n+pub trait Visitor<'tcx> {\n+    // Override these, and call `self.super_xxx` to revert back to the\n+    // default behavior.\n+\n+    fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n+        self.super_mir(mir);\n+    }\n+\n+    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n+        self.super_basic_block_data(block, data);\n+    }\n+\n+    fn visit_statement(&mut self, block: BasicBlock, statement: &Statement<'tcx>) {\n+        self.super_statement(block, statement);\n+    }\n+\n+    fn visit_assign(&mut self, block: BasicBlock, lvalue: &Lvalue<'tcx>, rvalue: &Rvalue<'tcx>) {\n+        self.super_assign(block, lvalue, rvalue);\n+    }\n+\n+    fn visit_terminator(&mut self, block: BasicBlock, terminator: &Terminator<'tcx>) {\n+        self.super_terminator(block, terminator);\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n+        self.super_rvalue(rvalue);\n+    }\n+\n+    fn visit_operand(&mut self, operand: &Operand<'tcx>) {\n+        self.super_operand(operand);\n+    }\n+\n+    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext) {\n+        self.super_lvalue(lvalue, context);\n+    }\n+\n+    fn visit_branch(&mut self, source: BasicBlock, target: BasicBlock) {\n+        self.super_branch(source, target);\n+    }\n+\n+    fn visit_constant(&mut self, constant: &Constant<'tcx>) {\n+        self.super_constant(constant);\n+    }\n+\n+    // The `super_xxx` methods comprise the default behavior and are\n+    // not meant to be overidden.\n+\n+    fn super_mir(&mut self, mir: &Mir<'tcx>) {\n+        for block in mir.all_basic_blocks() {\n+            let data = mir.basic_block_data(block);\n+            self.visit_basic_block_data(block, data);\n+        }\n+    }\n+\n+    fn super_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n+        for statement in &data.statements {\n+            self.visit_statement(block, statement);\n+        }\n+        self.visit_terminator(block, &data.terminator);\n+    }\n+\n+    fn super_statement(&mut self, block: BasicBlock, statement: &Statement<'tcx>) {\n+        match statement.kind {\n+            StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                self.visit_assign(block, lvalue, rvalue);\n+            }\n+            StatementKind::Drop(_, ref lvalue) => {\n+                self.visit_lvalue(lvalue, LvalueContext::Drop);\n+            }\n+        }\n+    }\n+\n+    fn super_assign(&mut self, _block: BasicBlock, lvalue: &Lvalue<'tcx>, rvalue: &Rvalue<'tcx>) {\n+        self.visit_lvalue(lvalue, LvalueContext::Store);\n+        self.visit_rvalue(rvalue);\n+    }\n+\n+    fn super_terminator(&mut self, block: BasicBlock, terminator: &Terminator<'tcx>) {\n+        match *terminator {\n+            Terminator::Goto { target } |\n+            Terminator::Panic { target } => {\n+                self.visit_branch(block, target);\n+            }\n+\n+            Terminator::If { ref cond, ref targets } => {\n+                self.visit_operand(cond);\n+                for &target in &targets[..] {\n+                    self.visit_branch(block, target);\n+                }\n+            }\n+\n+            Terminator::Switch { ref discr, adt_def: _, ref targets } => {\n+                self.visit_lvalue(discr, LvalueContext::Inspect);\n+                for &target in targets {\n+                    self.visit_branch(block, target);\n+                }\n+            }\n+\n+            Terminator::Diverge |\n+            Terminator::Return => {\n+            }\n+\n+            Terminator::Call { ref data, ref targets } => {\n+                self.visit_lvalue(&data.destination, LvalueContext::Store);\n+                self.visit_operand(&data.func);\n+                for arg in &data.args {\n+                    self.visit_operand(arg);\n+                }\n+                for &target in &targets[..] {\n+                    self.visit_branch(block, target);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn super_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n+        match *rvalue {\n+            Rvalue::Use(ref operand) => {\n+                self.visit_operand(operand);\n+            }\n+\n+            Rvalue::Repeat(ref value, ref len) => {\n+                self.visit_operand(value);\n+                self.visit_operand(len);\n+            }\n+\n+            Rvalue::Ref(r, bk, ref path) => {\n+                self.visit_lvalue(path, LvalueContext::Borrow {\n+                    region: r,\n+                    kind: bk\n+                });\n+            }\n+\n+            Rvalue::Len(ref path) => {\n+                self.visit_lvalue(path, LvalueContext::Inspect);\n+            }\n+\n+            Rvalue::Cast(_, ref operand, _) => {\n+                self.visit_operand(operand);\n+            }\n+\n+            Rvalue::BinaryOp(_, ref lhs, ref rhs) => {\n+                self.visit_operand(lhs);\n+                self.visit_operand(rhs);\n+            }\n+\n+            Rvalue::UnaryOp(_, ref op) => {\n+                self.visit_operand(op);\n+            }\n+\n+            Rvalue::Box(_) => {\n+            }\n+\n+            Rvalue::Aggregate(_, ref operands) => {\n+                for operand in operands {\n+                    self.visit_operand(operand);\n+                }\n+            }\n+\n+            Rvalue::Slice { ref input, from_start, from_end } => {\n+                self.visit_lvalue(input, LvalueContext::Slice {\n+                    from_start: from_start,\n+                    from_end: from_end,\n+                });\n+            }\n+\n+            Rvalue::InlineAsm(_) => {\n+            }\n+        }\n+    }\n+\n+    fn super_operand(&mut self, operand: &Operand<'tcx>) {\n+        match *operand {\n+            Operand::Consume(ref lvalue) => {\n+                self.visit_lvalue(lvalue, LvalueContext::Consume);\n+            }\n+            Operand::Constant(ref constant) => {\n+                self.visit_constant(constant);\n+            }\n+        }\n+    }\n+\n+    fn super_lvalue(&mut self, lvalue: &Lvalue<'tcx>, _context: LvalueContext) {\n+        match *lvalue {\n+            Lvalue::Var(_) |\n+            Lvalue::Temp(_) |\n+            Lvalue::Arg(_) |\n+            Lvalue::Static(_) |\n+            Lvalue::ReturnPointer => {\n+            }\n+            Lvalue::Projection(ref proj) => {\n+                self.visit_lvalue(&proj.base, LvalueContext::Projection);\n+            }\n+        }\n+    }\n+\n+    fn super_branch(&mut self, _source: BasicBlock, _target: BasicBlock) {\n+    }\n+\n+    fn super_constant(&mut self, _constant: &Constant<'tcx>) {\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum LvalueContext {\n+    // Appears as LHS of an assignment or as dest of a call\n+    Store,\n+\n+    // Being dropped\n+    Drop,\n+\n+    // Being inspected in some way, like loading a len\n+    Inspect,\n+\n+    // Being borrowed\n+    Borrow { region: Region, kind: BorrowKind },\n+\n+    // Being sliced -- this should be same as being borrowed, probably\n+    Slice { from_start: usize, from_end: usize },\n+\n+    // Used as base for another lvalue, e.g. `x` in `x.y`\n+    Projection,\n+\n+    // Consumed as part of an operand\n+    Consume,\n+}"}, {"sha": "84ce458ed14f7f4b62acfffd87453a2e12a0e0bb", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -37,6 +37,7 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(unicode)]\n #![feature(vec_push_all)]\n@@ -50,8 +51,10 @@ extern crate graphviz;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n+extern crate rustc_data_structures;\n extern crate rustc_front;\n extern crate rustc_llvm as llvm;\n+extern crate rustc_mir;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate serialize;\n "}, {"sha": "3c53d5588656530c4b81b6dc01c8c5749fd99c52", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -303,7 +303,7 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }\n             Variant(disr_val, ref repr, _, _) => {\n-                adt::trans_case(bcx, &**repr, disr_val)\n+                SingleResult(Result::new(bcx, adt::trans_case(bcx, &**repr, disr_val)))\n             }\n             SliceLengthEqual(length, _) => {\n                 SingleResult(Result::new(bcx, C_uint(ccx, length)))"}, {"sha": "a4f66110450dfc6adb2dc6503e743febe70ac27b", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -945,23 +945,21 @@ fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n ///\n /// This should ideally be less tightly tied to `_match`.\n pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n-                              -> _match::OptResult<'blk, 'tcx> {\n+                              -> ValueRef {\n     match *r {\n         CEnum(ity, _, _) => {\n-            _match::SingleResult(Result::new(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n-                                                              discr as u64, true)))\n+            C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true)\n         }\n         General(ity, _, _) => {\n-            _match::SingleResult(Result::new(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n-                                                              discr as u64, true)))\n+            C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true)\n         }\n         Univariant(..) => {\n             bcx.ccx().sess().bug(\"no cases for univariants or structs\")\n         }\n         RawNullablePointer { .. } |\n         StructWrappedNullablePointer { .. } => {\n             assert!(discr == 0 || discr == 1);\n-            _match::SingleResult(Result::new(bcx, C_bool(bcx.ccx(), discr != 0)))\n+            C_bool(bcx.ccx(), discr != 0)\n         }\n     }\n }"}, {"sha": "a536060efbd0f43be93adc87f777326d832ad19f", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -44,6 +44,7 @@ use middle::pat_util::simple_name;\n use middle::subst::Substs;\n use middle::ty::{self, Ty, HasTypeFlags};\n use rustc::front::map as hir_map;\n+use rustc_mir::mir_map::MirMap;\n use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use trans::_match;\n@@ -74,6 +75,7 @@ use trans::intrinsic;\n use trans::machine;\n use trans::machine::{llsize_of, llsize_of_real};\n use trans::meth;\n+use trans::mir;\n use trans::monomorphize;\n use trans::tvec;\n use trans::type_::Type;\n@@ -497,13 +499,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                               &format!(\"enum-iter-variant-{}\",\n                                       &variant.disr_val.to_string())\n                               );\n-                      match adt::trans_case(cx, &*repr, variant.disr_val) {\n-                          _match::SingleResult(r) => {\n-                              AddCase(llswitch, r.val, variant_cx.llbb)\n-                          }\n-                          _ => ccx.sess().unimpl(\"value from adt::trans_case \\\n-                                                  in iter_structural_ty\")\n-                      }\n+                      let case_val = adt::trans_case(cx, &*repr, variant.disr_val);\n+                      AddCase(llswitch, case_val, variant_cx.llbb);\n                       let variant_cx =\n                           iter_variant(variant_cx,\n                                        &*repr,\n@@ -1235,7 +1232,10 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n         false\n     };\n \n+    let mir = ccx.mir_map().get(&id);\n+\n     let mut fcx = FunctionContext {\n+          mir: mir,\n           llfn: llfndecl,\n           llenv: None,\n           llretslotptr: Cell::new(None),\n@@ -1575,7 +1575,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                    llfndecl: ValueRef,\n                                    param_substs: &'tcx Substs<'tcx>,\n                                    fn_ast_id: ast::NodeId,\n-                                   _attributes: &[ast::Attribute],\n+                                   attributes: &[ast::Attribute],\n                                    output_type: ty::FnOutput<'tcx>,\n                                    abi: Abi,\n                                    closure_env: closure::ClosureEnv<'b>) {\n@@ -1604,6 +1604,12 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                       &arena);\n     let mut bcx = init_function(&fcx, false, output_type);\n \n+    if attributes.iter().any(|item| item.check_name(\"rustc_mir\")) {\n+        mir::trans_mir(bcx);\n+        fcx.cleanup();\n+        return;\n+    }\n+\n     // cleanup scope for the incoming arguments\n     let fn_cleanup_debug_loc =\n         debuginfo::get_cleanup_debug_loc_for_ast_node(ccx, fn_ast_id, body.span, true);\n@@ -2737,7 +2743,10 @@ pub fn filter_reachable_ids(ccx: &SharedCrateContext) -> NodeSet {\n     }).collect()\n }\n \n-pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslation {\n+pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                         mir_map: &MirMap<'tcx>,\n+                         analysis: ty::CrateAnalysis)\n+                         -> CrateTranslation {\n     let ty::CrateAnalysis { export_map, reachable, name, .. } = analysis;\n     let krate = tcx.map.krate();\n \n@@ -2779,6 +2788,7 @@ pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslat\n     let shared_ccx = SharedCrateContext::new(&link_meta.crate_name,\n                                              codegen_units,\n                                              tcx,\n+                                             &mir_map,\n                                              export_map,\n                                              Sha256::new(),\n                                              link_meta.clone(),"}, {"sha": "8d6ba53dd222d9b52c220887d5cb444524368137", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -16,7 +16,7 @@ pub use self::ExprOrMethodCall::*;\n \n use session::Session;\n use llvm;\n-use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef};\n+use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool};\n use middle::cfg;\n use middle::def;\n@@ -40,6 +40,7 @@ use middle::traits;\n use middle::ty::{self, HasTypeFlags, Ty};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use rustc_front::hir;\n+use rustc_mir::repr::Mir;\n use util::nodemap::{FnvHashMap, NodeMap};\n \n use arena::TypedArena;\n@@ -328,6 +329,11 @@ impl<'tcx> DropFlagHintsMap<'tcx> {\n // Function context.  Every LLVM function we create will have one of\n // these.\n pub struct FunctionContext<'a, 'tcx: 'a> {\n+    // The MIR for this function. At present, this is optional because\n+    // we only have MIR available for things that are local to the\n+    // crate.\n+    pub mir: Option<&'a Mir<'tcx>>,\n+\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n     // instructions for this function that will go in the .text\n@@ -407,6 +413,10 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n+    pub fn mir(&self) -> &'a Mir<'tcx> {\n+        self.mir.unwrap()\n+    }\n+\n     pub fn arg_offset(&self) -> usize {\n         self.env_arg_pos() + if self.llenv.is_some() { 1 } else { 0 }\n     }\n@@ -644,6 +654,10 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n     pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n \n+    pub fn mir(&self) -> &'blk Mir<'tcx> {\n+        self.fcx.mir()\n+    }\n+\n     pub fn name(&self, name: ast::Name) -> String {\n         name.to_string()\n     }\n@@ -729,6 +743,12 @@ pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     }\n }\n \n+pub fn C_floating_f64(f: f64, t: Type) -> ValueRef {\n+    unsafe {\n+        llvm::LLVMConstReal(t.to_ref(), f)\n+    }\n+}\n+\n pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n     C_struct(ccx, &[], false)\n }\n@@ -1132,3 +1152,65 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ccx.sess().bug(&format!(\"no variant for {:?}::{}\", adt_def, inlined_vid))\n     })\n }\n+\n+// To avoid UB from LLVM, these two functions mask RHS with an\n+// appropriate mask unconditionally (i.e. the fallback behavior for\n+// all shifts). For 32- and 64-bit types, this matches the semantics\n+// of Java. (See related discussion on #1877 and #10183.)\n+\n+pub fn build_unchecked_lshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          lhs: ValueRef,\n+                                          rhs: ValueRef,\n+                                          binop_debug_loc: DebugLoc) -> ValueRef {\n+    let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShl, lhs, rhs);\n+    // #1877, #10183: Ensure that input is always valid\n+    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n+    build::Shl(bcx, lhs, rhs, binop_debug_loc)\n+}\n+\n+pub fn build_unchecked_rshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          lhs_t: Ty<'tcx>,\n+                                          lhs: ValueRef,\n+                                          rhs: ValueRef,\n+                                          binop_debug_loc: DebugLoc) -> ValueRef {\n+    let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShr, lhs, rhs);\n+    // #1877, #10183: Ensure that input is always valid\n+    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n+    let is_signed = lhs_t.is_signed();\n+    if is_signed {\n+        build::AShr(bcx, lhs, rhs, binop_debug_loc)\n+    } else {\n+        build::LShr(bcx, lhs, rhs, binop_debug_loc)\n+    }\n+}\n+\n+fn shift_mask_rhs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              rhs: ValueRef,\n+                              debug_loc: DebugLoc) -> ValueRef {\n+    let rhs_llty = val_ty(rhs);\n+    build::And(bcx, rhs, shift_mask_val(bcx, rhs_llty, rhs_llty, false), debug_loc)\n+}\n+\n+pub fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              llty: Type,\n+                              mask_llty: Type,\n+                              invert: bool) -> ValueRef {\n+    let kind = llty.kind();\n+    match kind {\n+        TypeKind::Integer => {\n+            // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n+            let val = llty.int_width() - 1;\n+            if invert {\n+                C_integral(mask_llty, !val, true)\n+            } else {\n+                C_integral(mask_llty, val, false)\n+            }\n+        },\n+        TypeKind::Vector => {\n+            let mask = shift_mask_val(bcx, llty.element_type(), mask_llty.element_type(), invert);\n+            build::VectorSplat(bcx, mask_llty.vector_length(), mask)\n+        },\n+        _ => panic!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n+    }\n+}\n+"}, {"sha": "1f1d43feeb38e70f372cb74b627fab46466cf309", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -14,6 +14,7 @@ use metadata::common::LinkMeta;\n use middle::def::ExportMap;\n use middle::def_id::DefId;\n use middle::traits;\n+use rustc_mir::mir_map::MirMap;\n use trans::adt;\n use trans::base;\n use trans::builder::Builder;\n@@ -70,6 +71,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     stats: Stats,\n     check_overflow: bool,\n     check_drop_flag_for_sanity: bool,\n+    mir_map: &'a MirMap<'tcx>,\n \n     available_drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, String>>,\n     use_dll_storage_attrs: bool,\n@@ -251,6 +253,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn new(crate_name: &str,\n                local_count: usize,\n                tcx: &'b ty::ctxt<'tcx>,\n+               mir_map: &'b MirMap<'tcx>,\n                export_map: ExportMap,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n@@ -317,6 +320,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             link_meta: link_meta,\n             symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n+            mir_map: mir_map,\n             stats: Stats {\n                 n_glues_created: Cell::new(0),\n                 n_null_glues: Cell::new(0),\n@@ -803,6 +807,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn use_dll_storage_attrs(&self) -> bool {\n         self.shared.use_dll_storage_attrs()\n     }\n+\n+    pub fn mir_map(&self) -> &'b MirMap<'tcx> {\n+        self.shared.mir_map\n+    }\n }\n \n pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'tcx>);"}, {"sha": "7648587e35268458c1a92b90beb66a0ef42aeb56", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -2574,29 +2574,6 @@ impl OverflowOpViaInputCheck {\n     }\n }\n \n-fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              llty: Type,\n-                              mask_llty: Type,\n-                              invert: bool) -> ValueRef {\n-    let kind = llty.kind();\n-    match kind {\n-        TypeKind::Integer => {\n-            // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n-            let val = llty.int_width() - 1;\n-            if invert {\n-                C_integral(mask_llty, !val, true)\n-            } else {\n-                C_integral(mask_llty, val, false)\n-            }\n-        },\n-        TypeKind::Vector => {\n-            let mask = shift_mask_val(bcx, llty.element_type(), mask_llty.element_type(), invert);\n-            VectorSplat(bcx, mask_llty.vector_length(), mask)\n-        },\n-        _ => panic!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n-    }\n-}\n-\n // Check if an integer or vector contains a nonzero element.\n fn build_nonzero_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    value: ValueRef,\n@@ -2616,44 +2593,6 @@ fn build_nonzero_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-// To avoid UB from LLVM, these two functions mask RHS with an\n-// appropriate mask unconditionally (i.e. the fallback behavior for\n-// all shifts). For 32- and 64-bit types, this matches the semantics\n-// of Java. (See related discussion on #1877 and #10183.)\n-\n-fn build_unchecked_lshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                      lhs: ValueRef,\n-                                      rhs: ValueRef,\n-                                      binop_debug_loc: DebugLoc) -> ValueRef {\n-    let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShl, lhs, rhs);\n-    // #1877, #10183: Ensure that input is always valid\n-    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n-    Shl(bcx, lhs, rhs, binop_debug_loc)\n-}\n-\n-fn build_unchecked_rshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                      lhs_t: Ty<'tcx>,\n-                                      lhs: ValueRef,\n-                                      rhs: ValueRef,\n-                                      binop_debug_loc: DebugLoc) -> ValueRef {\n-    let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShr, lhs, rhs);\n-    // #1877, #10183: Ensure that input is always valid\n-    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n-    let is_signed = lhs_t.is_signed();\n-    if is_signed {\n-        AShr(bcx, lhs, rhs, binop_debug_loc)\n-    } else {\n-        LShr(bcx, lhs, rhs, binop_debug_loc)\n-    }\n-}\n-\n-fn shift_mask_rhs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              rhs: ValueRef,\n-                              debug_loc: DebugLoc) -> ValueRef {\n-    let rhs_llty = val_ty(rhs);\n-    And(bcx, rhs, shift_mask_val(bcx, rhs_llty, rhs_llty, false), debug_loc)\n-}\n-\n fn with_overflow_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, oop: OverflowOp, info: NodeIdAndSpan,\n                                    lhs_t: Ty<'tcx>, lhs: ValueRef,\n                                    rhs: ValueRef,"}, {"sha": "f5fa897bca63122c0b768a6b39819c408f12061e", "filename": "src/librustc_trans/trans/mir/analyze.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An analysis to determine which temporaries require allocas and\n+//! which do not.\n+\n+use rustc_data_structures::fnv::FnvHashSet;\n+use rustc_mir::repr as mir;\n+use rustc_mir::visit::{Visitor, LvalueContext};\n+use trans::common::{self, Block};\n+use super::rvalue;\n+\n+pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n+                               mir: &mir::Mir<'tcx>)\n+                               -> FnvHashSet<usize> {\n+    let mut analyzer = TempAnalyzer::new();\n+\n+    analyzer.visit_mir(mir);\n+\n+    for (index, temp_decl) in mir.temp_decls.iter().enumerate() {\n+        let ty = bcx.monomorphize(&temp_decl.ty);\n+        debug!(\"temp {:?} has type {:?}\", index, ty);\n+        if\n+            ty.is_scalar() ||\n+            ty.is_unique() ||\n+            (ty.is_region_ptr() && !common::type_is_fat_ptr(bcx.tcx(), ty)) ||\n+            ty.is_simd()\n+        {\n+            // These sorts of types are immediates that we can store\n+            // in an ValueRef without an alloca.\n+            assert!(common::type_is_immediate(bcx.ccx(), ty));\n+        } else {\n+            // These sorts of types require an alloca. Note that\n+            // type_is_immediate() may *still* be true, particularly\n+            // for newtypes, but we currently force some types\n+            // (e.g. structs) into an alloca unconditionally, just so\n+            // that we don't have to deal with having two pathways\n+            // (gep vs extractvalue etc).\n+            analyzer.mark_as_lvalue(index);\n+        }\n+    }\n+\n+    analyzer.lvalue_temps\n+}\n+\n+struct TempAnalyzer {\n+    lvalue_temps: FnvHashSet<usize>,\n+}\n+\n+impl TempAnalyzer {\n+    fn new() -> TempAnalyzer {\n+        TempAnalyzer { lvalue_temps: FnvHashSet() }\n+    }\n+\n+    fn mark_as_lvalue(&mut self, temp: usize) {\n+        debug!(\"marking temp {} as lvalue\", temp);\n+        self.lvalue_temps.insert(temp);\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for TempAnalyzer {\n+    fn visit_assign(&mut self,\n+                    block: mir::BasicBlock,\n+                    lvalue: &mir::Lvalue<'tcx>,\n+                    rvalue: &mir::Rvalue<'tcx>) {\n+        debug!(\"visit_assign(block={:?}, lvalue={:?}, rvalue={:?})\", block, lvalue, rvalue);\n+\n+        match *lvalue {\n+            mir::Lvalue::Temp(index) => {\n+                if !rvalue::rvalue_creates_operand(rvalue) {\n+                    self.mark_as_lvalue(index as usize);\n+                }\n+            }\n+            _ => {\n+                self.visit_lvalue(lvalue, LvalueContext::Store);\n+            }\n+        }\n+\n+        self.visit_rvalue(rvalue);\n+    }\n+\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &mir::Lvalue<'tcx>,\n+                    context: LvalueContext) {\n+        debug!(\"visit_lvalue(lvalue={:?}, context={:?})\", lvalue, context);\n+\n+        match *lvalue {\n+            mir::Lvalue::Temp(index) => {\n+                match context {\n+                    LvalueContext::Consume => {\n+                    }\n+                    LvalueContext::Store |\n+                    LvalueContext::Drop |\n+                    LvalueContext::Inspect |\n+                    LvalueContext::Borrow { .. } |\n+                    LvalueContext::Slice { .. } |\n+                    LvalueContext::Projection => {\n+                        self.mark_as_lvalue(index as usize);\n+                    }\n+                }\n+            }\n+            _ => {\n+            }\n+        }\n+\n+        self.super_lvalue(lvalue, context);\n+    }\n+}"}, {"sha": "c9f4123c17127aabc7a66132743e4d0a40a1b99d", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::BasicBlockRef;\n+use rustc_mir::repr as mir;\n+use trans::base;\n+use trans::build;\n+use trans::common::Block;\n+use trans::debuginfo::DebugLoc;\n+\n+use super::MirContext;\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n+        debug!(\"trans_block({:?})\", bb);\n+\n+        let mut bcx = self.bcx(bb);\n+        let data = self.mir.basic_block_data(bb);\n+\n+        for statement in &data.statements {\n+            bcx = self.trans_statement(bcx, statement);\n+        }\n+\n+        debug!(\"trans_block: terminator: {:?}\", data.terminator);\n+\n+        match data.terminator {\n+            mir::Terminator::Goto { target } => {\n+                build::Br(bcx, self.llblock(target), DebugLoc::None)\n+            }\n+\n+            mir::Terminator::Panic { .. } => {\n+                unimplemented!()\n+            }\n+\n+            mir::Terminator::If { ref cond, targets: [true_bb, false_bb] } => {\n+                let cond = self.trans_operand(bcx, cond);\n+                let lltrue = self.llblock(true_bb);\n+                let llfalse = self.llblock(false_bb);\n+                build::CondBr(bcx, cond.llval, lltrue, llfalse, DebugLoc::None);\n+            }\n+\n+            mir::Terminator::Switch { .. } => {\n+                unimplemented!()\n+            }\n+\n+            mir::Terminator::Diverge => {\n+                if let Some(llpersonalityslot) = self.llpersonalityslot {\n+                    let lp = build::Load(bcx, llpersonalityslot);\n+                    // FIXME(lifetime) base::call_lifetime_end(bcx, self.personality);\n+                    build::Resume(bcx, lp);\n+                } else {\n+                    // This fn never encountered anything fallible, so\n+                    // a Diverge cannot actually happen. Note that we\n+                    // do a total hack to ensure that we visit the\n+                    // DIVERGE block last.\n+                    build::Unreachable(bcx);\n+                }\n+            }\n+\n+            mir::Terminator::Return => {\n+                let return_ty = bcx.monomorphize(&self.mir.return_ty);\n+                base::build_return_block(bcx.fcx, bcx, return_ty, DebugLoc::None);\n+            }\n+\n+            mir::Terminator::Call { .. } => {\n+                unimplemented!()\n+                //let llbb = unimplemented!(); // self.make_landing_pad(panic_bb);\n+                //\n+                //let tr_dest = self.trans_lvalue(bcx, &data.destination);\n+                //\n+                //// Create the callee. This will always be a fn\n+                //// ptr and hence a kind of scalar.\n+                //let callee = self.trans_operand(bcx, &data.func);\n+                //\n+                //// Process the arguments.\n+                //\n+                //let args = unimplemented!();\n+                //\n+                //callee::trans_call_inner(bcx,\n+                //                         DebugLoc::None,\n+                //                         |bcx, _| Callee {\n+                //                             bcx: bcx,\n+                //                             data: CalleeData::Fn(callee.llval),\n+                //                             ty: callee.ty,\n+                //                         },\n+                //                         args,\n+                //                         Some(Dest::SaveIn(tr_dest.llval)));\n+            }\n+        }\n+    }\n+\n+    fn bcx(&self, bb: mir::BasicBlock) -> Block<'bcx, 'tcx> {\n+        self.blocks[bb.index()]\n+    }\n+\n+    fn llblock(&self, bb: mir::BasicBlock) -> BasicBlockRef {\n+        self.blocks[bb.index()].llbb\n+    }\n+}"}, {"sha": "1b61001834a997b7e2eeae6c99982e2dce679f24", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::ValueRef;\n+use rustc::middle::const_eval::ConstVal;\n+use rustc_mir::repr as mir;\n+use trans::consts::{self, TrueConst};\n+use trans::common::{self, Block};\n+use trans::type_of;\n+\n+use super::MirContext;\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_constant(&mut self,\n+                          bcx: Block<'bcx, 'tcx>,\n+                          constant: &mir::Constant<'tcx>)\n+                          -> ValueRef\n+    {\n+        let ccx = bcx.ccx();\n+        let constant_ty = bcx.monomorphize(&constant.ty);\n+        let llty = type_of::type_of(ccx, constant_ty);\n+        match constant.literal {\n+            mir::Literal::Item { .. } => {\n+                unimplemented!()\n+            }\n+            mir::Literal::Value { ref value } => {\n+                match *value {\n+                    ConstVal::Float(v) => common::C_floating_f64(v, llty),\n+                    ConstVal::Bool(v) => common::C_bool(ccx, v),\n+                    ConstVal::Int(v) => common::C_integral(llty, v as u64, true),\n+                    ConstVal::Uint(v) => common::C_integral(llty, v, false),\n+                    ConstVal::Str(ref v) => common::C_str_slice(ccx, v.clone()),\n+                    ConstVal::ByteStr(ref v) => consts::addr_of(ccx,\n+                                                                common::C_bytes(ccx, v),\n+                                                                1,\n+                                                                \"byte_str\"),\n+                    ConstVal::Struct(id) | ConstVal::Tuple(id) => {\n+                        let expr = bcx.tcx().map.expect_expr(id);\n+                        let (llval, _) = match consts::const_expr(ccx,\n+                                                                  expr,\n+                                                                  bcx.fcx.param_substs,\n+                                                                  None,\n+                                                                  TrueConst::Yes) {\n+                            Ok(v) => v,\n+                            Err(_) => panic!(\"constant eval failure\"),\n+                        };\n+                        llval\n+                    }\n+                    ConstVal::Function(_) => {\n+                        unimplemented!()\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "1ce7b55a9c686400d077d7eb44ecd88091212427", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -0,0 +1,154 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::ValueRef;\n+use rustc::middle::ty::Ty;\n+use rustc_mir::repr as mir;\n+use rustc_mir::tcx::LvalueTy;\n+use trans::adt;\n+use trans::base;\n+use trans::build;\n+use trans::common::{self, Block};\n+use trans::debuginfo::DebugLoc;\n+use trans::machine;\n+use trans::tvec;\n+\n+use super::{MirContext, TempRef};\n+\n+#[derive(Copy, Clone)]\n+pub struct LvalueRef<'tcx> {\n+    /// Pointer to the contents of the lvalue\n+    pub llval: ValueRef,\n+\n+    /// Monomorphized type of this lvalue, including variant information\n+    pub ty: LvalueTy<'tcx>,\n+}\n+\n+impl<'tcx> LvalueRef<'tcx> {\n+    pub fn new(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>) -> LvalueRef<'tcx> {\n+        LvalueRef { llval: llval, ty: lvalue_ty }\n+    }\n+\n+    pub fn alloca<'bcx>(bcx: Block<'bcx, 'tcx>,\n+                        ty: Ty<'tcx>,\n+                        name: &str)\n+                        -> LvalueRef<'tcx>\n+    {\n+        let lltemp = base::alloc_ty(bcx, ty, name);\n+        LvalueRef::new(lltemp, LvalueTy::from_ty(ty))\n+    }\n+}\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_lvalue(&mut self,\n+                        bcx: Block<'bcx, 'tcx>,\n+                        lvalue: &mir::Lvalue<'tcx>)\n+                        -> LvalueRef<'tcx> {\n+        debug!(\"trans_lvalue(lvalue={:?})\", lvalue);\n+\n+        let fcx = bcx.fcx;\n+        let ccx = fcx.ccx;\n+        let tcx = bcx.tcx();\n+        match *lvalue {\n+            mir::Lvalue::Var(index) => self.vars[index as usize],\n+            mir::Lvalue::Temp(index) => match self.temps[index as usize] {\n+                TempRef::Lvalue(lvalue) =>\n+                    lvalue,\n+                TempRef::Operand(..) =>\n+                    tcx.sess.bug(&format!(\"using operand temp {:?} as lvalue\", lvalue)),\n+            },\n+            mir::Lvalue::Arg(index) => self.args[index as usize],\n+            mir::Lvalue::Static(_def_id) => unimplemented!(),\n+            mir::Lvalue::ReturnPointer => {\n+                let return_ty = bcx.monomorphize(&self.mir.return_ty);\n+                let llval = fcx.get_ret_slot(bcx, return_ty, \"return\");\n+                LvalueRef::new(llval, LvalueTy::from_ty(return_ty.unwrap()))\n+            }\n+            mir::Lvalue::Projection(ref projection) => {\n+                let tr_base = self.trans_lvalue(bcx, &projection.base);\n+                let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n+                let llprojected = match projection.elem {\n+                    mir::ProjectionElem::Deref => {\n+                        let base_ty = tr_base.ty.to_ty(tcx);\n+                        base::load_ty(bcx, tr_base.llval, base_ty)\n+                    }\n+                    mir::ProjectionElem::Field(ref field) => {\n+                        let base_ty = tr_base.ty.to_ty(tcx);\n+                        let base_repr = adt::represent_type(ccx, base_ty);\n+                        let discr = match tr_base.ty {\n+                            LvalueTy::Ty { .. } => 0,\n+                            LvalueTy::Downcast { adt_def: _, substs: _, variant_index: v } => v,\n+                        };\n+                        let discr = discr as u64;\n+                        adt::trans_field_ptr(bcx, &base_repr, tr_base.llval, discr, field.index())\n+                    }\n+                    mir::ProjectionElem::Index(ref index) => {\n+                        let base_ty = tr_base.ty.to_ty(tcx);\n+                        let index = self.trans_operand(bcx, index);\n+                        let llindex = self.prepare_index(bcx, index.llval);\n+                        let (llbase, _) = tvec::get_base_and_len(bcx, tr_base.llval, base_ty);\n+                        build::InBoundsGEP(bcx, llbase, &[llindex])\n+                    }\n+                    mir::ProjectionElem::ConstantIndex { offset,\n+                                                         from_end: false,\n+                                                         min_length: _ } => {\n+                        let base_ty = tr_base.ty.to_ty(tcx);\n+                        let lloffset = common::C_u32(bcx.ccx(), offset);\n+                        let llindex = self.prepare_index(bcx, lloffset);\n+                        let (llbase, _) = tvec::get_base_and_len(bcx,\n+                                                                 tr_base.llval,\n+                                                                 base_ty);\n+                        build::InBoundsGEP(bcx, llbase, &[llindex])\n+                    }\n+                    mir::ProjectionElem::ConstantIndex { offset,\n+                                                         from_end: true,\n+                                                         min_length: _ } => {\n+                        let lloffset = common::C_u32(bcx.ccx(), offset);\n+                        let base_ty = tr_base.ty.to_ty(tcx);\n+                        let (llbase, lllen) = tvec::get_base_and_len(bcx,\n+                                                                     tr_base.llval,\n+                                                                     base_ty);\n+                        let llindex = build::Sub(bcx, lllen, lloffset, DebugLoc::None);\n+                        let llindex = self.prepare_index(bcx, llindex);\n+                        build::InBoundsGEP(bcx, llbase, &[llindex])\n+                    }\n+                    mir::ProjectionElem::Downcast(..) => {\n+                        tr_base.llval\n+                    }\n+                };\n+                LvalueRef {\n+                    llval: llprojected,\n+                    ty: projected_ty,\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Adjust the bitwidth of an index since LLVM is less forgiving\n+    /// than we are.\n+    ///\n+    /// nmatsakis: is this still necessary? Not sure.\n+    fn prepare_index(&mut self,\n+                     bcx: Block<'bcx, 'tcx>,\n+                     llindex: ValueRef)\n+                     -> ValueRef\n+    {\n+        let ccx = bcx.ccx();\n+        let index_size = machine::llbitsize_of_real(bcx.ccx(), common::val_ty(llindex));\n+        let int_size = machine::llbitsize_of_real(bcx.ccx(), ccx.int_type());\n+        if index_size < int_size {\n+            build::ZExt(bcx, llindex, ccx.int_type())\n+        } else if index_size > int_size {\n+            build::Trunc(bcx, llindex, ccx.int_type())\n+        } else {\n+            llindex\n+        }\n+    }\n+}"}, {"sha": "3b018cc132184b54ccac287a770c65a5e402d533", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::c_uint;\n+use llvm::{self, ValueRef};\n+use rustc_mir::repr as mir;\n+use rustc_mir::tcx::LvalueTy;\n+use trans::base;\n+use trans::build;\n+use trans::common::{self, Block};\n+use trans::debuginfo::DebugLoc;\n+use trans::expr;\n+use trans::type_of;\n+\n+use self::lvalue::LvalueRef;\n+use self::operand::OperandRef;\n+\n+// FIXME DebugLoc is always None right now\n+\n+/// Master context for translating MIR.\n+pub struct MirContext<'bcx, 'tcx:'bcx> {\n+    mir: &'bcx mir::Mir<'tcx>,\n+\n+    /// When unwinding is initiated, we have to store this personality\n+    /// value somewhere so that we can load it and re-use it in the\n+    /// resume instruction. The personality is (afaik) some kind of\n+    /// value used for C++ unwinding, which must filter by type: we\n+    /// don't really care about it very much. Anyway, this value\n+    /// contains an alloca into which the personality is stored and\n+    /// then later loaded when generating the DIVERGE_BLOCK.\n+    llpersonalityslot: Option<ValueRef>,\n+\n+    /// A `Block` for each MIR `BasicBlock`\n+    blocks: Vec<Block<'bcx, 'tcx>>,\n+\n+    /// An LLVM alloca for each MIR `VarDecl`\n+    vars: Vec<LvalueRef<'tcx>>,\n+\n+    /// The location where each MIR `TempDecl` is stored. This is\n+    /// usually an `LvalueRef` representing an alloca, but not always:\n+    /// sometimes we can skip the alloca and just store the value\n+    /// directly using an `OperandRef`, which makes for tighter LLVM\n+    /// IR. The conditions for using an `OperandRef` are as follows:\n+    ///\n+    /// - the type of the temporary must be judged \"immediate\" by `type_is_immediate`\n+    /// - the operand must never be referenced indirectly\n+    ///     - we should not take its address using the `&` operator\n+    ///     - nor should it appear in an lvalue path like `tmp.a`\n+    /// - the operand must be defined by an rvalue that can generate immediate\n+    ///   values\n+    ///\n+    /// Avoiding allocs can also be important for certain intrinsics,\n+    /// notably `expect`.\n+    temps: Vec<TempRef<'tcx>>,\n+\n+    /// The arguments to the function; as args are lvalues, these are\n+    /// always indirect, though we try to avoid creating an alloca\n+    /// when we can (and just reuse the pointer the caller provided).\n+    args: Vec<LvalueRef<'tcx>>,\n+}\n+\n+enum TempRef<'tcx> {\n+    Lvalue(LvalueRef<'tcx>),\n+    Operand(Option<OperandRef<'tcx>>),\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub fn trans_mir<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>) {\n+    let fcx = bcx.fcx;\n+    let mir = bcx.mir();\n+\n+    let mir_blocks = bcx.mir().all_basic_blocks();\n+\n+    // Analyze the temps to determine which must be lvalues\n+    // FIXME\n+    let lvalue_temps = analyze::lvalue_temps(bcx, mir);\n+\n+    // Allocate variable and temp allocas\n+    let vars = mir.var_decls.iter()\n+                            .map(|decl| (bcx.monomorphize(&decl.ty), decl.name))\n+                            .map(|(mty, name)| LvalueRef::alloca(bcx, mty, &name.as_str()))\n+                            .collect();\n+    let temps = mir.temp_decls.iter()\n+                              .map(|decl| bcx.monomorphize(&decl.ty))\n+                              .enumerate()\n+                              .map(|(i, mty)| if lvalue_temps.contains(&i) {\n+                                  TempRef::Lvalue(LvalueRef::alloca(bcx,\n+                                                                    mty,\n+                                                                    &format!(\"temp{:?}\", i)))\n+                              } else {\n+                                  // If this is an immediate temp, we do not create an\n+                                  // alloca in advance. Instead we wait until we see the\n+                                  // definition and update the operand there.\n+                                  TempRef::Operand(None)\n+                              })\n+                              .collect();\n+    let args = arg_value_refs(bcx, mir);\n+\n+    // Allocate a `Block` for every basic block\n+    let block_bcxs: Vec<Block<'bcx,'tcx>> =\n+        mir_blocks.iter()\n+                  .map(|&bb| fcx.new_block(false, &format!(\"{:?}\", bb), None))\n+                  .collect();\n+\n+    // Branch to the START block\n+    let start_bcx = block_bcxs[mir::START_BLOCK.index()];\n+    build::Br(bcx, start_bcx.llbb, DebugLoc::None);\n+\n+    let mut mircx = MirContext {\n+        mir: mir,\n+        llpersonalityslot: None,\n+        blocks: block_bcxs,\n+        vars: vars,\n+        temps: temps,\n+        args: args,\n+    };\n+\n+    // Translate the body of each block\n+    for &bb in &mir_blocks {\n+        if bb != mir::DIVERGE_BLOCK {\n+            mircx.trans_block(bb);\n+        }\n+    }\n+\n+    // Total hack: translate DIVERGE_BLOCK last. This is so that any\n+    // panics which the fn may do can initialize the\n+    // `llpersonalityslot` cell. We don't do this up front because the\n+    // LLVM type of it is (frankly) annoying to compute.\n+    mircx.trans_block(mir::DIVERGE_BLOCK);\n+}\n+\n+/// Produce, for each argument, a `ValueRef` pointing at the\n+/// argument's value. As arguments are lvalues, these are always\n+/// indirect.\n+fn arg_value_refs<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>,\n+                              mir: &mir::Mir<'tcx>)\n+                              -> Vec<LvalueRef<'tcx>> {\n+    // FIXME tupled_args? I think I'd rather that mapping is done in MIR land though\n+    let fcx = bcx.fcx;\n+    let tcx = bcx.tcx();\n+    let mut idx = fcx.arg_offset() as c_uint;\n+    mir.arg_decls\n+       .iter()\n+       .enumerate()\n+       .map(|(arg_index, arg_decl)| {\n+           let arg_ty = bcx.monomorphize(&arg_decl.ty);\n+           let llval = if type_of::arg_is_indirect(bcx.ccx(), arg_ty) {\n+               // Don't copy an indirect argument to an alloca, the caller\n+               // already put it in a temporary alloca and gave it up, unless\n+               // we emit extra-debug-info, which requires local allocas :(.\n+               // FIXME: lifetimes, debug info\n+               let llarg = llvm::get_param(fcx.llfn, idx);\n+               idx += 1;\n+               llarg\n+           } else if common::type_is_fat_ptr(tcx, arg_ty) {\n+               // we pass fat pointers as two words, but we want to\n+               // represent them internally as a pointer to two words,\n+               // so make an alloca to store them in.\n+               let lldata = llvm::get_param(fcx.llfn, idx);\n+               let llextra = llvm::get_param(fcx.llfn, idx + 1);\n+               idx += 2;\n+               let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+               build::Store(bcx, lldata, expr::get_dataptr(bcx, lltemp));\n+               build::Store(bcx, llextra, expr::get_dataptr(bcx, lltemp));\n+               lltemp\n+           } else {\n+               // otherwise, arg is passed by value, so make a\n+               // temporary and store it there\n+               let llarg = llvm::get_param(fcx.llfn, idx);\n+               idx += 1;\n+               let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+               build::Store(bcx, llarg, lltemp);\n+               lltemp\n+           };\n+           LvalueRef::new(llval, LvalueTy::from_ty(arg_ty))\n+       })\n+       .collect()\n+}\n+\n+mod analyze;\n+mod block;\n+mod constant;\n+mod lvalue;\n+mod rvalue;\n+mod operand;\n+mod statement;\n+"}, {"sha": "a0308032ac07bb4e1e4a0438af3769bafaf4e394", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::ValueRef;\n+use rustc::middle::ty::Ty;\n+use rustc_mir::repr as mir;\n+use trans::base;\n+use trans::build;\n+use trans::common::Block;\n+use trans::datum;\n+\n+use super::{MirContext, TempRef};\n+\n+#[derive(Copy, Clone)]\n+pub struct OperandRef<'tcx> {\n+    // This will be \"indirect\" if `appropriate_rvalue_mode` returns\n+    // ByRef, and otherwise ByValue.\n+    pub llval: ValueRef,\n+\n+    // The type of value being returned.\n+    pub ty: Ty<'tcx>\n+}\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_operand(&mut self,\n+                         bcx: Block<'bcx, 'tcx>,\n+                         operand: &mir::Operand<'tcx>)\n+                         -> OperandRef<'tcx>\n+    {\n+        debug!(\"trans_operand(operand={:?})\", operand);\n+\n+        match *operand {\n+            mir::Operand::Consume(ref lvalue) => {\n+                // watch out for temporaries that do not have an\n+                // alloca; they are handled somewhat differently\n+                if let &mir::Lvalue::Temp(index) = lvalue {\n+                    match self.temps[index as usize] {\n+                        TempRef::Operand(Some(o)) => {\n+                            return o;\n+                        }\n+                        TempRef::Operand(None) => {\n+                            bcx.tcx().sess.bug(\n+                                &format!(\"use of {:?} before def\", lvalue));\n+                        }\n+                        TempRef::Lvalue(..) => {\n+                            // use path below\n+                        }\n+                    }\n+                }\n+\n+                // for most lvalues, to consume them we just load them\n+                // out from their home\n+                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+                debug!(\"trans_operand: tr_lvalue={} @ {:?}\",\n+                       bcx.val_to_string(tr_lvalue.llval),\n+                       ty);\n+                let llval = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n+                    datum::ByValue => build::Load(bcx, tr_lvalue.llval),\n+                    datum::ByRef => tr_lvalue.llval,\n+                };\n+                OperandRef {\n+                    llval: llval,\n+                    ty: ty\n+                }\n+            }\n+\n+            mir::Operand::Constant(ref constant) => {\n+                let llval = self.trans_constant(bcx, constant);\n+                let ty = bcx.monomorphize(&constant.ty);\n+                OperandRef {\n+                    llval: llval,\n+                    ty: ty,\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn trans_operand_into(&mut self,\n+                              bcx: Block<'bcx, 'tcx>,\n+                              lldest: ValueRef,\n+                              operand: &mir::Operand<'tcx>)\n+    {\n+        debug!(\"trans_operand_into(lldest={}, operand={:?})\",\n+               bcx.val_to_string(lldest),\n+               operand);\n+\n+        match *operand {\n+            mir::Operand::Consume(ref lvalue) => {\n+                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+                let lvalue_ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+                debug!(\"trans_operand_into: tr_lvalue={} @ {:?}\",\n+                       bcx.val_to_string(tr_lvalue.llval),\n+                       lvalue_ty);\n+                base::memcpy_ty(bcx, lldest, tr_lvalue.llval, lvalue_ty);\n+            }\n+\n+            mir::Operand::Constant(..) => {\n+                unimplemented!()\n+            }\n+        }\n+    }\n+}"}, {"sha": "ad89ee79de40fe40611381671f956a164b0a741d", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -0,0 +1,307 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::ValueRef;\n+use rustc::middle::ty::Ty;\n+use rustc_front::hir;\n+use rustc_mir::repr as mir;\n+\n+use trans::asm;\n+use trans::base;\n+use trans::build;\n+use trans::common::{self, Block, Result};\n+use trans::debuginfo::DebugLoc;\n+use trans::declare;\n+use trans::expr;\n+use trans::machine;\n+use trans::type_::Type;\n+use trans::type_of;\n+use trans::tvec;\n+\n+use super::MirContext;\n+use super::operand::OperandRef;\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_rvalue(&mut self,\n+                        bcx: Block<'bcx, 'tcx>,\n+                        lldest: ValueRef,\n+                        rvalue: &mir::Rvalue<'tcx>)\n+                        -> Block<'bcx, 'tcx>\n+    {\n+        debug!(\"trans_rvalue(lldest={}, rvalue={:?})\",\n+               bcx.val_to_string(lldest),\n+               rvalue);\n+\n+        match *rvalue {\n+            mir::Rvalue::Use(ref operand) => {\n+                self.trans_operand_into(bcx, lldest, operand);\n+                bcx\n+            }\n+\n+            mir::Rvalue::Cast(..) => {\n+                unimplemented!()\n+            }\n+\n+            mir::Rvalue::Repeat(..) => {\n+                unimplemented!()\n+            }\n+\n+            mir::Rvalue::Aggregate(_, ref operands) => {\n+                for (i, operand) in operands.iter().enumerate() {\n+                    // Note: perhaps this should be StructGep, but\n+                    // note that in some cases the values here will\n+                    // not be structs but arrays.\n+                    let lldest_i = build::GEPi(bcx, lldest, &[0, i]);\n+                    self.trans_operand_into(bcx, lldest_i, operand);\n+                }\n+                bcx\n+            }\n+\n+            mir::Rvalue::Slice { ref input, from_start, from_end } => {\n+                let ccx = bcx.ccx();\n+                let input = self.trans_lvalue(bcx, input);\n+                let (llbase, lllen) = tvec::get_base_and_len(bcx,\n+                                                             input.llval,\n+                                                             input.ty.to_ty(bcx.tcx()));\n+                let llbase1 = build::GEPi(bcx, llbase, &[from_start]);\n+                let adj = common::C_uint(ccx, from_start + from_end);\n+                let lllen1 = build::Sub(bcx, lllen, adj, DebugLoc::None);\n+                let lladdrdest = expr::get_dataptr(bcx, lldest);\n+                build::Store(bcx, llbase1, lladdrdest);\n+                let llmetadest = expr::get_meta(bcx, lldest);\n+                build::Store(bcx, lllen1, llmetadest);\n+                bcx\n+            }\n+\n+            mir::Rvalue::InlineAsm(inline_asm) => {\n+                asm::trans_inline_asm(bcx, inline_asm)\n+            }\n+\n+            _ => {\n+                assert!(rvalue_creates_operand(rvalue));\n+                let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n+                build::Store(bcx, temp.llval, lldest);\n+                bcx\n+            }\n+        }\n+    }\n+\n+    pub fn trans_rvalue_operand(&mut self,\n+                                bcx: Block<'bcx, 'tcx>,\n+                                rvalue: &mir::Rvalue<'tcx>)\n+                                -> (Block<'bcx, 'tcx>, OperandRef<'tcx>)\n+    {\n+        assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n+\n+        match *rvalue {\n+            mir::Rvalue::Use(ref operand) => {\n+                let operand = self.trans_operand(bcx, operand);\n+                (bcx, operand)\n+            }\n+\n+            mir::Rvalue::Cast(..) => {\n+                unimplemented!()\n+            }\n+\n+            mir::Rvalue::Ref(_, _, ref lvalue) => {\n+                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+\n+                // Note: lvalues are indirect, so storing the `llval` into the\n+                // destination effectively creates a reference.\n+                (bcx, OperandRef {\n+                    llval: tr_lvalue.llval,\n+                    ty: tr_lvalue.ty.to_ty(bcx.tcx()),\n+                })\n+            }\n+\n+            mir::Rvalue::Len(ref lvalue) => {\n+                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+                let (_, lllen) = tvec::get_base_and_len(bcx,\n+                                                        tr_lvalue.llval,\n+                                                        tr_lvalue.ty.to_ty(bcx.tcx()));\n+                (bcx, OperandRef {\n+                    llval: lllen,\n+                    ty: bcx.tcx().types.usize,\n+                })\n+            }\n+\n+            mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs = self.trans_operand(bcx, lhs);\n+                let rhs = self.trans_operand(bcx, rhs);\n+                let is_float = lhs.ty.is_fp();\n+                let is_signed = lhs.ty.is_signed();\n+                let binop_debug_loc = DebugLoc::None;\n+                let llval = match op {\n+                    mir::BinOp::Add => if is_float {\n+                        build::FAdd(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    } else {\n+                        build::Add(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    },\n+                    mir::BinOp::Sub => if is_float {\n+                        build::FSub(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    } else {\n+                        build::Sub(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    },\n+                    mir::BinOp::Mul => if is_float {\n+                        build::FMul(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    } else {\n+                        build::Mul(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    },\n+                    mir::BinOp::Div => if is_float {\n+                        build::FDiv(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    } else if is_signed {\n+                        build::SDiv(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    } else {\n+                        build::UDiv(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    },\n+                    mir::BinOp::Rem => if is_float {\n+                        // LLVM currently always lowers the `frem` instructions appropriate\n+                        // library calls typically found in libm. Notably f64 gets wired up\n+                        // to `fmod` and f32 gets wired up to `fmodf`. Inconveniently for\n+                        // us, 32-bit MSVC does not actually have a `fmodf` symbol, it's\n+                        // instead just an inline function in a header that goes up to a\n+                        // f64, uses `fmod`, and then comes back down to a f32.\n+                        //\n+                        // Although LLVM knows that `fmodf` doesn't exist on MSVC, it will\n+                        // still unconditionally lower frem instructions over 32-bit floats\n+                        // to a call to `fmodf`. To work around this we special case MSVC\n+                        // 32-bit float rem instructions and instead do the call out to\n+                        // `fmod` ourselves.\n+                        //\n+                        // Note that this is currently duplicated with src/libcore/ops.rs\n+                        // which does the same thing, and it would be nice to perhaps unify\n+                        // these two implementations one day! Also note that we call `fmod`\n+                        // for both 32 and 64-bit floats because if we emit any FRem\n+                        // instruction at all then LLVM is capable of optimizing it into a\n+                        // 32-bit FRem (which we're trying to avoid).\n+                        let tcx = bcx.tcx();\n+                        let use_fmod = tcx.sess.target.target.options.is_like_msvc &&\n+                            tcx.sess.target.target.arch == \"x86\";\n+                        if use_fmod {\n+                            let f64t = Type::f64(bcx.ccx());\n+                            let fty = Type::func(&[f64t, f64t], &f64t);\n+                            let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty,\n+                                                            tcx.types.f64);\n+                            if lhs.ty == tcx.types.f32 {\n+                                let lllhs = build::FPExt(bcx, lhs.llval, f64t);\n+                                let llrhs = build::FPExt(bcx, rhs.llval, f64t);\n+                                let llres = build::Call(bcx, llfn, &[lllhs, llrhs],\n+                                                        None, binop_debug_loc);\n+                                build::FPTrunc(bcx, llres, Type::f32(bcx.ccx()))\n+                            } else {\n+                                build::Call(bcx, llfn, &[lhs.llval, rhs.llval],\n+                                            None, binop_debug_loc)\n+                            }\n+                        } else {\n+                            build::FRem(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                        }\n+                    } else if is_signed {\n+                        build::SRem(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    } else {\n+                        build::URem(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    },\n+                    mir::BinOp::BitOr => build::Or(bcx, lhs.llval, rhs.llval, binop_debug_loc),\n+                    mir::BinOp::BitAnd => build::And(bcx, lhs.llval, rhs.llval, binop_debug_loc),\n+                    mir::BinOp::BitXor => build::Xor(bcx, lhs.llval, rhs.llval, binop_debug_loc),\n+                    mir::BinOp::Shl => common::build_unchecked_lshift(bcx,\n+                                                                      lhs.llval,\n+                                                                      rhs.llval,\n+                                                                      binop_debug_loc),\n+                    mir::BinOp::Shr => common::build_unchecked_rshift(bcx,\n+                                                                      lhs.ty,\n+                                                                      lhs.llval,\n+                                                                      rhs.llval,\n+                                                                      binop_debug_loc),\n+                    mir::BinOp::Eq => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n+                                                                 hir::BiEq, binop_debug_loc),\n+                    mir::BinOp::Lt => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n+                                                                 hir::BiLt, binop_debug_loc),\n+                    mir::BinOp::Le => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n+                                                                 hir::BiLe, binop_debug_loc),\n+                    mir::BinOp::Ne => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n+                                                                 hir::BiNe, binop_debug_loc),\n+                    mir::BinOp::Ge => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n+                                                                 hir::BiGe, binop_debug_loc),\n+                    mir::BinOp::Gt => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n+                                                                 hir::BiGt, binop_debug_loc),\n+                };\n+                (bcx, OperandRef {\n+                    llval: llval,\n+                    ty: lhs.ty,\n+                })\n+            }\n+\n+            mir::Rvalue::UnaryOp(op, ref operand) => {\n+                let operand = self.trans_operand(bcx, operand);\n+                let is_float = operand.ty.is_fp();\n+                let debug_loc = DebugLoc::None;\n+                let llval = match op {\n+                    mir::UnOp::Not => build::Not(bcx, operand.llval, debug_loc),\n+                    mir::UnOp::Neg => if is_float {\n+                        build::FNeg(bcx, operand.llval, debug_loc)\n+                    } else {\n+                        build::Neg(bcx, operand.llval, debug_loc)\n+                    }\n+                };\n+                (bcx, OperandRef {\n+                    llval: llval,\n+                    ty: operand.ty,\n+                })\n+            }\n+\n+            mir::Rvalue::Box(content_ty) => {\n+                let content_ty: Ty<'tcx> = bcx.monomorphize(&content_ty);\n+                let llty = type_of::type_of(bcx.ccx(), content_ty);\n+                let llsize = machine::llsize_of(bcx.ccx(), llty);\n+                let align = type_of::align_of(bcx.ccx(), content_ty);\n+                let llalign = common::C_uint(bcx.ccx(), align);\n+                let llty_ptr = llty.ptr_to();\n+                let box_ty = bcx.tcx().mk_box(content_ty);\n+                let Result { bcx, val: llval } = base::malloc_raw_dyn(bcx,\n+                                                                      llty_ptr,\n+                                                                      box_ty,\n+                                                                      llsize,\n+                                                                      llalign,\n+                                                                      DebugLoc::None);\n+                (bcx, OperandRef {\n+                    llval: llval,\n+                    ty: box_ty,\n+                })\n+            }\n+\n+            mir::Rvalue::Repeat(..) |\n+            mir::Rvalue::Aggregate(..) |\n+            mir::Rvalue::Slice { .. } |\n+            mir::Rvalue::InlineAsm(..) => {\n+                bcx.tcx().sess.bug(&format!(\"cannot generate operand from rvalue {:?}\", rvalue));\n+            }\n+        }\n+    }\n+}\n+\n+pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n+    match *rvalue {\n+        mir::Rvalue::Use(..) | // (*)\n+        mir::Rvalue::Ref(..) |\n+        mir::Rvalue::Len(..) |\n+        mir::Rvalue::Cast(..) | // (*)\n+        mir::Rvalue::BinaryOp(..) |\n+        mir::Rvalue::UnaryOp(..) |\n+        mir::Rvalue::Box(..) =>\n+            true,\n+        mir::Rvalue::Repeat(..) |\n+        mir::Rvalue::Aggregate(..) |\n+        mir::Rvalue::Slice { .. } |\n+        mir::Rvalue::InlineAsm(..) =>\n+            false,\n+    }\n+\n+    // (*) this is only true if the type is suitable\n+}"}, {"sha": "95ff049836eb43ed9de900b734f39eb35fda8e87", "filename": "src/librustc_trans/trans/mir/statement.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::middle::ty::LvaluePreference;\n+use rustc_mir::repr as mir;\n+use trans::common::Block;\n+use trans::debuginfo::DebugLoc;\n+use trans::glue;\n+\n+use super::MirContext;\n+use super::TempRef;\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_statement(&mut self,\n+                           bcx: Block<'bcx, 'tcx>,\n+                           statement: &mir::Statement<'tcx>)\n+                           -> Block<'bcx, 'tcx> {\n+        debug!(\"trans_statement(statement={:?})\", statement);\n+\n+        match statement.kind {\n+            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                match *lvalue {\n+                    mir::Lvalue::Temp(index) => {\n+                        let index = index as usize;\n+                        match self.temps[index as usize] {\n+                            TempRef::Lvalue(tr_dest) => {\n+                                self.trans_rvalue(bcx, tr_dest.llval, rvalue)\n+                            }\n+                            TempRef::Operand(None) => {\n+                                let (bcx, operand) = self.trans_rvalue_operand(bcx, rvalue);\n+                                self.temps[index] = TempRef::Operand(Some(operand));\n+                                bcx\n+                            }\n+                            TempRef::Operand(Some(_)) => {\n+                                bcx.tcx().sess.span_bug(\n+                                    statement.span,\n+                                    &format!(\"operand {:?} already assigned\", rvalue));\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        let tr_dest = self.trans_lvalue(bcx, lvalue);\n+                        self.trans_rvalue(bcx, tr_dest.llval, rvalue)\n+                    }\n+                }\n+            }\n+\n+            mir::StatementKind::Drop(mir::DropKind::Deep, ref lvalue) => {\n+                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+                glue::drop_ty(bcx, tr_lvalue.llval, ty, DebugLoc::None)\n+            }\n+\n+            mir::StatementKind::Drop(mir::DropKind::Free, ref lvalue) => {\n+                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+                let content_ty = ty.builtin_deref(true, LvaluePreference::NoPreference);\n+                let content_ty = content_ty.unwrap().ty;\n+                glue::trans_exchange_free_ty(bcx, tr_lvalue.llval, content_ty, DebugLoc::None)\n+            }\n+        }\n+    }\n+}"}, {"sha": "fa37b00553982f5534d701ae2bc37c9d6665259d", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -52,6 +52,7 @@ mod llrepr;\n mod machine;\n mod _match;\n mod meth;\n+mod mir;\n mod monomorphize;\n mod tvec;\n mod type_;"}, {"sha": "dc2b2b75ab6d15f166d12e81efcc46357152e481", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -164,11 +164,6 @@ pub struct Inherited<'a, 'tcx: 'a> {\n \n     tables: &'a RefCell<ty::Tables<'tcx>>,\n \n-    // A mapping from each fn's id to its signature, with all bound\n-    // regions replaced with free ones. Unlike the other tables, this\n-    // one is never copied into the tcx: it is only used by regionck.\n-    fn_sig_map: RefCell<NodeMap<Vec<Ty<'tcx>>>>,\n-\n     // When we process a call like `c()` where `c` is a closure type,\n     // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n     // `FnOnce` closure. In that case, we defer full resolution of the\n@@ -314,7 +309,6 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env), true),\n             locals: RefCell::new(NodeMap()),\n             tables: tables,\n-            fn_sig_map: RefCell::new(NodeMap()),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n         }\n@@ -620,22 +614,13 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         ccx: ccx\n     };\n \n-    // Remember return type so that regionck can access it later.\n-    let mut fn_sig_tys: Vec<Ty> =\n-        arg_tys.iter()\n-        .cloned()\n-        .collect();\n-\n     if let ty::FnConverging(ret_ty) = ret_ty {\n         fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::ReturnType);\n-        fn_sig_tys.push(ret_ty); // FIXME(#25759) just take implied bounds from the arguments\n     }\n \n-    debug!(\"fn-sig-map: fn_id={} fn_sig_tys={:?}\",\n-           fn_id,\n-           fn_sig_tys);\n+    debug!(\"fn-sig-map: fn_id={} fn_sig={:?}\", fn_id, fn_sig);\n \n-    inherited.fn_sig_map.borrow_mut().insert(fn_id, fn_sig_tys);\n+    inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig.clone());\n \n     {\n         let mut visit = GatherLocalsVisitor { fcx: &fcx, };"}, {"sha": "3cdc9b559446eee1003ebe4644eb1ff2ada5ce53", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -284,19 +284,32 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         // When we enter a function, we can derive\n         debug!(\"visit_fn_body(id={})\", id);\n \n-        let fn_sig_map = self.fcx.inh.fn_sig_map.borrow();\n-        let fn_sig = match fn_sig_map.get(&id) {\n-            Some(f) => f,\n-            None => {\n-                self.tcx().sess.bug(\n-                    &format!(\"No fn-sig entry for id={}\", id));\n+        let fn_sig = {\n+            let fn_sig_map = &self.infcx().tables.borrow().liberated_fn_sigs;\n+            match fn_sig_map.get(&id) {\n+                Some(f) => f.clone(),\n+                None => {\n+                    self.tcx().sess.bug(\n+                        &format!(\"No fn-sig entry for id={}\", id));\n+                }\n             }\n         };\n \n         let old_region_bounds_pairs_len = self.region_bound_pairs.len();\n \n+        // Collect the types from which we create inferred bounds.\n+        // For the return type, if diverging, substitute `bool` just\n+        // because it will have no effect.\n+        //\n+        // FIXME(#25759) return types should not be implied bounds\n+        let fn_sig_tys: Vec<_> =\n+            fn_sig.inputs.iter()\n+                         .cloned()\n+                         .chain(Some(fn_sig.output.unwrap_or(self.tcx().types.bool)))\n+                         .collect();\n+\n         let old_body_id = self.set_body_id(body.id);\n-        self.relate_free_regions(&fn_sig[..], body.id, span);\n+        self.relate_free_regions(&fn_sig_tys[..], body.id, span);\n         link_fn_args(self,\n                      self.tcx().region_maps.node_extent(body.id),\n                      &fn_decl.inputs[..]);"}, {"sha": "cfab28f923e0942f3463a8d9dfd811b30616f07c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -43,6 +43,7 @@ pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &hir::Expr) {\n     wbcx.visit_expr(e);\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_closures();\n+    wbcx.visit_liberated_fn_sigs();\n }\n \n pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n@@ -63,6 +64,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     }\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_closures();\n+    wbcx.visit_liberated_fn_sigs();\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -361,6 +363,13 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n+    fn visit_liberated_fn_sigs(&self) {\n+        for (&node_id, fn_sig) in self.fcx.inh.tables.borrow().liberated_fn_sigs.iter() {\n+            let fn_sig = self.resolve(fn_sig, ResolvingFnSig(node_id));\n+            self.tcx().tables.borrow_mut().liberated_fn_sigs.insert(node_id, fn_sig.clone());\n+        }\n+    }\n+\n     fn resolve<T:TypeFoldable<'tcx>>(&self, t: &T, reason: ResolveReason) -> T {\n         t.fold_with(&mut Resolver::new(self.fcx, reason))\n     }\n@@ -376,6 +385,7 @@ enum ResolveReason {\n     ResolvingPattern(Span),\n     ResolvingUpvar(ty::UpvarId),\n     ResolvingClosure(DefId),\n+    ResolvingFnSig(ast::NodeId),\n }\n \n impl ResolveReason {\n@@ -387,6 +397,9 @@ impl ResolveReason {\n             ResolvingUpvar(upvar_id) => {\n                 tcx.expr_span(upvar_id.closure_expr_id)\n             }\n+            ResolvingFnSig(id) => {\n+                tcx.map.span(id)\n+            }\n             ResolvingClosure(did) => {\n                 if let Some(node_id) = tcx.map.as_local_node_id(did) {\n                     tcx.expr_span(node_id)\n@@ -463,6 +476,16 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                     span_err!(self.tcx.sess, span, E0196,\n                               \"cannot determine a type for this closure\")\n                 }\n+\n+                ResolvingFnSig(id) => {\n+                    // any failures here should also fail when\n+                    // resolving the patterns, closure types, or\n+                    // something else.\n+                    let span = self.reason.span(self.tcx);\n+                    self.tcx.sess.delay_span_bug(\n+                        span,\n+                        &format!(\"cannot resolve some aspect of fn sig for {:?}\", id));\n+                }\n             }\n         }\n     }"}, {"sha": "f9a138f8fd7af603ef9c1f441cc49d87ee1b71a6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -146,7 +146,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n                                         &arenas,\n                                         &name,\n                                         resolve::MakeGlobMap::No,\n-                                        |tcx, analysis| {\n+                                        |tcx, _, analysis| {\n         let ty::CrateAnalysis { exported_items, public_items, .. } = analysis;\n \n         // Convert from a NodeId set to a DefId set since we don't always have easy access"}, {"sha": "f2dd155595ac46bb4bf7b5faa8741829458feadc", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -229,9 +229,9 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let ast_map = driver::make_map(&sess, &mut hir_forest);\n \n         driver::phase_3_run_analysis_passes(\n-            &sess, ast_map, &arenas, &id, MakeGlobMap::No, |tcx, analysis| {\n+            &sess, ast_map, &arenas, &id, MakeGlobMap::No, |tcx, mir_map, analysis| {\n \n-            let trans = driver::phase_4_translate_to_llvm(tcx, analysis);\n+            let trans = driver::phase_4_translate_to_llvm(tcx, &mir_map, analysis);\n \n             let crates = tcx.sess.cstore.get_used_crates(RequireDynamic);\n "}, {"sha": "9a06ab78e73b45efd2023a2c450c372ffca8c1e7", "filename": "src/test/run-pass/mir_trans_spike1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Ftest%2Frun-pass%2Fmir_trans_spike1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a216e847272ddbd3033037b606eaf2d801c250b9/src%2Ftest%2Frun-pass%2Fmir_trans_spike1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_spike1.rs?ref=a216e847272ddbd3033037b606eaf2d801c250b9", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A simple spike test for MIR version of trans.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_mir]\n+fn sum(x: i32, y: i32) -> i32 {\n+    x + y\n+}\n+\n+fn main() {\n+    let x = sum(22, 44);\n+    assert_eq!(x, 66);\n+    println!(\"sum()={:?}\", x);\n+}"}]}