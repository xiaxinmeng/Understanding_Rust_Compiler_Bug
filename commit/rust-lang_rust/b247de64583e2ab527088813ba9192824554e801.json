{"sha": "b247de64583e2ab527088813ba9192824554e801", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNDdkZTY0NTgzZTJhYjUyNzA4ODgxM2JhOTE5MjgyNDU1NGU4MDE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-18T22:59:00Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-19T00:03:35Z"}, "message": "rt: Remove lock_held_by_current_thread", "tree": {"sha": "ae9a3787632c877c6b9450cbf4431e26b5f081e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae9a3787632c877c6b9450cbf4431e26b5f081e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b247de64583e2ab527088813ba9192824554e801", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b247de64583e2ab527088813ba9192824554e801", "html_url": "https://github.com/rust-lang/rust/commit/b247de64583e2ab527088813ba9192824554e801", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b247de64583e2ab527088813ba9192824554e801/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4af1ca0657d2b3b4fc2e7829cd8f822d983de1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4af1ca0657d2b3b4fc2e7829cd8f822d983de1b", "html_url": "https://github.com/rust-lang/rust/commit/e4af1ca0657d2b3b4fc2e7829cd8f822d983de1b"}], "stats": {"total": 75, "additions": 0, "deletions": 75}, "files": [{"sha": "e9c1c6c9d3b2c8cf29f0574779361bbc880004e4", "filename": "src/etc/x86.supp", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b247de64583e2ab527088813ba9192824554e801/src%2Fetc%2Fx86.supp", "raw_url": "https://github.com/rust-lang/rust/raw/b247de64583e2ab527088813ba9192824554e801/src%2Fetc%2Fx86.supp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fx86.supp?ref=b247de64583e2ab527088813ba9192824554e801", "patch": "@@ -389,34 +389,6 @@\n    fun:uv_loop_delete\n }\n \n-{\n-   lock_and_signal-probably-threadsafe-access-outside-of-lock\n-   Helgrind:Race\n-   fun:_ZN15lock_and_signal27lock_held_by_current_threadEv\n-   ...\n-}  \n-\n-{\n-   lock_and_signal-probably-threadsafe-access-outside-of-lock2\n-   Helgrind:Race\n-   fun:_ZN15lock_and_signal6unlockEv\n-   ...\n-}\n-\n-{\n-   lock_and_signal-probably-threadsafe-access-outside-of-lock3\n-   Helgrind:Race\n-   fun:_ZN15lock_and_signal4lockEv\n-   ...\n-}\n-\n-{\n-   lock_and_signal-probably-threadsafe-access-outside-of-lock4\n-   Helgrind:Race\n-   fun:_ZN15lock_and_signal4waitEv\n-   ...\n-}\n-\n {\n    uv-async-send-does-racy-things\n    Helgrind:Race"}, {"sha": "8e6baf991978d1494ab6984df8346ea7f9b6a88f", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=b247de64583e2ab527088813ba9192824554e801", "patch": "@@ -62,7 +62,6 @@ void rust_kernel::free(void *mem) {\n \n rust_sched_id\n rust_kernel::create_scheduler(size_t num_threads) {\n-    I(this, !sched_lock.lock_held_by_current_thread());\n     rust_sched_id id;\n     rust_scheduler *sched;\n     {\n@@ -81,7 +80,6 @@ rust_kernel::create_scheduler(size_t num_threads) {\n \n rust_scheduler *\n rust_kernel::get_scheduler_by_id(rust_sched_id id) {\n-    I(this, !sched_lock.lock_held_by_current_thread());\n     scoped_lock with(sched_lock);\n     sched_map::iterator iter = sched_table.find(id);\n     if (iter != sched_table.end()) {\n@@ -93,7 +91,6 @@ rust_kernel::get_scheduler_by_id(rust_sched_id id) {\n \n void\n rust_kernel::release_scheduler_id(rust_sched_id id) {\n-    I(this, !sched_lock.lock_held_by_current_thread());\n     scoped_lock with(sched_lock);\n     // This list will most likely only ever have a single element in it, but\n     // it's an actual list because we could potentially get here multiple\n@@ -111,7 +108,6 @@ them then we can see valgrind errors due to un-freed pthread memory.\n int\n rust_kernel::wait_for_schedulers()\n {\n-    I(this, !sched_lock.lock_held_by_current_thread());\n     scoped_lock with(sched_lock);\n     while (!sched_table.empty()) {\n         while (!join_list.empty()) {"}, {"sha": "f88241665299cd3f1363ba944f1950d2813cee91", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=b247de64583e2ab527088813ba9192824554e801", "patch": "@@ -55,7 +55,6 @@ void rust_port::end_detach() {\n }\n \n void rust_port::send(void *sptr) {\n-    I(task->thread, !lock.lock_held_by_current_thread());\n     bool did_rendezvous = false;\n     {\n         scoped_lock with(lock);\n@@ -88,8 +87,6 @@ void rust_port::send(void *sptr) {\n }\n \n void rust_port::receive(void *dptr, uintptr_t *yield) {\n-    I(task->thread, !lock.lock_held_by_current_thread());\n-\n     LOG(task, comm, \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\n         \", size: 0x%\" PRIxPTR,\n         (uintptr_t) this, (uintptr_t) dptr, unit_sz);\n@@ -122,7 +119,6 @@ void rust_port::receive(void *dptr, uintptr_t *yield) {\n }\n \n size_t rust_port::size() {\n-    I(task->thread, !lock.lock_held_by_current_thread());\n     scoped_lock with(lock);\n     return buffer.size();\n }"}, {"sha": "5a3aaf0c65bdfd11b5f336704176914bf257b2c6", "filename": "src/rt/rust_port_selector.cpp", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Frust_port_selector.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Frust_port_selector.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port_selector.cpp?ref=b247de64583e2ab527088813ba9192824554e801", "patch": "@@ -69,9 +69,6 @@ void\n rust_port_selector::msg_sent_on(rust_port *port) {\n     rust_task *task = port->task;\n \n-    I(task->thread, !port->lock.lock_held_by_current_thread());\n-    I(task->thread, !rendezvous_lock.lock_held_by_current_thread());\n-\n     // Prevent two ports from trying to wake up the task\n     // simultaneously\n     scoped_lock with(rendezvous_lock);"}, {"sha": "750f921205ccf351e8275b71b50bfdaed984f4ce", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=b247de64583e2ab527088813ba9192824554e801", "patch": "@@ -133,7 +133,6 @@ rust_scheduler::number_of_threads() {\n \n void\n rust_scheduler::release_task_thread() {\n-    I(this, !lock.lock_held_by_current_thread());\n     uintptr_t new_live_threads;\n     {\n \tscoped_lock with(lock);"}, {"sha": "a8a03362018d193fbcb216b7484b76f0781c6ac4", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=b247de64583e2ab527088813ba9192824554e801", "patch": "@@ -242,7 +242,6 @@ rust_task::must_fail_from_being_killed() {\n \n bool\n rust_task::must_fail_from_being_killed_unlocked() {\n-    I(thread, kill_lock.lock_held_by_current_thread());\n     return killed && !reentered_rust_stack;\n }\n "}, {"sha": "d8fb28d579132fbac29841ad0d37036d90d78f5f", "filename": "src/rt/rust_task_thread.cpp", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Frust_task_thread.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Frust_task_thread.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_thread.cpp?ref=b247de64583e2ab527088813ba9192824554e801", "patch": "@@ -121,8 +121,6 @@ rust_task_thread::number_of_live_tasks() {\n  */\n void\n rust_task_thread::reap_dead_tasks() {\n-    I(this, lock.lock_held_by_current_thread());\n-\n     if (dead_tasks.length() == 0) {\n         return;\n     }\n@@ -358,7 +356,6 @@ rust_task_thread::place_task_in_tls(rust_task *task) {\n \n void\n rust_task_thread::exit() {\n-    A(this, !lock.lock_held_by_current_thread(), \"Shouldn't have lock\");\n     scoped_lock with(lock);\n     should_exit = true;\n     lock.signal();"}, {"sha": "11f7be4670a32edd5b24f6cd6807d0c6af59ad50", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=b247de64583e2ab527088813ba9192824554e801", "patch": "@@ -10,13 +10,8 @@\n \n #include \"lock_and_signal.h\"\n \n-// FIXME: This is not a portable way of specifying an invalid pthread_t\n-#define INVALID_THREAD 0\n-\n-\n #if defined(__WIN32__)\n lock_and_signal::lock_and_signal()\n-    : _holding_thread(INVALID_THREAD)\n {\n     _event = CreateEvent(NULL, FALSE, FALSE, NULL);\n \n@@ -35,7 +30,6 @@ lock_and_signal::lock_and_signal()\n \n #else\n lock_and_signal::lock_and_signal()\n-    : _holding_thread(INVALID_THREAD)\n {\n     CHECKED(pthread_cond_init(&_cond, NULL));\n     CHECKED(pthread_mutex_init(&_mutex, NULL));\n@@ -53,19 +47,14 @@ lock_and_signal::~lock_and_signal() {\n }\n \n void lock_and_signal::lock() {\n-    assert(!lock_held_by_current_thread());\n #if defined(__WIN32__)\n     EnterCriticalSection(&_cs);\n-    _holding_thread = GetCurrentThreadId();\n #else\n     CHECKED(pthread_mutex_lock(&_mutex));\n-    _holding_thread = pthread_self();\n #endif\n }\n \n void lock_and_signal::unlock() {\n-    assert(lock_held_by_current_thread());\n-    _holding_thread = INVALID_THREAD;\n #if defined(__WIN32__)\n     LeaveCriticalSection(&_cs);\n #else\n@@ -77,18 +66,12 @@ void lock_and_signal::unlock() {\n  * Wait indefinitely until condition is signaled.\n  */\n void lock_and_signal::wait() {\n-    assert(lock_held_by_current_thread());\n-    _holding_thread = INVALID_THREAD;\n #if defined(__WIN32__)\n     LeaveCriticalSection(&_cs);\n     WaitForSingleObject(_event, INFINITE);\n     EnterCriticalSection(&_cs);\n-    assert(_holding_thread == INVALID_THREAD);\n-    _holding_thread = GetCurrentThreadId();\n #else\n     CHECKED(pthread_cond_wait(&_cond, &_mutex));\n-    assert(_holding_thread == INVALID_THREAD);\n-    _holding_thread = pthread_self();\n #endif\n }\n \n@@ -103,15 +86,6 @@ void lock_and_signal::signal() {\n #endif\n }\n \n-bool lock_and_signal::lock_held_by_current_thread()\n-{\n-#if defined(__WIN32__)\n-    return _holding_thread == GetCurrentThreadId();\n-#else\n-    return pthread_equal(_holding_thread, pthread_self());\n-#endif\n-}\n-\n scoped_lock::scoped_lock(lock_and_signal &lock)\n     : lock(lock)\n {"}, {"sha": "f4ffcc30a6845f6f1d19f8474bdefa28cd9c1872", "filename": "src/rt/sync/lock_and_signal.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Fsync%2Flock_and_signal.h", "raw_url": "https://github.com/rust-lang/rust/raw/b247de64583e2ab527088813ba9192824554e801/src%2Frt%2Fsync%2Flock_and_signal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.h?ref=b247de64583e2ab527088813ba9192824554e801", "patch": "@@ -6,12 +6,9 @@ class lock_and_signal {\n #if defined(__WIN32__)\n     HANDLE _event;\n     CRITICAL_SECTION _cs;\n-    DWORD _holding_thread;\n #else\n     pthread_cond_t _cond;\n     pthread_mutex_t _mutex;\n-\n-    pthread_t _holding_thread;\n #endif\n \n public:\n@@ -22,8 +19,6 @@ class lock_and_signal {\n     void unlock();\n     void wait();\n     void signal();\n-\n-    bool lock_held_by_current_thread();\n };\n \n class scoped_lock {"}]}