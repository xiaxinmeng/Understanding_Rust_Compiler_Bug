{"sha": "d4b287e8525758896e78b39eca6f6e1c0f32cd98", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YjI4N2U4NTI1NzU4ODk2ZTc4YjM5ZWNhNmY2ZTFjMGYzMmNkOTg=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-01-23T10:41:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-24T06:28:25Z"}, "message": "Added str::any, str::bytes_iter, str::windowed, and vec::windowed functions", "tree": {"sha": "ae0138e480b70276f3d53b5175ff51071d58fff2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae0138e480b70276f3d53b5175ff51071d58fff2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4b287e8525758896e78b39eca6f6e1c0f32cd98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4b287e8525758896e78b39eca6f6e1c0f32cd98", "html_url": "https://github.com/rust-lang/rust/commit/d4b287e8525758896e78b39eca6f6e1c0f32cd98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4b287e8525758896e78b39eca6f6e1c0f32cd98/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0493a7c87d7769a3b3b819a7b38cd242f95dfad2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0493a7c87d7769a3b3b819a7b38cd242f95dfad2", "html_url": "https://github.com/rust-lang/rust/commit/0493a7c87d7769a3b3b819a7b38cd242f95dfad2"}], "stats": {"total": 165, "additions": 158, "deletions": 7}, "files": [{"sha": "df564c7bded128bb79507db315c8d01521bbf24f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 125, "deletions": 7, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/d4b287e8525758896e78b39eca6f6e1c0f32cd98/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b287e8525758896e78b39eca6f6e1c0f32cd98/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d4b287e8525758896e78b39eca6f6e1c0f32cd98", "patch": "@@ -14,8 +14,8 @@ export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len,\n        char_at, bytes, is_ascii, shift_byte, pop_byte,\n        unsafe_from_byte, unsafe_from_bytes, from_char, char_range_at,\n        from_cstr, sbuf, as_buf, push_byte, utf8_char_width, safe_slice,\n-       contains, iter_chars, loop_chars, loop_chars_sub,\n-       escape;\n+       contains, iter_chars, chars_iter, bytes_iter,\n+       loop_chars, loop_chars_sub, escape, any, all, map, windowed;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n@@ -346,7 +346,6 @@ Function: iter_chars\n \n Iterate over the characters in a string\n */\n-\n fn iter_chars(s: str, it: fn(char)) {\n     let pos = 0u, len = byte_len(s);\n     while (pos < len) {\n@@ -356,6 +355,34 @@ fn iter_chars(s: str, it: fn(char)) {\n     }\n }\n \n+/*\n+Function: chars_iter\n+\n+Iterate over the characters in a string\n+\n+FIXME: A synonym to iter_chars\n+*/\n+fn chars_iter(ss: str, it: fn&(char)) {\n+   iter_chars(ss, it)\n+}\n+\n+/*\n+Function: bytes_iter\n+\n+Iterate over the bytes in a string\n+\n+FIXME: Should it really include the last byte '\\0'?\n+*/\n+fn bytes_iter(ss: str, it: fn&(u8)) {\n+   let pos = 0u;\n+   let len = byte_len(ss);\n+\n+   while (pos < len) {\n+      it(ss[pos]);\n+      pos += 1u;\n+   }\n+}\n+\n /*\n Function: loop_chars\n \n@@ -1116,14 +1143,25 @@ fn escape(s: str) -> str {\n /*\n Function: all\n \n-Return true if a predicate matches all characters\n+Return true if a predicate matches all characters or\n+if the string contains no characters\n \n-If the string contains no characters\n+// FIXME: a synonym to loop_chars\n */\n fn all(ss: str, ff: fn&(char) -> bool) -> bool {\n     str::loop_chars(ss, ff)\n }\n \n+/*\n+Function: any\n+\n+Return true if a predicate matches any character\n+(and false if it matches none or there are no characters)\n+*/\n+fn any(ss: str, pred: fn&(char) -> bool) -> bool {\n+   !all(ss, {|cc| !pred(cc)})\n+}\n+\n /*\n Function: map\n \n@@ -1139,6 +1177,26 @@ fn map(ss: str, ff: fn&(char) -> char) -> str {\n     ret result;\n }\n \n+/*\n+Function: windowed\n+\n+Create a vector of substrings of size `nn`\n+*/\n+fn windowed(nn: uint, ss: str) -> [str] {\n+    let ww = [];\n+    let len = str::char_len(ss);\n+\n+    assert 1u <= nn;\n+\n+    let ii = 0u;\n+    while ii+nn <= len {\n+        let w = char_slice( ss, ii, ii+nn );\n+        vec::push(ww,w);\n+        ii += 1u;\n+    }\n+\n+    ret ww;\n+}\n \n #[cfg(test)]\n mod tests {\n@@ -1590,6 +1648,39 @@ mod tests {\n             }\n             i += 1;\n         }\n+\n+        iter_chars(\"\") {|ch| fail; } // should not fail\n+    }\n+\n+    #[test]\n+    fn test_chars_iter() {\n+        let i = 0;\n+        chars_iter(\"x\\u03c0y\") {|ch|\n+            alt i {\n+              0 { assert ch == 'x'; }\n+              1 { assert ch == '\\u03c0'; }\n+              2 { assert ch == 'y'; }\n+            }\n+            i += 1;\n+        }\n+\n+        chars_iter(\"\") {|_ch| fail; } // should not fail\n+    }\n+\n+    #[test]\n+    fn test_bytes_iter() {\n+        let i = 0;\n+\n+        bytes_iter(\"xyz\") {|bb|\n+            alt i {\n+              0 { assert bb == 'x' as u8; }\n+              1 { assert bb == 'y' as u8; }\n+              2 { assert bb == 'z' as u8; }\n+            }\n+            i += 1;\n+        }\n+\n+        bytes_iter(\"\") {|bb| assert bb == 0u8; }\n     }\n \n     #[test]\n@@ -1601,17 +1692,44 @@ mod tests {\n     }\n \n    #[test]\n-   fn test_map () {\n+   fn test_map() {\n       assert \"\" == map(\"\", char::to_upper);\n       assert \"YMCA\" == map(\"ymca\", char::to_upper);\n    }\n \n    #[test]\n-   fn test_all () {\n+   fn test_all() {\n        assert true  == all(\"\", char::is_uppercase);\n        assert false == all(\"ymca\", char::is_uppercase);\n        assert true  == all(\"YMCA\", char::is_uppercase);\n        assert false == all(\"yMCA\", char::is_uppercase);\n        assert false == all(\"YMCy\", char::is_uppercase);\n    }\n+\n+   #[test]\n+   fn test_any() {\n+       assert false  == any(\"\", char::is_uppercase);\n+       assert false == any(\"ymca\", char::is_uppercase);\n+       assert true  == any(\"YMCA\", char::is_uppercase);\n+       assert true == any(\"yMCA\", char::is_uppercase);\n+       assert true == any(\"YMCy\", char::is_uppercase);\n+   }\n+\n+    #[test]\n+    fn test_windowed() {\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n+\n+        assert [\"\u0e1b\u0e23\u0e30\", \"\u0e23\u0e30\u0e40\", \"\u0e30\u0e40\u0e17\", \"\u0e40\u0e17\u0e28\", \"\u0e17\u0e28\u0e44\", \"\u0e28\u0e44\u0e17\", \"\u0e44\u0e17\u0e22\", \"\u0e17\u0e22\u4e2d\"]\n+            == windowed(3u, data);\n+\n+        assert [data] == windowed(10u, data);\n+\n+        assert [] == windowed(6u, \"abcd\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_windowed_() {\n+        let _x = windowed(0u, \"abcd\");\n+    }\n }"}, {"sha": "8b7ea91becd53a3270ad28761b585624c31ce9e6", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d4b287e8525758896e78b39eca6f6e1c0f32cd98/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4b287e8525758896e78b39eca6f6e1c0f32cd98/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=d4b287e8525758896e78b39eca6f6e1c0f32cd98", "patch": "@@ -829,6 +829,23 @@ fn permute<T: copy>(v: [const T], put: fn([T])) {\n   }\n }\n \n+fn windowed <TT: copy> (nn: uint, xx: [TT]) -> [[TT]] {\n+   let ww = [];\n+\n+   assert 1u <= nn;\n+\n+   vec::iteri (xx, {|ii, _x|\n+      let len = vec::len(xx);\n+\n+      if ii+nn <= len {\n+         let w = vec::slice ( xx, ii, ii+nn );\n+         vec::push (ww, w);\n+      }\n+   });\n+\n+   ret ww;\n+}\n+\n /*\n Function: to_ptr\n \n@@ -1497,6 +1514,22 @@ mod tests {\n         assert concat([[1], [2,3]]) == [1, 2, 3];\n     }\n \n+    #[test]\n+    fn test_windowed () {\n+        assert [[1u,2u,3u],[2u,3u,4u],[3u,4u,5u],[4u,5u,6u]]\n+              == windowed (3u, [1u,2u,3u,4u,5u,6u]);\n+\n+        assert [[1u,2u,3u,4u],[2u,3u,4u,5u],[3u,4u,5u,6u]]\n+              == windowed (4u, [1u,2u,3u,4u,5u,6u]);\n+\n+        assert [] == windowed (7u, [1u,2u,3u,4u,5u,6u]);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_windowed_() {\n+        let _x = windowed (0u, [1u,2u,3u,4u,5u,6u]);\n+    }\n }\n \n // Local Variables:"}]}