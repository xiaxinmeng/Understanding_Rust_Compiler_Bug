{"sha": "490112dea10d476e9b5829499bc6670f03f7d138", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5MDExMmRlYTEwZDQ3NmU5YjU4Mjk0OTliYzY2NzBmMDNmN2QxMzg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-15T16:15:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-15T16:15:01Z"}, "message": "remove Cancelable from nameres", "tree": {"sha": "2c02cf513feeb85054e68a04f28c16e516c54653", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c02cf513feeb85054e68a04f28c16e516c54653"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/490112dea10d476e9b5829499bc6670f03f7d138", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/490112dea10d476e9b5829499bc6670f03f7d138", "html_url": "https://github.com/rust-lang/rust/commit/490112dea10d476e9b5829499bc6670f03f7d138", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/490112dea10d476e9b5829499bc6670f03f7d138/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18e9a710cd2f2ced84fde19e88d0b967dcb5939e", "url": "https://api.github.com/repos/rust-lang/rust/commits/18e9a710cd2f2ced84fde19e88d0b967dcb5939e", "html_url": "https://github.com/rust-lang/rust/commit/18e9a710cd2f2ced84fde19e88d0b967dcb5939e"}], "stats": {"total": 118, "additions": 52, "deletions": 66}, "files": [{"sha": "7ccd29e2f0b015e80eb1ab15fd31bdcadd1cb3fb", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=490112dea10d476e9b5829499bc6670f03f7d138", "patch": "@@ -134,11 +134,11 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n+    pub fn scope(&self, db: &impl HirDatabase) -> ModuleScope {\n         self.scope_impl(db)\n     }\n \n-    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> Cancelable<PerNs<DefId>> {\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<DefId> {\n         self.resolve_path_impl(db, path)\n     }\n "}, {"sha": "04301ae530625e8470c4ec365203de908ef6370f", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=490112dea10d476e9b5829499bc6670f03f7d138", "patch": "@@ -114,18 +114,13 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope_impl(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n+    pub fn scope_impl(&self, db: &impl HirDatabase) -> ModuleScope {\n         let loc = self.def_id.loc(db);\n-        let item_map = db.item_map(loc.source_root_id)?;\n-        let res = item_map.per_module[&loc.module_id].clone();\n-        Ok(res)\n+        let item_map = db.item_map(loc.source_root_id);\n+        item_map.per_module[&loc.module_id].clone()\n     }\n \n-    pub fn resolve_path_impl(\n-        &self,\n-        db: &impl HirDatabase,\n-        path: &Path,\n-    ) -> Cancelable<PerNs<DefId>> {\n+    pub fn resolve_path_impl(&self, db: &impl HirDatabase, path: &Path) -> PerNs<DefId> {\n         let mut curr_per_ns = PerNs::types(\n             match path.kind {\n                 PathKind::Crate => self.crate_root(db),\n@@ -134,7 +129,7 @@ impl Module {\n                     if let Some(p) = self.parent(db) {\n                         p\n                     } else {\n-                        return Ok(PerNs::none());\n+                        return PerNs::none();\n                     }\n                 }\n             }\n@@ -146,7 +141,7 @@ impl Module {\n             let curr = if let Some(r) = curr_per_ns.as_ref().take_types() {\n                 r\n             } else {\n-                return Ok(PerNs::none());\n+                return PerNs::none();\n             };\n             let module = match curr.resolve(db) {\n                 Def::Module(it) => it,\n@@ -157,28 +152,28 @@ impl Module {\n                             e.variants(db).into_iter().find(|(n, _variant)| n == name);\n \n                         if let Some((_n, variant)) = matching_variant {\n-                            return Ok(PerNs::both(variant.def_id(), e.def_id()));\n+                            return PerNs::both(variant.def_id(), e.def_id());\n                         } else {\n-                            return Ok(PerNs::none());\n+                            return PerNs::none();\n                         }\n                     } else if segments.len() == idx {\n                         // enum\n-                        return Ok(PerNs::types(e.def_id()));\n+                        return PerNs::types(e.def_id());\n                     } else {\n                         // malformed enum?\n-                        return Ok(PerNs::none());\n+                        return PerNs::none();\n                     }\n                 }\n-                _ => return Ok(PerNs::none()),\n+                _ => return PerNs::none(),\n             };\n-            let scope = module.scope(db)?;\n+            let scope = module.scope(db);\n             curr_per_ns = if let Some(r) = scope.get(&name) {\n                 r.def_id\n             } else {\n-                return Ok(PerNs::none());\n+                return PerNs::none();\n             };\n         }\n-        Ok(curr_per_ns)\n+        curr_per_ns\n     }\n \n     pub fn problems_impl("}, {"sha": "1466c3438d376891bc07fd131e931686425021f0", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=490112dea10d476e9b5829499bc6670f03f7d138", "patch": "@@ -87,7 +87,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::input_module_items;\n     }\n \n-    fn item_map(source_root_id: SourceRootId) -> Cancelable<Arc<ItemMap>> {\n+    fn item_map(source_root_id: SourceRootId) -> Arc<ItemMap> {\n         type ItemMapQuery;\n         use fn query_definitions::item_map;\n     }"}, {"sha": "484f668d076576f90a9501b519c72e8686647aad", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=490112dea10d476e9b5829499bc6670f03f7d138", "patch": "@@ -22,7 +22,7 @@ use ra_syntax::{\n     SyntaxKind::{self, *},\n     ast::{self, AstNode}\n };\n-use ra_db::{SourceRootId, Cancelable, FileId};\n+use ra_db::{SourceRootId, FileId};\n \n use crate::{\n     HirFileId,\n@@ -319,30 +319,26 @@ where\n         }\n     }\n \n-    pub(crate) fn resolve(mut self) -> Cancelable<ItemMap> {\n+    pub(crate) fn resolve(mut self) -> ItemMap {\n         for (&module_id, items) in self.input.iter() {\n-            self.populate_module(module_id, Arc::clone(items))?;\n+            self.populate_module(module_id, Arc::clone(items));\n         }\n \n         loop {\n             let processed_imports_count = self.processed_imports.len();\n             for &module_id in self.input.keys() {\n                 self.db.check_canceled();\n-                self.resolve_imports(module_id)?;\n+                self.resolve_imports(module_id);\n             }\n             if processed_imports_count == self.processed_imports.len() {\n                 // no new imports resolved\n                 break;\n             }\n         }\n-        Ok(self.result)\n+        self.result\n     }\n \n-    fn populate_module(\n-        &mut self,\n-        module_id: ModuleId,\n-        input: Arc<InputModuleItems>,\n-    ) -> Cancelable<()> {\n+    fn populate_module(&mut self, module_id: ModuleId, input: Arc<InputModuleItems>) {\n         let mut module_items = ModuleScope::default();\n \n         // Populate extern crates prelude\n@@ -415,7 +411,6 @@ where\n         }\n \n         self.result.per_module.insert(module_id, module_items);\n-        Ok(())\n     }\n \n     fn add_module_item(&self, module_items: &mut ModuleScope, name: Name, def_id: PerNs<DefId>) {\n@@ -426,24 +421,23 @@ where\n         module_items.items.insert(name, resolution);\n     }\n \n-    fn resolve_imports(&mut self, module_id: ModuleId) -> Cancelable<()> {\n+    fn resolve_imports(&mut self, module_id: ModuleId) {\n         for (i, import) in self.input[&module_id].imports.iter().enumerate() {\n             if self.processed_imports.contains(&(module_id, i)) {\n                 // already done\n                 continue;\n             }\n-            if self.resolve_import(module_id, import)? {\n+            if self.resolve_import(module_id, import) {\n                 log::debug!(\"import {:?} resolved (or definite error)\", import);\n                 self.processed_imports.insert((module_id, i));\n             }\n         }\n-        Ok(())\n     }\n \n-    fn resolve_import(&mut self, module_id: ModuleId, import: &Import) -> Cancelable<bool> {\n+    fn resolve_import(&mut self, module_id: ModuleId, import: &Import) -> bool {\n         log::debug!(\"resolving import: {:?}\", import);\n         let ptr = match import.kind {\n-            ImportKind::Glob => return Ok(false),\n+            ImportKind::Glob => return false,\n             ImportKind::Named(ptr) => ptr,\n         };\n \n@@ -455,7 +449,7 @@ where\n                     None => {\n                         // TODO: error\n                         log::debug!(\"super path in root module\");\n-                        return Ok(true); // this can't suddenly resolve if we just resolve some other imports\n+                        return true; // this can't suddenly resolve if we just resolve some other imports\n                     }\n                 }\n             }\n@@ -469,7 +463,7 @@ where\n                 Some(res) if !res.def_id.is_none() => res.def_id,\n                 _ => {\n                     log::debug!(\"path segment {:?} not found\", name);\n-                    return Ok(false);\n+                    return false;\n                 }\n             };\n \n@@ -481,7 +475,7 @@ where\n                         \"path segment {:?} resolved to value only, but is not last\",\n                         name\n                     );\n-                    return Ok(false);\n+                    return false;\n                 };\n                 curr = match type_def_id.loc(self.db) {\n                     DefLoc {\n@@ -499,7 +493,7 @@ where\n                                 kind: PathKind::Crate,\n                             };\n                             log::debug!(\"resolving {:?} in other source root\", path);\n-                            let def_id = module.resolve_path(self.db, &path)?;\n+                            let def_id = module.resolve_path(self.db, &path);\n                             if !def_id.is_none() {\n                                 let name = path.segments.last().unwrap();\n                                 self.update(module_id, |items| {\n@@ -515,10 +509,10 @@ where\n                                     import,\n                                     def_id.map(|did| did.loc(self.db))\n                                 );\n-                                return Ok(true);\n+                                return true;\n                             } else {\n                                 log::debug!(\"rest of path did not resolve in other source root\");\n-                                return Ok(true);\n+                                return true;\n                             }\n                         }\n                     }\n@@ -528,7 +522,7 @@ where\n                             name,\n                             type_def_id.loc(self.db)\n                         );\n-                        return Ok(true); // this resolved to a non-module, so the path won't ever resolve\n+                        return true; // this resolved to a non-module, so the path won't ever resolve\n                     }\n                 }\n             } else {\n@@ -547,7 +541,7 @@ where\n                 })\n             }\n         }\n-        Ok(true)\n+        true\n     }\n \n     fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {"}, {"sha": "9a047404547c92a8f04c4bc8fdda2824539c558c", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=490112dea10d476e9b5829499bc6670f03f7d138", "patch": "@@ -17,7 +17,7 @@ fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n     let source_root = db.file_source_root(pos.file_id);\n     let module = crate::source_binder::module_from_position(&db, pos).unwrap();\n     let module_id = module.def_id.loc(&db).module_id;\n-    (db.item_map(source_root).unwrap(), module_id)\n+    (db.item_map(source_root), module_id)\n }\n \n fn check_module_item_map(map: &ItemMap, module_id: ModuleId, expected: &str) {\n@@ -242,7 +242,7 @@ fn item_map_across_crates() {\n     let source_root = db.file_source_root(main_id);\n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n     let module_id = module.def_id.loc(&db).module_id;\n-    let item_map = db.item_map(source_root).unwrap();\n+    let item_map = db.item_map(source_root);\n \n     check_module_item_map(\n         &item_map,\n@@ -294,7 +294,7 @@ fn import_across_source_roots() {\n \n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n     let module_id = module.def_id.loc(&db).module_id;\n-    let item_map = db.item_map(source_root).unwrap();\n+    let item_map = db.item_map(source_root);\n \n     check_module_item_map(\n         &item_map,\n@@ -337,7 +337,7 @@ fn reexport_across_crates() {\n     let source_root = db.file_source_root(main_id);\n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n     let module_id = module.def_id.loc(&db).module_id;\n-    let item_map = db.item_map(source_root).unwrap();\n+    let item_map = db.item_map(source_root);\n \n     check_module_item_map(\n         &item_map,\n@@ -354,7 +354,7 @@ fn check_item_map_is_not_recomputed(initial: &str, file_change: &str) {\n     let source_root = db.file_source_root(pos.file_id);\n     {\n         let events = db.log_executed(|| {\n-            db.item_map(source_root).unwrap();\n+            db.item_map(source_root);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n     }\n@@ -363,7 +363,7 @@ fn check_item_map_is_not_recomputed(initial: &str, file_change: &str) {\n \n     {\n         let events = db.log_executed(|| {\n-            db.item_map(source_root).unwrap();\n+            db.item_map(source_root);\n         });\n         assert!(\n             !format!(\"{:?}\", events).contains(\"item_map\"),"}, {"sha": "24cb5c75276f399ab939e6bdb36dedfe9a58c946", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=490112dea10d476e9b5829499bc6670f03f7d138", "patch": "@@ -8,7 +8,7 @@ use ra_syntax::{\n     AstNode, SyntaxNode, TreeArc,\n     ast::{self, ModuleItemOwner}\n };\n-use ra_db::{SourceRootId, Cancelable,};\n+use ra_db::SourceRootId;\n \n use crate::{\n     SourceFileItems, SourceItemId, DefId, HirFileId, ModuleSource,\n@@ -93,10 +93,7 @@ pub(super) fn input_module_items(\n     Arc::new(res)\n }\n \n-pub(super) fn item_map(\n-    db: &impl HirDatabase,\n-    source_root: SourceRootId,\n-) -> Cancelable<Arc<ItemMap>> {\n+pub(super) fn item_map(db: &impl HirDatabase, source_root: SourceRootId) -> Arc<ItemMap> {\n     let start = Instant::now();\n     let module_tree = db.module_tree(source_root);\n     let input = module_tree\n@@ -105,8 +102,8 @@ pub(super) fn item_map(\n         .collect::<FxHashMap<_, _>>();\n \n     let resolver = Resolver::new(db, &input, source_root, module_tree);\n-    let res = resolver.resolve()?;\n+    let res = resolver.resolve();\n     let elapsed = start.elapsed();\n     log::info!(\"item_map: {:?}\", elapsed);\n-    Ok(Arc::new(res))\n+    Arc::new(res)\n }"}, {"sha": "6df7820eaf4d583218b7d4bd3816b54e835c2c26", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=490112dea10d476e9b5829499bc6670f03f7d138", "patch": "@@ -349,7 +349,7 @@ impl Ty {\n         }\n \n         // Resolve in module (in type namespace)\n-        let resolved = if let Some(r) = module.resolve_path(db, path)?.take_types() {\n+        let resolved = if let Some(r) = module.resolve_path(db, path).take_types() {\n             r\n         } else {\n             return Ok(Ty::Unknown);\n@@ -860,7 +860,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n \n         // resolve in module\n-        let resolved = ctry!(self.module.resolve_path(self.db, &path)?.take_values());\n+        let resolved = ctry!(self.module.resolve_path(self.db, &path).take_values());\n         let ty = self.db.type_for_def(resolved)?;\n         let ty = self.insert_type_vars(ty);\n         Ok(Some(ty))\n@@ -872,7 +872,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         } else {\n             return Ok((Ty::Unknown, None));\n         };\n-        let def_id = if let Some(def_id) = self.module.resolve_path(self.db, &path)?.take_types() {\n+        let def_id = if let Some(def_id) = self.module.resolve_path(self.db, &path).take_types() {\n             def_id\n         } else {\n             return Ok((Ty::Unknown, None));"}, {"sha": "42468681a9f15fd977f20c1e2d5a1386719c5d08", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=490112dea10d476e9b5829499bc6670f03f7d138", "patch": "@@ -8,13 +8,13 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) -> C\n         (Some(path), Some(module)) => (path.clone(), module),\n         _ => return Ok(()),\n     };\n-    let def_id = match module.resolve_path(ctx.db, &path)?.take_types() {\n+    let def_id = match module.resolve_path(ctx.db, &path).take_types() {\n         Some(it) => it,\n         None => return Ok(()),\n     };\n     match def_id.resolve(ctx.db) {\n         hir::Def::Module(module) => {\n-            let module_scope = module.scope(ctx.db)?;\n+            let module_scope = module.scope(ctx.db);\n             for (name, res) in module_scope.entries() {\n                 CompletionItem::new(CompletionKind::Reference, name.to_string())\n                     .from_resolution(ctx, res)"}, {"sha": "660c7d16e75fab0ce6f87b975ae75de5a713fb90", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=490112dea10d476e9b5829499bc6670f03f7d138", "patch": "@@ -19,7 +19,7 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) ->\n         complete_fn(acc, &scopes, ctx.offset);\n     }\n \n-    let module_scope = module.scope(ctx.db)?;\n+    let module_scope = module.scope(ctx.db);\n     let (file_id, _) = module.definition_source(ctx.db);\n     module_scope\n         .entries()"}, {"sha": "cdd8e211d51d0312fb2d7dc31fc0b79ba60cdb58", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490112dea10d476e9b5829499bc6670f03f7d138/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=490112dea10d476e9b5829499bc6670f03f7d138", "patch": "@@ -85,7 +85,7 @@ pub(crate) fn reference_definition(\n             .find_map(ast::Path::cast)\n             .and_then(hir::Path::from_ast)\n         {\n-            let resolved = module.resolve_path(db, &path)?;\n+            let resolved = module.resolve_path(db, &path);\n             if let Some(def_id) = resolved.take_types().or(resolved.take_values()) {\n                 if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)) {\n                     return Ok(Exact(target));"}]}