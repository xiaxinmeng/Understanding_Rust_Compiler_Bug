{"sha": "88451878f8eb12a32dbb0c1eded1a91cb6df8305", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NDUxODc4ZjhlYjEyYTMyZGJiMGMxZWRlZDFhOTFjYjZkZjgzMDU=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-03-06T01:02:23Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-03-06T17:41:47Z"}, "message": "removed unused abstraction over paths and value_paths", "tree": {"sha": "8c56227da1962bcc64c55da61d05f75d4ffcf87d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c56227da1962bcc64c55da61d05f75d4ffcf87d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88451878f8eb12a32dbb0c1eded1a91cb6df8305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88451878f8eb12a32dbb0c1eded1a91cb6df8305", "html_url": "https://github.com/rust-lang/rust/commit/88451878f8eb12a32dbb0c1eded1a91cb6df8305", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88451878f8eb12a32dbb0c1eded1a91cb6df8305/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67100ddb3519dedf8ab07371a381c7762f9fcc4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/67100ddb3519dedf8ab07371a381c7762f9fcc4f", "html_url": "https://github.com/rust-lang/rust/commit/67100ddb3519dedf8ab07371a381c7762f9fcc4f"}], "stats": {"total": 39, "additions": 14, "deletions": 25}, "files": [{"sha": "fc9158237032611185f56db38bbbb82bc1e705b0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88451878f8eb12a32dbb0c1eded1a91cb6df8305/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88451878f8eb12a32dbb0c1eded1a91cb6df8305/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=88451878f8eb12a32dbb0c1eded1a91cb6df8305", "patch": "@@ -105,6 +105,10 @@ pub struct Lifetime {\n     ident: ident\n }\n \n+// a \"Path\" is essentially Rust's notion of a name;\n+// for instance: core::cmp::Eq  .  It's represented\n+// as a sequence of identifiers, along with a bunch\n+// of supporting information.\n #[auto_encode]\n #[auto_decode]\n #[deriving_eq]"}, {"sha": "589b7693f9e3a4d5ea66cacdaa9a60d59d452fe1", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88451878f8eb12a32dbb0c1eded1a91cb6df8305/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88451878f8eb12a32dbb0c1eded1a91cb6df8305/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=88451878f8eb12a32dbb0c1eded1a91cb6df8305", "patch": "@@ -36,6 +36,7 @@ struct TtFrame {\n pub struct TtReader {\n     sp_diag: span_handler,\n     interner: @ident_interner,\n+    // the unzipped tree:\n     cur: @mut TtFrame,\n     /* for MBE-style macro transcription */\n     interpolations: std::oldmap::HashMap<ident, @named_match>,"}, {"sha": "7af2204fafd099333884073c8ad1d5407c0619d2", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88451878f8eb12a32dbb0c1eded1a91cb6df8305/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88451878f8eb12a32dbb0c1eded1a91cb6df8305/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=88451878f8eb12a32dbb0c1eded1a91cb6df8305", "patch": "@@ -119,10 +119,6 @@ pub impl Parser {\n                                                 id: self.get_id() })\n     }\n \n-    fn parse_value_ident(&self) -> ast::ident {\n-        return self.parse_ident();\n-    }\n-\n     // consume token 'tok' if it exists. Returns true if the given\n     // token was present, false otherwise.\n     fn eat(&self, tok: &token::Token) -> bool {"}, {"sha": "07fe5dec61d4968b99397542396b098c7c421d78", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/88451878f8eb12a32dbb0c1eded1a91cb6df8305/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88451878f8eb12a32dbb0c1eded1a91cb6df8305/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=88451878f8eb12a32dbb0c1eded1a91cb6df8305", "patch": "@@ -893,16 +893,9 @@ pub impl Parser {\n         codemap::spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n     }\n \n-    fn parse_path_without_tps(&self) -> @path {\n-        self.parse_path_without_tps_(|p| p.parse_ident(),\n-                                     |p| p.parse_ident())\n-    }\n-\n-    fn parse_path_without_tps_(\n-        &self,\n-        parse_ident: fn(&Parser) -> ident,\n-        parse_last_ident: fn(&Parser) -> ident\n-    ) -> @path {\n+    // parse a path that doesn't have type parameters attached\n+    fn parse_path_without_tps(&self)\n+        -> @ast::path {\n         maybe_whole!(self, nt_path);\n         let lo = self.span.lo;\n         let global = self.eat(&token::MOD_SEP);\n@@ -913,10 +906,10 @@ pub impl Parser {\n                 && self.look_ahead(1u) == token::MOD_SEP;\n \n             if is_not_last {\n-                ids.push(parse_ident(self));\n+                ids.push(self.parse_ident());\n                 self.expect(&token::MOD_SEP);\n             } else {\n-                ids.push(parse_last_ident(self));\n+                ids.push(self.parse_ident());\n                 break;\n             }\n         }\n@@ -927,12 +920,7 @@ pub impl Parser {\n                      types: ~[] }\n     }\n \n-    fn parse_value_path(&self) -> @path {\n-        self.parse_path_without_tps_(|p| p.parse_ident(),\n-                                     |p| p.parse_value_ident())\n-    }\n-\n-    fn parse_path_with_tps(&self, colons: bool) -> @path {\n+    fn parse_path_with_tps(&self, colons: bool) -> @ast::path {\n         debug!(\"parse_path_with_tps(colons=%b)\", colons);\n \n         maybe_whole!(self, nt_path);\n@@ -2282,7 +2270,7 @@ pub impl Parser {\n                 }\n \n                 if is_plain_ident(&*self.token) && cannot_be_enum_or_struct {\n-                    let name = self.parse_value_path();\n+                    let name = self.parse_path_without_tps();\n                     let sub;\n                     if self.eat(&token::AT) {\n                         sub = Some(self.parse_pat(refutable));\n@@ -2355,7 +2343,7 @@ pub impl Parser {\n                 *self.last_span,\n                 ~\"expected identifier, found path\");\n         }\n-        let name = self.parse_value_path();\n+        let name = self.parse_path_without_tps();\n         let sub = if self.eat(&token::AT) {\n             Some(self.parse_pat(refutable))\n         } else { None };\n@@ -2453,7 +2441,7 @@ pub impl Parser {\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n-            let pth = self.parse_value_path();\n+            let pth = self.parse_path_without_tps();\n             self.bump();\n \n             let id = if *self.token == token::LPAREN {"}]}