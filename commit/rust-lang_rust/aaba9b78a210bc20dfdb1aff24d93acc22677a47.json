{"sha": "aaba9b78a210bc20dfdb1aff24d93acc22677a47", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhYmE5Yjc4YTIxMGJjMjBkZmRiMWFmZjI0ZDkzYWNjMjI2NzdhNDc=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-31T18:58:17Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-31T19:35:34Z"}, "message": "Fix `redundant_clone` fp where the cloned value is modified while the clone is in use.", "tree": {"sha": "ef2bcd813381ec389744e1702f49640fa7ccb1d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef2bcd813381ec389744e1702f49640fa7ccb1d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aaba9b78a210bc20dfdb1aff24d93acc22677a47", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmBkzwwACgkQ2lnoZDo37QYHDQD/cZhCNmc+nUl2FxJUd/95fUhn\npsL3lCVeMEeraay6fb8BAPyre77ErM2YkaoAqFgX2wXJtx8L4CSrBfB11+mFr9sL\n=iCe0\n-----END PGP SIGNATURE-----", "payload": "tree ef2bcd813381ec389744e1702f49640fa7ccb1d3\nparent 44bf60f62d0036c12d7e2c8ecddf6fced973663f\nauthor Jason Newcomb <jsnewcomb@pm.me> 1617217097 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1617219334 -0400\n\nFix `redundant_clone` fp where the cloned value is modified while the clone is in use.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aaba9b78a210bc20dfdb1aff24d93acc22677a47", "html_url": "https://github.com/rust-lang/rust/commit/aaba9b78a210bc20dfdb1aff24d93acc22677a47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aaba9b78a210bc20dfdb1aff24d93acc22677a47/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44bf60f62d0036c12d7e2c8ecddf6fced973663f", "url": "https://api.github.com/repos/rust-lang/rust/commits/44bf60f62d0036c12d7e2c8ecddf6fced973663f", "html_url": "https://github.com/rust-lang/rust/commit/44bf60f62d0036c12d7e2c8ecddf6fced973663f"}], "stats": {"total": 320, "additions": 207, "deletions": 113}, "files": [{"sha": "9656ee64c818486332200eaa4118cd72a504599d", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 149, "deletions": 103, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/aaba9b78a210bc20dfdb1aff24d93acc22677a47/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaba9b78a210bc20dfdb1aff24d93acc22677a47/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=aaba9b78a210bc20dfdb1aff24d93acc22677a47", "patch": "@@ -199,79 +199,72 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 (local, deref_clone_ret)\n             };\n \n-            let is_temp = mir.local_kind(ret_local) == mir::LocalKind::Temp;\n-\n-            // 1. `local` can be moved out if it is not used later.\n-            // 2. If `ret_local` is a temporary and is neither consumed nor mutated, we can remove this `clone`\n-            // call anyway.\n-            let (used, consumed_or_mutated) = traversal::ReversePostorder::new(&mir, bb).skip(1).fold(\n-                (false, !is_temp),\n-                |(used, consumed), (tbb, tdata)| {\n-                    // Short-circuit\n-                    if (used && consumed) ||\n-                        // Give up on loops\n-                        tdata.terminator().successors().any(|s| *s == bb)\n-                    {\n-                        return (true, true);\n+            let clone_usage = if local == ret_local {\n+                CloneUsage {\n+                    cloned_used: false,\n+                    cloned_consume_or_mutate_loc: None,\n+                    clone_consumed_or_mutated: true,\n+                }\n+            } else {\n+                let clone_usage = visit_clone_usage(local, ret_local, &mir, bb);\n+                if clone_usage.cloned_used && clone_usage.clone_consumed_or_mutated {\n+                    // cloned value is used, and the clone is modified or moved\n+                    continue;\n+                } else if let Some(loc) = clone_usage.cloned_consume_or_mutate_loc {\n+                    // cloned value is mutated, and the clone is alive.\n+                    if possible_borrower.is_alive_at(ret_local, loc) {\n+                        continue;\n                     }\n+                }\n+                clone_usage\n+            };\n \n-                    let mut vis = LocalUseVisitor {\n-                        used: (local, false),\n-                        consumed_or_mutated: (ret_local, false),\n-                    };\n-                    vis.visit_basic_block_data(tbb, tdata);\n-                    (used || vis.used.1, consumed || vis.consumed_or_mutated.1)\n-                },\n-            );\n-\n-            if !used || !consumed_or_mutated {\n-                let span = terminator.source_info.span;\n-                let scope = terminator.source_info.scope;\n-                let node = mir.source_scopes[scope]\n-                    .local_data\n-                    .as_ref()\n-                    .assert_crate_local()\n-                    .lint_root;\n-\n-                if_chain! {\n-                    if let Some(snip) = snippet_opt(cx, span);\n-                    if let Some(dot) = snip.rfind('.');\n-                    then {\n-                        let sugg_span = span.with_lo(\n-                            span.lo() + BytePos(u32::try_from(dot).unwrap())\n-                        );\n-                        let mut app = Applicability::MaybeIncorrect;\n-\n-                        let call_snip = &snip[dot + 1..];\n-                        // Machine applicable when `call_snip` looks like `foobar()`\n-                        if let Some(call_snip) = call_snip.strip_suffix(\"()\").map(str::trim) {\n-                            if call_snip.as_bytes().iter().all(|b| b.is_ascii_alphabetic() || *b == b'_') {\n-                                app = Applicability::MachineApplicable;\n-                            }\n+            let span = terminator.source_info.span;\n+            let scope = terminator.source_info.scope;\n+            let node = mir.source_scopes[scope]\n+                .local_data\n+                .as_ref()\n+                .assert_crate_local()\n+                .lint_root;\n+\n+            if_chain! {\n+                if let Some(snip) = snippet_opt(cx, span);\n+                if let Some(dot) = snip.rfind('.');\n+                then {\n+                    let sugg_span = span.with_lo(\n+                        span.lo() + BytePos(u32::try_from(dot).unwrap())\n+                    );\n+                    let mut app = Applicability::MaybeIncorrect;\n+\n+                    let call_snip = &snip[dot + 1..];\n+                    // Machine applicable when `call_snip` looks like `foobar()`\n+                    if let Some(call_snip) = call_snip.strip_suffix(\"()\").map(str::trim) {\n+                        if call_snip.as_bytes().iter().all(|b| b.is_ascii_alphabetic() || *b == b'_') {\n+                            app = Applicability::MachineApplicable;\n                         }\n+                    }\n \n-                        span_lint_hir_and_then(cx, REDUNDANT_CLONE, node, sugg_span, \"redundant clone\", |diag| {\n-                            diag.span_suggestion(\n-                                sugg_span,\n-                                \"remove this\",\n-                                String::new(),\n-                                app,\n+                    span_lint_hir_and_then(cx, REDUNDANT_CLONE, node, sugg_span, \"redundant clone\", |diag| {\n+                        diag.span_suggestion(\n+                            sugg_span,\n+                            \"remove this\",\n+                            String::new(),\n+                            app,\n+                        );\n+                        if clone_usage.cloned_used {\n+                            diag.span_note(\n+                                span,\n+                                \"cloned value is neither consumed nor mutated\",\n                             );\n-                            if used {\n-                                diag.span_note(\n-                                    span,\n-                                    \"cloned value is neither consumed nor mutated\",\n-                                );\n-                            } else {\n-                                diag.span_note(\n-                                    span.with_hi(span.lo() + BytePos(u32::try_from(dot).unwrap())),\n-                                    \"this value is dropped without further use\",\n-                                );\n-                            }\n-                        });\n-                    } else {\n-                        span_lint_hir(cx, REDUNDANT_CLONE, node, span, \"redundant clone\");\n-                    }\n+                        } else {\n+                            diag.span_note(\n+                                span.with_hi(span.lo() + BytePos(u32::try_from(dot).unwrap())),\n+                                \"this value is dropped without further use\",\n+                            );\n+                        }\n+                    });\n+                } else {\n+                    span_lint_hir(cx, REDUNDANT_CLONE, node, span, \"redundant clone\");\n                 }\n             }\n         }\n@@ -365,49 +358,97 @@ fn base_local_and_movability<'tcx>(\n     (local, deref || field || slice)\n }\n \n-struct LocalUseVisitor {\n-    used: (mir::Local, bool),\n-    consumed_or_mutated: (mir::Local, bool),\n+#[derive(Default)]\n+struct CloneUsage {\n+    /// Whether the cloned value is used after the clone.\n+    cloned_used: bool,\n+    /// The first location where the cloned value is consumed or mutated, if any.\n+    cloned_consume_or_mutate_loc: Option<mir::Location>,\n+    /// Whether the clone value is mutated.\n+    clone_consumed_or_mutated: bool,\n }\n-\n-impl<'tcx> mir::visit::Visitor<'tcx> for LocalUseVisitor {\n-    fn visit_basic_block_data(&mut self, block: mir::BasicBlock, data: &mir::BasicBlockData<'tcx>) {\n-        let statements = &data.statements;\n-        for (statement_index, statement) in statements.iter().enumerate() {\n-            self.visit_statement(statement, mir::Location { block, statement_index });\n-        }\n-\n-        self.visit_terminator(\n-            data.terminator(),\n-            mir::Location {\n-                block,\n-                statement_index: statements.len(),\n-            },\n-        );\n+fn visit_clone_usage(cloned: mir::Local, clone: mir::Local, mir: &mir::Body<'_>, bb: mir::BasicBlock) -> CloneUsage {\n+    struct V {\n+        cloned: mir::Local,\n+        clone: mir::Local,\n+        result: CloneUsage,\n     }\n+    impl<'tcx> mir::visit::Visitor<'tcx> for V {\n+        fn visit_basic_block_data(&mut self, block: mir::BasicBlock, data: &mir::BasicBlockData<'tcx>) {\n+            let statements = &data.statements;\n+            for (statement_index, statement) in statements.iter().enumerate() {\n+                self.visit_statement(statement, mir::Location { block, statement_index });\n+            }\n \n-    fn visit_place(&mut self, place: &mir::Place<'tcx>, ctx: PlaceContext, _: mir::Location) {\n-        let local = place.local;\n-\n-        if local == self.used.0\n-            && !matches!(\n-                ctx,\n-                PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(_)\n-            )\n-        {\n-            self.used.1 = true;\n+            self.visit_terminator(\n+                data.terminator(),\n+                mir::Location {\n+                    block,\n+                    statement_index: statements.len(),\n+                },\n+            );\n         }\n \n-        if local == self.consumed_or_mutated.0 {\n-            match ctx {\n-                PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)\n-                | PlaceContext::MutatingUse(MutatingUseContext::Borrow) => {\n-                    self.consumed_or_mutated.1 = true;\n-                },\n-                _ => {},\n+        fn visit_place(&mut self, place: &mir::Place<'tcx>, ctx: PlaceContext, loc: mir::Location) {\n+            let local = place.local;\n+\n+            if local == self.cloned\n+                && !matches!(\n+                    ctx,\n+                    PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(_)\n+                )\n+            {\n+                self.result.cloned_used = true;\n+                self.result.cloned_consume_or_mutate_loc = self.result.cloned_consume_or_mutate_loc.or_else(|| {\n+                    matches!(\n+                        ctx,\n+                        PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)\n+                            | PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n+                    )\n+                    .then(|| loc)\n+                });\n+            } else if local == self.clone {\n+                match ctx {\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)\n+                    | PlaceContext::MutatingUse(MutatingUseContext::Borrow) => {\n+                        self.result.clone_consumed_or_mutated = true;\n+                    },\n+                    _ => {},\n+                }\n             }\n         }\n     }\n+\n+    let init = CloneUsage {\n+        cloned_used: false,\n+        cloned_consume_or_mutate_loc: None,\n+        // Consider non-temporary clones consumed.\n+        // TODO: Actually check for mutation of non-temporaries.\n+        clone_consumed_or_mutated: mir.local_kind(clone) != mir::LocalKind::Temp,\n+    };\n+    traversal::ReversePostorder::new(&mir, bb)\n+        .skip(1)\n+        .fold(init, |usage, (tbb, tdata)| {\n+            // Short-circuit\n+            if (usage.cloned_used && usage.clone_consumed_or_mutated) ||\n+                // Give up on loops\n+                tdata.terminator().successors().any(|s| *s == bb)\n+            {\n+                return CloneUsage {\n+                    cloned_used: true,\n+                    clone_consumed_or_mutated: true,\n+                    ..usage\n+                };\n+            }\n+\n+            let mut v = V {\n+                cloned,\n+                clone,\n+                result: usage,\n+            };\n+            v.visit_basic_block_data(tbb, tdata);\n+            v.result\n+        })\n }\n \n /// Determines liveness of each local purely based on `StorageLive`/`Dead`.\n@@ -623,4 +664,9 @@ impl PossibleBorrowerMap<'_, '_> {\n \n         self.bitset.0 == self.bitset.1\n     }\n+\n+    fn is_alive_at(&mut self, local: mir::Local, at: mir::Location) -> bool {\n+        self.maybe_live.seek_after_primary_effect(at);\n+        self.maybe_live.contains(local)\n+    }\n }"}, {"sha": "f5da703cd1dea5e9d524f8c2950ec629525faec2", "filename": "tests/ui/redundant_clone.fixed", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aaba9b78a210bc20dfdb1aff24d93acc22677a47/tests%2Fui%2Fredundant_clone.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/aaba9b78a210bc20dfdb1aff24d93acc22677a47/tests%2Fui%2Fredundant_clone.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.fixed?ref=aaba9b78a210bc20dfdb1aff24d93acc22677a47", "patch": "@@ -54,6 +54,7 @@ fn main() {\n     not_consumed();\n     issue_5405();\n     manually_drop();\n+    clone_then_move_cloned();\n }\n \n #[derive(Clone)]\n@@ -182,3 +183,26 @@ fn manually_drop() {\n         Arc::from_raw(p);\n     }\n }\n+\n+fn clone_then_move_cloned() {\n+    // issue #5973\n+    let x = Some(String::new());\n+    // ok, x is moved while the clone is in use.\n+    assert_eq!(x.clone(), None, \"not equal {}\", x.unwrap());\n+\n+    // issue #5595\n+    fn foo<F: Fn()>(_: &Alpha, _: F) {}\n+    let x = Alpha;\n+    // ok, data is moved while the clone is in use.\n+    foo(&x.clone(), move || {\n+        let _ = x;\n+    });\n+\n+    // issue #6998\n+    struct S(String);\n+    impl S {\n+        fn m(&mut self) {}\n+    }\n+    let mut x = S(String::new());\n+    x.0.clone().chars().for_each(|_| x.m());\n+}"}, {"sha": "fd7f31a1cc5b6b944a635ff0282477600f7268b7", "filename": "tests/ui/redundant_clone.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aaba9b78a210bc20dfdb1aff24d93acc22677a47/tests%2Fui%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaba9b78a210bc20dfdb1aff24d93acc22677a47/tests%2Fui%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.rs?ref=aaba9b78a210bc20dfdb1aff24d93acc22677a47", "patch": "@@ -54,6 +54,7 @@ fn main() {\n     not_consumed();\n     issue_5405();\n     manually_drop();\n+    clone_then_move_cloned();\n }\n \n #[derive(Clone)]\n@@ -182,3 +183,26 @@ fn manually_drop() {\n         Arc::from_raw(p);\n     }\n }\n+\n+fn clone_then_move_cloned() {\n+    // issue #5973\n+    let x = Some(String::new());\n+    // ok, x is moved while the clone is in use.\n+    assert_eq!(x.clone(), None, \"not equal {}\", x.unwrap());\n+\n+    // issue #5595\n+    fn foo<F: Fn()>(_: &Alpha, _: F) {}\n+    let x = Alpha;\n+    // ok, data is moved while the clone is in use.\n+    foo(&x.clone(), move || {\n+        let _ = x;\n+    });\n+\n+    // issue #6998\n+    struct S(String);\n+    impl S {\n+        fn m(&mut self) {}\n+    }\n+    let mut x = S(String::new());\n+    x.0.clone().chars().for_each(|_| x.m());\n+}"}, {"sha": "529a6de91e266baa93294822e2337b1401e035b2", "filename": "tests/ui/redundant_clone.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aaba9b78a210bc20dfdb1aff24d93acc22677a47/tests%2Fui%2Fredundant_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aaba9b78a210bc20dfdb1aff24d93acc22677a47/tests%2Fui%2Fredundant_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.stderr?ref=aaba9b78a210bc20dfdb1aff24d93acc22677a47", "patch": "@@ -108,61 +108,61 @@ LL |     let _t = tup.0.clone();\n    |              ^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:62:25\n+  --> $DIR/redundant_clone.rs:63:25\n    |\n LL |     if b { (a.clone(), a.clone()) } else { (Alpha, a) }\n    |                         ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:62:24\n+  --> $DIR/redundant_clone.rs:63:24\n    |\n LL |     if b { (a.clone(), a.clone()) } else { (Alpha, a) }\n    |                        ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:119:15\n+  --> $DIR/redundant_clone.rs:120:15\n    |\n LL |     let _s = s.clone();\n    |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:119:14\n+  --> $DIR/redundant_clone.rs:120:14\n    |\n LL |     let _s = s.clone();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:120:15\n+  --> $DIR/redundant_clone.rs:121:15\n    |\n LL |     let _t = t.clone();\n    |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:120:14\n+  --> $DIR/redundant_clone.rs:121:14\n    |\n LL |     let _t = t.clone();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:130:19\n+  --> $DIR/redundant_clone.rs:131:19\n    |\n LL |         let _f = f.clone();\n    |                   ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:130:18\n+  --> $DIR/redundant_clone.rs:131:18\n    |\n LL |         let _f = f.clone();\n    |                  ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:142:14\n+  --> $DIR/redundant_clone.rs:143:14\n    |\n LL |     let y = x.clone().join(\"matthias\");\n    |              ^^^^^^^^ help: remove this\n    |\n note: cloned value is neither consumed nor mutated\n-  --> $DIR/redundant_clone.rs:142:13\n+  --> $DIR/redundant_clone.rs:143:13\n    |\n LL |     let y = x.clone().join(\"matthias\");\n    |             ^^^^^^^^^"}]}