{"sha": "59eb44407652f5b66a66231f12f66f89c5df5c5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZWI0NDQwNzY1MmY1YjY2YTY2MjMxZjEyZjY2Zjg5YzVkZjVjNWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-29T21:32:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-29T21:32:39Z"}, "message": "Auto merge of #28715 - petrochenkov:visit, r=nrc\n\nSome minor parts of AST and HIR were not visited by the `visit::walk_xxx` methods - some identifiers, lifetimes, loop labels, attributes of exported macros - but nothing as serious as in, for example, https://github.com/rust-lang/rust/pull/28364.\r\n\\+ Added a convenience macro for visiting lists (including Options)\r\n\\+ Removed some pre-Deref-coersions `&**` noise from visitors\r\n\r\nr? @nrc", "tree": {"sha": "c9138eb7b2cab13ef942a9a21dfb8a8a5dde1dbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9138eb7b2cab13ef942a9a21dfb8a8a5dde1dbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59eb44407652f5b66a66231f12f66f89c5df5c5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59eb44407652f5b66a66231f12f66f89c5df5c5f", "html_url": "https://github.com/rust-lang/rust/commit/59eb44407652f5b66a66231f12f66f89c5df5c5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59eb44407652f5b66a66231f12f66f89c5df5c5f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19fe7b6d6444424403be07699a8a312562ede51f", "url": "https://api.github.com/repos/rust-lang/rust/commits/19fe7b6d6444424403be07699a8a312562ede51f", "html_url": "https://github.com/rust-lang/rust/commit/19fe7b6d6444424403be07699a8a312562ede51f"}, {"sha": "4764d98223bfca20e10d87a80b11f658aab01906", "url": "https://api.github.com/repos/rust-lang/rust/commits/4764d98223bfca20e10d87a80b11f658aab01906", "html_url": "https://github.com/rust-lang/rust/commit/4764d98223bfca20e10d87a80b11f658aab01906"}], "stats": {"total": 1265, "additions": 552, "deletions": 713}, "files": [{"sha": "16c455537b69a29f2ab1da611d505dbf4de01ed3", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -912,12 +912,12 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.parent_node = parent_node;\n     }\n \n-    fn visit_lifetime_ref(&mut self, lifetime: &'ast Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n \n     fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n-        self.visit_lifetime_ref(&def.lifetime);\n+        self.visit_lifetime(&def.lifetime);\n     }\n }\n "}, {"sha": "36236efe50d2c38e8e81fc5ef38afa77c4aeb394", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -745,12 +745,8 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<hir::Lifetime>) {\n-        run_lints!(self, check_opt_lifetime_ref, late_passes, sp, lt);\n-    }\n-\n-    fn visit_lifetime_ref(&mut self, lt: &hir::Lifetime) {\n-        run_lints!(self, check_lifetime_ref, late_passes, lt);\n+    fn visit_lifetime(&mut self, lt: &hir::Lifetime) {\n+        run_lints!(self, check_lifetime, late_passes, lt);\n     }\n \n     fn visit_lifetime_def(&mut self, lt: &hir::LifetimeDef) {\n@@ -898,12 +894,8 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n         });\n     }\n \n-    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>) {\n-        run_lints!(self, check_opt_lifetime_ref, early_passes, sp, lt);\n-    }\n-\n-    fn visit_lifetime_ref(&mut self, lt: &ast::Lifetime) {\n-        run_lints!(self, check_lifetime_ref, early_passes, lt);\n+    fn visit_lifetime(&mut self, lt: &ast::Lifetime) {\n+        run_lints!(self, check_lifetime, early_passes, lt);\n     }\n \n     fn visit_lifetime_def(&mut self, lt: &ast::LifetimeDef) {"}, {"sha": "5c316b58303fe5a2ee8377bb3fa17265658b5730", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -156,8 +156,7 @@ pub trait LateLintPass: LintPass {\n     fn check_struct_field(&mut self, _: &LateContext, _: &hir::StructField) { }\n     fn check_variant(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n     fn check_variant_post(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n-    fn check_opt_lifetime_ref(&mut self, _: &LateContext, _: Span, _: &Option<hir::Lifetime>) { }\n-    fn check_lifetime_ref(&mut self, _: &LateContext, _: &hir::Lifetime) { }\n+    fn check_lifetime(&mut self, _: &LateContext, _: &hir::Lifetime) { }\n     fn check_lifetime_def(&mut self, _: &LateContext, _: &hir::LifetimeDef) { }\n     fn check_explicit_self(&mut self, _: &LateContext, _: &hir::ExplicitSelf) { }\n     fn check_path(&mut self, _: &LateContext, _: &hir::Path, _: ast::NodeId) { }\n@@ -199,11 +198,7 @@ pub trait EarlyLintPass: LintPass {\n     fn check_struct_field(&mut self, _: &EarlyContext, _: &ast::StructField) { }\n     fn check_variant(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n     fn check_variant_post(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n-    fn check_opt_lifetime_ref(&mut self,\n-                              _: &EarlyContext,\n-                              _: Span,\n-                              _: &Option<ast::Lifetime>) { }\n-    fn check_lifetime_ref(&mut self, _: &EarlyContext, _: &ast::Lifetime) { }\n+    fn check_lifetime(&mut self, _: &EarlyContext, _: &ast::Lifetime) { }\n     fn check_lifetime_def(&mut self, _: &EarlyContext, _: &ast::LifetimeDef) { }\n     fn check_explicit_self(&mut self, _: &EarlyContext, _: &ast::ExplicitSelf) { }\n     fn check_path(&mut self, _: &EarlyContext, _: &ast::Path, _: ast::NodeId) { }"}, {"sha": "4492b0565d2fc44a290930c7e444951056a71a7c", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -481,6 +481,12 @@ impl<'a> CrateReader<'a> {\n                 };\n                 let span = mk_sp(lo, p.last_span.hi);\n                 p.abort_if_errors();\n+\n+                // Mark the attrs as used\n+                for attr in &attrs {\n+                    attr::mark_used(attr);\n+                }\n+\n                 macros.push(ast::MacroDef {\n                     ident: ast::Ident::with_empty_ctxt(name),\n                     attrs: attrs,"}, {"sha": "0f9ba50e78855b6324e0b289367bffe575bfef65", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -705,7 +705,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &hir::Block) {\n             }\n             visitor.visit_stmt(&**statement)\n         }\n-        visit::walk_expr_opt(visitor, &blk.expr)\n+        walk_list!(visitor, visit_expr, &blk.expr);\n     }\n \n     visitor.cx = prev_cx;"}, {"sha": "d9398a1c58cd9a65ca4f9dd8822d03f519889e4f", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -195,7 +195,6 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n         match ty.node {\n             hir::TyBareFn(ref c) => {\n-                visit::walk_lifetime_decls_helper(self, &c.lifetimes);\n                 self.with(LateScope(&c.lifetimes, self.scope), |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n                     // contained within is scoped within its binder.\n@@ -245,7 +244,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                   |_, this| visit::walk_block(this, b));\n     }\n \n-    fn visit_lifetime_ref(&mut self, lifetime_ref: &hir::Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n         if lifetime_ref.name == special_idents::static_lifetime.name {\n             self.insert_lifetime(lifetime_ref, DefStaticRegion);\n             return;\n@@ -255,7 +254,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n \n     fn visit_generics(&mut self, generics: &hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            visit::walk_ty_param_bounds_helper(self, &ty_param.bounds);\n+            walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n             match ty_param.default {\n                 Some(ref ty) => self.visit_ty(&**ty),\n                 None => {}\n@@ -273,22 +272,22 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                                                |old_scope, this| {\n                             this.check_lifetime_defs(old_scope, bound_lifetimes);\n                             this.visit_ty(&**bounded_ty);\n-                            visit::walk_ty_param_bounds_helper(this, bounds);\n+                            walk_list!(this, visit_ty_param_bound, bounds);\n                         });\n                         self.trait_ref_hack = false;\n                         result\n                     } else {\n                         self.visit_ty(&**bounded_ty);\n-                        visit::walk_ty_param_bounds_helper(self, bounds);\n+                        walk_list!(self, visit_ty_param_bound, bounds);\n                     }\n                 }\n                 &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,\n                                                                                 ref bounds,\n                                                                                 .. }) => {\n \n-                    self.visit_lifetime_ref(lifetime);\n+                    self.visit_lifetime(lifetime);\n                     for bound in bounds {\n-                        self.visit_lifetime_ref(bound);\n+                        self.visit_lifetime(bound);\n                     }\n                 }\n                 &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ id,\n@@ -799,23 +798,23 @@ fn early_bound_lifetime_names(generics: &hir::Generics) -> Vec<ast::Name> {\n             FreeLifetimeCollector { early_bound: &mut early_bound,\n                                     late_bound: &mut late_bound };\n         for ty_param in generics.ty_params.iter() {\n-            visit::walk_ty_param_bounds_helper(&mut collector, &ty_param.bounds);\n+            walk_list!(&mut collector, visit_ty_param_bound, &ty_param.bounds);\n         }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{ref bounds,\n                                                                               ref bounded_ty,\n                                                                               ..}) => {\n                     collector.visit_ty(&**bounded_ty);\n-                    visit::walk_ty_param_bounds_helper(&mut collector, bounds);\n+                    walk_list!(&mut collector, visit_ty_param_bound, bounds);\n                 }\n                 &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,\n                                                                                 ref bounds,\n                                                                                 ..}) => {\n-                    collector.visit_lifetime_ref(lifetime);\n+                    collector.visit_lifetime(lifetime);\n \n                     for bound in bounds {\n-                        collector.visit_lifetime_ref(bound);\n+                        collector.visit_lifetime(bound);\n                     }\n                 }\n                 &hir::WherePredicate::EqPredicate(_) => unimplemented!()\n@@ -843,7 +842,7 @@ fn early_bound_lifetime_names(generics: &hir::Generics) -> Vec<ast::Name> {\n     }\n \n     impl<'a, 'v> Visitor<'v> for FreeLifetimeCollector<'a> {\n-        fn visit_lifetime_ref(&mut self, lifetime_ref: &hir::Lifetime) {\n+        fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n             shuffle(self.early_bound, self.late_bound,\n                     lifetime_ref.name);\n         }"}, {"sha": "25b4cfad01ce0e3a43cd2f80c97f7e99b2e39af3", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -177,7 +177,7 @@ mod svh_visitor {\n         SawIdent(token::InternedString),\n         SawStructDef(token::InternedString),\n \n-        SawLifetimeRef(token::InternedString),\n+        SawLifetime(token::InternedString),\n         SawLifetimeDef(token::InternedString),\n \n         SawMod,\n@@ -193,7 +193,6 @@ mod svh_visitor {\n         SawVariant,\n         SawExplicitSelf,\n         SawPath,\n-        SawOptLifetimeRef,\n         SawBlock,\n         SawPat,\n         SawLocal,\n@@ -316,17 +315,6 @@ mod svh_visitor {\n             visit::walk_variant(self, v, g)\n         }\n \n-        fn visit_opt_lifetime_ref(&mut self, _: Span, l: &Option<Lifetime>) {\n-            SawOptLifetimeRef.hash(self.st);\n-            // (This is a strange method in the visitor trait, in that\n-            // it does not expose a walk function to do the subroutine\n-            // calls.)\n-            match *l {\n-                Some(ref l) => self.visit_lifetime_ref(l),\n-                None => ()\n-            }\n-        }\n-\n         // All of the remaining methods just record (in the hash\n         // SipHasher) that the visitor saw that particular variant\n         // (with its payload), and continue walking as the default\n@@ -345,8 +333,8 @@ mod svh_visitor {\n             SawIdent(name.as_str()).hash(self.st);\n         }\n \n-        fn visit_lifetime_ref(&mut self, l: &Lifetime) {\n-            SawLifetimeRef(l.name.as_str()).hash(self.st);\n+        fn visit_lifetime(&mut self, l: &Lifetime) {\n+            SawLifetime(l.name.as_str()).hash(self.st);\n         }\n \n         fn visit_lifetime_def(&mut self, l: &LifetimeDef) {"}, {"sha": "a447453e9ed9e46596e830bdcaca876959ae79e0", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -1054,6 +1054,13 @@ impl PathListItem_ {\n         }\n     }\n \n+    pub fn name(&self) -> Option<Name> {\n+        match *self {\n+            PathListIdent { name, .. } => Some(name),\n+            PathListMod { .. } => None,\n+        }\n+    }\n+\n     pub fn rename(&self) -> Option<Name> {\n         match *self {\n             PathListIdent { rename, .. } | PathListMod { rename, .. } => rename"}, {"sha": "f7a0f03e4f1a88c436c15dcdcbff2dbecd224ad3", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -303,12 +303,12 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n         visit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_lifetime_ref(&mut self, lifetime: &Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n         self.operation.visit_id(lifetime.id);\n     }\n \n     fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n-        self.visit_lifetime_ref(&def.lifetime);\n+        self.visit_lifetime(&def.lifetime);\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: &TraitRef) {"}, {"sha": "149b734884634005fe90cc994a214e0e2284a362", "filename": "src/librustc_front/visit.rs", "status": "modified", "additions": 218, "deletions": 312, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_front%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_front%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fvisit.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -25,11 +25,8 @@\n \n use syntax::abi::Abi;\n use syntax::ast::{Ident, NodeId, CRATE_NODE_ID, Name, Attribute};\n-use hir::*;\n-use hir;\n use syntax::codemap::Span;\n-use syntax::ptr::P;\n-use syntax::owned_slice::OwnedSlice;\n+use hir::*;\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n@@ -39,8 +36,7 @@ pub enum FnKind<'a> {\n     /// fn foo(&self)\n     Method(Name, &'a MethodSig, Option<Visibility>),\n \n-    /// |x, y| ...\n-    /// proc(x, y) ...\n+    /// |x, y| {}\n     Closure,\n }\n \n@@ -57,7 +53,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n-    fn visit_ident(&mut self, span: Span, ident: Ident) { walk_ident(self, span, ident) }\n+    fn visit_ident(&mut self, span: Span, ident: Ident) {\n+        walk_ident(self, span, ident);\n+    }\n     fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n     fn visit_foreign_item(&mut self, i: &'v ForeignItem) { walk_foreign_item(self, i) }\n     fn visit_item(&mut self, i: &'v Item) { walk_item(self, i) }\n@@ -94,21 +92,8 @@ pub trait Visitor<'v> : Sized {\n \n     fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics) { walk_variant(self, v, g) }\n \n-    /// Visits an optional reference to a lifetime. The `span` is the span of some surrounding\n-    /// reference should opt_lifetime be None.\n-    fn visit_opt_lifetime_ref(&mut self,\n-                              _span: Span,\n-                              opt_lifetime: &'v Option<Lifetime>) {\n-        match *opt_lifetime {\n-            Some(ref l) => self.visit_lifetime_ref(l),\n-            None => ()\n-        }\n-    }\n-    fn visit_lifetime_bound(&mut self, lifetime: &'v Lifetime) {\n-        walk_lifetime_bound(self, lifetime)\n-    }\n-    fn visit_lifetime_ref(&mut self, lifetime: &'v Lifetime) {\n-        walk_lifetime_ref(self, lifetime)\n+    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n+        walk_lifetime(self, lifetime)\n     }\n     fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n@@ -132,6 +117,21 @@ pub trait Visitor<'v> : Sized {\n         walk_assoc_type_binding(self, type_binding)\n     }\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n+    fn visit_macro_def(&mut self, macro_def: &'v MacroDef) {\n+        walk_macro_def(self, macro_def)\n+    }\n+}\n+\n+pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n+    for name in opt_name {\n+        visitor.visit_name(span, name);\n+    }\n+}\n+\n+pub fn walk_opt_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n+    for ident in opt_ident {\n+        visitor.visit_ident(span, ident);\n+    }\n }\n \n pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, ident: Ident) {\n@@ -140,49 +140,51 @@ pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, ident: Ident)\n \n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n-    for attr in &krate.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_attribute, &krate.attrs);\n+    walk_list!(visitor, visit_macro_def, &krate.exported_macros);\n }\n \n-pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n-    for item in &module.items {\n-        visitor.visit_item(&**item)\n-    }\n+pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef) {\n+    visitor.visit_name(macro_def.span, macro_def.name);\n+    walk_opt_name(visitor, macro_def.span, macro_def.imported_from);\n+    walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n \n-pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n-    visitor.visit_pat(&*local.pat);\n-    walk_ty_opt(visitor, &local.ty);\n-    walk_expr_opt(visitor, &local.init);\n+pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n+    walk_list!(visitor, visit_item, &module.items);\n }\n \n-pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                              lifetime_def: &'v LifetimeDef) {\n-    visitor.visit_name(lifetime_def.lifetime.span, lifetime_def.lifetime.name);\n-    for bound in &lifetime_def.bounds {\n-        visitor.visit_lifetime_bound(bound);\n-    }\n+pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n+    visitor.visit_pat(&local.pat);\n+    walk_list!(visitor, visit_ty, &local.ty);\n+    walk_list!(visitor, visit_expr, &local.init);\n }\n \n-pub fn walk_lifetime_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                               lifetime_ref: &'v Lifetime) {\n-    visitor.visit_lifetime_ref(lifetime_ref)\n+pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n+    visitor.visit_name(lifetime.span, lifetime.name);\n }\n \n-pub fn walk_lifetime_ref<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             lifetime_ref: &'v Lifetime) {\n-    visitor.visit_name(lifetime_ref.span, lifetime_ref.name)\n+pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                              lifetime_def: &'v LifetimeDef) {\n+    visitor.visit_lifetime(&lifetime_def.lifetime);\n+    walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n }\n \n pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n                                               explicit_self: &'v ExplicitSelf) {\n     match explicit_self.node {\n-        SelfStatic | SelfValue(_) => {},\n-        SelfRegion(ref lifetime, _, _) => {\n-            visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime)\n+        SelfStatic => {},\n+        SelfValue(name) => {\n+            visitor.visit_name(explicit_self.span, name)\n+        }\n+        SelfRegion(ref opt_lifetime, _, name) => {\n+            visitor.visit_name(explicit_self.span, name);\n+            walk_list!(visitor, visit_lifetime, opt_lifetime);\n+        }\n+        SelfExplicit(ref typ, name) => {\n+            visitor.visit_name(explicit_self.span, name);\n+            visitor.visit_ty(typ)\n         }\n-        SelfExplicit(ref typ, _) => visitor.visit_ty(&**typ),\n     }\n }\n \n@@ -191,7 +193,7 @@ pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   _modifier: &'v TraitBoundModifier)\n     where V: Visitor<'v>\n {\n-    walk_lifetime_decls_helper(visitor, &trait_ref.bound_lifetimes);\n+    walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n@@ -205,7 +207,9 @@ pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_name(item.span, item.name);\n     match item.node {\n-        ItemExternCrate(..) => {}\n+        ItemExternCrate(opt_name) => {\n+            walk_opt_name(visitor, item.span, opt_name)\n+        }\n         ItemUse(ref vp) => {\n             match vp.node {\n                 ViewPathSimple(name, ref path) => {\n@@ -228,27 +232,25 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemStatic(ref typ, _, ref expr) |\n         ItemConst(ref typ, ref expr) => {\n-            visitor.visit_ty(&**typ);\n-            visitor.visit_expr(&**expr);\n+            visitor.visit_ty(typ);\n+            visitor.visit_expr(expr);\n         }\n         ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n             visitor.visit_fn(FnKind::ItemFn(item.name, generics, unsafety,\n                                             constness, abi, item.vis),\n-                             &**declaration,\n-                             &**body,\n+                             declaration,\n+                             body,\n                              item.span,\n                              item.id)\n         }\n         ItemMod(ref module) => {\n             visitor.visit_mod(module, item.span, item.id)\n         }\n         ItemForeignMod(ref foreign_module) => {\n-            for foreign_item in &foreign_module.items {\n-                visitor.visit_foreign_item(&**foreign_item)\n-            }\n+            walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n         ItemTy(ref typ, ref type_parameters) => {\n-            visitor.visit_ty(&**typ);\n+            visitor.visit_ty(typ);\n             visitor.visit_generics(type_parameters)\n         }\n         ItemEnum(ref enum_definition, ref type_parameters) => {\n@@ -260,44 +262,35 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemImpl(_, _,\n                  ref type_parameters,\n-                 ref trait_reference,\n+                 ref opt_trait_reference,\n                  ref typ,\n                  ref impl_items) => {\n             visitor.visit_generics(type_parameters);\n-            match *trait_reference {\n-                Some(ref trait_reference) => visitor.visit_trait_ref(trait_reference),\n-                None => ()\n-            }\n-            visitor.visit_ty(&**typ);\n-            for impl_item in impl_items {\n-                visitor.visit_impl_item(impl_item);\n-            }\n+            walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n+            visitor.visit_ty(typ);\n+            walk_list!(visitor, visit_impl_item, impl_items);\n         }\n         ItemStruct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_struct_def(&**struct_definition,\n+            visitor.visit_struct_def(struct_definition,\n                                      item.name,\n                                      generics,\n                                      item.id)\n         }\n         ItemTrait(_, ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n-            walk_ty_param_bounds_helper(visitor, bounds);\n-            for method in methods {\n-                visitor.visit_trait_item(method)\n-            }\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_trait_item, methods);\n         }\n     }\n-    for attr in &item.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_attribute, &item.attrs);\n }\n \n pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                          enum_definition: &'v EnumDef,\n                                          generics: &'v Generics) {\n     for variant in &enum_definition.variants {\n-        visitor.visit_variant(&**variant, generics);\n+        visitor.visit_variant(variant, generics);\n     }\n }\n \n@@ -309,59 +302,38 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n     match variant.node.kind {\n         TupleVariantKind(ref variant_arguments) => {\n             for variant_argument in variant_arguments {\n-                visitor.visit_ty(&*variant_argument.ty)\n+                visitor.visit_ty(&variant_argument.ty)\n             }\n         }\n         StructVariantKind(ref struct_definition) => {\n-            visitor.visit_struct_def(&**struct_definition,\n+            visitor.visit_struct_def(struct_definition,\n                                      variant.node.name,\n                                      generics,\n                                      variant.node.id)\n         }\n     }\n-    match variant.node.disr_expr {\n-        Some(ref expr) => visitor.visit_expr(&**expr),\n-        None => ()\n-    }\n-    for attr in &variant.node.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n-}\n-\n-pub fn skip_ty<'v, V: Visitor<'v>>(_: &mut V, _: &'v Ty) {\n-    // Empty!\n-}\n-\n-pub fn walk_ty_opt<'v, V: Visitor<'v>>(visitor: &mut V, optional_type: &'v Option<P<Ty>>) {\n-    match *optional_type {\n-        Some(ref ty) => visitor.visit_ty(&**ty),\n-        None => ()\n-    }\n+    walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n+    walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     match typ.node {\n         TyVec(ref ty) | TyParen(ref ty) => {\n-            visitor.visit_ty(&**ty)\n+            visitor.visit_ty(ty)\n         }\n         TyPtr(ref mutable_type) => {\n-            visitor.visit_ty(&*mutable_type.ty)\n+            visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyRptr(ref lifetime, ref mutable_type) => {\n-            visitor.visit_opt_lifetime_ref(typ.span, lifetime);\n-            visitor.visit_ty(&*mutable_type.ty)\n+        TyRptr(ref opt_lifetime, ref mutable_type) => {\n+            walk_list!(visitor, visit_lifetime, opt_lifetime);\n+            visitor.visit_ty(&mutable_type.ty)\n         }\n         TyTup(ref tuple_element_types) => {\n-            for tuple_element_type in tuple_element_types {\n-                visitor.visit_ty(&**tuple_element_type)\n-            }\n+            walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n         TyBareFn(ref function_declaration) => {\n-            for argument in &function_declaration.decl.inputs {\n-                visitor.visit_ty(&*argument.ty)\n-            }\n-            walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n-            walk_lifetime_decls_helper(visitor, &function_declaration.lifetimes);\n+            walk_fn_decl(visitor, &function_declaration.decl);\n+            walk_list!(visitor, visit_lifetime_def, &function_declaration.lifetimes);\n         }\n         TyPath(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n@@ -370,30 +342,23 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_path(path, typ.id);\n         }\n         TyObjectSum(ref ty, ref bounds) => {\n-            visitor.visit_ty(&**ty);\n-            walk_ty_param_bounds_helper(visitor, bounds);\n+            visitor.visit_ty(ty);\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyFixedLengthVec(ref ty, ref expression) => {\n-            visitor.visit_ty(&**ty);\n-            visitor.visit_expr(&**expression)\n+            visitor.visit_ty(ty);\n+            visitor.visit_expr(expression)\n         }\n         TyPolyTraitRef(ref bounds) => {\n-            walk_ty_param_bounds_helper(visitor, bounds)\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyTypeof(ref expression) => {\n-            visitor.visit_expr(&**expression)\n+            visitor.visit_expr(expression)\n         }\n         TyInfer => {}\n     }\n }\n \n-pub fn walk_lifetime_decls_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                                      lifetimes: &'v Vec<LifetimeDef>) {\n-    for l in lifetimes {\n-        visitor.visit_lifetime_def(l);\n-    }\n-}\n-\n pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n@@ -406,9 +371,8 @@ pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V, prefix: &'v Path\n         visitor.visit_path_segment(prefix.span, segment);\n     }\n \n-    if let PathListIdent { name, .. } = item.node {\n-        visitor.visit_name(item.span, name);\n-    }\n+    walk_opt_name(visitor, item.span, item.node.name());\n+    walk_opt_name(visitor, item.span, item.node.rename());\n }\n \n pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n@@ -422,42 +386,30 @@ pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                 _path_span: Span,\n                                                 path_parameters: &'v PathParameters) {\n     match *path_parameters {\n-        hir::AngleBracketedParameters(ref data) => {\n-            for typ in data.types.iter() {\n-                visitor.visit_ty(&**typ);\n-            }\n-            for lifetime in &data.lifetimes {\n-                visitor.visit_lifetime_ref(lifetime);\n-            }\n-            for binding in data.bindings.iter() {\n-                visitor.visit_assoc_type_binding(&**binding);\n-            }\n+        AngleBracketedParameters(ref data) => {\n+            walk_list!(visitor, visit_ty, &data.types);\n+            walk_list!(visitor, visit_lifetime, &data.lifetimes);\n+            walk_list!(visitor, visit_assoc_type_binding, &data.bindings);\n         }\n-        hir::ParenthesizedParameters(ref data) => {\n-            for typ in &data.inputs {\n-                visitor.visit_ty(&**typ);\n-            }\n-            if let Some(ref typ) = data.output {\n-                visitor.visit_ty(&**typ);\n-            }\n+        ParenthesizedParameters(ref data) => {\n+            walk_list!(visitor, visit_ty, &data.inputs);\n+            walk_list!(visitor, visit_ty, &data.output);\n         }\n     }\n }\n \n pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                    type_binding: &'v TypeBinding) {\n     visitor.visit_name(type_binding.span, type_binding.name);\n-    visitor.visit_ty(&*type_binding.ty);\n+    visitor.visit_ty(&type_binding.ty);\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n-        PatEnum(ref path, ref children) => {\n+        PatEnum(ref path, ref opt_children) => {\n             visitor.visit_path(path, pattern.id);\n-            if let Some(ref children) = *children {\n-                for child in children {\n-                    visitor.visit_pat(&*child)\n-                }\n+            if let Some(ref children) = *opt_children {\n+                walk_list!(visitor, visit_pat, children);\n             }\n         }\n         PatQPath(ref qself, ref path) => {\n@@ -467,41 +419,31 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatStruct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id);\n             for field in fields {\n-                visitor.visit_pat(&*field.node.pat)\n+                visitor.visit_name(field.span, field.node.name);\n+                visitor.visit_pat(&field.node.pat)\n             }\n         }\n         PatTup(ref tuple_elements) => {\n-            for tuple_element in tuple_elements {\n-                visitor.visit_pat(&**tuple_element)\n-            }\n+            walk_list!(visitor, visit_pat, tuple_elements);\n         }\n         PatBox(ref subpattern) |\n         PatRegion(ref subpattern, _) => {\n-            visitor.visit_pat(&**subpattern)\n+            visitor.visit_pat(subpattern)\n         }\n         PatIdent(_, ref pth1, ref optional_subpattern) => {\n             visitor.visit_ident(pth1.span, pth1.node);\n-            match *optional_subpattern {\n-                None => {}\n-                Some(ref subpattern) => visitor.visit_pat(&**subpattern),\n-            }\n+            walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n-        PatLit(ref expression) => visitor.visit_expr(&**expression),\n+        PatLit(ref expression) => visitor.visit_expr(expression),\n         PatRange(ref lower_bound, ref upper_bound) => {\n-            visitor.visit_expr(&**lower_bound);\n-            visitor.visit_expr(&**upper_bound)\n+            visitor.visit_expr(lower_bound);\n+            visitor.visit_expr(upper_bound)\n         }\n         PatWild(_) => (),\n-        PatVec(ref prepattern, ref slice_pattern, ref postpatterns) => {\n-            for prepattern in prepattern {\n-                visitor.visit_pat(&**prepattern)\n-            }\n-            if let Some(ref slice_pattern) = *slice_pattern {\n-                visitor.visit_pat(&**slice_pattern)\n-            }\n-            for postpattern in postpatterns {\n-                visitor.visit_pat(&**postpattern)\n-            }\n+        PatVec(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n+            walk_list!(visitor, visit_pat, prepatterns);\n+            walk_list!(visitor, visit_pat, slice_pattern);\n+            walk_list!(visitor, visit_pat, postpatterns);\n         }\n     }\n }\n@@ -512,22 +454,13 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n \n     match foreign_item.node {\n         ForeignItemFn(ref function_declaration, ref generics) => {\n-            walk_fn_decl(visitor, &**function_declaration);\n+            walk_fn_decl(visitor, function_declaration);\n             visitor.visit_generics(generics)\n         }\n-        ForeignItemStatic(ref typ, _) => visitor.visit_ty(&**typ),\n+        ForeignItemStatic(ref typ, _) => visitor.visit_ty(typ),\n     }\n \n-    for attr in &foreign_item.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n-}\n-\n-pub fn walk_ty_param_bounds_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                                       bounds: &'v OwnedSlice<TyParamBound>) {\n-    for bound in bounds.iter() {\n-        visitor.visit_ty_param_bound(bound)\n-    }\n+    walk_list!(visitor, visit_attribute, &foreign_item.attrs);\n }\n \n pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n@@ -537,56 +470,62 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n             visitor.visit_poly_trait_ref(typ, modifier);\n         }\n         RegionTyParamBound(ref lifetime) => {\n-            visitor.visit_lifetime_bound(lifetime);\n+            visitor.visit_lifetime(lifetime);\n         }\n     }\n }\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n-    for param in generics.ty_params.iter() {\n+    for param in &generics.ty_params {\n         visitor.visit_name(param.span, param.name);\n-        walk_ty_param_bounds_helper(visitor, &param.bounds);\n-        walk_ty_opt(visitor, &param.default);\n+        walk_list!(visitor, visit_ty_param_bound, &param.bounds);\n+        walk_list!(visitor, visit_ty, &param.default);\n     }\n-    walk_lifetime_decls_helper(visitor, &generics.lifetimes);\n+    walk_list!(visitor, visit_lifetime_def, &generics.lifetimes);\n     for predicate in &generics.where_clause.predicates {\n         match predicate {\n-            &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{ref bounded_ty,\n+            &WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n                                                                           ref bounds,\n+                                                                          ref bound_lifetimes,\n                                                                           ..}) => {\n-                visitor.visit_ty(&**bounded_ty);\n-                walk_ty_param_bounds_helper(visitor, bounds);\n+                visitor.visit_ty(bounded_ty);\n+                walk_list!(visitor, visit_ty_param_bound, bounds);\n+                walk_list!(visitor, visit_lifetime_def, bound_lifetimes);\n             }\n-            &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,\n+            &WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n                                                                             ref bounds,\n                                                                             ..}) => {\n-                visitor.visit_lifetime_ref(lifetime);\n-\n-                for bound in bounds {\n-                    visitor.visit_lifetime_ref(bound);\n-                }\n+                visitor.visit_lifetime(lifetime);\n+                walk_list!(visitor, visit_lifetime, bounds);\n             }\n-            &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{id,\n+            &WherePredicate::EqPredicate(WhereEqPredicate{id,\n                                                                     ref path,\n                                                                     ref ty,\n                                                                     ..}) => {\n                 visitor.visit_path(path, id);\n-                visitor.visit_ty(&**ty);\n+                visitor.visit_ty(ty);\n             }\n         }\n     }\n }\n \n pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy) {\n     if let Return(ref output_ty) = *ret_ty {\n-        visitor.visit_ty(&**output_ty)\n+        visitor.visit_ty(output_ty)\n     }\n }\n \n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n     for argument in &function_declaration.inputs {\n-        visitor.visit_pat(&*argument.pat);\n-        visitor.visit_ty(&*argument.ty)\n+        visitor.visit_pat(&argument.pat);\n+        visitor.visit_ty(&argument.ty)\n+    }\n+    walk_fn_ret_ty(visitor, &function_declaration.output)\n+}\n+\n+pub fn walk_fn_decl_nopat<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n+    for argument in &function_declaration.inputs {\n+        visitor.visit_ty(&argument.ty)\n     }\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n@@ -601,7 +540,7 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V,\n             visitor.visit_generics(&sig.generics);\n             visitor.visit_explicit_self(&sig.explicit_self);\n         }\n-        FnKind::Closure(..) => {}\n+        FnKind::Closure => {}\n     }\n }\n \n@@ -617,15 +556,11 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n     visitor.visit_name(trait_item.span, trait_item.name);\n-    for attr in &trait_item.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     match trait_item.node {\n         ConstTraitItem(ref ty, ref default) => {\n             visitor.visit_ty(ty);\n-            if let Some(ref expr) = *default {\n-                visitor.visit_expr(expr);\n-            }\n+            walk_list!(visitor, visit_expr, default);\n         }\n         MethodTraitItem(ref sig, None) => {\n             visitor.visit_explicit_self(&sig.explicit_self);\n@@ -637,17 +572,15 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n                              body, trait_item.span, trait_item.id);\n         }\n         TypeTraitItem(ref bounds, ref default) => {\n-            walk_ty_param_bounds_helper(visitor, bounds);\n-            walk_ty_opt(visitor, default);\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_ty, default);\n         }\n     }\n }\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n     visitor.visit_name(impl_item.span, impl_item.name);\n-    for attr in &impl_item.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_attribute, &impl_item.attrs);\n     match impl_item.node {\n         ConstImplItem(ref ty, ref expr) => {\n             visitor.visit_ty(ty);\n@@ -665,173 +598,150 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n \n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                            struct_definition: &'v StructDef) {\n-    for field in &struct_definition.fields {\n-        visitor.visit_struct_field(field)\n-    }\n+    walk_list!(visitor, visit_struct_field, &struct_definition.fields);\n }\n \n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              struct_field: &'v StructField) {\n-    if let NamedField(name, _) = struct_field.node.kind {\n-        visitor.visit_name(struct_field.span, name);\n-    }\n-\n-    visitor.visit_ty(&*struct_field.node.ty);\n-\n-    for attr in &struct_field.node.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_opt_name(visitor, struct_field.span, struct_field.node.name());\n+    visitor.visit_ty(&struct_field.node.ty);\n+    walk_list!(visitor, visit_attribute, &struct_field.node.attrs);\n }\n \n pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n-    for statement in &block.stmts {\n-        visitor.visit_stmt(&**statement)\n-    }\n-    walk_expr_opt(visitor, &block.expr)\n+    walk_list!(visitor, visit_stmt, &block.stmts);\n+    walk_list!(visitor, visit_expr, &block.expr);\n }\n \n pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n     match statement.node {\n-        StmtDecl(ref declaration, _) => visitor.visit_decl(&**declaration),\n+        StmtDecl(ref declaration, _) => visitor.visit_decl(declaration),\n         StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n-            visitor.visit_expr(&**expression)\n+            visitor.visit_expr(expression)\n         }\n     }\n }\n \n pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n     match declaration.node {\n-        DeclLocal(ref local) => visitor.visit_local(&**local),\n-        DeclItem(ref item) => visitor.visit_item(&**item),\n-    }\n-}\n-\n-pub fn walk_expr_opt<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                         optional_expression: &'v Option<P<Expr>>) {\n-    match *optional_expression {\n-        None => {}\n-        Some(ref expression) => visitor.visit_expr(&**expression),\n-    }\n-}\n-\n-pub fn walk_exprs<'v, V: Visitor<'v>>(visitor: &mut V, expressions: &'v [P<Expr>]) {\n-    for expression in expressions {\n-        visitor.visit_expr(&**expression)\n+        DeclLocal(ref local) => visitor.visit_local(local),\n+        DeclItem(ref item) => visitor.visit_item(item),\n     }\n }\n \n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     match expression.node {\n         ExprBox(ref subexpression) => {\n-            visitor.visit_expr(&**subexpression)\n+            visitor.visit_expr(subexpression)\n         }\n         ExprVec(ref subexpressions) => {\n-            walk_exprs(visitor, subexpressions)\n+            walk_list!(visitor, visit_expr, subexpressions);\n         }\n         ExprRepeat(ref element, ref count) => {\n-            visitor.visit_expr(&**element);\n-            visitor.visit_expr(&**count)\n+            visitor.visit_expr(element);\n+            visitor.visit_expr(count)\n         }\n         ExprStruct(ref path, ref fields, ref optional_base) => {\n             visitor.visit_path(path, expression.id);\n             for field in fields {\n-                visitor.visit_expr(&*field.expr)\n+                visitor.visit_name(field.name.span, field.name.node);\n+                visitor.visit_expr(&field.expr)\n             }\n-            walk_expr_opt(visitor, optional_base)\n+            walk_list!(visitor, visit_expr, optional_base);\n         }\n         ExprTup(ref subexpressions) => {\n-            for subexpression in subexpressions {\n-                visitor.visit_expr(&**subexpression)\n-            }\n+            walk_list!(visitor, visit_expr, subexpressions);\n         }\n         ExprCall(ref callee_expression, ref arguments) => {\n-            for argument in arguments {\n-                visitor.visit_expr(&**argument)\n-            }\n-            visitor.visit_expr(&**callee_expression)\n+            walk_list!(visitor, visit_expr, arguments);\n+            visitor.visit_expr(callee_expression)\n         }\n-        ExprMethodCall(_, ref types, ref arguments) => {\n-            walk_exprs(visitor, arguments);\n-            for typ in types {\n-                visitor.visit_ty(&**typ)\n-            }\n+        ExprMethodCall(ref name, ref types, ref arguments) => {\n+            visitor.visit_name(name.span, name.node);\n+            walk_list!(visitor, visit_expr, arguments);\n+            walk_list!(visitor, visit_ty, types);\n         }\n         ExprBinary(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(&**left_expression);\n-            visitor.visit_expr(&**right_expression)\n+            visitor.visit_expr(left_expression);\n+            visitor.visit_expr(right_expression)\n         }\n         ExprAddrOf(_, ref subexpression) | ExprUnary(_, ref subexpression) => {\n-            visitor.visit_expr(&**subexpression)\n+            visitor.visit_expr(subexpression)\n         }\n         ExprLit(_) => {}\n         ExprCast(ref subexpression, ref typ) => {\n-            visitor.visit_expr(&**subexpression);\n-            visitor.visit_ty(&**typ)\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ty(typ)\n         }\n         ExprIf(ref head_expression, ref if_block, ref optional_else) => {\n-            visitor.visit_expr(&**head_expression);\n-            visitor.visit_block(&**if_block);\n-            walk_expr_opt(visitor, optional_else)\n+            visitor.visit_expr(head_expression);\n+            visitor.visit_block(if_block);\n+            walk_list!(visitor, visit_expr, optional_else);\n+        }\n+        ExprWhile(ref subexpression, ref block, opt_ident) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_block(block);\n+            walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n-        ExprWhile(ref subexpression, ref block, _) => {\n-            visitor.visit_expr(&**subexpression);\n-            visitor.visit_block(&**block)\n+        ExprLoop(ref block, opt_ident) => {\n+            visitor.visit_block(block);\n+            walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n-        ExprLoop(ref block, _) => visitor.visit_block(&**block),\n         ExprMatch(ref subexpression, ref arms, _) => {\n-            visitor.visit_expr(&**subexpression);\n-            for arm in arms {\n-                visitor.visit_arm(arm)\n-            }\n+            visitor.visit_expr(subexpression);\n+            walk_list!(visitor, visit_arm, arms);\n         }\n         ExprClosure(_, ref function_declaration, ref body) => {\n             visitor.visit_fn(FnKind::Closure,\n-                             &**function_declaration,\n-                             &**body,\n+                             function_declaration,\n+                             body,\n                              expression.span,\n                              expression.id)\n         }\n-        ExprBlock(ref block) => visitor.visit_block(&**block),\n+        ExprBlock(ref block) => visitor.visit_block(block),\n         ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n-            visitor.visit_expr(&**right_hand_expression);\n-            visitor.visit_expr(&**left_hand_expression)\n+            visitor.visit_expr(right_hand_expression);\n+            visitor.visit_expr(left_hand_expression)\n         }\n         ExprAssignOp(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(&**right_expression);\n-            visitor.visit_expr(&**left_expression)\n+            visitor.visit_expr(right_expression);\n+            visitor.visit_expr(left_expression)\n         }\n-        ExprField(ref subexpression, _) => {\n-            visitor.visit_expr(&**subexpression);\n+        ExprField(ref subexpression, ref name) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_name(name.span, name.node);\n         }\n         ExprTupField(ref subexpression, _) => {\n-            visitor.visit_expr(&**subexpression);\n+            visitor.visit_expr(subexpression);\n         }\n         ExprIndex(ref main_expression, ref index_expression) => {\n-            visitor.visit_expr(&**main_expression);\n-            visitor.visit_expr(&**index_expression)\n+            visitor.visit_expr(main_expression);\n+            visitor.visit_expr(index_expression)\n         }\n         ExprRange(ref start, ref end) => {\n-            walk_expr_opt(visitor, start);\n-            walk_expr_opt(visitor, end)\n+            walk_list!(visitor, visit_expr, start);\n+            walk_list!(visitor, visit_expr, end);\n         }\n         ExprPath(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprBreak(_) | ExprAgain(_) => {}\n+        ExprBreak(ref opt_sp_ident) | ExprAgain(ref opt_sp_ident) => {\n+            for sp_ident in opt_sp_ident {\n+                visitor.visit_ident(sp_ident.span, sp_ident.node);\n+            }\n+        }\n         ExprRet(ref optional_expression) => {\n-            walk_expr_opt(visitor, optional_expression)\n+            walk_list!(visitor, visit_expr, optional_expression);\n         }\n         ExprInlineAsm(ref ia) => {\n-            for input in &ia.inputs {\n-                let (_, ref input) = *input;\n-                visitor.visit_expr(&**input)\n+            for &(_, ref input) in &ia.inputs {\n+                visitor.visit_expr(&input)\n             }\n-            for output in &ia.outputs {\n-                let (_, ref output, _) = *output;\n-                visitor.visit_expr(&**output)\n+            for &(_, ref output, _) in &ia.outputs {\n+                visitor.visit_expr(&output)\n             }\n         }\n     }\n@@ -840,12 +750,8 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n }\n \n pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n-    for pattern in &arm.pats {\n-        visitor.visit_pat(&**pattern)\n-    }\n-    walk_expr_opt(visitor, &arm.guard);\n-    visitor.visit_expr(&*arm.body);\n-    for attr in &arm.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_pat, &arm.pats);\n+    walk_list!(visitor, visit_expr, &arm.guard);\n+    visitor.visit_expr(&arm.body);\n+    walk_list!(visitor, visit_attribute, &arm.attrs);\n }"}, {"sha": "4f6b3f9353afab9d4ecacfd66ccf253d6eebdc44", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -2158,7 +2158,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                              |this| {\n                     this.with_self_rib(DefSelfTy(Some(DefId::local(item.id)), None), |this| {\n                         this.visit_generics(generics);\n-                        visit::walk_ty_param_bounds_helper(this, bounds);\n+                        walk_list!(this, visit_ty_param_bound, bounds);\n \n                         for trait_item in trait_items {\n                             match trait_item.node {\n@@ -2542,10 +2542,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_local(&mut self, local: &Local) {\n         // Resolve the type.\n-        visit::walk_ty_opt(self, &local.ty);\n+        walk_list!(self, visit_ty, &local.ty);\n \n         // Resolve the initializer.\n-        visit::walk_expr_opt(self, &local.init);\n+        walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n         self.resolve_pattern(&*local.pat,\n@@ -2622,7 +2622,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // pat_idents are variants\n         self.check_consistent_bindings(arm);\n \n-        visit::walk_expr_opt(self, &arm.guard);\n+        walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&*arm.body);\n \n         if !self.resolved {"}, {"sha": "6c53762c3ead77ff140372c67f19f9fec5b0b211", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -771,7 +771,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             }\n         }\n \n-        visit::walk_expr_opt(self, base)\n+        walk_list!(self, visit_expr, base);\n     }\n \n     fn process_method_call(&mut self, ex: &ast::Expr, args: &Vec<P<ast::Expr>>) {\n@@ -785,7 +785,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         }\n \n         // walk receiver and args\n-        visit::walk_exprs(self, &args);\n+        walk_list!(self, visit_expr, args);\n     }\n \n     fn process_pat(&mut self, p: &ast::Pat) {\n@@ -1200,7 +1200,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n         for &(id, ref path, ref_kind) in &paths_to_process {\n             self.process_path(id, path, ref_kind);\n         }\n-        visit::walk_expr_opt(self, &arm.guard);\n+        walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&arm.body);\n     }\n \n@@ -1246,7 +1246,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n         }\n \n         // Just walk the initialiser and type (don't want to walk the pattern again).\n-        visit::walk_ty_opt(self, &l.ty);\n-        visit::walk_expr_opt(self, &l.init);\n+        walk_list!(self, visit_ty, &l.ty);\n+        walk_list!(self, visit_expr, &l.init);\n     }\n }"}, {"sha": "9dab5c2f514edcbca7146f5a1572294854dd5e6a", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -1167,7 +1167,7 @@ fn has_nested_returns(tcx: &ty::ctxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bo\n             }\n             Some(hir_map::NodeBlock(blk)) if blk.id == blk_id => {\n                 let mut visitor = FindNestedReturn::new();\n-                visit::walk_expr_opt(&mut visitor, &blk.expr);\n+                walk_list!(&mut visitor, visit_expr, &blk.expr);\n                 if visitor.found {\n                     return true;\n                 }"}, {"sha": "324a4a4ca083730ff26f6c4c9071ffa172053de6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -376,6 +376,11 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n             hir::TyFixedLengthVec(_, ref expr) => {\n                 check_const_in_type(self.ccx, &**expr, self.ccx.tcx.types.usize);\n             }\n+            hir::TyBareFn(ref function_declaration) => {\n+                visit::walk_fn_decl_nopat(self, &function_declaration.decl);\n+                walk_list!(self, visit_lifetime_def, &function_declaration.lifetimes);\n+                return\n+            }\n             _ => {}\n         }\n \n@@ -560,6 +565,10 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                 self.visit_ty(&**ty);\n                 check_expr_with_hint(self.fcx, &**count_expr, self.fcx.tcx().types.usize);\n             }\n+            hir::TyBareFn(ref function_declaration) => {\n+                visit::walk_fn_decl_nopat(self, &function_declaration.decl);\n+                walk_list!(self, visit_lifetime_def, &function_declaration.lifetimes);\n+            }\n             _ => visit::walk_ty(self, t)\n         }\n     }"}, {"sha": "68c0f130c20f18a167eb54491395b8cd605ebc95", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -225,6 +225,10 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n                 self.visit_ty(&**ty);\n                 write_ty_to_tcx(self.tcx(), count_expr.id, self.tcx().types.usize);\n             }\n+            hir::TyBareFn(ref function_declaration) => {\n+                visit::walk_fn_decl_nopat(self, &function_declaration.decl);\n+                walk_list!(self, visit_lifetime_def, &function_declaration.lifetimes);\n+            }\n             _ => visit::walk_ty(self, t)\n         }\n     }"}, {"sha": "71261fa457fcd30e6342c7f330d4e3ca56890f8e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -1613,6 +1613,13 @@ impl PathListItem_ {\n         }\n     }\n \n+    pub fn name(&self) -> Option<Ident> {\n+        match *self {\n+            PathListIdent { name, .. } => Some(name),\n+            PathListMod { .. } => None,\n+        }\n+    }\n+\n     pub fn rename(&self) -> Option<Ident> {\n         match *self {\n             PathListIdent { rename, .. } | PathListMod { rename, .. } => rename"}, {"sha": "6ab1ad863ff352eb51643da47f37aa03671c7674", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -476,12 +476,12 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         visit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_lifetime_ref(&mut self, lifetime: &Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n         self.operation.visit_id(lifetime.id);\n     }\n \n     fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n-        self.visit_lifetime_ref(&def.lifetime);\n+        self.visit_lifetime(&def.lifetime);\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: &TraitRef) {"}, {"sha": "83369689a94de077efbce2a8ce81ff6e32c4751e", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -12,6 +12,7 @@ use std::default::Default;\n use std::fmt;\n use std::iter::{IntoIterator, FromIterator};\n use std::ops::Deref;\n+use std::slice;\n use std::vec;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -82,6 +83,14 @@ impl<T> FromIterator<T> for OwnedSlice<T> {\n     }\n }\n \n+impl<'a, T> IntoIterator for &'a OwnedSlice<T> {\n+    type Item = &'a T;\n+    type IntoIter = slice::Iter<'a, T>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.data.into_iter()\n+    }\n+}\n+\n impl<T: Encodable> Encodable for OwnedSlice<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         Encodable::encode(&**self, s)"}, {"sha": "67e4927a52fca0cc5fac71bccc52c6329b120510", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 255, "deletions": 338, "changes": 593, "blob_url": "https://github.com/rust-lang/rust/blob/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59eb44407652f5b66a66231f12f66f89c5df5c5f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=59eb44407652f5b66a66231f12f66f89c5df5c5f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -25,10 +25,7 @@\n \n use abi::Abi;\n use ast::*;\n-use ast;\n use codemap::Span;\n-use ptr::P;\n-use owned_slice::OwnedSlice;\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n@@ -56,7 +53,7 @@ pub trait Visitor<'v> : Sized {\n         // Nothing to do.\n     }\n     fn visit_ident(&mut self, span: Span, ident: Ident) {\n-        self.visit_name(span, ident.name);\n+        walk_ident(self, span, ident);\n     }\n     fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n     fn visit_foreign_item(&mut self, i: &'v ForeignItem) { walk_foreign_item(self, i) }\n@@ -94,21 +91,8 @@ pub trait Visitor<'v> : Sized {\n \n     fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics) { walk_variant(self, v, g) }\n \n-    /// Visits an optional reference to a lifetime. The `span` is the span of some surrounding\n-    /// reference should opt_lifetime be None.\n-    fn visit_opt_lifetime_ref(&mut self,\n-                              _span: Span,\n-                              opt_lifetime: &'v Option<Lifetime>) {\n-        match *opt_lifetime {\n-            Some(ref l) => self.visit_lifetime_ref(l),\n-            None => ()\n-        }\n-    }\n-    fn visit_lifetime_bound(&mut self, lifetime: &'v Lifetime) {\n-        walk_lifetime_bound(self, lifetime)\n-    }\n-    fn visit_lifetime_ref(&mut self, lifetime: &'v Lifetime) {\n-        walk_lifetime_ref(self, lifetime)\n+    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n+        walk_lifetime(self, lifetime)\n     }\n     fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n@@ -124,7 +108,7 @@ pub trait Visitor<'v> : Sized {\n         // definition in your trait impl:\n         // visit::walk_mac(self, _mac)\n     }\n-    fn visit_path(&mut self, path: &'v Path, _id: ast::NodeId) {\n+    fn visit_path(&mut self, path: &'v Path, _id: NodeId) {\n         walk_path(self, path)\n     }\n     fn visit_path_list_item(&mut self, prefix: &'v Path, item: &'v PathListItem) {\n@@ -140,53 +124,83 @@ pub trait Visitor<'v> : Sized {\n         walk_assoc_type_binding(self, type_binding)\n     }\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n+    fn visit_macro_def(&mut self, macro_def: &'v MacroDef) {\n+        walk_macro_def(self, macro_def)\n+    }\n }\n \n-pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n-    visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n-    for attr in &krate.attrs {\n-        visitor.visit_attribute(attr);\n+#[macro_export]\n+macro_rules! walk_list {\n+    ($visitor: expr, $method: ident, $list: expr) => {\n+        for elem in $list {\n+            $visitor.$method(elem)\n+        }\n     }\n }\n \n-pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n-    for item in &module.items {\n-        visitor.visit_item(&**item)\n+pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n+    for name in opt_name {\n+        visitor.visit_name(span, name);\n     }\n }\n \n-pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n-    visitor.visit_pat(&*local.pat);\n-    walk_ty_opt(visitor, &local.ty);\n-    walk_expr_opt(visitor, &local.init);\n+pub fn walk_opt_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n+    for ident in opt_ident {\n+        visitor.visit_ident(span, ident);\n+    }\n }\n \n-pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                              lifetime_def: &'v LifetimeDef) {\n-    visitor.visit_name(lifetime_def.lifetime.span, lifetime_def.lifetime.name);\n-    for bound in &lifetime_def.bounds {\n-        visitor.visit_lifetime_bound(bound);\n-    }\n+pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, ident: Ident) {\n+    visitor.visit_name(span, ident.name);\n }\n \n-pub fn walk_lifetime_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                               lifetime_ref: &'v Lifetime) {\n-    visitor.visit_lifetime_ref(lifetime_ref)\n+pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n+    visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n+    walk_list!(visitor, visit_attribute, &krate.attrs);\n+    walk_list!(visitor, visit_macro_def, &krate.exported_macros);\n+}\n+\n+pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef) {\n+    visitor.visit_ident(macro_def.span, macro_def.ident);\n+    walk_opt_ident(visitor, macro_def.span, macro_def.imported_from);\n+    walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n \n-pub fn walk_lifetime_ref<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             lifetime_ref: &'v Lifetime) {\n-    visitor.visit_name(lifetime_ref.span, lifetime_ref.name)\n+pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod) {\n+    walk_list!(visitor, visit_item, &module.items);\n+}\n+\n+pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n+    visitor.visit_pat(&local.pat);\n+    walk_list!(visitor, visit_ty, &local.ty);\n+    walk_list!(visitor, visit_expr, &local.init);\n+}\n+\n+pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n+    visitor.visit_name(lifetime.span, lifetime.name);\n+}\n+\n+pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                              lifetime_def: &'v LifetimeDef) {\n+    visitor.visit_lifetime(&lifetime_def.lifetime);\n+    walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n }\n \n pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n                                               explicit_self: &'v ExplicitSelf) {\n     match explicit_self.node {\n-        SelfStatic | SelfValue(_) => {},\n-        SelfRegion(ref lifetime, _, _) => {\n-            visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime)\n+        SelfStatic => {},\n+        SelfValue(ident) => {\n+            visitor.visit_ident(explicit_self.span, ident)\n+        }\n+        SelfRegion(ref opt_lifetime, _, ident) => {\n+            visitor.visit_ident(explicit_self.span, ident);\n+            walk_list!(visitor, visit_lifetime, opt_lifetime);\n+        }\n+        SelfExplicit(ref typ, ident) => {\n+            visitor.visit_ident(explicit_self.span, ident);\n+            visitor.visit_ty(typ)\n         }\n-        SelfExplicit(ref typ, _) => visitor.visit_ty(&**typ),\n     }\n }\n \n@@ -195,7 +209,7 @@ pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   _modifier: &'v TraitBoundModifier)\n     where V: Visitor<'v>\n {\n-    walk_lifetime_decls_helper(visitor, &trait_ref.bound_lifetimes);\n+    walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n@@ -209,10 +223,13 @@ pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n-        ItemExternCrate(..) => {}\n+        ItemExternCrate(opt_name) => {\n+            walk_opt_name(visitor, item.span, opt_name)\n+        }\n         ItemUse(ref vp) => {\n             match vp.node {\n-                ViewPathSimple(_ident, ref path) => {\n+                ViewPathSimple(ident, ref path) => {\n+                    visitor.visit_ident(vp.span, ident);\n                     visitor.visit_path(path, item.id);\n                 }\n                 ViewPathGlob(ref path) => {\n@@ -231,27 +248,25 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemStatic(ref typ, _, ref expr) |\n         ItemConst(ref typ, ref expr) => {\n-            visitor.visit_ty(&**typ);\n-            visitor.visit_expr(&**expr);\n+            visitor.visit_ty(typ);\n+            visitor.visit_expr(expr);\n         }\n         ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n             visitor.visit_fn(FnKind::ItemFn(item.ident, generics, unsafety,\n                                             constness, abi, item.vis),\n-                             &**declaration,\n-                             &**body,\n+                             declaration,\n+                             body,\n                              item.span,\n                              item.id)\n         }\n         ItemMod(ref module) => {\n             visitor.visit_mod(module, item.span, item.id)\n         }\n         ItemForeignMod(ref foreign_module) => {\n-            for foreign_item in &foreign_module.items {\n-                visitor.visit_foreign_item(&**foreign_item)\n-            }\n+            walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n         ItemTy(ref typ, ref type_parameters) => {\n-            visitor.visit_ty(&**typ);\n+            visitor.visit_ty(typ);\n             visitor.visit_generics(type_parameters)\n         }\n         ItemEnum(ref enum_definition, ref type_parameters) => {\n@@ -263,45 +278,36 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemImpl(_, _,\n                  ref type_parameters,\n-                 ref trait_reference,\n+                 ref opt_trait_reference,\n                  ref typ,\n                  ref impl_items) => {\n             visitor.visit_generics(type_parameters);\n-            match *trait_reference {\n-                Some(ref trait_reference) => visitor.visit_trait_ref(trait_reference),\n-                None => ()\n-            }\n-            visitor.visit_ty(&**typ);\n-            for impl_item in impl_items {\n-                visitor.visit_impl_item(impl_item);\n-            }\n+            walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n+            visitor.visit_ty(typ);\n+            walk_list!(visitor, visit_impl_item, impl_items);\n         }\n         ItemStruct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_struct_def(&**struct_definition,\n+            visitor.visit_struct_def(struct_definition,\n                                      item.ident,\n                                      generics,\n                                      item.id)\n         }\n         ItemTrait(_, ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n-            walk_ty_param_bounds_helper(visitor, bounds);\n-            for method in methods {\n-                visitor.visit_trait_item(method)\n-            }\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_trait_item, methods);\n         }\n         ItemMac(ref mac) => visitor.visit_mac(mac),\n     }\n-    for attr in &item.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_attribute, &item.attrs);\n }\n \n pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                          enum_definition: &'v EnumDef,\n                                          generics: &'v Generics) {\n     for variant in &enum_definition.variants {\n-        visitor.visit_variant(&**variant, generics);\n+        visitor.visit_variant(variant, generics);\n     }\n }\n \n@@ -313,59 +319,38 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n     match variant.node.kind {\n         TupleVariantKind(ref variant_arguments) => {\n             for variant_argument in variant_arguments {\n-                visitor.visit_ty(&*variant_argument.ty)\n+                visitor.visit_ty(&variant_argument.ty)\n             }\n         }\n         StructVariantKind(ref struct_definition) => {\n-            visitor.visit_struct_def(&**struct_definition,\n+            visitor.visit_struct_def(struct_definition,\n                                      variant.node.name,\n                                      generics,\n                                      variant.node.id)\n         }\n     }\n-    match variant.node.disr_expr {\n-        Some(ref expr) => visitor.visit_expr(&**expr),\n-        None => ()\n-    }\n-    for attr in &variant.node.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n-}\n-\n-pub fn skip_ty<'v, V: Visitor<'v>>(_: &mut V, _: &'v Ty) {\n-    // Empty!\n-}\n-\n-pub fn walk_ty_opt<'v, V: Visitor<'v>>(visitor: &mut V, optional_type: &'v Option<P<Ty>>) {\n-    match *optional_type {\n-        Some(ref ty) => visitor.visit_ty(&**ty),\n-        None => ()\n-    }\n+    walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n+    walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     match typ.node {\n         TyVec(ref ty) | TyParen(ref ty) => {\n-            visitor.visit_ty(&**ty)\n+            visitor.visit_ty(ty)\n         }\n         TyPtr(ref mutable_type) => {\n-            visitor.visit_ty(&*mutable_type.ty)\n+            visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyRptr(ref lifetime, ref mutable_type) => {\n-            visitor.visit_opt_lifetime_ref(typ.span, lifetime);\n-            visitor.visit_ty(&*mutable_type.ty)\n+        TyRptr(ref opt_lifetime, ref mutable_type) => {\n+            walk_list!(visitor, visit_lifetime, opt_lifetime);\n+            visitor.visit_ty(&mutable_type.ty)\n         }\n         TyTup(ref tuple_element_types) => {\n-            for tuple_element_type in tuple_element_types {\n-                visitor.visit_ty(&**tuple_element_type)\n-            }\n+            walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n         TyBareFn(ref function_declaration) => {\n-            for argument in &function_declaration.decl.inputs {\n-                visitor.visit_ty(&*argument.ty)\n-            }\n-            walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n-            walk_lifetime_decls_helper(visitor, &function_declaration.lifetimes);\n+            walk_fn_decl(visitor, &function_declaration.decl);\n+            walk_list!(visitor, visit_lifetime_def, &function_declaration.lifetimes);\n         }\n         TyPath(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n@@ -374,18 +359,18 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_path(path, typ.id);\n         }\n         TyObjectSum(ref ty, ref bounds) => {\n-            visitor.visit_ty(&**ty);\n-            walk_ty_param_bounds_helper(visitor, bounds);\n+            visitor.visit_ty(ty);\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyFixedLengthVec(ref ty, ref expression) => {\n-            visitor.visit_ty(&**ty);\n-            visitor.visit_expr(&**expression)\n+            visitor.visit_ty(ty);\n+            visitor.visit_expr(expression)\n         }\n         TyPolyTraitRef(ref bounds) => {\n-            walk_ty_param_bounds_helper(visitor, bounds)\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyTypeof(ref expression) => {\n-            visitor.visit_expr(&**expression)\n+            visitor.visit_expr(expression)\n         }\n         TyInfer => {}\n         TyMac(ref mac) => {\n@@ -394,13 +379,6 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     }\n }\n \n-pub fn walk_lifetime_decls_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                                      lifetimes: &'v Vec<LifetimeDef>) {\n-    for l in lifetimes {\n-        visitor.visit_lifetime_def(l);\n-    }\n-}\n-\n pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n@@ -413,9 +391,8 @@ pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V, prefix: &'v Path\n         visitor.visit_path_segment(prefix.span, segment);\n     }\n \n-    if let PathListIdent { name, .. } = item.node {\n-        visitor.visit_ident(item.span, name);\n-    }\n+    walk_opt_ident(visitor, item.span, item.node.name());\n+    walk_opt_ident(visitor, item.span, item.node.rename());\n }\n \n pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n@@ -429,42 +406,30 @@ pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                 _path_span: Span,\n                                                 path_parameters: &'v PathParameters) {\n     match *path_parameters {\n-        ast::AngleBracketedParameters(ref data) => {\n-            for typ in data.types.iter() {\n-                visitor.visit_ty(&**typ);\n-            }\n-            for lifetime in &data.lifetimes {\n-                visitor.visit_lifetime_ref(lifetime);\n-            }\n-            for binding in data.bindings.iter() {\n-                visitor.visit_assoc_type_binding(&**binding);\n-            }\n+        AngleBracketedParameters(ref data) => {\n+            walk_list!(visitor, visit_ty, &data.types);\n+            walk_list!(visitor, visit_lifetime, &data.lifetimes);\n+            walk_list!(visitor, visit_assoc_type_binding, &data.bindings);\n         }\n-        ast::ParenthesizedParameters(ref data) => {\n-            for typ in &data.inputs {\n-                visitor.visit_ty(&**typ);\n-            }\n-            if let Some(ref typ) = data.output {\n-                visitor.visit_ty(&**typ);\n-            }\n+        ParenthesizedParameters(ref data) => {\n+            walk_list!(visitor, visit_ty, &data.inputs);\n+            walk_list!(visitor, visit_ty, &data.output);\n         }\n     }\n }\n \n pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                    type_binding: &'v TypeBinding) {\n     visitor.visit_ident(type_binding.span, type_binding.ident);\n-    visitor.visit_ty(&*type_binding.ty);\n+    visitor.visit_ty(&type_binding.ty);\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n-        PatEnum(ref path, ref children) => {\n+        PatEnum(ref path, ref opt_children) => {\n             visitor.visit_path(path, pattern.id);\n-            if let Some(ref children) = *children {\n-                for child in children {\n-                    visitor.visit_pat(&*child)\n-                }\n+            if let Some(ref children) = *opt_children {\n+                walk_list!(visitor, visit_pat, children);\n             }\n         }\n         PatQPath(ref qself, ref path) => {\n@@ -474,41 +439,31 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatStruct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id);\n             for field in fields {\n-                visitor.visit_pat(&*field.node.pat)\n+                visitor.visit_ident(field.span, field.node.ident);\n+                visitor.visit_pat(&field.node.pat)\n             }\n         }\n         PatTup(ref tuple_elements) => {\n-            for tuple_element in tuple_elements {\n-                visitor.visit_pat(&**tuple_element)\n-            }\n+            walk_list!(visitor, visit_pat, tuple_elements);\n         }\n         PatBox(ref subpattern) |\n         PatRegion(ref subpattern, _) => {\n-            visitor.visit_pat(&**subpattern)\n+            visitor.visit_pat(subpattern)\n         }\n         PatIdent(_, ref pth1, ref optional_subpattern) => {\n             visitor.visit_ident(pth1.span, pth1.node);\n-            match *optional_subpattern {\n-                None => {}\n-                Some(ref subpattern) => visitor.visit_pat(&**subpattern),\n-            }\n+            walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n-        PatLit(ref expression) => visitor.visit_expr(&**expression),\n+        PatLit(ref expression) => visitor.visit_expr(expression),\n         PatRange(ref lower_bound, ref upper_bound) => {\n-            visitor.visit_expr(&**lower_bound);\n-            visitor.visit_expr(&**upper_bound)\n+            visitor.visit_expr(lower_bound);\n+            visitor.visit_expr(upper_bound)\n         }\n         PatWild(_) => (),\n-        PatVec(ref prepattern, ref slice_pattern, ref postpatterns) => {\n-            for prepattern in prepattern {\n-                visitor.visit_pat(&**prepattern)\n-            }\n-            if let Some(ref slice_pattern) = *slice_pattern {\n-                visitor.visit_pat(&**slice_pattern)\n-            }\n-            for postpattern in postpatterns {\n-                visitor.visit_pat(&**postpattern)\n-            }\n+        PatVec(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n+            walk_list!(visitor, visit_pat, prepatterns);\n+            walk_list!(visitor, visit_pat, slice_pattern);\n+            walk_list!(visitor, visit_pat, postpatterns);\n         }\n         PatMac(ref mac) => visitor.visit_mac(mac),\n     }\n@@ -520,22 +475,13 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n \n     match foreign_item.node {\n         ForeignItemFn(ref function_declaration, ref generics) => {\n-            walk_fn_decl(visitor, &**function_declaration);\n+            walk_fn_decl(visitor, function_declaration);\n             visitor.visit_generics(generics)\n         }\n-        ForeignItemStatic(ref typ, _) => visitor.visit_ty(&**typ),\n+        ForeignItemStatic(ref typ, _) => visitor.visit_ty(typ),\n     }\n \n-    for attr in &foreign_item.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n-}\n-\n-pub fn walk_ty_param_bounds_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                                       bounds: &'v OwnedSlice<TyParamBound>) {\n-    for bound in bounds.iter() {\n-        visitor.visit_ty_param_bound(bound)\n-    }\n+    walk_list!(visitor, visit_attribute, &foreign_item.attrs);\n }\n \n pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n@@ -545,67 +491,61 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n             visitor.visit_poly_trait_ref(typ, modifier);\n         }\n         RegionTyParamBound(ref lifetime) => {\n-            visitor.visit_lifetime_bound(lifetime);\n+            visitor.visit_lifetime(lifetime);\n         }\n     }\n }\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n-    for param in generics.ty_params.iter() {\n+    for param in &generics.ty_params {\n         visitor.visit_ident(param.span, param.ident);\n-        walk_ty_param_bounds_helper(visitor, &param.bounds);\n-        walk_ty_opt(visitor, &param.default);\n+        walk_list!(visitor, visit_ty_param_bound, &param.bounds);\n+        walk_list!(visitor, visit_ty, &param.default);\n     }\n-    walk_lifetime_decls_helper(visitor, &generics.lifetimes);\n+    walk_list!(visitor, visit_lifetime_def, &generics.lifetimes);\n     for predicate in &generics.where_clause.predicates {\n         match predicate {\n-            &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bounded_ty,\n+            &WherePredicate::BoundPredicate(WhereBoundPredicate{ref bounded_ty,\n                                                                           ref bounds,\n+                                                                          ref bound_lifetimes,\n                                                                           ..}) => {\n-                visitor.visit_ty(&**bounded_ty);\n-                walk_ty_param_bounds_helper(visitor, bounds);\n+                visitor.visit_ty(bounded_ty);\n+                walk_list!(visitor, visit_ty_param_bound, bounds);\n+                walk_list!(visitor, visit_lifetime_def, bound_lifetimes);\n             }\n-            &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n+            &WherePredicate::RegionPredicate(WhereRegionPredicate{ref lifetime,\n                                                                             ref bounds,\n                                                                             ..}) => {\n-                visitor.visit_lifetime_ref(lifetime);\n-\n-                for bound in bounds {\n-                    visitor.visit_lifetime_ref(bound);\n-                }\n+                visitor.visit_lifetime(lifetime);\n+                walk_list!(visitor, visit_lifetime, bounds);\n             }\n-            &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{id,\n+            &WherePredicate::EqPredicate(WhereEqPredicate{id,\n                                                                     ref path,\n                                                                     ref ty,\n                                                                     ..}) => {\n                 visitor.visit_path(path, id);\n-                visitor.visit_ty(&**ty);\n+                visitor.visit_ty(ty);\n             }\n         }\n     }\n }\n \n pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy) {\n     if let Return(ref output_ty) = *ret_ty {\n-        visitor.visit_ty(&**output_ty)\n+        visitor.visit_ty(output_ty)\n     }\n }\n \n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n     for argument in &function_declaration.inputs {\n-        visitor.visit_pat(&*argument.pat);\n-        visitor.visit_ty(&*argument.ty)\n+        visitor.visit_pat(&argument.pat);\n+        visitor.visit_ty(&argument.ty)\n     }\n     walk_fn_ret_ty(visitor, &function_declaration.output)\n }\n \n-pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                   function_kind: FnKind<'v>,\n-                                   function_declaration: &'v FnDecl,\n-                                   function_body: &'v Block,\n-                                   _span: Span) {\n-    walk_fn_decl(visitor, function_declaration);\n-\n+pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                        function_kind: FnKind<'v>) {\n     match function_kind {\n         FnKind::ItemFn(_, generics, _, _, _, _) => {\n             visitor.visit_generics(generics);\n@@ -614,23 +554,27 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n             visitor.visit_generics(&sig.generics);\n             visitor.visit_explicit_self(&sig.explicit_self);\n         }\n-        FnKind::Closure(..) => {}\n+        FnKind::Closure => {}\n     }\n+}\n \n+pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                   function_kind: FnKind<'v>,\n+                                   function_declaration: &'v FnDecl,\n+                                   function_body: &'v Block,\n+                                   _span: Span) {\n+    walk_fn_decl(visitor, function_declaration);\n+    walk_fn_kind(visitor, function_kind);\n     visitor.visit_block(function_body)\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n     visitor.visit_ident(trait_item.span, trait_item.ident);\n-    for attr in &trait_item.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     match trait_item.node {\n         ConstTraitItem(ref ty, ref default) => {\n             visitor.visit_ty(ty);\n-            if let Some(ref expr) = *default {\n-                visitor.visit_expr(expr);\n-            }\n+            walk_list!(visitor, visit_expr, default);\n         }\n         MethodTraitItem(ref sig, None) => {\n             visitor.visit_explicit_self(&sig.explicit_self);\n@@ -642,17 +586,15 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n                              body, trait_item.span, trait_item.id);\n         }\n         TypeTraitItem(ref bounds, ref default) => {\n-            walk_ty_param_bounds_helper(visitor, bounds);\n-            walk_ty_opt(visitor, default);\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_ty, default);\n         }\n     }\n }\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n     visitor.visit_ident(impl_item.span, impl_item.ident);\n-    for attr in &impl_item.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_attribute, &impl_item.attrs);\n     match impl_item.node {\n         ConstImplItem(ref ty, ref expr) => {\n             visitor.visit_ty(ty);\n@@ -673,59 +615,35 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n \n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                            struct_definition: &'v StructDef) {\n-    for field in &struct_definition.fields {\n-        visitor.visit_struct_field(field)\n-    }\n+    walk_list!(visitor, visit_struct_field, &struct_definition.fields);\n }\n \n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              struct_field: &'v StructField) {\n-    if let NamedField(name, _) = struct_field.node.kind {\n-        visitor.visit_ident(struct_field.span, name);\n-    }\n-\n-    visitor.visit_ty(&*struct_field.node.ty);\n-\n-    for attr in &struct_field.node.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_opt_ident(visitor, struct_field.span, struct_field.node.ident());\n+    visitor.visit_ty(&struct_field.node.ty);\n+    walk_list!(visitor, visit_attribute, &struct_field.node.attrs);\n }\n \n pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n-    for statement in &block.stmts {\n-        visitor.visit_stmt(&**statement)\n-    }\n-    walk_expr_opt(visitor, &block.expr)\n+    walk_list!(visitor, visit_stmt, &block.stmts);\n+    walk_list!(visitor, visit_expr, &block.expr);\n }\n \n pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n     match statement.node {\n-        StmtDecl(ref declaration, _) => visitor.visit_decl(&**declaration),\n+        StmtDecl(ref declaration, _) => visitor.visit_decl(declaration),\n         StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n-            visitor.visit_expr(&**expression)\n+            visitor.visit_expr(expression)\n         }\n-        StmtMac(ref mac, _) => visitor.visit_mac(&**mac),\n+        StmtMac(ref mac, _) => visitor.visit_mac(mac),\n     }\n }\n \n pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n     match declaration.node {\n-        DeclLocal(ref local) => visitor.visit_local(&**local),\n-        DeclItem(ref item) => visitor.visit_item(&**item),\n-    }\n-}\n-\n-pub fn walk_expr_opt<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                         optional_expression: &'v Option<P<Expr>>) {\n-    match *optional_expression {\n-        None => {}\n-        Some(ref expression) => visitor.visit_expr(&**expression),\n-    }\n-}\n-\n-pub fn walk_exprs<'v, V: Visitor<'v>>(visitor: &mut V, expressions: &'v [P<Expr>]) {\n-    for expression in expressions {\n-        visitor.visit_expr(&**expression)\n+        DeclLocal(ref local) => visitor.visit_local(local),\n+        DeclItem(ref item) => visitor.visit_item(item),\n     }\n }\n \n@@ -736,139 +654,142 @@ pub fn walk_mac<'v, V: Visitor<'v>>(_: &mut V, _: &'v Mac) {\n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     match expression.node {\n         ExprBox(ref subexpression) => {\n-            visitor.visit_expr(&**subexpression)\n+            visitor.visit_expr(subexpression)\n         }\n         ExprInPlace(ref place, ref subexpression) => {\n-            visitor.visit_expr(&**place);\n-            visitor.visit_expr(&**subexpression)\n+            visitor.visit_expr(place);\n+            visitor.visit_expr(subexpression)\n         }\n         ExprVec(ref subexpressions) => {\n-            walk_exprs(visitor, subexpressions)\n+            walk_list!(visitor, visit_expr, subexpressions);\n         }\n         ExprRepeat(ref element, ref count) => {\n-            visitor.visit_expr(&**element);\n-            visitor.visit_expr(&**count)\n+            visitor.visit_expr(element);\n+            visitor.visit_expr(count)\n         }\n         ExprStruct(ref path, ref fields, ref optional_base) => {\n             visitor.visit_path(path, expression.id);\n             for field in fields {\n-                visitor.visit_expr(&*field.expr)\n+                visitor.visit_ident(field.ident.span, field.ident.node);\n+                visitor.visit_expr(&field.expr)\n             }\n-            walk_expr_opt(visitor, optional_base)\n+            walk_list!(visitor, visit_expr, optional_base);\n         }\n         ExprTup(ref subexpressions) => {\n-            for subexpression in subexpressions {\n-                visitor.visit_expr(&**subexpression)\n-            }\n+            walk_list!(visitor, visit_expr, subexpressions);\n         }\n         ExprCall(ref callee_expression, ref arguments) => {\n-            for argument in arguments {\n-                visitor.visit_expr(&**argument)\n-            }\n-            visitor.visit_expr(&**callee_expression)\n+            walk_list!(visitor, visit_expr, arguments);\n+            visitor.visit_expr(callee_expression)\n         }\n-        ExprMethodCall(_, ref types, ref arguments) => {\n-            walk_exprs(visitor, arguments);\n-            for typ in types {\n-                visitor.visit_ty(&**typ)\n-            }\n+        ExprMethodCall(ref ident, ref types, ref arguments) => {\n+            visitor.visit_ident(ident.span, ident.node);\n+            walk_list!(visitor, visit_expr, arguments);\n+            walk_list!(visitor, visit_ty, types);\n         }\n         ExprBinary(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(&**left_expression);\n-            visitor.visit_expr(&**right_expression)\n+            visitor.visit_expr(left_expression);\n+            visitor.visit_expr(right_expression)\n         }\n         ExprAddrOf(_, ref subexpression) | ExprUnary(_, ref subexpression) => {\n-            visitor.visit_expr(&**subexpression)\n+            visitor.visit_expr(subexpression)\n         }\n         ExprLit(_) => {}\n         ExprCast(ref subexpression, ref typ) => {\n-            visitor.visit_expr(&**subexpression);\n-            visitor.visit_ty(&**typ)\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ty(typ)\n         }\n         ExprIf(ref head_expression, ref if_block, ref optional_else) => {\n-            visitor.visit_expr(&**head_expression);\n-            visitor.visit_block(&**if_block);\n-            walk_expr_opt(visitor, optional_else)\n+            visitor.visit_expr(head_expression);\n+            visitor.visit_block(if_block);\n+            walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhile(ref subexpression, ref block, _) => {\n-            visitor.visit_expr(&**subexpression);\n-            visitor.visit_block(&**block)\n+        ExprWhile(ref subexpression, ref block, opt_ident) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_block(block);\n+            walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n         ExprIfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n-            visitor.visit_pat(&**pattern);\n-            visitor.visit_expr(&**subexpression);\n-            visitor.visit_block(&**if_block);\n-            walk_expr_opt(visitor, optional_else);\n-        }\n-        ExprWhileLet(ref pattern, ref subexpression, ref block, _) => {\n-            visitor.visit_pat(&**pattern);\n-            visitor.visit_expr(&**subexpression);\n-            visitor.visit_block(&**block);\n-        }\n-        ExprForLoop(ref pattern, ref subexpression, ref block, _) => {\n-            visitor.visit_pat(&**pattern);\n-            visitor.visit_expr(&**subexpression);\n-            visitor.visit_block(&**block)\n-        }\n-        ExprLoop(ref block, _) => visitor.visit_block(&**block),\n+            visitor.visit_pat(pattern);\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_block(if_block);\n+            walk_list!(visitor, visit_expr, optional_else);\n+        }\n+        ExprWhileLet(ref pattern, ref subexpression, ref block, opt_ident) => {\n+            visitor.visit_pat(pattern);\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_block(block);\n+            walk_opt_ident(visitor, expression.span, opt_ident)\n+        }\n+        ExprForLoop(ref pattern, ref subexpression, ref block, opt_ident) => {\n+            visitor.visit_pat(pattern);\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_block(block);\n+            walk_opt_ident(visitor, expression.span, opt_ident)\n+        }\n+        ExprLoop(ref block, opt_ident) => {\n+            visitor.visit_block(block);\n+            walk_opt_ident(visitor, expression.span, opt_ident)\n+        }\n         ExprMatch(ref subexpression, ref arms, _) => {\n-            visitor.visit_expr(&**subexpression);\n-            for arm in arms {\n-                visitor.visit_arm(arm)\n-            }\n+            visitor.visit_expr(subexpression);\n+            walk_list!(visitor, visit_arm, arms);\n         }\n         ExprClosure(_, ref function_declaration, ref body) => {\n             visitor.visit_fn(FnKind::Closure,\n-                             &**function_declaration,\n-                             &**body,\n+                             function_declaration,\n+                             body,\n                              expression.span,\n                              expression.id)\n         }\n-        ExprBlock(ref block) => visitor.visit_block(&**block),\n+        ExprBlock(ref block) => visitor.visit_block(block),\n         ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n-            visitor.visit_expr(&**right_hand_expression);\n-            visitor.visit_expr(&**left_hand_expression)\n+            visitor.visit_expr(right_hand_expression);\n+            visitor.visit_expr(left_hand_expression)\n         }\n         ExprAssignOp(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(&**right_expression);\n-            visitor.visit_expr(&**left_expression)\n+            visitor.visit_expr(right_expression);\n+            visitor.visit_expr(left_expression)\n         }\n-        ExprField(ref subexpression, _) => {\n-            visitor.visit_expr(&**subexpression);\n+        ExprField(ref subexpression, ref ident) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ident(ident.span, ident.node);\n         }\n         ExprTupField(ref subexpression, _) => {\n-            visitor.visit_expr(&**subexpression);\n+            visitor.visit_expr(subexpression);\n         }\n         ExprIndex(ref main_expression, ref index_expression) => {\n-            visitor.visit_expr(&**main_expression);\n-            visitor.visit_expr(&**index_expression)\n+            visitor.visit_expr(main_expression);\n+            visitor.visit_expr(index_expression)\n         }\n         ExprRange(ref start, ref end) => {\n-            walk_expr_opt(visitor, start);\n-            walk_expr_opt(visitor, end)\n+            walk_list!(visitor, visit_expr, start);\n+            walk_list!(visitor, visit_expr, end);\n         }\n         ExprPath(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprBreak(_) | ExprAgain(_) => {}\n+        ExprBreak(ref opt_sp_ident) | ExprAgain(ref opt_sp_ident) => {\n+            for sp_ident in opt_sp_ident {\n+                visitor.visit_ident(sp_ident.span, sp_ident.node);\n+            }\n+        }\n         ExprRet(ref optional_expression) => {\n-            walk_expr_opt(visitor, optional_expression)\n+            walk_list!(visitor, visit_expr, optional_expression);\n         }\n         ExprMac(ref mac) => visitor.visit_mac(mac),\n         ExprParen(ref subexpression) => {\n-            visitor.visit_expr(&**subexpression)\n+            visitor.visit_expr(subexpression)\n         }\n         ExprInlineAsm(ref ia) => {\n-            for input in &ia.inputs {\n-                let (_, ref input) = *input;\n-                visitor.visit_expr(&**input)\n+            for &(_, ref input) in &ia.inputs {\n+                visitor.visit_expr(&input)\n             }\n-            for output in &ia.outputs {\n-                let (_, ref output, _) = *output;\n-                visitor.visit_expr(&**output)\n+            for &(_, ref output, _) in &ia.outputs {\n+                visitor.visit_expr(&output)\n             }\n         }\n     }\n@@ -877,12 +798,8 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n }\n \n pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n-    for pattern in &arm.pats {\n-        visitor.visit_pat(&**pattern)\n-    }\n-    walk_expr_opt(visitor, &arm.guard);\n-    visitor.visit_expr(&*arm.body);\n-    for attr in &arm.attrs {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_pat, &arm.pats);\n+    walk_list!(visitor, visit_expr, &arm.guard);\n+    visitor.visit_expr(&arm.body);\n+    walk_list!(visitor, visit_attribute, &arm.attrs);\n }"}]}