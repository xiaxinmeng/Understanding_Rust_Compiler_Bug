{"sha": "61026ae621ffbc6d7538cfb0add49b8fc5638e86", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMDI2YWU2MjFmZmJjNmQ3NTM4Y2ZiMGFkZDQ5YjhmYzU2MzhlODY=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-01T23:30:21Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-02T01:12:32Z"}, "message": "rt::io: Add Bytes iterator for Reader\n\nAn iterator that simply calls `.read_bytes()` each iteration.\n\nI think choosing to own the Reader value and implementing Decorator to\nallow extracting it is the most generically useful. The Reader type\nvariable can of course be some kind of reference type that implements\nReader.", "tree": {"sha": "667b44fd4a0c33e9042f18f670d9c09d8c682448", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/667b44fd4a0c33e9042f18f670d9c09d8c682448"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61026ae621ffbc6d7538cfb0add49b8fc5638e86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61026ae621ffbc6d7538cfb0add49b8fc5638e86", "html_url": "https://github.com/rust-lang/rust/commit/61026ae621ffbc6d7538cfb0add49b8fc5638e86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61026ae621ffbc6d7538cfb0add49b8fc5638e86/comments", "author": null, "committer": null, "parents": [{"sha": "1f4aba8cbf7caa3a82b52b6f171221ed6067eed5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4aba8cbf7caa3a82b52b6f171221ed6067eed5", "html_url": "https://github.com/rust-lang/rust/commit/1f4aba8cbf7caa3a82b52b6f171221ed6067eed5"}], "stats": {"total": 84, "additions": 83, "deletions": 1}, "files": [{"sha": "0b93a2ad2ca508c2af5e3f550f643e5433781986", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/61026ae621ffbc6d7538cfb0add49b8fc5638e86/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61026ae621ffbc6d7538cfb0add49b8fc5638e86/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=61026ae621ffbc6d7538cfb0add49b8fc5638e86", "patch": "@@ -15,8 +15,9 @@\n \n use uint;\n use int;\n+use iterator::Iterator;\n use vec;\n-use rt::io::{Reader, Writer};\n+use rt::io::{Reader, Writer, Decorator};\n use rt::io::{read_error, standard_error, EndOfFile, DEFAULT_BUF_SIZE};\n use option::{Option, Some, None};\n use unstable::finally::Finally;\n@@ -62,6 +63,16 @@ pub trait ReaderUtil {\n     /// Raises the same conditions as the `read` method.\n     fn read_to_end(&mut self) -> ~[u8];\n \n+    /// Create an iterator that reads a single byte on\n+    /// each iteration, until EOF.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the same conditions as the `read` method, for\n+    /// each call to its `.next()` method.\n+    /// Ends the iteration if the condition is handled.\n+    fn bytes(self) -> Bytes<Self>;\n+\n }\n \n pub trait ReaderByteConversions {\n@@ -337,6 +348,35 @@ impl<T: Reader> ReaderUtil for T {\n         }\n         return buf;\n     }\n+\n+    fn bytes(self) -> Bytes<T> {\n+        Bytes{reader: self}\n+    }\n+}\n+\n+/// An iterator that reads a single byte on each iteration,\n+/// until EOF.\n+///\n+/// # Failure\n+///\n+/// Raises the same conditions as the `read` method, for\n+/// each call to its `.next()` method.\n+/// Ends the iteration if the condition is handled.\n+pub struct Bytes<T> {\n+    priv reader: T,\n+}\n+\n+impl<R> Decorator<R> for Bytes<R> {\n+    fn inner(self) -> R { self.reader }\n+    fn inner_ref<'a>(&'a self) -> &'a R { &self.reader }\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R { &mut self.reader }\n+}\n+\n+impl<'self, R: Reader> Iterator<u8> for Bytes<R> {\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> {\n+        self.reader.read_byte()\n+    }\n }\n \n impl<T: Reader> ReaderByteConversions for T {\n@@ -646,6 +686,48 @@ mod test {\n         }\n     }\n \n+    #[test]\n+    fn bytes_0_bytes() {\n+        let mut reader = MockReader::new();\n+        let count = Cell::new(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    Some(0)\n+                } else {\n+                    buf[0] = 10;\n+                    Some(1)\n+                }\n+            }\n+        };\n+        let byte = reader.bytes().next();\n+        assert!(byte == Some(10));\n+    }\n+\n+    #[test]\n+    fn bytes_eof() {\n+        let mut reader = MockReader::new();\n+        reader.read = |_| None;\n+        let byte = reader.bytes().next();\n+        assert!(byte == None);\n+    }\n+\n+    #[test]\n+    fn bytes_error() {\n+        let mut reader = MockReader::new();\n+        reader.read = |_| {\n+            read_error::cond.raise(placeholder_error());\n+            None\n+        };\n+        let mut it = reader.bytes();\n+        do read_error::cond.trap(|_| ()).inside {\n+            let byte = it.next();\n+            assert!(byte == None);\n+        }\n+    }\n+\n+\n     #[test]\n     fn read_bytes() {\n         let mut reader = MemReader::new(~[10, 11, 12, 13]);"}]}