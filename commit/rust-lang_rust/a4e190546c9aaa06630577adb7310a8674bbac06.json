{"sha": "a4e190546c9aaa06630577adb7310a8674bbac06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZTE5MDU0NmM5YWFhMDY2MzA1NzdhZGI3MzEwYTg2NzRiYmFjMDY=", "commit": {"author": {"name": "jD91mZM2", "email": "me@krake.one", "date": "2018-06-27T08:11:46Z"}, "committer": {"name": "jD91mZM2", "email": "me@krake.one", "date": "2018-06-27T08:12:34Z"}, "message": "Horrible attempt at cleaning things up that probably just made it worse", "tree": {"sha": "668acb3e445410a3bfd64b688e5e45e105e87c9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/668acb3e445410a3bfd64b688e5e45e105e87c9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4e190546c9aaa06630577adb7310a8674bbac06", "comment_count": 0, "verification": {"verified": false, "reason": "unverified_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEvF2uTsFosfm5TJhQMFXVRymnJmYFAlszRvIACgkQMFXVRymn\nJmZrzgf/W+XdZ2zPUHrdKGjBLrbUpIfj8k3cGirzGentfDbV2zlIt3AW9Lmszftr\nI/PbQGG+6vwtLwxr8GsYh0NgKvI5kyoZZj+QHVb4hqx2l5nk6xg9MNC0EcFOrDRC\nvYl2UysknNJSIsZRMlkNU3pelclrB/RUvoxrz7P2Y3hfUbBgzp83glI3TnauGsqY\nP0OWK8mN3Z8fXCYNKTqTGNJXyQybeDCUhz6Lo8qI/ZQCZ7OZlDOlOQiS5A789Wut\nIlDe1uvXUmQ7NFPAtW9rgSnoay2nh3u+ycujhXYq37+bokutk5QrH1bXw2eLsYa4\nWYJSR/9ZSvYnXNhfF2ekOHiKwN+0wQ==\n=Wz3L\n-----END PGP SIGNATURE-----", "payload": "tree 668acb3e445410a3bfd64b688e5e45e105e87c9a\nparent 916f7c864a1da3bb822a282a9f7386c78bdc2c69\nauthor jD91mZM2 <me@krake.one> 1530087106 +0200\ncommitter jD91mZM2 <me@krake.one> 1530087154 +0200\n\nHorrible attempt at cleaning things up that probably just made it worse\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4e190546c9aaa06630577adb7310a8674bbac06", "html_url": "https://github.com/rust-lang/rust/commit/a4e190546c9aaa06630577adb7310a8674bbac06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4e190546c9aaa06630577adb7310a8674bbac06/comments", "author": {"login": "jD91mZM2", "id": 12830969, "node_id": "MDQ6VXNlcjEyODMwOTY5", "avatar_url": "https://avatars.githubusercontent.com/u/12830969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jD91mZM2", "html_url": "https://github.com/jD91mZM2", "followers_url": "https://api.github.com/users/jD91mZM2/followers", "following_url": "https://api.github.com/users/jD91mZM2/following{/other_user}", "gists_url": "https://api.github.com/users/jD91mZM2/gists{/gist_id}", "starred_url": "https://api.github.com/users/jD91mZM2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jD91mZM2/subscriptions", "organizations_url": "https://api.github.com/users/jD91mZM2/orgs", "repos_url": "https://api.github.com/users/jD91mZM2/repos", "events_url": "https://api.github.com/users/jD91mZM2/events{/privacy}", "received_events_url": "https://api.github.com/users/jD91mZM2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jD91mZM2", "id": 12830969, "node_id": "MDQ6VXNlcjEyODMwOTY5", "avatar_url": "https://avatars.githubusercontent.com/u/12830969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jD91mZM2", "html_url": "https://github.com/jD91mZM2", "followers_url": "https://api.github.com/users/jD91mZM2/followers", "following_url": "https://api.github.com/users/jD91mZM2/following{/other_user}", "gists_url": "https://api.github.com/users/jD91mZM2/gists{/gist_id}", "starred_url": "https://api.github.com/users/jD91mZM2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jD91mZM2/subscriptions", "organizations_url": "https://api.github.com/users/jD91mZM2/orgs", "repos_url": "https://api.github.com/users/jD91mZM2/repos", "events_url": "https://api.github.com/users/jD91mZM2/events{/privacy}", "received_events_url": "https://api.github.com/users/jD91mZM2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "916f7c864a1da3bb822a282a9f7386c78bdc2c69", "url": "https://api.github.com/repos/rust-lang/rust/commits/916f7c864a1da3bb822a282a9f7386c78bdc2c69", "html_url": "https://github.com/rust-lang/rust/commit/916f7c864a1da3bb822a282a9f7386c78bdc2c69"}], "stats": {"total": 2897, "additions": 1348, "deletions": 1549}, "files": [{"sha": "c86b5d78524fbe1958a5b8ec9d3fed7cedd45235", "filename": "src/libstd/sys/redox/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs?ref=a4e190546c9aaa06630577adb7310a8674bbac06", "patch": "@@ -36,6 +36,7 @@ pub mod io;\n pub mod net;\n pub mod process;\n pub mod thread;\n+pub(crate) mod unixsocket;\n \n /// A prelude for conveniently writing platform-specific code.\n ///"}, {"sha": "eb25688515574a2d85f0cc7970e5e7e5ab3ff874", "filename": "src/libstd/sys/redox/ext/net.rs", "status": "modified", "additions": 3, "deletions": 702, "changes": 705, "blob_url": "https://github.com/rust-lang/rust/blob/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs?ref=a4e190546c9aaa06630577adb7310a8674bbac06", "patch": "@@ -1,702 +1,3 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![unstable(feature = \"unix_socket_redox\", reason = \"new feature\", issue=\"51553\")]\n-\n-//! Unix-specific networking functionality\n-\n-use fmt;\n-use io::{self, Error, ErrorKind, Initializer};\n-use net::Shutdown;\n-use os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n-use path::Path;\n-use time::Duration;\n-use sys::{cvt, fd::FileDesc, syscall};\n-\n-/// An address associated with a Unix socket.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::os::unix::net::UnixListener;\n-///\n-/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n-///     Ok(sock) => sock,\n-///     Err(e) => {\n-///         println!(\"Couldn't bind: {:?}\", e);\n-///         return\n-///     }\n-/// };\n-/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-/// ```\n-#[derive(Clone)]\n-pub struct SocketAddr(());\n-\n-impl SocketAddr {\n-    /// Returns the contents of this address if it is a `pathname` address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// With a pathname:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    /// use std::path::Path;\n-    ///\n-    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n-    /// ```\n-    ///\n-    /// Without a pathname:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.as_pathname(), None);\n-    /// ```\n-    pub fn as_pathname(&self) -> Option<&Path> {\n-        None\n-    }\n-}\n-impl fmt::Debug for SocketAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"SocketAddr\")\n-    }\n-}\n-\n-/// A Unix stream socket.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::net::UnixStream;\n-/// use std::io::prelude::*;\n-///\n-/// let mut stream = UnixStream::connect(\"/path/to/my/socket\").unwrap();\n-/// stream.write_all(b\"hello world\").unwrap();\n-/// let mut response = String::new();\n-/// stream.read_to_string(&mut response).unwrap();\n-/// println!(\"{}\", response);\n-/// ```\n-pub struct UnixStream(FileDesc);\n-\n-impl fmt::Debug for UnixStream {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixStream\");\n-        builder.field(\"fd\", &self.0.raw());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixStream {\n-    /// Connects to the socket named by `path`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n-        if let Some(s) = path.as_ref().to_str() {\n-            cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CLOEXEC))\n-                .map(FileDesc::new)\n-                .map(UnixStream)\n-        } else {\n-            Err(Error::new(\n-                ErrorKind::Other,\n-                \"UnixStream::connect: non-utf8 paths not supported on redox\"\n-            ))\n-        }\n-    }\n-\n-    /// Creates an unnamed pair of connected sockets.\n-    ///\n-    /// Returns two `UnixStream`s which are connected to each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let (sock1, sock2) = match UnixStream::pair() {\n-    ///     Ok((sock1, sock2)) => (sock1, sock2),\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n-        let server = cvt(syscall::open(\"chan:\", syscall::O_CREAT | syscall::O_CLOEXEC))\n-            .map(FileDesc::new)?;\n-        let client = server.duplicate_path(b\"connect\")?;\n-        let stream = server.duplicate_path(b\"listen\")?;\n-        Ok((UnixStream(client), UnixStream(stream)))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixStream` is a reference to the same stream that this\n-    /// object references. Both handles will read and write the same stream of\n-    /// data, and options set on one stream will be propagated to the other\n-    /// stream.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n-    /// ```\n-    pub fn try_clone(&self) -> io::Result<UnixStream> {\n-        self.0.duplicate().map(UnixStream)\n-    }\n-\n-    /// Returns the socket address of the local half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::local_addr unimplemented on redox\"))\n-    }\n-\n-    /// Returns the socket address of the remote half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n-    /// ```\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::peer_addr unimplemented on redox\"))\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`read`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    pub fn set_read_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::set_read_timeout unimplemented on redox\"))\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`write`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n-    /// passed to this method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::net::UdpSocket;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n-    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    pub fn set_write_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::set_write_timeout unimplemented on redox\"))\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::read_timeout unimplemented on redox\"))\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::write_timeout unimplemented on redox\"))\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n-    /// ```\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// if let Ok(Some(err)) = socket.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns None.\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        Ok(None)\n-    }\n-\n-    /// Shuts down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    /// ```\n-    pub fn shutdown(&self, _how: Shutdown) -> io::Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::shutdown unimplemented on redox\"))\n-    }\n-}\n-\n-impl io::Read for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        io::Read::read(&mut &*self, buf)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-impl<'a> io::Read for &'a UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-impl io::Write for UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        io::Write::write(&mut &*self, buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        io::Write::flush(&mut &*self)\n-    }\n-}\n-\n-impl<'a> io::Write for &'a UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-impl AsRawFd for UnixStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.0.raw()\n-    }\n-}\n-\n-impl FromRawFd for UnixStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n-        UnixStream(FileDesc::new(fd))\n-    }\n-}\n-\n-impl IntoRawFd for UnixStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_raw()\n-    }\n-}\n-\n-/// A structure representing a Unix domain socket server.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-///\n-/// // accept connections and process them, spawning a new thread for each one\n-/// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             /* connection succeeded */\n-///             thread::spawn(|| handle_client(stream));\n-///         }\n-///         Err(err) => {\n-///             /* connection failed */\n-///             break;\n-///         }\n-///     }\n-/// }\n-/// ```\n-pub struct UnixListener(FileDesc);\n-\n-impl fmt::Debug for UnixListener {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixListener\");\n-        builder.field(\"fd\", &self.0.raw());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixListener {\n-    /// Creates a new `UnixListener` bound to the specified socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n-        if let Some(s) = path.as_ref().to_str() {\n-            cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CREAT | syscall::O_CLOEXEC))\n-                .map(FileDesc::new)\n-                .map(UnixListener)\n-        } else {\n-            Err(Error::new(\n-                ErrorKind::Other,\n-                \"UnixListener::bind: non-utf8 paths not supported on redox\"\n-            ))\n-        }\n-    }\n-\n-    /// Accepts a new incoming connection to this listener.\n-    ///\n-    /// This function will block the calling thread until a new Unix connection\n-    /// is established. When established, the corresponding [`UnixStream`] and\n-    /// the remote peer's address will be returned.\n-    ///\n-    /// [`UnixStream`]: ../../../../std/os/unix/net/struct.UnixStream.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// match listener.accept() {\n-    ///     Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n-    ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n-    /// }\n-    /// ```\n-    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n-        self.0.duplicate_path(b\"listen\").map(|fd| (UnixStream(fd), SocketAddr(())))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixListener` is a reference to the same socket that this\n-    /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one listener will affect the other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n-    /// ```\n-    pub fn try_clone(&self) -> io::Result<UnixListener> {\n-        self.0.duplicate().map(UnixListener)\n-    }\n-\n-    /// Returns the local socket address of this listener.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        Err(Error::new(ErrorKind::Other, \"UnixListener::local_addr unimplemented on redox\"))\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n-    /// ```\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    ///\n-    /// if let Ok(Some(err)) = listener.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns None.\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        Ok(None)\n-    }\n-\n-    /// Returns an iterator over incoming connections.\n-    ///\n-    /// The iterator will never return [`None`] and will also not yield the\n-    /// peer's [`SocketAddr`] structure.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`SocketAddr`]: struct.SocketAddr.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::thread;\n-    /// use std::os::unix::net::{UnixStream, UnixListener};\n-    ///\n-    /// fn handle_client(stream: UnixStream) {\n-    ///     // ...\n-    /// }\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// for stream in listener.incoming() {\n-    ///     match stream {\n-    ///         Ok(stream) => {\n-    ///             thread::spawn(|| handle_client(stream));\n-    ///         }\n-    ///         Err(err) => {\n-    ///             break;\n-    ///         }\n-    ///     }\n-    /// }\n-    /// ```\n-    pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n-        Incoming { listener: self }\n-    }\n-}\n-\n-impl AsRawFd for UnixListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.0.raw()\n-    }\n-}\n-\n-impl FromRawFd for UnixListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n-        UnixListener(FileDesc::new(fd))\n-    }\n-}\n-\n-impl IntoRawFd for UnixListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_raw()\n-    }\n-}\n-\n-impl<'a> IntoIterator for &'a UnixListener {\n-    type Item = io::Result<UnixStream>;\n-    type IntoIter = Incoming<'a>;\n-\n-    fn into_iter(self) -> Incoming<'a> {\n-        self.incoming()\n-    }\n-}\n-\n-/// An iterator over incoming connections to a [`UnixListener`].\n-///\n-/// It will never return [`None`].\n-///\n-/// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-/// [`UnixListener`]: struct.UnixListener.html\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-///\n-/// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             thread::spawn(|| handle_client(stream));\n-///         }\n-///         Err(err) => {\n-///             break;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[derive(Debug)]\n-pub struct Incoming<'a> {\n-    listener: &'a UnixListener,\n-}\n-\n-impl<'a> Iterator for Incoming<'a> {\n-    type Item = io::Result<UnixStream>;\n-\n-    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n-        Some(self.listener.accept().map(|s| s.0))\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::max_value(), None)\n-    }\n-}\n+#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub use sys_common::unixsocket::*;"}, {"sha": "78ca0f16af48d1a514e5f64419f2cd5d25703017", "filename": "src/libstd/sys/redox/ext/unixsocket.rs", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys%2Fredox%2Fext%2Funixsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys%2Fredox%2Fext%2Funixsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Funixsocket.rs?ref=a4e190546c9aaa06630577adb7310a8674bbac06", "patch": "@@ -0,0 +1,250 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+\n+use fmt;\n+use io::{self, Error, ErrorKind, Initializer};\n+use net::Shutdown;\n+use os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n+use path::Path;\n+use time::Duration;\n+use sys::{cvt, fd::FileDesc, syscall};\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+#[derive(Clone)]\n+pub(crate) struct SocketAddr(());\n+\n+impl SocketAddr {\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn as_pathname(&self) -> Option<&Path> {\n+        None\n+    }\n+}\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"SocketAddr\")\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub(crate) struct UnixStream(FileDesc);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixStream {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixStream\");\n+        builder.field(\"fd\", &self.0.raw());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        if let Ok(addr) = self.peer_addr() {\n+            builder.field(\"peer\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixStream {\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn connect(path: &Path) -> io::Result<UnixStream> {\n+        if let Some(s) = path.to_str() {\n+            cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CLOEXEC))\n+                .map(FileDesc::new)\n+                .map(UnixStream)\n+        } else {\n+            Err(Error::new(\n+                ErrorKind::Other,\n+                \"UnixStream::connect: non-utf8 paths not supported on redox\"\n+            ))\n+        }\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn pair() -> io::Result<(UnixStream, UnixStream)> {\n+        let server = cvt(syscall::open(\"chan:\", syscall::O_CREAT | syscall::O_CLOEXEC))\n+            .map(FileDesc::new)?;\n+        let client = server.duplicate_path(b\"connect\")?;\n+        let stream = server.duplicate_path(b\"listen\")?;\n+        Ok((UnixStream(client), UnixStream(stream)))\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn try_clone(&self) -> io::Result<UnixStream> {\n+        self.0.duplicate().map(UnixStream)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn local_addr(&self) -> io::Result<SocketAddr> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::local_addr unimplemented on redox\"))\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::peer_addr unimplemented on redox\"))\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn set_read_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::set_read_timeout unimplemented on redox\"))\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn set_write_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::set_write_timeout unimplemented on redox\"))\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::read_timeout unimplemented on redox\"))\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::write_timeout unimplemented on redox\"))\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        Ok(None)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn shutdown(&self, _how: Shutdown) -> io::Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::shutdown unimplemented on redox\"))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> io::Read for &'a UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        Initializer::nop()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> io::Write for &'a UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl AsRawFd for UnixStream {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.raw()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl FromRawFd for UnixStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n+        UnixStream(FileDesc::new(fd))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl IntoRawFd for UnixStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_raw()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub(crate) struct UnixListener(FileDesc);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixListener {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixListener\");\n+        builder.field(\"fd\", &self.0.raw());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixListener {\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn bind(path: &Path) -> io::Result<UnixListener> {\n+        if let Some(s) = path.to_str() {\n+            cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CREAT | syscall::O_CLOEXEC))\n+                .map(FileDesc::new)\n+                .map(UnixListener)\n+        } else {\n+            Err(Error::new(\n+                ErrorKind::Other,\n+                \"UnixListener::bind: non-utf8 paths not supported on redox\"\n+            ))\n+        }\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n+        self.0.duplicate_path(b\"listen\").map(|fd| (UnixStream(fd), SocketAddr(())))\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn try_clone(&self) -> io::Result<UnixListener> {\n+        self.0.duplicate().map(UnixListener)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn local_addr(&self) -> io::Result<SocketAddr> {\n+        Err(Error::new(ErrorKind::Other, \"UnixListener::local_addr unimplemented on redox\"))\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub(crate) fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        Ok(None)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl AsRawFd for UnixListener {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.raw()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl FromRawFd for UnixListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n+        UnixListener(FileDesc::new(fd))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl IntoRawFd for UnixListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_raw()\n+    }\n+}"}, {"sha": "b7a1b45e9b7947f0324d12241c888ee704338c6a", "filename": "src/libstd/sys/unix/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs?ref=a4e190546c9aaa06630577adb7310a8674bbac06", "patch": "@@ -44,6 +44,7 @@ pub mod process;\n pub mod raw;\n pub mod thread;\n pub mod net;\n+pub(crate) mod unixsocket;\n \n /// A prelude for conveniently writing platform-specific code.\n ///"}, {"sha": "77bca85fe88351d894f98558b2ea7ccaee3d8f7d", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 22, "deletions": 847, "changes": 869, "blob_url": "https://github.com/rust-lang/rust/blob/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=a4e190546c9aaa06630577adb7310a8674bbac06", "patch": "@@ -25,40 +25,42 @@ mod libc {\n     pub struct sockaddr_un;\n }\n \n-use ascii;\n-use ffi::OsStr;\n use fmt;\n-use io::{self, Initializer};\n+use io;\n use mem;\n use net::{self, Shutdown};\n use os::unix::ffi::OsStrExt;\n use os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n use path::Path;\n use time::Duration;\n-use sys::{self, cvt};\n+use sys::ext::unixsocket as inner;\n use sys::net::Socket;\n+use sys::{self, cvt};\n use sys_common::{self, AsInner, FromInner, IntoInner};\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub use sys_common::unixsocket::*;\n+\n #[cfg(any(target_os = \"linux\", target_os = \"android\",\n           target_os = \"dragonfly\", target_os = \"freebsd\",\n           target_os = \"openbsd\", target_os = \"netbsd\",\n           target_os = \"haiku\", target_os = \"bitrig\"))]\n-use libc::MSG_NOSIGNAL;\n+pub(crate) use libc::MSG_NOSIGNAL;\n #[cfg(not(any(target_os = \"linux\", target_os = \"android\",\n               target_os = \"dragonfly\", target_os = \"freebsd\",\n               target_os = \"openbsd\", target_os = \"netbsd\",\n               target_os = \"haiku\", target_os = \"bitrig\")))]\n-const MSG_NOSIGNAL: libc::c_int = 0x0;\n+pub(crate) const MSG_NOSIGNAL: libc::c_int = 0x0;\n \n-fn sun_path_offset() -> usize {\n+pub(crate) fn sun_path_offset() -> usize {\n     // Work with an actual instance of the type since using a null pointer is UB\n     let addr: libc::sockaddr_un = unsafe { mem::uninitialized() };\n     let base = &addr as *const _ as usize;\n     let path = &addr.sun_path as *const _ as usize;\n     path - base\n }\n \n-unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> {\n+pub(crate) unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> {\n     let mut addr: libc::sockaddr_un = mem::zeroed();\n     addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n \n@@ -87,573 +89,38 @@ unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::sockl\n     Ok((addr, len as libc::socklen_t))\n }\n \n-enum AddressKind<'a> {\n-    Unnamed,\n-    Pathname(&'a Path),\n-    Abstract(&'a [u8]),\n-}\n-\n-/// An address associated with a Unix socket.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::os::unix::net::UnixListener;\n-///\n-/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n-///     Ok(sock) => sock,\n-///     Err(e) => {\n-///         println!(\"Couldn't bind: {:?}\", e);\n-///         return\n-///     }\n-/// };\n-/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-/// ```\n-#[derive(Clone)]\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct SocketAddr {\n-    addr: libc::sockaddr_un,\n-    len: libc::socklen_t,\n-}\n-\n-impl SocketAddr {\n-    fn new<F>(f: F) -> io::Result<SocketAddr>\n-        where F: FnOnce(*mut libc::sockaddr, *mut libc::socklen_t) -> libc::c_int\n-    {\n-        unsafe {\n-            let mut addr: libc::sockaddr_un = mem::zeroed();\n-            let mut len = mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;\n-            cvt(f(&mut addr as *mut _ as *mut _, &mut len))?;\n-            SocketAddr::from_parts(addr, len)\n-        }\n-    }\n-\n-    fn from_parts(addr: libc::sockaddr_un, mut len: libc::socklen_t) -> io::Result<SocketAddr> {\n-        if len == 0 {\n-            // When there is a datagram from unnamed unix socket\n-            // linux returns zero bytes of address\n-            len = sun_path_offset() as libc::socklen_t;  // i.e. zero-length address\n-        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n-            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                      \"file descriptor did not correspond to a Unix socket\"));\n-        }\n-\n-        Ok(SocketAddr {\n-            addr,\n-            len,\n-        })\n-    }\n-\n-    /// Returns true if and only if the address is unnamed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// A named address:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.is_unnamed(), false);\n-    /// ```\n-    ///\n-    /// An unnamed address:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.is_unnamed(), true);\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn is_unnamed(&self) -> bool {\n-        if let AddressKind::Unnamed = self.address() {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// Returns the contents of this address if it is a `pathname` address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// With a pathname:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    /// use std::path::Path;\n-    ///\n-    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n-    /// ```\n-    ///\n-    /// Without a pathname:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let socket = UnixDatagram::unbound().unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// assert_eq!(addr.as_pathname(), None);\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn as_pathname(&self) -> Option<&Path> {\n-        if let AddressKind::Pathname(path) = self.address() {\n-            Some(path)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn address<'a>(&'a self) -> AddressKind<'a> {\n-        let len = self.len as usize - sun_path_offset();\n-        let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n-\n-        // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses\n-        if len == 0\n-            || (cfg!(not(any(target_os = \"linux\", target_os = \"android\")))\n-                && self.addr.sun_path[0] == 0)\n-        {\n-            AddressKind::Unnamed\n-        } else if self.addr.sun_path[0] == 0 {\n-            AddressKind::Abstract(&path[1..len])\n-        } else {\n-            AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for SocketAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match self.address() {\n-            AddressKind::Unnamed => write!(fmt, \"(unnamed)\"),\n-            AddressKind::Abstract(name) => write!(fmt, \"{} (abstract)\", AsciiEscaped(name)),\n-            AddressKind::Pathname(path) => write!(fmt, \"{:?} (pathname)\", path),\n-        }\n-    }\n-}\n-\n-struct AsciiEscaped<'a>(&'a [u8]);\n-\n-impl<'a> fmt::Display for AsciiEscaped<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"\\\"\")?;\n-        for byte in self.0.iter().cloned().flat_map(ascii::escape_default) {\n-            write!(fmt, \"{}\", byte as char)?;\n-        }\n-        write!(fmt, \"\\\"\")\n-    }\n-}\n-\n-/// A Unix stream socket.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::net::UnixStream;\n-/// use std::io::prelude::*;\n-///\n-/// let mut stream = UnixStream::connect(\"/path/to/my/socket\").unwrap();\n-/// stream.write_all(b\"hello world\").unwrap();\n-/// let mut response = String::new();\n-/// stream.read_to_string(&mut response).unwrap();\n-/// println!(\"{}\", response);\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixStream(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixStream {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixStream\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixStream {\n-    /// Connects to the socket named by `path`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n-        fn inner(path: &Path) -> io::Result<UnixStream> {\n-            unsafe {\n-                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n-                Ok(UnixStream(inner))\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Creates an unnamed pair of connected sockets.\n-    ///\n-    /// Returns two `UnixStream`s which are connected to each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let (sock1, sock2) = match UnixStream::pair() {\n-    ///     Ok((sock1, sock2)) => (sock1, sock2),\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n-        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-        Ok((UnixStream(i1), UnixStream(i2)))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixStream` is a reference to the same stream that this\n-    /// object references. Both handles will read and write the same stream of\n-    /// data, and options set on one stream will be propagated to the other\n-    /// stream.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixStream> {\n-        self.0.duplicate().map(UnixStream)\n-    }\n-\n-    /// Returns the socket address of the local half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Returns the socket address of the remote half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`read`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`write`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n-    /// passed to this method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::net::UdpSocket;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n-    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// if let Ok(Some(err)) = socket.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns None.\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Shuts down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        self.0.shutdown(how)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl io::Read for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        io::Read::read(&mut &*self, buf)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Read for &'a UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl io::Write for UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        io::Write::write(&mut &*self, buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        io::Write::flush(&mut &*self)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Write for &'a UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n-        UnixStream(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl AsRawFd for net::TcpStream {\n     fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl AsRawFd for net::TcpListener {\n     fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl AsRawFd for net::UdpSocket {\n     fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n }\n \n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl FromRawFd for net::TcpStream {\n     unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n         let socket = sys::net::Socket::from_inner(fd);\n         net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n     }\n }\n \n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl FromRawFd for net::TcpListener {\n     unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n         let socket = sys::net::Socket::from_inner(fd);\n         net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n     }\n }\n \n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl FromRawFd for net::UdpSocket {\n     unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n         let socket = sys::net::Socket::from_inner(fd);\n@@ -680,300 +147,6 @@ impl IntoRawFd for net::UdpSocket {\n     }\n }\n \n-/// A structure representing a Unix domain socket server.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-///\n-/// // accept connections and process them, spawning a new thread for each one\n-/// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             /* connection succeeded */\n-///             thread::spawn(|| handle_client(stream));\n-///         }\n-///         Err(err) => {\n-///             /* connection failed */\n-///             break;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixListener(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixListener {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixListener\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixListener {\n-    /// Creates a new `UnixListener` bound to the specified socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n-        fn inner(path: &Path) -> io::Result<UnixListener> {\n-            unsafe {\n-                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len as _))?;\n-                cvt(libc::listen(*inner.as_inner(), 128))?;\n-\n-                Ok(UnixListener(inner))\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Accepts a new incoming connection to this listener.\n-    ///\n-    /// This function will block the calling thread until a new Unix connection\n-    /// is established. When established, the corresponding [`UnixStream`] and\n-    /// the remote peer's address will be returned.\n-    ///\n-    /// [`UnixStream`]: ../../../../std/os/unix/net/struct.UnixStream.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// match listener.accept() {\n-    ///     Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n-    ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n-        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n-        let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n-        let sock = self.0.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n-        let addr = SocketAddr::from_parts(storage, len)?;\n-        Ok((UnixStream(sock), addr))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixListener` is a reference to the same socket that this\n-    /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one listener will affect the other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixListener> {\n-        self.0.duplicate().map(UnixListener)\n-    }\n-\n-    /// Returns the local socket address of this listener.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/tmp/sock\").unwrap();\n-    ///\n-    /// if let Ok(Some(err)) = listener.take_error() {\n-    ///     println!(\"Got error: {:?}\", err);\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns None.\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Returns an iterator over incoming connections.\n-    ///\n-    /// The iterator will never return [`None`] and will also not yield the\n-    /// peer's [`SocketAddr`] structure.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`SocketAddr`]: struct.SocketAddr.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::thread;\n-    /// use std::os::unix::net::{UnixStream, UnixListener};\n-    ///\n-    /// fn handle_client(stream: UnixStream) {\n-    ///     // ...\n-    /// }\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// for stream in listener.incoming() {\n-    ///     match stream {\n-    ///         Ok(stream) => {\n-    ///             thread::spawn(|| handle_client(stream));\n-    ///         }\n-    ///         Err(err) => {\n-    ///             break;\n-    ///         }\n-    ///     }\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n-        Incoming { listener: self }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n-        UnixListener(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> IntoIterator for &'a UnixListener {\n-    type Item = io::Result<UnixStream>;\n-    type IntoIter = Incoming<'a>;\n-\n-    fn into_iter(self) -> Incoming<'a> {\n-        self.incoming()\n-    }\n-}\n-\n-/// An iterator over incoming connections to a [`UnixListener`].\n-///\n-/// It will never return [`None`].\n-///\n-/// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-/// [`UnixListener`]: struct.UnixListener.html\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-///\n-/// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             thread::spawn(|| handle_client(stream));\n-///         }\n-///         Err(err) => {\n-///             break;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[derive(Debug)]\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct Incoming<'a> {\n-    listener: &'a UnixListener,\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> Iterator for Incoming<'a> {\n-    type Item = io::Result<UnixStream>;\n-\n-    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n-        Some(self.listener.accept().map(|s| s.0))\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::max_value(), None)\n-    }\n-}\n-\n /// A Unix datagram socket.\n ///\n /// # Examples\n@@ -1150,7 +323,8 @@ impl UnixDatagram {\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+        inner::SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+            .map(SocketAddr)\n     }\n \n     /// Returns the address of this socket's peer.\n@@ -1171,7 +345,8 @@ impl UnixDatagram {\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n+        inner::SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+            .map(SocketAddr)\n     }\n \n     /// Receives data from the socket.\n@@ -1194,7 +369,7 @@ impl UnixDatagram {\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         let mut count = 0;\n-        let addr = SocketAddr::new(|addr, len| {\n+        let addr = SocketAddr(inner::SocketAddr::new(|addr, len| {\n             unsafe {\n                 count = libc::recvfrom(*self.0.as_inner(),\n                                        buf.as_mut_ptr() as *mut _,\n@@ -1210,7 +385,7 @@ impl UnixDatagram {\n                     -1\n                 }\n             }\n-        })?;\n+        })?);\n \n         Ok((count as usize, addr))\n     }"}, {"sha": "f6996ecd66feb308e9633f52d7d5ff2c5e86eea0", "filename": "src/libstd/sys/unix/ext/unixsocket.rs", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys%2Funix%2Fext%2Funixsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys%2Funix%2Fext%2Funixsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Funixsocket.rs?ref=a4e190546c9aaa06630577adb7310a8674bbac06", "patch": "@@ -0,0 +1,366 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+\n+//! Unix-specific networking functionality\n+\n+#[cfg(unix)]\n+use libc;\n+\n+// FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n+#[cfg(not(unix))]\n+mod libc {\n+    pub use libc::c_int;\n+    pub type socklen_t = u32;\n+    pub struct sockaddr;\n+    #[derive(Clone)]\n+    pub struct sockaddr_un;\n+}\n+\n+use ascii;\n+use ffi::OsStr;\n+use fmt;\n+use io::{self, Initializer};\n+use mem;\n+use net::Shutdown;\n+use os::unix::ffi::OsStrExt;\n+use os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n+use path::Path;\n+use time::Duration;\n+use sys::cvt;\n+use sys::net::Socket;\n+use sys::ext::net::*;\n+use sys_common::{AsInner, FromInner, IntoInner};\n+\n+enum AddressKind<'a> {\n+    Unnamed,\n+    Pathname(&'a Path),\n+    Abstract(&'a [u8]),\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+#[derive(Clone)]\n+pub struct SocketAddr {\n+    addr: libc::sockaddr_un,\n+    len: libc::socklen_t,\n+}\n+\n+impl SocketAddr {\n+    pub(crate) fn new<F>(f: F) -> io::Result<SocketAddr>\n+        where F: FnOnce(*mut libc::sockaddr, *mut libc::socklen_t) -> libc::c_int\n+    {\n+        unsafe {\n+            let mut addr: libc::sockaddr_un = mem::zeroed();\n+            let mut len = mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;\n+            cvt(f(&mut addr as *mut _ as *mut _, &mut len))?;\n+            SocketAddr::from_parts(addr, len)\n+        }\n+    }\n+\n+    pub(crate) fn from_parts(addr: libc::sockaddr_un, mut len: libc::socklen_t) -> io::Result<SocketAddr> {\n+        if len == 0 {\n+            // When there is a datagram from unnamed unix socket\n+            // linux returns zero bytes of address\n+            len = sun_path_offset() as libc::socklen_t;  // i.e. zero-length address\n+        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                      \"file descriptor did not correspond to a Unix socket\"));\n+        }\n+\n+        Ok(SocketAddr {\n+            addr,\n+            len,\n+        })\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn is_unnamed(&self) -> bool {\n+        if let AddressKind::Unnamed = self.address() {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn as_pathname(&self) -> Option<&Path> {\n+        if let AddressKind::Pathname(path) = self.address() {\n+            Some(path)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn address<'a>(&'a self) -> AddressKind<'a> {\n+        let len = self.len as usize - sun_path_offset();\n+        let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n+\n+        // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses\n+        if len == 0\n+            || (cfg!(not(any(target_os = \"linux\", target_os = \"android\")))\n+                && self.addr.sun_path[0] == 0)\n+        {\n+            AddressKind::Unnamed\n+        } else if self.addr.sun_path[0] == 0 {\n+            AddressKind::Abstract(&path[1..len])\n+        } else {\n+            AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match self.address() {\n+            AddressKind::Unnamed => write!(fmt, \"(unnamed)\"),\n+            AddressKind::Abstract(name) => write!(fmt, \"{} (abstract)\", AsciiEscaped(name)),\n+            AddressKind::Pathname(path) => write!(fmt, \"{:?} (pathname)\", path),\n+        }\n+    }\n+}\n+\n+struct AsciiEscaped<'a>(&'a [u8]);\n+\n+impl<'a> fmt::Display for AsciiEscaped<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"\\\"\")?;\n+        for byte in self.0.iter().cloned().flat_map(ascii::escape_default) {\n+            write!(fmt, \"{}\", byte as char)?;\n+        }\n+        write!(fmt, \"\\\"\")\n+    }\n+}\n+\n+/// A Unix stream socket.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::os::unix::net::UnixStream;\n+/// use std::io::prelude::*;\n+///\n+/// let mut stream = UnixStream::connect(\"/path/to/my/socket\").unwrap();\n+/// stream.write_all(b\"hello world\").unwrap();\n+/// let mut response = String::new();\n+/// stream.read_to_string(&mut response).unwrap();\n+/// println!(\"{}\", response);\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixStream(Socket);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixStream {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixStream\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        if let Ok(addr) = self.peer_addr() {\n+            builder.field(\"peer\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixStream {\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn connect(path: &Path) -> io::Result<UnixStream> {\n+        unsafe {\n+            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+            let (addr, len) = sockaddr_un(path)?;\n+\n+            cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n+            Ok(UnixStream(inner))\n+        }\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n+        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+        Ok((UnixStream(i1), UnixStream(i2)))\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixStream> {\n+        self.0.duplicate().map(UnixStream)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_RCVTIMEO)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_SNDTIMEO)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        self.0.shutdown(how)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> io::Read for &'a UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        Initializer::nop()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> io::Write for &'a UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl AsRawFd for UnixStream {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl FromRawFd for UnixStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n+        UnixStream(Socket::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for UnixStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixListener(Socket);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixListener {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixListener\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixListener {\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn bind(path: &Path) -> io::Result<UnixListener> {\n+        unsafe {\n+            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+            let (addr, len) = sockaddr_un(path)?;\n+\n+            cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len as _))?;\n+            cvt(libc::listen(*inner.as_inner(), 128))?;\n+\n+            Ok(UnixListener(inner))\n+        }\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n+        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n+        let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n+        let sock = self.0.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n+        let addr = SocketAddr::from_parts(storage, len)?;\n+        Ok((UnixStream(sock), addr))\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixListener> {\n+        self.0.duplicate().map(UnixListener)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl AsRawFd for UnixListener {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl FromRawFd for UnixListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n+        UnixListener(Socket::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl IntoRawFd for UnixListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}"}, {"sha": "7fb273826cc4cc300be650b202c9e2177489318c", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=a4e190546c9aaa06630577adb7310a8674bbac06", "patch": "@@ -54,6 +54,7 @@ pub mod util;\n pub mod wtf8;\n pub mod bytestring;\n pub mod process;\n+pub mod unixsocket;\n \n cfg_if! {\n     if #[cfg(any(target_os = \"cloudabi\", target_os = \"l4re\", target_os = \"redox\"))] {"}, {"sha": "96037d6c5d9672376075564e3e2a314b5e647059", "filename": "src/libstd/sys_common/unixsocket.rs", "status": "added", "additions": 704, "deletions": 0, "changes": 704, "blob_url": "https://github.com/rust-lang/rust/blob/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys_common%2Funixsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e190546c9aaa06630577adb7310a8674bbac06/src%2Flibstd%2Fsys_common%2Funixsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Funixsocket.rs?ref=a4e190546c9aaa06630577adb7310a8674bbac06", "patch": "@@ -0,0 +1,704 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg(any(all(unix, not(target_os = \"emscripten\")), target_os = \"redox\"))]\n+#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+\n+//! Unix-specific networking functionality\n+\n+use fmt;\n+use io::{self, Initializer};\n+use net::Shutdown;\n+use os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n+use path::Path;\n+use time::Duration;\n+\n+use sys::ext::unixsocket as inner;\n+\n+/// An address associated with a Unix socket.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::os::unix::net::UnixListener;\n+///\n+/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n+///     Ok(sock) => sock,\n+///     Err(e) => {\n+///         println!(\"Couldn't bind: {:?}\", e);\n+///         return\n+///     }\n+/// };\n+/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+#[derive(Clone)]\n+pub struct SocketAddr(pub(crate) inner::SocketAddr);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}\", self.0)\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for UnixStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_raw_fd()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl AsRawFd for UnixStream {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.as_raw_fd()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl FromRawFd for UnixStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self {\n+        UnixStream(inner::UnixStream::from_raw_fd(fd))\n+    }\n+}\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl io::Read for UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        io::Read::read(&mut &self.0, buf)\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        io::Read::initializer(&&self.0)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> io::Read for &'a UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        io::Read::read(&mut &self.0, buf)\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        io::Read::initializer(&&self.0)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl io::Write for UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        io::Write::write(&mut &self.0, buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        io::Write::flush(&mut &self.0)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> io::Write for &'a UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        io::Write::write(&mut &self.0, buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        io::Write::flush(&mut &self.0)\n+    }\n+}\n+\n+impl SocketAddr {\n+    /// Returns the contents of this address if it is a `pathname` address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// With a pathname:\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    /// use std::path::Path;\n+    ///\n+    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n+    /// ```\n+    ///\n+    /// Without a pathname:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.as_pathname(), None);\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn as_pathname(&self) -> Option<&Path> {\n+        self.0.as_pathname()\n+    }\n+}\n+\n+/// A Unix stream socket.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::os::unix::net::UnixStream;\n+/// use std::io::prelude::*;\n+///\n+/// let mut stream = UnixStream::connect(\"/path/to/my/socket\").unwrap();\n+/// stream.write_all(b\"hello world\").unwrap();\n+/// let mut response = String::new();\n+/// stream.read_to_string(&mut response).unwrap();\n+/// println!(\"{}\", response);\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixStream(inner::UnixStream);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixStream {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}\", self.0)\n+    }\n+}\n+\n+impl UnixStream {\n+    /// Connects to the socket named by `path`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n+        inner::UnixStream::connect(path.as_ref()).map(UnixStream)\n+    }\n+\n+    /// Creates an unnamed pair of connected sockets.\n+    ///\n+    /// Returns two `UnixStream`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let (sock1, sock2) = match UnixStream::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n+        inner::UnixStream::pair().map(|(s1, s2)| (UnixStream(s1), UnixStream(s2)))\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixStream` is a reference to the same stream that this\n+    /// object references. Both handles will read and write the same stream of\n+    /// data, and options set on one stream will be propagated to the other\n+    /// stream.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixStream> {\n+        self.0.try_clone().map(UnixStream)\n+    }\n+\n+    /// Returns the socket address of the local half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.local_addr().map(SocketAddr)\n+    }\n+\n+    /// Returns the socket address of the remote half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.peer_addr().map(SocketAddr)\n+    }\n+\n+    /// Sets the read timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`read`] calls will block\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n+    /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_read_timeout(timeout)\n+    }\n+\n+    /// Sets the write timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`write`] calls will block\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n+    /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::UdpSocket;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n+    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_write_timeout(timeout)\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.read_timeout()\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n+    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.write_timeout()\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// if let Ok(Some(err)) = socket.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Platform specific\n+    /// On Redox this always returns None.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Shuts down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O calls on the\n+    /// specified portions to immediately return with an appropriate value\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        self.0.shutdown(how)\n+    }\n+}\n+\n+/// A structure representing a Unix domain socket server.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// pub fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+///\n+/// // accept connections and process them, spawning a new thread for each one\n+/// for stream in listener.incoming() {\n+///     match stream {\n+///         Ok(stream) => {\n+///             /* connection succeeded */\n+///             thread::spawn(|| handle_client(stream));\n+///         }\n+///         Err(err) => {\n+///             /* connection failed */\n+///             break;\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixListener(inner::UnixListener);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixListener {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}\", self.0)\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for UnixListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_raw_fd()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl AsRawFd for UnixListener {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.as_raw_fd()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl FromRawFd for UnixListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self {\n+        UnixListener(inner::UnixListener::from_raw_fd(fd))\n+    }\n+}\n+\n+impl UnixListener {\n+    /// Creates a new `UnixListener` bound to the specified socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n+        inner::UnixListener::bind(path.as_ref()).map(UnixListener)\n+    }\n+\n+    /// Accepts a new incoming connection to this listener.\n+    ///\n+    /// This function will block the calling thread until a new Unix connection\n+    /// is established. When established, the corresponding [`UnixStream`] and\n+    /// the remote peer's address will be returned.\n+    ///\n+    /// [`UnixStream`]: ../../../../std/os/unix/net/struct.UnixStream.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// match listener.accept() {\n+    ///     Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n+    ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n+        self.0.accept().map(|(s, a)| (UnixStream(s), SocketAddr(a)))\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixListener` is a reference to the same socket that this\n+    /// object references. Both handles can be used to accept incoming\n+    /// connections and options set on one listener will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixListener> {\n+        self.0.try_clone().map(UnixListener)\n+    }\n+\n+    /// Returns the local socket address of this listener.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.local_addr().map(SocketAddr)\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    ///\n+    /// if let Ok(Some(err)) = listener.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Platform specific\n+    /// On Redox this always returns None.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Returns an iterator over incoming connections.\n+    ///\n+    /// The iterator will never return [`None`] and will also not yield the\n+    /// peer's [`SocketAddr`] structure.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`SocketAddr`]: struct.SocketAddr.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::thread;\n+    /// use std::os::unix::net::{UnixStream, UnixListener};\n+    ///\n+    /// pub fn handle_client(stream: UnixStream) {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// for stream in listener.incoming() {\n+    ///     match stream {\n+    ///         Ok(stream) => {\n+    ///             thread::spawn(|| handle_client(stream));\n+    ///         }\n+    ///         Err(err) => {\n+    ///             break;\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n+        Incoming { listener: self }\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> IntoIterator for &'a UnixListener {\n+    type Item = io::Result<UnixStream>;\n+    type IntoIter = Incoming<'a>;\n+\n+    fn into_iter(self) -> Incoming<'a> {\n+        self.incoming()\n+    }\n+}\n+\n+/// An iterator over incoming connections to a [`UnixListener`].\n+///\n+/// It will never return [`None`].\n+///\n+/// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+/// [`UnixListener`]: struct.UnixListener.html\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// pub fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+///\n+/// for stream in listener.incoming() {\n+///     match stream {\n+///         Ok(stream) => {\n+///             thread::spawn(|| handle_client(stream));\n+///         }\n+///         Err(err) => {\n+///             break;\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+#[derive(Debug)]\n+pub struct Incoming<'a> {\n+    listener: &'a UnixListener,\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> Iterator for Incoming<'a> {\n+    type Item = io::Result<UnixStream>;\n+\n+    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n+        Some(self.listener.accept().map(|s| s.0))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::max_value(), None)\n+    }\n+}"}]}