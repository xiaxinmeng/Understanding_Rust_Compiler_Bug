{"sha": "75b616e92f6cad9c44bd4faf10e034439a5757f2", "node_id": "C_kwDOAAsO6NoAKDc1YjYxNmU5MmY2Y2FkOWM0NGJkNGZhZjEwZTAzNDQzOWE1NzU3ZjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-13T14:49:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-13T14:49:56Z"}, "message": "Auto merge of #8471 - J-ZhengLi:master-issue7040, r=llogiq\n\nnew lint that detects useless match expression\n\nfixes #7040\n\nchangelog: Add new  lint [`needless_match`] under complexity lint group", "tree": {"sha": "9f94aab8633a3751de64dfc5a270a122e7142d3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f94aab8633a3751de64dfc5a270a122e7142d3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75b616e92f6cad9c44bd4faf10e034439a5757f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75b616e92f6cad9c44bd4faf10e034439a5757f2", "html_url": "https://github.com/rust-lang/rust/commit/75b616e92f6cad9c44bd4faf10e034439a5757f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75b616e92f6cad9c44bd4faf10e034439a5757f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ae74da63b11ca298a30cc1af686019c7417938a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ae74da63b11ca298a30cc1af686019c7417938a", "html_url": "https://github.com/rust-lang/rust/commit/8ae74da63b11ca298a30cc1af686019c7417938a"}, {"sha": "086b045822b008c5b4e6eb34bac10bfa8d5a7ea1", "url": "https://api.github.com/repos/rust-lang/rust/commits/086b045822b008c5b4e6eb34bac10bfa8d5a7ea1", "html_url": "https://github.com/rust-lang/rust/commit/086b045822b008c5b4e6eb34bac10bfa8d5a7ea1"}], "stats": {"total": 577, "additions": 577, "deletions": 0}, "files": [{"sha": "94171cdd2d63d95f61414290a67c03c5cb18cd98", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75b616e92f6cad9c44bd4faf10e034439a5757f2/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/75b616e92f6cad9c44bd4faf10e034439a5757f2/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=75b616e92f6cad9c44bd4faf10e034439a5757f2", "patch": "@@ -3331,6 +3331,7 @@ Released 2018-09-13\n [`needless_for_each`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_for_each\n [`needless_late_init`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_late_init\n [`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n+[`needless_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_match\n [`needless_option_as_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_option_as_deref\n [`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n [`needless_question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark"}, {"sha": "6938fd365730d92a7acf29bde42d2fa97c45b045", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75b616e92f6cad9c44bd4faf10e034439a5757f2/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b616e92f6cad9c44bd4faf10e034439a5757f2/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=75b616e92f6cad9c44bd4faf10e034439a5757f2", "patch": "@@ -138,6 +138,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(matches::MATCH_OVERLAPPING_ARM),\n     LintId::of(matches::MATCH_REF_PATS),\n     LintId::of(matches::MATCH_SINGLE_BINDING),\n+    LintId::of(matches::NEEDLESS_MATCH),\n     LintId::of(matches::REDUNDANT_PATTERN_MATCHING),\n     LintId::of(matches::SINGLE_MATCH),\n     LintId::of(matches::WILDCARD_IN_OR_PATTERNS),"}, {"sha": "5bf8ca70381881007ad8a6cc0367918635447c2c", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75b616e92f6cad9c44bd4faf10e034439a5757f2/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b616e92f6cad9c44bd4faf10e034439a5757f2/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=75b616e92f6cad9c44bd4faf10e034439a5757f2", "patch": "@@ -30,6 +30,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_SINGLE_BINDING),\n+    LintId::of(matches::NEEDLESS_MATCH),\n     LintId::of(matches::WILDCARD_IN_OR_PATTERNS),\n     LintId::of(methods::BIND_INSTEAD_OF_MAP),\n     LintId::of(methods::CLONE_ON_COPY),"}, {"sha": "7d6f6a4857f41e867da5c31ac5910c273977951d", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75b616e92f6cad9c44bd4faf10e034439a5757f2/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b616e92f6cad9c44bd4faf10e034439a5757f2/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=75b616e92f6cad9c44bd4faf10e034439a5757f2", "patch": "@@ -260,6 +260,7 @@ store.register_lints(&[\n     matches::MATCH_SINGLE_BINDING,\n     matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n     matches::MATCH_WILD_ERR_ARM,\n+    matches::NEEDLESS_MATCH,\n     matches::REDUNDANT_PATTERN_MATCHING,\n     matches::REST_PAT_IN_FULLY_BOUND_STRUCTS,\n     matches::SINGLE_MATCH,"}, {"sha": "ff85623acf49b85eabdd4c4eb4e399e9537ceefa", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/75b616e92f6cad9c44bd4faf10e034439a5757f2/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b616e92f6cad9c44bd4faf10e034439a5757f2/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=75b616e92f6cad9c44bd4faf10e034439a5757f2", "patch": "@@ -16,6 +16,7 @@ mod match_same_arms;\n mod match_single_binding;\n mod match_wild_enum;\n mod match_wild_err_arm;\n+mod needless_match;\n mod overlapping_arms;\n mod redundant_pattern_match;\n mod rest_pat_in_fully_bound_struct;\n@@ -566,6 +567,49 @@ declare_clippy_lint! {\n     \"`match` with identical arm bodies\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for unnecessary `match` or match-like `if let` returns for `Option` and `Result`\n+    /// when function signatures are the same.\n+    ///\n+    /// ### Why is this bad?\n+    /// This `match` block does nothing and might not be what the coder intended.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// fn foo() -> Result<(), i32> {\n+    ///     match result {\n+    ///         Ok(val) => Ok(val),\n+    ///         Err(err) => Err(err),\n+    ///     }\n+    /// }\n+    ///\n+    /// fn bar() -> Option<i32> {\n+    ///     if let Some(val) = option {\n+    ///         Some(val)\n+    ///     } else {\n+    ///         None\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be replaced as\n+    ///\n+    /// ```rust,ignore\n+    /// fn foo() -> Result<(), i32> {\n+    ///     result\n+    /// }\n+    ///\n+    /// fn bar() -> Option<i32> {\n+    ///     option\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub NEEDLESS_MATCH,\n+    complexity,\n+    \"`match` or match-like `if let` that are unnecessary\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     msrv: Option<RustcVersion>,\n@@ -599,6 +643,7 @@ impl_lint_pass!(Matches => [\n     REDUNDANT_PATTERN_MATCHING,\n     MATCH_LIKE_MATCHES_MACRO,\n     MATCH_SAME_ARMS,\n+    NEEDLESS_MATCH,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n@@ -622,6 +667,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                     overlapping_arms::check(cx, ex, arms);\n                     match_wild_enum::check(cx, ex, arms);\n                     match_as_ref::check(cx, ex, arms, expr);\n+                    needless_match::check_match(cx, ex, arms);\n \n                     if self.infallible_destructuring_match_linted {\n                         self.infallible_destructuring_match_linted = false;\n@@ -640,6 +686,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 match_like_matches::check(cx, expr);\n             }\n             redundant_pattern_match::check(cx, expr);\n+            needless_match::check(cx, expr);\n         }\n     }\n "}, {"sha": "76131d307d777e10e262cba3971b4b890a6c8c49", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/75b616e92f6cad9c44bd4faf10e034439a5757f2/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b616e92f6cad9c44bd4faf10e034439a5757f2/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=75b616e92f6cad9c44bd4faf10e034439a5757f2", "patch": "@@ -0,0 +1,197 @@\n+use super::NEEDLESS_MATCH;\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{eq_expr_value, get_parent_expr, higher, is_else_clause, is_lang_ctor, peel_blocks_with_stmt};\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::OptionNone;\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, Pat, PatKind, Path, PathSegment, QPath, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n+    // This is for avoiding collision with `match_single_binding`.\n+    if arms.len() < 2 {\n+        return;\n+    }\n+\n+    for arm in arms {\n+        if let PatKind::Wild = arm.pat.kind {\n+            let ret_expr = strip_return(arm.body);\n+            if !eq_expr_value(cx, ex, ret_expr) {\n+                return;\n+            }\n+        } else if !pat_same_as_expr(arm.pat, arm.body) {\n+            return;\n+        }\n+    }\n+\n+    if let Some(match_expr) = get_parent_expr(cx, ex) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            NEEDLESS_MATCH,\n+            match_expr.span,\n+            \"this match expression is unnecessary\",\n+            \"replace it with\",\n+            snippet_with_applicability(cx, ex.span, \"..\", &mut applicability).to_string(),\n+            applicability,\n+        );\n+    }\n+}\n+\n+/// Check for nop `if let` expression that assembled as unnecessary match\n+///\n+/// ```rust,ignore\n+/// if let Some(a) = option {\n+///     Some(a)\n+/// } else {\n+///     None\n+/// }\n+/// ```\n+/// OR\n+/// ```rust,ignore\n+/// if let SomeEnum::A = some_enum {\n+///     SomeEnum::A\n+/// } else if let SomeEnum::B = some_enum {\n+///     SomeEnum::B\n+/// } else {\n+///     some_enum\n+/// }\n+/// ```\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n+    if_chain! {\n+        if let Some(ref if_let) = higher::IfLet::hir(cx, ex);\n+        if !is_else_clause(cx.tcx, ex);\n+        if check_if_let(cx, if_let);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                NEEDLESS_MATCH,\n+                ex.span,\n+                \"this if-let expression is unnecessary\",\n+                \"replace it with\",\n+                snippet_with_applicability(cx, if_let.let_expr.span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n+    if let Some(if_else) = if_let.if_else {\n+        if !pat_same_as_expr(if_let.let_pat, peel_blocks_with_stmt(if_let.if_then)) {\n+            return false;\n+        }\n+\n+        // Recurrsively check for each `else if let` phrase,\n+        if let Some(ref nested_if_let) = higher::IfLet::hir(cx, if_else) {\n+            return check_if_let(cx, nested_if_let);\n+        }\n+\n+        if matches!(if_else.kind, ExprKind::Block(..)) {\n+            let else_expr = peel_blocks_with_stmt(if_else);\n+            let ret = strip_return(else_expr);\n+            let let_expr_ty = cx.typeck_results().expr_ty(if_let.let_expr);\n+            if is_type_diagnostic_item(cx, let_expr_ty, sym::Option) {\n+                if let ExprKind::Path(ref qpath) = ret.kind {\n+                    return is_lang_ctor(cx, qpath, OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n+                }\n+            } else {\n+                return eq_expr_value(cx, if_let.let_expr, ret);\n+            }\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+/// Strip `return` keyword if the expression type is `ExprKind::Ret`.\n+fn strip_return<'hir>(expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n+    if let ExprKind::Ret(Some(ret)) = expr.kind {\n+        ret\n+    } else {\n+        expr\n+    }\n+}\n+\n+fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n+    let expr = strip_return(expr);\n+    match (&pat.kind, &expr.kind) {\n+        // Example: `Some(val) => Some(val)`\n+        (\n+            PatKind::TupleStruct(QPath::Resolved(_, path), [first_pat, ..], _),\n+            ExprKind::Call(call_expr, [first_param, ..]),\n+        ) => {\n+            if let ExprKind::Path(QPath::Resolved(_, call_path)) = call_expr.kind {\n+                if has_identical_segments(path.segments, call_path.segments)\n+                    && has_same_non_ref_symbol(first_pat, first_param)\n+                {\n+                    return true;\n+                }\n+            }\n+        },\n+        // Example: `val => val`, or `ref val => *val`\n+        (PatKind::Binding(annot, _, pat_ident, _), _) => {\n+            let new_expr = if let (\n+                BindingAnnotation::Ref | BindingAnnotation::RefMut,\n+                ExprKind::Unary(UnOp::Deref, operand_expr),\n+            ) = (annot, &expr.kind)\n+            {\n+                operand_expr\n+            } else {\n+                expr\n+            };\n+\n+            if let ExprKind::Path(QPath::Resolved(\n+                _,\n+                Path {\n+                    segments: [first_seg, ..],\n+                    ..\n+                },\n+            )) = new_expr.kind\n+            {\n+                return pat_ident.name == first_seg.ident.name;\n+            }\n+        },\n+        // Example: `Custom::TypeA => Custom::TypeB`, or `None => None`\n+        (PatKind::Path(QPath::Resolved(_, p_path)), ExprKind::Path(QPath::Resolved(_, e_path))) => {\n+            return has_identical_segments(p_path.segments, e_path.segments);\n+        },\n+        // Example: `5 => 5`\n+        (PatKind::Lit(pat_lit_expr), ExprKind::Lit(expr_spanned)) => {\n+            if let ExprKind::Lit(pat_spanned) = &pat_lit_expr.kind {\n+                return pat_spanned.node == expr_spanned.node;\n+            }\n+        },\n+        _ => {},\n+    }\n+\n+    false\n+}\n+\n+fn has_identical_segments(left_segs: &[PathSegment<'_>], right_segs: &[PathSegment<'_>]) -> bool {\n+    if left_segs.len() != right_segs.len() {\n+        return false;\n+    }\n+    for i in 0..left_segs.len() {\n+        if left_segs[i].ident.name != right_segs[i].ident.name {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn has_same_non_ref_symbol(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n+    if_chain! {\n+        if let PatKind::Binding(annot, _, pat_ident, _) = pat.kind;\n+        if !matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n+        if let ExprKind::Path(QPath::Resolved(_, Path {segments: [first_seg, ..], .. })) = expr.kind;\n+        then {\n+            return pat_ident.name == first_seg.ident.name;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "fc6a7abca0ebda5ea92eabdbdf406efbd0e8d59e", "filename": "tests/ui/manual_map_option.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75b616e92f6cad9c44bd4faf10e034439a5757f2/tests%2Fui%2Fmanual_map_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/75b616e92f6cad9c44bd4faf10e034439a5757f2/tests%2Fui%2Fmanual_map_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.fixed?ref=75b616e92f6cad9c44bd4faf10e034439a5757f2", "patch": "@@ -148,6 +148,7 @@ fn main() {\n \n     // #7077\n     let s = &String::new();\n+    #[allow(clippy::needless_match)]\n     let _: Option<&str> = match Some(s) {\n         Some(s) => Some(s),\n         None => None,"}, {"sha": "16508270f64d9f015fc39d89c4e8f05ea99b0ae7", "filename": "tests/ui/manual_map_option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75b616e92f6cad9c44bd4faf10e034439a5757f2/tests%2Fui%2Fmanual_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b616e92f6cad9c44bd4faf10e034439a5757f2/tests%2Fui%2Fmanual_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.rs?ref=75b616e92f6cad9c44bd4faf10e034439a5757f2", "patch": "@@ -214,6 +214,7 @@ fn main() {\n \n     // #7077\n     let s = &String::new();\n+    #[allow(clippy::needless_match)]\n     let _: Option<&str> = match Some(s) {\n         Some(s) => Some(s),\n         None => None,"}, {"sha": "ece18ad737fdad5264a22085a2dcfb94003a83b8", "filename": "tests/ui/needless_match.fixed", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/75b616e92f6cad9c44bd4faf10e034439a5757f2/tests%2Fui%2Fneedless_match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/75b616e92f6cad9c44bd4faf10e034439a5757f2/tests%2Fui%2Fneedless_match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.fixed?ref=75b616e92f6cad9c44bd4faf10e034439a5757f2", "patch": "@@ -0,0 +1,83 @@\n+// run-rustfix\n+#![warn(clippy::needless_match)]\n+#![allow(clippy::manual_map)]\n+#![allow(dead_code)]\n+\n+#[derive(Clone, Copy)]\n+enum Choice {\n+    A,\n+    B,\n+    C,\n+    D,\n+}\n+\n+#[allow(unused_mut)]\n+fn useless_match() {\n+    let mut i = 10;\n+    let _: i32 = i;\n+    let _: i32 = i;\n+    let mut _i_mut = i;\n+\n+    let s = \"test\";\n+    let _: &str = s;\n+}\n+\n+fn custom_type_match(se: Choice) {\n+    let _: Choice = se;\n+    // Don't trigger\n+    let _: Choice = match se {\n+        Choice::A => Choice::A,\n+        Choice::B => Choice::B,\n+        _ => Choice::C,\n+    };\n+    // Mingled, don't trigger\n+    let _: Choice = match se {\n+        Choice::A => Choice::B,\n+        Choice::B => Choice::C,\n+        Choice::C => Choice::D,\n+        Choice::D => Choice::A,\n+    };\n+}\n+\n+fn option_match(x: Option<i32>) {\n+    let _: Option<i32> = x;\n+    // Don't trigger, this is the case for manual_map_option\n+    let _: Option<i32> = match x {\n+        Some(a) => Some(-a),\n+        None => None,\n+    };\n+}\n+\n+fn func_ret_err<T>(err: T) -> Result<i32, T> {\n+    Err(err)\n+}\n+\n+fn result_match() {\n+    let _: Result<i32, i32> = Ok(1);\n+    let _: Result<i32, i32> = func_ret_err(0_i32);\n+}\n+\n+fn if_let_option() -> Option<i32> {\n+    Some(1)\n+}\n+\n+fn if_let_result(x: Result<(), i32>) {\n+    let _: Result<(), i32> = x;\n+    let _: Result<(), i32> = x;\n+    // Input type mismatch, don't trigger\n+    let _: Result<(), i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n+}\n+\n+fn if_let_custom_enum(x: Choice) {\n+    let _: Choice = x;\n+    // Don't trigger\n+    let _: Choice = if let Choice::A = x {\n+        Choice::A\n+    } else if true {\n+        Choice::B\n+    } else {\n+        x\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "36649de35a6030f91a1716c9d23844689981fccf", "filename": "tests/ui/needless_match.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/75b616e92f6cad9c44bd4faf10e034439a5757f2/tests%2Fui%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75b616e92f6cad9c44bd4faf10e034439a5757f2/tests%2Fui%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.rs?ref=75b616e92f6cad9c44bd4faf10e034439a5757f2", "patch": "@@ -0,0 +1,122 @@\n+// run-rustfix\n+#![warn(clippy::needless_match)]\n+#![allow(clippy::manual_map)]\n+#![allow(dead_code)]\n+\n+#[derive(Clone, Copy)]\n+enum Choice {\n+    A,\n+    B,\n+    C,\n+    D,\n+}\n+\n+#[allow(unused_mut)]\n+fn useless_match() {\n+    let mut i = 10;\n+    let _: i32 = match i {\n+        0 => 0,\n+        1 => 1,\n+        2 => 2,\n+        _ => i,\n+    };\n+    let _: i32 = match i {\n+        0 => 0,\n+        1 => 1,\n+        ref i => *i,\n+    };\n+    let mut _i_mut = match i {\n+        0 => 0,\n+        1 => 1,\n+        ref mut i => *i,\n+    };\n+\n+    let s = \"test\";\n+    let _: &str = match s {\n+        \"a\" => \"a\",\n+        \"b\" => \"b\",\n+        s => s,\n+    };\n+}\n+\n+fn custom_type_match(se: Choice) {\n+    let _: Choice = match se {\n+        Choice::A => Choice::A,\n+        Choice::B => Choice::B,\n+        Choice::C => Choice::C,\n+        Choice::D => Choice::D,\n+    };\n+    // Don't trigger\n+    let _: Choice = match se {\n+        Choice::A => Choice::A,\n+        Choice::B => Choice::B,\n+        _ => Choice::C,\n+    };\n+    // Mingled, don't trigger\n+    let _: Choice = match se {\n+        Choice::A => Choice::B,\n+        Choice::B => Choice::C,\n+        Choice::C => Choice::D,\n+        Choice::D => Choice::A,\n+    };\n+}\n+\n+fn option_match(x: Option<i32>) {\n+    let _: Option<i32> = match x {\n+        Some(a) => Some(a),\n+        None => None,\n+    };\n+    // Don't trigger, this is the case for manual_map_option\n+    let _: Option<i32> = match x {\n+        Some(a) => Some(-a),\n+        None => None,\n+    };\n+}\n+\n+fn func_ret_err<T>(err: T) -> Result<i32, T> {\n+    Err(err)\n+}\n+\n+fn result_match() {\n+    let _: Result<i32, i32> = match Ok(1) {\n+        Ok(a) => Ok(a),\n+        Err(err) => Err(err),\n+    };\n+    let _: Result<i32, i32> = match func_ret_err(0_i32) {\n+        Err(err) => Err(err),\n+        Ok(a) => Ok(a),\n+    };\n+}\n+\n+fn if_let_option() -> Option<i32> {\n+    if let Some(a) = Some(1) { Some(a) } else { None }\n+}\n+\n+fn if_let_result(x: Result<(), i32>) {\n+    let _: Result<(), i32> = if let Err(e) = x { Err(e) } else { x };\n+    let _: Result<(), i32> = if let Ok(val) = x { Ok(val) } else { x };\n+    // Input type mismatch, don't trigger\n+    let _: Result<(), i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n+}\n+\n+fn if_let_custom_enum(x: Choice) {\n+    let _: Choice = if let Choice::A = x {\n+        Choice::A\n+    } else if let Choice::B = x {\n+        Choice::B\n+    } else if let Choice::C = x {\n+        Choice::C\n+    } else {\n+        x\n+    };\n+    // Don't trigger\n+    let _: Choice = if let Choice::A = x {\n+        Choice::A\n+    } else if true {\n+        Choice::B\n+    } else {\n+        x\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "ad1525406ade7abd6029b8f85278520b478c768e", "filename": "tests/ui/needless_match.stderr", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/75b616e92f6cad9c44bd4faf10e034439a5757f2/tests%2Fui%2Fneedless_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75b616e92f6cad9c44bd4faf10e034439a5757f2/tests%2Fui%2Fneedless_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.stderr?ref=75b616e92f6cad9c44bd4faf10e034439a5757f2", "patch": "@@ -0,0 +1,122 @@\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:17:18\n+   |\n+LL |       let _: i32 = match i {\n+   |  __________________^\n+LL | |         0 => 0,\n+LL | |         1 => 1,\n+LL | |         2 => 2,\n+LL | |         _ => i,\n+LL | |     };\n+   | |_____^ help: replace it with: `i`\n+   |\n+   = note: `-D clippy::needless-match` implied by `-D warnings`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:23:18\n+   |\n+LL |       let _: i32 = match i {\n+   |  __________________^\n+LL | |         0 => 0,\n+LL | |         1 => 1,\n+LL | |         ref i => *i,\n+LL | |     };\n+   | |_____^ help: replace it with: `i`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:28:22\n+   |\n+LL |       let mut _i_mut = match i {\n+   |  ______________________^\n+LL | |         0 => 0,\n+LL | |         1 => 1,\n+LL | |         ref mut i => *i,\n+LL | |     };\n+   | |_____^ help: replace it with: `i`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:35:19\n+   |\n+LL |       let _: &str = match s {\n+   |  ___________________^\n+LL | |         \"a\" => \"a\",\n+LL | |         \"b\" => \"b\",\n+LL | |         s => s,\n+LL | |     };\n+   | |_____^ help: replace it with: `s`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:43:21\n+   |\n+LL |       let _: Choice = match se {\n+   |  _____________________^\n+LL | |         Choice::A => Choice::A,\n+LL | |         Choice::B => Choice::B,\n+LL | |         Choice::C => Choice::C,\n+LL | |         Choice::D => Choice::D,\n+LL | |     };\n+   | |_____^ help: replace it with: `se`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:65:26\n+   |\n+LL |       let _: Option<i32> = match x {\n+   |  __________________________^\n+LL | |         Some(a) => Some(a),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: replace it with: `x`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:81:31\n+   |\n+LL |       let _: Result<i32, i32> = match Ok(1) {\n+   |  _______________________________^\n+LL | |         Ok(a) => Ok(a),\n+LL | |         Err(err) => Err(err),\n+LL | |     };\n+   | |_____^ help: replace it with: `Ok(1)`\n+\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:85:31\n+   |\n+LL |       let _: Result<i32, i32> = match func_ret_err(0_i32) {\n+   |  _______________________________^\n+LL | |         Err(err) => Err(err),\n+LL | |         Ok(a) => Ok(a),\n+LL | |     };\n+   | |_____^ help: replace it with: `func_ret_err(0_i32)`\n+\n+error: this if-let expression is unnecessary\n+  --> $DIR/needless_match.rs:92:5\n+   |\n+LL |     if let Some(a) = Some(1) { Some(a) } else { None }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `Some(1)`\n+\n+error: this if-let expression is unnecessary\n+  --> $DIR/needless_match.rs:96:30\n+   |\n+LL |     let _: Result<(), i32> = if let Err(e) = x { Err(e) } else { x };\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n+\n+error: this if-let expression is unnecessary\n+  --> $DIR/needless_match.rs:97:30\n+   |\n+LL |     let _: Result<(), i32> = if let Ok(val) = x { Ok(val) } else { x };\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n+\n+error: this if-let expression is unnecessary\n+  --> $DIR/needless_match.rs:103:21\n+   |\n+LL |       let _: Choice = if let Choice::A = x {\n+   |  _____________________^\n+LL | |         Choice::A\n+LL | |     } else if let Choice::B = x {\n+LL | |         Choice::B\n+...  |\n+LL | |         x\n+LL | |     };\n+   | |_____^ help: replace it with: `x`\n+\n+error: aborting due to 12 previous errors\n+"}]}