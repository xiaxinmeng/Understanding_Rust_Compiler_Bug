{"sha": "a02da4ecdef0bc810357db3566f97e9cc1f24c46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMmRhNGVjZGVmMGJjODEwMzU3ZGIzNTY2Zjk3ZTljYzFmMjRjNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-21T05:22:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-21T05:22:30Z"}, "message": "auto merge of #5063 : pcwalton/rust/plussing, r=pcwalton", "tree": {"sha": "e61b61fe772d4454a0901fbe48a4828933e5a0eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e61b61fe772d4454a0901fbe48a4828933e5a0eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a02da4ecdef0bc810357db3566f97e9cc1f24c46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a02da4ecdef0bc810357db3566f97e9cc1f24c46", "html_url": "https://github.com/rust-lang/rust/commit/a02da4ecdef0bc810357db3566f97e9cc1f24c46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a02da4ecdef0bc810357db3566f97e9cc1f24c46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0aa1aaa2c1d095365e341017e443d61a960e0af6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aa1aaa2c1d095365e341017e443d61a960e0af6", "html_url": "https://github.com/rust-lang/rust/commit/0aa1aaa2c1d095365e341017e443d61a960e0af6"}, {"sha": "bf2a225c0b6f90f61bcaf4a6f33d9eaf424795b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf2a225c0b6f90f61bcaf4a6f33d9eaf424795b6", "html_url": "https://github.com/rust-lang/rust/commit/bf2a225c0b6f90f61bcaf4a6f33d9eaf424795b6"}], "stats": {"total": 1455, "additions": 729, "deletions": 726}, "files": [{"sha": "57bd8a97b5db98de1b08e4a10c43841697ed1faa", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -96,7 +96,7 @@ pub pure fn build_sized_opt<A>(size: Option<uint>,\n \n // Appending\n #[inline(always)]\n-pub pure fn append<T: Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n+pub pure fn append<T:Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n         for vec::each(lhs) |x| { push(*x); }\n         for uint::range(0, rhs.len()) |i| { push(rhs[i]); }\n@@ -132,7 +132,7 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pub pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n+pub pure fn from_elem<T:Copy>(n_elts: uint, t: T) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(copy t); i += 1u; }\n@@ -168,7 +168,7 @@ pub mod traits {\n     use kinds::Copy;\n     use ops::Add;\n \n-    pub impl<T: Copy> Add<&[const T],@[T]> for @[T] {\n+    pub impl<T:Copy> Add<&[const T],@[T]> for @[T] {\n         #[inline(always)]\n         pure fn add(&self, rhs: & &self/[const T]) -> @[T] {\n             append(*self, (*rhs))"}, {"sha": "fd99235bd270c6150f42d3041b91927fd2dc5dad", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -56,41 +56,41 @@ pub trait Ord {\n }\n \n #[inline(always)]\n-pub pure fn lt<T: Ord>(v1: &T, v2: &T) -> bool {\n+pub pure fn lt<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).lt(v2)\n }\n \n #[inline(always)]\n-pub pure fn le<T: Ord>(v1: &T, v2: &T) -> bool {\n+pub pure fn le<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).le(v2)\n }\n \n #[inline(always)]\n-pub pure fn eq<T: Eq>(v1: &T, v2: &T) -> bool {\n+pub pure fn eq<T:Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).eq(v2)\n }\n \n #[inline(always)]\n-pub pure fn ne<T: Eq>(v1: &T, v2: &T) -> bool {\n+pub pure fn ne<T:Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).ne(v2)\n }\n \n #[inline(always)]\n-pub pure fn ge<T: Ord>(v1: &T, v2: &T) -> bool {\n+pub pure fn ge<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).ge(v2)\n }\n \n #[inline(always)]\n-pub pure fn gt<T: Ord>(v1: &T, v2: &T) -> bool {\n+pub pure fn gt<T:Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).gt(v2)\n }\n \n #[inline(always)]\n-pub pure fn min<T: Ord>(v1: T, v2: T) -> T {\n+pub pure fn min<T:Ord>(v1: T, v2: T) -> T {\n     if v1 < v2 { v1 } else { v2 }\n }\n \n #[inline(always)]\n-pub pure fn max<T: Ord>(v1: T, v2: T) -> T {\n+pub pure fn max<T:Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }"}, {"sha": "3580736488926fc2d095eb0cafce3b5b1a671d83", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -106,7 +106,7 @@ pub pure fn from_elem<T>(data: T) -> @mut DList<T> {\n     list\n }\n \n-pub fn from_vec<T: Copy>(vec: &[T]) -> @mut DList<T> {\n+pub fn from_vec<T:Copy>(vec: &[T]) -> @mut DList<T> {\n     do vec::foldl(DList(), vec) |list,data| {\n         list.push(*data); // Iterating left-to-right -- add newly to the tail.\n         list\n@@ -457,7 +457,7 @@ impl<T> DList<T> {\n     }\n }\n \n-impl<T: Copy> DList<T> {\n+impl<T:Copy> DList<T> {\n     /// Remove data from the head of the list. O(1).\n     fn pop(@mut self) -> Option<T> {\n         self.pop_n().map(|nobe| nobe.data)"}, {"sha": "7651b737bf34ea62d9319e140bd6d384bbaf025a", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -227,7 +227,7 @@ impl<A> DVec<A> {\n     }\n }\n \n-impl<A: Copy> DVec<A> {\n+impl<A:Copy> DVec<A> {\n     /**\n      * Append all elements of a vector to the end of the list\n      *"}, {"sha": "93b28233acdd8ac818a922d42e5ac04de0736259", "filename": "src/libcore/either.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -41,7 +41,7 @@ pub fn either<T, U, V>(f_left: fn(&T) -> V,\n     }\n }\n \n-pub fn lefts<T: Copy, U>(eithers: &[Either<T, U>]) -> ~[T] {\n+pub fn lefts<T:Copy,U>(eithers: &[Either<T, U>]) -> ~[T] {\n     //! Extracts from a vector of either all the left values\n \n     do vec::build_sized(eithers.len()) |push| {"}, {"sha": "7c1448c88eef7b148ae1d732931e302021cb7555", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -59,7 +59,7 @@ pub trait HashUtil {\n     pure fn hash() -> u64;\n }\n \n-impl<A: Hash> HashUtil for A {\n+impl<A:Hash> HashUtil for A {\n     #[inline(always)]\n     pure fn hash() -> u64 { self.hash_keyed(0,0) }\n }\n@@ -74,7 +74,7 @@ pub trait Streaming {\n     fn reset();\n }\n \n-impl<A: IterBytes> Hash for A {\n+impl<A:IterBytes> Hash for A {\n     #[inline(always)]\n     pure fn hash_keyed(k0: u64, k1: u64) -> u64 {\n         unsafe {"}, {"sha": "07c7780898f96436fadd16a3358605f5319c8a33", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -56,14 +56,14 @@ pub mod linear {\n         ((capacity as float) * 3. / 4.) as uint\n     }\n \n-    pub fn linear_map_with_capacity<K: Eq Hash, V>(\n+    pub fn linear_map_with_capacity<K:Eq + Hash,V>(\n         initial_capacity: uint) -> LinearMap<K, V> {\n         let r = rand::task_rng();\n         linear_map_with_capacity_and_keys(r.gen_u64(), r.gen_u64(),\n                                           initial_capacity)\n     }\n \n-    pure fn linear_map_with_capacity_and_keys<K: Eq Hash, V>(\n+    pure fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n         k0: u64, k1: u64,\n         initial_capacity: uint) -> LinearMap<K, V> {\n         LinearMap {\n@@ -74,7 +74,7 @@ pub mod linear {\n         }\n     }\n \n-    priv impl<K: Hash IterBytes Eq, V> LinearMap<K, V> {\n+    priv impl<K:Hash + IterBytes + Eq,V> LinearMap<K, V> {\n         #[inline(always)]\n         pure fn to_bucket(&self, h: uint) -> uint {\n             // A good hash function with entropy spread over all of the\n@@ -246,7 +246,7 @@ pub mod linear {\n         }\n     }\n \n-    impl<K: Hash IterBytes Eq, V> BaseIter<(&K, &V)> for LinearMap<K, V> {\n+    impl<K:Hash + IterBytes + Eq,V> BaseIter<(&K, &V)> for LinearMap<K, V> {\n         /// Visit all key-value pairs\n         pure fn each(&self, blk: fn(&(&self/K, &self/V)) -> bool) {\n             for uint::range(0, self.buckets.len()) |i| {\n@@ -263,15 +263,15 @@ pub mod linear {\n     }\n \n \n-    impl<K: Hash IterBytes Eq, V> Container for LinearMap<K, V> {\n+    impl<K:Hash + IterBytes + Eq,V> Container for LinearMap<K, V> {\n         /// Return the number of elements in the map\n         pure fn len(&self) -> uint { self.size }\n \n         /// Return true if the map contains no elements\n         pure fn is_empty(&self) -> bool { self.len() == 0 }\n     }\n \n-    impl<K: Hash IterBytes Eq, V> Mutable for LinearMap<K, V> {\n+    impl<K:Hash + IterBytes + Eq,V> Mutable for LinearMap<K, V> {\n         /// Clear the map, removing all key-value pairs.\n         fn clear(&mut self) {\n             for uint::range(0, self.buckets.len()) |idx| {\n@@ -281,7 +281,7 @@ pub mod linear {\n         }\n     }\n \n-    impl<K: Hash IterBytes Eq, V> Map<K, V> for LinearMap<K, V> {\n+    impl<K:Hash + IterBytes + Eq,V> Map<K, V> for LinearMap<K, V> {\n         /// Return true if the map contains a value for the specified key\n         pure fn contains_key(&self, k: &K) -> bool {\n             match self.bucket_for_key(k) {\n@@ -333,7 +333,7 @@ pub mod linear {\n         }\n     }\n \n-    pub impl<K:Hash IterBytes Eq, V> LinearMap<K, V> {\n+    pub impl<K:Hash + IterBytes + Eq,V> LinearMap<K, V> {\n         /// Create an empty LinearMap\n         static fn new() -> LinearMap<K, V> {\n             linear_map_with_capacity(INITIAL_CAPACITY)\n@@ -457,7 +457,7 @@ pub mod linear {\n         }\n     }\n \n-    impl<K: Hash IterBytes Eq, V: Eq> Eq for LinearMap<K, V> {\n+    impl<K:Hash + IterBytes + Eq,V:Eq> Eq for LinearMap<K, V> {\n         pure fn eq(&self, other: &LinearMap<K, V>) -> bool {\n             if self.len() != other.len() { return false; }\n \n@@ -478,13 +478,13 @@ pub mod linear {\n         priv map: LinearMap<T, ()>\n     }\n \n-    impl<T: Hash IterBytes Eq> BaseIter<T> for LinearSet<T> {\n+    impl<T:Hash + IterBytes + Eq> BaseIter<T> for LinearSet<T> {\n         /// Visit all values in order\n         pure fn each(&self, f: fn(&T) -> bool) { self.map.each_key(f) }\n         pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n     }\n \n-    impl<T: Hash IterBytes Eq> Eq for LinearSet<T> {\n+    impl<T:Hash + IterBytes + Eq> Eq for LinearSet<T> {\n         pure fn eq(&self, other: &LinearSet<T>) -> bool {\n             self.map == other.map\n         }\n@@ -493,20 +493,20 @@ pub mod linear {\n         }\n     }\n \n-    impl<T: Hash IterBytes Eq> Container for LinearSet<T> {\n+    impl<T:Hash + IterBytes + Eq> Container for LinearSet<T> {\n         /// Return the number of elements in the set\n         pure fn len(&self) -> uint { self.map.len() }\n \n         /// Return true if the set contains no elements\n         pure fn is_empty(&self) -> bool { self.map.is_empty() }\n     }\n \n-    impl<T: Hash IterBytes Eq> Mutable for LinearSet<T> {\n+    impl<T:Hash + IterBytes + Eq> Mutable for LinearSet<T> {\n         /// Clear the set, removing all values.\n         fn clear(&mut self) { self.map.clear() }\n     }\n \n-    impl<T: Hash IterBytes Eq> Set<T> for LinearSet<T> {\n+    impl<T:Hash + IterBytes + Eq> Set<T> for LinearSet<T> {\n         /// Return true if the set contains a value\n         pure fn contains(&self, value: &T) -> bool {\n             self.map.contains_key(value)\n@@ -575,7 +575,7 @@ pub mod linear {\n         }\n     }\n \n-    pub impl <T: Hash IterBytes Eq> LinearSet<T> {\n+    pub impl <T:Hash + IterBytes + Eq> LinearSet<T> {\n         /// Create an empty LinearSet\n         static fn new() -> LinearSet<T> { LinearSet{map: LinearMap::new()} }\n "}, {"sha": "421eb94a29128e0ee631426987baa04e37224d9c", "filename": "src/libcore/io.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -169,7 +169,7 @@ pub trait ReaderUtil {\n     fn read_i8(&self) -> i8;\n }\n \n-impl<T: Reader> ReaderUtil for T {\n+impl<T:Reader> ReaderUtil for T {\n \n     fn read_bytes(&self,len: uint) -> ~[u8] {\n         let mut bytes = vec::with_capacity(len);\n@@ -193,7 +193,7 @@ impl<T: Reader> ReaderUtil for T {\n \n     fn read_chars(&self, n: uint) -> ~[char] {\n         // returns the (consumed offset, n_req), appends characters to &chars\n-        fn chars_from_bytes<T: Reader>(bytes: &~[u8], chars: &mut ~[char])\n+        fn chars_from_bytes<T:Reader>(bytes: &~[u8], chars: &mut ~[char])\n             -> (uint, uint) {\n             let mut i = 0;\n             let bytes_len = bytes.len();\n@@ -460,7 +460,7 @@ struct Wrapper<T, C> {\n // A forwarding impl of reader that also holds on to a resource for the\n // duration of its lifetime.\n // FIXME there really should be a better way to do this // #2004\n-impl<R: Reader, C> Reader for Wrapper<R, C> {\n+impl<R:Reader,C> Reader for Wrapper<R, C> {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         self.base.read(bytes, len)\n     }\n@@ -589,7 +589,7 @@ pub trait Writer {\n     fn get_type(&self) -> WriterType;\n }\n \n-impl<W: Writer, C> Writer for Wrapper<W, C> {\n+impl<W:Writer,C> Writer for Wrapper<W, C> {\n     fn write(&self, bs: &[const u8]) { self.base.write(bs); }\n     fn seek(&self, off: int, style: SeekStyle) { self.base.seek(off, style); }\n     fn tell(&self) -> uint { self.base.tell() }\n@@ -890,7 +890,7 @@ pub trait WriterUtil {\n     fn write_i8(&self, n: i8);\n }\n \n-impl<T: Writer> WriterUtil for T {\n+impl<T:Writer> WriterUtil for T {\n     fn write_char(&self, ch: char) {\n         if ch as uint < 128u {\n             self.write(&[ch as u8]);\n@@ -1112,7 +1112,7 @@ pub mod fsync {\n         arg: Arg<t>,\n     }\n \n-    impl<T: Copy> Drop for Res<T> {\n+    impl<T:Copy> Drop for Res<T> {\n         fn finalize(&self) {\n           match self.arg.opt_level {\n             None => (),"}, {"sha": "7c4a99133bbdbff0fcc34e1884367e850ddab17a", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -60,14 +60,14 @@ impl<A> iter::ExtendedIter<A> for IMPL_T<A> {\n \n }\n \n-impl<A: Eq> iter::EqIter<A> for IMPL_T<A> {\n+impl<A:Eq> iter::EqIter<A> for IMPL_T<A> {\n     #[inline(always)]\n     pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n     #[inline(always)]\n     pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n-impl<A: Copy> iter::CopyableIter<A> for IMPL_T<A> {\n+impl<A:Copy> iter::CopyableIter<A> for IMPL_T<A> {\n     #[inline(always)]\n     pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n@@ -80,7 +80,7 @@ impl<A: Copy> iter::CopyableIter<A> for IMPL_T<A> {\n     }\n }\n \n-impl<A: Copy Ord> iter::CopyableOrderedIter<A> for IMPL_T<A> {\n+impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for IMPL_T<A> {\n     #[inline(always)]\n     pure fn min(&self) -> A { iter::min(self) }\n     #[inline(always)]"}, {"sha": "e48edc9c1735bf369e985c0f9ff1ac6d606b71b7", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -57,7 +57,7 @@ pub trait CopyableIter<A:Copy> {\n     pure fn find(&self, p: fn(&A) -> bool) -> Option<A>;\n }\n \n-pub trait CopyableOrderedIter<A:Copy Ord> {\n+pub trait CopyableOrderedIter<A:Copy + Ord> {\n     pure fn min(&self) -> A;\n     pure fn max(&self) -> A;\n }\n@@ -211,7 +211,7 @@ pub pure fn repeat(times: uint, blk: fn() -> bool) {\n }\n \n #[inline(always)]\n-pub pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n+pub pure fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ < *b => {\n@@ -226,7 +226,7 @@ pub pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n }\n \n #[inline(always)]\n-pub pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n+pub pure fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ > *b => {\n@@ -241,7 +241,7 @@ pub pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n }\n \n #[inline(always)]\n-pub pure fn find<A: Copy,IA:BaseIter<A>>(self: &IA,\n+pub pure fn find<A:Copy,IA:BaseIter<A>>(self: &IA,\n                                    f: fn(&A) -> bool) -> Option<A> {\n     for self.each |i| {\n         if f(i) { return Some(*i) }\n@@ -323,7 +323,7 @@ pub pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint,\n  * to the value `t`.\n  */\n #[inline(always)]\n-pub pure fn from_elem<T: Copy,BT: Buildable<T>>(n_elts: uint,\n+pub pure fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint,\n                                                 t: T) -> BT {\n     do Buildable::build_sized(n_elts) |push| {\n         let mut i: uint = 0;\n@@ -333,7 +333,7 @@ pub pure fn from_elem<T: Copy,BT: Buildable<T>>(n_elts: uint,\n \n /// Appending two generic sequences\n #[inline(always)]\n-pub pure fn append<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n+pub pure fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(\n     lhs: &IT, rhs: &IT) -> BT {\n     let size_opt = lhs.size_hint().chain_ref(\n         |sz1| rhs.size_hint().map(|sz2| *sz1+*sz2));\n@@ -346,7 +346,7 @@ pub pure fn append<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n /// Copies a generic sequence, possibly converting it to a different\n /// type of sequence.\n #[inline(always)]\n-pub pure fn copy_seq<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n+pub pure fn copy_seq<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(\n     v: &IT) -> BT {\n     do build_sized_opt(v.size_hint()) |push| {\n         for v.each |x| { push(*x); }"}, {"sha": "7038ba07c0dea791394407dc8f8422c2edbaa5c2", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -62,7 +62,7 @@ pub enum RoundMode {\n  * ~~~\n  */\n #[inline(always)]\n-pub pure fn cast<T:NumCast, U:NumCast>(n: T) -> U {\n+pub pure fn cast<T:NumCast,U:NumCast>(n: T) -> U {\n     NumCast::from(n)\n }\n "}, {"sha": "e27b7086bc45bb53d0d5cc0279c639154f8ca2a0", "filename": "src/libcore/option.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -85,7 +85,7 @@ pub impl<T:Ord> Ord for Option<T> {\n }\n \n #[inline(always)]\n-pub pure fn get<T: Copy>(opt: Option<T>) -> T {\n+pub pure fn get<T:Copy>(opt: Option<T>) -> T {\n     /*!\n     Gets the value out of an option\n \n@@ -207,14 +207,14 @@ pub pure fn is_some<T>(opt: &Option<T>) -> bool {\n }\n \n #[inline(always)]\n-pub pure fn get_or_zero<T: Copy Zero>(opt: Option<T>) -> T {\n+pub pure fn get_or_zero<T:Copy + Zero>(opt: Option<T>) -> T {\n     //! Returns the contained value or zero (for this type)\n \n     match opt { Some(copy x) => x, None => Zero::zero() }\n }\n \n #[inline(always)]\n-pub pure fn get_or_default<T: Copy>(opt: Option<T>, def: T) -> T {\n+pub pure fn get_or_default<T:Copy>(opt: Option<T>, def: T) -> T {\n     //! Returns the contained value or a default\n \n     match opt { Some(copy x) => x, None => def }\n@@ -393,7 +393,7 @@ impl<T> Option<T> {\n     pure fn expect(self, reason: &str) -> T { expect(self, reason) }\n }\n \n-impl<T: Copy> Option<T> {\n+impl<T:Copy> Option<T> {\n     /**\n     Gets the value out of an option\n \n@@ -421,7 +421,7 @@ impl<T: Copy> Option<T> {\n     }\n }\n \n-impl<T: Copy Zero> Option<T> {\n+impl<T:Copy + Zero> Option<T> {\n     #[inline(always)]\n     pure fn get_or_zero(self) -> T { get_or_zero(self) }\n }"}, {"sha": "5728ac5fe78e6a9310c180a7b081a2f1856a9465", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -190,7 +190,7 @@ impl PacketHeader {\n         reinterpret_cast(&self.buffer)\n     }\n \n-    fn set_buffer<T: Owned>(b: ~Buffer<T>) {\n+    fn set_buffer<T:Owned>(b: ~Buffer<T>) {\n         unsafe {\n             self.buffer = reinterpret_cast(&b);\n         }\n@@ -208,14 +208,14 @@ pub trait HasBuffer {\n     fn set_buffer(b: *libc::c_void);\n }\n \n-impl<T: Owned> HasBuffer for Packet<T> {\n+impl<T:Owned> HasBuffer for Packet<T> {\n     fn set_buffer(b: *libc::c_void) {\n         self.header.buffer = b;\n     }\n }\n \n #[doc(hidden)]\n-pub fn mk_packet<T: Owned>() -> Packet<T> {\n+pub fn mk_packet<T:Owned>() -> Packet<T> {\n     Packet {\n         header: PacketHeader(),\n         payload: None,\n@@ -247,7 +247,7 @@ pub fn packet<T>() -> *Packet<T> {\n }\n \n #[doc(hidden)]\n-pub fn entangle_buffer<T: Owned, Tstart: Owned>(\n+pub fn entangle_buffer<T:Owned,Tstart:Owned>(\n     buffer: ~Buffer<T>,\n     init: fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n     -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n@@ -422,7 +422,7 @@ pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n Fails if the sender closes the connection.\n \n */\n-pub fn recv<T: Owned, Tbuffer: Owned>(\n+pub fn recv<T:Owned,Tbuffer:Owned>(\n     p: RecvPacketBuffered<T, Tbuffer>) -> T {\n     try_recv(p).expect(\"connection closed\")\n }\n@@ -433,7 +433,7 @@ Returns `None` if the sender has closed the connection without sending\n a message, or `Some(T)` if a message was received.\n \n */\n-pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n+pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n     -> Option<T>\n {\n     let p_ = p.unwrap();\n@@ -543,22 +543,22 @@ pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n }\n \n /// Returns true if messages are available.\n-pub pure fn peek<T: Owned, Tb: Owned>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n+pub pure fn peek<T:Owned,Tb:Owned>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n     match unsafe {(*p.header()).state} {\n       Empty | Terminated => false,\n       Blocked => fail!(~\"peeking on blocked packet\"),\n       Full => true\n     }\n }\n \n-impl<T: Owned, Tb: Owned> Peekable<T> for RecvPacketBuffered<T, Tb> {\n+impl<T:Owned,Tb:Owned> Peekable<T> for RecvPacketBuffered<T, Tb> {\n     pure fn peek() -> bool {\n         peek(&self)\n     }\n }\n \n #[doc(hidden)]\n-fn sender_terminate<T: Owned>(p: *Packet<T>) {\n+fn sender_terminate<T:Owned>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n@@ -589,7 +589,7 @@ fn sender_terminate<T: Owned>(p: *Packet<T>) {\n }\n \n #[doc(hidden)]\n-fn receiver_terminate<T: Owned>(p: *Packet<T>) {\n+fn receiver_terminate<T:Owned>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n@@ -622,7 +622,7 @@ that vector. The index points to an endpoint that has either been\n closed by the sender or has a message waiting to be received.\n \n */\n-fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n+fn wait_many<T:Selectable>(pkts: &[T]) -> uint {\n     let this = unsafe { rustrt::rust_get_task() };\n \n     unsafe {\n@@ -704,7 +704,7 @@ Sometimes messages will be available on both endpoints at once. In\n this case, `select2` may return either `left` or `right`.\n \n */\n-pub fn select2<A: Owned, Ab: Owned, B: Owned, Bb: Owned>(\n+pub fn select2<A:Owned,Ab:Owned,B:Owned,Bb:Owned>(\n     a: RecvPacketBuffered<A, Ab>,\n     b: RecvPacketBuffered<B, Bb>)\n     -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n@@ -729,12 +729,12 @@ impl Selectable for *PacketHeader {\n }\n \n /// Returns the index of an endpoint that is ready to receive.\n-pub fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n+pub fn selecti<T:Selectable>(endpoints: &[T]) -> uint {\n     wait_many(endpoints)\n }\n \n /// Returns 0 or 1 depending on which endpoint is ready to receive\n-pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n+pub fn select2i<A:Selectable,B:Selectable>(a: &A, b: &B) ->\n         Either<(), ()> {\n     match wait_many([a.header(), b.header()]) {\n       0 => Left(()),\n@@ -747,7 +747,7 @@ pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n  list of the remaining endpoints.\n \n */\n-pub fn select<T: Owned, Tb: Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n+pub fn select<T:Owned,Tb:Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n     -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n@@ -842,7 +842,7 @@ pub struct RecvPacketBuffered<T, Tbuffer> {\n     mut buffer: Option<BufferResource<Tbuffer>>,\n }\n \n-impl<T:Owned, Tbuffer:Owned> ::ops::Drop for RecvPacketBuffered<T,Tbuffer> {\n+impl<T:Owned,Tbuffer:Owned> ::ops::Drop for RecvPacketBuffered<T,Tbuffer> {\n     fn finalize(&self) {\n         //if self.p != none {\n         //    debug!(\"drop recv %?\", option::get(self.p));\n@@ -859,7 +859,7 @@ impl<T:Owned, Tbuffer:Owned> ::ops::Drop for RecvPacketBuffered<T,Tbuffer> {\n     }\n }\n \n-impl<T: Owned, Tbuffer: Owned> RecvPacketBuffered<T, Tbuffer> {\n+impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n     fn unwrap() -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n@@ -874,7 +874,7 @@ impl<T: Owned, Tbuffer: Owned> RecvPacketBuffered<T, Tbuffer> {\n     }\n }\n \n-impl<T: Owned, Tbuffer: Owned> Selectable for RecvPacketBuffered<T, Tbuffer> {\n+impl<T:Owned,Tbuffer:Owned> Selectable for RecvPacketBuffered<T, Tbuffer> {\n     pure fn header() -> *PacketHeader {\n         match self.p {\n           Some(packet) => unsafe {\n@@ -913,7 +913,7 @@ endpoint. The send endpoint is returned to the caller and the receive\n endpoint is passed to the new task.\n \n */\n-pub fn spawn_service<T: Owned, Tb: Owned>(\n+pub fn spawn_service<T:Owned,Tb:Owned>(\n     init: extern fn() -> (SendPacketBuffered<T, Tb>,\n                           RecvPacketBuffered<T, Tb>),\n     service: fn~(v: RecvPacketBuffered<T, Tb>))\n@@ -937,7 +937,7 @@ pub fn spawn_service<T: Owned, Tb: Owned>(\n receive state.\n \n */\n-pub fn spawn_service_recv<T: Owned, Tb: Owned>(\n+pub fn spawn_service_recv<T:Owned,Tb:Owned>(\n     init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n                           SendPacketBuffered<T, Tb>),\n     service: fn~(v: SendPacketBuffered<T, Tb>))\n@@ -960,7 +960,7 @@ pub fn spawn_service_recv<T: Owned, Tb: Owned>(\n // Streams - Make pipes a little easier in general.\n \n proto! streamp (\n-    Open:send<T: Owned> {\n+    Open:send<T:Owned> {\n         data(T) -> Open<T>\n     }\n )\n@@ -1026,7 +1026,7 @@ pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n     (Port_(Port_ { endp: Some(s) }), Chan_(Chan_{ endp: Some(c) }))\n }\n \n-impl<T: Owned> GenericChan<T> for Chan<T> {\n+impl<T:Owned> GenericChan<T> for Chan<T> {\n     fn send(x: T) {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -1035,7 +1035,7 @@ impl<T: Owned> GenericChan<T> for Chan<T> {\n     }\n }\n \n-impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+impl<T:Owned> GenericSmartChan<T> for Chan<T> {\n \n     fn try_send(x: T) -> bool {\n         let mut endp = None;\n@@ -1050,7 +1050,7 @@ impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n     }\n }\n \n-impl<T: Owned> GenericPort<T> for Port<T> {\n+impl<T:Owned> GenericPort<T> for Port<T> {\n     fn recv() -> T {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -1072,7 +1072,7 @@ impl<T: Owned> GenericPort<T> for Port<T> {\n     }\n }\n \n-impl<T: Owned> Peekable<T> for Port<T> {\n+impl<T:Owned> Peekable<T> for Port<T> {\n     pure fn peek() -> bool {\n         unsafe {\n             let mut endp = None;\n@@ -1087,7 +1087,7 @@ impl<T: Owned> Peekable<T> for Port<T> {\n     }\n }\n \n-impl<T: Owned> Selectable for Port<T> {\n+impl<T:Owned> Selectable for Port<T> {\n     pure fn header() -> *PacketHeader {\n         unsafe {\n             match self.endp {\n@@ -1103,13 +1103,13 @@ pub struct PortSet<T> {\n     mut ports: ~[pipes::Port<T>],\n }\n \n-pub fn PortSet<T: Owned>() -> PortSet<T>{\n+pub fn PortSet<T:Owned>() -> PortSet<T>{\n     PortSet {\n         ports: ~[]\n     }\n }\n \n-impl<T: Owned> PortSet<T> {\n+impl<T:Owned> PortSet<T> {\n \n     fn add(port: pipes::Port<T>) {\n         self.ports.push(port)\n@@ -1122,7 +1122,7 @@ impl<T: Owned> PortSet<T> {\n     }\n }\n \n-impl<T: Owned> GenericPort<T> for PortSet<T> {\n+impl<T:Owned> GenericPort<T> for PortSet<T> {\n \n     fn try_recv() -> Option<T> {\n         let mut result = None;\n@@ -1152,7 +1152,7 @@ impl<T: Owned> GenericPort<T> for PortSet<T> {\n \n }\n \n-impl<T: Owned> Peekable<T> for PortSet<T> {\n+impl<T:Owned> Peekable<T> for PortSet<T> {\n     pure fn peek() -> bool {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n@@ -1166,7 +1166,7 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n /// A channel that can be shared between many senders.\n pub type SharedChan<T> = private::Exclusive<Chan<T>>;\n \n-impl<T: Owned> GenericChan<T> for SharedChan<T> {\n+impl<T:Owned> GenericChan<T> for SharedChan<T> {\n     fn send(x: T) {\n         let mut xx = Some(x);\n         do self.with_imm |chan| {\n@@ -1177,7 +1177,7 @@ impl<T: Owned> GenericChan<T> for SharedChan<T> {\n     }\n }\n \n-impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n+impl<T:Owned> GenericSmartChan<T> for SharedChan<T> {\n     fn try_send(x: T) -> bool {\n         let mut xx = Some(x);\n         do self.with_imm |chan| {\n@@ -1194,7 +1194,7 @@ pub fn SharedChan<T:Owned>(c: Chan<T>) -> SharedChan<T> {\n }\n \n /// Receive a message from one of two endpoints.\n-pub trait Select2<T: Owned, U: Owned> {\n+pub trait Select2<T:Owned,U:Owned> {\n     /// Receive a message or return `None` if a connection closes.\n     fn try_select() -> Either<Option<T>, Option<U>>;\n     /// Receive a message or fail if a connection closes.\n@@ -1237,17 +1237,17 @@ pub type ChanOne<T> = oneshot::client::Oneshot<T>;\n pub type PortOne<T> = oneshot::server::Oneshot<T>;\n \n /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n-pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n+pub fn oneshot<T:Owned>() -> (PortOne<T>, ChanOne<T>) {\n     let (chan, port) = oneshot::init();\n     (port, chan)\n }\n \n-impl<T: Owned> PortOne<T> {\n+impl<T:Owned> PortOne<T> {\n     fn recv(self) -> T { recv_one(self) }\n     fn try_recv(self) -> Option<T> { try_recv_one(self) }\n }\n \n-impl<T: Owned> ChanOne<T> {\n+impl<T:Owned> ChanOne<T> {\n     fn send(self, data: T) { send_one(self, data) }\n     fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n }\n@@ -1256,13 +1256,13 @@ impl<T: Owned> ChanOne<T> {\n  * Receive a message from a oneshot pipe, failing if the connection was\n  * closed.\n  */\n-pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n+pub fn recv_one<T:Owned>(port: PortOne<T>) -> T {\n     let oneshot::send(message) = recv(port);\n     message\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n-pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n+pub fn try_recv_one<T:Owned> (port: PortOne<T>) -> Option<T> {\n     let message = try_recv(port);\n \n     if message.is_none() { None }\n@@ -1273,15 +1273,15 @@ pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n }\n \n /// Send a message on a oneshot pipe, failing if the connection was closed.\n-pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n+pub fn send_one<T:Owned>(chan: ChanOne<T>, data: T) {\n     oneshot::client::send(chan, data);\n }\n \n /**\n  * Send a message on a oneshot pipe, or return false if the connection was\n  * closed.\n  */\n-pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T)\n+pub fn try_send_one<T:Owned>(chan: ChanOne<T>, data: T)\n         -> bool {\n     oneshot::client::try_send(chan, data).is_some()\n }"}, {"sha": "61f2e013ababc54b29f3c2a0ddc10d6639859a8c", "filename": "src/libcore/private.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -166,7 +166,7 @@ fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n     }\n }\n \n-pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n+pub unsafe fn unwrap_shared_mutable_state<T:Owned>(rc: SharedMutableState<T>)\n         -> T {\n     struct DeathThroes<T> {\n         mut ptr:      Option<~ArcData<T>>,\n@@ -242,7 +242,7 @@ pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n  */\n pub type SharedMutableState<T> = ArcDestruct<T>;\n \n-pub unsafe fn shared_mutable_state<T: Owned>(data: T) ->\n+pub unsafe fn shared_mutable_state<T:Owned>(data: T) ->\n         SharedMutableState<T> {\n     let data = ~ArcData { count: 1, unwrapper: 0, data: Some(data) };\n     unsafe {\n@@ -252,7 +252,7 @@ pub unsafe fn shared_mutable_state<T: Owned>(data: T) ->\n }\n \n #[inline(always)]\n-pub unsafe fn get_shared_mutable_state<T: Owned>(\n+pub unsafe fn get_shared_mutable_state<T:Owned>(\n     rc: *SharedMutableState<T>) -> *mut T\n {\n     unsafe {\n@@ -264,7 +264,7 @@ pub unsafe fn get_shared_mutable_state<T: Owned>(\n     }\n }\n #[inline(always)]\n-pub unsafe fn get_shared_immutable_state<T: Owned>(\n+pub unsafe fn get_shared_immutable_state<T:Owned>(\n         rc: &a/SharedMutableState<T>) -> &a/T {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n@@ -276,7 +276,7 @@ pub unsafe fn get_shared_immutable_state<T: Owned>(\n     }\n }\n \n-pub unsafe fn clone_shared_mutable_state<T: Owned>(rc: &SharedMutableState<T>)\n+pub unsafe fn clone_shared_mutable_state<T:Owned>(rc: &SharedMutableState<T>)\n         -> SharedMutableState<T> {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n@@ -287,7 +287,7 @@ pub unsafe fn clone_shared_mutable_state<T: Owned>(rc: &SharedMutableState<T>)\n     ArcDestruct((*rc).data)\n }\n \n-impl<T: Owned> Clone for SharedMutableState<T> {\n+impl<T:Owned> Clone for SharedMutableState<T> {\n     fn clone(&self) -> SharedMutableState<T> {\n         unsafe {\n             clone_shared_mutable_state(self)\n@@ -349,21 +349,21 @@ struct ExData<T> { lock: LittleLock, mut failed: bool, mut data: T, }\n  */\n pub struct Exclusive<T> { x: SharedMutableState<ExData<T>> }\n \n-pub fn exclusive<T:Owned >(user_data: T) -> Exclusive<T> {\n+pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n         lock: LittleLock(), mut failed: false, mut data: user_data\n     };\n     Exclusive { x: unsafe { shared_mutable_state(data) } }\n }\n \n-impl<T: Owned> Clone for Exclusive<T> {\n+impl<T:Owned> Clone for Exclusive<T> {\n     // Duplicate an exclusive ARC, as std::arc::clone.\n     fn clone(&self) -> Exclusive<T> {\n         Exclusive { x: unsafe { clone_shared_mutable_state(&self.x) } }\n     }\n }\n \n-impl<T: Owned> Exclusive<T> {\n+impl<T:Owned> Exclusive<T> {\n     // Exactly like std::arc::mutex_arc,access(), but with the little_lock\n     // instead of a proper mutex. Same reason for being unsafe.\n     //\n@@ -396,7 +396,7 @@ impl<T: Owned> Exclusive<T> {\n }\n \n // FIXME(#3724) make this a by-move method on the exclusive\n-pub fn unwrap_exclusive<T: Owned>(arc: Exclusive<T>) -> T {\n+pub fn unwrap_exclusive<T:Owned>(arc: Exclusive<T>) -> T {\n     let Exclusive { x: x } = arc;\n     let inner = unsafe { unwrap_shared_mutable_state(x) };\n     let ExData { data: data, _ } = inner;"}, {"sha": "77b61347250d2b85b1c2d93e9bfc88a734bec413", "filename": "src/libcore/private/global.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fprivate%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fprivate%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fglobal.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -44,7 +44,7 @@ use uint;\n \n pub type GlobalDataKey<T> = &fn(v: T);\n \n-pub unsafe fn global_data_clone_create<T: Owned Clone>(\n+pub unsafe fn global_data_clone_create<T:Owned + Clone>(\n     key: GlobalDataKey<T>, create: &fn() -> ~T) -> T {\n     /*!\n      * Clone a global value or, if it has not been created,\n@@ -60,7 +60,7 @@ pub unsafe fn global_data_clone_create<T: Owned Clone>(\n     global_data_clone_create_(key_ptr(key), create)\n }\n \n-unsafe fn global_data_clone_create_<T: Owned Clone>(\n+unsafe fn global_data_clone_create_<T:Owned + Clone>(\n     key: uint, create: &fn() -> ~T) -> T {\n \n     let mut clone_value: Option<T> = None;\n@@ -80,13 +80,13 @@ unsafe fn global_data_clone_create_<T: Owned Clone>(\n     return clone_value.unwrap();\n }\n \n-unsafe fn global_data_modify<T: Owned>(\n+unsafe fn global_data_modify<T:Owned>(\n     key: GlobalDataKey<T>, op: &fn(Option<~T>) -> Option<~T>) {\n \n     global_data_modify_(key_ptr(key), op)\n }\n \n-unsafe fn global_data_modify_<T: Owned>(\n+unsafe fn global_data_modify_<T:Owned>(\n     key: uint, op: &fn(Option<~T>) -> Option<~T>) {\n \n     let mut old_dtor = None;\n@@ -125,7 +125,7 @@ unsafe fn global_data_modify_<T: Owned>(\n     }\n }\n \n-pub unsafe fn global_data_clone<T: Owned Clone>(\n+pub unsafe fn global_data_clone<T:Owned + Clone>(\n     key: GlobalDataKey<T>) -> Option<T> {\n     let mut maybe_clone: Option<T> = None;\n     do global_data_modify(key) |current| {\n@@ -221,7 +221,7 @@ fn get_global_state() -> Exclusive<GlobalState> {\n     }\n }\n \n-fn key_ptr<T: Owned>(key: GlobalDataKey<T>) -> uint {\n+fn key_ptr<T:Owned>(key: GlobalDataKey<T>) -> uint {\n     unsafe {\n         let closure: Closure = reinterpret_cast(&key);\n         return transmute(closure.code);"}, {"sha": "a88b83465161da8b4ee58ddefee7c82666ca309e", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -109,7 +109,7 @@ impl Rand for bool {\n     }\n }\n \n-impl<T: Rand> Rand for Option<T> {\n+impl<T:Rand> Rand for Option<T> {\n     static fn rand(rng: rand::Rng) -> Option<T> {\n         if rng.gen_bool() { Some(Rand::rand(rng)) }\n         else { None }\n@@ -143,7 +143,7 @@ pub struct Weighted<T> {\n /// Extension methods for random number generators\n impl Rng {\n     /// Return a random value for a Rand type\n-    fn gen<T: Rand>() -> T {\n+    fn gen<T:Rand>() -> T {\n         Rand::rand(self)\n     }\n \n@@ -302,7 +302,7 @@ impl Rng {\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n      */\n-    fn choose_weighted<T: Copy>(v : &[Weighted<T>]) -> T {\n+    fn choose_weighted<T:Copy>(v : &[Weighted<T>]) -> T {\n         self.choose_weighted_option(v).get()\n     }\n "}, {"sha": "ed7e485678e10dcefb9ada7362d21e332ebdc900", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -41,11 +41,11 @@ pub fn align(size: uint, align: uint) -> uint {\n pub struct MovePtrAdaptor<V> {\n     inner: V\n }\n-pub fn MovePtrAdaptor<V: TyVisitor MovePtr>(v: V) -> MovePtrAdaptor<V> {\n+pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n     MovePtrAdaptor { inner: v }\n }\n \n-impl<V: TyVisitor MovePtr> MovePtrAdaptor<V> {\n+impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n     #[inline(always)]\n     fn bump(sz: uint) {\n       do self.inner.move_ptr() |p| {\n@@ -72,7 +72,7 @@ impl<V: TyVisitor MovePtr> MovePtrAdaptor<V> {\n }\n \n /// Abstract type-directed pointer-movement using the MovePtr trait\n-impl<V: TyVisitor MovePtr> TyVisitor for MovePtrAdaptor<V> {\n+impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     fn visit_bot(&self) -> bool {\n         self.align_to::<()>();\n         if ! self.inner.visit_bot() { return false; }"}, {"sha": "b03eaeab3e0cc510a082711a73d6c4a1344dbf47", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -37,7 +37,7 @@ pub enum Result<T, U> {\n  * If the result is an error\n  */\n #[inline(always)]\n-pub pure fn get<T: Copy, U>(res: &Result<T, U>) -> T {\n+pub pure fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n     match *res {\n       Ok(copy t) => t,\n       Err(ref the_err) => unsafe {\n@@ -100,7 +100,7 @@ pub pure fn is_err<T, U>(res: &Result<T, U>) -> bool {\n  * result variants are converted to `either::left`.\n  */\n #[inline(always)]\n-pub pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>)\n+pub pure fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n     -> Either<T, U> {\n     match *res {\n       Ok(copy res) => either::Right(res),\n@@ -220,7 +220,7 @@ pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn(&T) -> U)\n  * successful result while handling an error.\n  */\n #[inline(always)]\n-pub pure fn map_err<T: Copy, E, F: Copy>(res: &Result<T, E>, op: fn(&E) -> F)\n+pub pure fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n       Ok(copy t) => Ok(t),\n@@ -261,7 +261,7 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n-impl<T: Copy, E> Result<T, E> {\n+impl<T:Copy,E> Result<T, E> {\n     #[inline(always)]\n     pure fn get(&self) -> T { get(self) }\n "}, {"sha": "ae101faaf0264f4f3cf1cc77e17c0e31aa0eb9e6", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -51,7 +51,7 @@ pub type LocalDataKey<T> = &fn(v: @T);\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n-pub unsafe fn local_data_pop<T: Durable>(\n+pub unsafe fn local_data_pop<T:Durable>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_pop(rt::rust_get_task(), key)\n@@ -60,7 +60,7 @@ pub unsafe fn local_data_pop<T: Durable>(\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n-pub unsafe fn local_data_get<T: Durable>(\n+pub unsafe fn local_data_get<T:Durable>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get(rt::rust_get_task(), key)\n@@ -69,7 +69,7 @@ pub unsafe fn local_data_get<T: Durable>(\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n-pub unsafe fn local_data_set<T: Durable>(\n+pub unsafe fn local_data_set<T:Durable>(\n     key: LocalDataKey<T>, data: @T) {\n \n     local_set(rt::rust_get_task(), key, data)\n@@ -78,7 +78,7 @@ pub unsafe fn local_data_set<T: Durable>(\n  * Modify a task-local data value. If the function returns 'None', the\n  * data is removed (and its reference dropped).\n  */\n-pub unsafe fn local_data_modify<T: Durable>(\n+pub unsafe fn local_data_modify<T:Durable>(\n     key: LocalDataKey<T>,\n     modify_fn: fn(Option<@T>) -> Option<@T>) {\n "}, {"sha": "3ac457b23d16eaefc53de7910abf08e9dde18d5b", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -26,7 +26,7 @@ use rt::rust_task;\n type rust_task = libc::c_void;\n \n pub trait LocalData { }\n-impl<T: Durable> LocalData for @T { }\n+impl<T:Durable> LocalData for @T { }\n \n impl Eq for LocalData {\n     pure fn eq(&self, other: &@LocalData) -> bool {\n@@ -79,7 +79,7 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     }\n }\n \n-unsafe fn key_to_key_value<T: Durable>(\n+unsafe fn key_to_key_value<T:Durable>(\n     key: LocalDataKey<T>) -> *libc::c_void {\n \n     // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n@@ -89,7 +89,7 @@ unsafe fn key_to_key_value<T: Durable>(\n }\n \n // If returning Some(..), returns with @T with the map's reference. Careful!\n-unsafe fn local_data_lookup<T: Durable>(\n+unsafe fn local_data_lookup<T:Durable>(\n     map: TaskLocalMap, key: LocalDataKey<T>)\n     -> Option<(uint, *libc::c_void)> {\n \n@@ -107,7 +107,7 @@ unsafe fn local_data_lookup<T: Durable>(\n     }\n }\n \n-unsafe fn local_get_helper<T: Durable>(\n+unsafe fn local_get_helper<T:Durable>(\n     task: *rust_task, key: LocalDataKey<T>,\n     do_pop: bool) -> Option<@T> {\n \n@@ -129,21 +129,21 @@ unsafe fn local_get_helper<T: Durable>(\n }\n \n \n-pub unsafe fn local_pop<T: Durable>(\n+pub unsafe fn local_pop<T:Durable>(\n     task: *rust_task,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get_helper(task, key, true)\n }\n \n-pub unsafe fn local_get<T: Durable>(\n+pub unsafe fn local_get<T:Durable>(\n     task: *rust_task,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get_helper(task, key, false)\n }\n \n-pub unsafe fn local_set<T: Durable>(\n+pub unsafe fn local_set<T:Durable>(\n     task: *rust_task, key: LocalDataKey<T>, data: @T) {\n \n     let map = get_task_local_map(task);\n@@ -175,7 +175,7 @@ pub unsafe fn local_set<T: Durable>(\n     }\n }\n \n-pub unsafe fn local_modify<T: Durable>(\n+pub unsafe fn local_modify<T:Durable>(\n     task: *rust_task, key: LocalDataKey<T>,\n     modify_fn: fn(Option<@T>) -> Option<@T>) {\n "}, {"sha": "54dfa7459a1e7b94222388576b39784ffa1f1193", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -396,7 +396,7 @@ impl TaskBuilder {\n         spawn::spawn_raw(opts, (x.gen_body)(f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A: Owned>(arg: A, f: fn~(v: A)) {\n+    fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n         let arg = ~mut Some(arg);\n         do self.spawn || {\n             f(option::swap_unwrap(arg))\n@@ -416,7 +416,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn try<T: Owned>(f: fn~() -> T) -> Result<T,()> {\n+    fn try<T:Owned>(f: fn~() -> T) -> Result<T,()> {\n         let (po, ch) = stream::<T>();\n         let mut result = None;\n "}, {"sha": "4b2cd3c2fab5bb6222821fae936e8c4ff717059b", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -197,7 +197,7 @@ impl IterBytes for int {\n     }\n }\n \n-impl<A: IterBytes> IterBytes for &[A] {\n+impl<A:IterBytes> IterBytes for &[A] {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         for (*self).each |elt| {\n@@ -208,7 +208,7 @@ impl<A: IterBytes> IterBytes for &[A] {\n     }\n }\n \n-impl<A: IterBytes, B: IterBytes> IterBytes for (A,B) {\n+impl<A:IterBytes,B:IterBytes> IterBytes for (A,B) {\n   #[inline(always)]\n   pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n     match *self {\n@@ -219,7 +219,7 @@ impl<A: IterBytes, B: IterBytes> IterBytes for (A,B) {\n   }\n }\n \n-impl<A: IterBytes, B: IterBytes, C: IterBytes> IterBytes for (A,B,C) {\n+impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n   #[inline(always)]\n   pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n     match *self {\n@@ -235,21 +235,21 @@ pure fn borrow<A>(a: &x/[A]) -> &x/[A] {\n     a\n }\n \n-impl<A: IterBytes> IterBytes for ~[A] {\n+impl<A:IterBytes> IterBytes for ~[A] {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n \n-impl<A: IterBytes> IterBytes for @[A] {\n+impl<A:IterBytes> IterBytes for @[A] {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         borrow(*self).iter_bytes(lsb0, f)\n     }\n }\n \n-pub pure fn iter_bytes_2<A: IterBytes, B: IterBytes>(a: &A, b: &B,\n+pub pure fn iter_bytes_2<A:IterBytes,B:IterBytes>(a: &A, b: &B,\n                                             lsb0: bool, z: Cb) {\n     let mut flag = true;\n     a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n@@ -379,7 +379,7 @@ impl IterBytes for @str {\n     }\n }\n \n-impl<A: IterBytes> IterBytes for Option<A> {\n+impl<A:IterBytes> IterBytes for Option<A> {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         match *self {\n@@ -389,21 +389,21 @@ impl<A: IterBytes> IterBytes for Option<A> {\n     }\n }\n \n-impl<A: IterBytes> IterBytes for &A {\n+impl<A:IterBytes> IterBytes for &A {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n \n-impl<A: IterBytes> IterBytes for @A {\n+impl<A:IterBytes> IterBytes for @A {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n     }\n }\n \n-impl<A: IterBytes> IterBytes for ~A {\n+impl<A:IterBytes> IterBytes for ~A {\n     #[inline(always)]\n     pure fn iter_bytes(&self, lsb0: bool, f: Cb) {\n         (**self).iter_bytes(lsb0, f);\n@@ -424,7 +424,7 @@ trait ToBytes {\n     fn to_bytes(&self, lsb0: bool) -> ~[u8];\n }\n \n-impl<A: IterBytes> ToBytes for A {\n+impl<A:IterBytes> ToBytes for A {\n     fn to_bytes(&self, lsb0: bool) -> ~[u8] {\n         do io::with_bytes_writer |wr| {\n             for self.iter_bytes(lsb0) |bytes| {"}, {"sha": "0145adc77b826d992d0f2f3d69b576bcd0fd2262", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -45,7 +45,7 @@ impl ToStr for @str {\n \n // FIXME #4898: impl for one-tuples\n \n-impl<A: ToStr, B: ToStr> ToStr for (A, B) {\n+impl<A:ToStr,B:ToStr> ToStr for (A, B) {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str {\n         // FIXME(#4760): this causes an llvm assertion\n@@ -57,7 +57,7 @@ impl<A: ToStr, B: ToStr> ToStr for (A, B) {\n         }\n     }\n }\n-impl<A: ToStr, B: ToStr, C: ToStr> ToStr for (A, B, C) {\n+impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str {\n         // FIXME(#4760): this causes an llvm assertion\n@@ -74,7 +74,7 @@ impl<A: ToStr, B: ToStr, C: ToStr> ToStr for (A, B, C) {\n     }\n }\n \n-impl<A: ToStr> ToStr for ~[A] {\n+impl<A:ToStr> ToStr for ~[A] {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str {\n         unsafe {\n@@ -94,11 +94,11 @@ impl<A: ToStr> ToStr for ~[A] {\n     }\n }\n \n-impl<A: ToStr> ToStr for @A {\n+impl<A:ToStr> ToStr for @A {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str { ~\"@\" + (**self).to_str() }\n }\n-impl<A: ToStr> ToStr for ~A {\n+impl<A:ToStr> ToStr for ~A {\n     #[inline(always)]\n     pure fn to_str(&self) -> ~str { ~\"~\" + (**self).to_str() }\n }"}, {"sha": "dde7d718c13d5d41d8213933ca0c97d0daceb946", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -20,7 +20,7 @@ pub trait CopyableTuple<T, U> {\n     pure fn swap() -> (U, T);\n }\n \n-impl<T: Copy, U: Copy> CopyableTuple<T, U> for (T, U) {\n+impl<T:Copy,U:Copy> CopyableTuple<T, U> for (T, U) {\n \n     /// Return the first element of self\n     #[inline(always)]\n@@ -70,7 +70,7 @@ pub trait ExtendedTupleOps<A,B> {\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C];\n }\n \n-impl<A: Copy, B: Copy> ExtendedTupleOps<A,B> for (&[A], &[B]) {\n+impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&[A], &[B]) {\n     #[inline(always)]\n     fn zip(&self) -> ~[(A, B)] {\n         match *self {\n@@ -90,7 +90,7 @@ impl<A: Copy, B: Copy> ExtendedTupleOps<A,B> for (&[A], &[B]) {\n     }\n }\n \n-impl<A: Copy, B: Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n+impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n \n     #[inline(always)]\n     fn zip(&self) -> ~[(A, B)] {\n@@ -114,7 +114,7 @@ impl<A: Copy, B: Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n // FIXME #4898: impl for one-tuples\n \n #[cfg(notest)]\n-impl<A: Eq, B: Eq> Eq for (A, B) {\n+impl<A:Eq,B:Eq> Eq for (A, B) {\n     #[inline(always)]\n     pure fn eq(&self, other: &(A, B)) -> bool {\n         match (*self) {\n@@ -130,7 +130,7 @@ impl<A: Eq, B: Eq> Eq for (A, B) {\n }\n \n #[cfg(notest)]\n-impl<A: Ord, B: Ord> Ord for (A, B) {\n+impl<A:Ord,B:Ord> Ord for (A, B) {\n     #[inline(always)]\n     pure fn lt(&self, other: &(A, B)) -> bool {\n         match (*self) {\n@@ -155,7 +155,7 @@ impl<A: Ord, B: Ord> Ord for (A, B) {\n }\n \n #[cfg(notest)]\n-impl<A: Eq, B: Eq, C: Eq> Eq for (A, B, C) {\n+impl<A:Eq,B:Eq,C:Eq> Eq for (A, B, C) {\n     #[inline(always)]\n     pure fn eq(&self, other: &(A, B, C)) -> bool {\n         match (*self) {\n@@ -172,7 +172,7 @@ impl<A: Eq, B: Eq, C: Eq> Eq for (A, B, C) {\n }\n \n #[cfg(notest)]\n-impl<A: Ord, B: Ord, C: Ord> Ord for (A, B, C) {\n+impl<A:Ord,B:Ord,C:Ord> Ord for (A, B, C) {\n     #[inline(always)]\n     pure fn lt(&self, other: &(A, B, C)) -> bool {\n         match (*self) {"}, {"sha": "629c4a3291ce0e5cd9f3b6d7f05e997de4c98a47", "filename": "src/libcore/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -28,7 +28,7 @@ pub pure fn ignore<T>(_x: T) { }\n /// Sets `*ptr` to `new_value`, invokes `op()`, and then restores the\n /// original value of `*ptr`.\n #[inline(always)]\n-pub fn with<T: Copy, R>(\n+pub fn with<T:Copy,R>(\n     ptr: &mut T,\n     new_value: T,\n     op: &fn() -> R) -> R"}, {"sha": "97162568d57a6b49877661dc52d7518b4d8118f1", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -130,12 +130,12 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pub pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> ~[T] {\n+pub pure fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n     from_fn(n_elts, |_i| copy t)\n }\n \n /// Creates a new unique vector with the same contents as the slice\n-pub pure fn from_slice<T: Copy>(t: &[T]) -> ~[T] {\n+pub pure fn from_slice<T:Copy>(t: &[T]) -> ~[T] {\n     from_fn(t.len(), |i| t[i])\n }\n \n@@ -211,29 +211,29 @@ pub pure fn cast_from_mut<T>(v: ~[mut T]) -> ~[T] {\n // Accessors\n \n /// Returns the first element of a vector\n-pub pure fn head<T: Copy>(v: &[const T]) -> T { v[0] }\n+pub pure fn head<T:Copy>(v: &[const T]) -> T { v[0] }\n \n /// Returns a vector containing all but the first element of a slice\n-pub pure fn tail<T: Copy>(v: &[const T]) -> ~[T] {\n+pub pure fn tail<T:Copy>(v: &[const T]) -> ~[T] {\n     slice(v, 1u, len(v)).to_vec()\n }\n \n /**\n  * Returns a vector containing all but the first `n` \\\n  * elements of a slice\n  */\n-pub pure fn tailn<T: Copy>(v: &[const T], n: uint) -> ~[T] {\n+pub pure fn tailn<T:Copy>(v: &[const T], n: uint) -> ~[T] {\n     slice(v, n, len(v)).to_vec()\n }\n \n /// Returns a vector containing all but the last element of a slice\n-pub pure fn init<T: Copy>(v: &[const T]) -> ~[T] {\n+pub pure fn init<T:Copy>(v: &[const T]) -> ~[T] {\n     assert len(v) != 0u;\n     slice(v, 0u, len(v) - 1u).to_vec()\n }\n \n /// Returns the last element of the slice `v`, failing if the slice is empty.\n-pub pure fn last<T: Copy>(v: &[const T]) -> T {\n+pub pure fn last<T:Copy>(v: &[const T]) -> T {\n     if len(v) == 0u { fail!(~\"last_unsafe: empty vector\") }\n     v[len(v) - 1u]\n }\n@@ -242,7 +242,7 @@ pub pure fn last<T: Copy>(v: &[const T]) -> T {\n  * Returns `Some(x)` where `x` is the last element of the slice `v`,\n  * or `none` if the vector is empty.\n  */\n-pub pure fn last_opt<T: Copy>(v: &[const T]) -> Option<T> {\n+pub pure fn last_opt<T:Copy>(v: &[const T]) -> Option<T> {\n     if len(v) == 0u { return None; }\n     Some(v[len(v) - 1u])\n }\n@@ -295,7 +295,7 @@ pub pure fn const_slice<T>(v: &r/[const T], start: uint,\n /// Copies\n \n /// Split the vector `v` by applying each element against the predicate `f`.\n-pub fn split<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn split<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -318,7 +318,7 @@ pub fn split<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Split the vector `v` by applying each element against the predicate `f` up\n  * to `n` times.\n  */\n-pub fn splitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn splitn<T:Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -344,7 +344,7 @@ pub fn splitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f`.\n  */\n-pub fn rsplit<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn rsplit<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0) { return ~[] }\n \n@@ -368,7 +368,7 @@ pub fn rsplit<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f` up to `n times.\n  */\n-pub fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -416,7 +416,7 @@ pub fn partition<T>(v: ~[T], f: fn(&T) -> bool) -> (~[T], ~[T]) {\n  * Partitions a vector into two new vectors: those that satisfies the\n  * predicate, and those that do not.\n  */\n-pub pure fn partitioned<T: Copy>(v: &[T], f: fn(&T) -> bool) -> (~[T], ~[T]) {\n+pub pure fn partitioned<T:Copy>(v: &[T], f: fn(&T) -> bool) -> (~[T], ~[T]) {\n     let mut lefts  = ~[];\n     let mut rights = ~[];\n \n@@ -611,7 +611,7 @@ fn push_slow<T>(v: &mut ~[T], initval: T) {\n }\n \n #[inline(always)]\n-pub fn push_all<T: Copy>(v: &mut ~[T], rhs: &[const T]) {\n+pub fn push_all<T:Copy>(v: &mut ~[T], rhs: &[const T]) {\n     let new_len = v.len() + rhs.len();\n     reserve(&mut *v, new_len);\n \n@@ -657,7 +657,7 @@ pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n  * Remove consecutive repeated elements from a vector; if the vector is\n  * sorted, this removes all duplicates.\n  */\n-pub fn dedup<T: Eq>(v: &mut ~[T]) {\n+pub fn dedup<T:Eq>(v: &mut ~[T]) {\n     unsafe {\n         if v.len() < 1 { return; }\n         let mut last_written = 0, next_to_read = 1;\n@@ -695,7 +695,7 @@ pub fn dedup<T: Eq>(v: &mut ~[T]) {\n \n // Appending\n #[inline(always)]\n-pub pure fn append<T: Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n+pub pure fn append<T:Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n     let mut v = lhs;\n     unsafe {\n         v.push_all(rhs);\n@@ -719,7 +719,7 @@ pub pure fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n  * * n - The number of elements to add\n  * * initval - The value for the new elements\n  */\n-pub fn grow<T: Copy>(v: &mut ~[T], n: uint, initval: &T) {\n+pub fn grow<T:Copy>(v: &mut ~[T], n: uint, initval: &T) {\n     let new_len = v.len() + n;\n     reserve_at_least(&mut *v, new_len);\n     let mut i: uint = 0u;\n@@ -761,7 +761,7 @@ pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: iter::InitOp<T>) {\n  * of the vector, expands the vector by replicating `initval` to fill the\n  * intervening space.\n  */\n-pub fn grow_set<T: Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n+pub fn grow_set<T:Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n     let l = v.len();\n     if index >= l { grow(&mut *v, index - l + 1u, initval); }\n     v[index] = val;\n@@ -808,7 +808,7 @@ pub pure fn flat_map<T, U>(v: &[T], f: fn(t: &T) -> ~[U]) -> ~[U] {\n }\n \n /// Apply a function to each pair of elements and return the results\n-pub pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n+pub pure fn map2<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n                                   f: fn(t: &T, v: &U) -> V) -> ~[V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail!(); }\n@@ -886,7 +886,7 @@ pub fn filter<T>(v: ~[T], f: fn(t: &T) -> bool) -> ~[T] {\n  * Apply function `f` to each element of `v` and return a vector containing\n  * only those elements for which `f` returned true.\n  */\n-pub pure fn filtered<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n+pub pure fn filtered<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n         if f(elem) { unsafe { result.push(*elem); } }\n@@ -919,14 +919,14 @@ pub fn retain<T>(v: &mut ~[T], f: pure fn(t: &T) -> bool) {\n  *\n  * Flattens a vector of vectors of T into a single vector of T.\n  */\n-pub pure fn concat<T: Copy>(v: &[~[T]]) -> ~[T] {\n+pub pure fn concat<T:Copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n     for each(v) |inner| { unsafe { r.push_all(*inner); } }\n     r\n }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n-pub pure fn connect<T: Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n+pub pure fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n     for each(v) |inner| {\n@@ -1055,13 +1055,13 @@ pub pure fn all2<T, U>(v0: &[T], v1: &[U],\n }\n \n /// Return true if a vector contains an element with the given value\n-pub pure fn contains<T: Eq>(v: &[T], x: &T) -> bool {\n+pub pure fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n     for each(v) |elt| { if *x == *elt { return true; } }\n     return false;\n }\n \n /// Returns the number of elements that are equal to a given value\n-pub pure fn count<T: Eq>(v: &[T], x: &T) -> uint {\n+pub pure fn count<T:Eq>(v: &[T], x: &T) -> uint {\n     let mut cnt = 0u;\n     for each(v) |elt| { if *x == *elt { cnt += 1u; } }\n     return cnt;\n@@ -1074,7 +1074,7 @@ pub pure fn count<T: Eq>(v: &[T], x: &T) -> uint {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n+pub pure fn find<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n@@ -1085,7 +1085,7 @@ pub pure fn find<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the element is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n+pub pure fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n                       f: fn(t: &T) -> bool) -> Option<T> {\n     position_between(v, start, end, f).map(|i| v[*i])\n }\n@@ -1097,7 +1097,7 @@ pub pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n  * `f` returns true then an option containing the element is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pub pure fn rfind<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n+pub pure fn rfind<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n@@ -1108,13 +1108,13 @@ pub pure fn rfind<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the element is returned. If `f` matches no elements then none is return.\n  */\n-pub pure fn rfind_between<T: Copy>(v: &[T], start: uint, end: uint,\n+pub pure fn rfind_between<T:Copy>(v: &[T], start: uint, end: uint,\n                                f: fn(t: &T) -> bool) -> Option<T> {\n     rposition_between(v, start, end, f).map(|i| v[*i])\n }\n \n /// Find the first index containing a matching value\n-pub pure fn position_elem<T: Eq>(v: &[T], x: &T) -> Option<uint> {\n+pub pure fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n     position(v, |y| *x == *y)\n }\n \n@@ -1146,7 +1146,7 @@ pub pure fn position_between<T>(v: &[T], start: uint, end: uint,\n }\n \n /// Find the last index containing a matching value\n-pure fn rposition_elem<T: Eq>(v: &[T], x: &T) -> Option<uint> {\n+pure fn rposition_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n     rposition(v, |y| *x == *y)\n }\n \n@@ -1188,7 +1188,7 @@ pub pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n /**\n  * Convert a vector of pairs into a pair of vectors, by reference. As unzip().\n  */\n-pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n+pure fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     for each(v) |p| {\n         let (t, u) = *p;\n@@ -1223,7 +1223,7 @@ pub pure fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n /**\n  * Convert two vectors to a vector of pairs, by reference. As zip().\n  */\n-pub pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n+pub pure fn zip_slice<T:Copy,U:Copy>(v: &[const T], u: &[const U])\n         -> ~[(T, U)] {\n     let mut zipped = ~[];\n     let sz = len(v);\n@@ -1274,7 +1274,7 @@ pub fn reverse<T>(v: &mut [T]) {\n }\n \n /// Returns a vector with the order of elements reversed\n-pub pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n+pub pure fn reversed<T:Copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n     if i == 0 { return (rs); } else { i -= 1; }\n@@ -1440,7 +1440,7 @@ pub fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n  */\n-pure fn each_permutation<T: Copy>(v: &[T], put: fn(ts: &[T]) -> bool) {\n+pure fn each_permutation<T:Copy>(v: &[T], put: fn(ts: &[T]) -> bool) {\n     let ln = len(v);\n     if ln <= 1 {\n         put(v);\n@@ -1464,7 +1464,7 @@ pure fn each_permutation<T: Copy>(v: &[T], put: fn(ts: &[T]) -> bool) {\n     }\n }\n \n-pub pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n+pub pure fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n     assert 1u <= nn;\n     for vec::eachi (xx) |ii, _x| {\n@@ -1531,7 +1531,7 @@ pub pure fn as_mut_buf<T,U>(s: &mut [T],\n \n // Equality\n \n-pure fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n+pure fn eq<T:Eq>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     if a_len != b_len { return false; }\n \n@@ -1545,7 +1545,7 @@ pure fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n }\n \n #[cfg(notest)]\n-impl<T: Eq> Eq for &[T] {\n+impl<T:Eq> Eq for &[T] {\n     #[inline(always)]\n     pure fn eq(&self, other: & &self/[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n@@ -1554,15 +1554,15 @@ impl<T: Eq> Eq for &[T] {\n \n \n #[cfg(notest)]\n-impl<T: Eq> Eq for ~[T] {\n+impl<T:Eq> Eq for ~[T] {\n     #[inline(always)]\n     pure fn eq(&self, other: &~[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n     pure fn ne(&self, other: &~[T]) -> bool { !(*self).eq(other) }\n }\n \n #[cfg(notest)]\n-impl<T: Eq> Eq for @[T] {\n+impl<T:Eq> Eq for @[T] {\n     #[inline(always)]\n     pure fn eq(&self, other: &@[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n@@ -1571,7 +1571,7 @@ impl<T: Eq> Eq for @[T] {\n \n // Lexicographical comparison\n \n-pure fn lt<T: Ord>(a: &[T], b: &[T]) -> bool {\n+pure fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     let mut end = uint::min(a_len, b_len);\n \n@@ -1586,12 +1586,12 @@ pure fn lt<T: Ord>(a: &[T], b: &[T]) -> bool {\n     return a_len < b_len;\n }\n \n-pure fn le<T: Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n-pure fn ge<T: Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n-pure fn gt<T: Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n+pure fn le<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(b, a) }\n+pure fn ge<T:Ord>(a: &[T], b: &[T]) -> bool { !lt(a, b) }\n+pure fn gt<T:Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n #[cfg(notest)]\n-impl<T: Ord> Ord for &[T] {\n+impl<T:Ord> Ord for &[T] {\n     #[inline(always)]\n     pure fn lt(&self, other: & &self/[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n@@ -1603,7 +1603,7 @@ impl<T: Ord> Ord for &[T] {\n }\n \n #[cfg(notest)]\n-impl<T: Ord> Ord for ~[T] {\n+impl<T:Ord> Ord for ~[T] {\n     #[inline(always)]\n     pure fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n@@ -1615,7 +1615,7 @@ impl<T: Ord> Ord for ~[T] {\n }\n \n #[cfg(notest)]\n-impl<T: Ord> Ord for @[T] {\n+impl<T:Ord> Ord for @[T] {\n     #[inline(always)]\n     pure fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n@@ -1632,7 +1632,7 @@ pub mod traits {\n     use ops::Add;\n     use vec::append;\n \n-    impl<T: Copy> Add<&[const T],~[T]> for ~[T] {\n+    impl<T:Copy> Add<&[const T],~[T]> for ~[T] {\n         #[inline(always)]\n         pure fn add(&self, rhs: & &self/[const T]) -> ~[T] {\n             append(copy *self, (*rhs))\n@@ -1659,7 +1659,7 @@ pub trait CopyableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<T: Copy> CopyableVector<T> for &[const T] {\n+impl<T:Copy> CopyableVector<T> for &[const T] {\n     /// Returns the first element of a vector\n     #[inline]\n     pure fn head(&self) -> T { head(*self) }\n@@ -1685,13 +1685,13 @@ impl<T: Copy> CopyableVector<T> for &[const T] {\n \n pub trait ImmutableVector<T> {\n     pure fn view(&self, start: uint, end: uint) -> &self/[T];\n-    pure fn foldr<U: Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U;\n+    pure fn foldr<U:Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U;\n     pure fn map<U>(&self, f: fn(t: &T) -> U) -> ~[U];\n     pure fn mapi<U>(&self, f: fn(uint, t: &T) -> U) -> ~[U];\n     fn map_r<U>(&self, f: fn(x: &T) -> U) -> ~[U];\n     pure fn alli(&self, f: fn(uint, t: &T) -> bool) -> bool;\n     pure fn flat_map<U>(&self, f: fn(t: &T) -> ~[U]) -> ~[U];\n-    pure fn filter_mapped<U: Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U];\n+    pure fn filter_mapped<U:Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U];\n }\n \n /// Extension methods for vectors\n@@ -1704,7 +1704,7 @@ impl<T> ImmutableVector<T> for &[T] {\n \n     /// Reduce a vector from right to left\n     #[inline]\n-    pure fn foldr<U: Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U {\n+    pure fn foldr<U:Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U {\n         foldr(*self, z, p)\n     }\n \n@@ -1754,19 +1754,19 @@ impl<T> ImmutableVector<T> for &[T] {\n      * the resulting vector.\n      */\n     #[inline]\n-    pure fn filter_mapped<U: Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U] {\n+    pure fn filter_mapped<U:Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U] {\n         filter_mapped(*self, f)\n     }\n }\n \n-pub trait ImmutableEqVector<T: Eq> {\n+pub trait ImmutableEqVector<T:Eq> {\n     pure fn position(&self, f: fn(t: &T) -> bool) -> Option<uint>;\n     pure fn position_elem(&self, t: &T) -> Option<uint>;\n     pure fn rposition(&self, f: fn(t: &T) -> bool) -> Option<uint>;\n     pure fn rposition_elem(&self, t: &T) -> Option<uint>;\n }\n \n-impl<T: Eq> ImmutableEqVector<T> for &[T] {\n+impl<T:Eq> ImmutableEqVector<T> for &[T] {\n     /**\n      * Find the first index matching some predicate\n      *\n@@ -1811,7 +1811,7 @@ pub trait ImmutableCopyableVector<T> {\n }\n \n /// Extension methods for vectors\n-impl<T: Copy> ImmutableCopyableVector<T> for &[T] {\n+impl<T:Copy> ImmutableCopyableVector<T> for &[T] {\n     /**\n      * Construct a new vector from the elements of a vector for which some\n      * predicate holds.\n@@ -1944,13 +1944,13 @@ impl<T> Mutable for ~[T] {\n     fn clear(&mut self) { self.truncate(0) }\n }\n \n-pub trait OwnedCopyableVector<T: Copy> {\n+pub trait OwnedCopyableVector<T:Copy> {\n     fn push_all(&mut self, rhs: &[const T]);\n     fn grow(&mut self, n: uint, initval: &T);\n     fn grow_set(&mut self, index: uint, initval: &T, val: T);\n }\n \n-impl<T: Copy> OwnedCopyableVector<T> for ~[T] {\n+impl<T:Copy> OwnedCopyableVector<T> for ~[T] {\n     #[inline]\n     fn push_all(&mut self, rhs: &[const T]) {\n         push_all(self, rhs);\n@@ -1967,11 +1967,11 @@ impl<T: Copy> OwnedCopyableVector<T> for ~[T] {\n     }\n }\n \n-trait OwnedEqVector<T: Eq> {\n+trait OwnedEqVector<T:Eq> {\n     fn dedup(&mut self);\n }\n \n-impl<T: Eq> OwnedEqVector<T> for ~[T] {\n+impl<T:Eq> OwnedEqVector<T> for ~[T] {\n     #[inline]\n     fn dedup(&mut self) {\n         dedup(self)\n@@ -2081,7 +2081,7 @@ pub mod raw {\n      * Unchecked vector indexing.\n      */\n     #[inline(always)]\n-    pub unsafe fn get<T: Copy>(v: &[const T], i: uint) -> T {\n+    pub unsafe fn get<T:Copy>(v: &[const T], i: uint) -> T {\n         as_const_buf(v, |p, _len| *ptr::const_offset(p, i))\n     }\n \n@@ -2319,24 +2319,24 @@ impl<A> iter::ExtendedIter<A> for @[A] {\n     }\n }\n \n-impl<A: Eq> iter::EqIter<A> for &[A] {\n+impl<A:Eq> iter::EqIter<A> for &[A] {\n     pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n     pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A: Eq> iter::EqIter<A> for ~[A] {\n+impl<A:Eq> iter::EqIter<A> for ~[A] {\n     pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n     pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A: Eq> iter::EqIter<A> for @[A] {\n+impl<A:Eq> iter::EqIter<A> for @[A] {\n     pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n     pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n-impl<A: Copy> iter::CopyableIter<A> for &[A] {\n+impl<A:Copy> iter::CopyableIter<A> for &[A] {\n     pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n@@ -2347,7 +2347,7 @@ impl<A: Copy> iter::CopyableIter<A> for &[A] {\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A: Copy> iter::CopyableIter<A> for ~[A] {\n+impl<A:Copy> iter::CopyableIter<A> for ~[A] {\n     pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n@@ -2358,7 +2358,7 @@ impl<A: Copy> iter::CopyableIter<A> for ~[A] {\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A: Copy> iter::CopyableIter<A> for @[A] {\n+impl<A:Copy> iter::CopyableIter<A> for @[A] {\n     pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n@@ -2368,19 +2368,19 @@ impl<A: Copy> iter::CopyableIter<A> for @[A] {\n     }\n }\n \n-impl<A: Copy Ord> iter::CopyableOrderedIter<A> for &[A] {\n+impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for &[A] {\n     pure fn min(&self) -> A { iter::min(self) }\n     pure fn max(&self) -> A { iter::max(self) }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A: Copy Ord> iter::CopyableOrderedIter<A> for ~[A] {\n+impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for ~[A] {\n     pure fn min(&self) -> A { iter::min(self) }\n     pure fn max(&self) -> A { iter::max(self) }\n }\n \n // FIXME(#4148): This should be redundant\n-impl<A: Copy Ord> iter::CopyableOrderedIter<A> for @[A] {\n+impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for @[A] {\n     pure fn min(&self) -> A { iter::min(self) }\n     pure fn max(&self) -> A { iter::max(self) }\n }"}, {"sha": "7288b6d261d2c605686f38bd0f3ffb0d3727203a", "filename": "src/libfuzzer/cycles.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibfuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibfuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fcycles.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -18,7 +18,7 @@ fn under(r : rand::rng, n : uint) -> uint {\n }\n \n // random choice from a vec\n-fn choice<T: copy>(r : rand::rng, v : ~[const T]) -> T {\n+fn choice<T:copy>(r : rand::rng, v : ~[const T]) -> T {\n     assert vec::len(v) != 0u; v[under(r, vec::len(v))]\n }\n "}, {"sha": "25dc14c3d788881832833f1ae9c8183e0c0d9425", "filename": "src/libfuzzer/ivec_fuzz.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibfuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibfuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fivec_fuzz.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -32,22 +32,22 @@ extern mod std;\n use vec::slice;\n use vec::len;\n \n-fn vec_omit<T: copy>(v: ~[T], i: uint) -> ~[T] {\n+fn vec_omit<T:copy>(v: ~[T], i: uint) -> ~[T] {\n     slice(v, 0u, i) + slice(v, i + 1u, len(v))\n }\n-fn vec_dup<T: copy>(v: ~[T], i: uint) -> ~[T] {\n+fn vec_dup<T:copy>(v: ~[T], i: uint) -> ~[T] {\n     slice(v, 0u, i) + [v[i]] + slice(v, i, len(v))\n }\n-fn vec_swadj<T: copy>(v: ~[T], i: uint) -> ~[T] {\n+fn vec_swadj<T:copy>(v: ~[T], i: uint) -> ~[T] {\n     slice(v, 0u, i) + [v[i + 1u], v[i]] + slice(v, i + 2u, len(v))\n }\n-fn vec_prefix<T: copy>(v: ~[T], i: uint) -> ~[T] { slice(v, 0u, i) }\n-fn vec_suffix<T: copy>(v: ~[T], i: uint) -> ~[T] { slice(v, i, len(v)) }\n+fn vec_prefix<T:copy>(v: ~[T], i: uint) -> ~[T] { slice(v, 0u, i) }\n+fn vec_suffix<T:copy>(v: ~[T], i: uint) -> ~[T] { slice(v, i, len(v)) }\n \n-fn vec_poke<T: copy>(v: ~[T], i: uint, x: T) -> ~[T] {\n+fn vec_poke<T:copy>(v: ~[T], i: uint, x: T) -> ~[T] {\n     slice(v, 0u, i) + ~[x] + slice(v, i + 1u, len(v))\n }\n-fn vec_insert<T: copy>(v: ~[T], i: uint, x: T) -> ~[T] {\n+fn vec_insert<T:copy>(v: ~[T], i: uint, x: T) -> ~[T] {\n     slice(v, 0u, i) + ~[x] + slice(v, i, len(v))\n }\n \n@@ -59,7 +59,7 @@ fn ix(skip_low: uint, skip_high: uint, length: uint, it: block(uint)) {\n \n // Returns a bunch of modified versions of v, some of which introduce\n // new elements (borrowed from xs).\n-fn vec_edits<T: copy>(v: ~[T], xs: ~[T]) -> ~[~[T]] {\n+fn vec_edits<T:copy>(v: ~[T], xs: ~[T]) -> ~[~[T]] {\n     let edits: ~[~[T]] = ~[];\n     let Lv: uint = len(v);\n "}, {"sha": "507d0666da0297a0d77ad6a3a4fd68ff081f8dbf", "filename": "src/libfuzzer/rand_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibfuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibfuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Frand_util.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -17,7 +17,7 @@ fn under(r : rand::rng, n : uint) -> uint {\n }\n \n // random choice from a vec\n-fn choice<T: copy>(r : rand::rng, v : ~[T]) -> T {\n+fn choice<T:copy>(r : rand::rng, v : ~[T]) -> T {\n     assert vec::len(v) != 0u; v[under(r, vec::len(v))]\n }\n \n@@ -35,7 +35,7 @@ fn shuffle<T>(r : rand::rng, &v : ~[T]) {\n }\n \n // create a shuffled copy of a vec\n-fn shuffled<T: copy>(r : rand::rng, v : ~[T]) -> ~[T] {\n+fn shuffled<T:copy>(r : rand::rng, v : ~[T]) -> ~[T] {\n     let w = vec::to_mut(v);\n     shuffle(r, w);\n     vec::from_mut(w) // Shouldn't this happen automatically?\n@@ -48,7 +48,7 @@ fn shuffled<T: copy>(r : rand::rng, v : ~[T]) -> ~[T] {\n // * weighted_choice is O(number of choices) time\n // * weighted_vec is O(total weight) space\n type weighted<T> = { weight: uint, item: T };\n-fn weighted_choice<T: copy>(r : rand::rng, v : ~[weighted<T>]) -> T {\n+fn weighted_choice<T:copy>(r : rand::rng, v : ~[weighted<T>]) -> T {\n     assert vec::len(v) != 0u;\n     let total = 0u;\n     for {weight: weight, item: _} in v {\n@@ -66,7 +66,7 @@ fn weighted_choice<T: copy>(r : rand::rng, v : ~[weighted<T>]) -> T {\n     core::unreachable();\n }\n \n-fn weighted_vec<T: copy>(v : ~[weighted<T>]) -> ~[T] {\n+fn weighted_vec<T:copy>(v : ~[weighted<T>]) -> ~[T] {\n     let r = ~[];\n     for {weight: weight, item: item} in v {\n         let i = 0u;"}, {"sha": "c783e1d616132e8acb004dfb33e4c3679664aaf1", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -294,7 +294,7 @@ pub fn basic_options() -> @options {\n }\n \n // Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T: Copy>(sess: Session,\n+pub fn expect<T:Copy>(sess: Session,\n                        opt: Option<T>,\n                        msg: fn() -> ~str)\n                     -> T {"}, {"sha": "51b25854bc751ee5cf46eba55eaaf1120b85daae", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -37,7 +37,7 @@ fn use_core(crate: @ast::crate) -> bool {\n \n fn inject_libcore_ref(sess: Session,\n                       crate: @ast::crate) -> @ast::crate {\n-    fn spanned<T: Copy>(x: T) -> codemap::spanned<T> {\n+    fn spanned<T:Copy>(x: T) -> codemap::spanned<T> {\n         codemap::spanned { node: x, span: dummy_sp() }\n     }\n "}, {"sha": "757c6233ba44419c1048f89b0a36891ca4efdcf7", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -335,7 +335,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n     return @item;\n }\n \n-fn nospan<T: Copy>(t: T) -> codemap::spanned<T> {\n+fn nospan<T:Copy>(t: T) -> codemap::spanned<T> {\n     codemap::spanned { node: t, span: dummy_sp() }\n }\n "}, {"sha": "86b07abffc2e995c9309fd1be9e9060caaa3a4d3", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -969,7 +969,7 @@ fn encode_info_for_items(ecx: @EncodeContext, ebml_w: writer::Encoder,\n \n // Path and definition ID indexing\n \n-fn create_index<T: Copy Hash IterBytes>(index: ~[entry<T>]) ->\n+fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n    ~[@~[entry<T>]] {\n     let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n     for uint::range(0u, 256u) |_i| { buckets.push(@mut ~[]); };"}, {"sha": "2175d0f074c60da596c0d85c7a568595345198a4", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -78,7 +78,7 @@ pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n     } as FileSearch\n }\n \n-pub fn search<T: Copy>(filesearch: FileSearch, pick: pick<T>) -> Option<T> {\n+pub fn search<T:Copy>(filesearch: FileSearch, pick: pick<T>) -> Option<T> {\n     let mut rslt = None;\n     for filesearch.lib_search_paths().each |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());"}, {"sha": "71de59391edba3ee7c577e422295e422c469b833", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -248,7 +248,7 @@ trait def_id_encoder_helpers {\n     fn emit_def_id(did: ast::def_id);\n }\n \n-impl<S: serialize::Encoder> def_id_encoder_helpers for S {\n+impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n     fn emit_def_id(did: ast::def_id) {\n         did.encode(&self)\n     }\n@@ -258,7 +258,7 @@ trait def_id_decoder_helpers {\n     fn read_def_id(xcx: @ExtendedDecodeContext) -> ast::def_id;\n }\n \n-impl<D: serialize::Decoder> def_id_decoder_helpers for D {\n+impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n \n     fn read_def_id(xcx: @ExtendedDecodeContext) -> ast::def_id {\n         let did: ast::def_id = Decodable::decode(&self);\n@@ -1276,14 +1276,14 @@ fn test_more() {\n fn test_simplification() {\n     let ext_cx = mk_ctxt();\n     let item_in = ast::ii_item(quote_item!(\n-        fn new_int_alist<B: Copy>() -> alist<int, B> {\n+        fn new_int_alist<B:Copy>() -> alist<int, B> {\n             fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n             return {eq_fn: eq_int, data: ~[]};\n         }\n     ).get());\n     let item_out = simplify_ast(item_in);\n     let item_exp = ast::ii_item(quote_item!(\n-        fn new_int_alist<B: Copy>() -> alist<int, B> {\n+        fn new_int_alist<B:Copy>() -> alist<int, B> {\n             return {eq_fn: eq_int, data: ~[]};\n         }\n     ).get());"}, {"sha": "568bc5b5e70f60c167b1b2a918aabe1969d8b6e1", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -491,7 +491,7 @@ pub impl BorrowckCtxt {\n         cat_def(self.tcx, self.method_map, id, span, ty, def)\n     }\n \n-    fn cat_variant<N: ast_node>(&self,\n+    fn cat_variant<N:ast_node>(&self,\n                                 arg: N,\n                                 enum_did: ast::def_id,\n                                 cmt: cmt) -> cmt {"}, {"sha": "a88f478dd4b7e4a7f416d34c013e16b9f5c1a359", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -526,7 +526,7 @@ fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n }\n \n fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n-    pure fn is_valid<T: cmp::Ord>(binop: ast::binop, v: T,\n+    pure fn is_valid<T:cmp::Ord>(binop: ast::binop, v: T,\n             min: T, max: T) -> bool {\n         match binop {\n             ast::lt => v <= max,"}, {"sha": "0621beb43a3d5a8f17fc9e41f01b8ac40d06308f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -263,7 +263,7 @@ pub fn cat_def(\n     return mcx.cat_def(expr_id, expr_span, expr_ty, def);\n }\n \n-pub fn cat_variant<N: ast_node>(\n+pub fn cat_variant<N:ast_node>(\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     arg: N,\n@@ -292,11 +292,11 @@ pub impl ast_node for @ast::pat {\n }\n \n pub trait get_type_for_node {\n-    fn ty<N: ast_node>(node: N) -> ty::t;\n+    fn ty<N:ast_node>(node: N) -> ty::t;\n }\n \n pub impl get_type_for_node for ty::ctxt {\n-    fn ty<N: ast_node>(node: N) -> ty::t {\n+    fn ty<N:ast_node>(node: N) -> ty::t {\n         ty::node_id_to_type(self, node.id())\n     }\n }\n@@ -575,7 +575,7 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_variant<N: ast_node>(&self,\n+    fn cat_variant<N:ast_node>(&self,\n                                 arg: N,\n                                 enum_did: ast::def_id,\n                                 cmt: cmt) -> cmt {\n@@ -589,7 +589,7 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_rvalue<N: ast_node>(&self, elt: N, expr_ty: ty::t) -> cmt {\n+    fn cat_rvalue<N:ast_node>(&self, elt: N, expr_ty: ty::t) -> cmt {\n         @cmt_ {\n             id:elt.id(),\n             span:elt.span(),\n@@ -739,7 +739,7 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_index<N: ast_node>(&self,\n+    fn cat_index<N:ast_node>(&self,\n                               elt: N,\n                               base_cmt: cmt) -> cmt {\n         let mt = match ty::index(self.tcx, base_cmt.ty) {\n@@ -792,7 +792,7 @@ pub impl mem_categorization_ctxt {\n           }\n         };\n \n-        fn comp<N: ast_node>(elt: N, of_cmt: cmt,\n+        fn comp<N:ast_node>(elt: N, of_cmt: cmt,\n                              vect: ty::t, mutbl: MutabilityCategory,\n                              mt: ty::mt) -> cmt\n         {\n@@ -809,7 +809,7 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_tuple_elt<N: ast_node>(&self,\n+    fn cat_tuple_elt<N:ast_node>(&self,\n                                   elt: N,\n                                   cmt: cmt) -> cmt {\n         @cmt_ {\n@@ -822,7 +822,7 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_anon_struct_field<N: ast_node>(&self,\n+    fn cat_anon_struct_field<N:ast_node>(&self,\n                                           elt: N,\n                                           cmt: cmt) -> cmt {\n         @cmt_ {"}, {"sha": "606f7ce7259399eb031a61485d588c1d807c0033", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -170,7 +170,7 @@ enum debug_metadata {\n     retval_metadata(@Metadata<RetvalMetadata>),\n }\n \n-fn cast_safely<T: Copy, U>(val: T) -> U {\n+fn cast_safely<T:Copy,U>(val: T) -> U {\n     unsafe {\n         let val2 = val;\n         return cast::transmute(val2);\n@@ -192,7 +192,7 @@ fn md_from_metadata<T>(val: debug_metadata) -> T {\n     }\n }\n \n-fn cached_metadata<T: Copy>(cache: metadata_cache,\n+fn cached_metadata<T:Copy>(cache: metadata_cache,\n                             mdtag: int,\n                             eq_fn: fn(md: T) -> bool)\n                          -> Option<T> {"}, {"sha": "413ec9fcdf389d9b3bc2d6505b7d4f636b8a0a01", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -775,7 +775,7 @@ fn mk_rcache() -> creader_cache {\n     return oldmap::HashMap();\n }\n \n-pub fn new_ty_hash<V: Copy>() -> oldmap::HashMap<t, V> {\n+pub fn new_ty_hash<V:Copy>() -> oldmap::HashMap<t, V> {\n     oldmap::HashMap()\n }\n \n@@ -3326,7 +3326,7 @@ pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n \n // Maintains a little union-set tree for inferred modes.  `canon()` returns\n // the current head value for `m0`.\n-fn canon<T:Copy cmp::Eq>(tbl: HashMap<ast::node_id, ast::inferable<T>>,\n+fn canon<T:Copy + cmp::Eq>(tbl: HashMap<ast::node_id, ast::inferable<T>>,\n                          +m0: ast::inferable<T>) -> ast::inferable<T> {\n     match m0 {\n       ast::infer(id) => match tbl.find(&id) {"}, {"sha": "9269752b8ecf412a0f70a41039037ef4671f6204", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -94,7 +94,7 @@ pub fn get_region_reporting_err(tcx: ty::ctxt,\n     }\n }\n \n-pub fn ast_region_to_region<AC: AstConv, RS: region_scope Copy Durable>(\n+pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: @mut AC,\n         rscope: RS,\n         span: span,\n@@ -110,7 +110,7 @@ pub fn ast_region_to_region<AC: AstConv, RS: region_scope Copy Durable>(\n     get_region_reporting_err(self.tcx(), span, res)\n }\n \n-pub fn ast_path_to_substs_and_ty<AC: AstConv, RS: region_scope Copy Durable>(\n+pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: @mut AC,\n         rscope: RS,\n         did: ast::def_id,\n@@ -166,7 +166,7 @@ pub fn ast_path_to_substs_and_ty<AC: AstConv, RS: region_scope Copy Durable>(\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n-pub fn ast_path_to_ty<AC: AstConv, RS: region_scope Copy Durable>(\n+pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: @mut AC,\n         rscope: RS,\n         did: ast::def_id,\n@@ -192,10 +192,10 @@ pub const NO_TPS: uint = 2;\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n-pub fn ast_ty_to_ty<AC: AstConv, RS: region_scope Copy Durable>(\n+pub fn ast_ty_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n     self: @mut AC, rscope: RS, &&ast_ty: @ast::Ty) -> ty::t {\n \n-    fn ast_mt_to_mt<AC: AstConv, RS: region_scope Copy Durable>(\n+    fn ast_mt_to_mt<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: @mut AC, rscope: RS, mt: ast::mt) -> ty::mt {\n \n         ty::mt {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl}\n@@ -204,7 +204,7 @@ pub fn ast_ty_to_ty<AC: AstConv, RS: region_scope Copy Durable>(\n     // Handle @, ~, and & being able to mean estrs and evecs.\n     // If a_seq_ty is a str or a vec, make it an estr/evec.\n     // Also handle function sigils and first-class trait types.\n-    fn mk_pointer<AC: AstConv, RS: region_scope Copy Durable>(\n+    fn mk_pointer<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: @mut AC,\n         rscope: RS,\n         a_seq_ty: ast::mt,\n@@ -420,7 +420,7 @@ pub fn ast_ty_to_ty<AC: AstConv, RS: region_scope Copy Durable>(\n     return typ;\n }\n \n-pub fn ty_of_arg<AC: AstConv, RS: region_scope Copy Durable>(\n+pub fn ty_of_arg<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: @mut AC,\n         rscope: RS,\n         a: ast::arg,\n@@ -468,7 +468,7 @@ pub fn ty_of_arg<AC: AstConv, RS: region_scope Copy Durable>(\n     arg {mode: mode, ty: ty}\n }\n \n-pub fn ty_of_bare_fn<AC: AstConv, RS: region_scope Copy Durable>(\n+pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: @mut AC,\n         rscope: RS,\n         purity: ast::purity,\n@@ -494,7 +494,7 @@ pub fn ty_of_bare_fn<AC: AstConv, RS: region_scope Copy Durable>(\n     }\n }\n \n-pub fn ty_of_closure<AC: AstConv, RS: region_scope Copy Durable>(\n+pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: @mut AC,\n         rscope: RS,\n         sigil: ast::Sigil,"}, {"sha": "3553caf5c33f79add29b217c1d7fb0a371eb0bcf", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -1590,7 +1590,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // through the `unpack` function.  It there is no expected type or\n     // resolution is not possible (e.g., no constraints yet present), just\n     // returns `none`.\n-    fn unpack_expected<O: Copy>(fcx: @mut FnCtxt,\n+    fn unpack_expected<O:Copy>(fcx: @mut FnCtxt,\n                                 expected: Option<ty::t>,\n                                 unpack: fn(&ty::sty) -> Option<O>)\n                              -> Option<O> {"}, {"sha": "96c76b52181c13732d385870a9156d95dc528ebf", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -115,7 +115,7 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n }\n \n pub impl @mut CrateCtxt {\n-    fn to_ty<RS: region_scope Copy Durable>(rs: RS, ast_ty: @ast::Ty)\n+    fn to_ty<RS:region_scope + Copy + Durable>(rs: RS, ast_ty: @ast::Ty)\n                                          -> ty::t {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }"}, {"sha": "34068a5eb0d431eabbe83d529a677d04d69e9b84", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -290,7 +290,7 @@ pub fn super_self_tys<C:Combine>(\n     }\n }\n \n-pub fn super_sigils<C: Combine>(\n+pub fn super_sigils<C:Combine>(\n     self: &C, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n     if p1 == p2 {\n         Ok(p1)"}, {"sha": "3998967dc984246a1d52be1f72cd436a035d7d7a", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -173,7 +173,7 @@ pub impl CombineFields {\n             b_id, a_bounds, b_bounds, node_b.rank)\n     }\n \n-    fn merge_bnd<T:Copy InferStr LatticeValue>(\n+    fn merge_bnd<T:Copy + InferStr + LatticeValue>(\n         &self,\n         a: &Bound<T>,\n         b: &Bound<T>,\n@@ -263,7 +263,7 @@ pub impl CombineFields {\n         uok()\n     }\n \n-    fn bnds<T:Copy InferStr LatticeValue>(\n+    fn bnds<T:Copy + InferStr + LatticeValue>(\n         &self,\n         a: &Bound<T>,\n         b: &Bound<T>) -> ures\n@@ -329,7 +329,7 @@ pub impl TyLatticeDir for Glb {\n     }\n }\n \n-pub fn super_lattice_tys<L:LatticeDir TyLatticeDir Combine>(\n+pub fn super_lattice_tys<L:LatticeDir + TyLatticeDir + Combine>(\n     self: &L,\n     a: ty::t,\n     b: ty::t) -> cres<ty::t> {\n@@ -485,7 +485,7 @@ pub fn lattice_var_and_t<L:LatticeDir Combine,\n // Random utility functions used by LUB/GLB when computing LUB/GLB of\n // fn types\n \n-pub fn var_ids<T: Combine>(self: &T, isr: isr_alist) -> ~[RegionVid] {\n+pub fn var_ids<T:Combine>(self: &T, isr: isr_alist) -> ~[RegionVid] {\n     let mut result = ~[];\n     for list::each(isr) |pair| {\n         match pair.second() {"}, {"sha": "7d799b7ea2fb6c6de5bf774d2efdf69b0010496d", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -351,7 +351,7 @@ pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n     }\n }\n \n-fn new_ValsAndBindings<V:Copy, T:Copy>() -> ValsAndBindings<V, T> {\n+fn new_ValsAndBindings<V:Copy,T:Copy>() -> ValsAndBindings<V, T> {\n     ValsAndBindings {\n         vals: oldsmallintmap::mk(),\n         bindings: ~[]\n@@ -517,7 +517,7 @@ trait CresCompare<T> {\n     fn compare(t: T, f: fn() -> ty::type_err) -> cres<T>;\n }\n \n-impl<T:Copy Eq> CresCompare<T> for cres<T> {\n+impl<T:Copy + Eq> CresCompare<T> for cres<T> {\n     fn compare(t: T, f: fn() -> ty::type_err) -> cres<T> {\n         do self.chain |s| {\n             if s == t {\n@@ -533,7 +533,7 @@ pub fn uok() -> ures {\n     Ok(())\n }\n \n-fn rollback_to<V:Copy Vid, T:Copy>(\n+fn rollback_to<V:Copy + Vid,T:Copy>(\n     vb: &mut ValsAndBindings<V, T>,\n     len: uint)\n {\n@@ -632,7 +632,7 @@ impl @mut InferCtxt {\n     }\n }\n \n-fn next_simple_var<V: Copy,T: Copy>(\n+fn next_simple_var<V:Copy,T:Copy>(\n         +counter: &mut uint,\n         +bindings: &mut ValsAndBindings<V,Option<T>>)\n      -> uint {"}, {"sha": "0013b417f7a31d66130a14bfe6a2b7f79fb70a1d", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -71,7 +71,7 @@ pub impl<T:InferStr> InferStr for Bounds<T> {\n     }\n }\n \n-pub impl<V:Vid ToStr, T:InferStr> InferStr for VarValue<V, T> {\n+pub impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         match *self {\n           Redirect(ref vid) => fmt!(\"Redirect(%s)\", vid.to_str()),"}, {"sha": "6abf2e5709b1c7dc38d353cb4d46daeb34e02ed9", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -89,7 +89,7 @@ pub impl InferCtxt {\n         }\n     }\n \n-    fn set<T:Copy InferStr, V:Copy Vid ToStr UnifyVid<T>>(\n+    fn set<T:Copy + InferStr,V:Copy + Vid + ToStr + UnifyVid<T>>(\n             &mut self,\n             +vid: V,\n             +new_v: VarValue<V, T>) {\n@@ -109,7 +109,7 @@ pub impl InferCtxt {\n         }\n     }\n \n-    fn unify<T:Copy InferStr, V:Copy Vid ToStr UnifyVid<T>>(\n+    fn unify<T:Copy + InferStr,V:Copy + Vid + ToStr + UnifyVid<T>>(\n         &mut self,\n         node_a: &Node<V, T>,\n         node_b: &Node<V, T>) -> (V, uint)\n@@ -150,7 +150,7 @@ pub trait SimplyUnifiable {\n     static fn to_type_err(expected_found<Self>) -> ty::type_err;\n }\n \n-pub fn mk_err<T: SimplyUnifiable>(+a_is_expected: bool,\n+pub fn mk_err<T:SimplyUnifiable>(+a_is_expected: bool,\n                                   +a_t: T,\n                                   +b_t: T) -> ures {\n     if a_is_expected {"}, {"sha": "05820bed0d036edd6dad3a6d02bc3f3237a7030d", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -157,7 +157,7 @@ pub enum vtable_origin {\n     vtable_static(ast::def_id, ~[ty::t], vtable_res),\n     /*\n       Dynamic vtable, comes from a parameter that has a bound on it:\n-      fn foo<T: quux, baz, bar>(a: T) -- a's vtable would have a\n+      fn foo<T:quux,baz,bar>(a: T) -- a's vtable would have a\n       vtable_param origin\n \n       The first uint is the param number (identifying T in the example),"}, {"sha": "d5834af3a574adfcc40f15cd8770bb84b0153d1a", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -69,9 +69,10 @@ pub fn bound_self_region(rp: Option<ty::region_variance>)\n }\n \n pub struct anon_rscope { anon: ty::Region, base: region_scope }\n-pub fn in_anon_rscope<RS: region_scope Copy Durable>(self: RS, r: ty::Region)\n-    -> @anon_rscope {\n-    @anon_rscope { anon: r, base: self as region_scope }\n+pub fn in_anon_rscope<RS:region_scope + Copy + Durable>(self: RS,\n+                                                        r: ty::Region)\n+                                                     -> @anon_rscope {\n+    @anon_rscope {anon: r, base: self as region_scope}\n }\n pub impl region_scope for @anon_rscope {\n     pure fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n@@ -91,7 +92,7 @@ pub struct binding_rscope {\n     anon_bindings: uint,\n }\n \n-pub fn in_binding_rscope<RS: region_scope Copy Durable>(self: RS)\n+pub fn in_binding_rscope<RS:region_scope + Copy + Durable>(self: RS)\n     -> @mut binding_rscope {\n     let base = self as region_scope;\n     @mut binding_rscope { base: base, anon_bindings: 0 }"}, {"sha": "d03af547af094c02384f58cd1a1f30c39004856e", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -35,7 +35,7 @@ pub struct Fold<T> {\n     fold_struct: FoldStruct<T>\n }\n \n-impl<T: Clone> Clone for Fold<T> {\n+impl<T:Clone> Clone for Fold<T> {\n     fn clone(&self) -> Fold<T> {\n         Fold {\n             ctxt: self.ctxt.clone(),\n@@ -103,7 +103,7 @@ fn mk_fold<T>(\n     }\n }\n \n-pub fn default_any_fold<T: Clone>(ctxt: T) -> Fold<T> {\n+pub fn default_any_fold<T:Clone>(ctxt: T) -> Fold<T> {\n     mk_fold(\n         ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -121,7 +121,7 @@ pub fn default_any_fold<T: Clone>(ctxt: T) -> Fold<T> {\n     )\n }\n \n-pub fn default_seq_fold<T: Clone>(ctxt: T) -> Fold<T> {\n+pub fn default_seq_fold<T:Clone>(ctxt: T) -> Fold<T> {\n     mk_fold(\n         ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -139,7 +139,7 @@ pub fn default_seq_fold<T: Clone>(ctxt: T) -> Fold<T> {\n     )\n }\n \n-pub fn default_par_fold<T: Clone>(ctxt: T) -> Fold<T> {\n+pub fn default_par_fold<T:Clone>(ctxt: T) -> Fold<T> {\n     mk_fold(\n         ctxt,\n         |f, d| default_seq_fold_doc(f, d),"}, {"sha": "61c02bf684938de032f9a39d6c6e1da53bcf1b3e", "filename": "src/librustdoc/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustdoc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibrustdoc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Futil.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -17,6 +17,6 @@ pub struct NominalOp<T> {\n     op: T\n }\n \n-impl<T: Copy> Clone for NominalOp<T> {\n+impl<T:Copy> Clone for NominalOp<T> {\n     fn clone(&self) -> NominalOp<T> { copy *self }\n }"}, {"sha": "50f40559807ab36b71f215097cb58ce11753db9b", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -80,15 +80,15 @@ impl &Condvar {\n struct ARC<T> { x: SharedMutableState<T> }\n \n /// Create an atomically reference counted wrapper.\n-pub fn ARC<T: Const Owned>(data: T) -> ARC<T> {\n+pub fn ARC<T:Const + Owned>(data: T) -> ARC<T> {\n     ARC { x: unsafe { shared_mutable_state(data) } }\n }\n \n /**\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-pub fn get<T: Const Owned>(rc: &a/ARC<T>) -> &a/T {\n+pub fn get<T:Const + Owned>(rc: &a/ARC<T>) -> &a/T {\n     unsafe { get_shared_immutable_state(&rc.x) }\n }\n \n@@ -99,7 +99,7 @@ pub fn get<T: Const Owned>(rc: &a/ARC<T>) -> &a/T {\n  * object. However, one of the `arc` objects can be sent to another task,\n  * allowing them to share the underlying data.\n  */\n-pub fn clone<T: Const Owned>(rc: &ARC<T>) -> ARC<T> {\n+pub fn clone<T:Const + Owned>(rc: &ARC<T>) -> ARC<T> {\n     ARC { x: unsafe { clone_shared_mutable_state(&rc.x) } }\n }\n \n@@ -112,12 +112,12 @@ pub fn clone<T: Const Owned>(rc: &ARC<T>) -> ARC<T> {\n  * unwrap from a task that holds another reference to the same ARC; it is\n  * guaranteed to deadlock.\n  */\n-pub fn unwrap<T: Const Owned>(rc: ARC<T>) -> T {\n+pub fn unwrap<T:Const + Owned>(rc: ARC<T>) -> T {\n     let ARC { x: x } = rc;\n     unsafe { unwrap_shared_mutable_state(x) }\n }\n \n-impl<T: Const Owned> Clone for ARC<T> {\n+impl<T:Const + Owned> Clone for ARC<T> {\n     fn clone(&self) -> ARC<T> {\n         clone(self)\n     }\n@@ -133,22 +133,22 @@ struct MutexARCInner<T> { lock: Mutex, failed: bool, data: T }\n struct MutexARC<T> { x: SharedMutableState<MutexARCInner<T>> }\n \n /// Create a mutex-protected ARC with the supplied data.\n-pub fn MutexARC<T: Owned>(user_data: T) -> MutexARC<T> {\n+pub fn MutexARC<T:Owned>(user_data: T) -> MutexARC<T> {\n     mutex_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a mutex-protected ARC with the supplied data and a specified number\n  * of condvars (as sync::mutex_with_condvars).\n  */\n-pub fn mutex_arc_with_condvars<T: Owned>(user_data: T,\n+pub fn mutex_arc_with_condvars<T:Owned>(user_data: T,\n                                     num_condvars: uint) -> MutexARC<T> {\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n                           failed: false, data: user_data };\n     MutexARC { x: unsafe { shared_mutable_state(data) } }\n }\n \n-impl<T: Owned> Clone for MutexARC<T> {\n+impl<T:Owned> Clone for MutexARC<T> {\n     /// Duplicate a mutex-protected ARC, as arc::clone.\n     fn clone(&self) -> MutexARC<T> {\n         // NB: Cloning the underlying mutex is not necessary. Its reference\n@@ -157,7 +157,7 @@ impl<T: Owned> Clone for MutexARC<T> {\n     }\n }\n \n-impl<T: Owned> &MutexARC<T> {\n+impl<T:Owned> &MutexARC<T> {\n \n     /**\n      * Access the underlying mutable data with mutual exclusion from other\n@@ -219,7 +219,7 @@ impl<T: Owned> &MutexARC<T> {\n  * Will additionally fail if another task has failed while accessing the arc.\n  */\n // FIXME(#3724) make this a by-move method on the arc\n-pub fn unwrap_mutex_arc<T: Owned>(arc: MutexARC<T>) -> T {\n+pub fn unwrap_mutex_arc<T:Owned>(arc: MutexARC<T>) -> T {\n     let MutexARC { x: x } = arc;\n     let inner = unsafe { unwrap_shared_mutable_state(x) };\n     let MutexARCInner { failed: failed, data: data, _ } = inner;\n@@ -283,14 +283,14 @@ struct RWARC<T> {\n }\n \n /// Create a reader/writer ARC with the supplied data.\n-pub fn RWARC<T: Const Owned>(user_data: T) -> RWARC<T> {\n+pub fn RWARC<T:Const + Owned>(user_data: T) -> RWARC<T> {\n     rw_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a reader/writer ARC with the supplied data and a specified number\n  * of condvars (as sync::rwlock_with_condvars).\n  */\n-pub fn rw_arc_with_condvars<T: Const Owned>(\n+pub fn rw_arc_with_condvars<T:Const + Owned>(\n     user_data: T,\n     num_condvars: uint) -> RWARC<T>\n {\n@@ -300,7 +300,7 @@ pub fn rw_arc_with_condvars<T: Const Owned>(\n     RWARC { x: unsafe { shared_mutable_state(data) }, cant_nest: () }\n }\n \n-impl<T: Const Owned> RWARC<T> {\n+impl<T:Const + Owned> RWARC<T> {\n     /// Duplicate a rwlock-protected ARC, as arc::clone.\n     fn clone(&self) -> RWARC<T> {\n         RWARC { x: unsafe { clone_shared_mutable_state(&self.x) },\n@@ -309,7 +309,7 @@ impl<T: Const Owned> RWARC<T> {\n \n }\n \n-impl<T: Const Owned> &RWARC<T> {\n+impl<T:Const + Owned> &RWARC<T> {\n     /**\n      * Access the underlying data mutably. Locks the rwlock in write mode;\n      * other readers and writers will block.\n@@ -418,7 +418,7 @@ impl<T: Const Owned> &RWARC<T> {\n  * in write mode.\n  */\n // FIXME(#3724) make this a by-move method on the arc\n-pub fn unwrap_rw_arc<T: Const Owned>(arc: RWARC<T>) -> T {\n+pub fn unwrap_rw_arc<T:Const + Owned>(arc: RWARC<T>) -> T {\n     let RWARC { x: x, _ } = arc;\n     let inner = unsafe { unwrap_shared_mutable_state(x) };\n     let RWARCInner { failed: failed, data: data, _ } = inner;\n@@ -432,7 +432,7 @@ pub fn unwrap_rw_arc<T: Const Owned>(arc: RWARC<T>) -> T {\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n-fn borrow_rwlock<T: Const Owned>(state: *const RWARCInner<T>) -> *RWlock {\n+fn borrow_rwlock<T:Const + Owned>(state: *const RWARCInner<T>) -> *RWlock {\n     unsafe { cast::transmute(&const (*state).lock) }\n }\n \n@@ -444,7 +444,7 @@ pub enum RWWriteMode<T> =\n /// The \"read permission\" token used for RWARC.write_downgrade().\n pub enum RWReadMode<T> = (&T, sync::RWlockReadMode);\n \n-impl<T: Const Owned> &RWWriteMode<T> {\n+impl<T:Const + Owned> &RWWriteMode<T> {\n     /// Access the pre-downgrade RWARC in write mode.\n     fn write<U>(blk: fn(x: &mut T) -> U) -> U {\n         match *self {\n@@ -474,7 +474,7 @@ impl<T: Const Owned> &RWWriteMode<T> {\n     }\n }\n \n-impl<T: Const Owned> &RWReadMode<T> {\n+impl<T:Const + Owned> &RWReadMode<T> {\n     /// Access the post-downgrade rwlock in read mode.\n     fn read<U>(blk: fn(x: &T) -> U) -> U {\n         match *self {"}, {"sha": "5af596c1f84e41fdfc43bc84c00f8e0bd45e01ae", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -120,7 +120,7 @@ pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n  *\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n-pub fn get<T: Copy>(t: CVec<T>, ofs: uint) -> T {\n+pub fn get<T:Copy>(t: CVec<T>, ofs: uint) -> T {\n     assert ofs < len(t);\n     return unsafe { *ptr::mut_offset(t.base, ofs) };\n }\n@@ -130,7 +130,7 @@ pub fn get<T: Copy>(t: CVec<T>, ofs: uint) -> T {\n  *\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n-pub fn set<T: Copy>(t: CVec<T>, ofs: uint, v: T) {\n+pub fn set<T:Copy>(t: CVec<T>, ofs: uint, v: T) {\n     assert ofs < len(t);\n     unsafe { *ptr::mut_offset(t.base, ofs) = v };\n }"}, {"sha": "9478a39279673cc21a120d62f2d110d39f90d16d", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -25,19 +25,19 @@ pub struct DuplexStream<T, U> {\n     priv port: Port<U>,\n }\n \n-impl<T: Owned, U: Owned> GenericChan<T> for DuplexStream<T, U> {\n+impl<T:Owned,U:Owned> GenericChan<T> for DuplexStream<T, U> {\n     fn send(x: T) {\n         self.chan.send(x)\n     }\n }\n \n-impl<T: Owned, U: Owned> GenericSmartChan<T> for DuplexStream<T, U> {\n+impl<T:Owned,U:Owned> GenericSmartChan<T> for DuplexStream<T, U> {\n     fn try_send(x: T) -> bool {\n         self.chan.try_send(x)\n     }\n }\n \n-impl<T: Owned, U: Owned> GenericPort<U> for DuplexStream<T, U> {\n+impl<T:Owned,U:Owned> GenericPort<U> for DuplexStream<T, U> {\n     fn recv() -> U {\n         self.port.recv()\n     }\n@@ -47,20 +47,20 @@ impl<T: Owned, U: Owned> GenericPort<U> for DuplexStream<T, U> {\n     }\n }\n \n-impl<T: Owned, U: Owned> Peekable<U> for DuplexStream<T, U> {\n+impl<T:Owned,U:Owned> Peekable<U> for DuplexStream<T, U> {\n     pure fn peek() -> bool {\n         self.port.peek()\n     }\n }\n \n-impl<T: Owned, U: Owned> Selectable for DuplexStream<T, U> {\n+impl<T:Owned,U:Owned> Selectable for DuplexStream<T, U> {\n     pure fn header() -> *pipes::PacketHeader {\n         self.port.header()\n     }\n }\n \n /// Creates a bidirectional stream.\n-pub fn DuplexStream<T: Owned, U: Owned>()\n+pub fn DuplexStream<T:Owned,U:Owned>()\n     -> (DuplexStream<T, U>, DuplexStream<U, T>)\n {\n     let (p1, c2) = pipes::stream();"}, {"sha": "0ac76cefd6b36480cb47cbcbfce86e08b3f0f8e0", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -198,7 +198,7 @@ mod tests {\n         assert *deq.get(3) == d;\n     }\n \n-    fn test_parameterized<T: Copy Eq Durable>(a: T, b: T, c: T, d: T) {\n+    fn test_parameterized<T:Copy + Eq + Durable>(a: T, b: T, c: T, d: T) {\n         let mut deq = Deque::new();\n         assert deq.len() == 0;\n         deq.add_front(a);"}, {"sha": "f97e5ee6800671777500e18e654fdfe96d5b2a62", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -129,7 +129,7 @@ pub mod serial {\n     }\n \n     /// Create a `FlatPort` from a `Port<~[u8]>`\n-    pub fn pipe_port<T: Decodable<DefaultDecoder>>(\n+    pub fn pipe_port<T:Decodable<DefaultDecoder>>(\n         port: Port<~[u8]>\n     ) -> PipePort<T> {\n         let unflat: DeserializingUnflattener<DefaultDecoder, T> =\n@@ -140,7 +140,7 @@ pub mod serial {\n     }\n \n     /// Create a `FlatChan` from a `Chan<~[u8]>`\n-    pub fn pipe_chan<T: Encodable<DefaultEncoder>>(\n+    pub fn pipe_chan<T:Encodable<DefaultEncoder>>(\n         chan: Chan<~[u8]>\n     ) -> PipeChan<T> {\n         let flat: SerializingFlattener<DefaultEncoder, T> =\n@@ -189,7 +189,7 @@ pub mod pod {\n     pub type PipeChan<T> = FlatChan<T, PodFlattener<T>, PipeByteChan>;\n \n     /// Create a `FlatPort` from a `Reader`\n-    pub fn reader_port<T: Copy Owned, R: Reader>(\n+    pub fn reader_port<T:Copy + Owned,R:Reader>(\n         reader: R\n     ) -> ReaderPort<T, R> {\n         let unflat: PodUnflattener<T> = PodUnflattener::new();\n@@ -198,7 +198,7 @@ pub mod pod {\n     }\n \n     /// Create a `FlatChan` from a `Writer`\n-    pub fn writer_chan<T: Copy Owned, W: Writer>(\n+    pub fn writer_chan<T:Copy + Owned,W:Writer>(\n         writer: W\n     ) -> WriterChan<T, W> {\n         let flat: PodFlattener<T> = PodFlattener::new();\n@@ -207,21 +207,21 @@ pub mod pod {\n     }\n \n     /// Create a `FlatPort` from a `Port<~[u8]>`\n-    pub fn pipe_port<T: Copy Owned>(port: Port<~[u8]>) -> PipePort<T> {\n+    pub fn pipe_port<T:Copy + Owned>(port: Port<~[u8]>) -> PipePort<T> {\n         let unflat: PodUnflattener<T> = PodUnflattener::new();\n         let byte_port = PipeBytePort::new(port);\n         FlatPort::new(unflat, byte_port)\n     }\n \n     /// Create a `FlatChan` from a `Chan<~[u8]>`\n-    pub fn pipe_chan<T: Copy Owned>(chan: Chan<~[u8]>) -> PipeChan<T> {\n+    pub fn pipe_chan<T:Copy + Owned>(chan: Chan<~[u8]>) -> PipeChan<T> {\n         let flat: PodFlattener<T> = PodFlattener::new();\n         let byte_chan = PipeByteChan::new(chan);\n         FlatChan::new(flat, byte_chan)\n     }\n \n     /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n-    pub fn pipe_stream<T: Copy Owned>() -> (PipePort<T>, PipeChan<T>) {\n+    pub fn pipe_stream<T:Copy + Owned>() -> (PipePort<T>, PipeChan<T>) {\n         let (port, chan) = pipes::stream();\n         return (pipe_port(port), pipe_chan(chan));\n     }\n@@ -358,7 +358,7 @@ pub mod flatteners {\n         bogus: ()\n     }\n \n-    pub impl<T: Copy Owned> Unflattener<T> for PodUnflattener<T> {\n+    pub impl<T:Copy + Owned> Unflattener<T> for PodUnflattener<T> {\n         fn unflatten(&self, buf: ~[u8]) -> T {\n             assert size_of::<T>() != 0;\n             assert size_of::<T>() == buf.len();\n@@ -368,7 +368,7 @@ pub mod flatteners {\n         }\n     }\n \n-    pub impl<T: Copy Owned> Flattener<T> for PodFlattener<T> {\n+    pub impl<T:Copy + Owned> Flattener<T> for PodFlattener<T> {\n         fn flatten(&self, val: T) -> ~[u8] {\n             assert size_of::<T>() != 0;\n             let val: *T = ptr::to_unsafe_ptr(&val);\n@@ -377,15 +377,15 @@ pub mod flatteners {\n         }\n     }\n \n-    pub impl<T: Copy Owned> PodUnflattener<T> {\n+    pub impl<T:Copy + Owned> PodUnflattener<T> {\n         static fn new() -> PodUnflattener<T> {\n             PodUnflattener {\n                 bogus: ()\n             }\n         }\n     }\n \n-    pub impl<T: Copy Owned> PodFlattener<T> {\n+    pub impl<T:Copy + Owned> PodFlattener<T> {\n         static fn new() -> PodFlattener<T> {\n             PodFlattener {\n                 bogus: ()\n@@ -406,21 +406,21 @@ pub mod flatteners {\n         serialize_value: SerializeValue<T>\n     }\n \n-    pub impl<D: Decoder, T: Decodable<D>> Unflattener<T>\n+    pub impl<D:Decoder,T:Decodable<D>> Unflattener<T>\n             for DeserializingUnflattener<D, T> {\n         fn unflatten(&self, buf: ~[u8]) -> T {\n             (self.deserialize_buffer)(buf)\n         }\n     }\n \n-    pub impl<S: Encoder, T: Encodable<S>> Flattener<T>\n+    pub impl<S:Encoder,T:Encodable<S>> Flattener<T>\n             for SerializingFlattener<S, T> {\n         fn flatten(&self, val: T) -> ~[u8] {\n             (self.serialize_value)(&val)\n         }\n     }\n \n-    pub impl<D: Decoder, T: Decodable<D>> DeserializingUnflattener<D, T> {\n+    pub impl<D:Decoder,T:Decodable<D>> DeserializingUnflattener<D, T> {\n         static fn new(deserialize_buffer: DeserializeBuffer<T>)\n                    -> DeserializingUnflattener<D, T> {\n             DeserializingUnflattener {\n@@ -429,7 +429,7 @@ pub mod flatteners {\n         }\n     }\n \n-    pub impl<S: Encoder, T: Encodable<S>> SerializingFlattener<S, T> {\n+    pub impl<S:Encoder,T:Encodable<S>> SerializingFlattener<S, T> {\n         static fn new(serialize_value: SerializeValue<T>)\n                    -> SerializingFlattener<S, T> {\n             SerializingFlattener {\n@@ -519,7 +519,7 @@ pub mod bytepipes {\n         writer: W\n     }\n \n-    pub impl<R: Reader> BytePort for ReaderBytePort<R> {\n+    pub impl<R:Reader> BytePort for ReaderBytePort<R> {\n         fn try_recv(&self, count: uint) -> Option<~[u8]> {\n             let mut left = count;\n             let mut bytes = ~[];\n@@ -541,21 +541,21 @@ pub mod bytepipes {\n         }\n     }\n \n-    pub impl<W: Writer> ByteChan for WriterByteChan<W> {\n+    pub impl<W:Writer> ByteChan for WriterByteChan<W> {\n         fn send(&self, val: ~[u8]) {\n             self.writer.write(val);\n         }\n     }\n \n-    pub impl<R: Reader> ReaderBytePort<R> {\n+    pub impl<R:Reader> ReaderBytePort<R> {\n         static fn new(r: R) -> ReaderBytePort<R> {\n             ReaderBytePort {\n                 reader: r\n             }\n         }\n     }\n \n-    pub impl<W: Writer> WriterByteChan<W> {\n+    pub impl<W:Writer> WriterByteChan<W> {\n         static fn new(w: W) -> WriterByteChan<W> {\n             WriterByteChan {\n                 writer: w\n@@ -765,7 +765,7 @@ mod test {\n     type WriterChanFactory<F> =\n         ~fn(TcpSocketBuf) -> FlatChan<int, F, WriterByteChan<TcpSocketBuf>>;\n \n-    fn test_some_tcp_stream<U: Unflattener<int>, F: Flattener<int>>(\n+    fn test_some_tcp_stream<U:Unflattener<int>,F:Flattener<int>>(\n         reader_port: ReaderPortFactory<U>,\n         writer_chan: WriterChanFactory<F>,\n         port: uint) {\n@@ -901,7 +901,7 @@ mod test {\n             pod::pipe_port(port)\n         }\n \n-        fn test_try_recv_none1<P: BytePort>(loader: PortLoader<P>) {\n+        fn test_try_recv_none1<P:BytePort>(loader: PortLoader<P>) {\n             let bytes = ~[];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n@@ -917,7 +917,7 @@ mod test {\n             test_try_recv_none1(pipe_port_loader);\n         }\n \n-        fn test_try_recv_none2<P: BytePort>(loader: PortLoader<P>) {\n+        fn test_try_recv_none2<P:BytePort>(loader: PortLoader<P>) {\n             // The control word in the protocol is interrupted\n             let bytes = ~[0];\n             let port = loader(bytes);\n@@ -934,7 +934,7 @@ mod test {\n             test_try_recv_none2(pipe_port_loader);\n         }\n \n-        fn test_try_recv_none3<P: BytePort>(loader: PortLoader<P>) {\n+        fn test_try_recv_none3<P:BytePort>(loader: PortLoader<P>) {\n             const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n             // The control word is followed by garbage\n             let bytes = CONTINUE.to_vec() + ~[0];\n@@ -952,7 +952,7 @@ mod test {\n             test_try_recv_none3(pipe_port_loader);\n         }\n \n-        fn test_try_recv_none4<P: BytePort>(+loader: PortLoader<P>) {\n+        fn test_try_recv_none4<P:BytePort>(+loader: PortLoader<P>) {\n             assert do task::try || {\n                 const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n                 // The control word is followed by a valid length,"}, {"sha": "0729987958a06cd5a0f5f5a9d8af821a6330a547", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -34,7 +34,7 @@ enum TreeNode<K, V> {\n pub fn init<K, V>() -> Treemap<K, V> { @Empty }\n \n /// Insert a value into the map\n-pub fn insert<K: Copy Eq Ord, V: Copy>(m: Treemap<K, V>, k: K, v: V)\n+pub fn insert<K:Copy + Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K, v: V)\n   -> Treemap<K, V> {\n     @match m {\n        @Empty => Node(@k, @v, @Empty, @Empty),\n@@ -49,7 +49,7 @@ pub fn insert<K: Copy Eq Ord, V: Copy>(m: Treemap<K, V>, k: K, v: V)\n }\n \n /// Find a value based on the key\n-pub fn find<K: Eq Ord, V: Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n+pub fn find<K:Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n     match *m {\n       Empty => None,\n       Node(@ref kk, @copy v, left, right) => {"}, {"sha": "8d0daa323ad7c9250a8437f6ded4831da4772891", "filename": "src/libstd/json.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -323,7 +323,7 @@ pub impl serialize::Encoder for PrettyEncoder {\n     }\n }\n \n-pub impl<S: serialize::Encoder> serialize::Encodable<S> for Json {\n+pub impl<S:serialize::Encoder> serialize::Encodable<S> for Json {\n     fn encode(&self, s: &S) {\n         match *self {\n             Number(v) => v.encode(s),\n@@ -1150,7 +1150,7 @@ impl ToJson for @~str {\n     fn to_json() -> Json { String(copy *self) }\n }\n \n-impl<A: ToJson, B: ToJson> ToJson for (A, B) {\n+impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n     fn to_json() -> Json {\n         match self {\n           (ref a, ref b) => {\n@@ -1160,7 +1160,7 @@ impl<A: ToJson, B: ToJson> ToJson for (A, B) {\n     }\n }\n \n-impl<A: ToJson, B: ToJson, C: ToJson> ToJson for (A, B, C) {\n+impl<A:ToJson,B:ToJson,C:ToJson> ToJson for (A, B, C) {\n     fn to_json() -> Json {\n         match self {\n           (ref a, ref b, ref c) => {\n@@ -1170,11 +1170,11 @@ impl<A: ToJson, B: ToJson, C: ToJson> ToJson for (A, B, C) {\n     }\n }\n \n-impl<A: ToJson> ToJson for ~[A] {\n+impl<A:ToJson> ToJson for ~[A] {\n     fn to_json() -> Json { List(self.map(|elt| elt.to_json())) }\n }\n \n-impl<A: ToJson Copy> ToJson for LinearMap<~str, A> {\n+impl<A:ToJson + Copy> ToJson for LinearMap<~str, A> {\n     fn to_json() -> Json {\n         let mut d = LinearMap::new();\n         for self.each |&(key, value)| {\n@@ -1184,7 +1184,7 @@ impl<A: ToJson Copy> ToJson for LinearMap<~str, A> {\n     }\n }\n \n-impl<A: ToJson> ToJson for Option<A> {\n+impl<A:ToJson> ToJson for Option<A> {\n     fn to_json() -> Json {\n         match self {\n           None => Null,\n@@ -1282,13 +1282,13 @@ mod tests {\n \n     // two fns copied from libsyntax/util/testing.rs.\n     // Should they be in their own crate?\n-    pub pure fn check_equal_ptr<T : cmp::Eq> (given : &T, expected: &T) {\n+    pub pure fn check_equal_ptr<T:cmp::Eq> (given : &T, expected: &T) {\n         if !((given == expected) && (expected == given )) {\n             fail!(fmt!(\"given %?, expected %?\",given,expected));\n         }\n     }\n \n-    pub pure fn check_equal<T : cmp::Eq> (given : T, expected: T) {\n+    pub pure fn check_equal<T:cmp::Eq> (given : T, expected: T) {\n         if !((given == expected) && (expected == given )) {\n             fail!(fmt!(\"given %?, expected %?\",given,expected));\n         }"}, {"sha": "f6cbd9a099b6aed4efa59004fc9302333ea11efc", "filename": "src/libstd/list.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -23,7 +23,7 @@ pub enum List<T> {\n }\n \n /// Create a list from a vector\n-pub pure fn from_vec<T: Copy>(v: &[T]) -> @List<T> {\n+pub pure fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n     vec::foldr(v, @Nil::<T>, |h, t| @Cons(*h, t))\n }\n \n@@ -40,7 +40,7 @@ pub pure fn from_vec<T: Copy>(v: &[T]) -> @List<T> {\n  * * z - The initial value\n  * * f - The function to apply\n  */\n-pub fn foldl<T: Copy, U>(z: T, ls: @List<U>, f: fn(&T, &U) -> T) -> T {\n+pub fn foldl<T:Copy,U>(z: T, ls: @List<U>, f: fn(&T, &U) -> T) -> T {\n     let mut accum: T = z;\n     do iter(ls) |elt| { accum = f(&accum, elt);}\n     accum\n@@ -53,7 +53,7 @@ pub fn foldl<T: Copy, U>(z: T, ls: @List<U>, f: fn(&T, &U) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find<T: Copy>(ls: @List<T>, f: fn(&T) -> bool) -> Option<T> {\n+pub pure fn find<T:Copy>(ls: @List<T>, f: fn(&T) -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n@@ -67,15 +67,15 @@ pub pure fn find<T: Copy>(ls: @List<T>, f: fn(&T) -> bool) -> Option<T> {\n }\n \n /// Returns true if a list contains an element with the given value\n-pub fn has<T: Copy Eq>(ls: @List<T>, elt: T) -> bool {\n+pub fn has<T:Copy + Eq>(ls: @List<T>, elt: T) -> bool {\n     for each(ls) |e| {\n         if *e == elt { return true; }\n     }\n     return false;\n }\n \n /// Returns true if the list is empty\n-pub pure fn is_empty<T: Copy>(ls: @List<T>) -> bool {\n+pub pure fn is_empty<T:Copy>(ls: @List<T>) -> bool {\n     match *ls {\n         Nil => true,\n         _ => false\n@@ -90,15 +90,15 @@ pub pure fn len<T>(ls: @List<T>) -> uint {\n }\n \n /// Returns all but the first element of a list\n-pub pure fn tail<T: Copy>(ls: @List<T>) -> @List<T> {\n+pub pure fn tail<T:Copy>(ls: @List<T>) -> @List<T> {\n     match *ls {\n         Cons(_, tl) => return tl,\n         Nil => fail!(~\"list empty\")\n     }\n }\n \n /// Returns the first element of a list\n-pub pure fn head<T: Copy>(ls: @List<T>) -> T {\n+pub pure fn head<T:Copy>(ls: @List<T>) -> T {\n     match *ls {\n       Cons(copy hd, _) => hd,\n       // makes me sad\n@@ -107,7 +107,7 @@ pub pure fn head<T: Copy>(ls: @List<T>) -> T {\n }\n \n /// Appends one list to another\n-pub pure fn append<T: Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n+pub pure fn append<T:Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n     match *l {\n       Nil => return m,\n       Cons(copy x, xs) => {\n@@ -120,7 +120,7 @@ pub pure fn append<T: Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n /*\n /// Push one element into the front of a list, returning a new list\n /// THIS VERSION DOESN'T ACTUALLY WORK\n-pure fn push<T: Copy>(ll: &mut @list<T>, vv: T) {\n+pure fn push<T:Copy>(ll: &mut @list<T>, vv: T) {\n     ll = &mut @cons(vv, *ll)\n }\n */"}, {"sha": "53692cd3be5706bcfeffda5862935e065c866e33", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -76,7 +76,7 @@ pub mod chained {\n         FoundAfter(@Entry<K,V>, @Entry<K,V>)\n     }\n \n-    priv impl<K:Eq IterBytes Hash, V> T<K, V> {\n+    priv impl<K:Eq + IterBytes + Hash,V> T<K, V> {\n         pure fn search_rem(k: &K, h: uint, idx: uint,\n                            e_root: @Entry<K,V>) -> SearchResult<K,V> {\n             let mut e0 = e_root;\n@@ -156,19 +156,19 @@ pub mod chained {\n         }\n     }\n \n-    impl<K: Eq IterBytes Hash, V> Container for T<K, V> {\n+    impl<K:Eq + IterBytes + Hash,V> Container for T<K, V> {\n         pure fn len(&self) -> uint { self.count }\n         pure fn is_empty(&self) -> bool { self.count == 0 }\n     }\n \n-    impl<K: Eq IterBytes Hash, V> Mutable for T<K, V> {\n+    impl<K:Eq + IterBytes + Hash,V> Mutable for T<K, V> {\n         fn clear(&mut self) {\n             self.count = 0u;\n             self.chains = chains(initial_capacity);\n         }\n     }\n \n-    impl<K: Eq IterBytes Hash, V> T<K, V> {\n+    impl<K:Eq + IterBytes + Hash,V> T<K, V> {\n         pure fn contains_key(&self, k: &K) -> bool {\n             let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(k, hash) {\n@@ -252,7 +252,7 @@ pub mod chained {\n         }\n     }\n \n-    impl<K: Eq IterBytes Hash Copy, V: Copy> T<K, V> {\n+    impl<K:Eq + IterBytes + Hash + Copy,V:Copy> T<K, V> {\n         pure fn find(&self, k: &K) -> Option<V> {\n             match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n               NotFound => None,\n@@ -325,7 +325,7 @@ pub mod chained {\n         }\n     }\n \n-    impl<K:Eq IterBytes Hash Copy ToStr, V: ToStr Copy> T<K, V> {\n+    impl<K:Eq + IterBytes + Hash + Copy + ToStr,V:ToStr + Copy> T<K, V> {\n         fn to_writer(wr: io::Writer) {\n             if self.count == 0u {\n                 wr.write_str(~\"{}\");\n@@ -347,7 +347,8 @@ pub mod chained {\n         }\n     }\n \n-    impl<K:Eq IterBytes Hash Copy ToStr, V: ToStr Copy> ToStr for T<K, V> {\n+    impl<K:Eq + IterBytes + Hash + Copy + ToStr,V:ToStr + Copy> ToStr\n+            for T<K, V> {\n         pure fn to_str(&self) -> ~str {\n             unsafe {\n                 // Meh -- this should be safe\n@@ -356,7 +357,7 @@ pub mod chained {\n         }\n     }\n \n-    impl<K:Eq IterBytes Hash Copy, V: Copy> ops::Index<K, V> for T<K, V> {\n+    impl<K:Eq + IterBytes + Hash + Copy,V:Copy> ops::Index<K, V> for T<K, V> {\n         pure fn index(&self, k: K) -> V {\n             self.get(&k)\n         }\n@@ -366,7 +367,7 @@ pub mod chained {\n         vec::from_elem(nchains, None)\n     }\n \n-    pub fn mk<K:Eq IterBytes Hash, V: Copy>() -> T<K,V> {\n+    pub fn mk<K:Eq + IterBytes + Hash,V:Copy>() -> T<K,V> {\n         let slf: T<K, V> = @HashMap_ {count: 0u,\n                                       chains: chains(initial_capacity)};\n         slf\n@@ -378,18 +379,19 @@ Function: hashmap\n \n Construct a hashmap.\n */\n-pub fn HashMap<K:Eq IterBytes Hash Const, V: Copy>()\n+pub fn HashMap<K:Eq + IterBytes + Hash + Const,V:Copy>()\n         -> HashMap<K, V> {\n     chained::mk()\n }\n \n /// Convenience function for adding keys to a hashmap with nil type keys\n-pub fn set_add<K:Eq IterBytes Hash Const Copy>(set: Set<K>, key: K) -> bool {\n+pub fn set_add<K:Eq + IterBytes + Hash + Const + Copy>(set: Set<K>, key: K)\n+                                                    -> bool {\n     set.insert(key, ())\n }\n \n /// Convert a set into a vector.\n-pub pure fn vec_from_set<T:Eq IterBytes Hash Copy>(s: Set<T>) -> ~[T] {\n+pub pure fn vec_from_set<T:Eq + IterBytes + Hash + Copy>(s: Set<T>) -> ~[T] {\n     do vec::build_sized(s.len()) |push| {\n         for s.each_key() |&k| {\n             push(k);\n@@ -398,7 +400,7 @@ pub pure fn vec_from_set<T:Eq IterBytes Hash Copy>(s: Set<T>) -> ~[T] {\n }\n \n /// Construct a hashmap from a vector\n-pub fn hash_from_vec<K: Eq IterBytes Hash Const Copy, V: Copy>(\n+pub fn hash_from_vec<K:Eq + IterBytes + Hash + Const + Copy,V:Copy>(\n     items: &[(K, V)]) -> HashMap<K, V> {\n     let map = HashMap();\n     for vec::each(items) |item| {"}, {"sha": "a31309d7980dcde46e70257a1e70eccbcbc80956", "filename": "src/libstd/oldsmallintmap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Foldsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Foldsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldsmallintmap.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -32,7 +32,7 @@ pub enum SmallIntMap<T> {\n }\n \n /// Create a smallintmap\n-pub fn mk<T: Copy>() -> SmallIntMap<T> {\n+pub fn mk<T:Copy>() -> SmallIntMap<T> {\n     let v = DVec();\n     SmallIntMap_(@SmallIntMap_ { v: v } )\n }\n@@ -42,7 +42,7 @@ pub fn mk<T: Copy>() -> SmallIntMap<T> {\n  * the specified key then the original value is replaced.\n  */\n #[inline(always)]\n-pub fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, val: T) {\n+pub fn insert<T:Copy>(self: SmallIntMap<T>, key: uint, val: T) {\n     //io::println(fmt!(\"%?\", key));\n     self.v.grow_set_elt(key, &None, Some(val));\n }\n@@ -51,7 +51,7 @@ pub fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, val: T) {\n  * Get the value for the specified key. If the key does not exist\n  * in the map then returns none\n  */\n-pub pure fn find<T: Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n+pub pure fn find<T:Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n     if key < self.v.len() { return self.v.get_elt(key); }\n     return None::<T>;\n }\n@@ -63,7 +63,7 @@ pub pure fn find<T: Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n  *\n  * If the key does not exist in the map\n  */\n-pub pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n+pub pure fn get<T:Copy>(self: SmallIntMap<T>, key: uint) -> T {\n     match find(self, key) {\n       None => {\n         error!(\"smallintmap::get(): key not present\");\n@@ -74,7 +74,7 @@ pub pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n }\n \n /// Returns true if the map contains a value for the specified key\n-pub pure fn contains_key<T: Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n+pub pure fn contains_key<T:Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n     return !find(self, key).is_none();\n }\n \n@@ -100,7 +100,7 @@ impl<V> Mutable for SmallIntMap<V> {\n }\n \n /// Implements the map::map interface for smallintmap\n-impl<V: Copy> SmallIntMap<V> {\n+impl<V:Copy> SmallIntMap<V> {\n     #[inline(always)]\n     fn insert(key: uint, value: V) -> bool {\n         let exists = contains_key(self, key);\n@@ -162,7 +162,7 @@ impl<V: Copy> SmallIntMap<V> {\n     }\n }\n \n-impl<V: Copy> ops::Index<uint, V> for SmallIntMap<V> {\n+impl<V:Copy> ops::Index<uint, V> for SmallIntMap<V> {\n     pure fn index(&self, key: uint) -> V {\n         unsafe {\n             get(*self, key)"}, {"sha": "0839ce181235572b8604b16f3d20b9d29c9cfb3c", "filename": "src/libstd/par.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -34,7 +34,7 @@ const min_granularity : uint = 1024u;\n  * This is used to build most of the other parallel vector functions,\n  * like map or alli.\n  */\n-fn map_slices<A: Copy Owned, B: Copy Owned>(\n+fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n     xs: &[A],\n     f: &fn() -> ~fn(uint, v: &[A]) -> B)\n     -> ~[B] {\n@@ -90,7 +90,7 @@ fn map_slices<A: Copy Owned, B: Copy Owned>(\n }\n \n /// A parallel version of map.\n-pub fn map<A: Copy Owned, B: Copy Owned>(\n+pub fn map<A:Copy + Owned,B:Copy + Owned>(\n     xs: &[A], fn_factory: &fn() -> ~fn(&A) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n         let f = fn_factory();\n@@ -101,7 +101,7 @@ pub fn map<A: Copy Owned, B: Copy Owned>(\n }\n \n /// A parallel version of mapi.\n-pub fn mapi<A: Copy Owned, B: Copy Owned>(\n+pub fn mapi<A:Copy + Owned,B:Copy + Owned>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(uint, &A) -> B) -> ~[B]\n {\n@@ -120,7 +120,7 @@ pub fn mapi<A: Copy Owned, B: Copy Owned>(\n }\n \n /// Returns true if the function holds for all elements in the vector.\n-pub fn alli<A: Copy Owned>(\n+pub fn alli<A:Copy + Owned>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(uint, &A) -> bool) -> bool\n {\n@@ -135,7 +135,7 @@ pub fn alli<A: Copy Owned>(\n }\n \n /// Returns true if the function holds for any elements in the vector.\n-pub fn any<A: Copy Owned>(\n+pub fn any<A:Copy + Owned>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n     do vec::any(map_slices(xs, || {"}, {"sha": "f642bf52f659ab718930a6e093236ea71b105ec0", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -27,28 +27,28 @@ pub struct PriorityQueue<T> {\n     priv data: ~[T],\n }\n \n-impl<T: Ord> BaseIter<T> for PriorityQueue<T> {\n+impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n     /// Visit all values in the underlying vector.\n     ///\n     /// The values are **not** visited in order.\n     pure fn each(&self, f: fn(&T) -> bool) { self.data.each(f) }\n     pure fn size_hint(&self) -> Option<uint> { self.data.size_hint() }\n }\n \n-impl<T: Ord> Container for PriorityQueue<T> {\n+impl<T:Ord> Container for PriorityQueue<T> {\n     /// Returns the length of the queue\n     pure fn len(&self) -> uint { self.data.len() }\n \n     /// Returns true if a queue contains no elements\n     pure fn is_empty(&self) -> bool { self.data.is_empty() }\n }\n \n-impl<T: Ord> Mutable for PriorityQueue<T> {\n+impl<T:Ord> Mutable for PriorityQueue<T> {\n     /// Drop all items from the queue\n     fn clear(&mut self) { self.data.truncate(0) }\n }\n \n-impl <T: Ord> PriorityQueue<T> {\n+impl <T:Ord> PriorityQueue<T> {\n     /// Returns the greatest item in the queue - fails if empty\n     pure fn top(&self) -> &self/T { &self.data[0] }\n "}, {"sha": "5f96687127cad66d7baa8fd6ef0683cc534a67b5", "filename": "src/libstd/semver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -392,4 +392,4 @@ fn test_spec_order() {\n         assert a < b;\n         i += 1;\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3178e141097f9dc58e7b9d10013703e753141e1d", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -105,218 +105,218 @@ pub trait Decoder {\n     fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n }\n \n-pub trait Encodable<S: Encoder> {\n+pub trait Encodable<S:Encoder> {\n     fn encode(&self, s: &S);\n }\n \n-pub trait Decodable<D: Decoder> {\n+pub trait Decodable<D:Decoder> {\n     static fn decode(&self, d: &D) -> Self;\n }\n \n-pub impl<S: Encoder> Encodable<S> for uint {\n+pub impl<S:Encoder> Encodable<S> for uint {\n     fn encode(&self, s: &S) { s.emit_uint(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for uint {\n+pub impl<D:Decoder> Decodable<D> for uint {\n     static fn decode(&self, d: &D) -> uint {\n         d.read_uint()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for u8 {\n+pub impl<S:Encoder> Encodable<S> for u8 {\n     fn encode(&self, s: &S) { s.emit_u8(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for u8 {\n+pub impl<D:Decoder> Decodable<D> for u8 {\n     static fn decode(&self, d: &D) -> u8 {\n         d.read_u8()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for u16 {\n+pub impl<S:Encoder> Encodable<S> for u16 {\n     fn encode(&self, s: &S) { s.emit_u16(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for u16 {\n+pub impl<D:Decoder> Decodable<D> for u16 {\n     static fn decode(&self, d: &D) -> u16 {\n         d.read_u16()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for u32 {\n+pub impl<S:Encoder> Encodable<S> for u32 {\n     fn encode(&self, s: &S) { s.emit_u32(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for u32 {\n+pub impl<D:Decoder> Decodable<D> for u32 {\n     static fn decode(&self, d: &D) -> u32 {\n         d.read_u32()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for u64 {\n+pub impl<S:Encoder> Encodable<S> for u64 {\n     fn encode(&self, s: &S) { s.emit_u64(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for u64 {\n+pub impl<D:Decoder> Decodable<D> for u64 {\n     static fn decode(&self, d: &D) -> u64 {\n         d.read_u64()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for int {\n+pub impl<S:Encoder> Encodable<S> for int {\n     fn encode(&self, s: &S) { s.emit_int(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for int {\n+pub impl<D:Decoder> Decodable<D> for int {\n     static fn decode(&self, d: &D) -> int {\n         d.read_int()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for i8 {\n+pub impl<S:Encoder> Encodable<S> for i8 {\n     fn encode(&self, s: &S) { s.emit_i8(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for i8 {\n+pub impl<D:Decoder> Decodable<D> for i8 {\n     static fn decode(&self, d: &D) -> i8 {\n         d.read_i8()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for i16 {\n+pub impl<S:Encoder> Encodable<S> for i16 {\n     fn encode(&self, s: &S) { s.emit_i16(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for i16 {\n+pub impl<D:Decoder> Decodable<D> for i16 {\n     static fn decode(&self, d: &D) -> i16 {\n         d.read_i16()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for i32 {\n+pub impl<S:Encoder> Encodable<S> for i32 {\n     fn encode(&self, s: &S) { s.emit_i32(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for i32 {\n+pub impl<D:Decoder> Decodable<D> for i32 {\n     static fn decode(&self, d: &D) -> i32 {\n         d.read_i32()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for i64 {\n+pub impl<S:Encoder> Encodable<S> for i64 {\n     fn encode(&self, s: &S) { s.emit_i64(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for i64 {\n+pub impl<D:Decoder> Decodable<D> for i64 {\n     static fn decode(&self, d: &D) -> i64 {\n         d.read_i64()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for &str {\n+pub impl<S:Encoder> Encodable<S> for &str {\n     fn encode(&self, s: &S) { s.emit_borrowed_str(*self) }\n }\n \n-pub impl<S: Encoder> Encodable<S> for ~str {\n+pub impl<S:Encoder> Encodable<S> for ~str {\n     fn encode(&self, s: &S) { s.emit_owned_str(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for ~str {\n+pub impl<D:Decoder> Decodable<D> for ~str {\n     static fn decode(&self, d: &D) -> ~str {\n         d.read_owned_str()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for @str {\n+pub impl<S:Encoder> Encodable<S> for @str {\n     fn encode(&self, s: &S) { s.emit_managed_str(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for @str {\n+pub impl<D:Decoder> Decodable<D> for @str {\n     static fn decode(&self, d: &D) -> @str {\n         d.read_managed_str()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for float {\n+pub impl<S:Encoder> Encodable<S> for float {\n     fn encode(&self, s: &S) { s.emit_float(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for float {\n+pub impl<D:Decoder> Decodable<D> for float {\n     static fn decode(&self, d: &D) -> float {\n         d.read_float()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for f32 {\n+pub impl<S:Encoder> Encodable<S> for f32 {\n     fn encode(&self, s: &S) { s.emit_f32(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for f32 {\n+pub impl<D:Decoder> Decodable<D> for f32 {\n     static fn decode(&self, d: &D) -> f32 {\n         d.read_f32() }\n }\n \n-pub impl<S: Encoder> Encodable<S> for f64 {\n+pub impl<S:Encoder> Encodable<S> for f64 {\n     fn encode(&self, s: &S) { s.emit_f64(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for f64 {\n+pub impl<D:Decoder> Decodable<D> for f64 {\n     static fn decode(&self, d: &D) -> f64 {\n         d.read_f64()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for bool {\n+pub impl<S:Encoder> Encodable<S> for bool {\n     fn encode(&self, s: &S) { s.emit_bool(*self) }\n }\n \n-pub impl<D: Decoder> Decodable<D> for bool {\n+pub impl<D:Decoder> Decodable<D> for bool {\n     static fn decode(&self, d: &D) -> bool {\n         d.read_bool()\n     }\n }\n \n-pub impl<S: Encoder> Encodable<S> for () {\n+pub impl<S:Encoder> Encodable<S> for () {\n     fn encode(&self, s: &S) { s.emit_nil() }\n }\n \n-pub impl<D: Decoder> Decodable<D> for () {\n+pub impl<D:Decoder> Decodable<D> for () {\n     static fn decode(&self, d: &D) -> () {\n         d.read_nil()\n     }\n }\n \n-pub impl<S: Encoder, T: Encodable<S>> Encodable<S> for &T {\n+pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for &T {\n     fn encode(&self, s: &S) {\n         s.emit_borrowed(|| (**self).encode(s))\n     }\n }\n \n-pub impl<S: Encoder, T: Encodable<S>> Encodable<S> for ~T {\n+pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n     fn encode(&self, s: &S) {\n         s.emit_owned(|| (**self).encode(s))\n     }\n }\n \n-pub impl<D: Decoder, T: Decodable<D>> Decodable<D> for ~T {\n+pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n     static fn decode(&self, d: &D) -> ~T {\n         d.read_owned(|| ~Decodable::decode(d))\n     }\n }\n \n-pub impl<S: Encoder, T: Encodable<S>> Encodable<S> for @T {\n+pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n     fn encode(&self, s: &S) {\n         s.emit_managed(|| (**self).encode(s))\n     }\n }\n \n-pub impl<D: Decoder, T: Decodable<D>> Decodable<D> for @T {\n+pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n     static fn decode(&self, d: &D) -> @T {\n         d.read_managed(|| @Decodable::decode(d))\n     }\n }\n \n-pub impl<S: Encoder, T: Encodable<S>> Encodable<S> for &[T] {\n+pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for &[T] {\n     fn encode(&self, s: &S) {\n         do s.emit_borrowed_vec(self.len()) {\n             for self.eachi |i, e| {\n@@ -326,7 +326,7 @@ pub impl<S: Encoder, T: Encodable<S>> Encodable<S> for &[T] {\n     }\n }\n \n-pub impl<S: Encoder, T: Encodable<S>> Encodable<S> for ~[T] {\n+pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     fn encode(&self, s: &S) {\n         do s.emit_owned_vec(self.len()) {\n             for self.eachi |i, e| {\n@@ -336,7 +336,7 @@ pub impl<S: Encoder, T: Encodable<S>> Encodable<S> for ~[T] {\n     }\n }\n \n-pub impl<D: Decoder, T: Decodable<D>> Decodable<D> for ~[T] {\n+pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     static fn decode(&self, d: &D) -> ~[T] {\n         do d.read_owned_vec |len| {\n             do vec::from_fn(len) |i| {\n@@ -346,7 +346,7 @@ pub impl<D: Decoder, T: Decodable<D>> Decodable<D> for ~[T] {\n     }\n }\n \n-pub impl<S: Encoder, T: Encodable<S>> Encodable<S> for @[T] {\n+pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     fn encode(&self, s: &S) {\n         do s.emit_managed_vec(self.len()) {\n             for self.eachi |i, e| {\n@@ -356,7 +356,7 @@ pub impl<S: Encoder, T: Encodable<S>> Encodable<S> for @[T] {\n     }\n }\n \n-pub impl<D: Decoder, T: Decodable<D>> Decodable<D> for @[T] {\n+pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n     static fn decode(&self, d: &D) -> @[T] {\n         do d.read_managed_vec |len| {\n             do at_vec::from_fn(len) |i| {\n@@ -366,7 +366,7 @@ pub impl<D: Decoder, T: Decodable<D>> Decodable<D> for @[T] {\n     }\n }\n \n-pub impl<S: Encoder, T: Encodable<S>> Encodable<S> for Option<T> {\n+pub impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &S) {\n         do s.emit_enum(~\"option\") {\n             match *self {\n@@ -381,7 +381,7 @@ pub impl<S: Encoder, T: Encodable<S>> Encodable<S> for Option<T> {\n     }\n }\n \n-pub impl<D: Decoder, T: Decodable<D>> Decodable<D> for Option<T> {\n+pub impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n     static fn decode(&self, d: &D) -> Option<T> {\n         do d.read_enum(~\"option\") {\n             do d.read_enum_variant |i| {\n@@ -396,7 +396,7 @@ pub impl<D: Decoder, T: Decodable<D>> Decodable<D> for Option<T> {\n     }\n }\n \n-pub impl<S: Encoder, T0: Encodable<S>, T1: Encodable<S>> Encodable<S>\n+pub impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S>\n         for (T0, T1) {\n     fn encode(&self, s: &S) {\n         match *self {\n@@ -410,7 +410,7 @@ pub impl<S: Encoder, T0: Encodable<S>, T1: Encodable<S>> Encodable<S>\n     }\n }\n \n-pub impl<D: Decoder, T0: Decodable<D>, T1: Decodable<D>> Decodable<D>\n+pub impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D>\n         for (T0, T1) {\n     static fn decode(&self, d: &D) -> (T0, T1) {\n         do d.read_tup(2) {\n@@ -552,7 +552,7 @@ pub trait EncoderHelpers {\n     fn emit_from_vec<T>(&self, v: &[T], f: fn(v: &T));\n }\n \n-pub impl<S: Encoder> EncoderHelpers for S {\n+pub impl<S:Encoder> EncoderHelpers for S {\n     fn emit_from_vec<T>(&self, v: &[T], f: fn(v: &T)) {\n         do self.emit_owned_vec(v.len()) {\n             for v.eachi |i, e| {\n@@ -568,7 +568,7 @@ pub trait DecoderHelpers {\n     fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n }\n \n-pub impl<D: Decoder> DecoderHelpers for D {\n+pub impl<D:Decoder> DecoderHelpers for D {\n     fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n         do self.read_owned_vec |len| {\n             do vec::from_fn(len) |i| {"}, {"sha": "68d22f7c919a67f895ad45b91ad9db61e2ab17e2", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -131,7 +131,7 @@ pub impl<V> SmallIntMap<V> {\n     }\n }\n \n-pub impl<V: Copy> SmallIntMap<V> {\n+pub impl<V:Copy> SmallIntMap<V> {\n     fn update_with_key(&mut self, key: uint, val: V,\n                        ff: fn(uint, V, V) -> V) -> bool {\n         let new_val = match self.find(&key) {"}, {"sha": "d2515df3e1b4005f16831ea6a96af49453486dcf", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -25,12 +25,12 @@ type Le<T> = pure fn(v1: &T, v2: &T) -> bool;\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-pub pure fn merge_sort<T: Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n+pub pure fn merge_sort<T:Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n     unsafe {return merge_sort_(v, (0u, len(v)), le);}\n \n-    fn merge_sort_<T: Copy>(v: &[const T], slice: Slice, le: Le<T>)\n+    fn merge_sort_<T:Copy>(v: &[const T], slice: Slice, le: Le<T>)\n         -> ~[T] {\n         let begin = slice.first();\n         let end = slice.second();\n@@ -45,7 +45,7 @@ pub pure fn merge_sort<T: Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n         return merge(le, merge_sort_(v, a, le), merge_sort_(v, b, le));\n     }\n \n-    fn merge<T: Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n+    fn merge<T:Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n         let mut rs = vec::with_capacity(len(a) + len(b));\n         let a_len = len(a);\n         let mut a_ix = 0;\n@@ -103,7 +103,7 @@ pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n     qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n }\n \n-fn qsort3<T: Copy Ord Eq>(arr: &mut [T], left: int, right: int) {\n+fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n     if right <= left { return; }\n     let v: T = arr[right];\n     let mut i: int = left - 1;\n@@ -160,7 +160,7 @@ fn qsort3<T: Copy Ord Eq>(arr: &mut [T], left: int, right: int) {\n  *\n  * This is an unstable sort.\n  */\n-pub fn quick_sort3<T: Copy Ord Eq>(arr: &mut [T]) {\n+pub fn quick_sort3<T:Copy + Ord + Eq>(arr: &mut [T]) {\n     if arr.len() <= 1 { return; }\n     qsort3(arr, 0, (arr.len() - 1) as int);\n }\n@@ -169,15 +169,15 @@ pub trait Sort {\n     fn qsort(self);\n }\n \n-impl<T: Copy Ord Eq> Sort for &mut [T] {\n+impl<T:Copy + Ord + Eq> Sort for &mut [T] {\n     fn qsort(self) { quick_sort3(self); }\n }\n \n const MIN_MERGE: uint = 64;\n const MIN_GALLOP: uint = 7;\n const INITIAL_TMP_STORAGE: uint = 128;\n \n-pub fn tim_sort<T: Copy Ord>(array: &mut [T]) {\n+pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n     let size = array.len();\n     if size < 2 {\n         return;\n@@ -216,7 +216,7 @@ pub fn tim_sort<T: Copy Ord>(array: &mut [T]) {\n     ms.merge_force_collapse(array);\n }\n \n-fn binarysort<T: Copy Ord>(array: &mut [T], start: uint) {\n+fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n     let size = array.len();\n     let mut start = start;\n     assert start <= size;\n@@ -266,7 +266,7 @@ pure fn min_run_length(n: uint) -> uint {\n     return n + r;\n }\n \n-fn count_run_ascending<T: Copy Ord>(array: &mut [T]) -> uint {\n+fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n     let size = array.len();\n     assert size > 0;\n     if size == 1 { return 1; }\n@@ -286,7 +286,7 @@ fn count_run_ascending<T: Copy Ord>(array: &mut [T]) -> uint {\n     return run;\n }\n \n-pure fn gallop_left<T: Copy Ord>(key: &const T, array: &[const T],\n+pure fn gallop_left<T:Copy + Ord>(key: &const T, array: &[const T],\n                             hint: uint) -> uint {\n     let size = array.len();\n     assert size != 0 && hint < size;\n@@ -335,7 +335,7 @@ pure fn gallop_left<T: Copy Ord>(key: &const T, array: &[const T],\n     return ofs;\n }\n \n-pure fn gallop_right<T: Copy Ord>(key: &const T, array: &[const T],\n+pure fn gallop_right<T:Copy + Ord>(key: &const T, array: &[const T],\n                             hint: uint) -> uint {\n     let size = array.len();\n     assert size != 0 && hint < size;\n@@ -404,7 +404,7 @@ fn MergeState<T>() -> MergeState<T> {\n     }\n }\n \n-impl<T: Copy Ord> MergeState<T> {\n+impl<T:Copy + Ord> MergeState<T> {\n     fn push_run(&self, run_base: uint, run_len: uint) {\n         let tmp = RunState{base: run_base, len: run_len};\n         self.runs.push(tmp);\n@@ -708,7 +708,7 @@ impl<T: Copy Ord> MergeState<T> {\n }\n \n #[inline(always)]\n-fn copy_vec<T: Copy>(dest: &mut [T], s1: uint,\n+fn copy_vec<T:Copy>(dest: &mut [T], s1: uint,\n                     from: &[const T], s2: uint, len: uint) {\n     assert s1+len <= dest.len() && s2+len <= from.len();\n \n@@ -1019,7 +1019,7 @@ mod big_tests {\n         tabulate_managed(low, high);\n     }\n \n-    fn multiplyVec<T: Copy>(arr: &[const T], num: uint) -> ~[T] {\n+    fn multiplyVec<T:Copy>(arr: &[const T], num: uint) -> ~[T] {\n         let size = arr.len();\n         let res = do vec::from_fn(num) |i| {\n             arr[i % size]\n@@ -1035,7 +1035,7 @@ mod big_tests {\n     }\n \n     fn tabulate_unique(lo: uint, hi: uint) {\n-        fn isSorted<T: Ord>(arr: &[const T]) {\n+        fn isSorted<T:Ord>(arr: &[const T]) {\n             for uint::range(0, arr.len()-1) |i| {\n                 if arr[i] > arr[i+1] {\n                     fail!(~\"Array not sorted\");\n@@ -1107,7 +1107,7 @@ mod big_tests {\n     }\n \n     fn tabulate_managed(lo: uint, hi: uint) {\n-        fn isSorted<T: Ord>(arr: &[const @T]) {\n+        fn isSorted<T:Ord>(arr: &[const @T]) {\n             for uint::range(0, arr.len()-1) |i| {\n                 if arr[i] > arr[i+1] {\n                     fail!(~\"Array not sorted\");"}, {"sha": "66d17392417888cff9f1dcae8226a13384c924b5", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -84,7 +84,7 @@ struct SemInner<Q> {\n enum Sem<Q> = Exclusive<SemInner<Q>>;\n \n #[doc(hidden)]\n-fn new_sem<Q: Owned>(count: int, q: Q) -> Sem<Q> {\n+fn new_sem<Q:Owned>(count: int, q: Q) -> Sem<Q> {\n     Sem(exclusive(SemInner {\n         mut count: count, waiters: new_waitqueue(), blocked: q }))\n }\n@@ -99,7 +99,7 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n }\n \n #[doc(hidden)]\n-impl<Q: Owned> &Sem<Q> {\n+impl<Q:Owned> &Sem<Q> {\n     fn acquire() {\n         let mut waiter_nobe = None;\n         unsafe {\n@@ -167,7 +167,7 @@ type SemRelease = SemReleaseGeneric<()>;\n type SemAndSignalRelease = SemReleaseGeneric<~[Waitqueue]>;\n struct SemReleaseGeneric<Q> { sem: &Sem<Q> }\n \n-impl<Q: Owned> Drop for SemReleaseGeneric<Q> {\n+impl<Q:Owned> Drop for SemReleaseGeneric<Q> {\n     fn finalize(&self) {\n         self.sem.release();\n     }"}, {"sha": "6768ff232487740a731c695b34cc7dcc21d7d33c", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -39,7 +39,7 @@ use core;\n  * * ch - a channel of type T to send a `val` on\n  * * val - a value of type T to send over the provided `ch`\n  */\n-pub fn delayed_send<T: Owned>(iotask: &IoTask,\n+pub fn delayed_send<T:Owned>(iotask: &IoTask,\n                               msecs: uint,\n                               ch: &Chan<T>,\n                               val: T) {\n@@ -123,7 +123,7 @@ pub fn sleep(iotask: &IoTask, msecs: uint) {\n  * on the provided port in the allotted timeout period, then the result will\n  * be a `Some(T)`. If not, then `None` will be returned.\n  */\n-pub fn recv_timeout<T: Copy Owned>(iotask: &IoTask,\n+pub fn recv_timeout<T:Copy + Owned>(iotask: &IoTask,\n                                    msecs: uint,\n                                    wait_po: &Port<T>)\n                                 -> Option<T> {"}, {"sha": "eb3093a27451f02f08ad50d5f2a86d4ed0ffea59", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -39,7 +39,7 @@ pub struct TreeMap<K, V> {\n     priv length: uint\n }\n \n-impl<K: Eq Ord, V: Eq> Eq for TreeMap<K, V> {\n+impl<K:Eq + Ord,V:Eq> Eq for TreeMap<K, V> {\n     pure fn eq(&self, other: &TreeMap<K, V>) -> bool {\n         if self.len() != other.len() {\n             false\n@@ -66,7 +66,7 @@ impl<K: Eq Ord, V: Eq> Eq for TreeMap<K, V> {\n }\n \n // Lexicographical comparison\n-pure fn lt<K: Ord, V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n+pure fn lt<K:Ord,V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n     let mut x = a.iter();\n     let mut y = b.iter();\n \n@@ -85,7 +85,7 @@ pure fn lt<K: Ord, V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n     return a_len < b_len;\n }\n \n-impl<K: Ord, V> Ord for TreeMap<K, V> {\n+impl<K:Ord,V> Ord for TreeMap<K, V> {\n     #[inline(always)]\n     pure fn lt(&self, other: &TreeMap<K, V>) -> bool {\n         lt(self, other)\n@@ -104,38 +104,38 @@ impl<K: Ord, V> Ord for TreeMap<K, V> {\n     }\n }\n \n-impl<K: Ord, V> BaseIter<(&K, &V)> for TreeMap<K, V> {\n+impl<K:Ord,V> BaseIter<(&K, &V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in order\n     pure fn each(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n         each(&self.root, f)\n     }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<K: Ord, V> ReverseIter<(&K, &V)> for TreeMap<K, V> {\n+impl<K:Ord,V> ReverseIter<(&K, &V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in reverse order\n     pure fn each_reverse(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n         each_reverse(&self.root, f);\n     }\n }\n \n-impl<K: Ord, V> Container for TreeMap<K, V> {\n+impl<K:Ord,V> Container for TreeMap<K, V> {\n     /// Return the number of elements in the map\n     pure fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n     pure fn is_empty(&self) -> bool { self.root.is_none() }\n }\n \n-impl<K: Ord, V> Mutable for TreeMap<K, V> {\n+impl<K:Ord,V> Mutable for TreeMap<K, V> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n         self.root = None;\n         self.length = 0\n     }\n }\n \n-impl<K: Ord, V> Map<K, V> for TreeMap<K, V> {\n+impl<K:Ord,V> Map<K, V> for TreeMap<K, V> {\n     /// Return true if the map contains a value for the specified key\n     pure fn contains_key(&self, key: &K) -> bool {\n         self.find(key).is_some()\n@@ -184,7 +184,7 @@ impl<K: Ord, V> Map<K, V> for TreeMap<K, V> {\n     }\n }\n \n-impl <K: Ord, V> TreeMap<K, V> {\n+impl <K:Ord,V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n@@ -212,7 +212,7 @@ pub struct TreeMapIterator<K, V> {\n     priv current: Option<&~TreeNode<K, V>>\n }\n \n-impl <K: Ord, V> TreeMapIterator<K, V> {\n+impl <K:Ord,V> TreeMapIterator<K, V> {\n     // Returns the current node, or None if this iterator is at the end.\n     fn get(&const self) -> Option<(&self/K, &self/V)> {\n         match self.current {\n@@ -224,7 +224,7 @@ impl <K: Ord, V> TreeMapIterator<K, V> {\n \n /// Advance the iterator to the next node (in order). If this iterator\n /// is finished, does nothing.\n-pub fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&a<K, V>) {\n+pub fn map_next<K:Ord,V>(iter: &mut TreeMapIterator/&a<K, V>) {\n     while !iter.stack.is_empty() || iter.node.is_some() {\n         match *iter.node {\n           Some(ref x) => {\n@@ -246,25 +246,25 @@ pub struct TreeSet<T> {\n     priv map: TreeMap<T, ()>\n }\n \n-impl<T: Ord> BaseIter<T> for TreeSet<T> {\n+impl<T:Ord> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n     pure fn each(&self, f: fn(&T) -> bool) { self.map.each_key(f) }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<T: Ord> ReverseIter<T> for TreeSet<T> {\n+impl<T:Ord> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n     pure fn each_reverse(&self, f: fn(&T) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n }\n \n-impl<T: Eq Ord> Eq for TreeSet<T> {\n+impl<T:Eq + Ord> Eq for TreeSet<T> {\n     pure fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n     pure fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n }\n \n-impl<T: Ord> Ord for TreeSet<T> {\n+impl<T:Ord> Ord for TreeSet<T> {\n     #[inline(always)]\n     pure fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n     #[inline(always)]\n@@ -275,20 +275,20 @@ impl<T: Ord> Ord for TreeSet<T> {\n     pure fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }\n }\n \n-impl<T: Ord> Container for TreeSet<T> {\n+impl<T:Ord> Container for TreeSet<T> {\n     /// Return the number of elements in the set\n     pure fn len(&self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     pure fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n \n-impl<T: Ord> Mutable for TreeSet<T> {\n+impl<T:Ord> Mutable for TreeSet<T> {\n     /// Clear the set, removing all values.\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl<T: Ord> Set<T> for TreeSet<T> {\n+impl<T:Ord> Set<T> for TreeSet<T> {\n     /// Return true if the set contains a value\n     pure fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n@@ -510,7 +510,7 @@ impl<T: Ord> Set<T> for TreeSet<T> {\n     }\n }\n \n-impl <T: Ord> TreeSet<T> {\n+impl <T:Ord> TreeSet<T> {\n     /// Create an empty TreeSet\n     static pure fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n@@ -526,7 +526,7 @@ pub struct TreeSetIterator<T> {\n     priv iter: TreeMapIterator<T, ()>\n }\n \n-impl <T: Ord> TreeSetIterator<T> {\n+impl <T:Ord> TreeSetIterator<T> {\n     /// Returns the current node, or None if this iterator is at the end.\n     fn get(&const self) -> Option<&self/T> {\n         match self.iter.get() {\n@@ -538,7 +538,7 @@ impl <T: Ord> TreeSetIterator<T> {\n \n /// Advance the iterator to the next node (in order). If this iterator is\n /// finished, does nothing.\n-pub fn set_next<T: Ord>(iter: &mut TreeSetIterator/&a<T>) {\n+pub fn set_next<T:Ord>(iter: &mut TreeSetIterator/&a<T>) {\n     map_next(&mut iter.iter);\n }\n \n@@ -552,22 +552,22 @@ struct TreeNode<K, V> {\n     level: uint\n }\n \n-impl <K: Ord, V> TreeNode<K, V> {\n+impl <K:Ord,V> TreeNode<K, V> {\n     #[inline(always)]\n     static pure fn new(key: K, value: V) -> TreeNode<K, V> {\n         TreeNode{key: key, value: value, left: None, right: None, level: 1}\n     }\n }\n \n-pure fn each<K: Ord, V>(node: &r/Option<~TreeNode<K, V>>,\n+pure fn each<K:Ord,V>(node: &r/Option<~TreeNode<K, V>>,\n                         f: fn(&(&r/K, &r/V)) -> bool) {\n     do node.iter |x| {\n         each(&x.left, f);\n         if f(&(&x.key, &x.value)) { each(&x.right, f) }\n     }\n }\n \n-pure fn each_reverse<K: Ord, V>(node: &r/Option<~TreeNode<K, V>>,\n+pure fn each_reverse<K:Ord,V>(node: &r/Option<~TreeNode<K, V>>,\n                                 f: fn(&(&r/K, &r/V)) -> bool) {\n     do node.iter |x| {\n         each_reverse(&x.right, f);\n@@ -576,7 +576,7 @@ pure fn each_reverse<K: Ord, V>(node: &r/Option<~TreeNode<K, V>>,\n }\n \n // Remove left horizontal link by rotating right\n-fn skew<K: Ord, V>(node: &mut ~TreeNode<K, V>) {\n+fn skew<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n     if node.left.map_default(false, |x| x.level == node.level) {\n         let mut save = node.left.swap_unwrap();\n         node.left <-> save.right; // save.right now None\n@@ -587,7 +587,7 @@ fn skew<K: Ord, V>(node: &mut ~TreeNode<K, V>) {\n \n // Remove dual horizontal link by rotating left and increasing level of\n // the parent\n-fn split<K: Ord, V>(node: &mut ~TreeNode<K, V>) {\n+fn split<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n     if node.right.map_default(false,\n       |x| x.right.map_default(false, |y| y.level == node.level)) {\n         let mut save = node.right.swap_unwrap();\n@@ -598,7 +598,7 @@ fn split<K: Ord, V>(node: &mut ~TreeNode<K, V>) {\n     }\n }\n \n-fn insert<K: Ord, V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n+fn insert<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n                      value: V) -> bool {\n     match *node {\n       Some(ref mut save) => {\n@@ -625,8 +625,8 @@ fn insert<K: Ord, V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n     }\n }\n \n-fn remove<K: Ord, V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n-    fn heir_swap<K: Ord, V>(node: &mut ~TreeNode<K, V>,\n+fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n+    fn heir_swap<K:Ord,V>(node: &mut ~TreeNode<K, V>,\n                             child: &mut Option<~TreeNode<K, V>>) {\n         // *could* be done without recursion, but it won't borrow check\n         do child.mutate |mut child| {\n@@ -772,7 +772,7 @@ mod test_treemap {\n         assert m.find(&k1) == Some(&v1);\n     }\n \n-    fn check_equal<K: Eq Ord, V: Eq>(ctrl: &[(K, V)], map: &TreeMap<K, V>) {\n+    fn check_equal<K:Eq + Ord,V:Eq>(ctrl: &[(K, V)], map: &TreeMap<K, V>) {\n         assert ctrl.is_empty() == map.is_empty();\n         for ctrl.each |x| {\n             let &(k, v) = x;\n@@ -792,7 +792,7 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_left<K: Ord, V>(node: &Option<~TreeNode<K, V>>,\n+    fn check_left<K:Ord,V>(node: &Option<~TreeNode<K, V>>,\n                              parent: &~TreeNode<K, V>) {\n         match *node {\n           Some(ref r) => {\n@@ -805,7 +805,7 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_right<K: Ord, V>(node: &Option<~TreeNode<K, V>>,\n+    fn check_right<K:Ord,V>(node: &Option<~TreeNode<K, V>>,\n                               parent: &~TreeNode<K, V>, parent_red: bool) {\n         match *node {\n           Some(ref r) => {\n@@ -820,7 +820,7 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_structure<K: Ord, V>(map: &TreeMap<K, V>) {\n+    fn check_structure<K:Ord,V>(map: &TreeMap<K, V>) {\n         match map.root {\n           Some(ref r) => {\n             check_left(&r.left, r);"}, {"sha": "4de7c1b99252655cce3f69f916c70a792b77d222", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -138,7 +138,7 @@ impl WorkKey {\n \n type WorkMap = LinearMap<WorkKey, ~str>;\n \n-pub impl<S: Encoder> Encodable<S> for WorkMap {\n+pub impl<S:Encoder> Encodable<S> for WorkMap {\n     fn encode(&self, s: &S) {\n         let mut d = ~[];\n         for self.each |&(k, v)| {\n@@ -149,7 +149,7 @@ pub impl<S: Encoder> Encodable<S> for WorkMap {\n     }\n }\n \n-pub impl<D: Decoder> Decodable<D> for WorkMap {\n+pub impl<D:Decoder> Decodable<D> for WorkMap {\n     static fn decode(&self, d: &D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n         let mut w = LinearMap::new();"}, {"sha": "6befb2f1880426ec1d272a9346ae280552944172", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -32,7 +32,7 @@ macro_rules! interner_key (\n #[deriving_eq]\n pub struct ident { repr: uint }\n \n-pub impl<S: Encoder> Encodable<S> for ident {\n+pub impl<S:Encoder> Encodable<S> for ident {\n     fn encode(&self, s: &S) {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n@@ -45,7 +45,7 @@ pub impl<S: Encoder> Encodable<S> for ident {\n     }\n }\n \n-pub impl<D: Decoder> Decodable<D> for ident {\n+pub impl<D:Decoder> Decodable<D> for ident {\n     static fn decode(d: &D) -> ident {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n@@ -383,7 +383,7 @@ pub enum inferable<T> {\n     infer(node_id)\n }\n \n-pub impl<T: to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n+pub impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           expl(ref t) =>"}, {"sha": "c9bc41ed61e9b3efe9cc1fa5149b26ae210d3445", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -140,12 +140,12 @@ pub impl cmp::Eq for span {\n     pure fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n }\n \n-pub impl<S: Encoder> Encodable<S> for span {\n+pub impl<S:Encoder> Encodable<S> for span {\n     /* Note #1972 -- spans are encoded but not decoded */\n     fn encode(&self, _s: &S) { }\n }\n \n-pub impl<D: Decoder> Decodable<D> for span {\n+pub impl<D:Decoder> Decodable<D> for span {\n     static fn decode(_d: &D) -> span {\n         dummy_sp()\n     }"}, {"sha": "f378325d0abd539d07c9b3f8caffdde83becf251", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -300,7 +300,7 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n     }\n }\n \n-pub fn expect<T: Copy>(diag: span_handler,\n+pub fn expect<T:Copy>(diag: span_handler,\n                        opt: Option<T>,\n                        msg: fn() -> ~str) -> T {\n     match opt {"}, {"sha": "7fbba987cc7dff6a1228a319ce46953b453b15a9", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -23,15 +23,15 @@ For example, a type like:\n \n would generate two implementations like:\n \n-impl<S: std::serialize::Encoder> Encodable<S> for Node {\n+impl<S:std::serialize::Encoder> Encodable<S> for Node {\n     fn encode(&self, s: &S) {\n         do s.emit_struct(\"Node\", 1) {\n             s.emit_field(\"id\", 0, || s.emit_uint(self.id))\n         }\n     }\n }\n \n-impl<D: Decoder> Decodable for node_id {\n+impl<D:Decoder> Decodable for node_id {\n     static fn decode(d: &D) -> Node {\n         do d.read_struct(\"Node\", 1) {\n             Node {\n@@ -54,7 +54,7 @@ would yield functions like:\n         S: Encoder,\n         T: Encodable<S>\n     > spanned<T>: Encodable<S> {\n-        fn encode<S: Encoder>(s: &S) {\n+        fn encode<S:Encoder>(s: &S) {\n             do s.emit_rec {\n                 s.emit_field(\"node\", 0, || self.node.encode(s));\n                 s.emit_field(\"span\", 1, || self.span.encode(s));"}, {"sha": "49f7fe5853e7bc4da0418111763662066333cc0d", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -319,7 +319,7 @@ pub impl ext_ctxt_ast_builder for ext_ctxt {\n                 +items: ~[@ast::item]) -> @ast::item {\n \n         // XXX: Total hack: import `core::kinds::Owned` to work around a\n-        // parser bug whereby `fn f<T: ::kinds::Owned>` doesn't parse.\n+        // parser bug whereby `fn f<T:::kinds::Owned>` doesn't parse.\n         let vi = ast::view_item_use(~[\n             @codemap::spanned {\n                 node: ast::view_path_simple("}, {"sha": "4c9c9a5e52a83ed3f36bc25052bfec9a6ea775fc", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -212,7 +212,7 @@ pub impl Parser {\n \n     // parse a sequence bracketed by '<' and '>', stopping\n     // before the '>'.\n-    fn parse_seq_to_before_gt<T: Copy>(sep: Option<token::Token>,\n+    fn parse_seq_to_before_gt<T:Copy>(sep: Option<token::Token>,\n                                        f: fn(Parser) -> T) -> ~[T] {\n         let mut first = true;\n         let mut v = ~[];\n@@ -231,7 +231,7 @@ pub impl Parser {\n         return v;\n     }\n \n-    fn parse_seq_to_gt<T: Copy>(sep: Option<token::Token>,\n+    fn parse_seq_to_gt<T:Copy>(sep: Option<token::Token>,\n                                 f: fn(Parser) -> T) -> ~[T] {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n@@ -240,7 +240,7 @@ pub impl Parser {\n     }\n \n     // parse a sequence bracketed by '<' and '>'\n-    fn parse_seq_lt_gt<T: Copy>(sep: Option<token::Token>,\n+    fn parse_seq_lt_gt<T:Copy>(sep: Option<token::Token>,\n                                 f: fn(Parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(token::LT);\n@@ -253,7 +253,7 @@ pub impl Parser {\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_seq_to_end<T: Copy>(ket: token::Token, sep: seq_sep,\n+    fn parse_seq_to_end<T:Copy>(ket: token::Token, sep: seq_sep,\n                                  f: fn(Parser) -> T) -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -263,7 +263,7 @@ pub impl Parser {\n     // parse a sequence, not including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_seq_to_before_end<T: Copy>(ket: token::Token, sep: seq_sep,\n+    fn parse_seq_to_before_end<T:Copy>(ket: token::Token, sep: seq_sep,\n                                         f: fn(Parser) -> T) -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n@@ -284,7 +284,7 @@ pub impl Parser {\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_unspanned_seq<T: Copy>(bra: token::Token,\n+    fn parse_unspanned_seq<T:Copy>(bra: token::Token,\n                                     ket: token::Token,\n                                     sep: seq_sep,\n                                     f: fn(Parser) -> T) -> ~[T] {\n@@ -296,7 +296,7 @@ pub impl Parser {\n \n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n-    fn parse_seq<T: Copy>(bra: token::Token, ket: token::Token, sep: seq_sep,\n+    fn parse_seq<T:Copy>(bra: token::Token, ket: token::Token, sep: seq_sep,\n                           f: fn(Parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);"}, {"sha": "ab7e3204b7b310030fc942af8c3ef25bdf060603", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -2282,7 +2282,7 @@ pub mod test {\n     //use util;\n     use util::testing::check_equal;\n \n-    fn string_check<T : Eq> (given : &T, expected: &T) {\n+    fn string_check<T:Eq> (given : &T, expected: &T) {\n         if !(given == expected) {\n             fail!(fmt!(\"given %?, expected %?\",given,expected));\n         }"}, {"sha": "4b13818974c3045605107debe62064b7e7772152", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -23,7 +23,7 @@ pub struct Interner<T> {\n }\n \n // when traits can extend traits, we should extend index<uint,T> to get []\n-pub impl<T: Eq IterBytes Hash Const Copy> Interner<T> {\n+pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     static fn new() -> Interner<T> {\n         Interner {\n             map: LinearMap::new(),"}, {"sha": "78a175df29f276a59e015d9cb6d572ac621bbfc5", "filename": "src/libsyntax/util/testing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Futil%2Ftesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Flibsyntax%2Futil%2Ftesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Ftesting.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -11,13 +11,13 @@\n // support for test cases.\n use core::cmp;\n \n-pub pure fn check_equal_ptr<T : cmp::Eq> (given : &T, expected: &T) {\n+pub pure fn check_equal_ptr<T:cmp::Eq> (given : &T, expected: &T) {\n     if !((given == expected) && (expected == given )) {\n         fail!(fmt!(\"given %?, expected %?\",given,expected));\n     }\n }\n \n-pub pure fn check_equal<T : cmp::Eq> (given : T, expected: T) {\n+pub pure fn check_equal<T:cmp::Eq> (given : T, expected: T) {\n     if !((given == expected) && (expected == given )) {\n         fail!(fmt!(\"given %?, expected %?\",given,expected));\n     }"}, {"sha": "8038c5fc41ac4c800b8aecd02ccf3be72c8cff71", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,7 +10,7 @@\n \n use core::pipes::*;\n \n-pub fn foo<T: Owned Copy>(x: T) -> Port<T> {\n+pub fn foo<T:Owned + Copy>(x: T) -> Port<T> {\n     let (p, c) = stream();\n     do task::spawn() {\n         c.send(x);"}, {"sha": "1be18459e407c5ba4be64ba5fe2c089a40f5b417", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -16,11 +16,11 @@ pub struct Entry<A,B> {key: A, value: B}\n \n pub struct alist<A,B> { eq_fn: fn@(A,A) -> bool, data: DVec<Entry<A,B>> }\n \n-pub fn alist_add<A: Copy, B: Copy>(lst: alist<A,B>, k: A, v: B) {\n+pub fn alist_add<A:Copy,B:Copy>(lst: alist<A,B>, k: A, v: B) {\n     lst.data.push(Entry{key:k, value:v});\n }\n \n-pub fn alist_get<A: Copy, B: Copy>(lst: alist<A,B>, k: A) -> B {\n+pub fn alist_get<A:Copy,B:Copy>(lst: alist<A,B>, k: A) -> B {\n     let eq_fn = lst.eq_fn;\n     for lst.data.each |entry| {\n         if eq_fn(entry.key, k) { return entry.value; }\n@@ -29,13 +29,13 @@ pub fn alist_get<A: Copy, B: Copy>(lst: alist<A,B>, k: A) -> B {\n }\n \n #[inline]\n-pub fn new_int_alist<B: Copy>() -> alist<int, B> {\n+pub fn new_int_alist<B:Copy>() -> alist<int, B> {\n     fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n     return alist {eq_fn: eq_int, data: DVec()};\n }\n \n #[inline]\n-pub fn new_int_alist_2<B: Copy>() -> alist<int, B> {\n+pub fn new_int_alist_2<B:Copy>() -> alist<int, B> {\n     #[inline]\n     fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n     return alist {eq_fn: eq_int, data: DVec()};"}, {"sha": "958fb75b9d233af11925bb3cf281196a2e78f358", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -23,13 +23,13 @@ impl<T:Const> Drop for arc_destruct<T> {\n     fn finalize(&self) {}\n }\n \n-fn arc_destruct<T: Const>(data: int) -> arc_destruct<T> {\n+fn arc_destruct<T:Const>(data: int) -> arc_destruct<T> {\n     arc_destruct {\n         _data: data\n     }\n }\n \n-fn arc<T: Const>(_data: T) -> arc_destruct<T> {\n+fn arc<T:Const>(_data: T) -> arc_destruct<T> {\n     arc_destruct(0)\n }\n "}, {"sha": "b1fb7a82c5c8b764f08cd6f919b1cbc966f4d3b3", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -19,6 +19,6 @@ use std::oldmap::HashMap;\n pub type header_map = HashMap<~str, @DVec<@~str>>;\n \n // the unused ty param is necessary so this gets monomorphized\n-pub fn request<T: Copy>(req: header_map) {\n+pub fn request<T:Copy>(req: header_map) {\n   let _x = copy *(copy *req.get(&~\"METHOD\"))[0u];\n }"}, {"sha": "0e2105243e70308eb0f4580d5d9b957096c52657", "filename": "src/test/auxiliary/issue4516_ty_param_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Fissue4516_ty_param_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Fissue4516_ty_param_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue4516_ty_param_lib.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn to_closure<A: Durable Copy>(x: A) -> @fn() -> A {\n+pub fn to_closure<A:Durable + Copy>(x: A) -> @fn() -> A {\n     fn@() -> A { copy x }\n }"}, {"sha": "dbfff4e8acaaf7b764b975429d151ce7754e0a61", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -33,7 +33,7 @@ impl read for bool {\n     }\n }\n \n-pub fn read<T: read Copy>(s: ~str) -> T {\n+pub fn read<T:read + Copy>(s: ~str) -> T {\n     match read::readMaybe(s) {\n       Some(x) => x,\n       _ => fail!(~\"read failed!\")"}, {"sha": "3e26a09fb8f0d47897f849ad63171eab5a016752", "filename": "src/test/auxiliary/trait_inheritance_auto_xc_aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_auto_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_auto_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_auto_xc_aux.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -14,4 +14,4 @@ trait Baz { fn h() -> int; }\n \n trait Quux: Foo Bar Baz { }\n \n-impl<T: Foo Bar Baz> Quux for T { }\n+impl<T:Foo + Bar + Baz> Quux for T { }"}, {"sha": "2845596e780079956767992d27140fd5ce05af09", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -32,7 +32,7 @@ fn timed(result: &mut float, op: fn()) {\n }\n \n impl Results {\n-    fn bench_int<T: Set<uint>>(&mut self, rng: @rand::Rng, num_keys: uint,\n+    fn bench_int<T:Set<uint>>(&mut self, rng: @rand::Rng, num_keys: uint,\n                                rand_cap: uint, f: fn() -> T) {\n         {\n             let mut set = f();\n@@ -70,7 +70,7 @@ impl Results {\n         }\n     }\n \n-    fn bench_str<T: Set<~str>>(&mut self, rng: @rand::Rng, num_keys: uint,\n+    fn bench_str<T:Set<~str>>(&mut self, rng: @rand::Rng, num_keys: uint,\n                                f: fn() -> T) {\n         {\n             let mut set = f();"}, {"sha": "16f44b88793c80f1de5b08411d6a1fe4b98cf4af", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -72,7 +72,7 @@ macro_rules! follow (\n     )\n )\n \n-fn switch<T: Owned, Tb: Owned, U>(+endp: pipes::RecvPacketBuffered<T, Tb>,\n+fn switch<T:Owned,Tb:Owned,U>(+endp: pipes::RecvPacketBuffered<T, Tb>,\n                       f: fn(+v: Option<T>) -> U) -> U {\n     f(pipes::try_recv(endp))\n }"}, {"sha": "a887a13bf3802b39106aaa34086900d00a6c1eb6", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -27,22 +27,22 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n       return (xx as float) * 100f / (yy as float);\n    }\n \n-   pure fn le_by_val<TT: Copy, UU: Copy Ord>(kv0: &(TT,UU),\n+   pure fn le_by_val<TT:Copy,UU:Copy + Ord>(kv0: &(TT,UU),\n                                          kv1: &(TT,UU)) -> bool {\n       let (_, v0) = *kv0;\n       let (_, v1) = *kv1;\n       return v0 >= v1;\n    }\n \n-   pure fn le_by_key<TT: Copy Ord, UU: Copy>(kv0: &(TT,UU),\n+   pure fn le_by_key<TT:Copy + Ord,UU:Copy>(kv0: &(TT,UU),\n                                          kv1: &(TT,UU)) -> bool {\n       let (k0, _) = *kv0;\n       let (k1, _) = *kv1;\n       return k0 <= k1;\n    }\n \n    // sort by key, then by value\n-   fn sortKV<TT: Copy Ord, UU: Copy Ord>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n+   fn sortKV<TT:Copy + Ord,UU:Copy + Ord>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n       return sort::merge_sort(sort::merge_sort(orig, le_by_key), le_by_val);\n    }\n "}, {"sha": "92581d756db030f09ce3bd7aaa5a11354bbb942a", "filename": "src/test/compile-fail/ambig_impl_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fambig_impl_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fambig_impl_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_bounds.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -11,7 +11,7 @@\n trait A { fn foo(); }\n trait B { fn foo(); }\n \n-fn foo<T: A B>(t: T) {\n+fn foo<T:A + B>(t: T) {\n     t.foo(); //~ ERROR multiple applicable methods in scope\n     //~^ NOTE candidate #1 derives from the bound `A`\n     //~^^ NOTE candidate #2 derives from the bound `B`"}, {"sha": "c9aeaae0ff934e596bc94abe120ce74f3a4c454c", "filename": "src/test/compile-fail/issue-2611-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fissue-2611-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fissue-2611-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-3.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -16,15 +16,15 @@\n use iter::BaseIter;\n \n trait A {\n-  fn b<C:Copy Const, D>(x: C) -> C;\n+  fn b<C:Copy + Const,D>(x: C) -> C;\n }\n \n struct E {\n  f: int\n }\n \n impl A for E {\n-  fn b<F:Copy, G>(_x: F) -> F { fail!() } //~ ERROR in method `b`, type parameter 0 has 1 bound, but\n+  fn b<F:Copy,G>(_x: F) -> F { fail!() } //~ ERROR in method `b`, type parameter 0 has 1 bound, but\n }\n \n fn main() {}"}, {"sha": "fb7c5bd6cb87b21c49e327f91676e5547ea083b6", "filename": "src/test/compile-fail/issue-2611-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -13,15 +13,15 @@\n use iter::BaseIter;\n \n trait A {\n-  fn b<C:Copy, D>(x: C) -> C;\n+  fn b<C:Copy,D>(x: C) -> C;\n }\n \n struct E {\n  f: int\n }\n \n impl A for E {\n-  fn b<F:Copy Const, G>(_x: F) -> F { fail!() } //~ ERROR in method `b`, type parameter 0 has 2 bounds, but\n+  fn b<F:Copy + Const,G>(_x: F) -> F { fail!() } //~ ERROR in method `b`, type parameter 0 has 2 bounds, but\n }\n \n fn main() {}"}, {"sha": "35015a260f5af16a1614cebb78542a79d2c79dc5", "filename": "src/test/compile-fail/issue-2611-5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fissue-2611-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fissue-2611-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-5.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -13,7 +13,7 @@\n use iter::BaseIter;\n \n trait A {\n-  fn b<C:Copy, D>(x: C) -> C;\n+  fn b<C:Copy,D>(x: C) -> C;\n }\n \n struct E {\n@@ -22,7 +22,7 @@ struct E {\n \n impl A for E {\n   // n.b. The error message is awful -- see #3404\n-  fn b<F:Copy, G>(_x: G) -> G { fail!() } //~ ERROR method `b` has an incompatible type\n+  fn b<F:Copy,G>(_x: G) -> G { fail!() } //~ ERROR method `b` has an incompatible type\n }\n \n fn main() {}"}, {"sha": "77a840e7e366dd372b9e286fea59df0b8f1b289f", "filename": "src/test/compile-fail/issue-2766-a.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n pub mod stream {\n-    pub enum Stream<T: Owned> { send(T, ::stream::server::Stream<T>), }\n+    pub enum Stream<T:Owned> { send(T, ::stream::server::Stream<T>), }\n     pub mod server {\n         use core::option;\n         use core::pipes;\n \n-        impl<T: Owned> Stream<T> {\n+        impl<T:Owned> Stream<T> {\n             pub fn recv() -> extern fn(+v: Stream<T>) -> ::stream::Stream<T> {\n               // resolve really should report just one error here.\n               // Change the test case when it changes.\n@@ -28,7 +28,7 @@ pub mod stream {\n             }\n         }\n \n-        pub type Stream<T: Owned> = pipes::RecvPacket<::stream::Stream<T>>;\n+        pub type Stream<T:Owned> = pipes::RecvPacket<::stream::Stream<T>>;\n     }\n }\n "}, {"sha": "ab28b461a2c6b4e5ecfb3c8a301b485e84e9a304", "filename": "src/test/compile-fail/issue-3177-mutable-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fissue-3177-mutable-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fissue-3177-mutable-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3177-mutable-struct.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-test\n // error-pattern: instantiating a type parameter with an incompatible type\n-struct S<T: Const> {\n+struct S<T:Const> {\n     s: T,\n     mut cant_nest: ()\n }"}, {"sha": "b2cef943528fe0ed449e7cb920fa7e3e023057ea", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -35,7 +35,7 @@ fn to_foo_2<T:Copy>(t: T) -> foo {\n     {f:t} as foo //~ ERROR value may contain borrowed pointers; use `&static` bound\n }\n \n-fn to_foo_3<T:Copy &static>(t: T) -> foo {\n+fn to_foo_3<T:Copy + &static>(t: T) -> foo {\n     // OK---T may escape as part of the returned foo value, but it is\n     // owned and hence does not contain borrowed ptrs\n     {f:t} as foo"}, {"sha": "2bc6a91120424f209d8d38ebf5805d18b9d51a7a", "filename": "src/test/compile-fail/kindck-owned-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,11 +10,11 @@\n \n trait foo { fn foo(); }\n \n-fn to_foo<T: Copy foo>(t: T) -> foo {\n+fn to_foo<T:Copy + foo>(t: T) -> foo {\n     t as foo //~ ERROR value may contain borrowed pointers; use `&static` bound\n }\n \n-fn to_foo2<T: Copy foo &static>(t: T) -> foo {\n+fn to_foo2<T:Copy + foo + &static>(t: T) -> foo {\n     t as foo\n }\n "}, {"sha": "e792917622b3f8a985612282c5e457594d6a9098", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn copy1<T: Copy>(t: T) -> fn@() -> T {\n+fn copy1<T:Copy>(t: T) -> fn@() -> T {\n     fn@() -> T { t } //~ ERROR value may contain borrowed pointers\n }\n \n-fn copy2<T: Copy &static>(t: T) -> fn@() -> T {\n+fn copy2<T:Copy + &static>(t: T) -> fn@() -> T {\n     fn@() -> T { t }\n }\n "}, {"sha": "95dd59eb27f73977408e3b09f01dd5202ca133a6", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn send<T: Owned>(ch: _chan<T>, -data: T) {\n+fn send<T:Owned>(ch: _chan<T>, -data: T) {\n     log(debug, ch);\n     log(debug, data);\n     fail!();"}, {"sha": "43c91490a9686bb22b0deacf4d5f82fdb4ec22c7", "filename": "src/test/compile-fail/non-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fnon-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fnon-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-const.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,7 +10,7 @@\n \n // Test that various non const things are rejected.\n \n-fn foo<T: Const>(_x: T) { }\n+fn foo<T:Const>(_x: T) { }\n \n struct r {\n   x:int,"}, {"sha": "ac873238bfc0d0505ead0cd9e1f65dbd6c4f9fbc", "filename": "src/test/compile-fail/obsolete-syntax.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,16 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f1<T: copy>() -> T { }\n+fn f1<T:copy>() -> T { }\n //~^ ERROR obsolete syntax: lower-case kind bounds\n \n-fn f1<T: send>() -> T { }\n+fn f1<T:send>() -> T { }\n //~^ ERROR obsolete syntax: lower-case kind bounds\n \n-fn f1<T: const>() -> T { }\n+fn f1<T:const>() -> T { }\n //~^ ERROR obsolete syntax: lower-case kind bounds\n \n-fn f1<T: owned>() -> T { }\n+fn f1<T:owned>() -> T { }\n //~^ ERROR obsolete syntax: lower-case kind bounds\n \n struct s {"}, {"sha": "e4598adca27dfd471e714f667017f40b0f45eca4", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -18,7 +18,7 @@ impl deref for &int {\n     }\n }\n \n-fn with<R: deref>(f: fn(x: &int) -> R) -> int {\n+fn with<R:deref>(f: fn(x: &int) -> R) -> int {\n     f(&3).get()\n }\n "}, {"sha": "26058bf89cad726813bda21f7d8e27c19b07d04e", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<T: Owned>(_i: T) {\n+fn f<T:Owned>(_i: T) {\n }\n \n fn main() {"}, {"sha": "478e01ccd042eccf841eb81b7a0ef0ef608e9544", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn concat<T: Copy>(v: ~[const ~[const T]]) -> ~[T] {\n+fn concat<T:Copy>(v: ~[const ~[const T]]) -> ~[T] {\n     let mut r = ~[];\n \n     // Earlier versions of our type checker accepted this:"}, {"sha": "bd886f44ede848c84b492e83178d49514c9c7935", "filename": "src/test/compile-fail/vtable-res-trait-param.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -13,16 +13,16 @@ trait TraitA {\n }\n \n trait TraitB {\n-    fn gimme_an_a<A: TraitA>(a: A) -> int;\n+    fn gimme_an_a<A:TraitA>(a: A) -> int;\n }\n \n impl TraitB for int {\n-    fn gimme_an_a<A: TraitA>(a: A) -> int {\n+    fn gimme_an_a<A:TraitA>(a: A) -> int {\n         a.method_a() + self\n     }\n }\n \n-fn call_it<B: TraitB>(b: B)  -> int {\n+fn call_it<B:TraitB>(b: B)  -> int {\n     let y = 4u;\n     b.gimme_an_a(y) //~ ERROR failed to find an implementation of trait @TraitA\n }"}, {"sha": "4dada6257d4b024f1a15c1c5c7430729b1dc3eeb", "filename": "src/test/run-fail/bug-811.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-fail%2Fbug-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-fail%2Fbug-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-811.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -16,6 +16,6 @@ type port_id = int;\n \n enum chan_t<T> = {task: task_id, port: port_id};\n \n-fn send<T: Owned>(ch: chan_t<T>, data: T) { fail!(); }\n+fn send<T:Owned>(ch: chan_t<T>, data: T) { fail!(); }\n \n fn main() { fail!(~\"quux\"); }"}, {"sha": "2972c425192a8281be17f5134b318b097a3f660d", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,7 +12,7 @@ type pair<A,B> = {\n     a: A, b: B\n };\n \n-fn f<A:Copy &static>(a: A, b: u16) -> fn@() -> (A, u16) {\n+fn f<A:Copy + &static>(a: A, b: u16) -> fn@() -> (A, u16) {\n     fn@() -> (A, u16) { (a, b) }\n }\n "}, {"sha": "2a09de7a81c222276db78fbda0c194fc58ddeaa0", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -23,7 +23,7 @@ fn make_cycle<A:Copy>(a: A) {\n     g.rec = Some(g);\n }\n \n-fn f<A:Owned Copy, B:Owned Copy>(a: A, b: B) -> fn@() -> (A, B) {\n+fn f<A:Owned + Copy,B:Owned + Copy>(a: A, b: B) -> fn@() -> (A, B) {\n     fn@() -> (A, B) { (a, b) }\n }\n "}, {"sha": "6bf5293913f5779234d2ce349099a394138d4d8a", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -26,7 +26,7 @@ use std::serialize::{Encodable, Decodable};\n use std::prettyprint;\n use std::time;\n \n-fn test_prettyprint<A: Encodable<prettyprint::Serializer>>(\n+fn test_prettyprint<A:Encodable<prettyprint::Serializer>>(\n     a: &A,\n     expected: &~str\n ) {"}, {"sha": "4075ec5603813c5fff5ff51a0559d078f9fce5e6", "filename": "src/test/run-pass/auto-instantiate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -16,7 +16,7 @@\n struct Pair<T, U> { a: T, b: U }\n struct Triple { x: int, y: int, z: int }\n \n-fn f<T: Copy, U: Copy>(x: T, y: U) -> Pair<T, U> { return Pair {a: x, b: y}; }\n+fn f<T:Copy,U:Copy>(x: T, y: U) -> Pair<T, U> { return Pair {a: x, b: y}; }\n \n pub fn main() {\n     log(debug, f(Triple {x: 3, y: 4, z: 5}, 4).a.x);"}, {"sha": "316627e349be0e697044a61934cd1e8dfbaecc36", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<T: Copy>(x: ~[T]) -> T { return x[0]; }\n+fn f<T:Copy>(x: ~[T]) -> T { return x[0]; }\n \n fn g(act: fn(~[int]) -> int) -> int { return act(~[1, 2, 3]); }\n "}, {"sha": "b44d1cbb78d48a6dc986780e3480c19eb610950f", "filename": "src/test/run-pass/autoderef-method-on-trait-monomorphized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait-monomorphized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait-monomorphized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait-monomorphized.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -16,7 +16,7 @@ impl double for uint {\n     fn double() -> uint { self * 2u }\n }\n \n-fn is_equal<D: double>(x: @D, exp: uint) {\n+fn is_equal<D:double>(x: @D, exp: uint) {\n     assert x.double() == exp;\n }\n "}, {"sha": "8bc02eb2f9f3f26fd13fe8473b3bdf217558c556", "filename": "src/test/run-pass/autoref-intermediate-types-issue-3585.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,7 +12,7 @@ trait Foo {\n     fn foo(&self) -> ~str;\n }\n \n-impl<T: Foo> Foo for @T {\n+impl<T:Foo> Foo for @T {\n     fn foo(&self) -> ~str {\n         fmt!(\"@%s\", (**self).foo())\n     }"}, {"sha": "b51481f1ea1a1df80a5efc62feaa485a9f9113f7", "filename": "src/test/run-pass/borrowed-ptr-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo<T: Copy>(x: &T) -> T{\n+fn foo<T:Copy>(x: &T) -> T{\n     match x {\n         &a => a\n     }"}, {"sha": "1efe12c1a3c18709e9f37e238f80e927cad3e5d0", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,7 +12,7 @@\n \n struct Box<T> {c: @T}\n \n-fn unbox<T: Copy>(b: Box<T>) -> T { return *b.c; }\n+fn unbox<T:Copy>(b: Box<T>) -> T { return *b.c; }\n \n pub fn main() {\n     let foo: int = 17;"}, {"sha": "f81b12b555e4b7494aaa5348aeb79be3824ece57", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -14,7 +14,7 @@ extern mod cci_class_cast;\n use core::to_str::ToStr;\n use cci_class_cast::kitty::*;\n \n-fn print_out<T: ToStr>(thing: T, expected: ~str) {\n+fn print_out<T:ToStr>(thing: T, expected: ~str) {\n   let actual = thing.to_str();\n   debug!(\"%s\", actual);\n   assert(actual == expected);"}, {"sha": "d21ff90e7fbd57e1d8ced9572a42a63734a8310f", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -48,7 +48,7 @@ class cat : to_str {\n   fn to_str() -> str { self.name }\n }\n \n-fn print_out<T: to_str>(thing: T, expected: str) {\n+fn print_out<T:to_str>(thing: T, expected: str) {\n   let actual = thing.to_str();\n   debug!(\"%s\", actual);\n   assert(actual == expected);"}, {"sha": "f35a91c2b914f0dfde7eca6d32f38c8da7458b4d", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -79,7 +79,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n \n-fn annoy_neighbors<T: noisy>(critter: T) {\n+fn annoy_neighbors<T:noisy>(critter: T) {\n   for uint::range(0u, 10u) |i| { critter.speak(); }\n }\n "}, {"sha": "15564d73e1f70987d18a027f6b0ed58ad4858022", "filename": "src/test/run-pass/class-implement-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -59,7 +59,7 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n \n-fn make_speak<C: noisy>(c: C) {\n+fn make_speak<C:noisy>(c: C) {\n     c.speak();\n }\n "}, {"sha": "a05b74c9a3c551dd28bdc91a5c04602a526faaeb", "filename": "src/test/run-pass/class-implements-multiple-traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -96,14 +96,14 @@ class cat : noisy, scratchy, bitey {\n   }\n }\n \n-fn annoy_neighbors<T: noisy>(critter: T) {\n+fn annoy_neighbors<T:noisy>(critter: T) {\n   for uint::range(0u, 10u) |i| {\n       let what = critter.speak();\n       debug!(\"%u %d\", i, what);\n   }\n }\n \n-fn bite_everything<T: bitey>(critter: T) -> bool {\n+fn bite_everything<T:bitey>(critter: T) -> bool {\n   let mut left : ~[body_part] = ~[finger, toe, nose, ear];\n   while vec::len(left) > 0u {\n     let part = critter.bite();\n@@ -118,7 +118,7 @@ fn bite_everything<T: bitey>(critter: T) -> bool {\n   true\n }\n \n-fn scratched_something<T: scratchy>(critter: T) -> bool {\n+fn scratched_something<T:scratchy>(critter: T) -> bool {\n   option::is_some(critter.scratch())\n }\n "}, {"sha": "fda358a86a2f50415b3f3c837e227439155141c8", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -57,7 +57,7 @@ impl ToStr for cat {\n   pure fn to_str(&self) -> ~str { copy self.name }\n }\n \n-fn print_out<T: ToStr>(thing: T, expected: ~str) {\n+fn print_out<T:ToStr>(thing: T, expected: ~str) {\n   let actual = thing.to_str();\n   debug!(\"%s\", actual);\n   assert(actual == expected);"}, {"sha": "5e39b18db737536131095cf51f130bee757832e0", "filename": "src/test/run-pass/class-trait-bounded-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -13,7 +13,7 @@\n extern mod std;\n use std::oldmap::{map, hashmap, int_hash};\n \n-class keys<K: Copy, V: Copy, M: Copy map<K,V>>\n+class keys<K:Copy,V:Copy,M:Copy + map<K,V>>\n     : iter::base_iter<K> {\n \n     let map: M;"}, {"sha": "32f39177e1c065453b8434bc0ccbba7c406921fa", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -16,7 +16,7 @@ type pair<A,B> = {\n     a: A, b: B\n };\n \n-fn f<A:Copy &static>(a: A, b: u16) -> fn@() -> (A, u16) {\n+fn f<A:Copy + &static>(a: A, b: u16) -> fn@() -> (A, u16) {\n     fn@() -> (A, u16) { (a, b) }\n }\n "}, {"sha": "d4467ca0c7a060b2e15e8d90bf7a8b9de930827c", "filename": "src/test/run-pass/const-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-bound.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,7 +12,7 @@\n // are const.\n \n \n-fn foo<T: Copy Const>(x: T) -> T { x }\n+fn foo<T:Copy + Const>(x: T) -> T { x }\n \n struct F { field: int }\n "}, {"sha": "e226423f848054beb1725c083b7794cd496715f6", "filename": "src/test/run-pass/explicit-self-objects-ext-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -13,7 +13,7 @@ pub trait ReaderUtil {\n     fn read_bytes(&self, len: uint);\n }\n \n-impl<T: Reader> ReaderUtil for T {\n+impl<T:Reader> ReaderUtil for T {\n \n     fn read_bytes(&self, len: uint) {\n         let mut count = self.read(&mut [0], len);"}, {"sha": "e226423f848054beb1725c083b7794cd496715f6", "filename": "src/test/run-pass/explicit-self-objects-ext-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -13,7 +13,7 @@ pub trait ReaderUtil {\n     fn read_bytes(&self, len: uint);\n }\n \n-impl<T: Reader> ReaderUtil for T {\n+impl<T:Reader> ReaderUtil for T {\n \n     fn read_bytes(&self, len: uint) {\n         let mut count = self.read(&mut [0], len);"}, {"sha": "1a18ee7c6f750df24e38cc5eea8c0e2caa118d15", "filename": "src/test/run-pass/explicit-self-objects-ext-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -13,7 +13,7 @@ pub trait ReaderUtil {\n     fn read_bytes(len: uint);\n }\n \n-impl<T: Reader> ReaderUtil for T {\n+impl<T:Reader> ReaderUtil for T {\n \n     fn read_bytes(len: uint) {\n         let mut count = self.read(&mut [0], len);"}, {"sha": "a5d934d99849413c2e1356aab16173f2c48056d0", "filename": "src/test/run-pass/explicit-self-objects-ext-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -13,7 +13,7 @@ pub trait ReaderUtil {\n     fn read_bytes(len: uint);\n }\n \n-impl<T: Reader> ReaderUtil for T {\n+impl<T:Reader> ReaderUtil for T {\n \n     fn read_bytes(len: uint) {\n         let mut count = self.read(&mut [0], len);"}, {"sha": "224ae2cf78e2386c9ee17824d5b2fb6dfc1566ca", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -15,7 +15,7 @@\n \n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: Copy>(expected: T, eq: compare<T>) {\n+fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n     let actual: T = match true { true => { expected }, _ => fail!(~\"wat\") };\n     assert (eq(expected, actual));\n }"}, {"sha": "ec51fabd4a75078fb72f5674cf4561263ed2f46a", "filename": "src/test/run-pass/expr-alt-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -13,7 +13,7 @@\n // -*- rust -*-\n type compare<T> = fn@(~T, ~T) -> bool;\n \n-fn test_generic<T: Copy>(expected: ~T, eq: compare<T>) {\n+fn test_generic<T:Copy>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = match true {\n         true => { copy expected },\n         _ => fail!(~\"wat\")"}, {"sha": "cb641b493e0a456ea08a0f1c2fd5eb5d4ff99593", "filename": "src/test/run-pass/expr-alt-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -15,7 +15,7 @@\n \n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: Copy>(expected: T, eq: compare<T>) {\n+fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n     let actual: T = match true {\n         true => copy expected,\n         _ => fail!(~\"wat\")"}, {"sha": "95710eecddb8694f8c30eb72f8ce67bd441df825", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -14,7 +14,7 @@\n \n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: Copy>(expected: T, eq: compare<T>) {\n+fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n   let actual: T = match true { true => { expected }, _ => fail!(~\"wat\") };\n     assert (eq(expected, actual));\n }"}, {"sha": "3851578d54748a2339ff3aae488617807832afd8", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -14,7 +14,7 @@\n \n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: Copy>(expected: T, eq: compare<T>) {\n+fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "c4efe32a31ec1a766337acfa04646069fac4c3a5", "filename": "src/test/run-pass/expr-block-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -13,7 +13,7 @@\n // -*- rust -*-\n type compare<T> = fn@(~T, ~T) -> bool;\n \n-fn test_generic<T: Copy>(expected: ~T, eq: compare<T>) {\n+fn test_generic<T:Copy>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = { copy expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "b0a056e889180987037349a7c99a79b478ab10d4", "filename": "src/test/run-pass/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -14,7 +14,7 @@\n \n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: Copy>(expected: T, eq: compare<T>) {\n+fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "3d1ef7dbea2c82f6d8692bbccad78c9ca4b14908", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -16,7 +16,7 @@\n // Tests for standalone blocks as expressions with dynamic type sizes\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: Copy>(expected: T, eq: compare<T>) {\n+fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "0db78f776c45e32222456e21ae27cddce109f125", "filename": "src/test/run-pass/expr-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-fn.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -19,7 +19,7 @@ fn test_vec() {\n }\n \n fn test_generic() {\n-    fn f<T: Copy>(t: T) -> T { t }\n+    fn f<T:Copy>(t: T) -> T { t }\n     assert (f(10) == 10);\n }\n "}, {"sha": "5a879071a8814ee85156152e09d2dfaca15414d4", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -14,7 +14,7 @@\n \n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: Copy>(expected: T, not_expected: T, eq: compare<T>) {\n+fn test_generic<T:Copy>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected } else { not_expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "179268a22b802f1cc0f65da0422588a7d4beddc3", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -15,7 +15,7 @@\n // Tests for if as expressions with dynamic type sizes\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T: Copy>(expected: T, not_expected: T, eq: compare<T>) {\n+fn test_generic<T:Copy>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected } else { not_expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "8547180b933ff451f08bf269fa5bb0867073d840", "filename": "src/test/run-pass/fixed-point-bind-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -11,11 +11,11 @@\n // xfail-fast\n #[legacy_modes];\n \n-fn fix_help<A: &static, B: Owned>(f: extern fn(fn@(A) -> B, A) -> B, x: A) -> B {\n+fn fix_help<A:&static,B:Owned>(f: extern fn(fn@(A) -> B, A) -> B, x: A) -> B {\n     return f(|a| fix_help(f, a), x);\n }\n \n-fn fix<A: &static, B: Owned>(f: extern fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n+fn fix<A:&static,B:Owned>(f: extern fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n     return |a| fix_help(f, a);\n }\n "}, {"sha": "9b2a8d0c68177ac2c05f1505110f0888a5d01146", "filename": "src/test/run-pass/fn-bare-spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,7 +10,7 @@\n \n // This is what the signature to spawn should look like with bare functions\n \n-fn spawn<T: Owned>(val: T, f: extern fn(T)) {\n+fn spawn<T:Owned>(val: T, f: extern fn(T)) {\n     f(val);\n }\n "}, {"sha": "95902acc8487a47cf0a78a6900d1406e61ff42b7", "filename": "src/test/run-pass/generic-alias-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,7 +10,7 @@\n \n \n \n-fn id<T: Copy>(t: T) -> T { return t; }\n+fn id<T:Copy>(t: T) -> T { return t; }\n \n pub fn main() {\n     let expected = @100;"}, {"sha": "3cb6409a254e1a206091143202dc459f4cfbbfd0", "filename": "src/test/run-pass/generic-alias-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,7 +10,7 @@\n \n \n \n-fn id<T: Copy Owned>(t: T) -> T { return t; }\n+fn id<T:Copy + Owned>(t: T) -> T { return t; }\n \n pub fn main() {\n     let expected = ~100;"}, {"sha": "43c6acd3f3da06b1f55a97a88a23a8c061bbcf83", "filename": "src/test/run-pass/generic-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-box.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,7 +10,7 @@\n \n \n \n-fn box<T: Copy>(x: Box<T>) -> @Box<T> { return @x; }\n+fn box<T:Copy>(x: Box<T>) -> @Box<T> { return @x; }\n \n struct Box<T> {x: T, y: T, z: T}\n "}, {"sha": "264703439e810591095324878c52e7b65e191a15", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,11 +10,11 @@\n \n \n \n-fn g<X: Copy>(x: X) -> X { return x; }\n+fn g<X:Copy>(x: X) -> X { return x; }\n \n struct Pair<T> {a: T, b: T}\n \n-fn f<T: Copy>(t: T) -> Pair<T> {\n+fn f<T:Copy>(t: T) -> Pair<T> {\n \n     let x: Pair<T> = Pair {a: t, b: t};\n     return g::<Pair<T>>(x);"}, {"sha": "19e11197fd91394474e4d8b701cce2d4179b2aa6", "filename": "src/test/run-pass/generic-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -11,6 +11,6 @@\n \n struct Pair { x: @int, y: @int }\n \n-fn f<T: Copy>(t: T) { let t1: T = t; }\n+fn f<T:Copy>(t: T) { let t1: T = t; }\n \n pub fn main() { let x = Pair {x: @10, y: @12}; f(x); }"}, {"sha": "7039fad1a9a2d40c9cb0a8b75e16cac61c19cd98", "filename": "src/test/run-pass/generic-exterior-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,7 +12,7 @@\n \n struct Recbox<T> {x: @T}\n \n-fn reclift<T: Copy>(t: T) -> Recbox<T> { return Recbox {x: @t}; }\n+fn reclift<T:Copy>(t: T) -> Recbox<T> { return Recbox {x: @t}; }\n \n pub fn main() {\n     let foo: int = 17;"}, {"sha": "3d3cc028f35831d3ee8724b98e3857aa0e862a12", "filename": "src/test/run-pass/generic-exterior-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-exterior-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-exterior-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-unique.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,7 +10,7 @@\n \n struct Recbox<T> {x: ~T}\n \n-fn reclift<T: Copy>(t: T) -> Recbox<T> { return Recbox {x: ~t}; }\n+fn reclift<T:Copy>(t: T) -> Recbox<T> { return Recbox {x: ~t}; }\n \n pub fn main() {\n     let foo: int = 17;"}, {"sha": "fcd356bcd2d835e123aa52f610a9c0fae73e412f", "filename": "src/test/run-pass/generic-fn-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -14,6 +14,6 @@\n // -*- rust -*-\n \n // Issue #45: infer type parameters in function applications\n-fn id<T: Copy>(x: T) -> T { return x; }\n+fn id<T:Copy>(x: T) -> T { return x; }\n \n pub fn main() { let x: int = 42; let y: int = id(x); assert (x == y); }"}, {"sha": "d41cd86bcc147f6100ee9b5fb5f2106d32201cb7", "filename": "src/test/run-pass/generic-fn-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n \n-fn f<T: Copy>(x: ~T) -> ~T { return x; }\n+fn f<T:Copy>(x: ~T) -> ~T { return x; }\n \n pub fn main() { let x = f(~3); log(debug, *x); }"}, {"sha": "2fad81f4db20a3aed9ba31fe4cfad055e59489a1", "filename": "src/test/run-pass/generic-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,7 +12,7 @@\n \n \n // -*- rust -*-\n-fn id<T: Copy>(x: T) -> T { return x; }\n+fn id<T:Copy>(x: T) -> T { return x; }\n \n struct Triple {x: int, y: int, z: int}\n "}, {"sha": "3f6f8e7af688105975ed873475739fb9f77a6c65", "filename": "src/test/run-pass/generic-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn get_third<T: Copy>(t: (T, T, T)) -> T { let (_, _, x) = t; return x; }\n+fn get_third<T:Copy>(t: (T, T, T)) -> T { let (_, _, x) = t; return x; }\n \n pub fn main() {\n     log(debug, get_third((1, 2, 3)));"}, {"sha": "dc88f7acfbdf35a7892c9d6e8819afb0fd49c0fa", "filename": "src/test/run-pass/generic-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,7 +10,7 @@\n \n struct Triple<T> { x: T, y: T, z: T }\n \n-fn box<T: Copy>(x: Triple<T>) -> ~Triple<T> { return ~x; }\n+fn box<T:Copy>(x: Triple<T>) -> ~Triple<T> { return ~x; }\n \n pub fn main() {\n     let x: ~Triple<int> = box::<int>(Triple{x: 1, y: 2, z: 3});"}, {"sha": "ebf7eec470c3ebaab9a083b863db211b20a5d5c9", "filename": "src/test/run-pass/issue-2284.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2284.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2284.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2284.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,7 +12,7 @@ trait Send {\n     fn f();\n }\n \n-fn f<T: Send>(t: T) {\n+fn f<T:Send>(t: T) {\n     t.f();\n }\n "}, {"sha": "375259baaf527091a7b62d25e9fd0c9d821bf8e2", "filename": "src/test/run-pass/issue-2288.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2288.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,25 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait clam<A: Copy> {\n+trait clam<A:Copy> {\n   fn chowder(y: A);\n }\n struct foo<A> {\n   x: A,\n }\n \n-impl<A: Copy> clam<A> for foo<A> {\n+impl<A:Copy> clam<A> for foo<A> {\n   fn chowder(y: A) {\n   }\n }\n \n-fn foo<A: Copy>(b: A) -> foo<A> {\n+fn foo<A:Copy>(b: A) -> foo<A> {\n     foo {\n         x: b\n     }\n }\n \n-fn f<A: Copy>(x: clam<A>, a: A) {\n+fn f<A:Copy>(x: clam<A>, a: A) {\n   x.chowder(a);\n }\n "}, {"sha": "b4141b47b4d6733cb9f15ac82c69dafce23206e3", "filename": "src/test/run-pass/issue-2311-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2311-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2311-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2311-2.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,18 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait clam<A: Copy> { }\n+trait clam<A:Copy> { }\n struct foo<A> {\n     x: A,\n }\n \n-impl<A: Copy> foo<A> {\n+impl<A:Copy> foo<A> {\n    fn bar<B,C:clam<A>>(c: C) -> B {\n      fail!();\n    }\n }\n \n-fn foo<A: Copy>(b: A) -> foo<A> {\n+fn foo<A:Copy>(b: A) -> foo<A> {\n     foo {\n         x: b\n     }"}, {"sha": "9869b8d330bf191060ae3d15b932c36fc618b661", "filename": "src/test/run-pass/issue-2445-b.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2445-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2445-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2445-b.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,18 +12,18 @@ struct c1<T> {\n     x: T,\n }\n \n-impl<T: Copy> c1<T> {\n+impl<T:Copy> c1<T> {\n     fn f1(x: int) {\n     }\n }\n \n-fn c1<T: Copy>(x: T) -> c1<T> {\n+fn c1<T:Copy>(x: T) -> c1<T> {\n     c1 {\n         x: x\n     }\n }\n \n-impl<T: Copy> c1<T> {\n+impl<T:Copy> c1<T> {\n     fn f2(x: int) {\n     }\n }"}, {"sha": "4a085a1eb8a97db65576f43f86368bf4e4d6c821", "filename": "src/test/run-pass/issue-2445.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2445.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2445.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2445.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,17 +12,17 @@ struct c1<T> {\n     x: T,\n }\n \n-impl<T: Copy> c1<T> {\n+impl<T:Copy> c1<T> {\n     fn f1(x: T) {}\n }\n \n-fn c1<T: Copy>(x: T) -> c1<T> {\n+fn c1<T:Copy>(x: T) -> c1<T> {\n     c1 {\n         x: x\n     }\n }\n \n-impl<T: Copy> c1<T> {\n+impl<T:Copy> c1<T> {\n     fn f2(x: T) {}\n }\n "}, {"sha": "029fe12fcd9847e8d617b62987f8000fe1accb13", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -34,7 +34,7 @@ pub mod pipes {\n         mut payload: Option<T>\n     };\n \n-    pub fn packet<T: Owned>() -> *packet<T> {\n+    pub fn packet<T:Owned>() -> *packet<T> {\n         unsafe {\n             let p: *packet<T> = cast::transmute(~Stuff{\n                 mut state: empty,\n@@ -70,7 +70,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub fn send<T: Owned>(-p: send_packet<T>, -payload: T) {\n+    pub fn send<T:Owned>(-p: send_packet<T>, -payload: T) {\n         let p = p.unwrap();\n         let p = unsafe { uniquify(p) };\n         assert (*p).payload.is_none();\n@@ -96,7 +96,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub fn recv<T: Owned>(-p: recv_packet<T>) -> Option<T> {\n+    pub fn recv<T:Owned>(-p: recv_packet<T>) -> Option<T> {\n         let p = p.unwrap();\n         let p = unsafe { uniquify(p) };\n         loop {\n@@ -117,7 +117,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub fn sender_terminate<T: Owned>(p: *packet<T>) {\n+    pub fn sender_terminate<T:Owned>(p: *packet<T>) {\n         let p = unsafe { uniquify(p) };\n         match swap_state_rel(&mut (*p).state, terminated) {\n           empty | blocked => {\n@@ -134,7 +134,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub fn receiver_terminate<T: Owned>(p: *packet<T>) {\n+    pub fn receiver_terminate<T:Owned>(p: *packet<T>) {\n         let p = unsafe { uniquify(p) };\n         match swap_state_rel(&mut (*p).state, terminated) {\n           empty => {\n@@ -155,7 +155,7 @@ pub mod pipes {\n         mut p: Option<*packet<T>>,\n     }\n \n-    pub impl<T: Owned> Drop for send_packet<T> {\n+    pub impl<T:Owned> Drop for send_packet<T> {\n         fn finalize(&self) {\n             if self.p != None {\n                 let mut p = None;\n@@ -165,15 +165,15 @@ pub mod pipes {\n         }\n     }\n \n-    pub impl<T: Owned> send_packet<T> {\n+    pub impl<T:Owned> send_packet<T> {\n         fn unwrap() -> *packet<T> {\n             let mut p = None;\n             p <-> self.p;\n             option::unwrap(p)\n         }\n     }\n \n-    pub fn send_packet<T: Owned>(p: *packet<T>) -> send_packet<T> {\n+    pub fn send_packet<T:Owned>(p: *packet<T>) -> send_packet<T> {\n         send_packet {\n             p: Some(p)\n         }\n@@ -183,7 +183,7 @@ pub mod pipes {\n         mut p: Option<*packet<T>>,\n     }\n \n-    pub impl<T: Owned> Drop for recv_packet<T> {\n+    pub impl<T:Owned> Drop for recv_packet<T> {\n         fn finalize(&self) {\n             if self.p != None {\n                 let mut p = None;\n@@ -193,21 +193,21 @@ pub mod pipes {\n         }\n     }\n \n-    pub impl<T: Owned> recv_packet<T> {\n+    pub impl<T:Owned> recv_packet<T> {\n         fn unwrap() -> *packet<T> {\n             let mut p = None;\n             p <-> self.p;\n             option::unwrap(p)\n         }\n     }\n \n-    pub fn recv_packet<T: Owned>(p: *packet<T>) -> recv_packet<T> {\n+    pub fn recv_packet<T:Owned>(p: *packet<T>) -> recv_packet<T> {\n         recv_packet {\n             p: Some(p)\n         }\n     }\n \n-    pub fn entangle<T: Owned>() -> (send_packet<T>, recv_packet<T>) {\n+    pub fn entangle<T:Owned>() -> (send_packet<T>, recv_packet<T>) {\n         let p = packet();\n         (send_packet(p), recv_packet(p))\n     }"}, {"sha": "45c6b22544d9cb3e1c499b1d6105f7e8efe207b3", "filename": "src/test/run-pass/issue-2734.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2734.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -11,7 +11,7 @@\n trait hax { } \n impl<A> hax for A { } \n \n-fn perform_hax<T: &static>(x: @T) -> hax {\n+fn perform_hax<T:&static>(x: @T) -> hax {\n     x as hax \n }\n "}, {"sha": "7c87c6a31cde1a0c1d864794a0a5c84faac8febb", "filename": "src/test/run-pass/issue-2735.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -11,7 +11,7 @@\n trait hax { } \n impl<A> hax for A { } \n \n-fn perform_hax<T: &static>(x: @T) -> hax {\n+fn perform_hax<T:&static>(x: @T) -> hax {\n     x as hax \n }\n "}, {"sha": "579c4f9f1d124f26b18d2a921a3bb9b313ccd4f8", "filename": "src/test/run-pass/issue-2834.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2834.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-2834.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2834.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,7 +12,7 @@\n //\n \n proto! streamp (\n-    open:send<T: Owned> {\n+    open:send<T:Owned> {\n         data(T) -> open<T>\n     }\n )"}, {"sha": "b44d1cbb78d48a6dc986780e3480c19eb610950f", "filename": "src/test/run-pass/issue-3305.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-3305.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-3305.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3305.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -16,7 +16,7 @@ impl double for uint {\n     fn double() -> uint { self * 2u }\n }\n \n-fn is_equal<D: double>(x: @D, exp: uint) {\n+fn is_equal<D:double>(x: @D, exp: uint) {\n     assert x.double() == exp;\n }\n "}, {"sha": "1f9dd6e3b6f3cccb8848913492da682c34c36440", "filename": "src/test/run-pass/issue-333.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-333.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn quux<T: Copy>(x: T) -> T { let f = id::<T>; return f(x); }\n+fn quux<T:Copy>(x: T) -> T { let f = id::<T>; return f(x); }\n \n-fn id<T: Copy>(x: T) -> T { return x; }\n+fn id<T:Copy>(x: T) -> T { return x; }\n \n pub fn main() { assert (quux(10) == 10); }"}, {"sha": "e813cde7c2760bd63d26992d9648702aedd0df95", "filename": "src/test/run-pass/issue-3480.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-3480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-3480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3480.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n \n // xfail-test\n-type IMap<K: Copy, V: Copy> = ~[(K, V)];\n+type IMap<K:Copy,V:Copy> = ~[(K, V)];\n \n-trait ImmutableMap<K: Copy, V: Copy>\n+trait ImmutableMap<K:Copy,V:Copy>\n {\n     pure fn contains_key(key: K) -> bool;\n }\n \n-impl<K: Copy, V: Copy> IMap<K, V> : ImmutableMap<K, V>\n+impl<K:Copy,V:Copy> IMap<K, V> : ImmutableMap<K, V>\n {\n     pure fn contains_key(key: K) -> bool\n     {"}, {"sha": "69cd1a2a19d86f3d19c97659fab848dea1772f7f", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -18,7 +18,7 @@ use std::serialization::{Deserializable, deserialize};\n trait JD : Deserializable<json::Deserializer> { }\n //type JD = Deserializable<json::Deserializer>;\n \n-fn exec<T: JD>() {\n+fn exec<T:JD>() {\n     let doc = result::unwrap(json::from_str(\"\"));\n     let _v: T = deserialize(&json::Deserializer(doc));\n     fail!()"}, {"sha": "aa61a35d6e350dc1c4fcf1c7e62a197532207a3b", "filename": "src/test/run-pass/ivec-add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fivec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fivec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-add.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn double<T: Copy>(a: T) -> ~[T] { return ~[a] + ~[a]; }\n+fn double<T:Copy>(a: T) -> ~[T] { return ~[a] + ~[a]; }\n \n fn double_int(a: int) -> ~[int] { return ~[a] + ~[a]; }\n "}, {"sha": "5a3adc14e433baadb077eb2259840496d76f8c2d", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,11 +12,11 @@\n #[legacy_modes];\n \n trait vec_monad<A> {\n-    fn bind<B: Copy>(f: fn(A) -> ~[B]) -> ~[B];\n+    fn bind<B:Copy>(f: fn(A) -> ~[B]) -> ~[B];\n }\n \n impl<A> vec_monad<A> for ~[A] {\n-    fn bind<B: Copy>(f: fn(A) -> ~[B]) -> ~[B] {\n+    fn bind<B:Copy>(f: fn(A) -> ~[B]) -> ~[B] {\n         let mut r = ~[];\n         for self.each |elt| { r += f(*elt); }\n         r"}, {"sha": "88c317a3c0735f52321dae481d680a85ba076e3d", "filename": "src/test/run-pass/monomorphized-callees-with-ty-params-3314.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -14,17 +14,17 @@ trait Serializer {\n }\n \n trait Serializable {\n-    fn serialize<S: Serializer>(s: S);\n+    fn serialize<S:Serializer>(s: S);\n }\n \n impl Serializable for int {\n-    fn serialize<S: Serializer>(_s: S) { }\n+    fn serialize<S:Serializer>(_s: S) { }\n }\n \n struct F<A> { a: A }\n \n-impl<A: Copy Serializable> Serializable for F<A> {\n-    fn serialize<S: Serializer>(s: S) {\n+impl<A:Copy + Serializable> Serializable for F<A> {\n+    fn serialize<S:Serializer>(s: S) {\n         self.a.serialize(s);\n     }\n }"}, {"sha": "01e554ad04128c80357842b21006708fa554c873", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,9 +10,9 @@\n \n enum myvec<X> = ~[X];\n \n-fn myvec_deref<X: Copy>(mv: myvec<X>) -> ~[X] { return copy *mv; }\n+fn myvec_deref<X:Copy>(mv: myvec<X>) -> ~[X] { return copy *mv; }\n \n-fn myvec_elt<X: Copy>(mv: myvec<X>) -> X { return mv[0]; }\n+fn myvec_elt<X:Copy>(mv: myvec<X>) -> X { return mv[0]; }\n \n pub fn main() {\n     let mv = myvec(~[1, 2, 3]);"}, {"sha": "931c4cbad79c441ed74147262b0451f5369405ab", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -14,15 +14,15 @@ extern mod std;\n \n use std::list::*;\n \n-pure fn pure_length_go<T: Copy>(ls: @List<T>, acc: uint) -> uint {\n+pure fn pure_length_go<T:Copy>(ls: @List<T>, acc: uint) -> uint {\n     match *ls { Nil => { acc } Cons(_, tl) => { pure_length_go(tl, acc + 1u) } }\n }\n \n-pure fn pure_length<T: Copy>(ls: @List<T>) -> uint { pure_length_go(ls, 0u) }\n+pure fn pure_length<T:Copy>(ls: @List<T>) -> uint { pure_length_go(ls, 0u) }\n \n-pure fn nonempty_list<T: Copy>(ls: @List<T>) -> bool { pure_length(ls) > 0u }\n+pure fn nonempty_list<T:Copy>(ls: @List<T>) -> bool { pure_length(ls) > 0u }\n \n-fn safe_head<T: Copy>(ls: @List<T>) -> T {\n+fn safe_head<T:Copy>(ls: @List<T>) -> T {\n     assert !is_empty(ls);\n     return head(ls);\n }"}, {"sha": "0016d792c0d0f14f50e499b839b88c14da713e48", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -47,7 +47,7 @@ macro_rules! move_it (\n     { $x:expr } => { unsafe { let y = *ptr::addr_of(&($x)); y } }\n )\n \n-fn switch<T: Owned, U>(+endp: pipes::RecvPacket<T>,\n+fn switch<T:Owned,U>(+endp: pipes::RecvPacket<T>,\n                       f: fn(+v: Option<T>) -> U) -> U {\n     f(pipes::try_recv(endp))\n }"}, {"sha": "890599f9b8bf4d16eb177e51618555f822abb256", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -31,7 +31,7 @@ fn align(size: uint, align: uint) -> uint {\n \n enum ptr_visit_adaptor<V> = Inner<V>;\n \n-impl<V: TyVisitor movable_ptr> ptr_visit_adaptor<V> {\n+impl<V:TyVisitor + movable_ptr> ptr_visit_adaptor<V> {\n \n     #[inline(always)]\n     fn bump(sz: uint) {\n@@ -59,7 +59,7 @@ impl<V: TyVisitor movable_ptr> ptr_visit_adaptor<V> {\n \n }\n \n-impl<V: TyVisitor movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n+impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n \n     fn visit_bot(&self) -> bool {\n         self.align_to::<()>();"}, {"sha": "347c14538a10dd1004adbc48c364fb845cb68f8d", "filename": "src/test/run-pass/resource-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-generic.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -17,13 +17,13 @@ struct finish<T> {\n   arg: Arg<T>\n }\n \n-impl<T: Copy> Drop for finish<T> {\n+impl<T:Copy> Drop for finish<T> {\n     fn finalize(&self) {\n         (self.arg.fin)(self.arg.val);\n     }\n }\n \n-fn finish<T: Copy>(arg: Arg<T>) -> finish<T> {\n+fn finish<T:Copy>(arg: Arg<T>) -> finish<T> {\n     finish {\n         arg: arg\n     }"}, {"sha": "e70c72f550d0d7fb2e6e611ab27c8bf9b46319a0", "filename": "src/test/run-pass/ret-break-cont-in-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -21,7 +21,7 @@ fn iter<T>(v: ~[T], it: fn(T) -> bool) {\n     }\n }\n \n-fn find_pos<T:Eq Copy>(n: T, h: ~[T]) -> Option<uint> {\n+fn find_pos<T:Eq + Copy>(n: T, h: ~[T]) -> Option<uint> {\n     let mut i = 0u;\n     for iter(copy h) |e| {\n         if e == n { return Some(i); }"}, {"sha": "d493f23ba8400a4d16bfb25506212d3d927b2b02", "filename": "src/test/run-pass/ret-none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fret-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fret-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-none.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,6 +12,6 @@\n \n enum option<T> { none, some(T), }\n \n-fn f<T: Copy>() -> option<T> { return none; }\n+fn f<T:Copy>() -> option<T> { return none; }\n \n pub fn main() { f::<int>(); }"}, {"sha": "77f0614036941b646be7bb0383db3fa0e27b8e7a", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -13,7 +13,7 @@ use core::pipes::*;\n // tests that ctrl's type gets inferred properly\n type command<K, V> = {key: K, val: V};\n \n-fn cache_server<K: Owned, V: Owned>(c: Chan<Chan<command<K, V>>>) {\n+fn cache_server<K:Owned,V:Owned>(c: Chan<Chan<command<K, V>>>) {\n     let (ctrl_port, ctrl_chan) = stream();\n     c.send(ctrl_chan);\n }"}, {"sha": "2dc008931e4902f361c95a4990e071dbf4f6ada3", "filename": "src/test/run-pass/sendfn-generic-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -15,7 +15,7 @@ pub fn main() { test05(); }\n \n struct Pair<A,B> { a: A, b: B }\n \n-fn make_generic_record<A: Copy, B: Copy>(a: A, b: B) -> Pair<A,B> {\n+fn make_generic_record<A:Copy,B:Copy>(a: A, b: B) -> Pair<A,B> {\n     return Pair {a: a, b: b};\n }\n \n@@ -31,7 +31,7 @@ fn test05_start(&&f: fn~(&&v: float, &&v: ~str) -> Pair<float, ~str>) {\n     assert q.b == ~\"Ho\";\n }\n \n-fn spawn<A: Copy, B: Copy>(f: extern fn(fn~(A,B)->Pair<A,B>)) {\n+fn spawn<A:Copy,B:Copy>(f: extern fn(fn~(A,B)->Pair<A,B>)) {\n     let arg = fn~(a: A, b: B) -> Pair<A,B> {\n         return make_generic_record(a, b);\n     };"}, {"sha": "5cc54da28b22c5b3310cff2684cf57523011d1a7", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -41,13 +41,13 @@ impl uint_utils for uint {\n trait vec_utils<T> {\n     fn length_() -> uint;\n     fn iter_(f: fn(T));\n-    fn map_<U: Copy>(f: fn(T) -> U) -> ~[U];\n+    fn map_<U:Copy>(f: fn(T) -> U) -> ~[U];\n }\n \n impl<T> vec_utils<T> for ~[T] {\n     fn length_() -> uint { vec::len(self) }\n     fn iter_(f: fn(T)) { for self.each |x| { f(*x); } }\n-    fn map_<U: Copy>(f: fn(T) -> U) -> ~[U] {\n+    fn map_<U:Copy>(f: fn(T) -> U) -> ~[U] {\n         let mut r = ~[];\n         for self.each |elt| { r += ~[f(*elt)]; }\n         r"}, {"sha": "9a9533d7c8a3b84df7f259ddd2e016fab0e9d72b", "filename": "src/test/run-pass/static-method-in-trait-with-tps-intracrate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fstatic-method-in-trait-with-tps-intracrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fstatic-method-in-trait-with-tps-intracrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-in-trait-with-tps-intracrate.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,11 +12,11 @@ trait Deserializer {\n     fn read_int() -> int;\n }\n \n-trait Deserializable<D: Deserializer> {\n+trait Deserializable<D:Deserializer> {\n     static fn deserialize(d: &D) -> Self;\n }\n \n-impl<D: Deserializer> Deserializable<D> for int {\n+impl<D:Deserializer> Deserializable<D> for int {\n     static fn deserialize(d: &D) -> int {\n         return d.read_int();\n     }"}, {"sha": "d9461c48be8a84eb7808634171f4618da2cbc525", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -17,7 +17,7 @@ trait bool_like {\n     static fn select<A>(b: Self, +x1: A, +x2: A) -> A;\n }\n \n-fn andand<T: bool_like Copy>(x1: T, x2: T) -> T {\n+fn andand<T:bool_like + Copy>(x1: T, x2: T) -> T {\n     bool_like::select(x1, x2, x1)\n }\n \n@@ -70,7 +70,7 @@ fn map<T, IT: BaseIter<T>, U, BU: buildable<U>>\n     }\n }\n \n-fn seq_range<BT: buildable<int>>(lo: uint, hi: uint) -> BT {\n+fn seq_range<BT:buildable<int>>(lo: uint, hi: uint) -> BT {\n     do buildable::build_sized(hi-lo) |push| {\n         for uint::range(lo, hi) |i| {\n             push(i as int);"}, {"sha": "1775bba934c9394505458da39a4aa2b445a509c5", "filename": "src/test/run-pass/trait-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,7 +12,7 @@ trait connection {\n     fn read() -> int;\n }\n \n-trait connection_factory<C: connection> {\n+trait connection_factory<C:connection> {\n     fn create() -> C;\n }\n "}, {"sha": "e0e3c6e15975ce681e1eaf6b5f1dc8e5f8225537", "filename": "src/test/run-pass/trait-cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cast.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -21,7 +21,7 @@ trait to_str {\n     fn to_str() -> ~str;\n }\n \n-impl<T: to_str> to_str for Option<T> {\n+impl<T:to_str> to_str for Option<T> {\n     fn to_str() -> ~str {\n         match self {\n           None => { ~\"none\" }\n@@ -42,7 +42,7 @@ impl to_str for Tree {\n     }\n }\n \n-fn foo<T: to_str>(x: T) -> ~str { x.to_str() }\n+fn foo<T:to_str>(x: T) -> ~str { x.to_str() }\n \n pub fn main() {\n     let t1 = Tree(@TreeR{mut left: None,"}, {"sha": "be50b4340553cf5b385f1bcbe13bdf259db4fc77", "filename": "src/test/run-pass/trait-default-method-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -16,7 +16,7 @@ trait A {\n \n impl A for int { }\n \n-fn f<T: A>(i: T) {\n+fn f<T:A>(i: T) {\n     assert i.g() == 10;\n }\n "}, {"sha": "ff902490e7c27f208e640f2d66c2030af767a542", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -25,10 +25,10 @@ impl to_str for () {\n }\n \n trait map<T> {\n-    fn map<U: Copy>(f: fn(T) -> U) -> ~[U];\n+    fn map<U:Copy>(f: fn(T) -> U) -> ~[U];\n }\n impl<T> map<T> for ~[T] {\n-    fn map<U: Copy>(f: fn(T) -> U) -> ~[U] {\n+    fn map<U:Copy>(f: fn(T) -> U) -> ~[U] {\n         let mut r = ~[];\n         for self.each |x| { r += ~[f(*x)]; }\n         r\n@@ -38,7 +38,7 @@ impl<T> map<T> for ~[T] {\n fn foo<U, T: map<U>>(x: T) -> ~[~str] {\n     x.map(|_e| ~\"hi\" )\n }\n-fn bar<U: to_str, T: map<U>>(x: T) -> ~[~str] {\n+fn bar<U:to_str,T:map<U>>(x: T) -> ~[~str] {\n     x.map(|_e| _e.to_str() )\n }\n "}, {"sha": "c3333fa10ab17f0321b2aae7279a8aa8326da2ee", "filename": "src/test/run-pass/trait-inheritance-auto-xc-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc-2.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -18,9 +18,9 @@ use aux::{Foo, Bar, Baz, A};\n \n // We want to extend all Foo, Bar, Bazes to Quuxes\n pub trait Quux: Foo Bar Baz { }\n-impl<T: Foo Bar Baz> Quux for T { }\n+impl<T:Foo + Bar + Baz> Quux for T { }\n \n-fn f<T: Quux>(a: &T) {\n+fn f<T:Quux>(a: &T) {\n     assert a.f() == 10;\n     assert a.g() == 20;\n     assert a.h() == 30;"}, {"sha": "302076da7a2211e9ebb538eb6e243508d66b81bc", "filename": "src/test/run-pass/trait-inheritance-auto-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -21,7 +21,7 @@ impl Foo for A { fn f() -> int { 10 } }\n impl Bar for A { fn g() -> int { 20 } }\n impl Baz for A { fn h() -> int { 30 } }\n \n-fn f<T: Quux>(a: &T) {\n+fn f<T:Quux>(a: &T) {\n     assert a.f() == 10;\n     assert a.g() == 20;\n     assert a.h() == 30;"}, {"sha": "5d576193880e55430ed54e5126e8075cfa280676", "filename": "src/test/run-pass/trait-inheritance-auto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,7 +10,7 @@\n \n // Testing that this impl turns A into a Quux, because\n // A is already a Foo Bar Baz\n-impl<T: Foo Bar Baz> Quux for T { }\n+impl<T:Foo + Bar + Baz> Quux for T { }\n \n trait Foo { fn f() -> int; }\n trait Bar { fn g() -> int; }\n@@ -24,7 +24,7 @@ impl Foo for A { fn f() -> int { 10 } }\n impl Bar for A { fn g() -> int { 20 } }\n impl Baz for A { fn h() -> int { 30 } }\n \n-fn f<T: Quux>(a: &T) {\n+fn f<T:Quux>(a: &T) {\n     assert a.f() == 10;\n     assert a.g() == 20;\n     assert a.h() == 30;"}, {"sha": "11a0918ba78c0cb4a170db451a2411e34f6f48c3", "filename": "src/test/run-pass/trait-inheritance-call-bound-inherited2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-call-bound-inherited2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-call-bound-inherited2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-call-bound-inherited2.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -20,7 +20,7 @@ impl Baz for A { fn h() -> int { 30 } }\n \n // Call a function on Foo, given a T: Baz,\n // which is inherited via Bar\n-fn gg<T: Baz>(a: &T) -> int {\n+fn gg<T:Baz>(a: &T) -> int {\n     a.f()\n }\n "}, {"sha": "1d6e482309178f332810eb768907188cd9c33d11", "filename": "src/test/run-pass/trait-inheritance-diamond.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-diamond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-diamond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-diamond.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -22,7 +22,7 @@ impl B for S { fn b(&self) -> int { 20 } }\n impl C for S { fn c(&self) -> int { 30 } }\n impl D for S { fn d(&self) -> int { 40 } }\n \n-fn f<T: D>(x: &T) {\n+fn f<T:D>(x: &T) {\n     assert x.a() == 10;\n     assert x.b() == 20;\n     assert x.c() == 30;"}, {"sha": "ad4d3ebc0b577a2788d776b51be10e9da0b4eddd", "filename": "src/test/run-pass/trait-inheritance-multiple-inheritors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-multiple-inheritors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-multiple-inheritors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-multiple-inheritors.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -19,7 +19,7 @@ impl B for S { fn b(&self) -> int { 20 } }\n impl C for S { fn c(&self) -> int { 30 } }\n \n // Both B and C inherit from A\n-fn f<T: B C>(x: &T) {\n+fn f<T:B + C>(x: &T) {\n     assert x.a() == 10;\n     assert x.b() == 20;\n     assert x.c() == 30;"}, {"sha": "5b6a754488efbf8fb26113819e7986f8288bf68c", "filename": "src/test/run-pass/trait-inheritance-multiple-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-multiple-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-multiple-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-multiple-params.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -19,7 +19,7 @@ impl B for S { fn b(&self) -> int { 20 } }\n impl C for S { fn c(&self) -> int { 30 } }\n \n // Multiple type params, multiple levels of inheritance\n-fn f<X: A, Y: B, Z: C>(x: &X, y: &Y, z: &Z) {\n+fn f<X:A,Y:B,Z:C>(x: &X, y: &Y, z: &Z) {\n     assert x.a() == 10;\n     assert y.a() == 10;\n     assert y.b() == 20;"}, {"sha": "1d59f1fc19e135f892fec9a8654baa3f2c0e5abd", "filename": "src/test/run-pass/trait-inheritance-overloading-xc-exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -14,7 +14,7 @@\n extern mod trait_inheritance_overloading_xc;\n use trait_inheritance_overloading_xc::{MyNum, MyInt};\n \n-fn f<T:Copy MyNum>(x: T, y: T) -> (T, T, T) {\n+fn f<T:Copy + MyNum>(x: T, y: T) -> (T, T, T) {\n     return (x + y, x - y, x * y);\n }\n "}, {"sha": "08f3d41ddad9bafbb8cbaf426b1515d92ff52d2c", "filename": "src/test/run-pass/trait-inheritance-overloading.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -33,7 +33,7 @@ impl Eq for MyInt {\n \n impl MyNum for MyInt;\n \n-fn f<T:Copy MyNum>(x: T, y: T) -> (T, T, T) {\n+fn f<T:Copy + MyNum>(x: T, y: T) -> (T, T, T) {\n     return (x + y, x - y, x * y);\n }\n "}, {"sha": "8518137bbb8291ff9f3495ea87d75c548bbb369e", "filename": "src/test/run-pass/trait-inheritance-visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-visibility.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -15,11 +15,11 @@ mod traits {\n }\n \n trait Quux: traits::Foo { }\n-impl<T: traits::Foo> Quux for T { }\n+impl<T:traits::Foo> Quux for T { }\n \n // Foo is not in scope but because Quux is we can still access\n // Foo's methods on a Quux bound typaram\n-fn f<T: Quux>(x: &T) {\n+fn f<T:Quux>(x: &T) {\n     assert x.f() == 10;\n }\n "}, {"sha": "55a63e9099a9379c0dc02b7245821c4b159fd254", "filename": "src/test/run-pass/trait-inheritance2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-inheritance2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance2.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -21,7 +21,7 @@ impl Bar for A { fn g() -> int { 20 } }\n impl Baz for A { fn h() -> int { 30 } }\n impl Quux for A;\n \n-fn f<T: Quux Foo Bar Baz>(a: &T) {\n+fn f<T:Quux + Foo + Bar + Baz>(a: &T) {\n     assert a.f() == 10;\n     assert a.g() == 20;\n     assert a.h() == 30;"}, {"sha": "20e23c0fc58e762b35166d347d0b899d284351c6", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -24,7 +24,7 @@ impl to_str for int {\n     fn to_str() -> ~str { int::str(self) }\n }\n \n-impl<T: to_str> to_str for ~[T] {\n+impl<T:to_str> to_str for ~[T] {\n     fn to_str() -> ~str {\n         ~\"[\" + str::connect(vec::map(self, |e| e.to_str() ), ~\", \") + ~\"]\"\n     }\n@@ -34,12 +34,12 @@ pub fn main() {\n     assert 1.to_str() == ~\"1\";\n     assert (~[2, 3, 4]).to_str() == ~\"[2, 3, 4]\";\n \n-    fn indirect<T: to_str>(x: T) -> ~str {\n+    fn indirect<T:to_str>(x: T) -> ~str {\n         x.to_str() + ~\"!\"\n     }\n     assert indirect(~[10, 20]) == ~\"[10, 20]!\";\n \n-    fn indirect2<T: to_str>(x: T) -> ~str {\n+    fn indirect2<T:to_str>(x: T) -> ~str {\n         indirect(x)\n     }\n     assert indirect2(~[1]) == ~\"[1]!\";"}, {"sha": "684e0a8aaaed85ac876ba3c3df717b998763e17f", "filename": "src/test/run-pass/type-param-constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,8 +12,8 @@\n #[legacy_modes];\n \n fn p_foo<T>(pinned: T) { }\n-fn s_foo<T: Copy>(shared: T) { }\n-fn u_foo<T: Owned>(unique: T) { }\n+fn s_foo<T:Copy>(shared: T) { }\n+fn u_foo<T:Owned>(unique: T) { }\n \n struct r {\n   i: int,"}, {"sha": "dd86150b93bf9a5ff0caaca05073abdec34a267d", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -18,7 +18,7 @@ struct Pointy {\n     d : fn~() -> uint,\n }\n \n-fn make_uniq_closure<A:Owned Copy>(a: A) -> fn~() -> uint {\n+fn make_uniq_closure<A:Owned + Copy>(a: A) -> fn~() -> uint {\n     fn~() -> uint { ptr::addr_of(&a) as uint }\n }\n "}, {"sha": "d6992e4623fd061e85631021671ba44c2009b114", "filename": "src/test/run-pass/unique-assign-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Funique-assign-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Funique-assign-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-assign-generic.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<T: Copy>(t: T) -> T {\n+fn f<T:Copy>(t: T) -> T {\n     let t1 = t;\n     t1\n }"}, {"sha": "ab92b10a3320bdca772a6aa365119dc09ec00a79", "filename": "src/test/run-pass/unique-generic-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Funique-generic-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Funique-generic-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-generic-assign.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -10,7 +10,7 @@\n \n // Issue #976\n \n-fn f<T: Copy>(x: ~T) {\n+fn f<T:Copy>(x: ~T) {\n     let _x2 = x;\n }\n pub fn main() { }"}, {"sha": "180ce716dcc9d6e5e42998e834a59b39e99fe18d", "filename": "src/test/run-pass/unique-kinds.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02da4ecdef0bc810357db3566f97e9cc1f24c46/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-kinds.rs?ref=a02da4ecdef0bc810357db3566f97e9cc1f24c46", "patch": "@@ -12,11 +12,11 @@ use cmp::Eq;\n \n fn sendable() {\n \n-    fn f<T: Owned Eq>(i: T, j: T) {\n+    fn f<T:Owned + Eq>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<T: Owned Eq>(i: T, j: T) {\n+    fn g<T:Owned + Eq>(i: T, j: T) {\n         assert i != j;\n     }\n \n@@ -30,11 +30,11 @@ fn sendable() {\n \n fn copyable() {\n \n-    fn f<T: Copy Eq>(i: T, j: T) {\n+    fn f<T:Copy + Eq>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<T: Copy Eq>(i: T, j: T) {\n+    fn g<T:Copy + Eq>(i: T, j: T) {\n         assert i != j;\n     }\n \n@@ -48,11 +48,11 @@ fn copyable() {\n \n fn noncopyable() {\n \n-    fn f<T: Eq>(i: T, j: T) {\n+    fn f<T:Eq>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<T: Eq>(i: T, j: T) {\n+    fn g<T:Eq>(i: T, j: T) {\n         assert i != j;\n     }\n "}]}