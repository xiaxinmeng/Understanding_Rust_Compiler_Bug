{"sha": "5d44d5456f2bc93beef26372b752d5b8613894a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNDRkNTQ1NmYyYmM5M2JlZWYyNjM3MmI3NTJkNWI4NjEzODk0YTY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-07-13T14:12:07Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-08-16T18:34:40Z"}, "message": "rustc_typeck: construct {Closure,Generator}Substs more directly.", "tree": {"sha": "78007afd2d96ea43999abd8a12e66e89d1d47020", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78007afd2d96ea43999abd8a12e66e89d1d47020"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d44d5456f2bc93beef26372b752d5b8613894a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d44d5456f2bc93beef26372b752d5b8613894a6", "html_url": "https://github.com/rust-lang/rust/commit/5d44d5456f2bc93beef26372b752d5b8613894a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d44d5456f2bc93beef26372b752d5b8613894a6/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a4fb355c6ce4e534e0998d83b68591bbe234ddb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a4fb355c6ce4e534e0998d83b68591bbe234ddb", "html_url": "https://github.com/rust-lang/rust/commit/7a4fb355c6ce4e534e0998d83b68591bbe234ddb"}], "stats": {"total": 200, "additions": 118, "deletions": 82}, "files": [{"sha": "dacf242118122c2f835defd9c7ce125b24c88c29", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d44d5456f2bc93beef26372b752d5b8613894a6/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d44d5456f2bc93beef26372b752d5b8613894a6/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=5d44d5456f2bc93beef26372b752d5b8613894a6", "patch": "@@ -60,6 +60,7 @@ pub use self::sty::{Binder, BoundTy, BoundTyKind, BoundVar, DebruijnIndex, INNER\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::{CanonicalPolyFnSig, FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, TypeAndMut, UpvarSubsts};\n+pub use self::sty::{ClosureSubstsParts, GeneratorSubstsParts};\n pub use self::sty::{ConstVid, FloatVid, IntVid, RegionVid, TyVid};\n pub use self::sty::{ExistentialPredicate, InferTy, ParamConst, ParamTy, ProjectionTy};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection};"}, {"sha": "71da5506315af66a126abc01d510350cd5e1f4e5", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 67, "deletions": 27, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5d44d5456f2bc93beef26372b752d5b8613894a6/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d44d5456f2bc93beef26372b752d5b8613894a6/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=5d44d5456f2bc93beef26372b752d5b8613894a6", "patch": "@@ -325,24 +325,39 @@ pub struct ClosureSubsts<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n-/// Struct returned by `split()`. Note that these are subslices of the\n-/// parent slice and not canonical substs themselves.\n-struct SplitClosureSubsts<'tcx> {\n-    parent: &'tcx [GenericArg<'tcx>],\n-    closure_kind_ty: GenericArg<'tcx>,\n-    closure_sig_as_fn_ptr_ty: GenericArg<'tcx>,\n-    tupled_upvars_ty: GenericArg<'tcx>,\n+/// Struct returned by `split()`.\n+pub struct ClosureSubstsParts<'tcx, T> {\n+    pub parent_substs: &'tcx [GenericArg<'tcx>],\n+    pub closure_kind_ty: T,\n+    pub closure_sig_as_fn_ptr_ty: T,\n+    pub tupled_upvars_ty: T,\n }\n \n impl<'tcx> ClosureSubsts<'tcx> {\n-    /// Divides the closure substs into their respective\n-    /// components. Single source of truth with respect to the\n-    /// ordering.\n-    fn split(self) -> SplitClosureSubsts<'tcx> {\n+    /// Construct `ClosureSubsts` from `ClosureSubstsParts`, containing `Substs`\n+    /// for the closure parent, alongside additional closure-specific components.\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        parts: ClosureSubstsParts<'tcx, Ty<'tcx>>,\n+    ) -> ClosureSubsts<'tcx> {\n+        ClosureSubsts {\n+            substs: tcx.mk_substs(\n+                parts.parent_substs.iter().copied().chain(\n+                    [parts.closure_kind_ty, parts.closure_sig_as_fn_ptr_ty, parts.tupled_upvars_ty]\n+                        .iter()\n+                        .map(|&ty| ty.into()),\n+                ),\n+            ),\n+        }\n+    }\n+\n+    /// Divides the closure substs into their respective components.\n+    /// The ordering assumed here must match that used by `ClosureSubsts::new` above.\n+    fn split(self) -> ClosureSubstsParts<'tcx, GenericArg<'tcx>> {\n         match self.substs[..] {\n-            [ref parent @ .., closure_kind_ty, closure_sig_as_fn_ptr_ty, tupled_upvars_ty] => {\n-                SplitClosureSubsts {\n-                    parent,\n+            [ref parent_substs @ .., closure_kind_ty, closure_sig_as_fn_ptr_ty, tupled_upvars_ty] => {\n+                ClosureSubstsParts {\n+                    parent_substs,\n                     closure_kind_ty,\n                     closure_sig_as_fn_ptr_ty,\n                     tupled_upvars_ty,\n@@ -363,7 +378,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n \n     /// Returns the substitutions of the closure's parent.\n     pub fn parent_substs(self) -> &'tcx [GenericArg<'tcx>] {\n-        self.split().parent\n+        self.split().parent_substs\n     }\n \n     #[inline]\n@@ -418,21 +433,46 @@ pub struct GeneratorSubsts<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n-struct SplitGeneratorSubsts<'tcx> {\n-    parent: &'tcx [GenericArg<'tcx>],\n-    resume_ty: GenericArg<'tcx>,\n-    yield_ty: GenericArg<'tcx>,\n-    return_ty: GenericArg<'tcx>,\n-    witness: GenericArg<'tcx>,\n-    tupled_upvars_ty: GenericArg<'tcx>,\n+pub struct GeneratorSubstsParts<'tcx, T> {\n+    pub parent_substs: &'tcx [GenericArg<'tcx>],\n+    pub resume_ty: T,\n+    pub yield_ty: T,\n+    pub return_ty: T,\n+    pub witness: T,\n+    pub tupled_upvars_ty: T,\n }\n \n impl<'tcx> GeneratorSubsts<'tcx> {\n-    fn split(self) -> SplitGeneratorSubsts<'tcx> {\n+    /// Construct `GeneratorSubsts` from `GeneratorSubstsParts`, containing `Substs`\n+    /// for the generator parent, alongside additional generator-specific components.\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        parts: GeneratorSubstsParts<'tcx, Ty<'tcx>>,\n+    ) -> GeneratorSubsts<'tcx> {\n+        GeneratorSubsts {\n+            substs: tcx.mk_substs(\n+                parts.parent_substs.iter().copied().chain(\n+                    [\n+                        parts.resume_ty,\n+                        parts.yield_ty,\n+                        parts.return_ty,\n+                        parts.witness,\n+                        parts.tupled_upvars_ty,\n+                    ]\n+                    .iter()\n+                    .map(|&ty| ty.into()),\n+                ),\n+            ),\n+        }\n+    }\n+\n+    /// Divides the generator substs into their respective components.\n+    /// The ordering assumed here must match that used by `GeneratorSubsts::new` above.\n+    fn split(self) -> GeneratorSubstsParts<'tcx, GenericArg<'tcx>> {\n         match self.substs[..] {\n-            [ref parent @ .., resume_ty, yield_ty, return_ty, witness, tupled_upvars_ty] => {\n-                SplitGeneratorSubsts {\n-                    parent,\n+            [ref parent_substs @ .., resume_ty, yield_ty, return_ty, witness, tupled_upvars_ty] => {\n+                GeneratorSubstsParts {\n+                    parent_substs,\n                     resume_ty,\n                     yield_ty,\n                     return_ty,\n@@ -455,7 +495,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n \n     /// Returns the substitutions of the generator's parent.\n     pub fn parent_substs(self) -> &'tcx [GenericArg<'tcx>] {\n-        self.split().parent\n+        self.split().parent_substs\n     }\n \n     /// This describes the types that can be contained in a generator."}, {"sha": "c7f9e9d63e03c576a21a595dd72144437b5d5040", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 50, "deletions": 55, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5d44d5456f2bc93beef26372b752d5b8613894a6/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d44d5456f2bc93beef26372b752d5b8613894a6/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5d44d5456f2bc93beef26372b752d5b8613894a6", "patch": "@@ -11,7 +11,7 @@ use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::{self, GenericParamDefKind, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n@@ -76,60 +76,44 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let generator_types =\n             check_fn(self, self.param_env, liberated_sig, decl, expr.hir_id, body, gen).1;\n \n-        let base_substs = InternalSubsts::identity_for_item(\n+        let parent_substs = InternalSubsts::identity_for_item(\n             self.tcx,\n             self.tcx.closure_base_def_id(expr_def_id.to_def_id()),\n         );\n-        // HACK(eddyb) this hardcodes indices into substs but it should rely on\n-        // `ClosureSubsts` and `GeneratorSubsts` providing constructors, instead.\n-        // That would also remove the need for most of the inference variables,\n-        // as they immediately unified with the actual type below, including\n-        // the `InferCtxt::closure_sig` and `ClosureSubsts::sig_ty` methods.\n-        let tupled_upvars_idx = base_substs.len() + if generator_types.is_some() { 4 } else { 2 };\n-        let substs =\n-            base_substs.extend_to(self.tcx, expr_def_id.to_def_id(), |param, _| match param.kind {\n-                GenericParamDefKind::Lifetime => span_bug!(expr.span, \"closure has lifetime param\"),\n-                GenericParamDefKind::Type { .. } => if param.index as usize == tupled_upvars_idx {\n-                    self.tcx.mk_tup(self.tcx.upvars_mentioned(expr_def_id).iter().flat_map(\n-                        |upvars| {\n-                            upvars.iter().map(|(&var_hir_id, _)| {\n-                                // Create type variables (for now) to represent the transformed\n-                                // types of upvars. These will be unified during the upvar\n-                                // inference phase (`upvar.rs`).\n-                                self.infcx.next_ty_var(TypeVariableOrigin {\n-                                    // FIXME(eddyb) distinguish upvar inference variables from the rest.\n-                                    kind: TypeVariableOriginKind::ClosureSynthetic,\n-                                    span: self.tcx.hir().span(var_hir_id),\n-                                })\n-                            })\n-                        },\n-                    ))\n-                } else {\n-                    // Create type variables (for now) to represent the various\n-                    // pieces of information kept in `{Closure,Generic}Substs`.\n-                    // They will either be unified below, or later during the upvar\n-                    // inference phase (`upvar.rs`)\n+\n+        let tupled_upvars_ty =\n+            self.tcx.mk_tup(self.tcx.upvars_mentioned(expr_def_id).iter().flat_map(|upvars| {\n+                upvars.iter().map(|(&var_hir_id, _)| {\n+                    // Create type variables (for now) to represent the transformed\n+                    // types of upvars. These will be unified during the upvar\n+                    // inference phase (`upvar.rs`).\n                     self.infcx.next_ty_var(TypeVariableOrigin {\n+                        // FIXME(eddyb) distinguish upvar inference variables from the rest.\n                         kind: TypeVariableOriginKind::ClosureSynthetic,\n-                        span: expr.span,\n+                        span: self.tcx.hir().span(var_hir_id),\n                     })\n-                }\n-                .into(),\n-                GenericParamDefKind::Const => span_bug!(expr.span, \"closure has const param\"),\n-            });\n+                })\n+            }));\n+\n         if let Some(GeneratorTypes { resume_ty, yield_ty, interior, movability }) = generator_types\n         {\n-            let generator_substs = substs.as_generator();\n-            self.demand_eqtype(expr.span, resume_ty, generator_substs.resume_ty());\n-            self.demand_eqtype(expr.span, yield_ty, generator_substs.yield_ty());\n-            self.demand_eqtype(expr.span, liberated_sig.output(), generator_substs.return_ty());\n-            self.demand_eqtype(expr.span, interior, generator_substs.witness());\n-\n-            // HACK(eddyb) this forces the types equated above into `substs` but\n-            // it should rely on `GeneratorSubsts` providing a constructor, instead.\n-            let substs = self.resolve_vars_if_possible(&substs);\n+            let generator_substs = ty::GeneratorSubsts::new(\n+                self.tcx,\n+                ty::GeneratorSubstsParts {\n+                    parent_substs,\n+                    resume_ty,\n+                    yield_ty,\n+                    return_ty: liberated_sig.output(),\n+                    witness: interior,\n+                    tupled_upvars_ty,\n+                },\n+            );\n \n-            return self.tcx.mk_generator(expr_def_id.to_def_id(), substs, movability);\n+            return self.tcx.mk_generator(\n+                expr_def_id.to_def_id(),\n+                generator_substs.substs,\n+                movability,\n+            );\n         }\n \n         // Tuple up the arguments and insert the resulting function type into\n@@ -149,18 +133,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expr_def_id, sig, opt_kind\n         );\n \n-        let sig_fn_ptr_ty = self.tcx.mk_fn_ptr(sig);\n-        self.demand_eqtype(expr.span, sig_fn_ptr_ty, substs.as_closure().sig_as_fn_ptr_ty());\n+        let closure_kind_ty = match opt_kind {\n+            Some(kind) => kind.to_ty(self.tcx),\n \n-        if let Some(kind) = opt_kind {\n-            self.demand_eqtype(expr.span, kind.to_ty(self.tcx), substs.as_closure().kind_ty());\n-        }\n+            // Create a type variable (for now) to represent the closure kind.\n+            // It will be unified during the upvar inference phase (`upvar.rs`)\n+            None => self.infcx.next_ty_var(TypeVariableOrigin {\n+                // FIXME(eddyb) distinguish closure kind inference variables from the rest.\n+                kind: TypeVariableOriginKind::ClosureSynthetic,\n+                span: expr.span,\n+            }),\n+        };\n \n-        // HACK(eddyb) this forces the types equated above into `substs` but\n-        // it should rely on `ClosureSubsts` providing a constructor, instead.\n-        let substs = self.resolve_vars_if_possible(&substs);\n+        let closure_substs = ty::ClosureSubsts::new(\n+            self.tcx,\n+            ty::ClosureSubstsParts {\n+                parent_substs,\n+                closure_kind_ty,\n+                closure_sig_as_fn_ptr_ty: self.tcx.mk_fn_ptr(sig),\n+                tupled_upvars_ty,\n+            },\n+        );\n \n-        let closure_type = self.tcx.mk_closure(expr_def_id.to_def_id(), substs);\n+        let closure_type = self.tcx.mk_closure(expr_def_id.to_def_id(), closure_substs.substs);\n \n         debug!(\"check_closure: expr.hir_id={:?} closure_type={:?}\", expr.hir_id, closure_type);\n "}]}