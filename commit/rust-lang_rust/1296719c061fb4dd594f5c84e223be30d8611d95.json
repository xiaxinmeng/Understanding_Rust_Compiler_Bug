{"sha": "1296719c061fb4dd594f5c84e223be30d8611d95", "node_id": "C_kwDOAAsO6NoAKDEyOTY3MTljMDYxZmI0ZGQ1OTRmNWM4NGUyMjNiZTMwZDg2MTFkOTU", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-10-21T13:36:35Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-11-10T14:10:19Z"}, "message": "no overlap errors after failing the orphan check", "tree": {"sha": "df684d7c922747ef26f40b1d7b7d8b95e319e969", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df684d7c922747ef26f40b1d7b7d8b95e319e969"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1296719c061fb4dd594f5c84e223be30d8611d95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1296719c061fb4dd594f5c84e223be30d8611d95", "html_url": "https://github.com/rust-lang/rust/commit/1296719c061fb4dd594f5c84e223be30d8611d95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1296719c061fb4dd594f5c84e223be30d8611d95/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "800a156c1ef0c16eb80f57536d96fbf6629fb3b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/800a156c1ef0c16eb80f57536d96fbf6629fb3b1", "html_url": "https://github.com/rust-lang/rust/commit/800a156c1ef0c16eb80f57536d96fbf6629fb3b1"}], "stats": {"total": 993, "additions": 496, "deletions": 497}, "files": [{"sha": "9a58009a173d4df85b4d837bd16b06389170fead", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -822,6 +822,14 @@ rustc_queries! {\n         desc { \"check for overlap between inherent impls defined in this crate\" }\n     }\n \n+    /// Checks whether all impls in the crate pass the overlap check, returning\n+    /// which impls fail it. If all impls are correct, the returned slice is empty.\n+    query orphan_check_crate(_: ()) -> &'tcx [LocalDefId] {\n+        desc {\n+            \"checking whether the immpl in the this crate follow the orphan rules\",\n+        }\n+    }\n+\n     /// Check whether the function has any recursion that could cause the inliner to trigger\n     /// a cycle. Returns the call stack causing the cycle. The call stack does not contain the\n     /// current function, just all intermediate functions.\n@@ -1056,11 +1064,6 @@ rustc_queries! {\n     }\n \n     /// Return all `impl` blocks in the current crate.\n-    ///\n-    /// To allow caching this between crates, you must pass in [`LOCAL_CRATE`] as the crate number.\n-    /// Passing in any other crate will cause an ICE.\n-    ///\n-    /// [`LOCAL_CRATE`]: rustc_hir::def_id::LOCAL_CRATE\n     query all_local_trait_impls(_: ()) -> &'tcx BTreeMap<DefId, Vec<LocalDefId>> {\n         desc { \"local trait impls\" }\n     }"}, {"sha": "96ab399424e20d45e49c5b1d21bd5c6e64f0c066", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -443,8 +443,12 @@ fn report_conflicting_impls(\n     match used_to_be_allowed {\n         None => {\n             sg.has_errored = true;\n-            let err = struct_span_err!(tcx.sess, impl_span, E0119, \"\");\n-            decorate(LintDiagnosticBuilder::new(err));\n+            if overlap.with_impl.is_local() || !tcx.orphan_check_crate(()).contains(&impl_def_id) {\n+                let err = struct_span_err!(tcx.sess, impl_span, E0119, \"\");\n+                decorate(LintDiagnosticBuilder::new(err));\n+            } else {\n+                tcx.sess.delay_span_bug(impl_span, \"impl should have failed the orphan check\");\n+            }\n         }\n         Some(kind) => {\n             let lint = match kind {"}, {"sha": "377ebf1fe2a9f5fdad1b5a23e4ebc4492182d594", "filename": "compiler/rustc_typeck/src/coherence/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -168,13 +168,15 @@ pub fn provide(providers: &mut Providers) {\n     use self::builtin::coerce_unsized_info;\n     use self::inherent_impls::{crate_inherent_impls, inherent_impls};\n     use self::inherent_impls_overlap::crate_inherent_impls_overlap_check;\n+    use self::orphan::orphan_check_crate;\n \n     *providers = Providers {\n         coherent_trait,\n         crate_inherent_impls,\n         inherent_impls,\n         crate_inherent_impls_overlap_check,\n         coerce_unsized_info,\n+        orphan_check_crate,\n         ..*providers\n     };\n }\n@@ -195,13 +197,13 @@ fn coherent_trait(tcx: TyCtxt<'_>, def_id: DefId) {\n }\n \n pub fn check_coherence(tcx: TyCtxt<'_>) {\n+    tcx.sess.time(\"unsafety_checking\", || unsafety::check(tcx));\n+    tcx.ensure().orphan_check_crate(());\n+\n     for &trait_def_id in tcx.all_local_trait_impls(()).keys() {\n         tcx.ensure().coherent_trait(trait_def_id);\n     }\n \n-    tcx.sess.time(\"unsafety_checking\", || unsafety::check(tcx));\n-    tcx.sess.time(\"orphan_checking\", || orphan::check(tcx));\n-\n     // these queries are executed for side-effects (error reporting):\n     tcx.ensure().crate_inherent_impls(());\n     tcx.ensure().crate_inherent_impls_overlap_check(());"}, {"sha": "b450d3f6c08ab98b04f1d622855b9ed10de1ffda", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 240, "deletions": 224, "changes": 464, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -2,250 +2,266 @@\n //! crate or pertains to a type defined in this crate.\n \n use rustc_errors::struct_span_err;\n+use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::def_id::LocalDefId;\n+use rustc_span::Span;\n use rustc_trait_selection::traits;\n \n-pub fn check(tcx: TyCtxt<'_>) {\n-    let mut orphan = OrphanChecker { tcx };\n-    tcx.hir().visit_all_item_likes(&mut orphan);\n+pub(super) fn orphan_check_crate(tcx: TyCtxt<'_>, (): ()) -> &[LocalDefId] {\n+    let mut errors = Vec::new();\n+    for (_trait, impls_of_trait) in tcx.all_local_trait_impls(()) {\n+        for &impl_of_trait in impls_of_trait {\n+            match orphan_check_impl(tcx, impl_of_trait) {\n+                Ok(()) => {}\n+                Err(ErrorReported) => errors.push(impl_of_trait),\n+            }\n+        }\n+    }\n+    tcx.arena.alloc_slice(&errors)\n }\n \n-struct OrphanChecker<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n+#[instrument(skip(tcx), level = \"debug\")]\n+fn orphan_check_impl(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorReported> {\n+    let trait_ref = tcx.impl_trait_ref(def_id).unwrap();\n+    let trait_def_id = trait_ref.def_id;\n \n-impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n-    /// Checks exactly one impl for orphan rules and other such\n-    /// restrictions. In this fn, it can happen that multiple errors\n-    /// apply to a specific impl, so just return after reporting one\n-    /// to prevent inundating the user with a bunch of similar error\n-    /// reports.\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        // \"Trait\" impl\n-        if let hir::ItemKind::Impl(hir::Impl {\n-            generics, of_trait: Some(ref tr), self_ty, ..\n-        }) = &item.kind\n-        {\n-            debug!(\n-                \"coherence2::orphan check: trait impl {}\",\n-                self.tcx.hir().node_to_string(item.hir_id())\n-            );\n-            let trait_ref = self.tcx.impl_trait_ref(item.def_id).unwrap();\n-            let trait_def_id = trait_ref.def_id;\n-            let sm = self.tcx.sess.source_map();\n-            let sp = sm.guess_head_span(item.span);\n-            match traits::orphan_check(self.tcx, item.def_id.to_def_id()) {\n-                Ok(()) => {}\n-                Err(traits::OrphanCheckErr::NonLocalInputType(tys)) => {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        sp,\n-                        E0117,\n-                        \"only traits defined in the current crate can be implemented for \\\n-                         arbitrary types\"\n-                    );\n-                    err.span_label(sp, \"impl doesn't use only types from inside the current crate\");\n-                    for (ty, is_target_ty) in &tys {\n-                        let mut ty = *ty;\n-                        self.tcx.infer_ctxt().enter(|infcx| {\n-                            // Remove the lifetimes unnecessary for this error.\n-                            ty = infcx.freshen(ty);\n-                        });\n-                        ty = match ty.kind() {\n-                            // Remove the type arguments from the output, as they are not relevant.\n-                            // You can think of this as the reverse of `resolve_vars_if_possible`.\n-                            // That way if we had `Vec<MyType>`, we will properly attribute the\n-                            // problem to `Vec<T>` and avoid confusing the user if they were to see\n-                            // `MyType` in the error.\n-                            ty::Adt(def, _) => self.tcx.mk_adt(def, ty::List::empty()),\n-                            _ => ty,\n-                        };\n-                        let this = \"this\".to_string();\n-                        let (ty, postfix) = match &ty.kind() {\n-                            ty::Slice(_) => (this, \" because slices are always foreign\"),\n-                            ty::Array(..) => (this, \" because arrays are always foreign\"),\n-                            ty::Tuple(..) => (this, \" because tuples are always foreign\"),\n-                            _ => (format!(\"`{}`\", ty), \"\"),\n-                        };\n-                        let msg = format!(\"{} is not defined in the current crate{}\", ty, postfix);\n-                        if *is_target_ty {\n-                            // Point at `D<A>` in `impl<A, B> for C<B> in D<A>`\n-                            err.span_label(self_ty.span, &msg);\n-                        } else {\n-                            // Point at `C<B>` in `impl<A, B> for C<B> in D<A>`\n-                            err.span_label(tr.path.span, &msg);\n-                        }\n-                    }\n-                    err.note(\"define and implement a trait or new type instead\");\n-                    err.emit();\n-                    return;\n-                }\n-                Err(traits::OrphanCheckErr::UncoveredTy(param_ty, local_type)) => {\n-                    let mut sp = sp;\n-                    for param in generics.params {\n-                        if param.name.ident().to_string() == param_ty.to_string() {\n-                            sp = param.span;\n-                        }\n-                    }\n+    let item = tcx.hir().item(hir::ItemId { def_id });\n+    let impl_ = match item.kind {\n+        hir::ItemKind::Impl(ref impl_) => impl_,\n+        _ => bug!(\"{:?} is not an impl: {:?}\", def_id, item),\n+    };\n+    let sp = tcx.sess.source_map().guess_head_span(item.span);\n+    let tr = impl_.of_trait.as_ref().unwrap();\n+    match traits::orphan_check(tcx, item.def_id.to_def_id()) {\n+        Ok(()) => {}\n+        Err(err) => emit_orphan_check_error(\n+            tcx,\n+            sp,\n+            tr.path.span,\n+            impl_.self_ty.span,\n+            &impl_.generics,\n+            err,\n+        )?,\n+    }\n+\n+    // In addition to the above rules, we restrict impls of auto traits\n+    // so that they can only be implemented on nominal types, such as structs,\n+    // enums or foreign types. To see why this restriction exists, consider the\n+    // following example (#22978). Imagine that crate A defines an auto trait\n+    // `Foo` and a fn that operates on pairs of types:\n+    //\n+    // ```\n+    // // Crate A\n+    // auto trait Foo { }\n+    // fn two_foos<A:Foo,B:Foo>(..) {\n+    //     one_foo::<(A,B)>(..)\n+    // }\n+    // fn one_foo<T:Foo>(..) { .. }\n+    // ```\n+    //\n+    // This type-checks fine; in particular the fn\n+    // `two_foos` is able to conclude that `(A,B):Foo`\n+    // because `A:Foo` and `B:Foo`.\n+    //\n+    // Now imagine that crate B comes along and does the following:\n+    //\n+    // ```\n+    // struct A { }\n+    // struct B { }\n+    // impl Foo for A { }\n+    // impl Foo for B { }\n+    // impl !Send for (A, B) { }\n+    // ```\n+    //\n+    // This final impl is legal according to the orphan\n+    // rules, but it invalidates the reasoning from\n+    // `two_foos` above.\n+    debug!(\n+        \"trait_ref={:?} trait_def_id={:?} trait_is_auto={}\",\n+        trait_ref,\n+        trait_def_id,\n+        tcx.trait_is_auto(trait_def_id)\n+    );\n+\n+    if tcx.trait_is_auto(trait_def_id) && !trait_def_id.is_local() {\n+        let self_ty = trait_ref.self_ty();\n+        let opt_self_def_id = match *self_ty.kind() {\n+            ty::Adt(self_def, _) => Some(self_def.did),\n+            ty::Foreign(did) => Some(did),\n+            _ => None,\n+        };\n \n-                    match local_type {\n-                        Some(local_type) => {\n-                            struct_span_err!(\n-                                self.tcx.sess,\n-                                sp,\n-                                E0210,\n-                                \"type parameter `{}` must be covered by another type \\\n-                                when it appears before the first local type (`{}`)\",\n-                                param_ty,\n-                                local_type\n-                            )\n-                            .span_label(\n-                                sp,\n-                                format!(\n-                                    \"type parameter `{}` must be covered by another type \\\n-                                when it appears before the first local type (`{}`)\",\n-                                    param_ty, local_type\n-                                ),\n-                            )\n-                            .note(\n-                                \"implementing a foreign trait is only possible if at \\\n-                                    least one of the types for which it is implemented is local, \\\n-                                    and no uncovered type parameters appear before that first \\\n-                                    local type\",\n-                            )\n-                            .note(\n-                                \"in this case, 'before' refers to the following order: \\\n-                                    `impl<..> ForeignTrait<T1, ..., Tn> for T0`, \\\n-                                    where `T0` is the first and `Tn` is the last\",\n-                            )\n-                            .emit();\n-                        }\n-                        None => {\n-                            struct_span_err!(\n-                                self.tcx.sess,\n-                                sp,\n-                                E0210,\n-                                \"type parameter `{}` must be used as the type parameter for some \\\n-                                local type (e.g., `MyStruct<{}>`)\",\n-                                param_ty,\n-                                param_ty\n-                            ).span_label(sp, format!(\n-                                \"type parameter `{}` must be used as the type parameter for some \\\n-                                local type\",\n-                                param_ty,\n-                            )).note(\"implementing a foreign trait is only possible if at \\\n-                                    least one of the types for which it is implemented is local\"\n-                            ).note(\"only traits defined in the current crate can be \\\n-                                    implemented for a type parameter\"\n-                            ).emit();\n-                        }\n-                    };\n-                    return;\n+        let msg = match opt_self_def_id {\n+            // We only want to permit nominal types, but not *all* nominal types.\n+            // They must be local to the current crate, so that people\n+            // can't do `unsafe impl Send for Rc<SomethingLocal>` or\n+            // `impl !Send for Box<SomethingLocalAndSend>`.\n+            Some(self_def_id) => {\n+                if self_def_id.is_local() {\n+                    None\n+                } else {\n+                    Some((\n+                        format!(\n+                            \"cross-crate traits with a default impl, like `{}`, \\\n+                                    can only be implemented for a struct/enum type \\\n+                                    defined in the current crate\",\n+                            tcx.def_path_str(trait_def_id)\n+                        ),\n+                        \"can't implement cross-crate trait for type in another crate\",\n+                    ))\n                 }\n             }\n+            _ => Some((\n+                format!(\n+                    \"cross-crate traits with a default impl, like `{}`, can \\\n+                                only be implemented for a struct/enum type, not `{}`\",\n+                    tcx.def_path_str(trait_def_id),\n+                    self_ty\n+                ),\n+                \"can't implement cross-crate trait with a default impl for \\\n+                        non-struct/enum type\",\n+            )),\n+        };\n \n-            // In addition to the above rules, we restrict impls of auto traits\n-            // so that they can only be implemented on nominal types, such as structs,\n-            // enums or foreign types. To see why this restriction exists, consider the\n-            // following example (#22978). Imagine that crate A defines an auto trait\n-            // `Foo` and a fn that operates on pairs of types:\n-            //\n-            // ```\n-            // // Crate A\n-            // auto trait Foo { }\n-            // fn two_foos<A:Foo,B:Foo>(..) {\n-            //     one_foo::<(A,B)>(..)\n-            // }\n-            // fn one_foo<T:Foo>(..) { .. }\n-            // ```\n-            //\n-            // This type-checks fine; in particular the fn\n-            // `two_foos` is able to conclude that `(A,B):Foo`\n-            // because `A:Foo` and `B:Foo`.\n-            //\n-            // Now imagine that crate B comes along and does the following:\n-            //\n-            // ```\n-            // struct A { }\n-            // struct B { }\n-            // impl Foo for A { }\n-            // impl Foo for B { }\n-            // impl !Send for (A, B) { }\n-            // ```\n-            //\n-            // This final impl is legal according to the orphan\n-            // rules, but it invalidates the reasoning from\n-            // `two_foos` above.\n-            debug!(\n-                \"trait_ref={:?} trait_def_id={:?} trait_is_auto={}\",\n-                trait_ref,\n-                trait_def_id,\n-                self.tcx.trait_is_auto(trait_def_id)\n+        if let Some((msg, label)) = msg {\n+            struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).span_label(sp, label).emit();\n+            return Err(ErrorReported);\n+        }\n+    }\n+\n+    if let ty::Opaque(def_id, _) = *trait_ref.self_ty().kind() {\n+        tcx.sess\n+            .struct_span_err(sp, \"cannot implement trait on type alias impl trait\")\n+            .span_note(tcx.def_span(def_id), \"type alias impl trait defined here\")\n+            .emit();\n+        return Err(ErrorReported);\n+    }\n+\n+    Ok(())\n+}\n+\n+fn emit_orphan_check_error(\n+    tcx: TyCtxt<'tcx>,\n+    sp: Span,\n+    trait_span: Span,\n+    self_ty_span: Span,\n+    generics: &hir::Generics<'tcx>,\n+    err: traits::OrphanCheckErr<'tcx>,\n+) -> Result<!, ErrorReported> {\n+    match err {\n+        traits::OrphanCheckErr::NonLocalInputType(tys) => {\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                sp,\n+                E0117,\n+                \"only traits defined in the current crate can be implemented for \\\n+                        arbitrary types\"\n             );\n-            if self.tcx.trait_is_auto(trait_def_id) && !trait_def_id.is_local() {\n-                let self_ty = trait_ref.self_ty();\n-                let opt_self_def_id = match *self_ty.kind() {\n-                    ty::Adt(self_def, _) => Some(self_def.did),\n-                    ty::Foreign(did) => Some(did),\n-                    _ => None,\n+            err.span_label(sp, \"impl doesn't use only types from inside the current crate\");\n+            for (ty, is_target_ty) in &tys {\n+                let mut ty = *ty;\n+                tcx.infer_ctxt().enter(|infcx| {\n+                    // Remove the lifetimes unnecessary for this error.\n+                    ty = infcx.freshen(ty);\n+                });\n+                ty = match ty.kind() {\n+                    // Remove the type arguments from the output, as they are not relevant.\n+                    // You can think of this as the reverse of `resolve_vars_if_possible`.\n+                    // That way if we had `Vec<MyType>`, we will properly attribute the\n+                    // problem to `Vec<T>` and avoid confusing the user if they were to see\n+                    // `MyType` in the error.\n+                    ty::Adt(def, _) => tcx.mk_adt(def, ty::List::empty()),\n+                    _ => ty,\n                 };\n-\n-                let msg = match opt_self_def_id {\n-                    // We only want to permit nominal types, but not *all* nominal types.\n-                    // They must be local to the current crate, so that people\n-                    // can't do `unsafe impl Send for Rc<SomethingLocal>` or\n-                    // `impl !Send for Box<SomethingLocalAndSend>`.\n-                    Some(self_def_id) => {\n-                        if self_def_id.is_local() {\n-                            None\n-                        } else {\n-                            Some((\n-                                format!(\n-                                    \"cross-crate traits with a default impl, like `{}`, \\\n-                                         can only be implemented for a struct/enum type \\\n-                                         defined in the current crate\",\n-                                    self.tcx.def_path_str(trait_def_id)\n-                                ),\n-                                \"can't implement cross-crate trait for type in another crate\",\n-                            ))\n-                        }\n-                    }\n-                    _ => Some((\n-                        format!(\n-                            \"cross-crate traits with a default impl, like `{}`, can \\\n-                                       only be implemented for a struct/enum type, not `{}`\",\n-                            self.tcx.def_path_str(trait_def_id),\n-                            self_ty\n-                        ),\n-                        \"can't implement cross-crate trait with a default impl for \\\n-                               non-struct/enum type\",\n-                    )),\n+                let this = \"this\".to_string();\n+                let (ty, postfix) = match &ty.kind() {\n+                    ty::Slice(_) => (this, \" because slices are always foreign\"),\n+                    ty::Array(..) => (this, \" because arrays are always foreign\"),\n+                    ty::Tuple(..) => (this, \" because tuples are always foreign\"),\n+                    _ => (format!(\"`{}`\", ty), \"\"),\n                 };\n-\n-                if let Some((msg, label)) = msg {\n-                    struct_span_err!(self.tcx.sess, sp, E0321, \"{}\", msg)\n-                        .span_label(sp, label)\n-                        .emit();\n-                    return;\n+                let msg = format!(\"{} is not defined in the current crate{}\", ty, postfix);\n+                if *is_target_ty {\n+                    // Point at `D<A>` in `impl<A, B> for C<B> in D<A>`\n+                    err.span_label(self_ty_span, &msg);\n+                } else {\n+                    // Point at `C<B>` in `impl<A, B> for C<B> in D<A>`\n+                    err.span_label(trait_span, &msg);\n+                }\n+            }\n+            err.note(\"define and implement a trait or new type instead\");\n+            err.emit()\n+        }\n+        traits::OrphanCheckErr::UncoveredTy(param_ty, local_type) => {\n+            let mut sp = sp;\n+            for param in generics.params {\n+                if param.name.ident().to_string() == param_ty.to_string() {\n+                    sp = param.span;\n                 }\n             }\n \n-            if let ty::Opaque(def_id, _) = *trait_ref.self_ty().kind() {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(sp, \"cannot implement trait on type alias impl trait\")\n-                    .span_note(self.tcx.def_span(def_id), \"type alias impl trait defined here\")\n-                    .emit();\n+            match local_type {\n+                Some(local_type) => struct_span_err!(\n+                    tcx.sess,\n+                    sp,\n+                    E0210,\n+                    \"type parameter `{}` must be covered by another type \\\n+                    when it appears before the first local type (`{}`)\",\n+                    param_ty,\n+                    local_type\n+                )\n+                .span_label(\n+                    sp,\n+                    format!(\n+                        \"type parameter `{}` must be covered by another type \\\n+                    when it appears before the first local type (`{}`)\",\n+                        param_ty, local_type\n+                    ),\n+                )\n+                .note(\n+                    \"implementing a foreign trait is only possible if at \\\n+                        least one of the types for which it is implemented is local, \\\n+                        and no uncovered type parameters appear before that first \\\n+                        local type\",\n+                )\n+                .note(\n+                    \"in this case, 'before' refers to the following order: \\\n+                        `impl<..> ForeignTrait<T1, ..., Tn> for T0`, \\\n+                        where `T0` is the first and `Tn` is the last\",\n+                )\n+                .emit(),\n+                None => struct_span_err!(\n+                    tcx.sess,\n+                    sp,\n+                    E0210,\n+                    \"type parameter `{}` must be used as the type parameter for some \\\n+                    local type (e.g., `MyStruct<{}>`)\",\n+                    param_ty,\n+                    param_ty\n+                )\n+                .span_label(\n+                    sp,\n+                    format!(\n+                        \"type parameter `{}` must be used as the type parameter for some \\\n+                    local type\",\n+                        param_ty,\n+                    ),\n+                )\n+                .note(\n+                    \"implementing a foreign trait is only possible if at \\\n+                        least one of the types for which it is implemented is local\",\n+                )\n+                .note(\n+                    \"only traits defined in the current crate can be \\\n+                        implemented for a type parameter\",\n+                )\n+                .emit(),\n             }\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {}\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n+    Err(ErrorReported)\n }"}, {"sha": "588630957c94a323b5f98f45a0b64543685792ff", "filename": "src/test/ui/coherence/coherence-cross-crate-conflict.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-cross-crate-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-cross-crate-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-cross-crate-conflict.rs?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -6,9 +6,7 @@\n extern crate trait_impl_conflict;\n use trait_impl_conflict::Foo;\n \n-impl<A> Foo for A {\n-    //~^ ERROR E0119\n-    //~| ERROR E0210\n+impl<A> Foo for A { //~ ERROR E0210\n }\n \n fn main() {"}, {"sha": "3d253d56a45654bf5b9939524ff579fc4d9146d7", "filename": "src/test/ui/coherence/coherence-cross-crate-conflict.stderr", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-cross-crate-conflict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-cross-crate-conflict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-cross-crate-conflict.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,12 +1,3 @@\n-error[E0119]: conflicting implementations of trait `trait_impl_conflict::Foo` for type `isize`\n-  --> $DIR/coherence-cross-crate-conflict.rs:9:1\n-   |\n-LL | impl<A> Foo for A {\n-   | ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: conflicting implementation in crate `trait_impl_conflict`:\n-           - impl Foo for isize;\n-\n error[E0210]: type parameter `A` must be used as the type parameter for some local type (e.g., `MyStruct<A>`)\n   --> $DIR/coherence-cross-crate-conflict.rs:9:6\n    |\n@@ -16,7 +7,6 @@ LL | impl<A> Foo for A {\n    = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0119, E0210.\n-For more information about an error, try `rustc --explain E0119`.\n+For more information about this error, try `rustc --explain E0210`."}, {"sha": "912891480790ee141f1e7c0deda860ef875d271c", "filename": "src/test/ui/coherence/coherence-impl-trait-for-marker-trait-negative.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,15 +1,3 @@\n-error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker1`\n-  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:15:1\n-   |\n-LL | impl !Marker1 for dyn Object + Marker2 { }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker1`\n-\n-error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker2`\n-  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:17:1\n-   |\n-LL | impl !Marker2 for dyn Object + Marker2 { }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker2`\n-\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:23:1\n    |\n@@ -33,6 +21,18 @@ error[E0321]: cross-crate traits with a default impl, like `Send`, can only be i\n LL | impl !Send for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't implement cross-crate trait with a default impl for non-struct/enum type\n \n+error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker1`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:15:1\n+   |\n+LL | impl !Marker1 for dyn Object + Marker2 { }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker1`\n+\n+error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker2`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:17:1\n+   |\n+LL | impl !Marker2 for dyn Object + Marker2 { }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker2`\n+\n error: aborting due to 5 previous errors\n \n Some errors have detailed explanations: E0117, E0321, E0371."}, {"sha": "056198374a4cc1e0caff6754ae35d49263aeaaf7", "filename": "src/test/ui/coherence/coherence-impl-trait-for-marker-trait-positive.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,15 +1,3 @@\n-error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker1`\n-  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:15:1\n-   |\n-LL | impl Marker1 for dyn Object + Marker2 { }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker1`\n-\n-error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker2`\n-  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:17:1\n-   |\n-LL | impl Marker2 for dyn Object + Marker2 { }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker2`\n-\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:23:1\n    |\n@@ -33,6 +21,18 @@ error[E0321]: cross-crate traits with a default impl, like `Send`, can only be i\n LL | unsafe impl Send for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't implement cross-crate trait with a default impl for non-struct/enum type\n \n+error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker1`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:15:1\n+   |\n+LL | impl Marker1 for dyn Object + Marker2 { }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker1`\n+\n+error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker2`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:17:1\n+   |\n+LL | impl Marker2 for dyn Object + Marker2 { }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker2`\n+\n error: aborting due to 5 previous errors\n \n Some errors have detailed explanations: E0117, E0321, E0371."}, {"sha": "4204fecc37e15d4053372d3876aa14a439d67915", "filename": "src/test/ui/coherence/coherence-impls-copy.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-copy.rs?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -3,8 +3,7 @@\n use std::marker::Copy;\n \n impl Copy for i32 {}\n-//~^ ERROR E0119\n-//~| ERROR E0117\n+//~^ ERROR E0117\n enum TestE {\n   A\n }\n@@ -32,7 +31,6 @@ impl Copy for [MyType] {}\n //~^ ERROR E0206\n //~| ERROR E0117\n impl Copy for &'static [NotSync] {}\n-//~^ ERROR E0119\n-//~| ERROR E0117\n+//~^ ERROR E0117\n fn main() {\n }"}, {"sha": "a7d6968a2967cc272de8e7fcb712ca75b96c8574", "filename": "src/test/ui/coherence/coherence-impls-copy.stderr", "status": "modified", "additions": 32, "deletions": 51, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-copy.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,50 +1,3 @@\n-error[E0119]: conflicting implementations of trait `std::marker::Copy` for type `i32`\n-  --> $DIR/coherence-impls-copy.rs:5:1\n-   |\n-LL | impl Copy for i32 {}\n-   | ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: conflicting implementation in crate `core`:\n-           - impl Copy for i32;\n-\n-error[E0119]: conflicting implementations of trait `std::marker::Copy` for type `&NotSync`\n-  --> $DIR/coherence-impls-copy.rs:29:1\n-   |\n-LL | impl Copy for &'static NotSync {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: conflicting implementation in crate `core`:\n-           - impl<T> Copy for &T\n-             where T: ?Sized;\n-\n-error[E0119]: conflicting implementations of trait `std::marker::Copy` for type `&[NotSync]`\n-  --> $DIR/coherence-impls-copy.rs:34:1\n-   |\n-LL | impl Copy for &'static [NotSync] {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: conflicting implementation in crate `core`:\n-           - impl<T> Copy for &T\n-             where T: ?Sized;\n-\n-error[E0206]: the trait `Copy` may not be implemented for this type\n-  --> $DIR/coherence-impls-copy.rs:22:15\n-   |\n-LL | impl Copy for &'static mut MyType {}\n-   |               ^^^^^^^^^^^^^^^^^^^ type is not a structure or enumeration\n-\n-error[E0206]: the trait `Copy` may not be implemented for this type\n-  --> $DIR/coherence-impls-copy.rs:26:15\n-   |\n-LL | impl Copy for (MyType, MyType) {}\n-   |               ^^^^^^^^^^^^^^^^ type is not a structure or enumeration\n-\n-error[E0206]: the trait `Copy` may not be implemented for this type\n-  --> $DIR/coherence-impls-copy.rs:31:15\n-   |\n-LL | impl Copy for [MyType] {}\n-   |               ^^^^^^^^ type is not a structure or enumeration\n-\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> $DIR/coherence-impls-copy.rs:5:1\n    |\n@@ -57,7 +10,7 @@ LL | impl Copy for i32 {}\n    = note: define and implement a trait or new type instead\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impls-copy.rs:26:1\n+  --> $DIR/coherence-impls-copy.rs:25:1\n    |\n LL | impl Copy for (MyType, MyType) {}\n    | ^^^^^^^^^^^^^^----------------\n@@ -68,7 +21,7 @@ LL | impl Copy for (MyType, MyType) {}\n    = note: define and implement a trait or new type instead\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impls-copy.rs:31:1\n+  --> $DIR/coherence-impls-copy.rs:30:1\n    |\n LL | impl Copy for [MyType] {}\n    | ^^^^^^^^^^^^^^--------\n@@ -79,7 +32,7 @@ LL | impl Copy for [MyType] {}\n    = note: define and implement a trait or new type instead\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impls-copy.rs:34:1\n+  --> $DIR/coherence-impls-copy.rs:33:1\n    |\n LL | impl Copy for &'static [NotSync] {}\n    | ^^^^^^^^^^^^^^------------------\n@@ -89,7 +42,35 @@ LL | impl Copy for &'static [NotSync] {}\n    |\n    = note: define and implement a trait or new type instead\n \n-error: aborting due to 10 previous errors\n+error[E0119]: conflicting implementations of trait `std::marker::Copy` for type `&NotSync`\n+  --> $DIR/coherence-impls-copy.rs:28:1\n+   |\n+LL | impl Copy for &'static NotSync {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: conflicting implementation in crate `core`:\n+           - impl<T> Copy for &T\n+             where T: ?Sized;\n+\n+error[E0206]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/coherence-impls-copy.rs:21:15\n+   |\n+LL | impl Copy for &'static mut MyType {}\n+   |               ^^^^^^^^^^^^^^^^^^^ type is not a structure or enumeration\n+\n+error[E0206]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/coherence-impls-copy.rs:25:15\n+   |\n+LL | impl Copy for (MyType, MyType) {}\n+   |               ^^^^^^^^^^^^^^^^ type is not a structure or enumeration\n+\n+error[E0206]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/coherence-impls-copy.rs:30:15\n+   |\n+LL | impl Copy for [MyType] {}\n+   |               ^^^^^^^^ type is not a structure or enumeration\n+\n+error: aborting due to 8 previous errors\n \n Some errors have detailed explanations: E0117, E0119, E0206.\n For more information about an error, try `rustc --explain E0117`."}, {"sha": "b7b57c602b8d134ceab984111fc7771ff7794143", "filename": "src/test/ui/coherence/coherence-impls-send.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-send.rs?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -23,7 +23,6 @@ unsafe impl Send for [MyType] {}\n //~^ ERROR E0117\n \n unsafe impl Send for &'static [NotSync] {}\n-//~^ ERROR conflicting implementations of trait\n-//~| ERROR only traits defined in the current crate\n+//~^ ERROR only traits defined in the current crate\n \n fn main() {}"}, {"sha": "dd1fd1b0dce24ff54448a062599d2d9c8a2f66cd", "filename": "src/test/ui/coherence/coherence-impls-send.stderr", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-send.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-send.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-send.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,14 +1,3 @@\n-error[E0119]: conflicting implementations of trait `std::marker::Send` for type `&[NotSync]`\n-  --> $DIR/coherence-impls-send.rs:25:1\n-   |\n-LL | unsafe impl Send for &'static [NotSync] {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: conflicting implementation in crate `core`:\n-           - impl<T> Send for &T\n-             where T: Sync, T: ?Sized;\n-   = note: upstream crates may add a new impl of trait `std::marker::Sync` for type `[NotSync]` in future versions\n-\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> $DIR/coherence-impls-send.rs:16:1\n    |\n@@ -48,7 +37,7 @@ LL | unsafe impl Send for &'static [NotSync] {}\n    |\n    = note: define and implement a trait or new type instead\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0117, E0119, E0321.\n+Some errors have detailed explanations: E0117, E0321.\n For more information about an error, try `rustc --explain E0117`."}, {"sha": "9cf5ed38c9c6bf8a838f6126934db39a1aae2058", "filename": "src/test/ui/coherence/coherence-impls-sized.stderr", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-impls-sized.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,3 +1,36 @@\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/coherence-impls-sized.rs:20:1\n+   |\n+LL | impl Sized for (MyType, MyType) {}\n+   | ^^^^^^^^^^^^^^^----------------\n+   | |              |\n+   | |              this is not defined in the current crate because tuples are always foreign\n+   | impl doesn't use only types from inside the current crate\n+   |\n+   = note: define and implement a trait or new type instead\n+\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/coherence-impls-sized.rs:27:1\n+   |\n+LL | impl Sized for [MyType] {}\n+   | ^^^^^^^^^^^^^^^--------\n+   | |              |\n+   | |              this is not defined in the current crate because slices are always foreign\n+   | impl doesn't use only types from inside the current crate\n+   |\n+   = note: define and implement a trait or new type instead\n+\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/coherence-impls-sized.rs:31:1\n+   |\n+LL | impl Sized for &'static [NotSync] {}\n+   | ^^^^^^^^^^^^^^^------------------\n+   | |              |\n+   | |              this is not defined in the current crate because slices are always foreign\n+   | impl doesn't use only types from inside the current crate\n+   |\n+   = note: define and implement a trait or new type instead\n+\n error[E0322]: explicit impls for the `Sized` trait are not permitted\n   --> $DIR/coherence-impls-sized.rs:14:1\n    |\n@@ -34,39 +67,6 @@ error[E0322]: explicit impls for the `Sized` trait are not permitted\n LL | impl Sized for &'static [NotSync] {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl of 'Sized' not allowed\n \n-error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impls-sized.rs:20:1\n-   |\n-LL | impl Sized for (MyType, MyType) {}\n-   | ^^^^^^^^^^^^^^^----------------\n-   | |              |\n-   | |              this is not defined in the current crate because tuples are always foreign\n-   | impl doesn't use only types from inside the current crate\n-   |\n-   = note: define and implement a trait or new type instead\n-\n-error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impls-sized.rs:27:1\n-   |\n-LL | impl Sized for [MyType] {}\n-   | ^^^^^^^^^^^^^^^--------\n-   | |              |\n-   | |              this is not defined in the current crate because slices are always foreign\n-   | impl doesn't use only types from inside the current crate\n-   |\n-   = note: define and implement a trait or new type instead\n-\n-error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impls-sized.rs:31:1\n-   |\n-LL | impl Sized for &'static [NotSync] {}\n-   | ^^^^^^^^^^^^^^^------------------\n-   | |              |\n-   | |              this is not defined in the current crate because slices are always foreign\n-   | impl doesn't use only types from inside the current crate\n-   |\n-   = note: define and implement a trait or new type instead\n-\n error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0117, E0322."}, {"sha": "051a519ee1477dec0fefa272b51f28d0bcbd7963", "filename": "src/test/ui/coherence/coherence-orphan.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-orphan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-orphan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-orphan.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,22 +1,22 @@\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-orphan.rs:10:1\n+  --> $DIR/coherence-orphan.rs:17:1\n    |\n-LL | impl TheTrait<usize> for isize { }\n-   | ^^^^^---------------^^^^^-----\n-   | |    |                   |\n-   | |    |                   `isize` is not defined in the current crate\n-   | |    `usize` is not defined in the current crate\n+LL | impl !Send for Vec<isize> { }\n+   | ^^^^^^^^^^^^^^^----------\n+   | |              |\n+   | |              `Vec` is not defined in the current crate\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-orphan.rs:17:1\n+  --> $DIR/coherence-orphan.rs:10:1\n    |\n-LL | impl !Send for Vec<isize> { }\n-   | ^^^^^^^^^^^^^^^----------\n-   | |              |\n-   | |              `Vec` is not defined in the current crate\n+LL | impl TheTrait<usize> for isize { }\n+   | ^^^^^---------------^^^^^-----\n+   | |    |                   |\n+   | |    |                   `isize` is not defined in the current crate\n+   | |    `usize` is not defined in the current crate\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead"}, {"sha": "e52728f3781f8882f431b2bc3a990ad4a29c0067", "filename": "src/test/ui/dropck/drop-on-non-struct.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fdropck%2Fdrop-on-non-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fdropck%2Fdrop-on-non-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdrop-on-non-struct.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -4,12 +4,6 @@ error[E0412]: cannot find type `Nonexistent` in this scope\n LL | impl Drop for Nonexistent {\n    |               ^^^^^^^^^^^ not found in this scope\n \n-error[E0120]: the `Drop` trait may only be implemented for structs, enums, and unions\n-  --> $DIR/drop-on-non-struct.rs:1:19\n-   |\n-LL | impl<'a> Drop for &'a mut isize {\n-   |                   ^^^^^^^^^^^^^ must be a struct, enum, or union\n-\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> $DIR/drop-on-non-struct.rs:1:1\n    |\n@@ -21,6 +15,12 @@ LL | impl<'a> Drop for &'a mut isize {\n    |\n    = note: define and implement a trait or new type instead\n \n+error[E0120]: the `Drop` trait may only be implemented for structs, enums, and unions\n+  --> $DIR/drop-on-non-struct.rs:1:19\n+   |\n+LL | impl<'a> Drop for &'a mut isize {\n+   |                   ^^^^^^^^^^^^^ must be a struct, enum, or union\n+\n error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0117, E0120, E0412."}, {"sha": "cdbafff2a202bbc70e098609b28cb58660aea48a", "filename": "src/test/ui/error-codes/E0117.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ferror-codes%2FE0117.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ferror-codes%2FE0117.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0117.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,9 +1,3 @@\n-error[E0120]: the `Drop` trait may only be implemented for structs, enums, and unions\n-  --> $DIR/E0117.rs:1:15\n-   |\n-LL | impl Drop for u32 {}\n-   |               ^^^ must be a struct, enum, or union\n-\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> $DIR/E0117.rs:1:1\n    |\n@@ -15,6 +9,12 @@ LL | impl Drop for u32 {}\n    |\n    = note: define and implement a trait or new type instead\n \n+error[E0120]: the `Drop` trait may only be implemented for structs, enums, and unions\n+  --> $DIR/E0117.rs:1:15\n+   |\n+LL | impl Drop for u32 {}\n+   |               ^^^ must be a struct, enum, or union\n+\n error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0117, E0120."}, {"sha": "9149e4ce58e767990d7014ac7b359673757dbfe8", "filename": "src/test/ui/error-codes/e0119/complex-impl.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fcomplex-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fcomplex-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fcomplex-impl.rs?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -7,6 +7,5 @@ use complex_impl_support::{External, M};\n struct Q;\n \n impl<R> External for (Q, R) {} //~ ERROR only traits defined\n-//~^ ERROR conflicting implementations of trait\n \n fn main() {}"}, {"sha": "654073eec2602bb5542f68a90b08824b5b42596a", "filename": "src/test/ui/error-codes/e0119/complex-impl.stderr", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fcomplex-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fcomplex-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fcomplex-impl.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,13 +1,3 @@\n-error[E0119]: conflicting implementations of trait `complex_impl_support::External` for type `(Q, complex_impl_support::M<'_, '_, '_, std::boxed::Box<_>, _, _>)`\n-  --> $DIR/complex-impl.rs:9:1\n-   |\n-LL | impl<R> External for (Q, R) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: conflicting implementation in crate `complex_impl_support`:\n-           - impl<'a, 'b, 'c, T, U, V, W> External for (T, M<'a, 'b, 'c, Box<U>, V, W>)\n-             where <U as FnOnce<(T,)>>::Output == V, <V as Iterator>::Item == T, 'b: 'a, T: 'a, U: 'static, U: FnOnce<(T,)>, V: Iterator, V: Clone, W: Add, <W as Add>::Output: Copy;\n-\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> $DIR/complex-impl.rs:9:1\n    |\n@@ -19,7 +9,6 @@ LL | impl<R> External for (Q, R) {}\n    |\n    = note: define and implement a trait or new type instead\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0117, E0119.\n-For more information about an error, try `rustc --explain E0117`.\n+For more information about this error, try `rustc --explain E0117`."}, {"sha": "5fb7e9a9913abb0dc17b1ba6f8c77ae4c5df489b", "filename": "src/test/ui/error-codes/e0119/issue-28981.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fissue-28981.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fissue-28981.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fissue-28981.rs?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -3,6 +3,5 @@ use std::ops::Deref;\n struct Foo;\n \n impl<Foo> Deref for Foo { } //~ ERROR must be used\n-//~^ ERROR conflicting implementations\n \n fn main() {}"}, {"sha": "97b570bc7aca369af4125afb2c21ed08ac86549a", "filename": "src/test/ui/error-codes/e0119/issue-28981.stderr", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fissue-28981.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fissue-28981.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fe0119%2Fissue-28981.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,13 +1,3 @@\n-error[E0119]: conflicting implementations of trait `std::ops::Deref` for type `&_`\n-  --> $DIR/issue-28981.rs:5:1\n-   |\n-LL | impl<Foo> Deref for Foo { }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: conflicting implementation in crate `core`:\n-           - impl<T> Deref for &T\n-             where T: ?Sized;\n-\n error[E0210]: type parameter `Foo` must be used as the type parameter for some local type (e.g., `MyStruct<Foo>`)\n   --> $DIR/issue-28981.rs:5:6\n    |\n@@ -17,7 +7,6 @@ LL | impl<Foo> Deref for Foo { }\n    = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0119, E0210.\n-For more information about an error, try `rustc --explain E0119`.\n+For more information about this error, try `rustc --explain E0210`."}, {"sha": "10c363479a374a6288175bef782f17f0dca4b3c0", "filename": "src/test/ui/issues/issue-41974.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fissues%2Fissue-41974.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fissues%2Fissue-41974.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41974.rs?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -4,9 +4,9 @@ struct Flags;\n trait A {\n }\n \n-impl<T> Drop for T where T: A { //~ ERROR E0119\n-                                //~^ ERROR E0120\n-                                //~| ERROR E0210\n+impl<T> Drop for T where T: A {\n+    //~^ ERROR E0120\n+    //~| ERROR E0210\n     fn drop(&mut self) {\n     }\n }"}, {"sha": "fcbb4014025f152eb97c312c00abe90b63e910af", "filename": "src/test/ui/issues/issue-41974.stderr", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41974.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,30 +1,19 @@\n-error[E0119]: conflicting implementations of trait `std::ops::Drop` for type `std::boxed::Box<_, _>`\n-  --> $DIR/issue-41974.rs:7:1\n+error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n+  --> $DIR/issue-41974.rs:7:6\n    |\n LL | impl<T> Drop for T where T: A {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |      ^ type parameter `T` must be used as the type parameter for some local type\n    |\n-   = note: conflicting implementation in crate `alloc`:\n-           - impl<T, A> Drop for Box<T, A>\n-             where A: Allocator, T: ?Sized;\n-   = note: downstream crates may implement trait `A` for type `std::boxed::Box<_, _>`\n+   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n+   = note: only traits defined in the current crate can be implemented for a type parameter\n \n error[E0120]: the `Drop` trait may only be implemented for structs, enums, and unions\n   --> $DIR/issue-41974.rs:7:18\n    |\n LL | impl<T> Drop for T where T: A {\n    |                  ^ must be a struct, enum, or union\n \n-error[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\n-  --> $DIR/issue-41974.rs:7:6\n-   |\n-LL | impl<T> Drop for T where T: A {\n-   |      ^ type parameter `T` must be used as the type parameter for some local type\n-   |\n-   = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n-   = note: only traits defined in the current crate can be implemented for a type parameter\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0119, E0120, E0210.\n-For more information about an error, try `rustc --explain E0119`.\n+Some errors have detailed explanations: E0120, E0210.\n+For more information about an error, try `rustc --explain E0120`."}, {"sha": "961968186de24a520918bcee881ed1344de12c46", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-and-non-const-impl.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.rs?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -2,25 +2,24 @@\n \n pub struct Int(i32);\n \n-impl const std::ops::Add for i32 {\n-    //~^ ERROR conflicting implementations of trait\n-    //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n+impl const std::ops::Add for i32 { //~ ERROR type annotations needed\n+    //~^ ERROR only traits defined in the current crate can be implemented for arbitrary types\n     type Output = Self;\n \n     fn add(self, rhs: Self) -> Self {\n         self + rhs\n     }\n }\n \n-impl std::ops::Add for Int {\n+impl std::ops::Add for Int { //~ ERROR type annotations needed\n     type Output = Self;\n \n     fn add(self, rhs: Self) -> Self {\n         Int(self.0 + rhs.0)\n     }\n }\n \n-impl const std::ops::Add for Int {\n+impl const std::ops::Add for Int { //~ ERROR type annotations needed\n     //~^ ERROR conflicting implementations of trait\n     type Output = Self;\n "}, {"sha": "785095c29ae4ebc8e886f96583285bbd08994615", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-and-non-const-impl.stderr", "status": "modified", "additions": 81, "deletions": 14, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-and-non-const-impl.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,34 +1,101 @@\n-error[E0119]: conflicting implementations of trait `std::ops::Add` for type `i32`\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> $DIR/const-and-non-const-impl.rs:5:1\n    |\n LL | impl const std::ops::Add for i32 {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^-------------^^^^^---\n+   | |          |                 |\n+   | |          |                 `i32` is not defined in the current crate\n+   | |          `i32` is not defined in the current crate\n+   | impl doesn't use only types from inside the current crate\n    |\n-   = note: conflicting implementation in crate `core`:\n-           - impl Add for i32;\n+   = note: define and implement a trait or new type instead\n \n error[E0119]: conflicting implementations of trait `std::ops::Add` for type `Int`\n-  --> $DIR/const-and-non-const-impl.rs:23:1\n+  --> $DIR/const-and-non-const-impl.rs:22:1\n    |\n LL | impl std::ops::Add for Int {\n    | -------------------------- first implementation here\n ...\n LL | impl const std::ops::Add for Int {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `Int`\n \n-error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+error[E0283]: type annotations needed\n+  --> $DIR/const-and-non-const-impl.rs:5:12\n+   |\n+LL | impl const std::ops::Add for i32 {\n+   |            ^^^^^^^^^^^^^ cannot infer type for type `i32`\n+   |\n+note: multiple `impl`s satisfying `i32: Add` found\n   --> $DIR/const-and-non-const-impl.rs:5:1\n    |\n LL | impl const std::ops::Add for i32 {\n-   | ^^^^^^^^^^^-------------^^^^^---\n-   | |          |                 |\n-   | |          |                 `i32` is not defined in the current crate\n-   | |          `i32` is not defined in the current crate\n-   | impl doesn't use only types from inside the current crate\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: and another `impl` found in the `core` crate: `impl Add for i32;`\n+note: required by a bound in `Add`\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n    |\n-   = note: define and implement a trait or new type instead\n+LL | / pub trait Add<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `+` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn add(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^ required by this bound in `Add`\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/const-and-non-const-impl.rs:14:6\n+   |\n+LL | impl std::ops::Add for Int {\n+   |      ^^^^^^^^^^^^^ cannot infer type for struct `Int`\n+   |\n+note: multiple `impl`s satisfying `Int: Add` found\n+  --> $DIR/const-and-non-const-impl.rs:14:1\n+   |\n+LL | impl std::ops::Add for Int {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl const std::ops::Add for Int {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: required by a bound in `Add`\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | / pub trait Add<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `+` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn add(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^ required by this bound in `Add`\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/const-and-non-const-impl.rs:22:12\n+   |\n+LL | impl const std::ops::Add for Int {\n+   |            ^^^^^^^^^^^^^ cannot infer type for struct `Int`\n+   |\n+note: multiple `impl`s satisfying `Int: Add` found\n+  --> $DIR/const-and-non-const-impl.rs:14:1\n+   |\n+LL | impl std::ops::Add for Int {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl const std::ops::Add for Int {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: required by a bound in `Add`\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | / pub trait Add<Rhs = Self> {\n+LL | |     /// The resulting type after applying the `+` operator.\n+LL | |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+LL | |     type Output;\n+...  |\n+LL | |     fn add(self, rhs: Rhs) -> Self::Output;\n+LL | | }\n+   | |_^ required by this bound in `Add`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0117, E0119.\n+Some errors have detailed explanations: E0117, E0119, E0283.\n For more information about an error, try `rustc --explain E0117`."}, {"sha": "6a3498a389375e3806243cde691d6ae85f3064c0", "filename": "src/test/ui/traits/alias/issue-83613.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,11 +1,3 @@\n-error[E0119]: conflicting implementations of trait `AnotherTrait` for type `impl OpaqueTrait`\n-  --> $DIR/issue-83613.rs:10:1\n-   |\n-LL | impl<T: Send> AnotherTrait for T {}\n-   | -------------------------------- first implementation here\n-LL | impl AnotherTrait for OpaqueType {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `impl OpaqueTrait`\n-\n error: cannot implement trait on type alias impl trait\n   --> $DIR/issue-83613.rs:10:1\n    |\n@@ -18,6 +10,14 @@ note: type alias impl trait defined here\n LL | type OpaqueType = impl OpaqueTrait;\n    |                   ^^^^^^^^^^^^^^^^\n \n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `impl OpaqueTrait`\n+  --> $DIR/issue-83613.rs:10:1\n+   |\n+LL | impl<T: Send> AnotherTrait for T {}\n+   | -------------------------------- first implementation here\n+LL | impl AnotherTrait for OpaqueType {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `impl OpaqueTrait`\n+\n error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "49a9f479368769d4186a87fc61038fd331bf048e", "filename": "src/test/ui/traits/issue-78372.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ftraits%2Fissue-78372.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ftraits%2Fissue-78372.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-78372.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -50,12 +50,6 @@ LL | impl<T> DispatchFromDyn<Smaht<U, MISC>> for T {}\n    |\n    = help: add `#![feature(dispatch_from_dyn)]` to the crate attributes to enable\n \n-error[E0378]: the trait `DispatchFromDyn` may only be implemented for a coercion between structures\n-  --> $DIR/issue-78372.rs:3:1\n-   |\n-LL | impl<T> DispatchFromDyn<Smaht<U, MISC>> for T {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error[E0210]: type parameter `T` must be covered by another type when it appears before the first local type (`Smaht<[type error], [type error]>`)\n   --> $DIR/issue-78372.rs:3:6\n    |\n@@ -65,6 +59,12 @@ LL | impl<T> DispatchFromDyn<Smaht<U, MISC>> for T {}\n    = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local, and no uncovered type parameters appear before that first local type\n    = note: in this case, 'before' refers to the following order: `impl<..> ForeignTrait<T1, ..., Tn> for T0`, where `T0` is the first and `Tn` is the last\n \n+error[E0378]: the trait `DispatchFromDyn` may only be implemented for a coercion between structures\n+  --> $DIR/issue-78372.rs:3:1\n+   |\n+LL | impl<T> DispatchFromDyn<Smaht<U, MISC>> for T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: aborting due to 7 previous errors\n \n Some errors have detailed explanations: E0210, E0378, E0412, E0658."}, {"sha": "685d76ee36f33cb5f3a56a48dde128810e019540", "filename": "src/test/ui/type-alias-impl-trait/incoherent-assoc-imp-trait.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.rs?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -8,8 +8,7 @@ trait MyTrait {}\n impl MyTrait for () {}\n \n impl<F> FnOnce<()> for &F {\n-    //~^ ERROR conflicting implementations\n-    //~| ERROR type parameter `F` must be used\n+    //~^ ERROR type parameter `F` must be used\n     type Output = impl MyTrait;\n     extern \"rust-call\" fn call_once(self, _: ()) -> Self::Output {}\n }"}, {"sha": "b93ea955c89f59303965a5b86d7b4a60d8072894", "filename": "src/test/ui/type-alias-impl-trait/incoherent-assoc-imp-trait.stderr", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1296719c061fb4dd594f5c84e223be30d8611d95/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincoherent-assoc-imp-trait.stderr?ref=1296719c061fb4dd594f5c84e223be30d8611d95", "patch": "@@ -1,13 +1,3 @@\n-error[E0119]: conflicting implementations of trait `std::ops::FnOnce<()>` for type `&_`\n-  --> $DIR/incoherent-assoc-imp-trait.rs:10:1\n-   |\n-LL | impl<F> FnOnce<()> for &F {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: conflicting implementation in crate `core`:\n-           - impl<A, F> FnOnce<A> for &F\n-             where F: Fn<A>, F: ?Sized;\n-\n error[E0210]: type parameter `F` must be used as the type parameter for some local type (e.g., `MyStruct<F>`)\n   --> $DIR/incoherent-assoc-imp-trait.rs:10:6\n    |\n@@ -17,7 +7,6 @@ LL | impl<F> FnOnce<()> for &F {\n    = note: implementing a foreign trait is only possible if at least one of the types for which it is implemented is local\n    = note: only traits defined in the current crate can be implemented for a type parameter\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0119, E0210.\n-For more information about an error, try `rustc --explain E0119`.\n+For more information about this error, try `rustc --explain E0210`."}]}