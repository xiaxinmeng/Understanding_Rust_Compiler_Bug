{"sha": "cc9bb1522e357a4a11e7b0bfbbb7eddbd880a44f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjOWJiMTUyMmUzNTdhNGExMWU3YjBiZmJiYjdlZGRiZDg4MGE0NGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-02T03:31:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-02T03:31:17Z"}, "message": "Auto merge of #83342 - Count-Count:win-console-incomplete-utf8, r=m-ou-se\n\nAllow writing of incomplete UTF-8 sequences to the Windows console via stdout/stderr\n\n# Problem\nWrites of just an incomplete UTF-8 byte sequence (e.g. `b\"\\xC3\"` or `b\"\\xF0\\x9F\"`)  to stdout/stderr with a Windows console attached error with `io::ErrorKind::InvalidData, \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\"` even though further writes could complete the codepoint. This is currently a rare occurence since the [linewritershim](https://github.com/rust-lang/rust/blob/2c56ea38b045624dc8b42ec948fc169eaff1206a/library/std/src/io/buffered/linewritershim.rs) implementation flushes complete lines immediately and buffers up to 1024 bytes for incomplete lines. It can still happen as described in #83258.\n\nThe problem will become more pronounced once the developer can switch stdout/stderr from line-buffered to block-buffered or immediate when the changes in the \"Switchable buffering for Stdout\" pull request (#78515) get merged.\n\n# Patch description\nIf there is at least one valid UTF-8 codepoint all valid UTF-8 is passed through to the extracted `write_valid_utf8_to_console()` fn. The new code only comes into play if `write()` is being passed a short byte slice comprising an incomplete UTF-8 codepoint. In this case up to three bytes are buffered in the `IncompleteUtf8` struct associated with `Stdout` / `Stderr`. The bytes are accepted one at a time. As soon as an error can be detected `io::ErrorKind::InvalidData, \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\"` is returned. Once a complete UTF-8 codepoint is received it is passed to the `write_valid_utf8_to_console()` and the buffer length is set to zero.\n\nCalling `flush()` will neither error nor write anything if an incomplete codepoint is present in the buffer.\n\n# Tests\nCurrently there are no Windows-specific tests for console writing code at all. Writing (regression) tests for this problem is a bit challenging since unit tests and UI tests don't run in a console and suddenly popping up another console window might be surprising to developers running the testsuite and it might not work at all in CI builds. To just test the new functionality in unit tests the code would need to be refactored. Some guidance on how to proceed would be appreciated.\n\n# Public API changes\n* `std::str::verifications::utf8_char_width()` would be exposed as `std::str::utf8_char_width()` behind the \"str_internals\" feature gate.\n\n# Related issues\n* Fixes #83258.\n* PR #78515 will exacerbate the problem.\n\n# Open questions\n* Add tests?\n* Squash into one commit with better commit message?", "tree": {"sha": "14c1af10a9798f27d7bd7059d3d8a2fc5b904bcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14c1af10a9798f27d7bd7059d3d8a2fc5b904bcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc9bb1522e357a4a11e7b0bfbbb7eddbd880a44f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc9bb1522e357a4a11e7b0bfbbb7eddbd880a44f", "html_url": "https://github.com/rust-lang/rust/commit/cc9bb1522e357a4a11e7b0bfbbb7eddbd880a44f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc9bb1522e357a4a11e7b0bfbbb7eddbd880a44f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3c71f1e33b026dea7c9ca7c1c4554e63f56a0da", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3c71f1e33b026dea7c9ca7c1c4554e63f56a0da", "html_url": "https://github.com/rust-lang/rust/commit/e3c71f1e33b026dea7c9ca7c1c4554e63f56a0da"}, {"sha": "fbfde7eaaf6e95ec186c311d5044281d7b2415c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbfde7eaaf6e95ec186c311d5044281d7b2415c6", "html_url": "https://github.com/rust-lang/rust/commit/fbfde7eaaf6e95ec186c311d5044281d7b2415c6"}], "stats": {"total": 106, "additions": 91, "deletions": 15}, "files": [{"sha": "ca4e2e6b7f3517af02727acb916d047e8bf4f2d5", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc9bb1522e357a4a11e7b0bfbbb7eddbd880a44f/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc9bb1522e357a4a11e7b0bfbbb7eddbd880a44f/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=cc9bb1522e357a4a11e7b0bfbbb7eddbd880a44f", "patch": "@@ -69,7 +69,7 @@ pub use iter::SplitAsciiWhitespace;\n pub use iter::SplitInclusive;\n \n #[unstable(feature = \"str_internals\", issue = \"none\")]\n-pub use validations::next_code_point;\n+pub use validations::{next_code_point, utf8_char_width};\n \n use iter::MatchIndicesInternal;\n use iter::SplitInternal;"}, {"sha": "2719a530dfd41151cd50581889909e312530c2d0", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 90, "deletions": 14, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/cc9bb1522e357a4a11e7b0bfbbb7eddbd880a44f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc9bb1522e357a4a11e7b0bfbbb7eddbd880a44f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=cc9bb1522e357a4a11e7b0bfbbb7eddbd880a44f", "patch": "@@ -9,14 +9,25 @@ use crate::str;\n use crate::sys::c;\n use crate::sys::cvt;\n use crate::sys::handle::Handle;\n+use core::str::utf8_char_width;\n \n // Don't cache handles but get them fresh for every read/write. This allows us to track changes to\n // the value over time (such as if a process calls `SetStdHandle` while it's running). See #40490.\n pub struct Stdin {\n     surrogate: u16,\n }\n-pub struct Stdout;\n-pub struct Stderr;\n+pub struct Stdout {\n+    incomplete_utf8: IncompleteUtf8,\n+}\n+\n+pub struct Stderr {\n+    incomplete_utf8: IncompleteUtf8,\n+}\n+\n+struct IncompleteUtf8 {\n+    bytes: [u8; 4],\n+    len: u8,\n+}\n \n // Apparently Windows doesn't handle large reads on stdin or writes to stdout/stderr well (see\n // #13304 for details).\n@@ -51,7 +62,15 @@ fn is_console(handle: c::HANDLE) -> bool {\n     unsafe { c::GetConsoleMode(handle, &mut mode) != 0 }\n }\n \n-fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n+fn write(\n+    handle_id: c::DWORD,\n+    data: &[u8],\n+    incomplete_utf8: &mut IncompleteUtf8,\n+) -> io::Result<usize> {\n+    if data.is_empty() {\n+        return Ok(0);\n+    }\n+\n     let handle = get_handle(handle_id)?;\n     if !is_console(handle) {\n         unsafe {\n@@ -62,22 +81,73 @@ fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n         }\n     }\n \n-    // As the console is meant for presenting text, we assume bytes of `data` come from a string\n-    // and are encoded as UTF-8, which needs to be encoded as UTF-16.\n+    if incomplete_utf8.len > 0 {\n+        assert!(\n+            incomplete_utf8.len < 4,\n+            \"Unexpected number of bytes for incomplete UTF-8 codepoint.\"\n+        );\n+        if data[0] >> 6 != 0b10 {\n+            // not a continuation byte - reject\n+            incomplete_utf8.len = 0;\n+            return Err(io::Error::new_const(\n+                io::ErrorKind::InvalidData,\n+                &\"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n+            ));\n+        }\n+        incomplete_utf8.bytes[incomplete_utf8.len as usize] = data[0];\n+        incomplete_utf8.len += 1;\n+        let char_width = utf8_char_width(incomplete_utf8.bytes[0]);\n+        if (incomplete_utf8.len as usize) < char_width {\n+            // more bytes needed\n+            return Ok(1);\n+        }\n+        let s = str::from_utf8(&incomplete_utf8.bytes[0..incomplete_utf8.len as usize]);\n+        incomplete_utf8.len = 0;\n+        match s {\n+            Ok(s) => {\n+                assert_eq!(char_width, s.len());\n+                let written = write_valid_utf8_to_console(handle, s)?;\n+                assert_eq!(written, s.len()); // guaranteed by write_valid_utf8_to_console() for single codepoint writes\n+                return Ok(1);\n+            }\n+            Err(_) => {\n+                return Err(io::Error::new_const(\n+                    io::ErrorKind::InvalidData,\n+                    &\"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n+                ));\n+            }\n+        }\n+    }\n+\n+    // As the console is meant for presenting text, we assume bytes of `data` are encoded as UTF-8,\n+    // which needs to be encoded as UTF-16.\n     //\n     // If the data is not valid UTF-8 we write out as many bytes as are valid.\n-    // Only when there are no valid bytes (which will happen on the next call), return an error.\n+    // If the first byte is invalid it is either first byte of a multi-byte sequence but the\n+    // provided byte slice is too short or it is the first byte of an invalide multi-byte sequence.\n     let len = cmp::min(data.len(), MAX_BUFFER_SIZE / 2);\n     let utf8 = match str::from_utf8(&data[..len]) {\n         Ok(s) => s,\n         Err(ref e) if e.valid_up_to() == 0 => {\n-            return Err(io::Error::new_const(\n-                io::ErrorKind::InvalidData,\n-                &\"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n-            ));\n+            let first_byte_char_width = utf8_char_width(data[0]);\n+            if first_byte_char_width > 1 && data.len() < first_byte_char_width {\n+                incomplete_utf8.bytes[0] = data[0];\n+                incomplete_utf8.len = 1;\n+                return Ok(1);\n+            } else {\n+                return Err(io::Error::new_const(\n+                    io::ErrorKind::InvalidData,\n+                    &\"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n+                ));\n+            }\n         }\n         Err(e) => str::from_utf8(&data[..e.valid_up_to()]).unwrap(),\n     };\n+\n+    write_valid_utf8_to_console(handle, utf8)\n+}\n+\n+fn write_valid_utf8_to_console(handle: c::HANDLE, utf8: &str) -> io::Result<usize> {\n     let mut utf16 = [0u16; MAX_BUFFER_SIZE / 2];\n     let mut len_utf16 = 0;\n     for (chr, dest) in utf8.encode_utf16().zip(utf16.iter_mut()) {\n@@ -259,15 +329,21 @@ fn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n     Ok(written)\n }\n \n+impl IncompleteUtf8 {\n+    pub const fn new() -> IncompleteUtf8 {\n+        IncompleteUtf8 { bytes: [0; 4], len: 0 }\n+    }\n+}\n+\n impl Stdout {\n     pub const fn new() -> Stdout {\n-        Stdout\n+        Stdout { incomplete_utf8: IncompleteUtf8::new() }\n     }\n }\n \n impl io::Write for Stdout {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        write(c::STD_OUTPUT_HANDLE, buf)\n+        write(c::STD_OUTPUT_HANDLE, buf, &mut self.incomplete_utf8)\n     }\n \n     fn flush(&mut self) -> io::Result<()> {\n@@ -277,13 +353,13 @@ impl io::Write for Stdout {\n \n impl Stderr {\n     pub const fn new() -> Stderr {\n-        Stderr\n+        Stderr { incomplete_utf8: IncompleteUtf8::new() }\n     }\n }\n \n impl io::Write for Stderr {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        write(c::STD_ERROR_HANDLE, buf)\n+        write(c::STD_ERROR_HANDLE, buf, &mut self.incomplete_utf8)\n     }\n \n     fn flush(&mut self) -> io::Result<()> {"}]}