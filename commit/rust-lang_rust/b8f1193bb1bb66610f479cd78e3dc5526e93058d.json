{"sha": "b8f1193bb1bb66610f479cd78e3dc5526e93058d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZjExOTNiYjFiYjY2NjEwZjQ3OWNkNzhlM2RjNTUyNmU5MzA1OGQ=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-17T01:57:11Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-09T04:40:39Z"}, "message": "Runtime removal: refactor timer\n\nThis patch continues runtime removal by moving out timer-related code\ninto `sys`.\n\nBecause this eliminates APIs in `libnative` and `librustrt`, it is a:\n\n[breaking-change]\n\nThis functionality is likely to be available publicly, in some form,\nfrom `std` in the future.", "tree": {"sha": "4fbf269f6f0e31069f62ce6539c7d2ccfb7c0f35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fbf269f6f0e31069f62ce6539c7d2ccfb7c0f35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8f1193bb1bb66610f479cd78e3dc5526e93058d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8f1193bb1bb66610f479cd78e3dc5526e93058d", "html_url": "https://github.com/rust-lang/rust/commit/b8f1193bb1bb66610f479cd78e3dc5526e93058d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8f1193bb1bb66610f479cd78e3dc5526e93058d/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f98e75b69d16edce9ca60d7961b8440856a3f72", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f98e75b69d16edce9ca60d7961b8440856a3f72", "html_url": "https://github.com/rust-lang/rust/commit/0f98e75b69d16edce9ca60d7961b8440856a3f72"}], "stats": {"total": 143, "additions": 60, "deletions": 83}, "files": [{"sha": "5d6d23f5f03abdef0312997d924db80e2ee5b609", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b8f1193bb1bb66610f479cd78e3dc5526e93058d/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f1193bb1bb66610f479cd78e3dc5526e93058d/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=b8f1193bb1bb66610f479cd78e3dc5526e93058d", "patch": "@@ -29,19 +29,6 @@ use std::os;\n use std::rt::rtio::{mod, IoResult, IoError};\n use std::num;\n \n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"ios\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"android\",\n-          target_os = \"linux\"))]\n-#[path = \"timer_unix.rs\"]\n-pub mod timer;\n-\n-#[cfg(target_os = \"windows\")]\n-#[path = \"timer_windows.rs\"]\n-pub mod timer;\n-\n #[cfg(windows)]\n #[path = \"tty_windows.rs\"]\n mod tty;\n@@ -112,10 +99,6 @@ impl IoFactory {\n }\n \n impl rtio::IoFactory for IoFactory {\n-    // misc\n-    fn timer_init(&mut self) -> IoResult<Box<rtio::RtioTimer + Send>> {\n-        timer::Timer::new().map(|t| box t as Box<rtio::RtioTimer + Send>)\n-    }\n     #[cfg(unix)]\n     fn tty_open(&mut self, fd: c_int, _readable: bool)\n                 -> IoResult<Box<rtio::RtioTTY + Send>> {"}, {"sha": "ec588f134784af9c69e746951668fedef27a9970", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b8f1193bb1bb66610f479cd78e3dc5526e93058d/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f1193bb1bb66610f479cd78e3dc5526e93058d/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=b8f1193bb1bb66610f479cd78e3dc5526e93058d", "patch": "@@ -21,10 +21,9 @@ and create receivers which will receive notifications after a period of time.\n \n use comm::{Receiver, Sender, channel};\n use time::Duration;\n-use io::{IoResult, IoError};\n-use kinds::Send;\n-use boxed::Box;\n-use rt::rtio::{IoFactory, LocalIo, RtioTimer, Callback};\n+use io::IoResult;\n+use sys::timer::Callback;\n+use sys::timer::Timer as TimerImp;\n \n /// A synchronous timer object\n ///\n@@ -69,7 +68,7 @@ use rt::rtio::{IoFactory, LocalIo, RtioTimer, Callback};\n /// # }\n /// ```\n pub struct Timer {\n-    obj: Box<RtioTimer + Send>,\n+    inner: TimerImp,\n }\n \n struct TimerCallback { tx: Sender<()> }\n@@ -90,9 +89,7 @@ impl Timer {\n     /// for a number of milliseconds, or to possibly create channels which will\n     /// get notified after an amount of time has passed.\n     pub fn new() -> IoResult<Timer> {\n-        LocalIo::maybe_raise(|io| {\n-            io.timer_init().map(|t| Timer { obj: t })\n-        }).map_err(IoError::from_rtio_error)\n+        TimerImp::new().map(|t| Timer { inner: t })\n     }\n \n     /// Blocks the current task for the specified duration.\n@@ -106,7 +103,7 @@ impl Timer {\n         // Short-circuit the timer backend for 0 duration\n         let ms = in_ms_u64(duration);\n         if ms == 0 { return }\n-        self.obj.sleep(ms);\n+        self.inner.sleep(ms);\n     }\n \n     /// Creates a oneshot receiver which will have a notification sent when\n@@ -152,7 +149,7 @@ impl Timer {\n         let (tx, rx) = channel();\n         // Short-circuit the timer backend for 0 duration\n         if in_ms_u64(duration) != 0 {\n-            self.obj.oneshot(in_ms_u64(duration), box TimerCallback { tx: tx });\n+            self.inner.oneshot(in_ms_u64(duration), box TimerCallback { tx: tx });\n         } else {\n             tx.send(());\n         }\n@@ -213,7 +210,7 @@ impl Timer {\n         // not clear what use a 0ms period is anyway...\n         let ms = if ms == 0 { 1 } else { ms };\n         let (tx, rx) = channel();\n-        self.obj.period(ms, box TimerCallback { tx: tx });\n+        self.inner.period(ms, box TimerCallback { tx: tx });\n         return rx\n     }\n }"}, {"sha": "03a4e56f00dc46fd3390378953b68b5b18e0cfbb", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8f1193bb1bb66610f479cd78e3dc5526e93058d/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f1193bb1bb66610f479cd78e3dc5526e93058d/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=b8f1193bb1bb66610f479cd78e3dc5526e93058d", "patch": "@@ -34,6 +34,7 @@ pub mod udp;\n pub mod pipe;\n pub mod helper_signal;\n pub mod process;\n+pub mod timer;\n \n pub mod addrinfo {\n     pub use sys_common::net::get_host_addresses;"}, {"sha": "a1e6ac3db7e38b7287f1e0c06e8c1b73a6ead872", "filename": "src/libstd/sys/unix/timer.rs", "status": "renamed", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b8f1193bb1bb66610f479cd78e3dc5526e93058d/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f1193bb1bb66610f479cd78e3dc5526e93058d/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=b8f1193bb1bb66610f479cd78e3dc5526e93058d", "patch": "@@ -47,27 +47,30 @@\n //! Note that all time units in this file are in *milliseconds*.\n \n use libc;\n-use std::mem;\n-use std::os;\n-use std::ptr;\n-use std::rt::rtio;\n-use std::rt::rtio::IoResult;\n-use std::sync::atomic;\n-use std::comm;\n-\n-use io::c;\n-use platform_imp::fs::FileDesc;\n-use io::helper_thread::Helper;\n+use mem;\n+use os;\n+use ptr;\n+use sync::atomic;\n+use comm;\n+use sys::c;\n+use sys::fs::FileDesc;\n+use sys_common::helper_thread::Helper;\n+use prelude::*;\n+use io::IoResult;\n \n helper_init!(static HELPER: Helper<Req>)\n \n+pub trait Callback {\n+    fn call(&mut self);\n+}\n+\n pub struct Timer {\n     id: uint,\n     inner: Option<Box<Inner>>,\n }\n \n pub struct Inner {\n-    cb: Option<Box<rtio::Callback + Send>>,\n+    cb: Option<Box<Callback + Send>>,\n     interval: u64,\n     repeat: bool,\n     target: u64,\n@@ -190,11 +193,11 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n \n                 // drain the file descriptor\n                 let mut buf = [0];\n-                assert_eq!(fd.inner_read(buf).ok().unwrap(), 1);\n+                assert_eq!(fd.read(buf).ok().unwrap(), 1);\n             }\n \n-            -1 if os::errno() == libc::EINTR as int => {}\n-            n => panic!(\"helper thread panicked in select() with error: {} ({})\",\n+            -1 if os::errno() == libc::EINTR as uint => {}\n+            n => panic!(\"helper thread failed in select() with error: {} ({})\",\n                        n, os::last_os_error())\n         }\n     }\n@@ -220,7 +223,11 @@ impl Timer {\n         })\n     }\n \n-    pub fn sleep(ms: u64) {\n+    pub fn sleep(&mut self, ms: u64) {\n+        let mut inner = self.inner();\n+        inner.cb = None; // cancel any previous request\n+        self.inner = Some(inner);\n+\n         let mut to_sleep = libc::timespec {\n             tv_sec: (ms / 1000) as libc::time_t,\n             tv_nsec: ((ms % 1000) * 1000000) as libc::c_long,\n@@ -232,28 +239,7 @@ impl Timer {\n         }\n     }\n \n-    fn inner(&mut self) -> Box<Inner> {\n-        match self.inner.take() {\n-            Some(i) => i,\n-            None => {\n-                let (tx, rx) = channel();\n-                HELPER.send(RemoveTimer(self.id, tx));\n-                rx.recv()\n-            }\n-        }\n-    }\n-}\n-\n-impl rtio::RtioTimer for Timer {\n-    fn sleep(&mut self, msecs: u64) {\n-        let mut inner = self.inner();\n-        inner.cb = None; // cancel any previous request\n-        self.inner = Some(inner);\n-\n-        Timer::sleep(msecs);\n-    }\n-\n-    fn oneshot(&mut self, msecs: u64, cb: Box<rtio::Callback + Send>) {\n+    pub fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n         let now = now();\n         let mut inner = self.inner();\n \n@@ -265,7 +251,7 @@ impl rtio::RtioTimer for Timer {\n         HELPER.send(NewTimer(inner));\n     }\n \n-    fn period(&mut self, msecs: u64, cb: Box<rtio::Callback + Send>) {\n+    pub fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n         let now = now();\n         let mut inner = self.inner();\n \n@@ -276,6 +262,17 @@ impl rtio::RtioTimer for Timer {\n \n         HELPER.send(NewTimer(inner));\n     }\n+\n+    fn inner(&mut self) -> Box<Inner> {\n+        match self.inner.take() {\n+            Some(i) => i,\n+            None => {\n+                let (tx, rx) = channel();\n+                HELPER.send(RemoveTimer(self.id, tx));\n+                rx.recv()\n+            }\n+        }\n+    }\n }\n \n impl Drop for Timer {", "previous_filename": "src/libnative/io/timer_unix.rs"}, {"sha": "0dc06de33e0cc753f527f09db983d6603243421f", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8f1193bb1bb66610f479cd78e3dc5526e93058d/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f1193bb1bb66610f479cd78e3dc5526e93058d/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=b8f1193bb1bb66610f479cd78e3dc5526e93058d", "patch": "@@ -41,6 +41,7 @@ pub mod udp;\n pub mod pipe;\n pub mod helper_signal;\n pub mod process;\n+pub mod timer;\n \n pub mod addrinfo {\n     pub use sys_common::net::get_host_addresses;"}, {"sha": "f507be2a985dfed573913e5eb4eda883d33e195a", "filename": "src/libstd/sys/windows/timer.rs", "status": "renamed", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b8f1193bb1bb66610f479cd78e3dc5526e93058d/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8f1193bb1bb66610f479cd78e3dc5526e93058d/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=b8f1193bb1bb66610f479cd78e3dc5526e93058d", "patch": "@@ -21,15 +21,21 @@\n //! the other two implementations of timers with nothing *that* new showing up.\n \n use libc;\n-use std::ptr;\n-use std::rt::rtio;\n-use std::rt::rtio::{IoResult, Callback};\n-use std::comm;\n+use ptr;\n+use comm;\n \n-use io::helper_thread::Helper;\n+use sys::c;\n+use sys::fs::FileDesc;\n+use sys_common::helper_thread::Helper;\n+use prelude::*;\n+use io::IoResult;\n \n helper_init!(static HELPER: Helper<Req>)\n \n+pub trait Callback {\n+    fn call(&mut self);\n+}\n+\n pub struct Timer {\n     obj: libc::HANDLE,\n     on_worker: bool,\n@@ -116,12 +122,6 @@ impl Timer {\n         }\n     }\n \n-    pub fn sleep(ms: u64) {\n-        use std::rt::rtio::RtioTimer;\n-        let mut t = Timer::new().ok().expect(\"must allocate a timer!\");\n-        t.sleep(ms);\n-    }\n-\n     fn remove(&mut self) {\n         if !self.on_worker { return }\n \n@@ -131,10 +131,8 @@ impl Timer {\n \n         self.on_worker = false;\n     }\n-}\n \n-impl rtio::RtioTimer for Timer {\n-    fn sleep(&mut self, msecs: u64) {\n+    pub fn sleep(&mut self, msecs: u64) {\n         self.remove();\n \n         // there are 10^6 nanoseconds in a millisecond, and the parameter is in\n@@ -148,7 +146,7 @@ impl rtio::RtioTimer for Timer {\n         let _ = unsafe { imp::WaitForSingleObject(self.obj, libc::INFINITE) };\n     }\n \n-    fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n+    pub fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n         self.remove();\n \n         // see above for the calculation\n@@ -162,7 +160,7 @@ impl rtio::RtioTimer for Timer {\n         self.on_worker = true;\n     }\n \n-    fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n+    pub fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n         self.remove();\n \n         // see above for the calculation", "previous_filename": "src/libnative/io/timer_windows.rs"}]}