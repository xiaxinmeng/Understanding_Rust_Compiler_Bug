{"sha": "0529dc818f4f603c5419e25f44bd1a0b7526c6ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MjlkYzgxOGY0ZjYwM2M1NDE5ZTI1ZjQ0YmQxYTBiNzUyNmM2ZmY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-04T11:45:21Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-05T09:30:56Z"}, "message": "proide ptr_wrapping_offset on Scalars", "tree": {"sha": "b8617319b5c86c0f227ea618e0ec6349e0067144", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8617319b5c86c0f227ea618e0ec6349e0067144"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0529dc818f4f603c5419e25f44bd1a0b7526c6ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0529dc818f4f603c5419e25f44bd1a0b7526c6ff", "html_url": "https://github.com/rust-lang/rust/commit/0529dc818f4f603c5419e25f44bd1a0b7526c6ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0529dc818f4f603c5419e25f44bd1a0b7526c6ff/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "873041009d1c2f5e2034b021133d2f93e901e745", "url": "https://api.github.com/repos/rust-lang/rust/commits/873041009d1c2f5e2034b021133d2f93e901e745", "html_url": "https://github.com/rust-lang/rust/commit/873041009d1c2f5e2034b021133d2f93e901e745"}], "stats": {"total": 108, "additions": 65, "deletions": 43}, "files": [{"sha": "e2abf7970d6d821fe9808ac3b2cf4b120fd22eb8", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0529dc818f4f603c5419e25f44bd1a0b7526c6ff/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0529dc818f4f603c5419e25f44bd1a0b7526c6ff/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=0529dc818f4f603c5419e25f44bd1a0b7526c6ff", "patch": "@@ -91,42 +91,43 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     }\n \n     //// Trunace the given value to the pointer size; also return whether there was an overflow\n+    #[inline]\n     fn truncate_to_ptr(&self, val: u128) -> (u64, bool) {\n         let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n         ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n     }\n \n-    // Overflow checking only works properly on the range from -u64 to +u64.\n-    fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n-        // FIXME: is it possible to over/underflow here?\n-        if i < 0 {\n-            // trickery to ensure that i64::min_value() works fine\n-            // this formula only works for true negative values, it panics for zero!\n-            let n = u64::max_value() - (i as u64) + 1;\n-            val.overflowing_sub(n)\n-        } else {\n-            self.overflowing_offset(val, i as u64)\n-        }\n+    #[inline]\n+    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_offset(val, i);\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n+    #[inline]\n     fn overflowing_offset(&self, val: u64, i: u64) -> (u64, bool) {\n         let (res, over1) = val.overflowing_add(i);\n-        let (res, over2) = self.truncate_to_ptr(res as u128);\n+        let (res, over2) = self.truncate_to_ptr(u128::from(res));\n         (res, over1 || over2)\n     }\n \n+    #[inline]\n     fn signed_offset<'tcx>(&self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_signed_offset(val, i as i128);\n+        let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n         if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n-    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_offset(val, i);\n-        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n-    }\n-\n-    fn wrapping_signed_offset(&self, val: u64, i: i64) -> u64 {\n-        self.overflowing_signed_offset(val, i as i128).0\n+    // Overflow checking only works properly on the range from -u64 to +u64.\n+    #[inline]\n+    fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n+        // FIXME: is it possible to over/underflow here?\n+        if i < 0 {\n+            // trickery to ensure that i64::min_value() works fine\n+            // this formula only works for true negative values, it panics for zero!\n+            let n = u64::max_value() - (i as u64) + 1;\n+            val.overflowing_sub(n)\n+        } else {\n+            self.overflowing_offset(val, i as u64)\n+        }\n     }\n }\n \n@@ -176,19 +177,27 @@ impl<'tcx, Tag> Pointer<Tag> {\n         Pointer { alloc_id, offset, tag }\n     }\n \n-    pub fn wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n-        Pointer::new_with_tag(\n+    #[inline]\n+    pub fn offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+        Ok(Pointer::new_with_tag(\n             self.alloc_id,\n-            Size::from_bytes(cx.data_layout().wrapping_signed_offset(self.offset.bytes(), i)),\n-            self.tag,\n-        )\n+            Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n+            self.tag\n+        ))\n     }\n \n-    pub fn overflowing_signed_offset(self, i: i128, cx: &impl HasDataLayout) -> (Self, bool) {\n-        let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n+    #[inline]\n+    pub fn overflowing_offset(self, i: Size, cx: &impl HasDataLayout) -> (Self, bool) {\n+        let (res, over) = cx.data_layout().overflowing_offset(self.offset.bytes(), i.bytes());\n         (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n     }\n \n+    #[inline(always)]\n+    pub fn wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n+        self.overflowing_offset(i, cx).0\n+    }\n+\n+    #[inline]\n     pub fn signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         Ok(Pointer::new_with_tag(\n             self.alloc_id,\n@@ -197,20 +206,18 @@ impl<'tcx, Tag> Pointer<Tag> {\n         ))\n     }\n \n-    pub fn overflowing_offset(self, i: Size, cx: &impl HasDataLayout) -> (Self, bool) {\n-        let (res, over) = cx.data_layout().overflowing_offset(self.offset.bytes(), i.bytes());\n+    #[inline]\n+    pub fn overflowing_signed_offset(self, i: i128, cx: &impl HasDataLayout) -> (Self, bool) {\n+        let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n         (Pointer::new_with_tag(self.alloc_id, Size::from_bytes(res), self.tag), over)\n     }\n \n-    pub fn offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n-        Ok(Pointer::new_with_tag(\n-            self.alloc_id,\n-            Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n-            self.tag\n-        ))\n+    #[inline(always)]\n+    pub fn wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n+        self.overflowing_signed_offset(i128::from(i), cx).0\n     }\n \n-    #[inline]\n+    #[inline(always)]\n     pub fn erase_tag(self) -> Pointer {\n         Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n     }"}, {"sha": "66faebb8c03ed9fb73a8a0ca5ffa75356ec5f318", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0529dc818f4f603c5419e25f44bd1a0b7526c6ff/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0529dc818f4f603c5419e25f44bd1a0b7526c6ff/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=0529dc818f4f603c5419e25f44bd1a0b7526c6ff", "patch": "@@ -143,32 +143,47 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     #[inline]\n-    pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let dl = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n                 Ok(Scalar::Bits {\n-                    bits: dl.signed_offset(bits as u64, i)? as u128,\n+                    bits: dl.offset(bits as u64, i.bytes())? as u128,\n                     size,\n                 })\n             }\n-            Scalar::Ptr(ptr) => ptr.signed_offset(i, dl).map(Scalar::Ptr),\n+            Scalar::Ptr(ptr) => ptr.offset(i, dl).map(Scalar::Ptr),\n         }\n     }\n \n     #[inline]\n-    pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n         let dl = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n+                Scalar::Bits {\n+                    bits: dl.overflowing_offset(bits as u64, i.bytes()).0 as u128,\n+                    size,\n+                }\n+            }\n+            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_offset(i, dl)),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n+        let dl = cx.data_layout();\n+        match self {\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(size as u64, dl.pointer_size().bytes());\n                 Ok(Scalar::Bits {\n-                    bits: dl.offset(bits as u64, i.bytes())? as u128,\n+                    bits: dl.signed_offset(bits as u64, i)? as u128,\n                     size,\n                 })\n             }\n-            Scalar::Ptr(ptr) => ptr.offset(i, dl).map(Scalar::Ptr),\n+            Scalar::Ptr(ptr) => ptr.signed_offset(i, dl).map(Scalar::Ptr),\n         }\n     }\n \n@@ -179,7 +194,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n                 Scalar::Bits {\n-                    bits: dl.wrapping_signed_offset(bits as u64, i) as u128,\n+                    bits: dl.overflowing_signed_offset(bits as u64, i128::from(i)).0 as u128,\n                     size,\n                 }\n             }"}]}