{"sha": "629a613faa65344163f922a7e95f6caaddf4ca5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyOWE2MTNmYWE2NTM0NDE2M2Y5MjJhN2U5NWY2Y2FhZGRmNGNhNWU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-23T13:57:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-23T13:57:13Z"}, "message": "Rollup merge of #71198 - oli-obk:const_check_cleanup, r=RalfJung\n\nConst check/promotion cleanup and sanity assertion\n\nr? @RalfJung\n\nThis is just the part of https://github.com/rust-lang/rust/pull/70042#issuecomment-614592765 that does not change behaviour", "tree": {"sha": "cb20906af853dc8a70bdf9818f35a6a1f0a0ad2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb20906af853dc8a70bdf9818f35a6a1f0a0ad2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/629a613faa65344163f922a7e95f6caaddf4ca5e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeoZ65CRBK7hj4Ov3rIwAAdHIIAFmUel9KVAY5eR2WZa6ZREgp\n9xvQAEIHzIZDjF4q22KzSDZ+h8J51kUU//gHpevBwCvId1VGzCgEhL+2Hyl4OsSc\nCFiDMg/Y6MU3cwXwW9RI/F4wLVkNiMpBlBmGzhxbzmjc0Ir3L1gX81sk6qyqKXT5\nmGTlqro6Dxi9f1jlfELaiQFSffxKOEFH0nMzfopVA0OglnRYZVrBL+xYw02RQ1s0\n6MzBrCNYQINvD1LohQLucdSC9b0cwk9Q78v9OMZjYzVrpkN50Ajxm1t+j1kcAZq/\ngcI2PWaMeiHLev2eZjW6DN1Gw41pZo7/q+OupTuRd5/wUPTLWsoqriCy3z1on8k=\n=SFaE\n-----END PGP SIGNATURE-----\n", "payload": "tree cb20906af853dc8a70bdf9818f35a6a1f0a0ad2e\nparent 61fbc6a394e00778876a5776db27a5e58231f67b\nparent 4cdc31b965a6c966922c60b18594d4ea85a54587\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587650233 +0200\ncommitter GitHub <noreply@github.com> 1587650233 +0200\n\nRollup merge of #71198 - oli-obk:const_check_cleanup, r=RalfJung\n\nConst check/promotion cleanup and sanity assertion\n\nr? @RalfJung\n\nThis is just the part of https://github.com/rust-lang/rust/pull/70042#issuecomment-614592765 that does not change behaviour\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/629a613faa65344163f922a7e95f6caaddf4ca5e", "html_url": "https://github.com/rust-lang/rust/commit/629a613faa65344163f922a7e95f6caaddf4ca5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/629a613faa65344163f922a7e95f6caaddf4ca5e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61fbc6a394e00778876a5776db27a5e58231f67b", "url": "https://api.github.com/repos/rust-lang/rust/commits/61fbc6a394e00778876a5776db27a5e58231f67b", "html_url": "https://github.com/rust-lang/rust/commit/61fbc6a394e00778876a5776db27a5e58231f67b"}, {"sha": "4cdc31b965a6c966922c60b18594d4ea85a54587", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cdc31b965a6c966922c60b18594d4ea85a54587", "html_url": "https://github.com/rust-lang/rust/commit/4cdc31b965a6c966922c60b18594d4ea85a54587"}], "stats": {"total": 336, "additions": 180, "deletions": 156}, "files": [{"sha": "179641ec7c03ad1b007ae9f571bf39b1b60e8b18", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=629a613faa65344163f922a7e95f6caaddf4ca5e", "patch": "@@ -42,7 +42,10 @@ use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligations}\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::dataflow::ResultsCursor;\n-use crate::transform::promote_consts::should_suggest_const_in_array_repeat_expressions_attribute;\n+use crate::transform::{\n+    check_consts::ConstCx,\n+    promote_consts::should_suggest_const_in_array_repeat_expressions_attribute,\n+};\n \n use crate::borrow_check::{\n     borrow_set::BorrowSet,\n@@ -1984,14 +1987,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let span = body.source_info(location).span;\n                         let ty = operand.ty(body, tcx);\n                         if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n+                            let ccx = ConstCx::new_with_param_env(\n+                                tcx,\n+                                self.mir_def_id,\n+                                body,\n+                                self.param_env,\n+                            );\n                             // To determine if `const_in_array_repeat_expressions` feature gate should\n                             // be mentioned, need to check if the rvalue is promotable.\n                             let should_suggest =\n                                 should_suggest_const_in_array_repeat_expressions_attribute(\n-                                    tcx,\n-                                    self.mir_def_id,\n-                                    body,\n-                                    operand,\n+                                    &ccx, operand,\n                                 );\n                             debug!(\"check_rvalue: should_suggest={:?}\", should_suggest);\n "}, {"sha": "a630c56ee977f773eadad2be2cc89aee40ee6596", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=629a613faa65344163f922a7e95f6caaddf4ca5e", "patch": "@@ -20,20 +20,29 @@ pub mod validation;\n \n /// Information about the item currently being const-checked, as well as a reference to the global\n /// context.\n-pub struct Item<'mir, 'tcx> {\n+pub struct ConstCx<'mir, 'tcx> {\n     pub body: &'mir mir::Body<'tcx>,\n     pub tcx: TyCtxt<'tcx>,\n     pub def_id: DefId,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub const_kind: Option<ConstKind>,\n }\n \n-impl Item<'mir, 'tcx> {\n+impl ConstCx<'mir, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'mir mir::Body<'tcx>) -> Self {\n         let param_env = tcx.param_env(def_id);\n+        Self::new_with_param_env(tcx, def_id, body, param_env)\n+    }\n+\n+    pub fn new_with_param_env(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        body: &'mir mir::Body<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n         let const_kind = ConstKind::for_item(tcx, def_id);\n \n-        Item { body, tcx, def_id, param_env, const_kind }\n+        ConstCx { body, tcx, def_id, param_env, const_kind }\n     }\n \n     /// Returns the kind of const context this `Item` represents (`const`, `static`, etc.)."}, {"sha": "60eb51f7ccabf03be4ef8261c14c11db87c92e5c", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=629a613faa65344163f922a7e95f6caaddf4ca5e", "patch": "@@ -7,7 +7,7 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n \n-use super::{ConstKind, Item};\n+use super::{ConstCx, ConstKind};\n \n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n@@ -27,19 +27,19 @@ pub trait NonConstOp: std::fmt::Debug {\n     ///\n     /// By default, it returns `true` if and only if this operation has a corresponding feature\n     /// gate and that gate is enabled.\n-    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n-        Self::feature_gate().map_or(false, |gate| item.tcx.features().enabled(gate))\n+    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n+        Self::feature_gate().map_or(false, |gate| ccx.tcx.features().enabled(gate))\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0019,\n             \"{} contains unimplemented expression type\",\n-            item.const_kind()\n+            ccx.const_kind()\n         );\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"A function call isn't allowed in the const's initialization expression \\\n                       because the expression's value must be known at compile-time.\",\n@@ -66,9 +66,9 @@ impl NonConstOp for Downcast {\n #[derive(Debug)]\n pub struct FnCallIndirect;\n impl NonConstOp for FnCallIndirect {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err =\n-            item.tcx.sess.struct_span_err(span, \"function pointers are not allowed in const fn\");\n+            ccx.tcx.sess.struct_span_err(span, \"function pointers are not allowed in const fn\");\n         err.emit();\n     }\n }\n@@ -77,14 +77,14 @@ impl NonConstOp for FnCallIndirect {\n #[derive(Debug)]\n pub struct FnCallNonConst(pub DefId);\n impl NonConstOp for FnCallNonConst {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0015,\n             \"calls in {}s are limited to constant functions, \\\n              tuple structs and tuple variants\",\n-            item.const_kind(),\n+            ccx.const_kind(),\n         );\n         err.emit();\n     }\n@@ -96,12 +96,12 @@ impl NonConstOp for FnCallNonConst {\n #[derive(Debug)]\n pub struct FnCallUnstable(pub DefId, pub Symbol);\n impl NonConstOp for FnCallUnstable {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let FnCallUnstable(def_id, feature) = *self;\n \n-        let mut err = item.tcx.sess.struct_span_err(\n+        let mut err = ccx.tcx.sess.struct_span_err(\n             span,\n-            &format!(\"`{}` is not yet stable as a const fn\", item.tcx.def_path_str(def_id)),\n+            &format!(\"`{}` is not yet stable as a const fn\", ccx.tcx.def_path_str(def_id)),\n         );\n         if nightly_options::is_nightly_build() {\n             err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", feature));\n@@ -113,16 +113,16 @@ impl NonConstOp for FnCallUnstable {\n #[derive(Debug)]\n pub struct HeapAllocation;\n impl NonConstOp for HeapAllocation {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0010,\n             \"allocations are not allowed in {}s\",\n-            item.const_kind()\n+            ccx.const_kind()\n         );\n-        err.span_label(span, format!(\"allocation not allowed in {}s\", item.const_kind()));\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+        err.span_label(span, format!(\"allocation not allowed in {}s\", ccx.const_kind()));\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"The value of statics and constants must be known at compile time, \\\n                  and they live for the entire lifetime of a program. Creating a boxed \\\n@@ -141,9 +141,9 @@ impl NonConstOp for IfOrMatch {\n         Some(sym::const_if_match)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         // This should be caught by the HIR const-checker.\n-        item.tcx.sess.delay_span_bug(span, \"complex control flow is forbidden in a const context\");\n+        ccx.tcx.sess.delay_span_bug(span, \"complex control flow is forbidden in a const context\");\n     }\n }\n \n@@ -154,14 +154,14 @@ impl NonConstOp for InlineAsm {}\n #[derive(Debug)]\n pub struct LiveDrop;\n impl NonConstOp for LiveDrop {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0493,\n             \"destructors cannot be evaluated at compile-time\"\n         )\n-        .span_label(span, format!(\"{}s cannot evaluate destructors\", item.const_kind()))\n+        .span_label(span, format!(\"{}s cannot evaluate destructors\", ccx.const_kind()))\n         .emit();\n     }\n }\n@@ -173,18 +173,18 @@ impl NonConstOp for Loop {\n         Some(sym::const_loop)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         // This should be caught by the HIR const-checker.\n-        item.tcx.sess.delay_span_bug(span, \"complex control flow is forbidden in a const context\");\n+        ccx.tcx.sess.delay_span_bug(span, \"complex control flow is forbidden in a const context\");\n     }\n }\n \n #[derive(Debug)]\n pub struct CellBorrow;\n impl NonConstOp for CellBorrow {\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0492,\n             \"cannot borrow a constant which may contain \\\n@@ -201,19 +201,19 @@ impl NonConstOp for MutBorrow {\n         Some(sym::const_mut_refs)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n             span,\n             &format!(\n                 \"references in {}s may only refer \\\n                       to immutable values\",\n-                item.const_kind()\n+                ccx.const_kind()\n             ),\n         );\n-        err.span_label(span, format!(\"{}s require immutable values\", item.const_kind()));\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+        err.span_label(span, format!(\"{}s require immutable values\", ccx.const_kind()));\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"References in statics and constants may only refer \\\n                       to immutable values.\\n\\n\\\n@@ -236,12 +236,12 @@ impl NonConstOp for MutAddressOf {\n         Some(sym::const_mut_refs)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n             span,\n-            &format!(\"`&raw mut` is not allowed in {}s\", item.const_kind()),\n+            &format!(\"`&raw mut` is not allowed in {}s\", ccx.const_kind()),\n         )\n         .emit();\n     }\n@@ -262,12 +262,12 @@ impl NonConstOp for Panic {\n         Some(sym::const_panic)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_panic,\n             span,\n-            &format!(\"panicking in {}s is unstable\", item.const_kind()),\n+            &format!(\"panicking in {}s is unstable\", ccx.const_kind()),\n         )\n         .emit();\n     }\n@@ -280,12 +280,12 @@ impl NonConstOp for RawPtrComparison {\n         Some(sym::const_compare_raw_pointers)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_compare_raw_pointers,\n             span,\n-            &format!(\"comparing raw pointers inside {}\", item.const_kind()),\n+            &format!(\"comparing raw pointers inside {}\", ccx.const_kind()),\n         )\n         .emit();\n     }\n@@ -298,12 +298,12 @@ impl NonConstOp for RawPtrDeref {\n         Some(sym::const_raw_ptr_deref)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_raw_ptr_deref,\n             span,\n-            &format!(\"dereferencing raw pointers in {}s is unstable\", item.const_kind(),),\n+            &format!(\"dereferencing raw pointers in {}s is unstable\", ccx.const_kind(),),\n         )\n         .emit();\n     }\n@@ -316,12 +316,12 @@ impl NonConstOp for RawPtrToIntCast {\n         Some(sym::const_raw_ptr_to_usize_cast)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_raw_ptr_to_usize_cast,\n             span,\n-            &format!(\"casting pointers to integers in {}s is unstable\", item.const_kind(),),\n+            &format!(\"casting pointers to integers in {}s is unstable\", ccx.const_kind(),),\n         )\n         .emit();\n     }\n@@ -331,22 +331,22 @@ impl NonConstOp for RawPtrToIntCast {\n #[derive(Debug)]\n pub struct StaticAccess;\n impl NonConstOp for StaticAccess {\n-    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n-        item.const_kind().is_static()\n+    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n+        ccx.const_kind().is_static()\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0013,\n             \"{}s cannot refer to statics\",\n-            item.const_kind()\n+            ccx.const_kind()\n         );\n         err.help(\n             \"consider extracting the value of the `static` to a `const`, and referring to that\",\n         );\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"`static` and `const` variables can refer to other `const` variables. \\\n                     A `const` variable, however, cannot refer to a `static` variable.\",\n@@ -363,9 +363,9 @@ pub struct ThreadLocalAccess;\n impl NonConstOp for ThreadLocalAccess {\n     const IS_SUPPORTED_IN_MIRI: bool = false;\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         struct_span_err!(\n-            item.tcx.sess,\n+            ccx.tcx.sess,\n             span,\n             E0625,\n             \"thread-local statics cannot be \\\n@@ -378,19 +378,19 @@ impl NonConstOp for ThreadLocalAccess {\n #[derive(Debug)]\n pub struct UnionAccess;\n impl NonConstOp for UnionAccess {\n-    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n+    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n         // Union accesses are stable in all contexts except `const fn`.\n-        item.const_kind() != ConstKind::ConstFn\n-            || item.tcx.features().enabled(Self::feature_gate().unwrap())\n+        ccx.const_kind() != ConstKind::ConstFn\n+            || ccx.tcx.features().enabled(Self::feature_gate().unwrap())\n     }\n \n     fn feature_gate() -> Option<Symbol> {\n         Some(sym::const_fn_union)\n     }\n \n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+    fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         feature_err(\n-            &item.tcx.sess.parse_sess,\n+            &ccx.tcx.sess.parse_sess,\n             sym::const_fn_union,\n             span,\n             \"unions in const fn are unstable\","}, {"sha": "f82f06599b74a0f0d5703d555f7592b4952a68b2", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=629a613faa65344163f922a7e95f6caaddf4ca5e", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::{self, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n \n-use super::Item as ConstCx;\n+use super::ConstCx;\n \n pub fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> ConstQualifs {\n     ConstQualifs {"}, {"sha": "a81d7a23be2fb640c0a60a58396770aa81e437fb", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=629a613faa65344163f922a7e95f6caaddf4ca5e", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::mir::{self, BasicBlock, Local, Location};\n \n use std::marker::PhantomData;\n \n-use super::{qualifs, Item, Qualif};\n+use super::{qualifs, ConstCx, Qualif};\n use crate::dataflow;\n \n /// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n@@ -18,7 +18,7 @@ use crate::dataflow;\n /// the `MaybeMutBorrowedLocals` dataflow pass to see if a `Local` may have become qualified via\n /// an indirect assignment or function call.\n struct TransferFunction<'a, 'mir, 'tcx, Q> {\n-    item: &'a Item<'mir, 'tcx>,\n+    ccx: &'a ConstCx<'mir, 'tcx>,\n     qualifs_per_local: &'a mut BitSet<Local>,\n \n     _qualif: PhantomData<Q>,\n@@ -28,16 +28,16 @@ impl<Q> TransferFunction<'a, 'mir, 'tcx, Q>\n where\n     Q: Qualif,\n {\n-    fn new(item: &'a Item<'mir, 'tcx>, qualifs_per_local: &'a mut BitSet<Local>) -> Self {\n-        TransferFunction { item, qualifs_per_local, _qualif: PhantomData }\n+    fn new(ccx: &'a ConstCx<'mir, 'tcx>, qualifs_per_local: &'a mut BitSet<Local>) -> Self {\n+        TransferFunction { ccx, qualifs_per_local, _qualif: PhantomData }\n     }\n \n     fn initialize_state(&mut self) {\n         self.qualifs_per_local.clear();\n \n-        for arg in self.item.body.args_iter() {\n-            let arg_ty = self.item.body.local_decls[arg].ty;\n-            if Q::in_any_value_of_ty(self.item, arg_ty) {\n+        for arg in self.ccx.body.args_iter() {\n+            let arg_ty = self.ccx.body.local_decls[arg].ty;\n+            if Q::in_any_value_of_ty(self.ccx, arg_ty) {\n                 self.qualifs_per_local.insert(arg);\n             }\n         }\n@@ -72,8 +72,8 @@ where\n     ) {\n         // We cannot reason about another function's internals, so use conservative type-based\n         // qualification for the result of a function call.\n-        let return_ty = return_place.ty(self.item.body, self.item.tcx).ty;\n-        let qualif = Q::in_any_value_of_ty(self.item, return_ty);\n+        let return_ty = return_place.ty(self.ccx.body, self.ccx.tcx).ty;\n+        let qualif = Q::in_any_value_of_ty(self.ccx, return_ty);\n \n         if !return_place.is_indirect() {\n             self.assign_qualif_direct(&return_place, qualif);\n@@ -108,7 +108,7 @@ where\n         location: Location,\n     ) {\n         let qualif = qualifs::in_rvalue::<Q, _>(\n-            self.item,\n+            self.ccx,\n             &mut |l| self.qualifs_per_local.contains(l),\n             rvalue,\n         );\n@@ -127,7 +127,7 @@ where\n \n         if let mir::TerminatorKind::DropAndReplace { value, location: dest, .. } = kind {\n             let qualif = qualifs::in_operand::<Q, _>(\n-                self.item,\n+                self.ccx,\n                 &mut |l| self.qualifs_per_local.contains(l),\n                 value,\n             );\n@@ -145,23 +145,23 @@ where\n \n /// The dataflow analysis used to propagate qualifs on arbitrary CFGs.\n pub(super) struct FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q> {\n-    item: &'a Item<'mir, 'tcx>,\n+    ccx: &'a ConstCx<'mir, 'tcx>,\n     _qualif: PhantomData<Q>,\n }\n \n impl<'a, 'mir, 'tcx, Q> FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>\n where\n     Q: Qualif,\n {\n-    pub(super) fn new(_: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n-        FlowSensitiveAnalysis { item, _qualif: PhantomData }\n+    pub(super) fn new(_: Q, ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n+        FlowSensitiveAnalysis { ccx, _qualif: PhantomData }\n     }\n \n     fn transfer_function(\n         &self,\n         state: &'a mut BitSet<Local>,\n     ) -> TransferFunction<'a, 'mir, 'tcx, Q> {\n-        TransferFunction::<Q>::new(self.item, state)\n+        TransferFunction::<Q>::new(self.ccx, state)\n     }\n }\n "}, {"sha": "45d8e1d08b7219ded92ce987a9d020c96c9ec65a", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=629a613faa65344163f922a7e95f6caaddf4ca5e", "patch": "@@ -20,7 +20,7 @@ use std::ops::Deref;\n use super::ops::{self, NonConstOp};\n use super::qualifs::{self, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n-use super::{is_lang_panic_fn, ConstKind, Item, Qualif};\n+use super::{is_lang_panic_fn, ConstCx, ConstKind, Qualif};\n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::dataflow::MaybeMutBorrowedLocals;\n use crate::dataflow::{self, Analysis};\n@@ -37,15 +37,15 @@ struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n }\n \n impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n-    pub fn new(q: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n-        let cursor = FlowSensitiveAnalysis::new(q, item)\n-            .into_engine(item.tcx, item.body, item.def_id)\n+    pub fn new(q: Q, ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n+        let cursor = FlowSensitiveAnalysis::new(q, ccx)\n+            .into_engine(ccx.tcx, ccx.body, ccx.def_id)\n             .iterate_to_fixpoint()\n-            .into_results_cursor(item.body);\n+            .into_results_cursor(ccx.body);\n \n-        let mut in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n-        for (local, decl) in item.body.local_decls.iter_enumerated() {\n-            if Q::in_any_value_of_ty(item, decl.ty) {\n+        let mut in_any_value_of_ty = BitSet::new_empty(ccx.body.local_decls.len());\n+        for (local, decl) in ccx.body.local_decls.iter_enumerated() {\n+            if Q::in_any_value_of_ty(ccx, decl.ty) {\n                 in_any_value_of_ty.insert(local);\n             }\n         }\n@@ -91,12 +91,12 @@ impl Qualifs<'a, 'mir, 'tcx> {\n             || self.indirectly_mutable(local, location)\n     }\n \n-    fn in_return_place(&mut self, item: &Item<'_, 'tcx>) -> ConstQualifs {\n+    fn in_return_place(&mut self, ccx: &ConstCx<'_, 'tcx>) -> ConstQualifs {\n         // Find the `Return` terminator if one exists.\n         //\n         // If no `Return` terminator exists, this MIR is divergent. Just return the conservative\n         // qualifs for the return type.\n-        let return_block = item\n+        let return_block = ccx\n             .body\n             .basic_blocks()\n             .iter_enumerated()\n@@ -107,11 +107,11 @@ impl Qualifs<'a, 'mir, 'tcx> {\n             .map(|(bb, _)| bb);\n \n         let return_block = match return_block {\n-            None => return qualifs::in_any_value_of_ty(item, item.body.return_ty()),\n+            None => return qualifs::in_any_value_of_ty(ccx, ccx.body.return_ty()),\n             Some(bb) => bb,\n         };\n \n-        let return_loc = item.body.terminator_loc(return_block);\n+        let return_loc = ccx.body.terminator_loc(return_block);\n \n         ConstQualifs {\n             needs_drop: self.needs_drop(RETURN_PLACE, return_loc),\n@@ -121,27 +121,27 @@ impl Qualifs<'a, 'mir, 'tcx> {\n }\n \n pub struct Validator<'a, 'mir, 'tcx> {\n-    item: &'a Item<'mir, 'tcx>,\n+    ccx: &'a ConstCx<'mir, 'tcx>,\n     qualifs: Qualifs<'a, 'mir, 'tcx>,\n \n     /// The span of the current statement.\n     span: Span,\n }\n \n impl Deref for Validator<'_, 'mir, 'tcx> {\n-    type Target = Item<'mir, 'tcx>;\n+    type Target = ConstCx<'mir, 'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n-        &self.item\n+        &self.ccx\n     }\n }\n \n impl Validator<'a, 'mir, 'tcx> {\n-    pub fn new(item: &'a Item<'mir, 'tcx>) -> Self {\n-        let Item { tcx, body, def_id, param_env, .. } = *item;\n+    pub fn new(ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n+        let ConstCx { tcx, body, def_id, param_env, .. } = *ccx;\n \n-        let needs_drop = QualifCursor::new(NeedsDrop, item);\n-        let has_mut_interior = QualifCursor::new(HasMutInterior, item);\n+        let needs_drop = QualifCursor::new(NeedsDrop, ccx);\n+        let has_mut_interior = QualifCursor::new(HasMutInterior, ccx);\n \n         // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n         // allowed in a const.\n@@ -156,11 +156,11 @@ impl Validator<'a, 'mir, 'tcx> {\n \n         let qualifs = Qualifs { needs_drop, has_mut_interior, indirectly_mutable };\n \n-        Validator { span: item.body.span, item, qualifs }\n+        Validator { span: ccx.body.span, ccx, qualifs }\n     }\n \n     pub fn check_body(&mut self) {\n-        let Item { tcx, body, def_id, const_kind, .. } = *self.item;\n+        let ConstCx { tcx, body, def_id, const_kind, .. } = *self.ccx;\n \n         let use_min_const_fn_checks = (const_kind == Some(ConstKind::ConstFn)\n             && crate::const_eval::is_min_const_fn(tcx, def_id))\n@@ -175,7 +175,7 @@ impl Validator<'a, 'mir, 'tcx> {\n             }\n         }\n \n-        check_short_circuiting_in_const_local(self.item);\n+        check_short_circuiting_in_const_local(self.ccx);\n \n         if body.is_cfg_cyclic() {\n             // We can't provide a good span for the error here, but this should be caught by the\n@@ -196,7 +196,7 @@ impl Validator<'a, 'mir, 'tcx> {\n     }\n \n     pub fn qualifs_in_return_place(&mut self) -> ConstQualifs {\n-        self.qualifs.in_return_place(self.item)\n+        self.qualifs.in_return_place(self.ccx)\n     }\n \n     /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n@@ -344,7 +344,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             Rvalue::Ref(_, BorrowKind::Shared | BorrowKind::Shallow, ref place)\n             | Rvalue::AddressOf(Mutability::Not, ref place) => {\n                 let borrowed_place_has_mut_interior = qualifs::in_place::<HasMutInterior, _>(\n-                    &self.item,\n+                    &self.ccx,\n                     &mut |local| self.qualifs.has_mut_interior(local, location),\n                     place.as_ref(),\n                 );\n@@ -608,8 +608,8 @@ fn error_min_const_fn_violation(tcx: TyCtxt<'_>, span: Span, msg: Cow<'_, str>)\n         .emit();\n }\n \n-fn check_short_circuiting_in_const_local(item: &Item<'_, 'tcx>) {\n-    let body = item.body;\n+fn check_short_circuiting_in_const_local(ccx: &ConstCx<'_, 'tcx>) {\n+    let body = ccx.body;\n \n     if body.control_flow_destroyed.is_empty() {\n         return;\n@@ -618,12 +618,12 @@ fn check_short_circuiting_in_const_local(item: &Item<'_, 'tcx>) {\n     let mut locals = body.vars_iter();\n     if let Some(local) = locals.next() {\n         let span = body.local_decls[local].source_info.span;\n-        let mut error = item.tcx.sess.struct_span_err(\n+        let mut error = ccx.tcx.sess.struct_span_err(\n             span,\n             &format!(\n                 \"new features like let bindings are not permitted in {}s \\\n                 which also use short circuiting operators\",\n-                item.const_kind(),\n+                ccx.const_kind(),\n             ),\n         );\n         for (span, kind) in body.control_flow_destroyed.iter() {"}, {"sha": "a87955274a779c790fad76c083ff0dfcc0aaf49d", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=629a613faa65344163f922a7e95f6caaddf4ca5e", "patch": "@@ -194,10 +194,10 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n         return Default::default();\n     }\n \n-    let item =\n-        check_consts::Item { body, tcx, def_id, const_kind, param_env: tcx.param_env(def_id) };\n+    let ccx =\n+        check_consts::ConstCx { body, tcx, def_id, const_kind, param_env: tcx.param_env(def_id) };\n \n-    let mut validator = check_consts::validation::Validator::new(&item);\n+    let mut validator = check_consts::validation::Validator::new(&ccx);\n     validator.check_body();\n \n     // We return the qualifs in the return place for every MIR body, even though it is only used"}, {"sha": "998af4ba39006d6f356cd02110be6505922d1498", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 43, "deletions": 38, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=629a613faa65344163f922a7e95f6caaddf4ca5e", "patch": "@@ -30,7 +30,7 @@ use std::cell::Cell;\n use std::{cmp, iter, mem};\n \n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n-use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstKind, Item};\n+use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstCx, ConstKind};\n use crate::transform::{MirPass, MirSource};\n \n /// A `MirPass` for promotion.\n@@ -62,9 +62,10 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n         let def_id = src.def_id();\n \n         let mut rpo = traversal::reverse_postorder(body);\n-        let (temps, all_candidates) = collect_temps_and_candidates(tcx, body, &mut rpo);\n+        let ccx = ConstCx::new(tcx, def_id, body);\n+        let (temps, all_candidates) = collect_temps_and_candidates(&ccx, &mut rpo);\n \n-        let promotable_candidates = validate_candidates(tcx, body, def_id, &temps, &all_candidates);\n+        let promotable_candidates = validate_candidates(&ccx, &temps, &all_candidates);\n \n         let promoted = promote_candidates(def_id, body, tcx, temps, promotable_candidates);\n         self.promoted_fragments.set(promoted);\n@@ -139,8 +140,7 @@ fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Vec<usize>> {\n }\n \n struct Collector<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    body: &'a Body<'tcx>,\n+    ccx: &'a ConstCx<'a, 'tcx>,\n     temps: IndexVec<Local, TempState>,\n     candidates: Vec<Candidate>,\n     span: Span,\n@@ -150,7 +150,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n     fn visit_local(&mut self, &index: &Local, context: PlaceContext, location: Location) {\n         debug!(\"visit_local: index={:?} context={:?} location={:?}\", index, context, location);\n         // We're only interested in temporaries and the return place\n-        match self.body.local_kind(index) {\n+        match self.ccx.body.local_kind(index) {\n             LocalKind::Temp | LocalKind::ReturnPointer => {}\n             LocalKind::Arg | LocalKind::Var => return,\n         }\n@@ -203,7 +203,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n             Rvalue::Ref(..) => {\n                 self.candidates.push(Candidate::Ref(location));\n             }\n-            Rvalue::Repeat(..) if self.tcx.features().const_in_array_repeat_expressions => {\n+            Rvalue::Repeat(..) if self.ccx.tcx.features().const_in_array_repeat_expressions => {\n                 // FIXME(#49147) only promote the element when it isn't `Copy`\n                 // (so that code that can copy it at runtime is unaffected).\n                 self.candidates.push(Candidate::Repeat(location));\n@@ -216,10 +216,10 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n         self.super_terminator_kind(kind, location);\n \n         if let TerminatorKind::Call { ref func, .. } = *kind {\n-            if let ty::FnDef(def_id, _) = func.ty(self.body, self.tcx).kind {\n-                let fn_sig = self.tcx.fn_sig(def_id);\n+            if let ty::FnDef(def_id, _) = func.ty(self.ccx.body, self.ccx.tcx).kind {\n+                let fn_sig = self.ccx.tcx.fn_sig(def_id);\n                 if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = fn_sig.abi() {\n-                    let name = self.tcx.item_name(def_id);\n+                    let name = self.ccx.tcx.item_name(def_id);\n                     // FIXME(eddyb) use `#[rustc_args_required_const(2)]` for shuffles.\n                     if name.as_str().starts_with(\"simd_shuffle\") {\n                         self.candidates.push(Candidate::Argument { bb: location.block, index: 2 });\n@@ -228,7 +228,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n                     }\n                 }\n \n-                if let Some(constant_args) = args_required_const(self.tcx, def_id) {\n+                if let Some(constant_args) = args_required_const(self.ccx.tcx, def_id) {\n                     for index in constant_args {\n                         self.candidates.push(Candidate::Argument { bb: location.block, index });\n                     }\n@@ -243,16 +243,14 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n }\n \n pub fn collect_temps_and_candidates(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n+    ccx: &ConstCx<'mir, 'tcx>,\n     rpo: &mut ReversePostorder<'_, 'tcx>,\n ) -> (IndexVec<Local, TempState>, Vec<Candidate>) {\n     let mut collector = Collector {\n-        tcx,\n-        body,\n-        temps: IndexVec::from_elem(TempState::Undefined, &body.local_decls),\n+        temps: IndexVec::from_elem(TempState::Undefined, &ccx.body.local_decls),\n         candidates: vec![],\n-        span: body.span,\n+        span: ccx.body.span,\n+        ccx,\n     };\n     for (bb, data) in rpo {\n         collector.visit_basic_block_data(bb, data);\n@@ -264,7 +262,7 @@ pub fn collect_temps_and_candidates(\n ///\n /// This wraps an `Item`, and has access to all fields of that `Item` via `Deref` coercion.\n struct Validator<'a, 'tcx> {\n-    item: Item<'a, 'tcx>,\n+    ccx: &'a ConstCx<'a, 'tcx>,\n     temps: &'a IndexVec<Local, TempState>,\n \n     /// Explicit promotion happens e.g. for constant arguments declared via\n@@ -277,10 +275,10 @@ struct Validator<'a, 'tcx> {\n }\n \n impl std::ops::Deref for Validator<'a, 'tcx> {\n-    type Target = Item<'a, 'tcx>;\n+    type Target = ConstCx<'a, 'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n-        &self.item\n+        &self.ccx\n     }\n }\n \n@@ -413,7 +411,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n                     StatementKind::Assign(box (_, rhs)) => qualifs::in_rvalue::<Q, _>(\n-                        &self.item,\n+                        &self.ccx,\n                         &mut |l| self.qualif_local::<Q>(l),\n                         rhs,\n                     ),\n@@ -430,7 +428,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 match &terminator.kind {\n                     TerminatorKind::Call { .. } => {\n                         let return_ty = self.body.local_decls[local].ty;\n-                        Q::in_any_value_of_ty(&self.item, return_ty)\n+                        Q::in_any_value_of_ty(&self.ccx, return_ty)\n                     }\n                     kind => {\n                         span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n@@ -717,13 +715,11 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n // FIXME(eddyb) remove the differences for promotability in `static`, `const`, `const fn`.\n pub fn validate_candidates(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n-    def_id: DefId,\n+    ccx: &ConstCx<'_, '_>,\n     temps: &IndexVec<Local, TempState>,\n     candidates: &[Candidate],\n ) -> Vec<Candidate> {\n-    let mut validator = Validator { item: Item::new(tcx, def_id, body), temps, explicit: false };\n+    let mut validator = Validator { ccx, temps, explicit: false };\n \n     candidates\n         .iter()\n@@ -735,11 +731,23 @@ pub fn validate_candidates(\n             // and `#[rustc_args_required_const]` arguments here.\n \n             let is_promotable = validator.validate_candidate(candidate).is_ok();\n+\n+            // If we use explicit validation, we carry the risk of turning a legitimate run-time\n+            // operation into a failing compile-time operation. Make sure that does not happen\n+            // by asserting that there is no possible run-time behavior here in case promotion\n+            // fails.\n+            if validator.explicit && !is_promotable {\n+                ccx.tcx.sess.delay_span_bug(\n+                    ccx.body.span,\n+                    \"Explicit promotion requested, but failed to promote\",\n+                );\n+            }\n+\n             match candidate {\n                 Candidate::Argument { bb, index } if !is_promotable => {\n-                    let span = body[bb].terminator().source_info.span;\n+                    let span = ccx.body[bb].terminator().source_info.span;\n                     let msg = format!(\"argument {} is required to be a constant\", index + 1);\n-                    tcx.sess.span_err(span, &msg);\n+                    ccx.tcx.sess.span_err(span, &msg);\n                 }\n                 _ => (),\n             }\n@@ -1147,22 +1155,19 @@ pub fn promote_candidates<'tcx>(\n /// Feature attribute should be suggested if `operand` can be promoted and the feature is not\n /// enabled.\n crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mir_def_id: DefId,\n-    body: &Body<'tcx>,\n+    ccx: &ConstCx<'_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> bool {\n-    let mut rpo = traversal::reverse_postorder(&body);\n-    let (temps, _) = collect_temps_and_candidates(tcx, &body, &mut rpo);\n-    let validator =\n-        Validator { item: Item::new(tcx, mir_def_id, body), temps: &temps, explicit: false };\n+    let mut rpo = traversal::reverse_postorder(&ccx.body);\n+    let (temps, _) = collect_temps_and_candidates(&ccx, &mut rpo);\n+    let validator = Validator { ccx, temps: &temps, explicit: false };\n \n     let should_promote = validator.validate_operand(operand).is_ok();\n-    let feature_flag = tcx.features().const_in_array_repeat_expressions;\n+    let feature_flag = validator.ccx.tcx.features().const_in_array_repeat_expressions;\n     debug!(\n-        \"should_suggest_const_in_array_repeat_expressions_flag: mir_def_id={:?} \\\n+        \"should_suggest_const_in_array_repeat_expressions_flag: def_id={:?} \\\n             should_promote={:?} feature_flag={:?}\",\n-        mir_def_id, should_promote, feature_flag\n+        validator.ccx.def_id, should_promote, feature_flag\n     );\n     should_promote && !feature_flag\n }"}, {"sha": "1dd5adb2209ef43b9f700117587fe3fe29632f15", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a613faa65344163f922a7e95f6caaddf4ca5e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=629a613faa65344163f922a7e95f6caaddf4ca5e", "patch": "@@ -3338,6 +3338,10 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn delete_file(&self, file: &PathBuf) {\n+        if !file.exists() {\n+            // Deleting a nonexistant file would error.\n+            return;\n+        }\n         if let Err(e) = fs::remove_file(file) {\n             self.fatal(&format!(\"failed to delete `{}`: {}\", file.display(), e,));\n         }\n@@ -3400,7 +3404,7 @@ impl<'test> TestCx<'test> {\n         let examined_content =\n             self.load_expected_output_from_path(&examined_path).unwrap_or_else(|_| String::new());\n \n-        if examined_path.exists() && canon_content == &examined_content {\n+        if canon_content == &examined_content {\n             self.delete_file(&examined_path);\n         }\n     }"}]}