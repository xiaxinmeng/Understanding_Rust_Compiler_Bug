{"sha": "5918ee431717a276ea1a9c65d7c0009679a0643b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MThlZTQzMTcxN2EyNzZlYTFhOWM2NWQ3YzAwMDk2NzlhMDY0M2I=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2021-04-11T19:51:28Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2021-05-13T21:31:57Z"}, "message": "Add support for const operands and options to global_asm!\n\nOn x86, the default syntax is also switched to Intel to match asm!", "tree": {"sha": "b9657afac0da6cacb582b6409db50281e8149f9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9657afac0da6cacb582b6409db50281e8149f9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5918ee431717a276ea1a9c65d7c0009679a0643b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5918ee431717a276ea1a9c65d7c0009679a0643b", "html_url": "https://github.com/rust-lang/rust/commit/5918ee431717a276ea1a9c65d7c0009679a0643b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5918ee431717a276ea1a9c65d7c0009679a0643b/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "952c5732c2d25a875f90e5cd5dd29a1a21c1d4a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/952c5732c2d25a875f90e5cd5dd29a1a21c1d4a2", "html_url": "https://github.com/rust-lang/rust/commit/952c5732c2d25a875f90e5cd5dd29a1a21c1d4a2"}], "stats": {"total": 1728, "additions": 928, "deletions": 800}, "files": [{"sha": "d237997843c94c573b443367972a7ff54fd52d21", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -655,9 +655,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.39\"\n+version = \"0.1.40\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3748f82c7d366a0b4950257d19db685d4958d2fa27c6d164a3f069fec42b748b\"\n+checksum = \"288a0d48b8155926ebb4552bdde3fa32744ce424c5de0a26ddbc68369aeb7172\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\","}, {"sha": "fb012d9802f6cb0c92acbae931391dbec9087c79", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -2279,14 +2279,6 @@ pub struct ForeignMod {\n     pub items: Vec<P<ForeignItem>>,\n }\n \n-/// Global inline assembly.\n-///\n-/// Also known as \"module-level assembly\" or \"file-scoped assembly\".\n-#[derive(Clone, Encodable, Decodable, Debug, Copy)]\n-pub struct GlobalAsm {\n-    pub asm: Symbol,\n-}\n-\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct EnumDef {\n     pub variants: Vec<Variant>,\n@@ -2669,7 +2661,7 @@ pub enum ItemKind {\n     /// E.g., `extern {}` or `extern \"C\" {}`.\n     ForeignMod(ForeignMod),\n     /// Module-level inline assembly (from `global_asm!()`).\n-    GlobalAsm(GlobalAsm),\n+    GlobalAsm(InlineAsm),\n     /// A type alias (`type`).\n     ///\n     /// E.g., `type Foo = Bar<u8>;`."}, {"sha": "374a6ec972fba40e974b402a67fc288329b4c414", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -965,7 +965,7 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             ModKind::Unloaded => {}\n         },\n         ItemKind::ForeignMod(nm) => vis.visit_foreign_mod(nm),\n-        ItemKind::GlobalAsm(_ga) => {}\n+        ItemKind::GlobalAsm(asm) => noop_visit_inline_asm(asm, vis),\n         ItemKind::TyAlias(box TyAliasKind(_, generics, bounds, ty)) => {\n             vis.visit_generics(generics);\n             visit_bounds(bounds, vis);\n@@ -1170,6 +1170,28 @@ pub fn noop_visit_anon_const<T: MutVisitor>(AnonConst { id, value }: &mut AnonCo\n     vis.visit_expr(value);\n }\n \n+fn noop_visit_inline_asm<T: MutVisitor>(asm: &mut InlineAsm, vis: &mut T) {\n+    for (op, _) in &mut asm.operands {\n+        match op {\n+            InlineAsmOperand::In { expr, .. }\n+            | InlineAsmOperand::InOut { expr, .. }\n+            | InlineAsmOperand::Sym { expr, .. } => vis.visit_expr(expr),\n+            InlineAsmOperand::Out { expr, .. } => {\n+                if let Some(expr) = expr {\n+                    vis.visit_expr(expr);\n+                }\n+            }\n+            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                vis.visit_expr(in_expr);\n+                if let Some(out_expr) = out_expr {\n+                    vis.visit_expr(out_expr);\n+                }\n+            }\n+            InlineAsmOperand::Const { anon_const, .. } => vis.visit_anon_const(anon_const),\n+        }\n+    }\n+}\n+\n pub fn noop_visit_expr<T: MutVisitor>(\n     Expr { kind, id, span, attrs, tokens }: &mut Expr,\n     vis: &mut T,\n@@ -1288,27 +1310,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n         ExprKind::Ret(expr) => {\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n-        ExprKind::InlineAsm(asm) => {\n-            for (op, _) in &mut asm.operands {\n-                match op {\n-                    InlineAsmOperand::In { expr, .. }\n-                    | InlineAsmOperand::InOut { expr, .. }\n-                    | InlineAsmOperand::Sym { expr, .. } => vis.visit_expr(expr),\n-                    InlineAsmOperand::Out { expr, .. } => {\n-                        if let Some(expr) = expr {\n-                            vis.visit_expr(expr);\n-                        }\n-                    }\n-                    InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                        vis.visit_expr(in_expr);\n-                        if let Some(out_expr) = out_expr {\n-                            vis.visit_expr(out_expr);\n-                        }\n-                    }\n-                    InlineAsmOperand::Const { anon_const, .. } => vis.visit_anon_const(anon_const),\n-                }\n-            }\n-        }\n+        ExprKind::InlineAsm(asm) => noop_visit_inline_asm(asm, vis),\n         ExprKind::LlvmInlineAsm(asm) => {\n             let LlvmInlineAsm {\n                 asm: _,"}, {"sha": "c50b334d3e94902d558814db1febdf31dfa07c92", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -90,9 +90,6 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_foreign_item(&mut self, i: &'ast ForeignItem) {\n         walk_foreign_item(self, i)\n     }\n-    fn visit_global_asm(&mut self, ga: &'ast GlobalAsm) {\n-        walk_global_asm(self, ga)\n-    }\n     fn visit_item(&mut self, i: &'ast Item) {\n         walk_item(self, i)\n     }\n@@ -299,7 +296,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n         ItemKind::ForeignMod(ref foreign_module) => {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n-        ItemKind::GlobalAsm(ref ga) => visitor.visit_global_asm(ga),\n+        ItemKind::GlobalAsm(ref asm) => walk_inline_asm(visitor, asm),\n         ItemKind::TyAlias(box TyAliasKind(_, ref generics, ref bounds, ref ty)) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n@@ -557,10 +554,6 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignI\n     }\n }\n \n-pub fn walk_global_asm<'a, V: Visitor<'a>>(_: &mut V, _: &'a GlobalAsm) {\n-    // Empty!\n-}\n-\n pub fn walk_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a GenericBound) {\n     match *bound {\n         GenericBound::Trait(ref typ, ref modifier) => visitor.visit_poly_trait_ref(typ, modifier),\n@@ -708,6 +701,28 @@ pub fn walk_anon_const<'a, V: Visitor<'a>>(visitor: &mut V, constant: &'a AnonCo\n     visitor.visit_expr(&constant.value);\n }\n \n+fn walk_inline_asm<'a, V: Visitor<'a>>(visitor: &mut V, asm: &'a InlineAsm) {\n+    for (op, _) in &asm.operands {\n+        match op {\n+            InlineAsmOperand::In { expr, .. }\n+            | InlineAsmOperand::InOut { expr, .. }\n+            | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n+            InlineAsmOperand::Out { expr, .. } => {\n+                if let Some(expr) = expr {\n+                    visitor.visit_expr(expr);\n+                }\n+            }\n+            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                visitor.visit_expr(in_expr);\n+                if let Some(out_expr) = out_expr {\n+                    visitor.visit_expr(out_expr);\n+                }\n+            }\n+            InlineAsmOperand::Const { anon_const, .. } => visitor.visit_anon_const(anon_const),\n+        }\n+    }\n+}\n+\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n@@ -830,29 +845,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         }\n         ExprKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n         ExprKind::Paren(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::InlineAsm(ref ia) => {\n-            for (op, _) in &ia.operands {\n-                match op {\n-                    InlineAsmOperand::In { expr, .. }\n-                    | InlineAsmOperand::InOut { expr, .. }\n-                    | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n-                    InlineAsmOperand::Out { expr, .. } => {\n-                        if let Some(expr) = expr {\n-                            visitor.visit_expr(expr);\n-                        }\n-                    }\n-                    InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                        visitor.visit_expr(in_expr);\n-                        if let Some(out_expr) = out_expr {\n-                            visitor.visit_expr(out_expr);\n-                        }\n-                    }\n-                    InlineAsmOperand::Const { anon_const, .. } => {\n-                        visitor.visit_anon_const(anon_const)\n-                    }\n-                }\n-            }\n-        }\n+        ExprKind::InlineAsm(ref asm) => walk_inline_asm(visitor, asm),\n         ExprKind::LlvmInlineAsm(ref ia) => {\n             for &(_, ref input) in &ia.inputs {\n                 visitor.visit_expr(input)"}, {"sha": "6acdfa1b5f8033edb0e091ace237c33bfe6d97e7", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -0,0 +1,328 @@\n+use super::LoweringContext;\n+\n+use rustc_ast::*;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_span::{Span, Symbol};\n+use rustc_target::asm;\n+use std::collections::hash_map::Entry;\n+use std::fmt::Write;\n+\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    crate fn lower_inline_asm(&mut self, sp: Span, asm: &InlineAsm) -> &'hir hir::InlineAsm<'hir> {\n+        // Rustdoc needs to support asm! from foriegn architectures: don't try\n+        // lowering the register contraints in this case.\n+        let asm_arch = if self.sess.opts.actually_rustdoc { None } else { self.sess.asm_arch };\n+        if asm_arch.is_none() && !self.sess.opts.actually_rustdoc {\n+            struct_span_err!(self.sess, sp, E0472, \"asm! is unsupported on this target\").emit();\n+        }\n+        if asm.options.contains(InlineAsmOptions::ATT_SYNTAX)\n+            && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n+            && !self.sess.opts.actually_rustdoc\n+        {\n+            self.sess\n+                .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n+                .emit();\n+        }\n+\n+        // Lower operands to HIR. We use dummy register classes if an error\n+        // occurs during lowering because we still need to be able to produce a\n+        // valid HIR.\n+        let sess = self.sess;\n+        let operands: Vec<_> = asm\n+            .operands\n+            .iter()\n+            .map(|(op, op_sp)| {\n+                let lower_reg = |reg| match reg {\n+                    InlineAsmRegOrRegClass::Reg(s) => {\n+                        asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n+                            asm::InlineAsmReg::parse(\n+                                asm_arch,\n+                                |feature| sess.target_features.contains(&Symbol::intern(feature)),\n+                                &sess.target,\n+                                s,\n+                            )\n+                            .unwrap_or_else(|e| {\n+                                let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n+                                sess.struct_span_err(*op_sp, &msg).emit();\n+                                asm::InlineAsmReg::Err\n+                            })\n+                        } else {\n+                            asm::InlineAsmReg::Err\n+                        })\n+                    }\n+                    InlineAsmRegOrRegClass::RegClass(s) => {\n+                        asm::InlineAsmRegOrRegClass::RegClass(if let Some(asm_arch) = asm_arch {\n+                            asm::InlineAsmRegClass::parse(asm_arch, s).unwrap_or_else(|e| {\n+                                let msg = format!(\"invalid register class `{}`: {}\", s.as_str(), e);\n+                                sess.struct_span_err(*op_sp, &msg).emit();\n+                                asm::InlineAsmRegClass::Err\n+                            })\n+                        } else {\n+                            asm::InlineAsmRegClass::Err\n+                        })\n+                    }\n+                };\n+\n+                let op = match *op {\n+                    InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n+                        reg: lower_reg(reg),\n+                        expr: self.lower_expr_mut(expr),\n+                    },\n+                    InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n+                        reg: lower_reg(reg),\n+                        late,\n+                        expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                    },\n+                    InlineAsmOperand::InOut { reg, late, ref expr } => {\n+                        hir::InlineAsmOperand::InOut {\n+                            reg: lower_reg(reg),\n+                            late,\n+                            expr: self.lower_expr_mut(expr),\n+                        }\n+                    }\n+                    InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n+                        hir::InlineAsmOperand::SplitInOut {\n+                            reg: lower_reg(reg),\n+                            late,\n+                            in_expr: self.lower_expr_mut(in_expr),\n+                            out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                        }\n+                    }\n+                    InlineAsmOperand::Const { ref anon_const } => hir::InlineAsmOperand::Const {\n+                        anon_const: self.lower_anon_const(anon_const),\n+                    },\n+                    InlineAsmOperand::Sym { ref expr } => {\n+                        hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n+                    }\n+                };\n+                (op, *op_sp)\n+            })\n+            .collect();\n+\n+        // Validate template modifiers against the register classes for the operands\n+        for p in &asm.template {\n+            if let InlineAsmTemplatePiece::Placeholder {\n+                operand_idx,\n+                modifier: Some(modifier),\n+                span: placeholder_span,\n+            } = *p\n+            {\n+                let op_sp = asm.operands[operand_idx].1;\n+                match &operands[operand_idx].0 {\n+                    hir::InlineAsmOperand::In { reg, .. }\n+                    | hir::InlineAsmOperand::Out { reg, .. }\n+                    | hir::InlineAsmOperand::InOut { reg, .. }\n+                    | hir::InlineAsmOperand::SplitInOut { reg, .. } => {\n+                        let class = reg.reg_class();\n+                        if class == asm::InlineAsmRegClass::Err {\n+                            continue;\n+                        }\n+                        let valid_modifiers = class.valid_modifiers(asm_arch.unwrap());\n+                        if !valid_modifiers.contains(&modifier) {\n+                            let mut err = sess.struct_span_err(\n+                                placeholder_span,\n+                                \"invalid asm template modifier for this register class\",\n+                            );\n+                            err.span_label(placeholder_span, \"template modifier\");\n+                            err.span_label(op_sp, \"argument\");\n+                            if !valid_modifiers.is_empty() {\n+                                let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n+                                for m in &valid_modifiers[1..] {\n+                                    let _ = write!(mods, \", `{}`\", m);\n+                                }\n+                                err.note(&format!(\n+                                    \"the `{}` register class supports \\\n+                                     the following template modifiers: {}\",\n+                                    class.name(),\n+                                    mods\n+                                ));\n+                            } else {\n+                                err.note(&format!(\n+                                    \"the `{}` register class does not support template modifiers\",\n+                                    class.name()\n+                                ));\n+                            }\n+                            err.emit();\n+                        }\n+                    }\n+                    hir::InlineAsmOperand::Const { .. } => {\n+                        let mut err = sess.struct_span_err(\n+                            placeholder_span,\n+                            \"asm template modifiers are not allowed for `const` arguments\",\n+                        );\n+                        err.span_label(placeholder_span, \"template modifier\");\n+                        err.span_label(op_sp, \"argument\");\n+                        err.emit();\n+                    }\n+                    hir::InlineAsmOperand::Sym { .. } => {\n+                        let mut err = sess.struct_span_err(\n+                            placeholder_span,\n+                            \"asm template modifiers are not allowed for `sym` arguments\",\n+                        );\n+                        err.span_label(placeholder_span, \"template modifier\");\n+                        err.span_label(op_sp, \"argument\");\n+                        err.emit();\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut used_input_regs = FxHashMap::default();\n+        let mut used_output_regs = FxHashMap::default();\n+        let mut required_features: Vec<&str> = vec![];\n+        for (idx, &(ref op, op_sp)) in operands.iter().enumerate() {\n+            if let Some(reg) = op.reg() {\n+                // Make sure we don't accidentally carry features from the\n+                // previous iteration.\n+                required_features.clear();\n+\n+                let reg_class = reg.reg_class();\n+                if reg_class == asm::InlineAsmRegClass::Err {\n+                    continue;\n+                }\n+\n+                // We ignore target feature requirements for clobbers: if the\n+                // feature is disabled then the compiler doesn't care what we\n+                // do with the registers.\n+                //\n+                // Note that this is only possible for explicit register\n+                // operands, which cannot be used in the asm string.\n+                let is_clobber = matches!(\n+                    op,\n+                    hir::InlineAsmOperand::Out {\n+                        reg: asm::InlineAsmRegOrRegClass::Reg(_),\n+                        late: _,\n+                        expr: None\n+                    }\n+                );\n+\n+                if !is_clobber {\n+                    // Validate register classes against currently enabled target\n+                    // features. We check that at least one type is available for\n+                    // the current target.\n+                    for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n+                        if let Some(feature) = feature {\n+                            if self.sess.target_features.contains(&Symbol::intern(feature)) {\n+                                required_features.clear();\n+                                break;\n+                            } else {\n+                                required_features.push(feature);\n+                            }\n+                        } else {\n+                            required_features.clear();\n+                            break;\n+                        }\n+                    }\n+                    // We are sorting primitive strs here and can use unstable sort here\n+                    required_features.sort_unstable();\n+                    required_features.dedup();\n+                    match &required_features[..] {\n+                        [] => {}\n+                        [feature] => {\n+                            let msg = format!(\n+                                \"register class `{}` requires the `{}` target feature\",\n+                                reg_class.name(),\n+                                feature\n+                            );\n+                            sess.struct_span_err(op_sp, &msg).emit();\n+                        }\n+                        features => {\n+                            let msg = format!(\n+                                \"register class `{}` requires at least one target feature: {}\",\n+                                reg_class.name(),\n+                                features.join(\", \")\n+                            );\n+                            sess.struct_span_err(op_sp, &msg).emit();\n+                        }\n+                    }\n+                }\n+\n+                // Check for conflicts between explicit register operands.\n+                if let asm::InlineAsmRegOrRegClass::Reg(reg) = reg {\n+                    let (input, output) = match op {\n+                        hir::InlineAsmOperand::In { .. } => (true, false),\n+\n+                        // Late output do not conflict with inputs, but normal outputs do\n+                        hir::InlineAsmOperand::Out { late, .. } => (!late, true),\n+\n+                        hir::InlineAsmOperand::InOut { .. }\n+                        | hir::InlineAsmOperand::SplitInOut { .. } => (true, true),\n+\n+                        hir::InlineAsmOperand::Const { .. } | hir::InlineAsmOperand::Sym { .. } => {\n+                            unreachable!()\n+                        }\n+                    };\n+\n+                    // Flag to output the error only once per operand\n+                    let mut skip = false;\n+                    reg.overlapping_regs(|r| {\n+                        let mut check = |used_regs: &mut FxHashMap<asm::InlineAsmReg, usize>,\n+                                         input| {\n+                            match used_regs.entry(r) {\n+                                Entry::Occupied(o) => {\n+                                    if skip {\n+                                        return;\n+                                    }\n+                                    skip = true;\n+\n+                                    let idx2 = *o.get();\n+                                    let &(ref op2, op_sp2) = &operands[idx2];\n+                                    let reg2 = match op2.reg() {\n+                                        Some(asm::InlineAsmRegOrRegClass::Reg(r)) => r,\n+                                        _ => unreachable!(),\n+                                    };\n+\n+                                    let msg = format!(\n+                                        \"register `{}` conflicts with register `{}`\",\n+                                        reg.name(),\n+                                        reg2.name()\n+                                    );\n+                                    let mut err = sess.struct_span_err(op_sp, &msg);\n+                                    err.span_label(op_sp, &format!(\"register `{}`\", reg.name()));\n+                                    err.span_label(op_sp2, &format!(\"register `{}`\", reg2.name()));\n+\n+                                    match (op, op2) {\n+                                        (\n+                                            hir::InlineAsmOperand::In { .. },\n+                                            hir::InlineAsmOperand::Out { late, .. },\n+                                        )\n+                                        | (\n+                                            hir::InlineAsmOperand::Out { late, .. },\n+                                            hir::InlineAsmOperand::In { .. },\n+                                        ) => {\n+                                            assert!(!*late);\n+                                            let out_op_sp = if input { op_sp2 } else { op_sp };\n+                                            let msg = \"use `lateout` instead of \\\n+                                                       `out` to avoid conflict\";\n+                                            err.span_help(out_op_sp, msg);\n+                                        }\n+                                        _ => {}\n+                                    }\n+\n+                                    err.emit();\n+                                }\n+                                Entry::Vacant(v) => {\n+                                    v.insert(idx);\n+                                }\n+                            }\n+                        };\n+                        if input {\n+                            check(&mut used_input_regs, true);\n+                        }\n+                        if output {\n+                            check(&mut used_output_regs, false);\n+                        }\n+                    });\n+                }\n+            }\n+        }\n+\n+        let operands = self.arena.alloc_from_iter(operands);\n+        let template = self.arena.alloc_from_iter(asm.template.iter().cloned());\n+        let line_spans = self.arena.alloc_slice(&asm.line_spans[..]);\n+        let hir_asm = hir::InlineAsm { template, operands, options: asm.options, line_spans };\n+        self.arena.alloc(hir_asm)\n+    }\n+}"}, {"sha": "483135ed3a3af56edbc262f9d3719bd47fe7cf3a", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 3, "deletions": 318, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -3,7 +3,6 @@ use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericAr\n use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n use rustc_ast::*;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n@@ -15,9 +14,6 @@ use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{hygiene::ForLoopLoc, DUMMY_SP};\n-use rustc_target::asm;\n-use std::collections::hash_map::Entry;\n-use std::fmt::Write;\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n@@ -222,7 +218,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let e = e.as_ref().map(|x| self.lower_expr(x));\n                     hir::ExprKind::Ret(e)\n                 }\n-                ExprKind::InlineAsm(ref asm) => self.lower_expr_asm(e.span, asm),\n+                ExprKind::InlineAsm(ref asm) => {\n+                    hir::ExprKind::InlineAsm(self.lower_inline_asm(e.span, asm))\n+                }\n                 ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_llvm_asm(asm),\n                 ExprKind::Struct(ref se) => {\n                     let rest = match &se.rest {\n@@ -1329,319 +1327,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         result\n     }\n \n-    fn lower_expr_asm(&mut self, sp: Span, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n-        // Rustdoc needs to support asm! from foriegn architectures: don't try\n-        // lowering the register contraints in this case.\n-        let asm_arch = if self.sess.opts.actually_rustdoc { None } else { self.sess.asm_arch };\n-        if asm_arch.is_none() && !self.sess.opts.actually_rustdoc {\n-            struct_span_err!(self.sess, sp, E0472, \"asm! is unsupported on this target\").emit();\n-        }\n-        if asm.options.contains(InlineAsmOptions::ATT_SYNTAX)\n-            && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n-            && !self.sess.opts.actually_rustdoc\n-        {\n-            self.sess\n-                .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n-                .emit();\n-        }\n-\n-        // Lower operands to HIR. We use dummy register classes if an error\n-        // occurs during lowering because we still need to be able to produce a\n-        // valid HIR.\n-        let sess = self.sess;\n-        let operands: Vec<_> = asm\n-            .operands\n-            .iter()\n-            .map(|(op, op_sp)| {\n-                let lower_reg = |reg| match reg {\n-                    InlineAsmRegOrRegClass::Reg(s) => {\n-                        asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmReg::parse(\n-                                asm_arch,\n-                                |feature| sess.target_features.contains(&Symbol::intern(feature)),\n-                                &sess.target,\n-                                s,\n-                            )\n-                            .unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n-                                asm::InlineAsmReg::Err\n-                            })\n-                        } else {\n-                            asm::InlineAsmReg::Err\n-                        })\n-                    }\n-                    InlineAsmRegOrRegClass::RegClass(s) => {\n-                        asm::InlineAsmRegOrRegClass::RegClass(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmRegClass::parse(asm_arch, s).unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register class `{}`: {}\", s.as_str(), e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n-                                asm::InlineAsmRegClass::Err\n-                            })\n-                        } else {\n-                            asm::InlineAsmRegClass::Err\n-                        })\n-                    }\n-                };\n-\n-                let op = match *op {\n-                    InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n-                        reg: lower_reg(reg),\n-                        expr: self.lower_expr_mut(expr),\n-                    },\n-                    InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n-                        reg: lower_reg(reg),\n-                        late,\n-                        expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n-                    },\n-                    InlineAsmOperand::InOut { reg, late, ref expr } => {\n-                        hir::InlineAsmOperand::InOut {\n-                            reg: lower_reg(reg),\n-                            late,\n-                            expr: self.lower_expr_mut(expr),\n-                        }\n-                    }\n-                    InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n-                        hir::InlineAsmOperand::SplitInOut {\n-                            reg: lower_reg(reg),\n-                            late,\n-                            in_expr: self.lower_expr_mut(in_expr),\n-                            out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n-                        }\n-                    }\n-                    InlineAsmOperand::Const { ref anon_const } => hir::InlineAsmOperand::Const {\n-                        anon_const: self.lower_anon_const(anon_const),\n-                    },\n-                    InlineAsmOperand::Sym { ref expr } => {\n-                        hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n-                    }\n-                };\n-                (op, *op_sp)\n-            })\n-            .collect();\n-\n-        // Validate template modifiers against the register classes for the operands\n-        for p in &asm.template {\n-            if let InlineAsmTemplatePiece::Placeholder {\n-                operand_idx,\n-                modifier: Some(modifier),\n-                span: placeholder_span,\n-            } = *p\n-            {\n-                let op_sp = asm.operands[operand_idx].1;\n-                match &operands[operand_idx].0 {\n-                    hir::InlineAsmOperand::In { reg, .. }\n-                    | hir::InlineAsmOperand::Out { reg, .. }\n-                    | hir::InlineAsmOperand::InOut { reg, .. }\n-                    | hir::InlineAsmOperand::SplitInOut { reg, .. } => {\n-                        let class = reg.reg_class();\n-                        if class == asm::InlineAsmRegClass::Err {\n-                            continue;\n-                        }\n-                        let valid_modifiers = class.valid_modifiers(asm_arch.unwrap());\n-                        if !valid_modifiers.contains(&modifier) {\n-                            let mut err = sess.struct_span_err(\n-                                placeholder_span,\n-                                \"invalid asm template modifier for this register class\",\n-                            );\n-                            err.span_label(placeholder_span, \"template modifier\");\n-                            err.span_label(op_sp, \"argument\");\n-                            if !valid_modifiers.is_empty() {\n-                                let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n-                                for m in &valid_modifiers[1..] {\n-                                    let _ = write!(mods, \", `{}`\", m);\n-                                }\n-                                err.note(&format!(\n-                                    \"the `{}` register class supports \\\n-                                     the following template modifiers: {}\",\n-                                    class.name(),\n-                                    mods\n-                                ));\n-                            } else {\n-                                err.note(&format!(\n-                                    \"the `{}` register class does not support template modifiers\",\n-                                    class.name()\n-                                ));\n-                            }\n-                            err.emit();\n-                        }\n-                    }\n-                    hir::InlineAsmOperand::Const { .. } => {\n-                        let mut err = sess.struct_span_err(\n-                            placeholder_span,\n-                            \"asm template modifiers are not allowed for `const` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n-                    }\n-                    hir::InlineAsmOperand::Sym { .. } => {\n-                        let mut err = sess.struct_span_err(\n-                            placeholder_span,\n-                            \"asm template modifiers are not allowed for `sym` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n-                    }\n-                }\n-            }\n-        }\n-\n-        let mut used_input_regs = FxHashMap::default();\n-        let mut used_output_regs = FxHashMap::default();\n-        let mut required_features: Vec<&str> = vec![];\n-        for (idx, &(ref op, op_sp)) in operands.iter().enumerate() {\n-            if let Some(reg) = op.reg() {\n-                // Make sure we don't accidentally carry features from the\n-                // previous iteration.\n-                required_features.clear();\n-\n-                let reg_class = reg.reg_class();\n-                if reg_class == asm::InlineAsmRegClass::Err {\n-                    continue;\n-                }\n-\n-                // We ignore target feature requirements for clobbers: if the\n-                // feature is disabled then the compiler doesn't care what we\n-                // do with the registers.\n-                //\n-                // Note that this is only possible for explicit register\n-                // operands, which cannot be used in the asm string.\n-                let is_clobber = matches!(\n-                    op,\n-                    hir::InlineAsmOperand::Out {\n-                        reg: asm::InlineAsmRegOrRegClass::Reg(_),\n-                        late: _,\n-                        expr: None\n-                    }\n-                );\n-\n-                if !is_clobber {\n-                    // Validate register classes against currently enabled target\n-                    // features. We check that at least one type is available for\n-                    // the current target.\n-                    for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n-                        if let Some(feature) = feature {\n-                            if self.sess.target_features.contains(&Symbol::intern(feature)) {\n-                                required_features.clear();\n-                                break;\n-                            } else {\n-                                required_features.push(feature);\n-                            }\n-                        } else {\n-                            required_features.clear();\n-                            break;\n-                        }\n-                    }\n-                    // We are sorting primitive strs here and can use unstable sort here\n-                    required_features.sort_unstable();\n-                    required_features.dedup();\n-                    match &required_features[..] {\n-                        [] => {}\n-                        [feature] => {\n-                            let msg = format!(\n-                                \"register class `{}` requires the `{}` target feature\",\n-                                reg_class.name(),\n-                                feature\n-                            );\n-                            sess.struct_span_err(op_sp, &msg).emit();\n-                        }\n-                        features => {\n-                            let msg = format!(\n-                                \"register class `{}` requires at least one target feature: {}\",\n-                                reg_class.name(),\n-                                features.join(\", \")\n-                            );\n-                            sess.struct_span_err(op_sp, &msg).emit();\n-                        }\n-                    }\n-                }\n-\n-                // Check for conflicts between explicit register operands.\n-                if let asm::InlineAsmRegOrRegClass::Reg(reg) = reg {\n-                    let (input, output) = match op {\n-                        hir::InlineAsmOperand::In { .. } => (true, false),\n-                        // Late output do not conflict with inputs, but normal outputs do\n-                        hir::InlineAsmOperand::Out { late, .. } => (!late, true),\n-                        hir::InlineAsmOperand::InOut { .. }\n-                        | hir::InlineAsmOperand::SplitInOut { .. } => (true, true),\n-                        hir::InlineAsmOperand::Const { .. } | hir::InlineAsmOperand::Sym { .. } => {\n-                            unreachable!()\n-                        }\n-                    };\n-\n-                    // Flag to output the error only once per operand\n-                    let mut skip = false;\n-                    reg.overlapping_regs(|r| {\n-                        let mut check = |used_regs: &mut FxHashMap<asm::InlineAsmReg, usize>,\n-                                         input| {\n-                            match used_regs.entry(r) {\n-                                Entry::Occupied(o) => {\n-                                    if skip {\n-                                        return;\n-                                    }\n-                                    skip = true;\n-\n-                                    let idx2 = *o.get();\n-                                    let &(ref op2, op_sp2) = &operands[idx2];\n-                                    let reg2 = match op2.reg() {\n-                                        Some(asm::InlineAsmRegOrRegClass::Reg(r)) => r,\n-                                        _ => unreachable!(),\n-                                    };\n-\n-                                    let msg = format!(\n-                                        \"register `{}` conflicts with register `{}`\",\n-                                        reg.name(),\n-                                        reg2.name()\n-                                    );\n-                                    let mut err = sess.struct_span_err(op_sp, &msg);\n-                                    err.span_label(op_sp, &format!(\"register `{}`\", reg.name()));\n-                                    err.span_label(op_sp2, &format!(\"register `{}`\", reg2.name()));\n-\n-                                    match (op, op2) {\n-                                        (\n-                                            hir::InlineAsmOperand::In { .. },\n-                                            hir::InlineAsmOperand::Out { late, .. },\n-                                        )\n-                                        | (\n-                                            hir::InlineAsmOperand::Out { late, .. },\n-                                            hir::InlineAsmOperand::In { .. },\n-                                        ) => {\n-                                            assert!(!*late);\n-                                            let out_op_sp = if input { op_sp2 } else { op_sp };\n-                                            let msg = \"use `lateout` instead of \\\n-                                                    `out` to avoid conflict\";\n-                                            err.span_help(out_op_sp, msg);\n-                                        }\n-                                        _ => {}\n-                                    }\n-\n-                                    err.emit();\n-                                }\n-                                Entry::Vacant(v) => {\n-                                    v.insert(idx);\n-                                }\n-                            }\n-                        };\n-                        if input {\n-                            check(&mut used_input_regs, true);\n-                        }\n-                        if output {\n-                            check(&mut used_output_regs, false);\n-                        }\n-                    });\n-                }\n-            }\n-        }\n-\n-        let operands = self.arena.alloc_from_iter(operands);\n-        let template = self.arena.alloc_from_iter(asm.template.iter().cloned());\n-        let line_spans = self.arena.alloc_slice(&asm.line_spans[..]);\n-        let hir_asm = hir::InlineAsm { template, operands, options: asm.options, line_spans };\n-        hir::ExprKind::InlineAsm(self.arena.alloc(hir_asm))\n-    }\n-\n     fn lower_expr_llvm_asm(&mut self, asm: &LlvmInlineAsm) -> hir::ExprKind<'hir> {\n         let inner = hir::LlvmInlineAsmInner {\n             inputs: asm.inputs.iter().map(|&(c, _)| c).collect(),"}, {"sha": "aa236a690ec79757ad0f2470e3b1a8273a1493c7", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -329,7 +329,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         .alloc_from_iter(fm.items.iter().map(|x| self.lower_foreign_item_ref(x))),\n                 }\n             }\n-            ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n+            ItemKind::GlobalAsm(ref asm) => {\n+                hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm))\n+            }\n             ItemKind::TyAlias(box TyAliasKind(_, ref gen, _, Some(ref ty))) => {\n                 // We lower\n                 //\n@@ -746,10 +748,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn lower_global_asm(&mut self, ga: &GlobalAsm) -> &'hir hir::GlobalAsm {\n-        self.arena.alloc(hir::GlobalAsm { asm: ga.asm })\n-    }\n-\n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant<'hir> {\n         let id = self.lower_node_id(v.id);\n         self.lower_attrs(id, &v.attrs);"}, {"sha": "0439de0ee7bf9727b0cb3459644625b04ffd9c07", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -77,6 +77,7 @@ macro_rules! arena_vec {\n     });\n }\n \n+mod asm;\n mod expr;\n mod item;\n mod pat;"}, {"sha": "0e42e0e3793f5a634362cf5c7d8c5833fba4d644", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 113, "deletions": 112, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -1164,9 +1164,9 @@ impl<'a> State<'a> {\n                 self.print_foreign_mod(nmod, &item.attrs);\n                 self.bclose(item.span);\n             }\n-            ast::ItemKind::GlobalAsm(ref ga) => {\n+            ast::ItemKind::GlobalAsm(ref asm) => {\n                 self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n-                self.s.word(ga.asm.to_string());\n+                self.print_inline_asm(asm);\n                 self.end();\n             }\n             ast::ItemKind::TyAlias(box ast::TyAliasKind(def, ref generics, ref bounds, ref ty)) => {\n@@ -2066,117 +2066,8 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ExprKind::InlineAsm(ref a) => {\n-                enum AsmArg<'a> {\n-                    Template(String),\n-                    Operand(&'a InlineAsmOperand),\n-                    Options(InlineAsmOptions),\n-                }\n-\n-                let mut args = vec![];\n-                args.push(AsmArg::Template(InlineAsmTemplatePiece::to_string(&a.template)));\n-                args.extend(a.operands.iter().map(|(o, _)| AsmArg::Operand(o)));\n-                if !a.options.is_empty() {\n-                    args.push(AsmArg::Options(a.options));\n-                }\n-\n                 self.word(\"asm!\");\n-                self.popen();\n-                self.commasep(Consistent, &args, |s, arg| match arg {\n-                    AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n-                    AsmArg::Operand(op) => {\n-                        let print_reg_or_class = |s: &mut Self, r: &InlineAsmRegOrRegClass| match r\n-                        {\n-                            InlineAsmRegOrRegClass::Reg(r) => {\n-                                s.print_symbol(*r, ast::StrStyle::Cooked)\n-                            }\n-                            InlineAsmRegOrRegClass::RegClass(r) => s.word(r.to_string()),\n-                        };\n-                        match op {\n-                            InlineAsmOperand::In { reg, expr } => {\n-                                s.word(\"in\");\n-                                s.popen();\n-                                print_reg_or_class(s, reg);\n-                                s.pclose();\n-                                s.space();\n-                                s.print_expr(expr);\n-                            }\n-                            InlineAsmOperand::Out { reg, late, expr } => {\n-                                s.word(if *late { \"lateout\" } else { \"out\" });\n-                                s.popen();\n-                                print_reg_or_class(s, reg);\n-                                s.pclose();\n-                                s.space();\n-                                match expr {\n-                                    Some(expr) => s.print_expr(expr),\n-                                    None => s.word(\"_\"),\n-                                }\n-                            }\n-                            InlineAsmOperand::InOut { reg, late, expr } => {\n-                                s.word(if *late { \"inlateout\" } else { \"inout\" });\n-                                s.popen();\n-                                print_reg_or_class(s, reg);\n-                                s.pclose();\n-                                s.space();\n-                                s.print_expr(expr);\n-                            }\n-                            InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n-                                s.word(if *late { \"inlateout\" } else { \"inout\" });\n-                                s.popen();\n-                                print_reg_or_class(s, reg);\n-                                s.pclose();\n-                                s.space();\n-                                s.print_expr(in_expr);\n-                                s.space();\n-                                s.word_space(\"=>\");\n-                                match out_expr {\n-                                    Some(out_expr) => s.print_expr(out_expr),\n-                                    None => s.word(\"_\"),\n-                                }\n-                            }\n-                            InlineAsmOperand::Const { anon_const } => {\n-                                s.word(\"const\");\n-                                s.space();\n-                                s.print_expr(&anon_const.value);\n-                            }\n-                            InlineAsmOperand::Sym { expr } => {\n-                                s.word(\"sym\");\n-                                s.space();\n-                                s.print_expr(expr);\n-                            }\n-                        }\n-                    }\n-                    AsmArg::Options(opts) => {\n-                        s.word(\"options\");\n-                        s.popen();\n-                        let mut options = vec![];\n-                        if opts.contains(InlineAsmOptions::PURE) {\n-                            options.push(\"pure\");\n-                        }\n-                        if opts.contains(InlineAsmOptions::NOMEM) {\n-                            options.push(\"nomem\");\n-                        }\n-                        if opts.contains(InlineAsmOptions::READONLY) {\n-                            options.push(\"readonly\");\n-                        }\n-                        if opts.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n-                            options.push(\"preserves_flags\");\n-                        }\n-                        if opts.contains(InlineAsmOptions::NORETURN) {\n-                            options.push(\"noreturn\");\n-                        }\n-                        if opts.contains(InlineAsmOptions::NOSTACK) {\n-                            options.push(\"nostack\");\n-                        }\n-                        if opts.contains(InlineAsmOptions::ATT_SYNTAX) {\n-                            options.push(\"att_syntax\");\n-                        }\n-                        s.commasep(Inconsistent, &options, |s, &opt| {\n-                            s.word(opt);\n-                        });\n-                        s.pclose();\n-                    }\n-                });\n-                self.pclose();\n+                self.print_inline_asm(a);\n             }\n             ast::ExprKind::LlvmInlineAsm(ref a) => {\n                 self.s.word(\"llvm_asm!\");\n@@ -2267,6 +2158,116 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n+    fn print_inline_asm(&mut self, asm: &ast::InlineAsm) {\n+        enum AsmArg<'a> {\n+            Template(String),\n+            Operand(&'a InlineAsmOperand),\n+            Options(InlineAsmOptions),\n+        }\n+\n+        let mut args = vec![];\n+        args.push(AsmArg::Template(InlineAsmTemplatePiece::to_string(&asm.template)));\n+        args.extend(asm.operands.iter().map(|(o, _)| AsmArg::Operand(o)));\n+        if !asm.options.is_empty() {\n+            args.push(AsmArg::Options(asm.options));\n+        }\n+\n+        self.popen();\n+        self.commasep(Consistent, &args, |s, arg| match arg {\n+            AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n+            AsmArg::Operand(op) => {\n+                let print_reg_or_class = |s: &mut Self, r: &InlineAsmRegOrRegClass| match r {\n+                    InlineAsmRegOrRegClass::Reg(r) => s.print_symbol(*r, ast::StrStyle::Cooked),\n+                    InlineAsmRegOrRegClass::RegClass(r) => s.word(r.to_string()),\n+                };\n+                match op {\n+                    InlineAsmOperand::In { reg, expr } => {\n+                        s.word(\"in\");\n+                        s.popen();\n+                        print_reg_or_class(s, reg);\n+                        s.pclose();\n+                        s.space();\n+                        s.print_expr(expr);\n+                    }\n+                    InlineAsmOperand::Out { reg, late, expr } => {\n+                        s.word(if *late { \"lateout\" } else { \"out\" });\n+                        s.popen();\n+                        print_reg_or_class(s, reg);\n+                        s.pclose();\n+                        s.space();\n+                        match expr {\n+                            Some(expr) => s.print_expr(expr),\n+                            None => s.word(\"_\"),\n+                        }\n+                    }\n+                    InlineAsmOperand::InOut { reg, late, expr } => {\n+                        s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                        s.popen();\n+                        print_reg_or_class(s, reg);\n+                        s.pclose();\n+                        s.space();\n+                        s.print_expr(expr);\n+                    }\n+                    InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                        s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                        s.popen();\n+                        print_reg_or_class(s, reg);\n+                        s.pclose();\n+                        s.space();\n+                        s.print_expr(in_expr);\n+                        s.space();\n+                        s.word_space(\"=>\");\n+                        match out_expr {\n+                            Some(out_expr) => s.print_expr(out_expr),\n+                            None => s.word(\"_\"),\n+                        }\n+                    }\n+                    InlineAsmOperand::Const { anon_const } => {\n+                        s.word(\"const\");\n+                        s.space();\n+                        s.print_expr(&anon_const.value);\n+                    }\n+                    InlineAsmOperand::Sym { expr } => {\n+                        s.word(\"sym\");\n+                        s.space();\n+                        s.print_expr(expr);\n+                    }\n+                }\n+            }\n+            AsmArg::Options(opts) => {\n+                s.word(\"options\");\n+                s.popen();\n+                let mut options = vec![];\n+                if opts.contains(InlineAsmOptions::PURE) {\n+                    options.push(\"pure\");\n+                }\n+                if opts.contains(InlineAsmOptions::NOMEM) {\n+                    options.push(\"nomem\");\n+                }\n+                if opts.contains(InlineAsmOptions::READONLY) {\n+                    options.push(\"readonly\");\n+                }\n+                if opts.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n+                    options.push(\"preserves_flags\");\n+                }\n+                if opts.contains(InlineAsmOptions::NORETURN) {\n+                    options.push(\"noreturn\");\n+                }\n+                if opts.contains(InlineAsmOptions::NOSTACK) {\n+                    options.push(\"nostack\");\n+                }\n+                if opts.contains(InlineAsmOptions::ATT_SYNTAX) {\n+                    options.push(\"att_syntax\");\n+                }\n+                s.commasep(Inconsistent, &options, |s, &opt| {\n+                    s.word(opt);\n+                });\n+                s.pclose();\n+            }\n+        });\n+        self.pclose();\n+    }\n+\n     crate fn print_local_decl(&mut self, loc: &ast::Local) {\n         self.print_pat(&loc.pat);\n         if let Some(ref ty) = loc.ty {"}, {"sha": "b28c6f0d99c5e0ebb5ac2d5708d4663f5a235144", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 73, "deletions": 29, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -8,9 +8,11 @@ use rustc_expand::base::{self, *};\n use rustc_parse::parser::Parser;\n use rustc_parse_format as parse;\n use rustc_session::lint;\n+use rustc_span::symbol::Ident;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{InnerSpan, Span};\n use rustc_target::asm::InlineAsmArch;\n+use smallvec::smallvec;\n \n struct AsmArgs {\n     templates: Vec<P<ast::Expr>>,\n@@ -25,6 +27,7 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n+    is_global_asm: bool,\n ) -> Result<AsmArgs, DiagnosticBuilder<'a>> {\n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -33,7 +36,7 @@ fn parse_args<'a>(\n     }\n \n     // Detect use of the legacy llvm_asm! syntax (which used to be called asm!)\n-    if p.look_ahead(1, |t| *t == token::Colon || *t == token::ModSep) {\n+    if !is_global_asm && p.look_ahead(1, |t| *t == token::Colon || *t == token::ModSep) {\n         let mut err =\n             ecx.struct_span_err(sp, \"the legacy LLVM-style asm! syntax is no longer supported\");\n         err.note(\"consider migrating to the new asm! syntax specified in RFC 2873\");\n@@ -84,7 +87,7 @@ fn parse_args<'a>(\n \n         // Parse options\n         if p.eat_keyword(sym::options) {\n-            parse_options(&mut p, &mut args)?;\n+            parse_options(&mut p, &mut args, is_global_asm)?;\n             allow_templates = false;\n             continue;\n         }\n@@ -103,19 +106,19 @@ fn parse_args<'a>(\n         };\n \n         let mut explicit_reg = false;\n-        let op = if p.eat_keyword(kw::In) {\n+        let op = if !is_global_asm && p.eat_keyword(kw::In) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = p.parse_expr()?;\n             ast::InlineAsmOperand::In { reg, expr }\n-        } else if p.eat_keyword(sym::out) {\n+        } else if !is_global_asm && p.eat_keyword(sym::out) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n             ast::InlineAsmOperand::Out { reg, expr, late: false }\n-        } else if p.eat_keyword(sym::lateout) {\n+        } else if !is_global_asm && p.eat_keyword(sym::lateout) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n             ast::InlineAsmOperand::Out { reg, expr, late: true }\n-        } else if p.eat_keyword(sym::inout) {\n+        } else if !is_global_asm && p.eat_keyword(sym::inout) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = p.parse_expr()?;\n             if p.eat(&token::FatArrow) {\n@@ -125,7 +128,7 @@ fn parse_args<'a>(\n             } else {\n                 ast::InlineAsmOperand::InOut { reg, expr, late: false }\n             }\n-        } else if p.eat_keyword(sym::inlateout) {\n+        } else if !is_global_asm && p.eat_keyword(sym::inlateout) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = p.parse_expr()?;\n             if p.eat(&token::FatArrow) {\n@@ -138,7 +141,7 @@ fn parse_args<'a>(\n         } else if p.eat_keyword(kw::Const) {\n             let anon_const = p.parse_anon_const_expr()?;\n             ast::InlineAsmOperand::Const { anon_const }\n-        } else if p.eat_keyword(sym::sym) {\n+        } else if !is_global_asm && p.eat_keyword(sym::sym) {\n             let expr = p.parse_expr()?;\n             match expr.kind {\n                 ast::ExprKind::Path(..) => {}\n@@ -329,23 +332,27 @@ fn try_set_option<'a>(\n     }\n }\n \n-fn parse_options<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> Result<(), DiagnosticBuilder<'a>> {\n+fn parse_options<'a>(\n+    p: &mut Parser<'a>,\n+    args: &mut AsmArgs,\n+    is_global_asm: bool,\n+) -> Result<(), DiagnosticBuilder<'a>> {\n     let span_start = p.prev_token.span;\n \n     p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n \n     while !p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n-        if p.eat_keyword(sym::pure) {\n+        if !is_global_asm && p.eat_keyword(sym::pure) {\n             try_set_option(p, args, sym::pure, ast::InlineAsmOptions::PURE);\n-        } else if p.eat_keyword(sym::nomem) {\n+        } else if !is_global_asm && p.eat_keyword(sym::nomem) {\n             try_set_option(p, args, sym::nomem, ast::InlineAsmOptions::NOMEM);\n-        } else if p.eat_keyword(sym::readonly) {\n+        } else if !is_global_asm && p.eat_keyword(sym::readonly) {\n             try_set_option(p, args, sym::readonly, ast::InlineAsmOptions::READONLY);\n-        } else if p.eat_keyword(sym::preserves_flags) {\n+        } else if !is_global_asm && p.eat_keyword(sym::preserves_flags) {\n             try_set_option(p, args, sym::preserves_flags, ast::InlineAsmOptions::PRESERVES_FLAGS);\n-        } else if p.eat_keyword(sym::noreturn) {\n+        } else if !is_global_asm && p.eat_keyword(sym::noreturn) {\n             try_set_option(p, args, sym::noreturn, ast::InlineAsmOptions::NORETURN);\n-        } else if p.eat_keyword(sym::nostack) {\n+        } else if !is_global_asm && p.eat_keyword(sym::nostack) {\n             try_set_option(p, args, sym::nostack, ast::InlineAsmOptions::NOSTACK);\n         } else if p.eat_keyword(sym::att_syntax) {\n             try_set_option(p, args, sym::att_syntax, ast::InlineAsmOptions::ATT_SYNTAX);\n@@ -388,7 +395,7 @@ fn parse_reg<'a>(\n     Ok(result)\n }\n \n-fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast::Expr> {\n+fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::InlineAsm> {\n     let mut template = vec![];\n     // Register operands are implicitly used since they are not allowed to be\n     // referenced in the template string.\n@@ -415,7 +422,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n                     if let Some(mut err) = err {\n                         err.emit();\n                     }\n-                    return DummyResult::raw_expr(sp, true);\n+                    return None;\n                 }\n             };\n \n@@ -492,7 +499,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n                 e.span_label(err_sp, label);\n             }\n             e.emit();\n-            return DummyResult::raw_expr(sp, true);\n+            return None;\n         }\n \n         curarg = parser.curarg;\n@@ -643,24 +650,61 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n         }\n     }\n \n-    let inline_asm =\n-        ast::InlineAsm { template, operands: args.operands, options: args.options, line_spans };\n-    P(ast::Expr {\n-        id: ast::DUMMY_NODE_ID,\n-        kind: ast::ExprKind::InlineAsm(P(inline_asm)),\n-        span: sp,\n-        attrs: ast::AttrVec::new(),\n-        tokens: None,\n-    })\n+    Some(ast::InlineAsm { template, operands: args.operands, options: args.options, line_spans })\n }\n \n pub fn expand_asm<'cx>(\n     ecx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n-    match parse_args(ecx, sp, tts) {\n-        Ok(args) => MacEager::expr(expand_preparsed_asm(ecx, sp, args)),\n+    match parse_args(ecx, sp, tts, false) {\n+        Ok(args) => {\n+            let expr = if let Some(inline_asm) = expand_preparsed_asm(ecx, args) {\n+                P(ast::Expr {\n+                    id: ast::DUMMY_NODE_ID,\n+                    kind: ast::ExprKind::InlineAsm(P(inline_asm)),\n+                    span: sp,\n+                    attrs: ast::AttrVec::new(),\n+                    tokens: None,\n+                })\n+            } else {\n+                DummyResult::raw_expr(sp, true)\n+            };\n+            MacEager::expr(expr)\n+        }\n+        Err(mut err) => {\n+            err.emit();\n+            DummyResult::any(sp)\n+        }\n+    }\n+}\n+\n+pub fn expand_global_asm<'cx>(\n+    ecx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Box<dyn base::MacResult + 'cx> {\n+    match parse_args(ecx, sp, tts, true) {\n+        Ok(args) => {\n+            if let Some(inline_asm) = expand_preparsed_asm(ecx, args) {\n+                MacEager::items(smallvec![P(ast::Item {\n+                    ident: Ident::invalid(),\n+                    attrs: Vec::new(),\n+                    id: ast::DUMMY_NODE_ID,\n+                    kind: ast::ItemKind::GlobalAsm(inline_asm),\n+                    vis: ast::Visibility {\n+                        span: sp.shrink_to_lo(),\n+                        kind: ast::VisibilityKind::Inherited,\n+                        tokens: None,\n+                    },\n+                    span: ecx.with_def_site_ctxt(sp),\n+                    tokens: None,\n+                })])\n+            } else {\n+                DummyResult::any(sp)\n+            }\n+        }\n         Err(mut err) => {\n             err.emit();\n             DummyResult::any(sp)"}, {"sha": "76d874529270e179167c66ce5a78fc0d9765e568", "filename": "compiler/rustc_builtin_macros/src/global_asm.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/952c5732c2d25a875f90e5cd5dd29a1a21c1d4a2/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/952c5732c2d25a875f90e5cd5dd29a1a21c1d4a2/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs?ref=952c5732c2d25a875f90e5cd5dd29a1a21c1d4a2", "patch": "@@ -1,68 +0,0 @@\n-//! Module-level assembly support.\n-//!\n-//! The macro defined here allows you to specify \"top-level\",\n-//! \"file-scoped\", or \"module-level\" assembly. These synonyms\n-//! all correspond to LLVM's module-level inline assembly instruction.\n-//!\n-//! For example, `global_asm!(\"some assembly here\")` codegens to\n-//! LLVM's `module asm \"some assembly here\"`. All of LLVM's caveats\n-//! therefore apply.\n-\n-use rustc_ast as ast;\n-use rustc_ast::ptr::P;\n-use rustc_ast::token;\n-use rustc_ast::tokenstream::TokenStream;\n-use rustc_errors::DiagnosticBuilder;\n-use rustc_expand::base::{self, *};\n-use rustc_span::symbol::Ident;\n-use rustc_span::Span;\n-use smallvec::smallvec;\n-\n-pub fn expand_global_asm<'cx>(\n-    cx: &'cx mut ExtCtxt<'_>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Box<dyn base::MacResult + 'cx> {\n-    match parse_global_asm(cx, sp, tts) {\n-        Ok(Some(global_asm)) => MacEager::items(smallvec![P(ast::Item {\n-            ident: Ident::invalid(),\n-            attrs: Vec::new(),\n-            id: ast::DUMMY_NODE_ID,\n-            kind: ast::ItemKind::GlobalAsm(global_asm),\n-            vis: ast::Visibility {\n-                span: sp.shrink_to_lo(),\n-                kind: ast::VisibilityKind::Inherited,\n-                tokens: None,\n-            },\n-            span: cx.with_def_site_ctxt(sp),\n-            tokens: None,\n-        })]),\n-        Ok(None) => DummyResult::any(sp),\n-        Err(mut err) => {\n-            err.emit();\n-            DummyResult::any(sp)\n-        }\n-    }\n-}\n-\n-fn parse_global_asm<'a>(\n-    cx: &mut ExtCtxt<'a>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Result<Option<ast::GlobalAsm>, DiagnosticBuilder<'a>> {\n-    let mut p = cx.new_parser_from_tts(tts);\n-\n-    if p.token == token::Eof {\n-        let mut err = cx.struct_span_err(sp, \"macro requires a string literal as an argument\");\n-        err.span_label(sp, \"string literal required\");\n-        return Err(err);\n-    }\n-\n-    let expr = p.parse_expr()?;\n-    let (asm, _) = match expr_to_string(cx, expr, \"inline assembly must be a string literal\") {\n-        Some((s, st)) => (s, st),\n-        None => return Ok(None),\n-    };\n-\n-    Ok(Some(ast::GlobalAsm { asm }))\n-}"}, {"sha": "17b7793c7ddc7b8e8a920a6e1324b58ed7bb5017", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -37,7 +37,6 @@ mod env;\n mod format;\n mod format_foreign;\n mod global_allocator;\n-mod global_asm;\n mod llvm_asm;\n mod log_syntax;\n mod panic;\n@@ -75,7 +74,7 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n         file: source_util::expand_file,\n         format_args_nl: format::expand_format_args_nl,\n         format_args: format::expand_format_args,\n-        global_asm: global_asm::expand_global_asm,\n+        global_asm: asm::expand_global_asm,\n         include_bytes: source_util::expand_include_bytes,\n         include_str: source_util::expand_include_str,\n         include: source_util::expand_include,"}, {"sha": "004e6bddaf3ee72c5db5b814df90eb788fe52a04", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -3,6 +3,7 @@\n \n use std::path::PathBuf;\n \n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_codegen_ssa::back::linker::LinkerInfo;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -125,9 +126,19 @@ fn module_codegen(\n             MonoItem::Static(def_id) => crate::constant::codegen_static(tcx, &mut module, def_id),\n             MonoItem::GlobalAsm(item_id) => {\n                 let item = cx.tcx.hir().item(item_id);\n-                if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n-                    cx.global_asm.push_str(&*asm.as_str());\n-                    cx.global_asm.push_str(\"\\n\\n\");\n+                if let rustc_hir::ItemKind::GlobalAsm(asm) = item.kind {\n+                    if !asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+                        cx.global_asm.push_str(\"\\n.intel_syntax noprefix\\n\");\n+                    } else {\n+                        cx.global_asm.push_str(\"\\n.att_syntax\\n\");\n+                    }\n+                    for piece in asm.template {\n+                        match *piece {\n+                            InlineAsmTemplatePiece::String(ref s) => cx.global_asm.push_str(s),\n+                            InlineAsmTemplatePiece::Placeholder { .. } => todo!(),\n+                        }\n+                    }\n+                    cx.global_asm.push_str(\"\\n.att_syntax\\n\\n\");\n                 } else {\n                     bug!(\"Expected GlobalAsm found {:?}\", item);\n                 }"}, {"sha": "a571418c1f5ffcfe36e2bfb0b1f2f44cbe922d2f", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -356,10 +356,49 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n }\n \n impl AsmMethods for CodegenCx<'ll, 'tcx> {\n-    fn codegen_global_asm(&self, ga: &hir::GlobalAsm) {\n-        let asm = ga.asm.as_str();\n+    fn codegen_global_asm(\n+        &self,\n+        template: &[InlineAsmTemplatePiece],\n+        operands: &[GlobalAsmOperandRef],\n+        options: InlineAsmOptions,\n+        _line_spans: &[Span],\n+    ) {\n+        let asm_arch = self.tcx.sess.asm_arch.unwrap();\n+\n+        // Default to Intel syntax on x86\n+        let intel_syntax = matches!(asm_arch, InlineAsmArch::X86 | InlineAsmArch::X86_64)\n+            && !options.contains(InlineAsmOptions::ATT_SYNTAX);\n+\n+        // Build the template string\n+        let mut template_str = String::new();\n+        if intel_syntax {\n+            template_str.push_str(\".intel_syntax\\n\");\n+        }\n+        for piece in template {\n+            match *piece {\n+                InlineAsmTemplatePiece::String(ref s) => template_str.push_str(s),\n+                InlineAsmTemplatePiece::Placeholder { operand_idx, modifier: _, span: _ } => {\n+                    match operands[operand_idx] {\n+                        GlobalAsmOperandRef::Const { ref string } => {\n+                            // Const operands get injected directly into the\n+                            // template. Note that we don't need to escape $\n+                            // here unlike normal inline assembly.\n+                            template_str.push_str(string);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if intel_syntax {\n+            template_str.push_str(\"\\n.att_syntax\\n\");\n+        }\n+\n         unsafe {\n-            llvm::LLVMRustAppendModuleInlineAsm(self.llmod, asm.as_ptr().cast(), asm.len());\n+            llvm::LLVMRustAppendModuleInlineAsm(\n+                self.llmod,\n+                template_str.as_ptr().cast(),\n+                template_str.len(),\n+            );\n         }\n     }\n }"}, {"sha": "955f658eb1c7ecdb9c9062b94b5fedbb09368a8c", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -4,7 +4,8 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n-use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_middle::mir::interpret::ConstValue;\n+use rustc_middle::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n use rustc_session::Session;\n use rustc_span::Span;\n \n@@ -194,3 +195,32 @@ pub fn shift_mask_val<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n pub fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n     struct_span_err!(a, b, E0511, \"{}\", c).emit();\n }\n+\n+pub fn asm_const_to_str<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sp: Span,\n+    const_value: ConstValue<'tcx>,\n+    ty_and_layout: TyAndLayout<'tcx>,\n+) -> String {\n+    let scalar = match const_value {\n+        ConstValue::Scalar(s) => s,\n+        _ => {\n+            span_bug!(sp, \"expected Scalar for promoted asm const, but got {:#?}\", const_value)\n+        }\n+    };\n+    let value = scalar.assert_bits(ty_and_layout.size);\n+    match ty_and_layout.ty.kind() {\n+        ty::Uint(_) => value.to_string(),\n+        ty::Int(int_ty) => match int_ty.normalize(tcx.sess.target.pointer_width) {\n+            ty::IntTy::I8 => (value as i8).to_string(),\n+            ty::IntTy::I16 => (value as i16).to_string(),\n+            ty::IntTy::I32 => (value as i32).to_string(),\n+            ty::IntTy::I64 => (value as i64).to_string(),\n+            ty::IntTy::I128 => (value as i128).to_string(),\n+            ty::IntTy::Isize => unreachable!(),\n+        },\n+        ty::Float(ty::FloatTy::F32) => f32::from_bits(value as u32).to_string(),\n+        ty::Float(ty::FloatTy::F64) => f64::from_bits(value as u64).to_string(),\n+        _ => span_bug!(sp, \"asm const has bad type {}\", ty_and_layout.ty),\n+    }\n+}"}, {"sha": "2bd35fe9b1435ed3747f504ad70f6fe5f5792d72", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -12,7 +12,6 @@ use crate::MemFlags;\n use rustc_ast as ast;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::Idx;\n-use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::{self, SwitchTargets};\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n@@ -825,33 +824,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     let const_value = self\n                         .eval_mir_constant(value)\n                         .unwrap_or_else(|_| span_bug!(span, \"asm const cannot be resolved\"));\n-                    let ty = value.ty();\n-                    let size = bx.layout_of(ty).size;\n-                    let scalar = match const_value {\n-                        ConstValue::Scalar(s) => s,\n-                        _ => span_bug!(\n-                            span,\n-                            \"expected Scalar for promoted asm const, but got {:#?}\",\n-                            const_value\n-                        ),\n-                    };\n-                    let value = scalar.assert_bits(size);\n-                    let string = match ty.kind() {\n-                        ty::Uint(_) => value.to_string(),\n-                        ty::Int(int_ty) => {\n-                            match int_ty.normalize(bx.tcx().sess.target.pointer_width) {\n-                                ty::IntTy::I8 => (value as i8).to_string(),\n-                                ty::IntTy::I16 => (value as i16).to_string(),\n-                                ty::IntTy::I32 => (value as i32).to_string(),\n-                                ty::IntTy::I64 => (value as i64).to_string(),\n-                                ty::IntTy::I128 => (value as i128).to_string(),\n-                                ty::IntTy::Isize => unreachable!(),\n-                            }\n-                        }\n-                        ty::Float(ty::FloatTy::F32) => f32::from_bits(value as u32).to_string(),\n-                        ty::Float(ty::FloatTy::F64) => f64::from_bits(value as u64).to_string(),\n-                        _ => span_bug!(span, \"asm const has bad type {}\", ty),\n-                    };\n+                    let string = common::asm_const_to_str(\n+                        bx.tcx(),\n+                        span,\n+                        const_value,\n+                        bx.layout_of(value.ty()),\n+                    );\n                     InlineAsmOperandRef::Const { string }\n                 }\n                 mir::InlineAsmOperand::SymFn { ref value } => {"}, {"sha": "48d753e0d843564f7d110c16d0ecad2f14206974", "filename": "compiler/rustc_codegen_ssa/src/mono_item.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -1,10 +1,11 @@\n use crate::base;\n+use crate::common;\n use crate::traits::*;\n use rustc_hir as hir;\n+use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::layout::HasTyCtxt;\n-\n-use rustc_middle::mir::mono::MonoItem;\n+use rustc_target::abi::LayoutOf;\n \n pub trait MonoItemExt<'a, 'tcx> {\n     fn define<Bx: BuilderMethods<'a, 'tcx>>(&self, cx: &'a Bx::CodegenCx);\n@@ -32,8 +33,35 @@ impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n             }\n             MonoItem::GlobalAsm(item_id) => {\n                 let item = cx.tcx().hir().item(item_id);\n-                if let hir::ItemKind::GlobalAsm(ref ga) = item.kind {\n-                    cx.codegen_global_asm(ga);\n+                if let hir::ItemKind::GlobalAsm(ref asm) = item.kind {\n+                    let operands: Vec<_> = asm\n+                        .operands\n+                        .iter()\n+                        .map(|(op, op_sp)| match *op {\n+                            hir::InlineAsmOperand::Const { ref anon_const } => {\n+                                let anon_const_def_id =\n+                                    cx.tcx().hir().local_def_id(anon_const.hir_id).to_def_id();\n+                                let const_value =\n+                                    cx.tcx().const_eval_poly(anon_const_def_id).unwrap_or_else(\n+                                        |_| span_bug!(*op_sp, \"asm const cannot be resolved\"),\n+                                    );\n+                                let ty = cx\n+                                    .tcx()\n+                                    .typeck_body(anon_const.body)\n+                                    .node_type(anon_const.hir_id);\n+                                let string = common::asm_const_to_str(\n+                                    cx.tcx(),\n+                                    *op_sp,\n+                                    const_value,\n+                                    cx.layout_of(ty),\n+                                );\n+                                GlobalAsmOperandRef::Const { string }\n+                            }\n+                            _ => span_bug!(*op_sp, \"invalid operand type for global_asm!\"),\n+                        })\n+                        .collect();\n+\n+                    cx.codegen_global_asm(asm.template, &operands, asm.options, asm.line_spans);\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and MonoItem type\")\n                 }"}, {"sha": "86f2781a7663b6a605c06764e75a4c0e26aa055b", "filename": "compiler/rustc_codegen_ssa/src/traits/asm.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -3,7 +3,7 @@ use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{GlobalAsm, LlvmInlineAsmInner};\n+use rustc_hir::LlvmInlineAsmInner;\n use rustc_middle::ty::Instance;\n use rustc_span::Span;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n@@ -36,6 +36,11 @@ pub enum InlineAsmOperandRef<'tcx, B: BackendTypes + ?Sized> {\n     },\n }\n \n+#[derive(Debug)]\n+pub enum GlobalAsmOperandRef {\n+    Const { string: String },\n+}\n+\n pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n     /// Take an inline assembly expression and splat it out via LLVM\n     fn codegen_llvm_inline_asm(\n@@ -57,5 +62,11 @@ pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n }\n \n pub trait AsmMethods {\n-    fn codegen_global_asm(&self, ga: &GlobalAsm);\n+    fn codegen_global_asm(\n+        &self,\n+        template: &[InlineAsmTemplatePiece],\n+        operands: &[GlobalAsmOperandRef],\n+        options: InlineAsmOptions,\n+        line_spans: &[Span],\n+    );\n }"}, {"sha": "c529fbbf518b667a9ed02953f9bf67cfcff6b61b", "filename": "compiler/rustc_codegen_ssa/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -29,7 +29,7 @@ mod type_;\n mod write;\n \n pub use self::abi::AbiBuilderMethods;\n-pub use self::asm::{AsmBuilderMethods, AsmMethods, InlineAsmOperandRef};\n+pub use self::asm::{AsmBuilderMethods, AsmMethods, GlobalAsmOperandRef, InlineAsmOperandRef};\n pub use self::backend::{Backend, BackendTypes, CodegenBackend, ExtraBackendMethods};\n pub use self::builder::{BuilderMethods, OverflowOp};\n pub use self::consts::ConstMethods;"}, {"sha": "b05ca381b8ab6e9263be40f01a2e17fa2258073c", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -19,7 +19,6 @@ macro_rules! arena_types {\n             [] attribute: rustc_ast::Attribute,\n             [] block: rustc_hir::Block<$tcx>,\n             [] bare_fn_ty: rustc_hir::BareFnTy<$tcx>,\n-            [few] global_asm: rustc_hir::GlobalAsm,\n             [] generic_arg: rustc_hir::GenericArg<$tcx>,\n             [] generic_args: rustc_hir::GenericArgs<$tcx>,\n             [] generic_bound: rustc_hir::GenericBound<$tcx>,"}, {"sha": "91fd97a0d4020150e23f8ecdca355c43d8957ad8", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -2502,11 +2502,6 @@ pub struct Mod<'hir> {\n     pub item_ids: &'hir [ItemId],\n }\n \n-#[derive(Encodable, Debug, HashStable_Generic)]\n-pub struct GlobalAsm {\n-    pub asm: Symbol,\n-}\n-\n #[derive(Debug, HashStable_Generic)]\n pub struct EnumDef<'hir> {\n     pub variants: &'hir [Variant<'hir>],\n@@ -2766,7 +2761,7 @@ pub enum ItemKind<'hir> {\n     /// An external module, e.g. `extern { .. }`.\n     ForeignMod { abi: Abi, items: &'hir [ForeignItemRef<'hir>] },\n     /// Module-level inline assembly (from `global_asm!`).\n-    GlobalAsm(&'hir GlobalAsm),\n+    GlobalAsm(&'hir InlineAsm<'hir>),\n     /// A type alias, e.g., `type Foo = Bar<u8>`.\n     TyAlias(&'hir Ty<'hir>, Generics<'hir>),\n     /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`."}, {"sha": "c08f1f53218d625c6062bbe39caf7a89186a1490", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -589,8 +589,9 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             visitor.visit_id(item.hir_id());\n             walk_list!(visitor, visit_foreign_item_ref, items);\n         }\n-        ItemKind::GlobalAsm(_) => {\n+        ItemKind::GlobalAsm(asm) => {\n             visitor.visit_id(item.hir_id());\n+            walk_inline_asm(visitor, asm);\n         }\n         ItemKind::TyAlias(ref ty, ref generics) => {\n             visitor.visit_id(item.hir_id());\n@@ -650,6 +651,28 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n     }\n }\n \n+fn walk_inline_asm<'v, V: Visitor<'v>>(visitor: &mut V, asm: &'v InlineAsm<'v>) {\n+    for (op, _op_sp) in asm.operands {\n+        match op {\n+            InlineAsmOperand::In { expr, .. }\n+            | InlineAsmOperand::InOut { expr, .. }\n+            | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n+            InlineAsmOperand::Out { expr, .. } => {\n+                if let Some(expr) = expr {\n+                    visitor.visit_expr(expr);\n+                }\n+            }\n+            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                visitor.visit_expr(in_expr);\n+                if let Some(out_expr) = out_expr {\n+                    visitor.visit_expr(out_expr);\n+                }\n+            }\n+            InlineAsmOperand::Const { anon_const } => visitor.visit_anon_const(anon_const),\n+        }\n+    }\n+}\n+\n pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n     visitor.visit_id(hir_id);\n     visitor.visit_path(path, hir_id);\n@@ -1185,27 +1208,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n         ExprKind::InlineAsm(ref asm) => {\n-            for (op, _op_sp) in asm.operands {\n-                match op {\n-                    InlineAsmOperand::In { expr, .. }\n-                    | InlineAsmOperand::InOut { expr, .. }\n-                    | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n-                    InlineAsmOperand::Out { expr, .. } => {\n-                        if let Some(expr) = expr {\n-                            visitor.visit_expr(expr);\n-                        }\n-                    }\n-                    InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                        visitor.visit_expr(in_expr);\n-                        if let Some(out_expr) = out_expr {\n-                            visitor.visit_expr(out_expr);\n-                        }\n-                    }\n-                    InlineAsmOperand::Const { anon_const, .. } => {\n-                        visitor.visit_anon_const(anon_const)\n-                    }\n-                }\n-            }\n+            walk_inline_asm(visitor, asm);\n         }\n         ExprKind::LlvmInlineAsm(ref asm) => {\n             walk_list!(visitor, visit_expr, asm.outputs_exprs);"}, {"sha": "fe02cc5de8cb8d459de28973fc3ffee67c52db2b", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 109, "deletions": 105, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -660,9 +660,9 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose(item.span);\n             }\n-            hir::ItemKind::GlobalAsm(ref ga) => {\n-                self.head(visibility_qualified(&item.vis, \"global asm\"));\n-                self.s.word(ga.asm.to_string());\n+            hir::ItemKind::GlobalAsm(ref asm) => {\n+                self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n+                self.print_inline_asm(asm);\n                 self.end()\n             }\n             hir::ItemKind::TyAlias(ref ty, ref generics) => {\n@@ -1352,6 +1352,110 @@ impl<'a> State<'a> {\n         self.word(lit.node.to_lit_token().to_string())\n     }\n \n+    fn print_inline_asm(&mut self, asm: &hir::InlineAsm<'_>) {\n+        enum AsmArg<'a> {\n+            Template(String),\n+            Operand(&'a hir::InlineAsmOperand<'a>),\n+            Options(ast::InlineAsmOptions),\n+        }\n+\n+        let mut args = vec![];\n+        args.push(AsmArg::Template(ast::InlineAsmTemplatePiece::to_string(&asm.template)));\n+        args.extend(asm.operands.iter().map(|(o, _)| AsmArg::Operand(o)));\n+        if !asm.options.is_empty() {\n+            args.push(AsmArg::Options(asm.options));\n+        }\n+\n+        self.popen();\n+        self.commasep(Consistent, &args, |s, arg| match arg {\n+            AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n+            AsmArg::Operand(op) => match op {\n+                hir::InlineAsmOperand::In { reg, expr } => {\n+                    s.word(\"in\");\n+                    s.popen();\n+                    s.word(format!(\"{}\", reg));\n+                    s.pclose();\n+                    s.space();\n+                    s.print_expr(expr);\n+                }\n+                hir::InlineAsmOperand::Out { reg, late, expr } => {\n+                    s.word(if *late { \"lateout\" } else { \"out\" });\n+                    s.popen();\n+                    s.word(format!(\"{}\", reg));\n+                    s.pclose();\n+                    s.space();\n+                    match expr {\n+                        Some(expr) => s.print_expr(expr),\n+                        None => s.word(\"_\"),\n+                    }\n+                }\n+                hir::InlineAsmOperand::InOut { reg, late, expr } => {\n+                    s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                    s.popen();\n+                    s.word(format!(\"{}\", reg));\n+                    s.pclose();\n+                    s.space();\n+                    s.print_expr(expr);\n+                }\n+                hir::InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                    s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                    s.popen();\n+                    s.word(format!(\"{}\", reg));\n+                    s.pclose();\n+                    s.space();\n+                    s.print_expr(in_expr);\n+                    s.space();\n+                    s.word_space(\"=>\");\n+                    match out_expr {\n+                        Some(out_expr) => s.print_expr(out_expr),\n+                        None => s.word(\"_\"),\n+                    }\n+                }\n+                hir::InlineAsmOperand::Const { anon_const } => {\n+                    s.word(\"const\");\n+                    s.space();\n+                    s.print_anon_const(anon_const);\n+                }\n+                hir::InlineAsmOperand::Sym { expr } => {\n+                    s.word(\"sym\");\n+                    s.space();\n+                    s.print_expr(expr);\n+                }\n+            },\n+            AsmArg::Options(opts) => {\n+                s.word(\"options\");\n+                s.popen();\n+                let mut options = vec![];\n+                if opts.contains(ast::InlineAsmOptions::PURE) {\n+                    options.push(\"pure\");\n+                }\n+                if opts.contains(ast::InlineAsmOptions::NOMEM) {\n+                    options.push(\"nomem\");\n+                }\n+                if opts.contains(ast::InlineAsmOptions::READONLY) {\n+                    options.push(\"readonly\");\n+                }\n+                if opts.contains(ast::InlineAsmOptions::PRESERVES_FLAGS) {\n+                    options.push(\"preserves_flags\");\n+                }\n+                if opts.contains(ast::InlineAsmOptions::NORETURN) {\n+                    options.push(\"noreturn\");\n+                }\n+                if opts.contains(ast::InlineAsmOptions::NOSTACK) {\n+                    options.push(\"nostack\");\n+                }\n+                if opts.contains(ast::InlineAsmOptions::ATT_SYNTAX) {\n+                    options.push(\"att_syntax\");\n+                }\n+                s.commasep(Inconsistent, &options, |s, &opt| {\n+                    s.word(opt);\n+                });\n+                s.pclose();\n+            }\n+        });\n+        self.pclose();\n+    }\n+\n     pub fn print_expr(&mut self, expr: &hir::Expr<'_>) {\n         self.maybe_print_comment(expr.span.lo());\n         self.print_outer_attributes(self.attrs(expr.hir_id));\n@@ -1530,109 +1634,9 @@ impl<'a> State<'a> {\n                     self.print_expr_maybe_paren(&expr, parser::PREC_JUMP);\n                 }\n             }\n-            hir::ExprKind::InlineAsm(ref a) => {\n-                enum AsmArg<'a> {\n-                    Template(String),\n-                    Operand(&'a hir::InlineAsmOperand<'a>),\n-                    Options(ast::InlineAsmOptions),\n-                }\n-\n-                let mut args = vec![];\n-                args.push(AsmArg::Template(ast::InlineAsmTemplatePiece::to_string(&a.template)));\n-                args.extend(a.operands.iter().map(|(o, _)| AsmArg::Operand(o)));\n-                if !a.options.is_empty() {\n-                    args.push(AsmArg::Options(a.options));\n-                }\n-\n+            hir::ExprKind::InlineAsm(ref asm) => {\n                 self.word(\"asm!\");\n-                self.popen();\n-                self.commasep(Consistent, &args, |s, arg| match arg {\n-                    AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n-                    AsmArg::Operand(op) => match op {\n-                        hir::InlineAsmOperand::In { reg, expr } => {\n-                            s.word(\"in\");\n-                            s.popen();\n-                            s.word(format!(\"{}\", reg));\n-                            s.pclose();\n-                            s.space();\n-                            s.print_expr(expr);\n-                        }\n-                        hir::InlineAsmOperand::Out { reg, late, expr } => {\n-                            s.word(if *late { \"lateout\" } else { \"out\" });\n-                            s.popen();\n-                            s.word(format!(\"{}\", reg));\n-                            s.pclose();\n-                            s.space();\n-                            match expr {\n-                                Some(expr) => s.print_expr(expr),\n-                                None => s.word(\"_\"),\n-                            }\n-                        }\n-                        hir::InlineAsmOperand::InOut { reg, late, expr } => {\n-                            s.word(if *late { \"inlateout\" } else { \"inout\" });\n-                            s.popen();\n-                            s.word(format!(\"{}\", reg));\n-                            s.pclose();\n-                            s.space();\n-                            s.print_expr(expr);\n-                        }\n-                        hir::InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n-                            s.word(if *late { \"inlateout\" } else { \"inout\" });\n-                            s.popen();\n-                            s.word(format!(\"{}\", reg));\n-                            s.pclose();\n-                            s.space();\n-                            s.print_expr(in_expr);\n-                            s.space();\n-                            s.word_space(\"=>\");\n-                            match out_expr {\n-                                Some(out_expr) => s.print_expr(out_expr),\n-                                None => s.word(\"_\"),\n-                            }\n-                        }\n-                        hir::InlineAsmOperand::Const { anon_const } => {\n-                            s.word(\"const\");\n-                            s.space();\n-                            s.print_anon_const(anon_const);\n-                        }\n-                        hir::InlineAsmOperand::Sym { expr } => {\n-                            s.word(\"sym\");\n-                            s.space();\n-                            s.print_expr(expr);\n-                        }\n-                    },\n-                    AsmArg::Options(opts) => {\n-                        s.word(\"options\");\n-                        s.popen();\n-                        let mut options = vec![];\n-                        if opts.contains(ast::InlineAsmOptions::PURE) {\n-                            options.push(\"pure\");\n-                        }\n-                        if opts.contains(ast::InlineAsmOptions::NOMEM) {\n-                            options.push(\"nomem\");\n-                        }\n-                        if opts.contains(ast::InlineAsmOptions::READONLY) {\n-                            options.push(\"readonly\");\n-                        }\n-                        if opts.contains(ast::InlineAsmOptions::PRESERVES_FLAGS) {\n-                            options.push(\"preserves_flags\");\n-                        }\n-                        if opts.contains(ast::InlineAsmOptions::NORETURN) {\n-                            options.push(\"noreturn\");\n-                        }\n-                        if opts.contains(ast::InlineAsmOptions::NOSTACK) {\n-                            options.push(\"nostack\");\n-                        }\n-                        if opts.contains(ast::InlineAsmOptions::ATT_SYNTAX) {\n-                            options.push(\"att_syntax\");\n-                        }\n-                        s.commasep(Inconsistent, &options, |s, &opt| {\n-                            s.word(opt);\n-                        });\n-                        s.pclose();\n-                    }\n-                });\n-                self.pclose();\n+                self.print_inline_asm(asm);\n             }\n             hir::ExprKind::LlvmInlineAsm(ref a) => {\n                 let i = &a.inner;"}, {"sha": "c0d327d478834981892c7eefd642ea844f967374", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -390,8 +390,27 @@ fn collect_items_rec<'tcx>(\n                 collect_neighbours(tcx, instance, &mut neighbors);\n             });\n         }\n-        MonoItem::GlobalAsm(..) => {\n+        MonoItem::GlobalAsm(item_id) => {\n             recursion_depth_reset = None;\n+\n+            let item = tcx.hir().item(item_id);\n+            if let hir::ItemKind::GlobalAsm(asm) = item.kind {\n+                for (op, op_sp) in asm.operands {\n+                    match op {\n+                        hir::InlineAsmOperand::Const { ref anon_const } => {\n+                            // Treat these the same way as ItemKind::Const\n+                            let anon_const_def_id =\n+                                tcx.hir().local_def_id(anon_const.hir_id).to_def_id();\n+                            if let Ok(val) = tcx.const_eval_poly(anon_const_def_id) {\n+                                collect_const_value(tcx, val, &mut neighbors);\n+                            }\n+                        }\n+                        _ => span_bug!(*op_sp, \"invalid operand type for global_asm!\"),\n+                    }\n+                }\n+            } else {\n+                span_bug!(item.span, \"Mismatch between hir::Item type and MonoItem type\")\n+            }\n         }\n     }\n "}, {"sha": "4532a0a350cefc730c3b385bb220b6b66ed3efbc", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -405,6 +405,33 @@ impl Visitor<'tcx> for ItemVisitor<'tcx> {\n         ExprVisitor { tcx: self.tcx, param_env, typeck_results }.visit_body(body);\n         self.visit_body(body);\n     }\n+\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n+        if let hir::ItemKind::GlobalAsm(asm) = item.kind {\n+            for (op, op_sp) in asm.operands {\n+                match *op {\n+                    hir::InlineAsmOperand::Const { ref anon_const } => {\n+                        let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n+                        let value = ty::Const::from_anon_const(self.tcx, anon_const_def_id);\n+                        match value.ty.kind() {\n+                            ty::Int(_) | ty::Uint(_) | ty::Float(_) => {}\n+                            _ => {\n+                                let msg = \"asm `const` arguments must be integer or floating-point values\";\n+                                self.tcx.sess.span_err(*op_sp, msg);\n+                            }\n+                        }\n+                    }\n+                    hir::InlineAsmOperand::In { .. }\n+                    | hir::InlineAsmOperand::Out { .. }\n+                    | hir::InlineAsmOperand::InOut { .. }\n+                    | hir::InlineAsmOperand::SplitInOut { .. }\n+                    | hir::InlineAsmOperand::Sym { .. } => unreachable!(),\n+                }\n+            }\n+        }\n+\n+        intravisit::walk_item(self, item);\n+    }\n }\n \n impl Visitor<'tcx> for ExprVisitor<'tcx> {"}, {"sha": "ffa825b7d46a33c8faf96edb7f727fcc6c24f358", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -1066,10 +1066,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.future_proof_import(use_tree);\n             }\n \n-            ItemKind::ExternCrate(..) | ItemKind::MacroDef(..) | ItemKind::GlobalAsm(..) => {\n+            ItemKind::ExternCrate(..) | ItemKind::MacroDef(..) => {\n                 // do nothing, these are just around to be encoded\n             }\n \n+            ItemKind::GlobalAsm(_) => {\n+                visit::walk_item(self, item);\n+            }\n+\n             ItemKind::MacCall(_) => panic!(\"unexpanded macro in resolve!\"),\n         }\n     }"}, {"sha": "994206bd419347a8e974ce65c23dfb2b4bc27811", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -545,8 +545,9 @@ fn typeck_with_fallback<'tcx>(\n                             kind: TypeVariableOriginKind::TypeInference,\n                             span,\n                         }),\n-                        Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(ia), .. })\n-                            if ia.operands.iter().any(|(op, _op_sp)| match op {\n+                        Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n+                        | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. })\n+                            if asm.operands.iter().any(|(op, _op_sp)| match op {\n                                 hir::InlineAsmOperand::Const { anon_const } => {\n                                     anon_const.hir_id == id\n                                 }"}, {"sha": "5197b620f90ba73532765ea268ea91d39a103fbb", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -450,8 +450,9 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     tcx.typeck(def_id).node_type(anon_const.hir_id)\n                 }\n \n-                Node::Expr(&Expr { kind: ExprKind::InlineAsm(ia), .. })\n-                    if ia.operands.iter().any(|(op, _op_sp)| match op {\n+                Node::Expr(&Expr { kind: ExprKind::InlineAsm(asm), .. })\n+                | Node::Item(&Item { kind: ItemKind::GlobalAsm(asm), .. })\n+                    if asm.operands.iter().any(|(op, _op_sp)| match op {\n                         hir::InlineAsmOperand::Const { anon_const } => anon_const.hir_id == hir_id,\n                         _ => false,\n                     }) =>"}, {"sha": "5793f5e681b4820b3baad765de15b046e5fd2505", "filename": "library/alloc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/library%2Falloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/library%2Falloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2FCargo.toml?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -11,7 +11,7 @@ edition = \"2018\"\n \n [dependencies]\n core = { path = \"../core\" }\n-compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std'] }\n+compiler_builtins = { version = \"0.1.40\", features = ['rustc-dep-of-std'] }\n \n [dev-dependencies]\n rand = \"0.7\""}, {"sha": "b46a7aa138cd1afb19c01af03e6bf0e17faeadcc", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -1358,7 +1358,10 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! global_asm {\n-        (\"assembly\") => {\n+        (\"assembly template\",\n+            $(operands,)*\n+            $(options($(option),*))?\n+        ) => {\n             /* compiler built-in */\n         };\n     }"}, {"sha": "44e8af9bf543b34462efeaed81b1c94470b9f45f", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -17,7 +17,7 @@ panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n libc = { version = \"0.2.93\", default-features = false, features = ['rustc-dep-of-std'] }\n-compiler_builtins = { version = \"0.1.39\" }\n+compiler_builtins = { version = \"0.1.40\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n hashbrown = { version = \"0.11\", default-features = false, features = ['rustc-dep-of-std'] }"}, {"sha": "231cc15b8497f30c59e836f7af36e66005d48a7a", "filename": "library/std/src/sys/sgx/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -15,7 +15,7 @@ pub mod tls;\n pub mod usercalls;\n \n #[cfg(not(test))]\n-global_asm!(include_str!(\"entry.S\"));\n+global_asm!(include_str!(\"entry.S\"), options(att_syntax));\n \n #[repr(C)]\n struct EntryReturn(u64, u64);"}, {"sha": "e241f5788b9d8076150fb9945839a3b59a8ef89e", "filename": "src/doc/unstable-book/src/library-features/global-asm.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fglobal-asm.md", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fglobal-asm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fglobal-asm.md?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -38,11 +38,11 @@ And a more complicated usage looks like this:\n # mod x86 {\n \n pub mod sally {\n-    global_asm!(r#\"\n-        .global foo\n-      foo:\n-        jmp baz\n-    \"#);\n+    global_asm!(\n+        \".global foo\",\n+        \"foo:\",\n+        \"jmp baz\",\n+    );\n \n     #[no_mangle]\n     pub unsafe extern \"C\" fn baz() {}\n@@ -56,11 +56,11 @@ extern \"C\" {\n }\n \n pub mod harry {\n-    global_asm!(r#\"\n-        .global bar\n-      bar:\n-        jmp quux\n-    \"#);\n+    global_asm!(\n+        \".global bar\",\n+        \"bar:\",\n+        \"jmp quux\",\n+    );\n \n     #[no_mangle]\n     pub unsafe extern \"C\" fn quux() {}"}, {"sha": "791dec2ed692b3f7e52774e1a942c646d6cebccb", "filename": "src/test/run-make/x86_64-fortanix-unknown-sgx-lvi/enclave/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/src%2Ftest%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fenclave%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/src%2Ftest%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fenclave%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fx86_64-fortanix-unknown-sgx-lvi%2Fenclave%2Fsrc%2Fmain.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -8,7 +8,7 @@ rust_plus_one_global_asm:\n     movl (%rdi), %eax\n     inc %eax\n     retq\n-\"# );\n+\"#, options(att_syntax));\n \n extern {\n     fn cc_plus_one_c(arg : &u32) -> u32;"}, {"sha": "b8903e07cfd38cf0fbf048b65c05d1afb7f319c2", "filename": "src/test/ui/macros/global-asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/src%2Ftest%2Fui%2Fmacros%2Fglobal-asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/src%2Ftest%2Fui%2Fmacros%2Fglobal-asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fglobal-asm.rs?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -1,7 +1,7 @@\n #![feature(global_asm)]\n \n fn main() {\n-    global_asm!();  //~ ERROR requires a string literal as an argument\n+    global_asm!();  //~ ERROR requires at least a template string argument\n     global_asm!(struct); //~ ERROR expected expression\n-    global_asm!(123); //~ ERROR inline assembly must be a string literal\n+    global_asm!(123); //~ ERROR asm template must be a string literal\n }"}, {"sha": "a8621a0c5185e50514a5fa28d5d9cbfb947e53cf", "filename": "src/test/ui/macros/global-asm.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5918ee431717a276ea1a9c65d7c0009679a0643b/src%2Ftest%2Fui%2Fmacros%2Fglobal-asm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5918ee431717a276ea1a9c65d7c0009679a0643b/src%2Ftest%2Fui%2Fmacros%2Fglobal-asm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fglobal-asm.stderr?ref=5918ee431717a276ea1a9c65d7c0009679a0643b", "patch": "@@ -1,16 +1,16 @@\n-error: macro requires a string literal as an argument\n+error: requires at least a template string argument\n   --> $DIR/global-asm.rs:4:5\n    |\n LL |     global_asm!();\n-   |     ^^^^^^^^^^^^^^ string literal required\n+   |     ^^^^^^^^^^^^^^\n \n error: expected expression, found keyword `struct`\n   --> $DIR/global-asm.rs:5:17\n    |\n LL |     global_asm!(struct);\n    |                 ^^^^^^ expected expression\n \n-error: inline assembly must be a string literal\n+error: asm template must be a string literal\n   --> $DIR/global-asm.rs:6:17\n    |\n LL |     global_asm!(123);"}]}