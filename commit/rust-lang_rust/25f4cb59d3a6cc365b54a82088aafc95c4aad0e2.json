{"sha": "25f4cb59d3a6cc365b54a82088aafc95c4aad0e2", "node_id": "C_kwDOAAsO6NoAKDI1ZjRjYjU5ZDNhNmNjMzY1YjU0YTgyMDg4YWFmYzk1YzRhYWQwZTI", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-09-02T00:29:39Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-09-10T21:52:34Z"}, "message": "Remove &[T] from vec_deque::Drain", "tree": {"sha": "6a5b67823feaf5c716349cb5419e7646bea0f989", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a5b67823feaf5c716349cb5419e7646bea0f989"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25f4cb59d3a6cc365b54a82088aafc95c4aad0e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25f4cb59d3a6cc365b54a82088aafc95c4aad0e2", "html_url": "https://github.com/rust-lang/rust/commit/25f4cb59d3a6cc365b54a82088aafc95c4aad0e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25f4cb59d3a6cc365b54a82088aafc95c4aad0e2/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a6ac3c225d6322caaf0ef86623cddc74e5260c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a6ac3c225d6322caaf0ef86623cddc74e5260c6", "html_url": "https://github.com/rust-lang/rust/commit/4a6ac3c225d6322caaf0ef86623cddc74e5260c6"}], "stats": {"total": 64, "additions": 41, "deletions": 23}, "files": [{"sha": "6983c6d272acd8bf7b612c5dddc7457d57c22612", "filename": "library/alloc/src/collections/vec_deque/iter.rs", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/25f4cb59d3a6cc365b54a82088aafc95c4aad0e2/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25f4cb59d3a6cc365b54a82088aafc95c4aad0e2/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs?ref=25f4cb59d3a6cc365b54a82088aafc95c4aad0e2", "patch": "@@ -1,7 +1,9 @@\n use core::fmt;\n use core::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n+use core::marker::PhantomData;\n use core::mem::MaybeUninit;\n use core::ops::Try;\n+use core::ptr::NonNull;\n \n use super::{count, wrap_index, RingSlices};\n \n@@ -13,38 +15,53 @@ use super::{count, wrap_index, RingSlices};\n /// [`iter`]: super::VecDeque::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    ring: &'a [MaybeUninit<T>],\n+    ring: NonNull<[T]>,\n     tail: usize,\n     head: usize,\n+    _marker: PhantomData<&'a T>,\n }\n \n impl<'a, T> Iter<'a, T> {\n     pub(super) fn new(ring: &'a [MaybeUninit<T>], tail: usize, head: usize) -> Self {\n-        Iter { ring, tail, head }\n+        Iter {\n+            ring: unsafe { NonNull::new_unchecked(ring as *const [MaybeUninit<T>] as *mut _) },\n+            tail,\n+            head,\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    unsafe fn ring(&self) -> &'a [MaybeUninit<T>] {\n+        unsafe {\n+            core::slice::from_raw_parts(\n+                self.ring.as_ptr() as *const MaybeUninit<T>,\n+                self.ring.len(),\n+            )\n+        }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync> Sync for Iter<'_, T> {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync> Send for Iter<'_, T> {}\n+\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        let (front, back) = unsafe { RingSlices::ring_slices(self.ring(), self.head, self.tail) };\n         // Safety:\n         // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n         // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            f.debug_tuple(\"Iter\")\n-                .field(&MaybeUninit::slice_assume_init_ref(front))\n-                .field(&MaybeUninit::slice_assume_init_ref(back))\n-                .finish()\n-        }\n+        f.debug_tuple(\"Iter\").field(&front).field(&back).finish()\n     }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Iter<'_, T> {\n     fn clone(&self) -> Self {\n-        Iter { ring: self.ring, tail: self.tail, head: self.head }\n+        Iter { ring: self.ring, tail: self.tail, head: self.head, _marker: PhantomData }\n     }\n }\n \n@@ -62,7 +79,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         // Safety:\n         // - `self.tail` in a ring buffer is always a valid index.\n         // - `self.head` and `self.tail` equality is checked above.\n-        unsafe { Some(self.ring.get_unchecked(tail).assume_init_ref()) }\n+        unsafe { Some(self.ring().get_unchecked(tail).assume_init_ref()) }\n     }\n \n     #[inline]\n@@ -75,11 +92,11 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         // Safety:\n         // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n         // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n         unsafe {\n+            let (front, back) = RingSlices::ring_slices(self.ring(), self.head, self.tail);\n             accum = MaybeUninit::slice_assume_init_ref(front).iter().fold(accum, &mut f);\n             MaybeUninit::slice_assume_init_ref(back).iter().fold(accum, &mut f)\n         }\n@@ -94,12 +111,13 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         let (mut iter, final_res);\n         if self.tail <= self.head {\n             // Safety: single slice self.ring[self.tail..self.head] is initialized.\n-            iter = unsafe { MaybeUninit::slice_assume_init_ref(&self.ring[self.tail..self.head]) }\n-                .iter();\n+            iter =\n+                unsafe { MaybeUninit::slice_assume_init_ref(&self.ring()[self.tail..self.head]) }\n+                    .iter();\n             final_res = iter.try_fold(init, &mut f);\n         } else {\n-            // Safety: two slices: self.ring[self.tail..], self.ring[..self.head] both are initialized.\n-            let (front, back) = self.ring.split_at(self.tail);\n+            // Safety: two slices: self.ring()[self.tail..], self.ring()[..self.head] both are initialized.\n+            let (front, back) = unsafe { self.ring().split_at(self.tail) };\n \n             let mut back_iter = unsafe { MaybeUninit::slice_assume_init_ref(back).iter() };\n             let res = back_iter.try_fold(init, &mut f);\n@@ -133,7 +151,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         // that is in bounds.\n         unsafe {\n             let idx = wrap_index(self.tail.wrapping_add(idx), self.ring.len());\n-            self.ring.get_unchecked(idx).assume_init_ref()\n+            self.ring().get_unchecked(idx).assume_init_ref()\n         }\n     }\n }\n@@ -149,18 +167,18 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n         // Safety:\n         // - `self.head` in a ring buffer is always a valid index.\n         // - `self.head` and `self.tail` equality is checked above.\n-        unsafe { Some(self.ring.get_unchecked(self.head).assume_init_ref()) }\n+        unsafe { Some(self.ring().get_unchecked(self.head).assume_init_ref()) }\n     }\n \n     fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         // Safety:\n         // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n         // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n         unsafe {\n+            let (front, back) = RingSlices::ring_slices(self.ring(), self.head, self.tail);\n             accum = MaybeUninit::slice_assume_init_ref(back).iter().rfold(accum, &mut f);\n             MaybeUninit::slice_assume_init_ref(front).iter().rfold(accum, &mut f)\n         }\n@@ -174,14 +192,14 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     {\n         let (mut iter, final_res);\n         if self.tail <= self.head {\n-            // Safety: single slice self.ring[self.tail..self.head] is initialized.\n+            // Safety: single slice self.ring()[self.tail..self.head] is initialized.\n             iter = unsafe {\n-                MaybeUninit::slice_assume_init_ref(&self.ring[self.tail..self.head]).iter()\n+                MaybeUninit::slice_assume_init_ref(&self.ring()[self.tail..self.head]).iter()\n             };\n             final_res = iter.try_rfold(init, &mut f);\n         } else {\n-            // Safety: two slices: self.ring[self.tail..], self.ring[..self.head] both are initialized.\n-            let (front, back) = self.ring.split_at(self.tail);\n+            // Safety: two slices: self.ring()[self.tail..], self.ring()[..self.head] both are initialized.\n+            let (front, back) = unsafe { self.ring().split_at(self.tail) };\n \n             let mut front_iter =\n                 unsafe { MaybeUninit::slice_assume_init_ref(&front[..self.head]).iter() };"}]}