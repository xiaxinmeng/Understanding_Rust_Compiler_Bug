{"sha": "ca8347a1ffac55d3e3de163575b982f1a5175aa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhODM0N2ExZmZhYzU1ZDNlM2RlMTYzNTc1Yjk4MmYxYTUxNzVhYTE=", "commit": {"author": {"name": "David Renshaw", "email": "david@sandstorm.io", "date": "2017-06-03T01:00:35Z"}, "committer": {"name": "David Renshaw", "email": "david@sandstorm.io", "date": "2017-06-03T01:00:35Z"}, "message": "update for upstream ParamEnv changes", "tree": {"sha": "674541603aa07d7f9235aa994fdd0ac58586343c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/674541603aa07d7f9235aa994fdd0ac58586343c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca8347a1ffac55d3e3de163575b982f1a5175aa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca8347a1ffac55d3e3de163575b982f1a5175aa1", "html_url": "https://github.com/rust-lang/rust/commit/ca8347a1ffac55d3e3de163575b982f1a5175aa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca8347a1ffac55d3e3de163575b982f1a5175aa1/comments", "author": null, "committer": null, "parents": [{"sha": "d7d11c1ecb5be4b8e38364092f706c66e486f553", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7d11c1ecb5be4b8e38364092f706c66e486f553", "html_url": "https://github.com/rust-lang/rust/commit/d7d11c1ecb5be4b8e38364092f706c66e486f553"}], "stats": {"total": 32, "additions": 16, "deletions": 16}, "files": [{"sha": "0ed8e5dc495df7e4bd2dbe59be14459e10bfd891", "filename": "src/eval_context.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ca8347a1ffac55d3e3de163575b982f1a5175aa1/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8347a1ffac55d3e3de163575b982f1a5175aa1/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=ca8347a1ffac55d3e3de163575b982f1a5175aa1", "patch": "@@ -379,7 +379,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n         // generics are weird, don't run this function on a generic\n         assert!(!ty.needs_subst());\n-        ty.is_sized(self.tcx, ty::ParamEnv::empty(), DUMMY_SP)\n+        ty.is_sized(self.tcx, ty::ParamEnv::empty(Reveal::All), DUMMY_SP)\n     }\n \n     pub fn load_mir(&self, instance: ty::InstanceDef<'tcx>) -> EvalResult<'tcx, &'tcx mir::Mir<'tcx>> {\n@@ -438,9 +438,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // TODO(solson): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty, substs);\n \n-        self.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-            ty.layout(&infcx).map_err(EvalError::Layout)\n-        })\n+        ty.layout(self.tcx, ty::ParamEnv::empty(Reveal::All)).map_err(EvalError::Layout)\n     }\n \n     pub fn push_stack_frame(\n@@ -2033,19 +2031,17 @@ pub fn needs_drop_glue<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, t: Ty<'tcx>) -> bo\n     // returned `false` does not appear unsound. The impact on\n     // code quality is unknown at this time.)\n \n-    let env = ty::ParamEnv::empty();\n+    let env = ty::ParamEnv::empty(Reveal::All);\n     if !t.needs_drop(tcx, env) {\n         return false;\n     }\n     match t.sty {\n         ty::TyAdt(def, _) if def.is_box() => {\n             let typ = t.boxed_ty();\n             if !typ.needs_drop(tcx, env) && type_is_sized(tcx, typ) {\n-                tcx.infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n-                    let layout = t.layout(&infcx).unwrap();\n-                    // `Box<ZeroSizeType>` does not allocate.\n-                    layout.size(&tcx.data_layout).bytes() != 0\n-                })\n+                let layout = t.layout(tcx, ty::ParamEnv::empty(Reveal::All)).unwrap();\n+                // `Box<ZeroSizeType>` does not allocate.\n+                layout.size(&tcx.data_layout).bytes() != 0\n             } else {\n                 true\n             }\n@@ -2157,7 +2153,7 @@ impl<'a, 'tcx> ::rustc::ty::fold::TypeFolder<'tcx, 'tcx> for AssociatedTypeNorma\n fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     // generics are weird, don't run this function on a generic\n     assert!(!ty.needs_subst());\n-    ty.is_sized(tcx, ty::ParamEnv::empty(), DUMMY_SP)\n+    ty.is_sized(tcx, ty::ParamEnv::empty(Reveal::All), DUMMY_SP)\n }\n \n /// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n@@ -2176,13 +2172,14 @@ fn fulfill_obligation<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n         let obligation_cause = traits::ObligationCause::misc(span,\n                                                             ast::DUMMY_NODE_ID);\n         let obligation = traits::Obligation::new(obligation_cause,\n-                                                    trait_ref.to_poly_trait_predicate());\n+                                                 ty::ParamEnv::empty(Reveal::All),\n+                                                 trait_ref.to_poly_trait_predicate());\n \n         let selection = match selcx.select(&obligation) {\n             Ok(Some(selection)) => selection,"}, {"sha": "9e04d583a22520b9c76f545e89783206960f1549", "filename": "src/step.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca8347a1ffac55d3e3de163575b982f1a5175aa1/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8347a1ffac55d3e3de163575b982f1a5175aa1/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=ca8347a1ffac55d3e3de163575b982f1a5175aa1", "patch": "@@ -6,6 +6,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir;\n+use rustc::traits::Reveal;\n use rustc::ty::layout::Layout;\n use rustc::ty::{subst, self};\n \n@@ -197,7 +198,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n             let mutable = !shared ||\n                 !mir.return_ty.is_freeze(\n                     this.ecx.tcx,\n-                    ty::ParamEnv::empty(),\n+                    ty::ParamEnv::empty(Reveal::All),\n                     span);\n             let cleanup = StackPopCleanup::MarkStatic(mutable);\n             let name = ty::tls::with(|tcx| tcx.item_path_str(def_id));"}, {"sha": "e65c7eda1219bd8cc3391ab86fc8d54f3f67966d", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca8347a1ffac55d3e3de163575b982f1a5175aa1/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8347a1ffac55d3e3de163575b982f1a5175aa1/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=ca8347a1ffac55d3e3de163575b982f1a5175aa1", "patch": "@@ -1,4 +1,5 @@\n use rustc::mir;\n+use rustc::traits::Reveal;\n use rustc::ty::layout::{Layout, Size, Align};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n@@ -291,7 +292,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"needs_drop\" => {\n                 let ty = substs.type_at(0);\n-                let env = ty::ParamEnv::empty();\n+                let env = ty::ParamEnv::empty(Reveal::All);\n                 let needs_drop = ty.needs_drop(self.tcx, env);\n                 self.write_primval(dest, PrimVal::from_bool(needs_drop), dest_ty)?;\n             }"}, {"sha": "622eddfde1baabad298157e8d5025d2e51b4083b", "filename": "src/traits.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca8347a1ffac55d3e3de163575b982f1a5175aa1/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca8347a1ffac55d3e3de163575b982f1a5175aa1/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=ca8347a1ffac55d3e3de163575b982f1a5175aa1", "patch": "@@ -16,11 +16,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(crate) fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n         // Do the initial selection for the obligation. This yields the shallow result we are\n         // looking for -- that is, what specific impl.\n-        self.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n+        self.tcx.infer_ctxt(()).enter(|infcx| {\n             let mut selcx = traits::SelectionContext::new(&infcx);\n \n             let obligation = traits::Obligation::new(\n                 traits::ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n+                ty::ParamEnv::empty(Reveal::All),\n                 trait_ref.to_poly_trait_predicate(),\n             );\n             let selection = selcx.select(&obligation).unwrap().unwrap();"}]}