{"sha": "effb3636cc416ae81450e857352b832a86d5dd44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZmIzNjM2Y2M0MTZhZTgxNDUwZTg1NzM1MmI4MzJhODZkNWRkNDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-18T15:08:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-25T11:06:27Z"}, "message": "Integrate builtin bounds fully into the trait checker", "tree": {"sha": "a672f3579167efd48b6b8b5673fa241542814fd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a672f3579167efd48b6b8b5673fa241542814fd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/effb3636cc416ae81450e857352b832a86d5dd44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/effb3636cc416ae81450e857352b832a86d5dd44", "html_url": "https://github.com/rust-lang/rust/commit/effb3636cc416ae81450e857352b832a86d5dd44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/effb3636cc416ae81450e857352b832a86d5dd44/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d299bafb31a7c0528e690e48ec6d5591f1eb0bac", "url": "https://api.github.com/repos/rust-lang/rust/commits/d299bafb31a7c0528e690e48ec6d5591f1eb0bac", "html_url": "https://github.com/rust-lang/rust/commit/d299bafb31a7c0528e690e48ec6d5591f1eb0bac"}], "stats": {"total": 1225, "additions": 821, "deletions": 404}, "files": [{"sha": "b0206e73e47990aeed09feed8268c1d9c4c0c98c", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -25,19 +25,19 @@ pub use self::Sync as Share;\n \n /// Types able to be transferred across task boundaries.\n #[lang=\"send\"]\n-pub trait Send {\n+pub trait Send for Sized? {\n     // empty.\n }\n \n /// Types with a constant size known at compile-time.\n #[lang=\"sized\"]\n-pub trait Sized {\n+pub trait Sized for Sized? {\n     // Empty.\n }\n \n /// Types that can be copied by simply copying bits (i.e. `memcpy`).\n #[lang=\"copy\"]\n-pub trait Copy {\n+pub trait Copy for Sized? {\n     // Empty.\n }\n \n@@ -87,7 +87,7 @@ pub trait Copy {\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n #[lang=\"sync\"]\n-pub trait Sync {\n+pub trait Sync for Sized? {\n     // Empty\n }\n "}, {"sha": "d84729d1935ff3fb727d6ef73ad20399bd022648", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -21,7 +21,6 @@ use middle::ty;\n use middle::typeck::infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n-use util::nodemap::DefIdMap;\n use util::ppaux::Repr;\n \n pub fn impl_can_satisfy(infcx: &InferCtxt,\n@@ -40,8 +39,7 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n     let param_env = ty::empty_parameter_environment();\n-    let unboxed_closures = DefIdMap::new();\n-    match evaluate_impl(infcx, &param_env, &unboxed_closures, DUMMY_CAUSE,\n+    match evaluate_impl(infcx, &param_env, infcx.tcx, DUMMY_CAUSE,\n                         impl2_def_id, impl1_self_ty) {\n         EvaluatedToMatch | EvaluatedToAmbiguity => true,\n         EvaluatedToUnmatch => false,"}, {"sha": "c0caa1d7c79fb638968938fefa552091cb8613a7", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 118, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::mem_categorization::Typer;\n use middle::ty;\n-use middle::typeck::infer::{InferCtxt, skolemize};\n-use util::nodemap::DefIdMap;\n+use middle::typeck::infer::InferCtxt;\n use util::ppaux::Repr;\n \n use super::CodeAmbiguity;\n use super::Obligation;\n use super::FulfillmentError;\n use super::CodeSelectionError;\n use super::select::SelectionContext;\n-use super::Unimplemented;\n \n /**\n  * The fulfillment context is used to drive trait resolution.  It\n@@ -36,17 +35,12 @@ pub struct FulfillmentContext {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n     trait_obligations: Vec<Obligation>,\n-\n-    // For semi-hacky reasons (see FIXME below) we keep the builtin\n-    // trait obligations segregated.\n-    builtin_obligations: Vec<Obligation>,\n }\n \n impl FulfillmentContext {\n     pub fn new() -> FulfillmentContext {\n         FulfillmentContext {\n             trait_obligations: Vec::new(),\n-            builtin_obligations: Vec::new()\n         }\n     }\n \n@@ -55,24 +49,16 @@ impl FulfillmentContext {\n                                obligation: Obligation)\n     {\n         debug!(\"register_obligation({})\", obligation.repr(tcx));\n-        match tcx.lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n-            Some(_) => {\n-                self.builtin_obligations.push(obligation);\n-            }\n-            None => {\n-                self.trait_obligations.push(obligation);\n-            }\n-        }\n+        self.trait_obligations.push(obligation);\n     }\n \n-    pub fn select_all_or_error(&mut self,\n-                               infcx: &InferCtxt,\n-                               param_env: &ty::ParameterEnvironment,\n-                               unboxed_closures: &DefIdMap<ty::UnboxedClosure>)\n-                               -> Result<(),Vec<FulfillmentError>>\n+    pub fn select_all_or_error<'a,'tcx>(&mut self,\n+                                        infcx: &InferCtxt<'a,'tcx>,\n+                                        param_env: &ty::ParameterEnvironment,\n+                                        typer: &Typer<'tcx>)\n+                                        -> Result<(),Vec<FulfillmentError>>\n     {\n-        try!(self.select_where_possible(infcx, param_env,\n-                                        unboxed_closures));\n+        try!(self.select_where_possible(infcx, param_env, typer));\n \n         // Anything left is ambiguous.\n         let errors: Vec<FulfillmentError> =\n@@ -88,15 +74,14 @@ impl FulfillmentContext {\n         }\n     }\n \n-    pub fn select_where_possible(&mut self,\n-                                 infcx: &InferCtxt,\n-                                 param_env: &ty::ParameterEnvironment,\n-                                 unboxed_closures: &DefIdMap<ty::UnboxedClosure>)\n-                                 -> Result<(),Vec<FulfillmentError>>\n+    pub fn select_where_possible<'a,'tcx>(&mut self,\n+                                          infcx: &InferCtxt<'a,'tcx>,\n+                                          param_env: &ty::ParameterEnvironment,\n+                                          typer: &Typer<'tcx>)\n+                                          -> Result<(),Vec<FulfillmentError>>\n     {\n         let tcx = infcx.tcx;\n-        let selcx = SelectionContext::new(infcx, param_env,\n-                                          unboxed_closures);\n+        let mut selcx = SelectionContext::new(infcx, param_env, typer);\n \n         debug!(\"select_where_possible({} obligations) start\",\n                self.trait_obligations.len());\n@@ -158,92 +143,4 @@ impl FulfillmentContext {\n             Err(errors)\n         }\n     }\n-\n-    pub fn check_builtin_bound_obligations(\n-        &self,\n-        infcx: &InferCtxt)\n-        -> Result<(),Vec<FulfillmentError>>\n-    {\n-        let tcx = infcx.tcx;\n-        let mut errors = Vec::new();\n-        debug!(\"check_builtin_bound_obligations\");\n-        for obligation in self.builtin_obligations.iter() {\n-            debug!(\"obligation={}\", obligation.repr(tcx));\n-\n-            let def_id = obligation.trait_ref.def_id;\n-            let bound = match tcx.lang_items.to_builtin_kind(def_id) {\n-                Some(bound) => { bound }\n-                None => { continue; }\n-            };\n-\n-            let unskol_self_ty = obligation.self_ty();\n-\n-            // Skolemize the self-type so that it no longer contains\n-            // inference variables. Note that this also replaces\n-            // regions with 'static. You might think that this is not\n-            // ok, because checking whether something is `Send`\n-            // implies checking whether it is 'static: that's true,\n-            // but in fact the region bound is fed into region\n-            // inference separately and enforced there (and that has\n-            // even already been done before this code executes,\n-            // generally speaking).\n-            let self_ty = skolemize(infcx, unskol_self_ty);\n-\n-            debug!(\"bound={} self_ty={}\", bound, self_ty.repr(tcx));\n-            if ty::type_is_error(self_ty) {\n-                // Indicates an error that was/will-be\n-                // reported elsewhere.\n-                continue;\n-            }\n-\n-            // Determine if builtin bound is met.\n-            let tc = ty::type_contents(tcx, self_ty);\n-            debug!(\"tc={}\", tc);\n-            let met = match bound {\n-                ty::BoundSend   => tc.is_sendable(tcx),\n-                ty::BoundSized  => tc.is_sized(tcx),\n-                ty::BoundCopy   => tc.is_copy(tcx),\n-                ty::BoundSync   => tc.is_sync(tcx),\n-            };\n-\n-            if met {\n-                continue;\n-            }\n-\n-            // FIXME -- This is kind of a hack: it requently happens\n-            // that some earlier error prevents types from being fully\n-            // inferred, and then we get a bunch of uninteresting\n-            // errors saying something like \"<generic #0> doesn't\n-            // implement Sized\".  It may even be true that we could\n-            // just skip over all checks where the self-ty is an\n-            // inference variable, but I was afraid that there might\n-            // be an inference variable created, registered as an\n-            // obligation, and then never forced by writeback, and\n-            // hence by skipping here we'd be ignoring the fact that\n-            // we don't KNOW the type works out. Though even that\n-            // would probably be harmless, given that we're only\n-            // talking about builtin traits, which are known to be\n-            // inhabited. But in any case I just threw in this check\n-            // for has_errors() to be sure that compilation isn't\n-            // happening anyway. In that case, why inundate the user.\n-            if ty::type_needs_infer(self_ty) &&\n-                tcx.sess.has_errors()\n-            {\n-                debug!(\"skipping printout because self_ty={}\",\n-                       self_ty.repr(tcx));\n-                continue;\n-            }\n-\n-            errors.push(\n-                FulfillmentError::new(\n-                    (*obligation).clone(),\n-                    CodeSelectionError(Unimplemented)));\n-        }\n-\n-        if errors.is_empty() {\n-            Ok(())\n-        } else {\n-            Err(errors)\n-        }\n-    }\n }"}, {"sha": "f69eb2e17ea260fba8da76013a048de3ba860d82", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -12,13 +12,13 @@\n  * Trait Resolution. See doc.rs.\n  */\n \n+use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::ty;\n use middle::typeck::infer::InferCtxt;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n-use util::nodemap::DefIdMap;\n \n pub use self::fulfill::FulfillmentContext;\n pub use self::select::SelectionContext;\n@@ -208,50 +208,29 @@ pub struct VtableParamData {\n     pub bound: Rc<ty::TraitRef>,\n }\n \n-pub fn try_select_obligation(infcx: &InferCtxt,\n-                             param_env: &ty::ParameterEnvironment,\n-                             unboxed_closures: &DefIdMap<ty::UnboxedClosure>,\n-                             obligation: &Obligation)\n-                             -> SelectionResult<Selection>\n-{\n-    /*!\n-     * Attempts to select the impl/bound/etc for the obligation\n-     * given. Returns `None` if we are unable to resolve, either\n-     * because of ambiguity or due to insufficient inference.  Note\n-     * that selection is a shallow process and hence the result may\n-     * contain nested obligations that must be resolved. The caller is\n-     * responsible for ensuring that those get resolved. (But see\n-     * `try_select_obligation_deep` below.)\n-     */\n-\n-    let selcx = select::SelectionContext::new(infcx, param_env, unboxed_closures);\n-    selcx.select(obligation)\n-}\n-\n-pub fn evaluate_obligation(infcx: &InferCtxt,\n-                           param_env: &ty::ParameterEnvironment,\n-                           obligation: &Obligation,\n-                           unboxed_closures: &DefIdMap<ty::UnboxedClosure>)\n-                           -> EvaluationResult\n+pub fn evaluate_obligation<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                    param_env: &ty::ParameterEnvironment,\n+                                    obligation: &Obligation,\n+                                    typer: &Typer<'tcx>)\n+                                    -> EvaluationResult\n {\n     /*!\n      * Attempts to resolve the obligation given. Returns `None` if\n      * we are unable to resolve, either because of ambiguity or\n      * due to insufficient inference.\n      */\n \n-    let selcx = select::SelectionContext::new(infcx, param_env,\n-                                              unboxed_closures);\n+    let mut selcx = select::SelectionContext::new(infcx, param_env, typer);\n     selcx.evaluate_obligation(obligation)\n }\n \n-pub fn evaluate_impl(infcx: &InferCtxt,\n-                     param_env: &ty::ParameterEnvironment,\n-                     unboxed_closures: &DefIdMap<ty::UnboxedClosure>,\n-                     cause: ObligationCause,\n-                     impl_def_id: ast::DefId,\n-                     self_ty: ty::t)\n-                     -> EvaluationResult\n+pub fn evaluate_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                              param_env: &ty::ParameterEnvironment,\n+                              typer: &Typer<'tcx>,\n+                              cause: ObligationCause,\n+                              impl_def_id: ast::DefId,\n+                              self_ty: ty::t)\n+                              -> EvaluationResult\n {\n     /*!\n      * Tests whether the impl `impl_def_id` can be applied to the self\n@@ -264,17 +243,17 @@ pub fn evaluate_impl(infcx: &InferCtxt,\n      *   (yes/no/unknown).\n      */\n \n-    let selcx = select::SelectionContext::new(infcx, param_env, unboxed_closures);\n+    let mut selcx = select::SelectionContext::new(infcx, param_env, typer);\n     selcx.evaluate_impl(impl_def_id, cause, self_ty)\n }\n \n-pub fn select_inherent_impl(infcx: &InferCtxt,\n-                            param_env: &ty::ParameterEnvironment,\n-                            unboxed_closures: &DefIdMap<ty::UnboxedClosure>,\n-                            cause: ObligationCause,\n-                            impl_def_id: ast::DefId,\n-                            self_ty: ty::t)\n-                            -> SelectionResult<VtableImplData<Obligation>>\n+pub fn select_inherent_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                     param_env: &ty::ParameterEnvironment,\n+                                     typer: &Typer<'tcx>,\n+                                     cause: ObligationCause,\n+                                     impl_def_id: ast::DefId,\n+                                     self_ty: ty::t)\n+                                     -> SelectionResult<VtableImplData<Obligation>>\n {\n     /*!\n      * Matches the self type of the inherent impl `impl_def_id`\n@@ -293,8 +272,7 @@ pub fn select_inherent_impl(infcx: &InferCtxt,\n     // `try_resolve_obligation()`.\n     assert!(ty::impl_trait_ref(infcx.tcx, impl_def_id).is_none());\n \n-    let selcx = select::SelectionContext::new(infcx, param_env,\n-                                              unboxed_closures);\n+    let mut selcx = select::SelectionContext::new(infcx, param_env, typer);\n     selcx.select_inherent_impl(impl_def_id, cause, self_ty)\n }\n "}, {"sha": "5395e966887715d30ac9136d84c10fab3bca1405", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 635, "deletions": 124, "changes": 759, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -21,20 +21,29 @@ use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure};\n use super::{VtableImplData, VtableParamData};\n use super::{util};\n \n+use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::ty;\n+use middle::ty_fold::TypeFoldable;\n use middle::typeck::check::regionmanip;\n use middle::typeck::infer;\n-use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::{InferCtxt, TypeSkolemizer};\n use std::rc::Rc;\n use syntax::ast;\n-use util::nodemap::DefIdMap;\n use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     param_env: &'cx ty::ParameterEnvironment,\n-    unboxed_closures: &'cx DefIdMap<ty::UnboxedClosure>,\n+    typer: &'cx Typer<'tcx>+'cx,\n+    skolemizer: TypeSkolemizer<'cx, 'tcx>,\n+}\n+\n+// A stack that walks back up the stack frame.\n+struct ObligationStack<'prev> {\n+    obligation: &'prev Obligation,\n+    skol_obligation_self_ty: ty::t,\n+    previous: Option<&'prev ObligationStack<'prev>>\n }\n \n // pub struct SelectionCache {\n@@ -47,6 +56,7 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n //     skol_obligation_self_ty: ty::t,\n // }\n \n+#[deriving(PartialEq,Eq)]\n enum MatchResult<T> {\n     Matched(T),\n     AmbiguousMatch,\n@@ -86,7 +96,8 @@ enum Candidate {\n     MatchedParamCandidate(VtableParamData),\n     AmbiguousParamCandidate,\n     Impl(ImplCandidate),\n-    MatchedUnboxedClosureCandidate(/* closure */ ast::DefId)\n+    MatchedUnboxedClosureCandidate(/* closure */ ast::DefId),\n+    ErrorCandidate,\n }\n \n #[deriving(Clone)]\n@@ -98,10 +109,14 @@ enum ImplCandidate {\n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n                param_env: &'cx ty::ParameterEnvironment,\n-               unboxed_closures: &'cx DefIdMap<ty::UnboxedClosure>)\n+               typer: &'cx Typer<'tcx>)\n                -> SelectionContext<'cx, 'tcx> {\n-        SelectionContext { infcx: infcx, param_env: param_env,\n-                           unboxed_closures: unboxed_closures }\n+        SelectionContext {\n+            infcx: infcx,\n+            param_env: param_env,\n+            typer: typer,\n+            skolemizer: infcx.skolemizer(),\n+        }\n     }\n \n     pub fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n@@ -123,7 +138,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     //    is `Vec<Foo>:Iterable<Bar>`, but the impl specifies\n     //    `impl<T> Iterable<T> for Vec<T>`, than an error would result.\n \n-    pub fn select(&self, obligation: &Obligation) -> SelectionResult<Selection> {\n+    pub fn select(&mut self, obligation: &Obligation) -> SelectionResult<Selection> {\n         /*!\n          * Evaluates whether the obligation can be satisfied. Returns\n          * an indication of whether the obligation can be satisfied\n@@ -133,13 +148,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"select({})\", obligation.repr(self.tcx()));\n \n-        match try!(self.candidate_from_obligation(obligation)) {\n+        let stack = self.new_stack(obligation);\n+        match try!(self.candidate_from_obligation(&stack)) {\n             None => Ok(None),\n             Some(candidate) => self.confirm_candidate(obligation, candidate),\n         }\n     }\n \n-    pub fn select_inherent_impl(&self,\n+    pub fn select_inherent_impl(&mut self,\n                                 impl_def_id: ast::DefId,\n                                 obligation_cause: ObligationCause,\n                                 obligation_self_ty: ty::t)\n@@ -177,7 +193,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // applied to particular types. It skips the \"confirmation\" step and\n     // hence completely ignores output type parameters.\n \n-    pub fn evaluate_obligation(&self,\n+    pub fn evaluate_obligation(&mut self,\n                                obligation: &Obligation)\n                                -> EvaluationResult\n     {\n@@ -189,14 +205,70 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_obligation({})\",\n                obligation.repr(self.tcx()));\n \n-        match self.candidate_from_obligation(obligation) {\n+        let stack = self.new_stack(obligation);\n+        match self.candidate_from_obligation(&stack) {\n+            Ok(Some(c)) => c.to_evaluation_result(),\n+            Ok(None) => EvaluatedToAmbiguity,\n+            Err(_) => EvaluatedToUnmatch,\n+        }\n+    }\n+\n+    fn evaluate_builtin_bound_recursively(&mut self,\n+                                          bound: ty::BuiltinBound,\n+                                          previous_stack: &ObligationStack,\n+                                          ty: ty::t)\n+                                          -> EvaluationResult\n+    {\n+        let obligation =\n+            util::obligation_for_builtin_bound(\n+                self.tcx(),\n+                previous_stack.obligation.cause,\n+                bound,\n+                previous_stack.obligation.recursion_depth + 1,\n+                ty);\n+        self.evaluate_obligation_recursively(previous_stack, &obligation)\n+    }\n+\n+    fn evaluate_obligation_recursively(&mut self,\n+                                       previous_stack: &ObligationStack,\n+                                       obligation: &Obligation)\n+                                       -> EvaluationResult\n+    {\n+        debug!(\"evaluate_obligation_recursively({})\",\n+               obligation.repr(self.tcx()));\n+\n+        // If there is any previous entry on the stack that precisely\n+        // matches this obligation, then we can assume that the\n+        // obligation is satisfied for now (still all other conditions\n+        // must be met of course). One obvious case this comes up is\n+        // marker traits like `Send`. Think of a a linked list:\n+        //\n+        //    struct List<T> { data: T, next: Option<Box<List<T>>> {\n+        //\n+        // `Box<List<T>>` will be `Send` if `T` is `Send` and\n+        // `Option<Box<List<T>>>` is `Send`, and in turn\n+        // `Option<Box<List<T>>>` is `Send` if `Box<List<T>>` is\n+        // `Send`.\n+        if\n+            previous_stack.iter()\n+            .filter(|e| e.obligation.trait_ref.def_id == obligation.trait_ref.def_id)\n+            .find(|e| self.match_self_types(obligation.cause,\n+                                            e.skol_obligation_self_ty,\n+                                            obligation.self_ty()) == Matched(()))\n+            .is_some()\n+        {\n+            return EvaluatedToMatch;\n+        }\n+\n+        let stack = self.push_stack(previous_stack, obligation);\n+        match self.candidate_from_obligation(&stack) {\n             Ok(Some(c)) => c.to_evaluation_result(),\n             Ok(None) => EvaluatedToAmbiguity,\n             Err(_) => EvaluatedToUnmatch,\n         }\n     }\n \n-    pub fn evaluate_impl(&self,\n+    pub fn evaluate_impl(&mut self,\n                          impl_def_id: ast::DefId,\n                          obligation_cause: ObligationCause,\n                          obligation_self_ty: ty::t)\n@@ -227,30 +299,40 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // caller obligations, and so forth and assembling a list of\n     // candidates. See `doc.rs` and the `Candidate` type for more details.\n \n-    fn candidate_from_obligation(&self, obligation: &Obligation)\n+    fn candidate_from_obligation(&mut self,\n+                                 stack: &ObligationStack)\n                                  -> SelectionResult<Candidate>\n     {\n-        debug!(\"candidate_from_obligation({}, self_ty={})\",\n-               obligation.repr(self.tcx()),\n-               self.infcx.ty_to_string(obligation.self_ty()));\n-\n-        let skol_obligation_self_ty =\n-            infer::skolemize(self.infcx, obligation.self_ty());\n+        debug!(\"candidate_from_obligation({})\",\n+               stack.repr(self.tcx()));\n \n         // First, check the cache.\n-        match self.check_candidate_cache(obligation, skol_obligation_self_ty) {\n+        match self.check_candidate_cache(stack.obligation, stack.skol_obligation_self_ty) {\n             Some(c) => {\n                 return Ok(Some(c));\n             }\n             None => { }\n         }\n \n-        let mut candidates =\n-            try!(self.assemble_candidates(obligation,\n-                                          skol_obligation_self_ty));\n+        // If no match, compute result and insert into cache.\n+        let result = self.pick_candidate(stack);\n+        // self.insert_candidate_cache(obligation, skol_obligation_self_ty, result.clone());\n+        result\n+    }\n+\n+    fn pick_candidate(&mut self,\n+                      stack: &ObligationStack)\n+                      -> SelectionResult<Candidate>\n+    {\n+        if ty::type_is_error(stack.skol_obligation_self_ty) {\n+            return Ok(Some(ErrorCandidate));\n+        }\n+\n+        let mut candidates = try!(self.assemble_candidates(stack));\n \n         debug!(\"candidate_from_obligation: {} candidates for {}\",\n-               candidates.len(), obligation.repr(self.tcx()));\n+               candidates.len(),\n+               stack.repr(self.tcx()));\n \n         // Examine candidates to determine outcome. Ideally we will\n         // have exactly one candidate that is definitively applicable.\n@@ -262,14 +344,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // it is possible that one of those unbound variables will\n             // be bound to a new type from some other crate which will\n             // also contain impls.\n-            let trait_ref = &*obligation.trait_ref;\n-            return if !self.trait_ref_unconstrained(trait_ref) {\n-                debug!(\"candidate_from_obligation({}) -> 0 matches, unimpl\",\n-                       obligation.repr(self.tcx()));\n+            return if !self.contains_skolemized_types(stack.skol_obligation_self_ty) {\n+                debug!(\"0 matches, unimpl\");\n                 Err(Unimplemented)\n             } else {\n                 debug!(\"candidate_from_obligation({}) -> 0 matches, ambig\",\n-                       obligation.repr(self.tcx()));\n+                       stack.repr(self.tcx()));\n                 Ok(None)\n             };\n         }\n@@ -279,18 +359,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // information on the potential candidates so we can give\n             // a better error message.\n             debug!(\"candidate_from_obligation({}) -> multiple matches, ambig\",\n-                   obligation.repr(self.tcx()));\n+                   stack.repr(self.tcx()));\n \n             return Ok(None);\n         }\n \n         let candidate = candidates.pop().unwrap();\n-        self.insert_candidate_cache(obligation, skol_obligation_self_ty,\n+        self.insert_candidate_cache(stack.obligation,\n+                                    stack.skol_obligation_self_ty,\n                                     candidate.clone());\n         Ok(Some(candidate))\n     }\n \n-    fn check_candidate_cache(&self,\n+    fn check_candidate_cache(&mut self,\n                              _obligation: &Obligation,\n                              _skol_obligation_self_ty: ty::t)\n                              -> Option<Candidate>\n@@ -302,7 +383,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         None\n     }\n \n-    fn insert_candidate_cache(&self,\n+    fn insert_candidate_cache(&mut self,\n                               _obligation: &Obligation,\n                               _skol_obligation_self_ty: ty::t,\n                               _candidate: Candidate)\n@@ -318,75 +399,64 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         //hashmap.insert(cache_key, candidate);\n     }\n \n-    fn assemble_candidates(&self,\n-                           obligation: &Obligation,\n-                           skol_obligation_self_ty: ty::t)\n+    fn assemble_candidates(&mut self,\n+                           stack: &ObligationStack)\n                            -> Result<Vec<Candidate>, SelectionError>\n     {\n         // Check for overflow.\n \n+        let ObligationStack { obligation, skol_obligation_self_ty, .. } = *stack;\n+\n         let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n         if obligation.recursion_depth >= recursion_limit {\n-            debug!(\"{} --> overflow\", obligation.repr(self.tcx()));\n+            debug!(\"{} --> overflow\", stack.obligation.repr(self.tcx()));\n             return Err(Overflow);\n         }\n \n         let mut candidates = Vec::new();\n \n-        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n-            Some(_) => {\n-                // FIXME -- The treatment of builtin bounds is a bit\n-                // hacky right now. Eventually, the idea is to move\n-                // the logic for selection out of type_contents and\n-                // into this module (And make it based on the generic\n-                // mechanisms of OIBTT2).  However, I want to land\n-                // some code today, so we're going to cut a few\n-                // corners. What we do now is that the trait selection\n-                // code always considers builtin obligations to\n-                // match. The fulfillment code (which also has the job\n-                // of tracking all the traits that must hold) will\n-                // then just accumulate the various\n-                // builtin-bound-related obligations that must be met.\n-                // Later, at the end of typeck, after writeback etc,\n-                // we will rewalk this list and extract all the\n-                // builtin-bound-related obligations and test them\n-                // again using type contents. Part of the motivation\n-                // for this is that the type contents code requires\n-                // that writeback has been completed in some cases.\n-\n-                candidates.push(AmbiguousBuiltinCandidate);\n-            }\n+        // Other bounds. Consider both in-scope bounds from fn decl\n+        // and applicable impls. There is a certain set of precedence rules here.\n \n-            None => {\n-                // Other bounds. Consider both in-scope bounds from fn decl\n-                // and applicable impls.\n-\n-                try!(self.assemble_candidates_from_caller_bounds(\n-                    obligation,\n-                    skol_obligation_self_ty,\n-                    &mut candidates));\n-\n-                try!(self.assemble_unboxed_candidates(\n-                    obligation,\n-                    skol_obligation_self_ty,\n-                    &mut candidates));\n-\n-                // If there is a fn bound that applies, forego the\n-                // impl search. It can only generate conflicts.\n-\n-                if candidates.len() == 0 {\n-                    try!(self.assemble_candidates_from_impls(\n-                        obligation,\n-                        skol_obligation_self_ty,\n-                        &mut candidates));\n+        // Where clauses have highest precedence.\n+        try!(self.assemble_candidates_from_caller_bounds(\n+            obligation,\n+            skol_obligation_self_ty,\n+            &mut candidates));\n+\n+        // In the special case of builtin bounds, consider the \"compiler-supplied\" impls.\n+        if candidates.len() == 0 {\n+            match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n+                Some(bound) => {\n+                    try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n                 }\n+\n+                None => { }\n             }\n         }\n \n+        // In the special case of fn traits and synthesized unboxed\n+        // closure types, consider the compiler-supplied impls. Note\n+        // that this is exclusive with the builtin bound case above.\n+        if candidates.len() == 0 {\n+            try!(self.assemble_unboxed_candidates(\n+                obligation,\n+                skol_obligation_self_ty,\n+                &mut candidates));\n+        }\n+\n+        // Finally, consider the actual impls found in the program.\n+        if candidates.len() == 0 {\n+            try!(self.assemble_candidates_from_impls(\n+                obligation,\n+                skol_obligation_self_ty,\n+                &mut candidates));\n+        }\n+\n         Ok(candidates)\n     }\n \n-    fn assemble_candidates_from_caller_bounds(&self,\n+    fn assemble_candidates_from_caller_bounds(&mut self,\n                                               obligation: &Obligation,\n                                               skol_obligation_self_ty: ty::t,\n                                               candidates: &mut Vec<Candidate>)\n@@ -398,28 +468,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n          * them.\n          *\n          * Never affects inference environment.\n-v         */\n+         */\n \n-        debug!(\"assemble_candidates_from_caller_bounds({})\",\n-               obligation.repr(self.tcx()));\n+        debug!(\"assemble_candidates_from_caller_bounds({}, {})\",\n+               obligation.repr(self.tcx()),\n+               skol_obligation_self_ty.repr(self.tcx()));\n \n         for caller_obligation in self.param_env.caller_obligations.iter() {\n-            debug!(\"caller_obligation={}\",\n-                   caller_obligation.repr(self.tcx()));\n-\n             // Skip over obligations that don't apply to\n             // `self_ty`.\n             let caller_bound = &caller_obligation.trait_ref;\n             let caller_self_ty = caller_bound.substs.self_ty().unwrap();\n+            debug!(\"caller_obligation={}, caller_self_ty={}\",\n+                   caller_obligation.repr(self.tcx()),\n+                   self.infcx.ty_to_string(caller_self_ty));\n             match self.match_self_types(obligation.cause,\n                                         caller_self_ty,\n                                         skol_obligation_self_ty) {\n                 AmbiguousMatch => {\n-                    debug!(\"-> AmbiguousParamCandidate\");\n+                    debug!(\"-> AmbiguousMatch\");\n                     candidates.push(AmbiguousParamCandidate);\n                     return Ok(());\n                 }\n                 NoMatch => {\n+                    debug!(\"-> NoMatch\");\n                     continue;\n                 }\n                 Matched(()) => { }\n@@ -428,26 +500,22 @@ v         */\n             // Search through the trait (and its supertraits) to\n             // see if it matches the def-id we are looking for.\n             let caller_bound = (*caller_bound).clone();\n-            match util::search_trait_and_supertraits_from_bound(\n-                self.infcx.tcx, caller_bound,\n-                |d| d == obligation.trait_ref.def_id)\n-            {\n-                Some(vtable_param) => {\n+            for bound in util::transitive_bounds(self.tcx(), &[caller_bound]) {\n+                debug!(\"-> check bound={}\", bound.repr(self.tcx()));\n+                if bound.def_id == obligation.trait_ref.def_id {\n                     // If so, we're done!\n-                    debug!(\"-> MatchedParamCandidate({})\", vtable_param);\n+                    debug!(\"-> MatchedParamCandidate({})\", bound.repr(self.tcx()));\n+                    let vtable_param = VtableParamData { bound: bound };\n                     candidates.push(MatchedParamCandidate(vtable_param));\n                     return Ok(());\n                 }\n-\n-                None => {\n-                }\n             }\n         }\n \n         Ok(())\n     }\n \n-    fn assemble_unboxed_candidates(&self,\n+    fn assemble_unboxed_candidates(&mut self,\n                                    obligation: &Obligation,\n                                    skol_obligation_self_ty: ty::t,\n                                    candidates: &mut Vec<Candidate>)\n@@ -481,7 +549,7 @@ v         */\n             };\n \n             // Check to see whether the argument and return types match.\n-            let closure_kind = match self.unboxed_closures.find(&closure_def_id) {\n+            let closure_kind = match self.typer.unboxed_closures().borrow().find(&closure_def_id) {\n                 Some(closure) => closure.kind,\n                 None => {\n                     self.tcx().sess.span_bug(\n@@ -501,7 +569,7 @@ v         */\n         Ok(())\n     }\n \n-    fn assemble_candidates_from_impls(&self,\n+    fn assemble_candidates_from_impls(&mut self,\n                                       obligation: &Obligation,\n                                       skol_obligation_self_ty: ty::t,\n                                       candidates: &mut Vec<Candidate>)\n@@ -528,7 +596,7 @@ v         */\n         Ok(())\n     }\n \n-    fn candidate_from_impl(&self,\n+    fn candidate_from_impl(&mut self,\n                            impl_def_id: ast::DefId,\n                            obligation_cause: ObligationCause,\n                            skol_obligation_self_ty: ty::t)\n@@ -551,14 +619,406 @@ v         */\n         }\n     }\n \n+    ///////////////////////////////////////////////////////////////////////////\n+    // BUILTIN BOUNDS\n+    //\n+    // These cover the traits that are built-in to the language\n+    // itself.  This includes `Copy` and `Sized` for sure. For the\n+    // moment, it also includes `Send` / `Sync` and a few others, but\n+    // those will hopefully change to library-defined traits in the\n+    // future.\n+\n+    fn assemble_builtin_bound_candidates(&mut self,\n+                                         bound: ty::BuiltinBound,\n+                                         stack: &ObligationStack,\n+                                         candidates: &mut Vec<Candidate>)\n+                                         -> Result<(),SelectionError>\n+    {\n+        // Copy -- owned, dtor, managed, marker, &mut -- only INTERIOR?\n+        // Sized -- str, [T], Trait -- but only INTERIOR\n+        // Send -- managed data, nonsend annot, borrowed data -- REACHABILITY\n+        // Sync -- non-sync marker trait -- REACHABILITY\n+\n+        // Ideally, we'd only have to examine the immediate fields.\n+        // But think this through carefully I guess.\n+\n+        enum WhenOk<'a> {\n+            Always,\n+            Unknown,\n+            Never,\n+            If(ty::t),\n+            IfAll(&'a [ty::t]),\n+            IfTrue(bool)\n+        }\n+\n+        let ok = |this: &mut SelectionContext, w: WhenOk| {\n+            let r = match w {\n+                Always => EvaluatedToMatch,\n+                Unknown => EvaluatedToAmbiguity,\n+                Never => EvaluatedToUnmatch,\n+                IfTrue(true) => EvaluatedToMatch,\n+                IfTrue(false) => EvaluatedToUnmatch,\n+                If(ty) => this.evaluate_builtin_bound_recursively(bound, stack, ty),\n+                IfAll(tys) => {\n+                    let mut result = EvaluatedToMatch;\n+                    for &ty in tys.iter() {\n+                        match this.evaluate_builtin_bound_recursively(bound, stack, ty) {\n+                            EvaluatedToMatch => { }\n+                            EvaluatedToAmbiguity => {\n+                                result = EvaluatedToAmbiguity;\n+                            }\n+                            EvaluatedToUnmatch => {\n+                                result = EvaluatedToUnmatch;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    result\n+                }\n+            };\n+\n+            match r {\n+                EvaluatedToMatch => Ok(candidates.push(MatchedBuiltinCandidate)),\n+                EvaluatedToAmbiguity => Ok(candidates.push(AmbiguousBuiltinCandidate)),\n+                EvaluatedToUnmatch => Err(Unimplemented)\n+            }\n+        };\n+\n+        return match ty::get(stack.skol_obligation_self_ty).sty {\n+            ty::ty_uint(_) | ty::ty_int(_) | ty::ty_infer(ty::SkolemizedIntTy(_)) |\n+            ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_float(_) |\n+            ty::ty_bare_fn(_) | ty::ty_char => {\n+                // safe for everything\n+                ok(self, Always)\n+            }\n+\n+            ty::ty_box(_) => {\n+                match bound {\n+                    ty::BoundSync |\n+                    ty::BoundSend |\n+                    ty::BoundCopy => {\n+                        // Managed data is not copyable, sendable, nor\n+                        // synchronized, regardless of referent.\n+                        ok(self, Never)\n+                    }\n+\n+                    ty::BoundSized => {\n+                        // But it is sized, regardless of referent.\n+                        ok(self, Always)\n+                    }\n+                }\n+            }\n+\n+            ty::ty_uniq(referent_ty) => {  // Box<T>\n+                match bound {\n+                    ty::BoundCopy => {\n+                        ok(self, Never)\n+                    }\n+\n+                    ty::BoundSized => {\n+                        ok(self, Always)\n+                    }\n+\n+                    ty::BoundSync |\n+                    ty::BoundSend => {\n+                        ok(self, If(referent_ty))\n+                    }\n+                }\n+            }\n+\n+            ty::ty_ptr(ty::mt { ty: referent_ty, .. }) => {     // *const T, *mut T\n+                match bound {\n+                    ty::BoundCopy |\n+                    ty::BoundSized => {\n+                        ok(self, Always)\n+                    }\n+\n+                    ty::BoundSync |\n+                    ty::BoundSend => {\n+                        ok(self, If(referent_ty))\n+                    }\n+                }\n+            }\n+\n+            ty::ty_closure(ref c) => {\n+                match c.store {\n+                    ty::UniqTraitStore => {\n+                        // proc: Equivalent to `Box<FnOnce>`\n+                        match bound {\n+                            ty::BoundCopy => {\n+                                ok(self, Never)\n+                            }\n+\n+                            ty::BoundSized => {\n+                                ok(self, Always)\n+                            }\n+\n+                            ty::BoundSync |\n+                            ty::BoundSend => {\n+                                ok(self, IfTrue(c.bounds.builtin_bounds.contains_elem(bound)))\n+                            }\n+                        }\n+                    }\n+                    ty::RegionTraitStore(_, mutbl) => {\n+                        // ||: Equivalent to `&FnMut` or `&mut FnMut` or something like that.\n+                        match bound {\n+                            ty::BoundCopy => {\n+                                ok(self, match mutbl {\n+                                    ast::MutMutable => Never,  // &mut T is affine\n+                                    ast::MutImmutable => Always,  // &T is copyable\n+                                })\n+                            }\n+\n+                            ty::BoundSized => {\n+                                ok(self, Always)\n+                            }\n+\n+                            ty::BoundSync |\n+                            ty::BoundSend => {\n+                                ok(self, IfTrue(c.bounds.builtin_bounds.contains_elem(bound)))\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ty::ty_trait(box ty::TyTrait { bounds, .. }) => {\n+                match bound {\n+                    ty::BoundSized => {\n+                        ok(self, Never)\n+                    }\n+                    ty::BoundCopy | ty::BoundSync | ty::BoundSend => {\n+                        ok(self, IfTrue(bounds.builtin_bounds.contains_elem(bound)))\n+                    }\n+                }\n+            }\n+\n+            ty::ty_rptr(_, ty::mt { ty: referent_ty, mutbl: mutbl }) => {\n+                // &mut T or &T\n+                match bound {\n+                    ty::BoundCopy => {\n+                        ok(self, match mutbl {\n+                            ast::MutMutable => Never,  // &mut T is affine and hence never `Copy`\n+                            ast::MutImmutable => Always,  // &T is copyable\n+                        })\n+                    }\n+\n+                    ty::BoundSized => {\n+                        ok(self, Always)\n+                    }\n+\n+                    ty::BoundSync |\n+                    ty::BoundSend => {\n+                        // Note: technically, a region pointer is only\n+                        // sendable if it has lifetime\n+                        // `'static`. However, we don't take regions\n+                        // into account when doing trait matching:\n+                        // instead, when we decide that `T : Send`, we\n+                        // will register a separate constraint with\n+                        // the region inferencer that `T : 'static`\n+                        // holds as well (because the trait `Send`\n+                        // requires it). This will ensure that there\n+                        // is no borrowed data in `T` (or else report\n+                        // an inference error). The reason we do it\n+                        // this way is that we do not yet *know* what\n+                        // lifetime the borrowed reference has, since\n+                        // we haven't finished running inference -- in\n+                        // other words, there's a kind of\n+                        // chicken-and-egg problem.\n+                        ok(self, If(referent_ty))\n+                    }\n+                }\n+            }\n+\n+            ty::ty_vec(element_ty, ref len) => {\n+                // [T, ..n] and [T]\n+                match bound {\n+                    ty::BoundCopy => {\n+                        match *len {\n+                            Some(_) => ok(self, If(element_ty)), // [T, ..n] is copy iff T is copy\n+                            None => ok(self, Never), // [T] is unsized and hence affine\n+                        }\n+                    }\n+\n+                    ty::BoundSized => {\n+                        ok(self, IfTrue(len.is_some()))\n+                    }\n+\n+                    ty::BoundSync |\n+                    ty::BoundSend => {\n+                        ok(self, If(element_ty))\n+                    }\n+                }\n+            }\n+\n+            ty::ty_str => {\n+                // Equivalent to [u8]\n+                match bound {\n+                    ty::BoundSync |\n+                    ty::BoundSend => {\n+                        ok(self, Always)\n+                    }\n+\n+                    ty::BoundCopy |\n+                    ty::BoundSized => {\n+                        ok(self, Never)\n+                    }\n+                }\n+            }\n+\n+            ty::ty_tup(ref tys) => {\n+                // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n+                ok(self, IfAll(tys.as_slice()))\n+            }\n+\n+            ty::ty_unboxed_closure(def_id, _) => {\n+                // FIXME -- This case is tricky. In the case of by-ref\n+                // closures particularly, we need the results of\n+                // inference to decide how to reflect the type of each\n+                // upvar (the upvar may have type `T`, but the runtime\n+                // type could be `&mut`, `&`, or just `T`). For now,\n+                // though, we'll do this unsoundly and assume that all\n+                // captures are by value. Really what we ought to do\n+                // is reserve judgement and then intertwine this\n+                // analysis with closure inference.\n+                //\n+                // FIXME -- this is wrong with respect to\n+                // skolemization. We want to skolemize the types of\n+                // the variables, but to do THAT we need the ability\n+                // to \"start\" the skolemization numbering from a\n+                // higher point. Perhaps this just means creating a\n+                // single skolemizer and then using it again here?\n+                assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+                match self.tcx().freevars.borrow().find(&def_id.node) {\n+                    None => {\n+                        // No upvars.\n+                        ok(self, Always)\n+                    }\n+\n+                    Some(freevars) => {\n+                        let tys: Vec<ty::t> =\n+                            freevars\n+                            .iter()\n+                            .map(|freevar| {\n+                                let freevar_def_id = freevar.def.def_id();\n+                                let freevar_ty = self.typer.node_ty(freevar_def_id.node)\n+                                    .unwrap_or(ty::mk_err());\n+                                freevar_ty.fold_with(&mut self.skolemizer)\n+                            })\n+                            .collect();\n+                        ok(self, IfAll(tys.as_slice()))\n+                    }\n+                }\n+            }\n+\n+            ty::ty_struct(def_id, ref substs) => {\n+                let types: Vec<ty::t> =\n+                    ty::struct_fields(self.tcx(), def_id, substs)\n+                    .iter()\n+                    .map(|f| f.mt.ty)\n+                    .collect();\n+                nominal(self, bound, def_id, types, ok)\n+            }\n+\n+            ty::ty_enum(def_id, ref substs) => {\n+                let types: Vec<ty::t> =\n+                    ty::substd_enum_variants(self.tcx(), def_id, substs)\n+                    .iter()\n+                    .flat_map(|variant| variant.args.iter())\n+                    .map(|&ty| ty)\n+                    .collect();\n+                nominal(self, bound, def_id, types, ok)\n+            }\n+\n+            ty::ty_param(_) => {\n+                // Note: A type parameter is only considered to meet a\n+                // particular bound if there is a where clause telling\n+                // us that it does, and that case is handled by\n+                // `assemble_candidates_from_caller_bounds()`.\n+                ok(self, Never)\n+            }\n+\n+            ty::ty_infer(ty::SkolemizedTy(_)) => {\n+                // Skolemized types represent unbound type\n+                // variables. They might or might not have applicable\n+                // impls and so forth, depending on what those type\n+                // variables wind up being bound to.\n+                ok(self, Unknown)\n+            }\n+\n+            ty::ty_open(_) |\n+            ty::ty_infer(ty::TyVar(_)) |\n+            ty::ty_infer(ty::IntVar(_)) |\n+            ty::ty_infer(ty::FloatVar(_)) |\n+            ty::ty_err => {\n+                self.tcx().sess.span_bug(\n+                    stack.obligation.cause.span,\n+                    format!(\n+                        \"asked to compute contents of unexpected type: {}\",\n+                        stack.skol_obligation_self_ty.repr(self.tcx())).as_slice());\n+            }\n+        };\n+\n+        fn nominal(this: &mut SelectionContext,\n+                   bound: ty::BuiltinBound,\n+                   def_id: ast::DefId,\n+                   types: Vec<ty::t>,\n+                   ok: |&mut SelectionContext, WhenOk| -> Result<(),SelectionError>)\n+                   -> Result<(),SelectionError>\n+        {\n+            // First check for markers and other nonsense.\n+            let tcx = this.tcx();\n+            match bound {\n+                ty::BoundSend => {\n+                    if\n+                        Some(def_id) == tcx.lang_items.no_send_bound() ||\n+                        Some(def_id) == tcx.lang_items.managed_bound()\n+                    {\n+                        return ok(this, Never);\n+                    }\n+                }\n+\n+                ty::BoundCopy => {\n+                    if\n+                        Some(def_id) == tcx.lang_items.no_copy_bound() ||\n+                        Some(def_id) == tcx.lang_items.managed_bound() ||\n+                        ty::has_dtor(tcx, def_id)\n+                    {\n+                        return ok(this, Never);\n+                    }\n+                }\n+\n+                ty::BoundSync => {\n+                    if\n+                        Some(def_id) == tcx.lang_items.no_sync_bound() ||\n+                        Some(def_id) == tcx.lang_items.managed_bound()\n+                    {\n+                        return ok(this, Never);\n+                    } else if\n+                        Some(def_id) == tcx.lang_items.unsafe_type()\n+                    {\n+                        // FIXME(#13231) -- we currently consider `UnsafeCell<T>`\n+                        // to always be sync. This is allow for types like `Queue`\n+                        // and `Mutex`, where `Queue<T> : Sync` is `T : Send`.\n+                        return ok(this, Always);\n+                    }\n+                }\n+\n+                ty::BoundSized => { }\n+            }\n+\n+            ok(this, IfAll(types.as_slice()))\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // CONFIRMATION\n     //\n     // Confirmation unifies the output type parameters of the trait\n     // with the values found in the obligation, possibly yielding a\n     // type error.  See `doc.rs` for more details.\n \n-    fn confirm_candidate(&self,\n+    fn confirm_candidate(&mut self,\n                          obligation: &Obligation,\n                          candidate: Candidate)\n                          -> SelectionResult<Selection>\n@@ -574,6 +1034,7 @@ v         */\n                 Ok(None)\n             }\n \n+            ErrorCandidate |\n             MatchedBuiltinCandidate => {\n                 Ok(Some(VtableBuiltin))\n             }\n@@ -596,7 +1057,7 @@ v         */\n         }\n     }\n \n-    fn confirm_param_candidate(&self,\n+    fn confirm_param_candidate(&mut self,\n                                obligation: &Obligation,\n                                param: VtableParamData)\n                                -> Result<VtableParamData,SelectionError>\n@@ -611,7 +1072,7 @@ v         */\n         Ok(param)\n     }\n \n-    fn confirm_impl_candidate(&self,\n+    fn confirm_impl_candidate(&mut self,\n                               obligation: &Obligation,\n                               impl_def_id: ast::DefId)\n                               -> Result<VtableImplData<Obligation>,SelectionError>\n@@ -638,7 +1099,7 @@ v         */\n         Ok(vtable_impl)\n     }\n \n-    fn confirm_inherent_impl_candidate(&self,\n+    fn confirm_inherent_impl_candidate(&mut self,\n                                        impl_def_id: ast::DefId,\n                                        obligation_cause: ObligationCause,\n                                        obligation_self_ty: ty::t,\n@@ -671,7 +1132,7 @@ v         */\n         Ok(vtable_impl)\n     }\n \n-    fn confirm_unboxed_closure_candidate(&self,\n+    fn confirm_unboxed_closure_candidate(&mut self,\n                                          obligation: &Obligation,\n                                          closure_def_id: ast::DefId)\n                                          -> Result<(),SelectionError>\n@@ -680,7 +1141,7 @@ v         */\n                obligation.repr(self.tcx()),\n                closure_def_id.repr(self.tcx()));\n \n-        let closure_type = match self.unboxed_closures.find(&closure_def_id) {\n+        let closure_type = match self.typer.unboxed_closures().borrow().find(&closure_def_id) {\n             Some(closure) => closure.closure_type.clone(),\n             None => {\n                 self.tcx().sess.span_bug(\n@@ -724,7 +1185,7 @@ v         */\n     // run inside of a `probe()` so that their side-effects are\n     // contained.\n \n-    fn match_impl_self_types(&self,\n+    fn match_impl_self_types(&mut self,\n                              impl_def_id: ast::DefId,\n                              obligation_cause: ObligationCause,\n                              obligation_self_ty: ty::t)\n@@ -776,7 +1237,7 @@ v         */\n         }\n     }\n \n-    fn match_self_types(&self,\n+    fn match_self_types(&mut self,\n                         cause: ObligationCause,\n \n                         // The self type provided by the impl/caller-obligation:\n@@ -821,7 +1282,7 @@ v         */\n     // the output type parameters from the obligation with those found\n     // on the impl/bound, which may yield type errors.\n \n-    fn confirm_impl_vtable(&self,\n+    fn confirm_impl_vtable(&mut self,\n                            impl_def_id: ast::DefId,\n                            obligation_cause: ObligationCause,\n                            obligation_trait_ref: Rc<ty::TraitRef>,\n@@ -851,7 +1312,7 @@ v         */\n         self.confirm(obligation_cause, obligation_trait_ref, impl_trait_ref)\n     }\n \n-    fn confirm(&self,\n+    fn confirm(&mut self,\n                obligation_cause: ObligationCause,\n                obligation_trait_ref: Rc<ty::TraitRef>,\n                expected_trait_ref: Rc<ty::TraitRef>)\n@@ -898,6 +1359,32 @@ v         */\n     ///////////////////////////////////////////////////////////////////////////\n     // Miscellany\n \n+    fn new_stack<'o>(&mut self, obligation: &'o Obligation) -> ObligationStack<'o> {\n+        let skol_obligation_self_ty =\n+            obligation.self_ty().fold_with(&mut self.skolemizer);\n+\n+        ObligationStack {\n+            obligation: obligation,\n+            skol_obligation_self_ty: skol_obligation_self_ty,\n+            previous: None\n+        }\n+    }\n+\n+    fn push_stack<'o>(&self,\n+                      previous_stack: &'o ObligationStack<'o>,\n+                      obligation: &'o Obligation)\n+                      -> ObligationStack<'o>\n+    {\n+        // No need to skolemize obligation.self_ty, because we\n+        // guarantee the self-type for all recursive obligations are\n+        // already skolemized.\n+        ObligationStack {\n+            obligation: obligation,\n+            skol_obligation_self_ty: obligation.self_ty(),\n+            previous: Some(previous_stack)\n+        }\n+    }\n+\n     fn all_impls(&self, trait_def_id: ast::DefId) -> Vec<ast::DefId> {\n         /*!\n          * Returns se tof all impls for a given trait.\n@@ -924,22 +1411,17 @@ v         */\n                                        &impl_generics, impl_substs)\n     }\n \n-    fn trait_ref_unconstrained(&self,\n-                               trait_ref: &ty::TraitRef)\n-                               -> bool\n+    fn contains_skolemized_types(&self,\n+                                 ty: ty::t)\n+                                 -> bool\n     {\n         /*!\n-         * True if the self type of the trait-ref contains\n-         * unconstrained type variables.\n+         * True if the type contains skolemized variables.\n          */\n \n         let mut found_skol = false;\n \n-        // Skolemization replaces all unconstrained type vars with\n-        // a SkolemizedTy instance. Then we search to see if we\n-        // found any.\n-        let skol_ty = infer::skolemize(self.infcx, trait_ref.self_ty());\n-        ty::walk_ty(skol_ty, |t| {\n+        ty::walk_ty(ty, |t| {\n             match ty::get(t).sty {\n                 ty::ty_infer(ty::SkolemizedTy(_)) => { found_skol = true; }\n                 _ => { }\n@@ -955,6 +1437,7 @@ impl Candidate {\n         match *self {\n             Impl(ref i) => i.to_evaluation_result(),\n \n+            ErrorCandidate |\n             MatchedUnboxedClosureCandidate(..) |\n             MatchedBuiltinCandidate |\n             MatchedParamCandidate(..) => {\n@@ -981,6 +1464,7 @@ impl ImplCandidate {\n impl Repr for Candidate {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n+            ErrorCandidate => format!(\"ErrorCandidate\"),\n             MatchedBuiltinCandidate => format!(\"MatchedBuiltinCandidate\"),\n             AmbiguousBuiltinCandidate => format!(\"AmbiguousBuiltinCandidate\"),\n             MatchedUnboxedClosureCandidate(c) => format!(\"MatchedUnboxedClosureCandidate({})\", c),\n@@ -1003,6 +1487,33 @@ impl Repr for ImplCandidate {\n     }\n }\n \n+impl<'o> ObligationStack<'o> {\n+    fn iter(&self) -> Option<&ObligationStack> {\n+        Some(self)\n+    }\n+}\n+\n+impl<'o> Iterator<&'o ObligationStack<'o>> for Option<&'o ObligationStack<'o>> {\n+    fn next(&mut self) -> Option<&'o ObligationStack<'o>> {\n+        match *self {\n+            Some(o) => {\n+                *self = o.previous;\n+                Some(o)\n+            }\n+            None => {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+impl<'o> Repr for ObligationStack<'o> {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"ObligationStack({}, {})\",\n+                self.obligation.repr(tcx),\n+                self.skol_obligation_self_ty.repr(tcx))\n+    }\n+}\n \n // impl SelectionCache {\n //     pub fn new() -> SelectionCache {"}, {"sha": "cad86003ce9dd920356263640e16172f875a0ba4", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -13,6 +13,7 @@ use middle::subst;\n use middle::subst::{ParamSpace, Subst, Substs, VecPerParamSpace};\n use middle::typeck::infer::InferCtxt;\n use middle::ty;\n+use std::collections::HashSet;\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -27,6 +28,7 @@ use super::{Obligation, ObligationCause, VtableImpl, VtableParam, VtableParamDat\n pub struct Supertraits<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n     stack: Vec<SupertraitEntry>,\n+    visited: HashSet<Rc<ty::TraitRef>>,\n }\n \n struct SupertraitEntry {\n@@ -62,15 +64,34 @@ pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n                                     -> Supertraits<'cx, 'tcx>\n {\n     let bounds = Vec::from_fn(bounds.len(), |i| bounds[i].clone());\n+\n+    let visited: HashSet<Rc<ty::TraitRef>> =\n+        bounds.iter()\n+              .map(|b| (*b).clone())\n+              .collect();\n+\n     let entry = SupertraitEntry { position: 0, supertraits: bounds };\n-    Supertraits { tcx: tcx, stack: vec![entry] }\n+    Supertraits { tcx: tcx, stack: vec![entry], visited: visited }\n }\n \n impl<'cx, 'tcx> Supertraits<'cx, 'tcx> {\n     fn push(&mut self, trait_ref: &ty::TraitRef) {\n-        let bounds = ty::bounds_for_trait_ref(self.tcx, trait_ref);\n-        let entry = SupertraitEntry { position: 0,\n-                                      supertraits: bounds.trait_bounds };\n+        let ty::ParamBounds { builtin_bounds, mut trait_bounds, .. } =\n+            ty::bounds_for_trait_ref(self.tcx, trait_ref);\n+        for builtin_bound in builtin_bounds.iter() {\n+            let bound_trait_ref = trait_ref_for_builtin_bound(self.tcx,\n+                                                              builtin_bound,\n+                                                              trait_ref.self_ty());\n+            trait_bounds.push(bound_trait_ref);\n+        }\n+\n+        // Only keep those bounds that we haven't already seen.  This\n+        // is necessary to prevent infinite recursion in some cases.\n+        // One common case is when people define `trait Sized { }`\n+        // rather than `trait Sized for Sized? { }`.\n+        trait_bounds.retain(|r| self.visited.insert((*r).clone()));\n+\n+        let entry = SupertraitEntry { position: 0, supertraits: trait_bounds };\n         self.stack.push(entry);\n     }\n \n@@ -211,31 +232,41 @@ fn push_obligations_for_param_bounds(\n     }\n }\n \n-pub fn obligation_for_builtin_bound(\n+pub fn trait_ref_for_builtin_bound(\n     tcx: &ty::ctxt,\n-    cause: ObligationCause,\n     builtin_bound: ty::BuiltinBound,\n-    recursion_depth: uint,\n     param_ty: ty::t)\n-    -> Obligation\n+    -> Rc<ty::TraitRef>\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n-            Obligation {\n-                cause: cause,\n-                recursion_depth: recursion_depth,\n-                trait_ref: Rc::new(ty::TraitRef {\n-                    def_id: def_id,\n-                    substs: Substs::empty().with_self_ty(param_ty),\n-                }),\n-            }\n+            Rc::new(ty::TraitRef {\n+                def_id: def_id,\n+                substs: Substs::empty().with_self_ty(param_ty)\n+            })\n         }\n         Err(e) => {\n-            tcx.sess.span_bug(cause.span, e.as_slice());\n+            tcx.sess.bug(e.as_slice());\n         }\n     }\n }\n \n+pub fn obligation_for_builtin_bound(\n+    tcx: &ty::ctxt,\n+    cause: ObligationCause,\n+    builtin_bound: ty::BuiltinBound,\n+    recursion_depth: uint,\n+    param_ty: ty::t)\n+    -> Obligation\n+{\n+    let trait_ref = trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty);\n+    Obligation {\n+        cause: cause,\n+        recursion_depth: recursion_depth,\n+        trait_ref: trait_ref\n+    }\n+}\n+\n pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n                                                caller_bound: Rc<ty::TraitRef>,\n                                                test: |ast::DefId| -> bool)"}, {"sha": "30f91c82930e331097cfa72e236f96d02ea709ef", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -31,6 +31,7 @@ use middle::trans::type_of;\n use middle::traits;\n use middle::ty;\n use middle::ty_fold;\n+use middle::ty_fold::TypeFoldable;\n use middle::typeck;\n use middle::typeck::infer;\n use util::ppaux::Repr;\n@@ -791,12 +792,10 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n     // Parameter environment is used to give details about type parameters,\n     // but since we are in trans, everything is fully monomorphized.\n     let param_env = ty::empty_parameter_environment();\n-    let unboxed_closures = tcx.unboxed_closures.borrow();\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let selcx = traits::SelectionContext::new(&infcx, &param_env,\n-                                              &*unboxed_closures);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &param_env, tcx);\n     let obligation = traits::Obligation::misc(span, trait_ref.clone());\n     let selection = match selcx.select(&obligation) {\n         Ok(Some(selection)) => selection,\n@@ -825,7 +824,7 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n     let vtable = selection.map_move_nested(|obligation| {\n         fulfill_cx.register_obligation(tcx, obligation);\n     });\n-    match fulfill_cx.select_all_or_error(&infcx, &param_env, &*unboxed_closures) {\n+    match fulfill_cx.select_all_or_error(&infcx, &param_env, tcx) {\n         Ok(()) => { }\n         Err(e) => {\n             tcx.sess.span_bug(\n@@ -841,7 +840,7 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n     // sort of overkill because we do not expect there to be any\n     // unbound type variables, hence no skolemized types should ever\n     // be inserted.\n-    let vtable = infer::skolemize(&infcx, vtable);\n+    let vtable = vtable.fold_with(&mut infcx.skolemizer());\n \n     info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n     ccx.trait_cache().borrow_mut().insert(trait_ref,"}, {"sha": "85c43f3f281141d28837b3faa50ff12eafa93491", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -561,6 +561,9 @@ pub fn get_vtable(bcx: Block,\n                                         DUMMY_SP,\n                                         trait_ref.clone());\n         match vtable {\n+            traits::VtableBuiltin => {\n+                Vec::new().into_iter()\n+            }\n             traits::VtableImpl(\n                 traits::VtableImplData {\n                     impl_def_id: id,\n@@ -634,7 +637,6 @@ pub fn get_vtable(bcx: Block,\n \n                 (vec!(llfn)).into_iter()\n             }\n-            traits::VtableBuiltin |\n             traits::VtableParam(..) => {\n                 bcx.sess().bug(\n                     format!(\"resolved vtable for {} to bad vtable {} in trans\","}, {"sha": "9009644eb0cc99a2c73c3b531a84f8e5c753eca0", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -298,30 +298,29 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         self.ccx.tcx\n     }\n     fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t> {\n-        self.ccx.tcx.node_ty(id)\n+        Ok(self.node_ty(id))\n     }\n     fn node_method_ty(&self, method_call: typeck::MethodCall)\n                       -> Option<ty::t> {\n-        self.ccx.tcx.node_method_ty(method_call)\n+        self.inh.method_map.borrow().find(&method_call).map(|m| m.ty)\n     }\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n-        self.ccx.tcx.adjustments()\n+        &self.inh.adjustments\n     }\n     fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.ccx.tcx.is_method_call(id)\n+        self.inh.method_map.borrow().contains_key(&typeck::MethodCall::expr(id))\n     }\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId> {\n-        self.ccx.tcx.temporary_scope(rvalue_id)\n+        self.tcx().temporary_scope(rvalue_id)\n     }\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.ccx.tcx.upvar_borrow(upvar_id)\n+        self.inh.upvar_borrow_map.borrow().get_copy(&upvar_id)\n     }\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n         self.ccx.tcx.capture_mode(closure_expr_id)\n     }\n-    fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure>> {\n+    fn unboxed_closures<'a>(&'a self) -> &'a RefCell<DefIdMap<ty::UnboxedClosure>> {\n         &self.inh.unboxed_closures\n     }\n }\n@@ -435,7 +434,6 @@ fn check_bare_fn(ccx: &CrateCtxt,\n             vtable2::select_all_fcx_obligations_or_error(&fcx);\n             regionck::regionck_fn(&fcx, id, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n-            vtable2::check_builtin_bound_obligations(&fcx); // must happen after writeback\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n                                  \"check_bare_fn: function type expected\")\n@@ -4866,7 +4864,6 @@ pub fn check_const_with_ty(fcx: &FnCtxt,\n     vtable2::select_all_fcx_obligations_or_error(fcx);\n     regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n-    vtable2::check_builtin_bound_obligations(fcx);\n }\n \n /// Checks whether a type can be represented in memory. In particular, it"}, {"sha": "63a17cec5751f1f643b7018f8a64b6efd7c6a1e1", "filename": "src/librustc/middle/typeck/check/vtable2.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -186,32 +186,15 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     debug!(\"select_all_fcx_obligations_or_error\");\n \n     let mut fulfillment_cx = fcx.inh.fulfillment_cx.borrow_mut();\n-    let r =\n-        fulfillment_cx.select_all_or_error(\n-            fcx.infcx(),\n-            &fcx.inh.param_env,\n-            &*fcx.inh.unboxed_closures.borrow());\n+    let r = fulfillment_cx.select_all_or_error(fcx.infcx(),\n+                                               &fcx.inh.param_env,\n+                                               fcx);\n     match r {\n         Ok(()) => { }\n         Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n     }\n }\n \n-pub fn check_builtin_bound_obligations(fcx: &FnCtxt) {\n-    /*!\n-     * Hacky second pass to check builtin-bounds obligations *after*\n-     * writeback occurs.\n-     */\n-\n-    match\n-        fcx.inh.fulfillment_cx.borrow()\n-                              .check_builtin_bound_obligations(fcx.infcx())\n-    {\n-        Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n-    }\n-}\n-\n fn resolve_trait_ref(fcx: &FnCtxt, obligation: &Obligation)\n                      -> (ty::TraitRef, ty::t)\n {\n@@ -244,7 +227,8 @@ pub fn report_fulfillment_error(fcx: &FnCtxt,\n \n pub fn report_selection_error(fcx: &FnCtxt,\n                               obligation: &Obligation,\n-                              error: &SelectionError) {\n+                              error: &SelectionError)\n+{\n     match *error {\n         Unimplemented => {\n             let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n@@ -309,15 +293,31 @@ pub fn maybe_report_ambiguity(fcx: &FnCtxt, obligation: &Obligation) {\n            obligation.repr(fcx.tcx()));\n     if ty::type_is_error(self_ty) {\n     } else if ty::type_needs_infer(self_ty) {\n-        fcx.tcx().sess.span_err(\n-            obligation.cause.span,\n-            format!(\n-                \"unable to infer enough type information to \\\n-             locate the impl of the trait `{}` for \\\n-             the type `{}`; type annotations required\",\n-            trait_ref.user_string(fcx.tcx()),\n-            self_ty.user_string(fcx.tcx())).as_slice());\n-        note_obligation_cause(fcx, obligation);\n+        // This is kind of a hack: it frequently happens that some earlier\n+        // error prevents types from being fully inferred, and then we get\n+        // a bunch of uninteresting errors saying something like \"<generic\n+        // #0> doesn't implement Sized\".  It may even be true that we\n+        // could just skip over all checks where the self-ty is an\n+        // inference variable, but I was afraid that there might be an\n+        // inference variable created, registered as an obligation, and\n+        // then never forced by writeback, and hence by skipping here we'd\n+        // be ignoring the fact that we don't KNOW the type works\n+        // out. Though even that would probably be harmless, given that\n+        // we're only talking about builtin traits, which are known to be\n+        // inhabited. But in any case I just threw in this check for\n+        // has_errors() to be sure that compilation isn't happening\n+        // anyway. In that case, why inundate the user.\n+        if !fcx.tcx().sess.has_errors() {\n+            fcx.tcx().sess.span_err(\n+                obligation.cause.span,\n+                format!(\n+                    \"unable to infer enough type information to \\\n+                     locate the impl of the trait `{}` for \\\n+                     the type `{}`; type annotations required\",\n+                    trait_ref.user_string(fcx.tcx()),\n+                    self_ty.user_string(fcx.tcx())).as_slice());\n+            note_obligation_cause(fcx, obligation);\n+        }\n     } else if fcx.tcx().sess.err_count() == 0 {\n          // Ambiguity. Coherence should have reported an error.\n         fcx.tcx().sess.span_bug(\n@@ -337,9 +337,7 @@ pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt) {\n     match\n         fcx.inh.fulfillment_cx\n         .borrow_mut()\n-        .select_where_possible(fcx.infcx(),\n-                               &fcx.inh.param_env,\n-                               &*fcx.inh.unboxed_closures.borrow())\n+        .select_where_possible(fcx.infcx(), &fcx.inh.param_env, fcx)\n     {\n         Ok(()) => { }\n         Err(errors) => { report_fulfillment_errors(fcx, &errors); }"}, {"sha": "6a63464c4b6e8913e29c1fa030dd0c53406a44a9", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -110,7 +110,6 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         f(self, &fcx);\n         vtable2::select_all_fcx_obligations_or_error(&fcx);\n         regionck::regionck_item(&fcx, item);\n-        vtable2::check_builtin_bound_obligations(&fcx);\n     }\n \n     fn check_type_defn(&mut self,"}, {"sha": "c36192777f0a98c7caa4f88111d6a5df57d723da", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -13,20 +13,20 @@\n #![allow(non_camel_case_types)]\n \n pub use middle::ty::IntVarValue;\n-pub use middle::typeck::infer::resolve::resolve_and_force_all_but_regions;\n-pub use middle::typeck::infer::resolve::{force_all, not_regions};\n-pub use middle::typeck::infer::resolve::{force_ivar};\n-pub use middle::typeck::infer::resolve::{force_tvar, force_rvar};\n-pub use middle::typeck::infer::resolve::{resolve_ivar, resolve_all};\n-pub use middle::typeck::infer::resolve::{resolve_nested_tvar};\n-pub use middle::typeck::infer::resolve::{resolve_rvar};\n+pub use self::resolve::resolve_and_force_all_but_regions;\n+pub use self::resolve::{force_all, not_regions};\n+pub use self::resolve::{force_ivar};\n+pub use self::resolve::{force_tvar, force_rvar};\n+pub use self::resolve::{resolve_ivar, resolve_all};\n+pub use self::resolve::{resolve_nested_tvar};\n+pub use self::resolve::{resolve_rvar};\n+pub use self::skolemize::TypeSkolemizer;\n \n use middle::subst;\n use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n use middle::ty;\n use middle::ty_fold;\n-use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::coercion::Coerce;\n@@ -382,13 +382,6 @@ pub fn verify_param_bound(cx: &InferCtxt,\n     cx.region_vars.verify_param_bound(origin, param_ty, a, bs);\n }\n \n-pub fn skolemize<T:TypeFoldable+Repr>(cx: &InferCtxt, a: T) -> T {\n-    let mut skol = skolemize::TypeSkolemizer::new(cx);\n-    let b = a.fold_with(&mut skol);\n-    debug!(\"skol(a={}) -> {}\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    b\n-}\n-\n pub fn mk_eqty(cx: &InferCtxt,\n                a_is_expected: bool,\n                origin: TypeOrigin,\n@@ -513,6 +506,10 @@ pub struct CombinedSnapshot {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    pub fn skolemizer<'a>(&'a self) -> TypeSkolemizer<'a, 'tcx> {\n+        skolemize::TypeSkolemizer::new(self)\n+    }\n+\n     pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace)\n                               -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,"}, {"sha": "4002f5984497b8899301d52dcea39fe20fb93787", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -119,9 +119,16 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n                 self.probe_unifiable(v)\n             }\n \n-            ty::ty_infer(ty::SkolemizedTy(_)) |\n-            ty::ty_infer(ty::SkolemizedIntTy(_)) => {\n-                self.tcx().sess.bug(\"Cannot skolemize a skolemized type\");\n+            ty::ty_infer(ty::SkolemizedTy(c)) |\n+            ty::ty_infer(ty::SkolemizedIntTy(c)) => {\n+                if c >= self.skolemization_count {\n+                    self.tcx().sess.bug(\n+                        format!(\"Encountered a skolemized type with id {} \\\n+                                 but our counter is only at {}\",\n+                                c,\n+                                self.skolemization_count).as_slice());\n+                }\n+                t\n             }\n \n             ty::ty_open(..) => {"}, {"sha": "356d95452b3e1788789d9acfcdedd8b038479455", "filename": "src/test/compile-fail/issue-12187-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -14,5 +14,5 @@ fn new<T>() -> &'static T {\n \n fn main() {\n     let &v = new();\n-    //~^ ERROR cannot determine a type for this local variable: unconstrained type\n+    //~^ ERROR type annotations required\n }"}, {"sha": "a67d9dee9768f206e9e0ed6e9c1632f5c969b4c3", "filename": "src/test/compile-fail/issue-12187-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -14,5 +14,5 @@ fn new<'r, T>() -> &'r T {\n \n fn main() {\n     let &v = new();\n-    //~^ ERROR cannot determine a type for this local variable: unconstrained type\n+    //~^ ERROR type annotations required\n }"}, {"sha": "4512eb3f70aceeca7ac618493259cfa83192364b", "filename": "src/test/compile-fail/issue-14915.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -15,8 +15,5 @@ fn main() {\n     let y: Gc<int> = box (GC) 0;\n \n     println!(\"{}\", x + 1); //~ ERROR binary operation `+` cannot be applied to type `Box<int>`\n-    //~^ ERROR unable to infer enough type information\n-    println!(\"{}\", y + 1);\n-    //~^ ERROR binary operation `+` cannot be applied to type `Gc<int>`\n-    //~^^ ERROR unable to infer enough type information\n+    println!(\"{}\", y + 1); //~ ERROR binary operation `+` cannot be applied to type `Gc<int>`\n }"}, {"sha": "df888fe78021bf9d3c804a5349c6786860ec5ddf", "filename": "src/test/compile-fail/issue-5062.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -10,4 +10,5 @@\n \n extern crate debug;\n \n-fn main() { format!(\"{:?}\", None); } //~ ERROR unconstrained type\n+fn main() { format!(\"{:?}\", None); }\n+    //~^ ERROR type annotations required"}, {"sha": "cb3ffae5dbae3df047b03159c3daeed3e38a0259", "filename": "src/test/compile-fail/issue-6458-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-6458-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-6458-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-1.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -9,4 +9,5 @@\n // except according to those terms.\n \n fn foo<T>(t: T) {}\n-fn main() { foo(fail!()) } //~ ERROR cannot determine a type for this expression: unconstrained type\n+fn main() { foo(fail!()) }\n+    //~^ ERROR type annotations required"}, {"sha": "94884c133b71645c130ee4162ba5aca850707605", "filename": "src/test/compile-fail/issue-6458-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -12,5 +12,6 @@ extern crate debug;\n \n fn main() {\n     // Unconstrained type:\n-    format!(\"{:?}\", None); //~ ERROR: E0101\n+    format!(\"{:?}\", None);\n+    //~^ ERROR type annotations required\n }"}, {"sha": "f96faeeec4bd198e696f93178b1df75d57ab3cf4", "filename": "src/test/compile-fail/issue-6458-3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -11,5 +11,6 @@\n use std::mem;\n \n fn main() {\n-    mem::transmute(0);  //~ ERROR: cannot determine a type for this expression: unconstrained type\n+    mem::transmute(0);\n+    //~^ ERROR type annotations required\n }"}, {"sha": "02274e5441e26bb8142e2b6714429827922cd716", "filename": "src/test/compile-fail/issue-6458-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -10,7 +10,7 @@\n \n fn foo(b: bool) -> Result<bool,String> {\n     Err(\"bar\".to_string());\n-    //~^ ERROR: cannot determine a type for this expression: unconstrained type\n+    //~^ ERROR type annotations required\n }\n \n fn main() {"}, {"sha": "efa3100360b5c0e0c4c000ad09a1cd785ca22407", "filename": "src/test/compile-fail/issue-6458.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -14,7 +14,7 @@ pub struct MyState;\n pub fn foo<State>(_: TypeWithState<State>) {}\n \n pub fn bar() {\n-   foo(TypeWithState); //~ ERROR: cannot determine a type for this expression: unconstrained type\n+   foo(TypeWithState);  //~ ERROR type annotations required\n }\n \n fn main() {"}, {"sha": "81421af4fa839a9f0dc00a4ef76540eb4f9e6a95", "filename": "src/test/compile-fail/issue-7813.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    let v = &[]; //~ ERROR cannot determine a type for this local variable: unconstrained type\n-    let it = v.iter();\n+    let v = &[];\n+    let it = v.iter(); //~ ERROR type annotations required\n }"}, {"sha": "ff8daa045c66d3b7c51a439a31e3cb0e0fefde6c", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -17,11 +17,12 @@ trait Dummy { }\n \n // careful with object types, who knows what they close over...\n fn test51<'a>() {\n-    assert_send::<&'a Dummy>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<&'a Dummy>();\n     //~^ ERROR the trait `core::kinds::Send` is not implemented\n }\n fn test52<'a>() {\n-    assert_send::<&'a Dummy+Send>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<&'a Dummy+Send>();\n+    //~^ ERROR does not fulfill the required lifetime\n }\n \n // ...unless they are properly bounded\n@@ -35,12 +36,12 @@ fn test61() {\n // closure and object types can have lifetime bounds which make\n // them not ok\n fn test_70<'a>() {\n-    assert_send::<proc():'a>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<proc():'a>();\n     //~^ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n fn test_71<'a>() {\n-    assert_send::<Box<Dummy+'a>>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<Box<Dummy+'a>>();\n     //~^ ERROR the trait `core::kinds::Send` is not implemented\n }\n "}, {"sha": "182b40ceaae03d544a3ef7bda139b6320947587f", "filename": "src/test/compile-fail/regions-bounded-by-send.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -57,21 +57,22 @@ fn box_with_region_not_ok<'a>() {\n // objects with insufficient bounds no ok\n \n fn object_with_random_bound_not_ok<'a>() {\n-    assert_send::<&'a Dummy+'a>(); //~ ERROR does not fulfill\n+    assert_send::<&'a Dummy+'a>();\n     //~^ ERROR not implemented\n }\n \n fn object_with_send_bound_not_ok<'a>() {\n-    assert_send::<&'a Dummy+Send>(); //~ ERROR does not fulfill\n+    assert_send::<&'a Dummy+Send>();\n+    //~^ ERROR does not fulfill\n }\n \n fn proc_with_lifetime_not_ok<'a>() {\n-    assert_send::<proc():'a>(); //~ ERROR does not fulfill\n+    assert_send::<proc():'a>();\n     //~^ ERROR not implemented\n }\n \n fn closure_with_lifetime_not_ok<'a>() {\n-    assert_send::<||:'a>(); //~ ERROR does not fulfill\n+    assert_send::<||:'a>();\n     //~^ ERROR not implemented\n }\n "}, {"sha": "9879766a8fa256431c80646c10ba03f85ccb0fd1", "filename": "src/test/compile-fail/unconstrained-none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Funconstrained-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Funconstrained-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funconstrained-none.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -11,5 +11,5 @@\n // Issue #5062\n \n fn main() {\n-    None; //~ ERROR cannot determine a type for this expression: unconstrained type\n+    None; //~ ERROR type annotations required\n }"}, {"sha": "e03f60e758ce2eebc043f68d75d956e5563056b4", "filename": "src/test/compile-fail/unconstrained-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -13,5 +13,5 @@ struct S<'a, T:'a> {\n }\n \n fn main() {\n-    S { o: &None }; //~ ERROR cannot determine a type for this expression: unconstrained type\n+    S { o: &None }; //~ ERROR type annotations required\n }"}, {"sha": "d48f5715ec1b980879c415842a6edd6b19f7f87a", "filename": "src/test/compile-fail/vector-no-ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/effb3636cc416ae81450e857352b832a86d5dd44/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs?ref=effb3636cc416ae81450e857352b832a86d5dd44", "patch": "@@ -10,5 +10,5 @@\n \n \n fn main() {\n-    let _foo = Vec::new(); //~ ERROR unconstrained type\n+    let _foo = Vec::new(); //~ ERROR type annotations required\n }"}]}