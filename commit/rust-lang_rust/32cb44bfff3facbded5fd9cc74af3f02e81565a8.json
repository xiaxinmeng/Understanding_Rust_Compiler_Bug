{"sha": "32cb44bfff3facbded5fd9cc74af3f02e81565a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyY2I0NGJmZmYzZmFjYmRlZDVmZDljYzc0YWYzZjAyZTgxNTY1YTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-17T06:21:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-17T06:21:21Z"}, "message": "auto merge of #14022 : pcwalton/rust/explicit-self, r=pnkfelix\n\nr? @nikomatsakis", "tree": {"sha": "162e3b98fc57b10079f3ed04ff2144bafbfabae4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/162e3b98fc57b10079f3ed04ff2144bafbfabae4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32cb44bfff3facbded5fd9cc74af3f02e81565a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32cb44bfff3facbded5fd9cc74af3f02e81565a8", "html_url": "https://github.com/rust-lang/rust/commit/32cb44bfff3facbded5fd9cc74af3f02e81565a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32cb44bfff3facbded5fd9cc74af3f02e81565a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "459ffc2adc74f5e8b64a76f5670edb419b9f65da", "url": "https://api.github.com/repos/rust-lang/rust/commits/459ffc2adc74f5e8b64a76f5670edb419b9f65da", "html_url": "https://github.com/rust-lang/rust/commit/459ffc2adc74f5e8b64a76f5670edb419b9f65da"}, {"sha": "00c70d1a803e62ccbe2545d5c5522f4dcd6953b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/00c70d1a803e62ccbe2545d5c5522f4dcd6953b9", "html_url": "https://github.com/rust-lang/rust/commit/00c70d1a803e62ccbe2545d5c5522f4dcd6953b9"}], "stats": {"total": 854, "additions": 662, "deletions": 192}, "files": [{"sha": "0adc8e915c679e2050e5f22f487ff27ad14ae549", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -132,7 +132,8 @@ pub fn get_method(tcx: &ty::ctxt, def: ast::DefId) -> ty::Method {\n \n pub fn get_method_name_and_explicit_self(cstore: &cstore::CStore,\n                                          def: ast::DefId)\n-                                     -> (ast::Ident, ast::ExplicitSelf_)\n+                                         -> (ast::Ident,\n+                                             ty::ExplicitSelfCategory)\n {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_method_name_and_explicit_self(cstore.intr.clone(), &*cdata, def.node)"}, {"sha": "094e83d2a4770af150046c2aa7102df4ca28c3ad", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -724,7 +724,7 @@ pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n     }).collect()\n }\n \n-fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n+fn get_explicit_self(item: ebml::Doc) -> ty::ExplicitSelfCategory {\n     fn get_mutability(ch: u8) -> ast::Mutability {\n         match ch as char {\n             'i' => ast::MutImmutable,\n@@ -738,12 +738,15 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n \n     let explicit_self_kind = string.as_bytes()[0];\n     match explicit_self_kind as char {\n-        's' => ast::SelfStatic,\n-        'v' => ast::SelfValue(special_idents::self_),\n-        '~' => ast::SelfUniq(special_idents::self_),\n+        's' => ty::StaticExplicitSelfCategory,\n+        'v' => ty::ByValueExplicitSelfCategory,\n+        '~' => ty::ByBoxExplicitSelfCategory,\n         // FIXME(#4846) expl. region\n-        '&' => ast::SelfRegion(None, get_mutability(string.as_bytes()[1]),\n-                               special_idents::self_),\n+        '&' => {\n+            ty::ByReferenceExplicitSelfCategory(\n+                ty::ReEmpty,\n+                get_mutability(string.as_bytes()[1]))\n+        }\n         _ => fail!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n     }\n }\n@@ -761,11 +764,11 @@ pub fn get_impl_methods(cdata: Cmd, impl_id: ast::NodeId) -> Vec<ast::DefId> {\n     methods\n }\n \n-pub fn get_method_name_and_explicit_self(\n-    intr: Rc<IdentInterner>,\n-    cdata: Cmd,\n-    id: ast::NodeId) -> (ast::Ident, ast::ExplicitSelf_)\n-{\n+pub fn get_method_name_and_explicit_self(intr: Rc<IdentInterner>,\n+                                         cdata: Cmd,\n+                                         id: ast::NodeId)\n+                                         -> (ast::Ident,\n+                                             ty::ExplicitSelfCategory) {\n     let method_doc = lookup_item(id, cdata.data());\n     let name = item_name(&*intr, method_doc);\n     let explicit_self = get_explicit_self(method_doc);"}, {"sha": "3c9f32dcd2f85ca9c7a2499521f38afc53190e63", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -402,7 +402,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n             for base_impl_did in implementations.borrow().iter() {\n                 for &method_did in impl_methods.get(base_impl_did).iter() {\n                     let m = ty::method(ecx.tcx, method_did);\n-                    if m.explicit_self == ast::SelfStatic {\n+                    if m.explicit_self == ty::StaticExplicitSelfCategory {\n                         encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n                     }\n                 }\n@@ -421,7 +421,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n     match ecx.tcx.trait_methods_cache.borrow().find(&exp.def_id) {\n         Some(methods) => {\n             for m in methods.iter() {\n-                if m.explicit_self == ast::SelfStatic {\n+                if m.explicit_self == ty::StaticExplicitSelfCategory {\n                     encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n                 }\n             }\n@@ -623,15 +623,22 @@ fn encode_visibility(ebml_w: &mut Encoder, visibility: Visibility) {\n     ebml_w.end_tag();\n }\n \n-fn encode_explicit_self(ebml_w: &mut Encoder, explicit_self: ast::ExplicitSelf_) {\n+fn encode_explicit_self(ebml_w: &mut Encoder,\n+                        explicit_self: &ty::ExplicitSelfCategory) {\n     ebml_w.start_tag(tag_item_trait_method_explicit_self);\n \n     // Encode the base self type.\n-    match explicit_self {\n-        SelfStatic   => { ebml_w.writer.write(&[ 's' as u8 ]); }\n-        SelfValue(_) => { ebml_w.writer.write(&[ 'v' as u8 ]); }\n-        SelfUniq(_)  => { ebml_w.writer.write(&[ '~' as u8 ]); }\n-        SelfRegion(_, m, _) => {\n+    match *explicit_self {\n+        ty::StaticExplicitSelfCategory => {\n+            ebml_w.writer.write(&[ 's' as u8 ]);\n+        }\n+        ty::ByValueExplicitSelfCategory => {\n+            ebml_w.writer.write(&[ 'v' as u8 ]);\n+        }\n+        ty::ByBoxExplicitSelfCategory => {\n+            ebml_w.writer.write(&[ '~' as u8 ]);\n+        }\n+        ty::ByReferenceExplicitSelfCategory(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n             ebml_w.writer.write(&['&' as u8]);\n             encode_mutability(ebml_w, m);\n@@ -748,10 +755,10 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n                               tag_item_method_tps);\n     encode_method_fty(ecx, ebml_w, &method_ty.fty);\n     encode_visibility(ebml_w, method_ty.vis);\n-    encode_explicit_self(ebml_w, method_ty.explicit_self);\n+    encode_explicit_self(ebml_w, &method_ty.explicit_self);\n     let fn_style = method_ty.fty.fn_style;\n     match method_ty.explicit_self {\n-        ast::SelfStatic => {\n+        ty::StaticExplicitSelfCategory => {\n             encode_family(ebml_w, fn_style_static_method_family(fn_style));\n         }\n         _ => encode_family(ebml_w, style_fn_family(fn_style))\n@@ -1206,7 +1213,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_path(ebml_w, path.clone().chain(Some(elem).move_iter()));\n \n             match method_ty.explicit_self {\n-                SelfStatic => {\n+                ty::StaticExplicitSelfCategory => {\n                     encode_family(ebml_w,\n                                   fn_style_static_method_family(\n                                       method_ty.fty.fn_style));\n@@ -1233,7 +1240,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_attributes(ebml_w, m.attrs.as_slice());\n                     // If this is a static method, we've already encoded\n                     // this.\n-                    if method_ty.explicit_self != SelfStatic {\n+                    if method_ty.explicit_self != ty::StaticExplicitSelfCategory {\n                         // FIXME: I feel like there is something funny going on.\n                         let pty = ty::lookup_item_type(tcx, method_def_id);\n                         encode_bounds_and_type(ebml_w, ecx, &pty);"}, {"sha": "822a43f2619dc4496ff7d0fa68b4d3b1d519e553", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -314,6 +314,16 @@ impl RegionMaps {\n                     self.sub_free_region(sub_fr, super_fr)\n                 }\n \n+                (ty::ReEarlyBound(param_id_a, param_space_a, index_a, _),\n+                 ty::ReEarlyBound(param_id_b, param_space_b, index_b, _)) => {\n+                    // This case is used only to make sure that explicitly-\n+                    // specified `Self` types match the real self type in\n+                    // implementations.\n+                    param_id_a == param_id_b &&\n+                        param_space_a == param_space_b &&\n+                        index_a == index_b\n+                }\n+\n                 _ => {\n                     false\n                 }"}, {"sha": "f00d7c36f53339efd8f75796bd27cee7f27ae3ce", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -11,13 +11,14 @@\n #![allow(non_camel_case_types)]\n \n use driver::session::Session;\n+use lint;\n use metadata::csearch;\n use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use middle::def::*;\n use middle::lang_items::LanguageItems;\n use middle::pat_util::pat_bindings;\n use middle::subst::{ParamSpace, FnSpace, TypeSpace};\n-use lint;\n+use middle::ty::{ExplicitSelfCategory, StaticExplicitSelfCategory};\n use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n \n use syntax::ast::*;\n@@ -287,6 +288,24 @@ enum ModulePrefixResult {\n     PrefixFound(Rc<Module>, uint)\n }\n \n+#[deriving(Clone, Eq, PartialEq)]\n+enum MethodIsStaticFlag {\n+    MethodIsNotStatic,\n+    MethodIsStatic,\n+}\n+\n+impl MethodIsStaticFlag {\n+    fn from_explicit_self_category(explicit_self_category:\n+                                   ExplicitSelfCategory)\n+                                   -> MethodIsStaticFlag {\n+        if explicit_self_category == StaticExplicitSelfCategory {\n+            MethodIsStatic\n+        } else {\n+            MethodIsNotStatic\n+        }\n+    }\n+}\n+\n #[deriving(PartialEq)]\n enum NameSearchType {\n     /// We're doing a name search in order to resolve a `use` directive.\n@@ -805,7 +824,8 @@ struct Resolver<'a> {\n \n     graph_root: NameBindings,\n \n-    method_map: RefCell<FnvHashMap<(Name, DefId), ast::ExplicitSelf_>>,\n+    method_map: RefCell<FnvHashMap<(Name, DefId), MethodIsStaticFlag>>,\n+\n     structs: FnvHashMap<DefId, Vec<Name>>,\n \n     // The number of imports that are currently unresolved.\n@@ -1361,17 +1381,19 @@ impl<'a> Resolver<'a> {\n                     let ident = ty_m.ident;\n \n                     // Add it as a name in the trait module.\n-                    let def = match ty_m.explicit_self.node {\n+                    let (def, static_flag) = match ty_m.explicit_self.node {\n                         SelfStatic => {\n                             // Static methods become `def_static_method`s.\n-                            DefStaticMethod(local_def(ty_m.id),\n+                            (DefStaticMethod(local_def(ty_m.id),\n                                               FromTrait(local_def(item.id)),\n-                                              ty_m.fn_style)\n+                                              ty_m.fn_style),\n+                             MethodIsStatic)\n                         }\n                         _ => {\n                             // Non-static methods become `def_method`s.\n-                            DefMethod(local_def(ty_m.id),\n-                                       Some(local_def(item.id)))\n+                            (DefMethod(local_def(ty_m.id),\n+                                       Some(local_def(item.id))),\n+                             MethodIsNotStatic)\n                         }\n                     };\n \n@@ -1382,8 +1404,9 @@ impl<'a> Resolver<'a> {\n                                        ty_m.span);\n                     method_name_bindings.define_value(def, ty_m.span, true);\n \n-                    self.method_map.borrow_mut().insert((ident.name, def_id),\n-                                                        ty_m.explicit_self.node);\n+                    self.method_map\n+                        .borrow_mut()\n+                        .insert((ident.name, def_id), static_flag);\n                 }\n \n                 name_bindings.define_type(DefTrait(def_id), sp, is_public);\n@@ -1670,7 +1693,11 @@ impl<'a> Resolver<'a> {\n                           trait method '{}'\",\n                          token::get_ident(method_name));\n \n-                  self.method_map.borrow_mut().insert((method_name.name, def_id), explicit_self);\n+                  self.method_map\n+                      .borrow_mut()\n+                      .insert((method_name.name, def_id),\n+                              MethodIsStaticFlag::from_explicit_self_category(\n+                                  explicit_self));\n \n                   if is_exported {\n                       self.external_exports.insert(method_def_id);\n@@ -3678,6 +3705,13 @@ impl<'a> Resolver<'a> {\n                                     this.resolve_type(&*argument.ty);\n                                 }\n \n+                                match ty_m.explicit_self.node {\n+                                    SelfExplicit(ref typ, _) => {\n+                                        this.resolve_type(*typ)\n+                                    }\n+                                    _ => {}\n+                                }\n+\n                                 this.resolve_type(&*ty_m.decl.output);\n                             });\n                           }\n@@ -4009,7 +4043,14 @@ impl<'a> Resolver<'a> {\n                                                 method.id,\n                                                 rib_kind);\n \n-        self.resolve_function(rib_kind, Some(method.pe_fn_decl()), type_parameters,\n+        match method.pe_explicit_self().node {\n+            SelfExplicit(ref typ, _) => self.resolve_type(*typ),\n+            _ => {}\n+        }\n+\n+        self.resolve_function(rib_kind,\n+                              Some(method.pe_fn_decl()),\n+                              type_parameters,\n                               method.pe_body());\n     }\n \n@@ -4765,7 +4806,7 @@ impl<'a> Resolver<'a> {\n                 match containing_module.def_id.get() {\n                     Some(def_id) => {\n                         match self.method_map.borrow().find(&(ident.name, def_id)) {\n-                            Some(x) if *x == SelfStatic => (),\n+                            Some(&MethodIsStatic) => (),\n                             None => (),\n                             _ => {\n                                 debug!(\"containing module was a trait or impl \\\n@@ -5037,7 +5078,7 @@ impl<'a> Resolver<'a> {\n                 let path_str = self.path_idents_to_string(&trait_ref.path);\n \n                 match method_map.find(&(name, did)) {\n-                    Some(&SelfStatic) => return StaticTraitMethod(path_str),\n+                    Some(&MethodIsStatic) => return StaticTraitMethod(path_str),\n                     Some(_) => return TraitMethod,\n                     None => {}\n                 }"}, {"sha": "53f0645cb87026321b4a7c78dfa96a16e5b13725", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -502,15 +502,12 @@ fn emit_vtable_methods(bcx: &Block,\n                                                        ExprId(0),\n                                                        substs.clone(),\n                                                        vtables.clone());\n-            match m.explicit_self {\n-                ast::SelfValue(_) => {\n-                    fn_ref = trans_unboxing_shim(bcx,\n-                                                 fn_ref,\n-                                                 &*m,\n-                                                 m_id,\n-                                                 substs.clone());\n-                },\n-                _ => {}\n+            if m.explicit_self == ty::ByValueExplicitSelfCategory {\n+                fn_ref = trans_unboxing_shim(bcx,\n+                                             fn_ref,\n+                                             &*m,\n+                                             m_id,\n+                                             substs.clone());\n             }\n             fn_ref\n         }"}, {"sha": "cfafe99090d58d99bb627b5115d581813f8948ec", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -85,7 +85,7 @@ pub struct Method {\n     pub ident: ast::Ident,\n     pub generics: ty::Generics,\n     pub fty: BareFnTy,\n-    pub explicit_self: ast::ExplicitSelf_,\n+    pub explicit_self: ExplicitSelfCategory,\n     pub vis: ast::Visibility,\n     pub def_id: ast::DefId,\n     pub container: MethodContainer,\n@@ -98,7 +98,7 @@ impl Method {\n     pub fn new(ident: ast::Ident,\n                generics: ty::Generics,\n                fty: BareFnTy,\n-               explicit_self: ast::ExplicitSelf_,\n+               explicit_self: ExplicitSelfCategory,\n                vis: ast::Visibility,\n                def_id: ast::DefId,\n                container: MethodContainer,\n@@ -311,6 +311,9 @@ pub struct ctxt {\n     /// (inferred) variance.\n     pub item_variance_map: RefCell<DefIdMap<Rc<ItemVariances>>>,\n \n+    /// True if the variance has been computed yet; false otherwise.\n+    pub variance_computed: Cell<bool>,\n+\n     /// A mapping from the def ID of an enum or struct type to the def ID\n     /// of the method that implements its destructor. If the type is not\n     /// present in this map, it does not have a destructor. This map is\n@@ -1055,6 +1058,7 @@ pub fn mk_ctxt(s: Session,\n     ctxt {\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n+        variance_computed: Cell::new(false),\n         interner: RefCell::new(FnvHashMap::new()),\n         next_id: Cell::new(primitives::LAST_PRIMITIVE_ID),\n         sess: s,\n@@ -4767,3 +4771,13 @@ impl mc::Typer for ty::ctxt {\n         self.upvar_borrow_map.borrow().get_copy(&upvar_id)\n     }\n }\n+\n+/// The category of explicit self.\n+#[deriving(Clone, Eq, PartialEq)]\n+pub enum ExplicitSelfCategory {\n+    StaticExplicitSelfCategory,\n+    ByValueExplicitSelfCategory,\n+    ByReferenceExplicitSelfCategory(Region, ast::Mutability),\n+    ByBoxExplicitSelfCategory,\n+}\n+"}, {"sha": "09557c94aa62a7812561fe0564a9550761645418", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 125, "deletions": 33, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -52,13 +52,13 @@\n use middle::const_eval;\n use middle::def;\n use middle::lang_items::FnMutTraitLangItem;\n-use rl = middle::resolve_lifetime;\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::ty;\n-use middle::typeck::TypeAndSubsts;\n-use middle::typeck::lookup_def_tcx;\n+use middle::ty_fold::TypeFolder;\n use middle::typeck::rscope::RegionScope;\n-use middle::typeck::rscope;\n+use middle::typeck::{TypeAndSubsts, infer, lookup_def_tcx, rscope};\n+use middle::typeck;\n+use rl = middle::resolve_lifetime;\n use util::ppaux::Repr;\n \n use std::rc::Rc;\n@@ -900,58 +900,73 @@ pub fn ty_of_arg<AC: AstConv, RS: RegionScope>(this: &AC, rscope: &RS, a: &ast::\n     }\n }\n \n-struct SelfInfo {\n+struct SelfInfo<'a> {\n     untransformed_self_ty: ty::t,\n-    explicit_self: ast::ExplicitSelf\n+    explicit_self: ast::ExplicitSelf,\n }\n \n pub fn ty_of_method<AC:AstConv>(\n-    this: &AC,\n-    id: ast::NodeId,\n-    fn_style: ast::FnStyle,\n-    untransformed_self_ty: ty::t,\n-    explicit_self: ast::ExplicitSelf,\n-    decl: &ast::FnDecl)\n-    -> ty::BareFnTy\n-{\n-    ty_of_method_or_bare_fn(this, id, fn_style, abi::Rust, Some(SelfInfo {\n+                    this: &AC,\n+                    id: ast::NodeId,\n+                    fn_style: ast::FnStyle,\n+                    untransformed_self_ty: ty::t,\n+                    explicit_self: ast::ExplicitSelf,\n+                    decl: &ast::FnDecl)\n+                    -> (ty::BareFnTy, ty::ExplicitSelfCategory) {\n+    let self_info = Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n-        explicit_self: explicit_self\n-    }), decl)\n+        explicit_self: explicit_self,\n+    });\n+    let (bare_fn_ty, optional_explicit_self_category) =\n+        ty_of_method_or_bare_fn(this,\n+                                id,\n+                                fn_style,\n+                                abi::Rust,\n+                                self_info,\n+                                decl);\n+    (bare_fn_ty, optional_explicit_self_category.unwrap())\n }\n \n pub fn ty_of_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n                                  fn_style: ast::FnStyle, abi: abi::Abi,\n                                  decl: &ast::FnDecl) -> ty::BareFnTy {\n-    ty_of_method_or_bare_fn(this, id, fn_style, abi, None, decl)\n+    let (bare_fn_ty, _) =\n+        ty_of_method_or_bare_fn(this, id, fn_style, abi, None, decl);\n+    bare_fn_ty\n }\n \n-fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n-                                       fn_style: ast::FnStyle, abi: abi::Abi,\n-                                       opt_self_info: Option<SelfInfo>,\n-                                       decl: &ast::FnDecl) -> ty::BareFnTy {\n+fn ty_of_method_or_bare_fn<AC:AstConv>(\n+                           this: &AC,\n+                           id: ast::NodeId,\n+                           fn_style: ast::FnStyle,\n+                           abi: abi::Abi,\n+                           opt_self_info: Option<SelfInfo>,\n+                           decl: &ast::FnDecl)\n+                           -> (ty::BareFnTy,\n+                               Option<ty::ExplicitSelfCategory>) {\n     debug!(\"ty_of_method_or_bare_fn\");\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n     let rb = rscope::BindingRscope::new(id);\n \n+    let mut explicit_self_category_result = None;\n     let self_ty = opt_self_info.and_then(|self_info| {\n-        match self_info.explicit_self.node {\n-            ast::SelfStatic => None,\n-            ast::SelfValue(_) => {\n+        // Figure out and record the explicit self category.\n+        let explicit_self_category =\n+            determine_explicit_self_category(this, &rb, &self_info);\n+        explicit_self_category_result = Some(explicit_self_category);\n+        match explicit_self_category {\n+            ty::StaticExplicitSelfCategory => None,\n+            ty::ByValueExplicitSelfCategory => {\n                 Some(self_info.untransformed_self_ty)\n             }\n-            ast::SelfRegion(ref lifetime, mutability, _) => {\n-                let region =\n-                    opt_ast_region_to_region(this, &rb,\n-                                             self_info.explicit_self.span,\n-                                             lifetime);\n+            ty::ByReferenceExplicitSelfCategory(region, mutability) => {\n                 Some(ty::mk_rptr(this.tcx(), region,\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: mutability}))\n             }\n-            ast::SelfUniq(_) => {\n+            ty::ByBoxExplicitSelfCategory => {\n                 Some(ty::mk_uniq(this.tcx(), self_info.untransformed_self_ty))\n             }\n         }\n@@ -972,7 +987,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n         _ => ast_ty_to_ty(this, &rb, &*decl.output)\n     };\n \n-    return ty::BareFnTy {\n+    (ty::BareFnTy {\n         fn_style: fn_style,\n         abi: abi,\n         sig: ty::FnSig {\n@@ -981,7 +996,83 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n             output: output_ty,\n             variadic: decl.variadic\n         }\n-    };\n+    }, explicit_self_category_result)\n+}\n+\n+fn determine_explicit_self_category<AC:AstConv,\n+                                    RS:RegionScope>(\n+                                    this: &AC,\n+                                    rscope: &RS,\n+                                    self_info: &SelfInfo)\n+                                    -> ty::ExplicitSelfCategory {\n+    match self_info.explicit_self.node {\n+        ast::SelfStatic => ty::StaticExplicitSelfCategory,\n+        ast::SelfValue(_) => ty::ByValueExplicitSelfCategory,\n+        ast::SelfRegion(ref lifetime, mutability, _) => {\n+            let region =\n+                opt_ast_region_to_region(this,\n+                                         rscope,\n+                                         self_info.explicit_self.span,\n+                                         lifetime);\n+            ty::ByReferenceExplicitSelfCategory(region, mutability)\n+        }\n+        ast::SelfUniq(_) => ty::ByBoxExplicitSelfCategory,\n+        ast::SelfExplicit(ast_type, _) => {\n+            let explicit_type = ast_ty_to_ty(this, rscope, ast_type);\n+\n+            {\n+                let inference_context = infer::new_infer_ctxt(this.tcx());\n+                let expected_self = self_info.untransformed_self_ty;\n+                let actual_self = explicit_type;\n+                let result = infer::mk_eqty(\n+                    &inference_context,\n+                    false,\n+                    infer::Misc(self_info.explicit_self.span),\n+                    expected_self,\n+                    actual_self);\n+                match result {\n+                    Ok(_) => {\n+                        inference_context.resolve_regions_and_report_errors();\n+                        return ty::ByValueExplicitSelfCategory\n+                    }\n+                    Err(_) => {}\n+                }\n+            }\n+\n+            match ty::get(explicit_type).sty {\n+                ty::ty_rptr(region, tm) => {\n+                    typeck::require_same_types(\n+                        this.tcx(),\n+                        None,\n+                        false,\n+                        self_info.explicit_self.span,\n+                        self_info.untransformed_self_ty,\n+                        tm.ty,\n+                        || \"not a valid type for `self`\".to_owned());\n+                    return ty::ByReferenceExplicitSelfCategory(region,\n+                                                               tm.mutbl)\n+                }\n+                ty::ty_uniq(typ) => {\n+                    typeck::require_same_types(\n+                        this.tcx(),\n+                        None,\n+                        false,\n+                        self_info.explicit_self.span,\n+                        self_info.untransformed_self_ty,\n+                        typ,\n+                        || \"not a valid type for `self`\".to_owned());\n+                    return ty::ByBoxExplicitSelfCategory\n+                }\n+                _ => {\n+                    this.tcx()\n+                        .sess\n+                        .span_err(self_info.explicit_self.span,\n+                                  \"not a valid type for `self`\");\n+                    return ty::ByValueExplicitSelfCategory\n+                }\n+            }\n+        }\n+    }\n }\n \n pub fn ty_of_closure<AC:AstConv>(\n@@ -1098,3 +1189,4 @@ fn conv_builtin_bounds(tcx: &ty::ctxt,\n         (&None, ty::UniqTraitStore) => ty::empty_builtin_bounds(),\n     }\n }\n+"}, {"sha": "e12fae4f9501e00ea4f325437d6c6b0ba6b7e110", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -100,9 +100,7 @@ use util::ppaux::Repr;\n \n use std::collections::HashSet;\n use std::rc::Rc;\n-use syntax::ast::{DefId, SelfValue, SelfRegion};\n-use syntax::ast::{SelfUniq, SelfStatic};\n-use syntax::ast::{MutMutable, MutImmutable};\n+use syntax::ast::{DefId, MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -267,15 +265,15 @@ fn construct_transformed_self_ty_for_object(\n     obj_substs.types.pop(subst::SelfSpace).unwrap();\n \n     match method_ty.explicit_self {\n-        ast::SelfStatic => {\n+        StaticExplicitSelfCategory => {\n             tcx.sess.span_bug(span, \"static method for object type receiver\");\n         }\n-        ast::SelfValue(_) => {\n+        ByValueExplicitSelfCategory => {\n             let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n                                   ty::empty_builtin_bounds());\n             ty::mk_uniq(tcx, tr)\n         }\n-        ast::SelfRegion(..) | ast::SelfUniq(..) => {\n+        ByReferenceExplicitSelfCategory(..) | ByBoxExplicitSelfCategory => {\n             let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n             match ty::get(transformed_self_ty).sty {\n                 ty::ty_rptr(r, mt) => { // must be SelfRegion\n@@ -618,7 +616,7 @@ impl<'a> LookupContext<'a> {\n \n             let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n             match trait_methods.iter().position(|m| {\n-                m.explicit_self != ast::SelfStatic &&\n+                m.explicit_self != ty::StaticExplicitSelfCategory &&\n                 m.ident.name == self.m_name }) {\n                 Some(pos) => {\n                     let method = trait_methods.get(pos).clone();\n@@ -1023,7 +1021,10 @@ impl<'a> LookupContext<'a> {\n \n         if self.report_statics == ReportStaticMethods {\n             // lookup should only be called with ReportStaticMethods if a regular lookup failed\n-            assert!(relevant_candidates.iter().all(|c| c.method_ty.explicit_self == SelfStatic));\n+            assert!(relevant_candidates.iter()\n+                                       .all(|c| {\n+                c.method_ty.explicit_self == ty::StaticExplicitSelfCategory\n+            }));\n \n             self.tcx().sess.fileline_note(self.span,\n                                 \"found defined static methods, maybe a `self` is missing?\");\n@@ -1100,7 +1101,8 @@ impl<'a> LookupContext<'a> {\n         self.enforce_drop_trait_limitations(candidate);\n \n         // static methods should never have gotten this far:\n-        assert!(candidate.method_ty.explicit_self != SelfStatic);\n+        assert!(candidate.method_ty.explicit_self !=\n+                ty::StaticExplicitSelfCategory);\n \n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n@@ -1217,12 +1219,16 @@ impl<'a> LookupContext<'a> {\n         }\n \n         match candidate.method_ty.explicit_self {\n-            ast::SelfStatic => { // reason (a) above\n-                span_err!(self.tcx().sess, self.span, E0037,\n-                    \"cannot call a method without a receiver through an object\");\n+            ty::StaticExplicitSelfCategory => { // reason (a) above\n+                self.tcx().sess.span_err(\n+                    self.span,\n+                    \"cannot call a method without a receiver \\\n+                     through an object\");\n             }\n \n-            ast::SelfValue(_) | ast::SelfRegion(..) | ast::SelfUniq(_) => {}\n+            ty::ByValueExplicitSelfCategory |\n+            ty::ByReferenceExplicitSelfCategory(..) |\n+            ty::ByBoxExplicitSelfCategory => {}\n         }\n \n         // reason (a) above\n@@ -1284,12 +1290,12 @@ impl<'a> LookupContext<'a> {\n                self.ty_to_string(rcvr_ty), candidate.repr(self.tcx()));\n \n         return match candidate.method_ty.explicit_self {\n-            SelfStatic => {\n+            StaticExplicitSelfCategory => {\n                 debug!(\"(is relevant?) explicit self is static\");\n                 self.report_statics == ReportStaticMethods\n             }\n \n-            SelfValue(_) => {\n+            ByValueExplicitSelfCategory => {\n                 debug!(\"(is relevant?) explicit self is by-value\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(typ) => {\n@@ -1312,7 +1318,7 @@ impl<'a> LookupContext<'a> {\n                 }\n             }\n \n-            SelfRegion(_, m, _) => {\n+            ByReferenceExplicitSelfCategory(_, m) => {\n                 debug!(\"(is relevant?) explicit self is a region\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n@@ -1332,7 +1338,7 @@ impl<'a> LookupContext<'a> {\n                 }\n             }\n \n-            SelfUniq(_) => {\n+            ByBoxExplicitSelfCategory => {\n                 debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(typ) => {\n@@ -1480,3 +1486,6 @@ impl Repr for RcvrMatchCondition {\n         }\n     }\n }\n+\n+\n+"}, {"sha": "4f07f1121b7ceb0aa888648ebce7e56693fbd9f1", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -862,19 +862,26 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     // inscrutable, particularly for cases where one method has no\n     // self.\n     match (&trait_m.explicit_self, &impl_m.explicit_self) {\n-        (&ast::SelfStatic, &ast::SelfStatic) => {}\n-        (&ast::SelfStatic, _) => {\n-            span_err!(tcx.sess, impl_m_span, E0047,\n-                \"method `{}` has a `{}` declaration in the impl, but not in the trait\",\n-                token::get_ident(trait_m.ident),\n-                pprust::explicit_self_to_string(impl_m.explicit_self));\n+        (&ty::StaticExplicitSelfCategory,\n+         &ty::StaticExplicitSelfCategory) => {}\n+        (&ty::StaticExplicitSelfCategory, _) => {\n+            tcx.sess.span_err(\n+                impl_m_span,\n+                format!(\"method `{}` has a `{}` declaration in the impl, \\\n+                        but not in the trait\",\n+                        token::get_ident(trait_m.ident),\n+                        ppaux::explicit_self_category_to_str(\n+                            &impl_m.explicit_self)).as_slice());\n             return;\n         }\n-        (_, &ast::SelfStatic) => {\n-            span_err!(tcx.sess, impl_m_span, E0048,\n-                \"method `{}` has a `{}` declaration in the trait, but not in the impl\",\n-                token::get_ident(trait_m.ident),\n-                pprust::explicit_self_to_string(trait_m.explicit_self));\n+        (_, &ty::StaticExplicitSelfCategory) => {\n+            tcx.sess.span_err(\n+                impl_m_span,\n+                format!(\"method `{}` has a `{}` declaration in the trait, \\\n+                        but not in the impl\",\n+                        token::get_ident(trait_m.ident),\n+                        ppaux::explicit_self_category_to_str(\n+                            &trait_m.explicit_self)).as_slice());\n             return;\n         }\n         _ => {\n@@ -4787,3 +4794,4 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             });\n     }\n }\n+"}, {"sha": "eea26fbcfc73fc5e736526694e552243d77c0e34", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 91, "deletions": 13, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -40,11 +40,14 @@ use middle::subst::{Substs};\n use middle::ty::{ImplContainer, MethodContainer, TraitContainer};\n use middle::ty::{Polytype};\n use middle::ty;\n+use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty};\n use middle::typeck::astconv;\n+use middle::typeck::infer;\n use middle::typeck::rscope::*;\n use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n+use middle::typeck;\n use util::ppaux;\n use util::ppaux::Repr;\n \n@@ -218,7 +221,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                             }\n                         });\n \n-                        if ty_method.explicit_self == ast::SelfStatic {\n+                        if ty_method.explicit_self ==\n+                                ty::StaticExplicitSelfCategory {\n                             make_static_method_ty(ccx, &*ty_method);\n                         }\n \n@@ -266,18 +270,26 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                  m_fn_style: &ast::FnStyle,\n                                  m_decl: &ast::FnDecl) -> ty::Method\n     {\n-        let trait_self_ty = ty::mk_self_type(this.tcx, local_def(trait_id));\n-        let fty = astconv::ty_of_method(this, *m_id, *m_fn_style, trait_self_ty,\n-                                        *m_explicit_self, m_decl);\n-        let ty_generics =\n-            ty_generics_for_fn_or_method(this,\n-                                         m_generics,\n-                                         (*trait_generics).clone());\n+        let trait_self_ty = ty::mk_param(this.tcx,\n+                                         subst::SelfSpace,\n+                                         0,\n+                                         local_def(trait_id));\n+        let ty_generics = ty_generics_for_fn_or_method(\n+            this,\n+            m_generics,\n+            (*trait_generics).clone());\n+        let (fty, explicit_self_category) =\n+            astconv::ty_of_method(this,\n+                                  *m_id,\n+                                  *m_fn_style,\n+                                  trait_self_ty,\n+                                  *m_explicit_self,\n+                                  m_decl);\n         ty::Method::new(\n             *m_ident,\n             ty_generics,\n             fty,\n-            m_explicit_self.node,\n+            explicit_self_category,\n             // assume public, because this is only invoked on trait methods\n             ast::Public,\n             local_def(*m_id),\n@@ -365,9 +377,13 @@ fn convert_methods(ccx: &CrateCtxt,\n                     rcvr_visibility: ast::Visibility)\n                     -> ty::Method\n     {\n-        let fty = astconv::ty_of_method(ccx, m.id, m.pe_fn_style(),\n-                                        untransformed_rcvr_ty,\n-                                        *m.pe_explicit_self(), m.pe_fn_decl());\n+        let (fty, explicit_self_category) =\n+            astconv::ty_of_method(ccx,\n+                                  m.id,\n+                                  m.pe_fn_style(),\n+                                  untransformed_rcvr_ty,\n+                                  *m.pe_explicit_self(),\n+                                  m.pe_fn_decl());\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n@@ -381,7 +397,7 @@ fn convert_methods(ccx: &CrateCtxt,\n         ty::Method::new(m.pe_ident(),\n                         m_ty_generics,\n                         fty,\n-                        m.pe_explicit_self().node,\n+                        explicit_self_category,\n                         method_vis,\n                         local_def(m.id),\n                         container,\n@@ -450,6 +466,13 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                 it.vis\n             };\n \n+            for method in ms.iter() {\n+                check_method_self_type(ccx,\n+                                       &BindingRscope::new(method.id),\n+                                       selfty,\n+                                       method.pe_explicit_self())\n+            }\n+\n             convert_methods(ccx,\n                             ImplContainer(local_def(it.id)),\n                             ms.as_slice(),\n@@ -464,6 +487,28 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n             let trait_def = trait_def_of_item(ccx, it);\n \n+            for trait_method in trait_methods.iter() {\n+                let self_type = ty::mk_param(ccx.tcx,\n+                                             subst::SelfSpace,\n+                                             0,\n+                                             local_def(it.id));\n+                match *trait_method {\n+                    ast::Required(ref type_method) => {\n+                        let rscope = BindingRscope::new(type_method.id);\n+                        check_method_self_type(ccx,\n+                                               &rscope,\n+                                               self_type,\n+                                               &type_method.explicit_self)\n+                    }\n+                    ast::Provided(ref method) => {\n+                        check_method_self_type(ccx,\n+                                               &BindingRscope::new(method.id),\n+                                               self_type,\n+                                               method.pe_explicit_self())\n+                    }\n+                }\n+            }\n+\n             // Run convert_methods on the provided methods.\n             let (_, provided_methods) =\n                 split_trait_methods(trait_methods.as_slice());\n@@ -1240,3 +1285,36 @@ pub fn mk_item_substs(ccx: &CrateCtxt,\n \n     subst::Substs::new(types, regions)\n }\n+\n+/// Verifies that the explicit self type of a method matches the impl or\n+/// trait.\n+fn check_method_self_type<RS:RegionScope>(\n+                          crate_context: &CrateCtxt,\n+                          rs: &RS,\n+                          required_type: ty::t,\n+                          explicit_self: &ast::ExplicitSelf) {\n+    match explicit_self.node {\n+        ast::SelfExplicit(ref ast_type, _) => {\n+            let typ = crate_context.to_ty(rs, *ast_type);\n+            let base_type = match ty::get(typ).sty {\n+                ty::ty_rptr(_, tm) => tm.ty,\n+                ty::ty_uniq(typ) => typ,\n+                _ => typ,\n+            };\n+            let infcx = infer::new_infer_ctxt(crate_context.tcx);\n+            drop(typeck::require_same_types(crate_context.tcx,\n+                                            Some(&infcx),\n+                                            false,\n+                                            explicit_self.span,\n+                                            base_type,\n+                                            required_type,\n+                                            || {\n+                format!(\"mismatched self type: expected `{}`\",\n+                        ppaux::ty_to_string(crate_context.tcx, required_type))\n+            }));\n+            infcx.resolve_regions_and_report_errors();\n+        }\n+        _ => {}\n+    }\n+}\n+"}, {"sha": "c3de120a0c393755a01f570f2eb0f00ccd7fffb5", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -111,7 +111,11 @@ pub trait Combine {\n               b_subst: &subst::Substs)\n               -> cres<subst::Substs>\n     {\n-        let variances = ty::item_variances(self.infcx().tcx, item_def_id);\n+        let variances = if self.infcx().tcx.variance_computed.get() {\n+            Some(ty::item_variances(self.infcx().tcx, item_def_id))\n+        } else {\n+            None\n+        };\n         let mut substs = subst::Substs::empty();\n \n         for &space in subst::ParamSpace::all().iter() {\n@@ -121,7 +125,18 @@ pub trait Combine {\n \n             let a_regions = a_subst.regions().get_slice(space);\n             let b_regions = b_subst.regions().get_slice(space);\n-            let r_variances = variances.regions.get_slice(space);\n+\n+            let mut invariance = Vec::new();\n+            let r_variances = match variances {\n+                Some(ref variances) => variances.regions.get_slice(space),\n+                None => {\n+                    for _ in a_regions.iter() {\n+                        invariance.push(ty::Invariant);\n+                    }\n+                    invariance.as_slice()\n+                }\n+            };\n+\n             let regions = if_ok!(relate_region_params(self,\n                                                       item_def_id,\n                                                       r_variances,"}, {"sha": "d17553e9c39b39b30e6801f46ff2b795765719c0", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -13,16 +13,15 @@\n \n use middle::ty;\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n-use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound,\n-                 ReLateBound};\n-use middle::ty::{ReScope, ReVar, ReSkolemized, BrFresh};\n+use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound};\n+use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::typeck::infer::cres;\n use middle::typeck::infer::{RegionVariableOrigin, SubregionOrigin, TypeTrace};\n use middle::typeck::infer;\n use middle::graph;\n use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n-use util::ppaux::{Repr};\n+use util::ppaux::Repr;\n \n use std::cell::{Cell, RefCell};\n use std::uint;\n@@ -318,6 +317,11 @@ impl<'a> RegionVarBindings<'a> {\n                origin.repr(self.tcx));\n \n         match (sub, sup) {\n+          (ReEarlyBound(..), ReEarlyBound(..)) => {\n+            // This case is used only to make sure that explicitly-specified\n+            // `Self` types match the real self type in implementations.\n+            self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n+          }\n           (ReEarlyBound(..), _) |\n           (ReLateBound(..), _) |\n           (_, ReEarlyBound(..)) |"}, {"sha": "a65aa0423a6d0a20d3790726a7ffaf04e237a74f", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -214,6 +214,7 @@ pub fn infer_variance(tcx: &ty::ctxt,\n     let terms_cx = determine_parameters_to_be_inferred(tcx, &mut arena, krate);\n     let constraints_cx = add_constraints_from_crate(terms_cx, krate);\n     solve_constraints(constraints_cx);\n+    tcx.variance_computed.set(true);\n }\n \n /**************************************************************************"}, {"sha": "e37bef98e4404a334fbd4ef7d55115a9448935cc", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -14,7 +14,7 @@ use middle::subst;\n use middle::subst::{VecPerParamSpace,Subst};\n use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n-use middle::ty::{BrFresh, ctxt};\n+use middle::ty::{ReEarlyBound, BrFresh, ctxt};\n use middle::ty::{mt, t, ParamTy};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region, ReEmpty};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n@@ -130,9 +130,13 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n \n       ReEmpty => { (\"the empty lifetime\".to_string(), None) }\n \n+      ReEarlyBound(_, _, _, name) => {\n+        (format!(\"{}\", token::get_name(name)), None)\n+      }\n+\n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n-      ty::ReInfer(_) | ty::ReEarlyBound(..) | ty::ReLateBound(..) => {\n+      ty::ReInfer(_) | ty::ReLateBound(..) => {\n         (format!(\"lifetime {:?}\", region), None)\n       }\n     };\n@@ -421,6 +425,19 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n     }\n }\n \n+pub fn explicit_self_category_to_str(category: &ty::ExplicitSelfCategory)\n+                                     -> &'static str {\n+    match *category {\n+        ty::StaticExplicitSelfCategory => \"static\",\n+        ty::ByValueExplicitSelfCategory => \"self\",\n+        ty::ByReferenceExplicitSelfCategory(_, ast::MutMutable) => {\n+            \"&mut self\"\n+        }\n+        ty::ByReferenceExplicitSelfCategory(_, ast::MutImmutable) => \"&self\",\n+        ty::ByBoxExplicitSelfCategory => \"Box<self>\",\n+    }\n+}\n+\n pub fn parameterized(cx: &ctxt,\n                      base: &str,\n                      substs: &subst::Substs,\n@@ -1083,3 +1100,10 @@ impl Repr for region_inference::VarValue {\n         }\n     }\n }\n+\n+impl Repr for ty::ExplicitSelfCategory {\n+    fn repr(&self, _: &ctxt) -> String {\n+        explicit_self_category_to_str(self).to_string()\n+    }\n+}\n+"}, {"sha": "c94759d7d7e8deef96b7bb838cb44c55d753b4fe", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -394,7 +394,7 @@ impl Clean<Item> for doctree::Module {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub enum Attribute {\n     Word(String),\n     List(String, Vec<Attribute> ),\n@@ -447,7 +447,7 @@ impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<ast::MetaItem>]> { None }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct TyParam {\n     pub name: String,\n     pub did: ast::DefId,\n@@ -479,7 +479,7 @@ impl Clean<TyParam> for ty::TypeParameterDef {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub enum TyParamBound {\n     RegionBound,\n     TraitBound(Type)\n@@ -638,7 +638,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n }\n \n // maybe use a Generic enum and use ~[Generic]?\n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct Generics {\n     pub lifetimes: Vec<Lifetime>,\n     pub type_params: Vec<TyParam>,\n@@ -771,6 +771,7 @@ pub enum SelfTy {\n     SelfValue,\n     SelfBorrowed(Option<Lifetime>, Mutability),\n     SelfOwned,\n+    SelfExplicit(Type),\n }\n \n impl Clean<SelfTy> for ast::ExplicitSelf_ {\n@@ -779,7 +780,10 @@ impl Clean<SelfTy> for ast::ExplicitSelf_ {\n             ast::SelfStatic => SelfStatic,\n             ast::SelfValue(_) => SelfValue,\n             ast::SelfUniq(_) => SelfOwned,\n-            ast::SelfRegion(lt, mt, _) => SelfBorrowed(lt.clean(), mt.clean()),\n+            ast::SelfRegion(lt, mt, _) => {\n+                SelfBorrowed(lt.clean(), mt.clean())\n+            }\n+            ast::SelfExplicit(typ, _) => SelfExplicit(typ.clean()),\n         }\n     }\n }\n@@ -809,7 +813,7 @@ impl Clean<Item> for doctree::Function {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct ClosureDecl {\n     pub lifetimes: Vec<Lifetime>,\n     pub decl: FnDecl,\n@@ -833,15 +837,15 @@ impl Clean<ClosureDecl> for ast::ClosureTy {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct FnDecl {\n     pub inputs: Arguments,\n     pub output: Type,\n     pub cf: RetStyle,\n     pub attrs: Vec<Attribute>,\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct Arguments {\n     pub values: Vec<Argument>,\n }\n@@ -888,7 +892,7 @@ impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct Argument {\n     pub type_: Type,\n     pub name: String,\n@@ -905,7 +909,7 @@ impl Clean<Argument> for ast::Arg {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub enum RetStyle {\n     NoReturn,\n     Return\n@@ -991,22 +995,28 @@ impl Clean<Item> for ty::Method {\n     fn clean(&self) -> Item {\n         let cx = get_cx();\n         let (self_, sig) = match self.explicit_self {\n-            ast::SelfStatic => (ast::SelfStatic.clean(), self.fty.sig.clone()),\n+            ty::StaticExplicitSelfCategory => (ast::SelfStatic.clean(), self.fty.sig.clone()),\n             s => {\n                 let sig = ty::FnSig {\n                     inputs: Vec::from_slice(self.fty.sig.inputs.slice_from(1)),\n                     ..self.fty.sig.clone()\n                 };\n                 let s = match s {\n-                    ast::SelfRegion(..) => {\n+                    ty::ByReferenceExplicitSelfCategory(..) => {\n                         match ty::get(self.fty.sig.inputs[0]).sty {\n                             ty::ty_rptr(r, mt) => {\n                                 SelfBorrowed(r.clean(), mt.mutbl.clean())\n                             }\n-                            _ => s.clean(),\n+                            _ => {\n+                                // FIXME(pcwalton): This is wrong.\n+                                SelfStatic\n+                            }\n                         }\n                     }\n-                    s => s.clean(),\n+                    _ => {\n+                        // FIXME(pcwalton): This is wrong.\n+                        SelfStatic\n+                    }\n                 };\n                 (s, sig)\n             }\n@@ -1032,7 +1042,7 @@ impl Clean<Item> for ty::Method {\n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n /// type out of the AST/ty::ctxt given one of these, if more information is needed. Most importantly\n /// it does not preserve mutability or boxes.\n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub enum Type {\n     /// structs/enums/traits (anything that'd be an ast::TyPath)\n     ResolvedPath {\n@@ -1550,7 +1560,7 @@ impl Clean<Span> for syntax::codemap::Span {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct Path {\n     pub global: bool,\n     pub segments: Vec<PathSegment>,\n@@ -1565,7 +1575,7 @@ impl Clean<Path> for ast::Path {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct PathSegment {\n     pub name: String,\n     pub lifetimes: Vec<Lifetime>,\n@@ -1631,7 +1641,7 @@ impl Clean<Item> for doctree::Typedef {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct BareFunctionDecl {\n     pub fn_style: ast::FnStyle,\n     pub generics: Generics,"}, {"sha": "d0f9b37cc4ce403a7b7dd8421ebb43caa74377c6", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -500,6 +500,9 @@ impl<'a> fmt::Show for Method<'a> {\n                 args.push_str(format!(\"&amp;{}self\",\n                                       MutableSpace(mtbl)).as_slice());\n             }\n+            clean::SelfExplicit(ref typ) => {\n+                args.push_str(format!(\"self: {}\", *typ).as_slice());\n+            }\n         }\n         for (i, input) in d.inputs.values.iter().enumerate() {\n             if i > 0 || args.len() > 0 { args.push_str(\", \"); }"}, {"sha": "d9f14bfa15661da7b5d59db64208a77c992b580e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -949,12 +949,14 @@ pub enum RetStyle {\n pub enum ExplicitSelf_ {\n     /// No self\n     SelfStatic,\n-    /// `self\n+    /// `self`\n     SelfValue(Ident),\n     /// `&'lt self`, `&'lt mut self`\n     SelfRegion(Option<Lifetime>, Mutability, Ident),\n     /// `~self`\n-    SelfUniq(Ident)\n+    SelfUniq(Ident),\n+    /// `self: TYPE`\n+    SelfExplicit(P<Ty>, Ident),\n }\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;"}, {"sha": "06eb92e1b271b1c1e333f7639be97b84a124aa02", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -25,8 +25,6 @@ use std::gc::Gc;\n \n /// The types of pointers\n pub enum PtrTy<'a> {\n-    /// ~\n-    Send,\n     /// &'lifetime mut\n     Borrowed(Option<&'a str>, ast::Mutability),\n }\n@@ -138,9 +136,6 @@ impl<'a> Ty<'a> {\n             Ptr(ref ty, ref ptr) => {\n                 let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);\n                 match *ptr {\n-                    Send => {\n-                        cx.ty_uniq(span, raw_ty)\n-                    }\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = mk_lifetime(cx, span, lt);\n                         cx.ty_rptr(span, raw_ty, lt, mutbl)\n@@ -260,7 +255,6 @@ pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n-                    Send => ast::SelfUniq(special_idents::self_),\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n                         ast::SelfRegion(lt, mutbl, special_idents::self_)"}, {"sha": "87c762af2e5bd63244c988c3215977108925b8e6", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -344,6 +344,7 @@ pub trait Folder {\n             SelfRegion(ref lifetime, m, id) => {\n                 SelfRegion(fold_opt_lifetime(lifetime, self), m, id)\n             }\n+            SelfExplicit(ref typ, id) => SelfExplicit(self.fold_ty(*typ), id),\n         }\n     }\n "}, {"sha": "bdfd928cfbcd8a5e22abaa9b66883f08fbb34195", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -45,7 +45,7 @@ use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub};\n use ast::StrStyle;\n-use ast::{SelfRegion, SelfStatic, SelfUniq, SelfValue};\n+use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfUniq, SelfValue};\n use ast::{TokenTree, TraitMethod, TraitRef, TTDelim, TTSeq, TTTok};\n use ast::{TTNonterminal, TupleVariantKind, Ty, Ty_, TyBot, TyBox};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n@@ -3843,15 +3843,25 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             token::IDENT(..) if self.is_self_ident() => {\n-                SelfValue(self.expect_self_ident())\n+                let self_ident = self.expect_self_ident();\n+\n+                // Determine whether this is the fully explicit form, `self:\n+                // TYPE`.\n+                if self.eat(&token::COLON) {\n+                    SelfExplicit(self.parse_ty(false), self_ident)\n+                } else {\n+                    SelfValue(self_ident)\n+                }\n             }\n             token::BINOP(token::STAR) => {\n                 // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n                 // emitting cryptic \"unexpected token\" errors.\n                 self.bump();\n                 let _mutability = if Parser::token_is_mutability(&self.token) {\n                     self.parse_mutability()\n-                } else { MutImmutable };\n+                } else {\n+                    MutImmutable\n+                };\n                 if self.is_self_ident() {\n                     let span = self.span;\n                     self.span_err(span, \"cannot pass self by unsafe pointer\");\n@@ -3863,7 +3873,15 @@ impl<'a> Parser<'a> {\n             _ if Parser::token_is_mutability(&self.token) &&\n                     self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) => {\n                 mutbl_self = self.parse_mutability();\n-                SelfValue(self.expect_self_ident())\n+                let self_ident = self.expect_self_ident();\n+\n+                // Determine whether this is the fully explicit form, `self:\n+                // TYPE`.\n+                if self.eat(&token::COLON) {\n+                    SelfExplicit(self.parse_ty(false), self_ident)\n+                } else {\n+                    SelfValue(self_ident)\n+                }\n             }\n             _ if Parser::token_is_mutability(&self.token) &&\n                     self.look_ahead(1, |t| *t == token::TILDE) &&\n@@ -3914,8 +3932,8 @@ impl<'a> Parser<'a> {\n             }\n             SelfValue(id) => parse_remaining_arguments!(id),\n             SelfRegion(_,_,id) => parse_remaining_arguments!(id),\n-            SelfUniq(id) => parse_remaining_arguments!(id)\n-\n+            SelfUniq(id) => parse_remaining_arguments!(id),\n+            SelfExplicit(_,id) => parse_remaining_arguments!(id),\n         };\n \n "}, {"sha": "428a15cb8cf746bc86a495dcaab509dd0d4e9799", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -1859,6 +1859,11 @@ impl<'a> State<'a> {\n                 try!(self.print_mutability(m));\n                 try!(word(&mut self.s, \"self\"));\n             }\n+            ast::SelfExplicit(ref typ, _) => {\n+                try!(word(&mut self.s, \"self\"));\n+                try!(self.word_space(\":\"));\n+                try!(self.print_type(*typ));\n+            }\n         }\n         return Ok(true);\n     }"}, {"sha": "6760d7a3932055bb7ae77de9c69431ab2149c46c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -215,6 +215,7 @@ pub fn walk_explicit_self<E: Clone, V: Visitor<E>>(visitor: &mut V,\n         SelfRegion(ref lifetime, _, _) => {\n             visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime, env)\n         }\n+        SelfExplicit(ref typ, _) => visitor.visit_ty(*typ, env.clone()),\n     }\n }\n "}, {"sha": "285792e26b1bf6678fb10fd737adb9e47edcab8f", "filename": "src/test/compile-fail/explicit-self-lifetime-mismatch.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<'a,'b> {\n+    x: &'a int,\n+    y: &'b int,\n+}\n+\n+impl<'a,'b> Foo<'a,'b> {\n+    // The number of errors is related to the way invariance works.\n+    fn bar(self: Foo<'b,'a>) {}\n+    //~^ ERROR mismatched types: expected `Foo<'a,'b>` but found `Foo<'b,'a>`\n+    //~^^ ERROR mismatched types: expected `Foo<'a,'b>` but found `Foo<'b,'a>`\n+    //~^^^ ERROR mismatched types: expected `Foo<'b,'a>` but found `Foo<'a,'b>`\n+    //~^^^^ ERROR mismatched types: expected `Foo<'b,'a>` but found `Foo<'a,'b>`\n+}\n+\n+fn main() {}\n+"}, {"sha": "57a158d2438dd98ab5b9efb0cf08fccc0b57d848", "filename": "src/test/compile-fail/issue-5153.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -11,11 +11,11 @@\n // error-pattern: type `&Foo` does not implement any method in scope named `foo`\n \n trait Foo {\n-    fn foo(~self);\n+    fn foo(self: Box<Self>);\n }\n \n impl Foo for int {\n-    fn foo(~self) { }\n+    fn foo(self: Box<int>) { }\n }\n \n fn main() {"}, {"sha": "fc19a1ba06f9b2324435ba2faa2d7d36cb2c38d3", "filename": "src/test/compile-fail/lint-unused-mut-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-self.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -16,7 +16,7 @@\n struct Foo;\n impl Foo {\n     fn foo(mut self) {} //~ ERROR: variable does not need to be mutable\n-    fn bar(mut ~self) {} //~ ERROR: variable does not need to be mutable\n+    fn bar(mut self: Box<Foo>) {} //~ ERROR: variable does not need to be mutable\n }\n \n fn main() {}"}, {"sha": "84e7f98a40dc2229bd04fa6b7a6efcd1f8b7ecb8", "filename": "src/test/compile-fail/object-pointer-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -13,7 +13,7 @@ trait Foo {\n     fn borrowed(&self);\n     fn borrowed_mut(&mut self);\n \n-    fn owned(~self);\n+    fn owned(self: Box<Self>);\n }\n \n fn borrowed_receiver(x: &Foo) {"}, {"sha": "e5bad7e31b81e41cc6ebca5ec971ccb48927f116", "filename": "src/test/compile-fail/ufcs-explicit-self-bad.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::owned::Box;\n+\n+struct Foo {\n+    f: int,\n+}\n+\n+impl Foo {\n+    fn foo(self: int, x: int) -> int {  //~ ERROR mismatched self type\n+//~^ ERROR not a valid type for `self`\n+        self.f + x\n+    }\n+}\n+\n+struct Bar<T> {\n+    f: T,\n+}\n+\n+impl<T> Bar<T> {\n+    fn foo(self: Bar<int>, x: int) -> int { //~ ERROR mismatched self type\n+//~^ ERROR not a valid type for `self`\n+        x\n+    }\n+    fn bar(self: &Bar<uint>, x: int) -> int {   //~ ERROR mismatched self type\n+//~^ ERROR not a valid type for `self`\n+        x\n+    }\n+}\n+\n+fn main() {\n+    let foo = box Foo {\n+        f: 1,\n+    };\n+    println!(\"{}\", foo.foo(2));\n+    let bar = box Bar {\n+        f: 1,\n+    };\n+    println!(\"{} {}\", bar.foo(2), bar.bar(2));\n+}\n+"}, {"sha": "2e43dcdeb498efe9599b35386b922dd65ad09696", "filename": "src/test/debuginfo/generic-method-on-generic-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-method-on-generic-struct.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -134,7 +134,7 @@ impl<T1> Struct<T1> {\n         arg1\n     }\n \n-    fn self_owned<T2>(~self, arg1: int, arg2: T2) -> int {\n+    fn self_owned<T2>(self: Box<Struct<T1>>, arg1: int, arg2: T2) -> int {\n         zzz(); // #break\n         arg1\n     }"}, {"sha": "74f4882bd4bf494918a01cb3515fcf98735a90c5", "filename": "src/test/debuginfo/method-on-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -136,7 +136,7 @@ impl Enum {\n         arg1 + arg2\n     }\n \n-    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+    fn self_owned(self: Box<Enum>, arg1: int, arg2: int) -> int {\n         zzz(); // #break\n         arg1 + arg2\n     }"}, {"sha": "590a821fcb6e10017d1af6240eca4af91613c925", "filename": "src/test/debuginfo/method-on-generic-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fmethod-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fmethod-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-generic-struct.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -134,7 +134,7 @@ impl<T> Struct<T> {\n         arg1 + arg2\n     }\n \n-    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+    fn self_owned(self: Box<Struct<T>>, arg1: int, arg2: int) -> int {\n         zzz(); // #break\n         arg1 + arg2\n     }"}, {"sha": "5ea89f1548915e520dca0b9accf293edf72759aa", "filename": "src/test/debuginfo/method-on-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fmethod-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fmethod-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-struct.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -133,7 +133,7 @@ impl Struct {\n         self.x + arg1 + arg2\n     }\n \n-    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+    fn self_owned(self: Box<Struct>, arg1: int, arg2: int) -> int {\n         zzz(); // #break\n         self.x + arg1 + arg2\n     }"}, {"sha": "1fc136ac1f695c95945871dbebc40f604cb1f5bb", "filename": "src/test/debuginfo/method-on-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fmethod-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fmethod-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-trait.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -124,7 +124,7 @@ struct Struct {\n trait Trait {\n     fn self_by_ref(&self, arg1: int, arg2: int) -> int;\n     fn self_by_val(self, arg1: int, arg2: int) -> int;\n-    fn self_owned(~self, arg1: int, arg2: int) -> int;\n+    fn self_owned(self: Box<Self>, arg1: int, arg2: int) -> int;\n }\n \n impl Trait for Struct {\n@@ -139,7 +139,7 @@ impl Trait for Struct {\n         self.x + arg1 + arg2\n     }\n \n-    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+    fn self_owned(self: Box<Struct>, arg1: int, arg2: int) -> int {\n         zzz(); // #break\n         self.x + arg1 + arg2\n     }"}, {"sha": "d4051e333c184319761c5e21e7853e2ed28f1529", "filename": "src/test/debuginfo/method-on-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-tuple-struct.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -131,7 +131,7 @@ impl TupleStruct {\n         arg1 + arg2\n     }\n \n-    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+    fn self_owned(self: Box<TupleStruct>, arg1: int, arg2: int) -> int {\n         zzz(); // #break\n         arg1 + arg2\n     }"}, {"sha": "4268c0adcc396f6408b976ab139c88009c10161f", "filename": "src/test/debuginfo/self-in-default-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fself-in-default-method.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -133,7 +133,7 @@ trait Trait {\n         arg1 + arg2\n     }\n \n-    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+    fn self_owned(self: Box<Self>, arg1: int, arg2: int) -> int {\n         zzz(); // #break\n         arg1 + arg2\n     }"}, {"sha": "35f3dffa0b63748fe64c1e66d1353768e2385450", "filename": "src/test/debuginfo/self-in-generic-default-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fself-in-generic-default-method.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -134,7 +134,7 @@ trait Trait {\n         arg1\n     }\n \n-    fn self_owned<T>(~self, arg1: int, arg2: T) -> int {\n+    fn self_owned<T>(self: Box<Self>, arg1: int, arg2: T) -> int {\n         zzz(); // #break\n         arg1\n     }"}, {"sha": "f13f598fda28c26032f3bf7bc96574e77392fb48", "filename": "src/test/run-pass/autoderef-method-on-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -10,11 +10,11 @@\n \n \n trait double {\n-    fn double(~self) -> uint;\n+    fn double(self: Box<Self>) -> uint;\n }\n \n impl double for uint {\n-    fn double(~self) -> uint { *self * 2u }\n+    fn double(self: Box<uint>) -> uint { *self * 2u }\n }\n \n pub fn main() {"}, {"sha": "856ee686db30e89c988c547aa97b6d6b5197ed7b", "filename": "src/test/run-pass/autoderef-method-twice-but-not-thrice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -10,11 +10,11 @@\n \n \n trait double {\n-    fn double(~self) -> uint;\n+    fn double(self: Box<Self>) -> uint;\n }\n \n impl double for Box<uint> {\n-    fn double(~self) -> uint { **self * 2u }\n+    fn double(self: Box<Box<uint>>) -> uint { **self * 2u }\n }\n \n pub fn main() {"}, {"sha": "94da61483eaaecf1f58f57996f2491c8b97a13ca", "filename": "src/test/run-pass/autoderef-method-twice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n trait double {\n-    fn double(~self) -> uint;\n+    fn double(self: Box<Self>) -> uint;\n }\n \n impl double for uint {\n-    fn double(~self) -> uint { *self * 2u }\n+    fn double(self: Box<uint>) -> uint { *self * 2u }\n }\n \n pub fn main() {"}, {"sha": "2e9751ce6acfccd405f527709718962891cf0898", "filename": "src/test/run-pass/autoderef-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n trait double {\n-    fn double(~self) -> uint;\n+    fn double(self: Box<Self>) -> uint;\n }\n \n impl double for uint {\n-    fn double(~self) -> uint { *self * 2u }\n+    fn double(self: Box<uint>) -> uint { *self * 2u }\n }\n \n pub fn main() {"}, {"sha": "e566f218aa8f61b02486073e7774071f545be693", "filename": "src/test/run-pass/explicit-self-objects-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-uniq.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -10,15 +10,15 @@\n \n \n trait Foo {\n-    fn f(~self);\n+    fn f(self: Box<Self>);\n }\n \n struct S {\n     x: int\n }\n \n impl Foo for S {\n-    fn f(~self) {\n+    fn f(self: Box<S>) {\n         assert_eq!(self.x, 3);\n     }\n }"}, {"sha": "32ac14ab18074ccdce1e5ae26191203bf5693874", "filename": "src/test/run-pass/explicit-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -57,7 +57,7 @@ fn thing(x: A) -> thing {\n }\n \n impl thing {\n-    pub fn bar(~self) -> int { self.x.a }\n+    pub fn bar(self: Box<thing>) -> int { self.x.a }\n     pub fn quux(&self) -> int { self.x.a }\n     pub fn baz<'a>(&'a self) -> &'a A { &self.x }\n     pub fn spam(self) -> int { self.x.a }"}, {"sha": "c7087f8e3a8ca5982663b681e72850ff75d27f26", "filename": "src/test/run-pass/issue-7320.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fissue-7320.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fissue-7320.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7320.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -10,7 +10,7 @@\n \n \n trait Foo {\n-    fn foo(~self) { bar(self as Box<Foo>); }\n+    fn foo(self: Box<Self>) { bar(self as Box<Foo>); }\n }\n \n fn bar(_b: Box<Foo>) { }"}, {"sha": "14ddc5d660f0cea9d71ab409c065643ce2aa3c2e", "filename": "src/test/run-pass/objects-owned-object-owned-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fobjects-owned-object-owned-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fobjects-owned-object-owned-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-owned-object-owned-method.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -14,15 +14,15 @@\n \n \n trait FooTrait {\n-    fn foo(~self) -> uint;\n+    fn foo(self: Box<Self>) -> uint;\n }\n \n struct BarStruct {\n     x: uint\n }\n \n impl FooTrait for BarStruct {\n-    fn foo(~self) -> uint {\n+    fn foo(self: Box<BarStruct>) -> uint {\n         self.x\n     }\n }"}, {"sha": "b4a46f34015a2455e78c0a27b74ff7e08d9550ea", "filename": "src/test/run-pass/self-in-mut-slot-default-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-default-method.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -19,7 +19,7 @@ trait Changer {\n         self\n     }\n \n-    fn change_again(mut ~self) -> Box<Self> {\n+    fn change_again(mut self: Box<Self>) -> Box<Self> {\n         self.set_to(45);\n         self\n     }"}, {"sha": "9ffb56c516af5de320a70be5787d21bdf1900869", "filename": "src/test/run-pass/ufcs-explicit-self.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fufcs-explicit-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Fufcs-explicit-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fufcs-explicit-self.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::owned::Box;\n+\n+struct Foo {\n+    f: int,\n+}\n+\n+impl Foo {\n+    fn foo(self: Foo, x: int) -> int {\n+        self.f + x\n+    }\n+    fn bar(self: &Foo, x: int) -> int {\n+        self.f + x\n+    }\n+    fn baz(self: Box<Foo>, x: int) -> int {\n+        self.f + x\n+    }\n+}\n+\n+struct Bar<T> {\n+    f: T,\n+}\n+\n+impl<T> Bar<T> {\n+    fn foo(self: Bar<T>, x: int) -> int {\n+        x\n+    }\n+    fn bar<'a>(self: &'a Bar<T>, x: int) -> int {\n+        x\n+    }\n+    fn baz(self: Bar<T>, x: int) -> int {\n+        x\n+    }\n+}\n+\n+fn main() {\n+    let foo = box Foo {\n+        f: 1,\n+    };\n+    println!(\"{} {} {}\", foo.foo(2), foo.bar(2), foo.baz(2));\n+    let bar = box Bar {\n+        f: 1,\n+    };\n+    println!(\"{} {} {}\", bar.foo(2), bar.bar(2), bar.baz(2));\n+    let bar: Box<Bar<int>> = bar;\n+    println!(\"{} {} {}\", bar.foo(2), bar.bar(2), bar.baz(2));\n+}\n+"}, {"sha": "4d7830e1cdca1ee70435b871410ca31d1cb1a7a0", "filename": "src/test/run-pass/uniq-self-in-mut-slot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Funiq-self-in-mut-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cb44bfff3facbded5fd9cc74af3f02e81565a8/src%2Ftest%2Frun-pass%2Funiq-self-in-mut-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-self-in-mut-slot.rs?ref=32cb44bfff3facbded5fd9cc74af3f02e81565a8", "patch": "@@ -14,11 +14,11 @@ struct X {\n }\n \n trait Changer {\n-    fn change(mut ~self) -> Box<Self>;\n+    fn change(mut self: Box<Self>) -> Box<Self>;\n }\n \n impl Changer for X {\n-    fn change(mut ~self) -> Box<X> {\n+    fn change(mut self: Box<X>) -> Box<X> {\n         self.a = 55;\n         self\n     }"}]}