{"sha": "022d20759baa6ebc9dcbe803aec1f19216c47d7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMmQyMDc1OWJhYTZlYmM5ZGNiZTgwM2FlYzFmMTkyMTZjNDdkN2Y=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-10-14T22:32:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-14T22:32:29Z"}, "message": "Rollup merge of #77739 - est31:remove_unused_code, r=petrochenkov,varkor\n\nRemove unused code\n\nRustc has a builtin lint for detecting unused code inside a crate, but when an item is marked `pub`, the code, even if unused inside the entire workspace, is never marked as such. Therefore, I've built [warnalyzer](https://github.com/est31/warnalyzer) to detect unused items in a cross-crate setting.\n\nCloses https://github.com/est31/warnalyzer/issues/2", "tree": {"sha": "d57199f3c4a32c27132387b159fbd01377c9fc05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d57199f3c4a32c27132387b159fbd01377c9fc05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/022d20759baa6ebc9dcbe803aec1f19216c47d7f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfh3x9CRBK7hj4Ov3rIwAAdHIIAEgJg3o9gQHVvcRcW9g0EDSX\nnqMm5hl5bSSzcJ1mNx7M7g9Vo33mIFoTS/Zg9mqL43INMrOocVvXvVeWgnV94Veg\nCCTRptiChdLtxPHZ30gFJ+I/MQrANfWf+iTkLA30Qr+5d/ZHRsmf4kioqEIcylqs\nE7x1qjRg8jgnJK6lCs2tK454oNgoXVSOwmaGFj8vxZBYYhjcXLWV7LcWXjPHqMO0\noRSsNX70jsbCn7FUZAJxWcXQis47Xl3hJjGAEfIyb18AmgIkiIj3SIqjFBAq5JLi\nxsDyIJmkyAfTg91sPQrozaew4UzqBTwQKV+SEtQSougOdPhZHY0gtJHoQrnTCiI=\n=3X/W\n-----END PGP SIGNATURE-----\n", "payload": "tree d57199f3c4a32c27132387b159fbd01377c9fc05\nparent 35210a66edcbea56765493bb6e85e55659b21e59\nparent 215cd36e1cff1806429806cb5be81f6d1a5f98b0\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1602714749 +0900\ncommitter GitHub <noreply@github.com> 1602714749 +0900\n\nRollup merge of #77739 - est31:remove_unused_code, r=petrochenkov,varkor\n\nRemove unused code\n\nRustc has a builtin lint for detecting unused code inside a crate, but when an item is marked `pub`, the code, even if unused inside the entire workspace, is never marked as such. Therefore, I've built [warnalyzer](https://github.com/est31/warnalyzer) to detect unused items in a cross-crate setting.\n\nCloses https://github.com/est31/warnalyzer/issues/2\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/022d20759baa6ebc9dcbe803aec1f19216c47d7f", "html_url": "https://github.com/rust-lang/rust/commit/022d20759baa6ebc9dcbe803aec1f19216c47d7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/022d20759baa6ebc9dcbe803aec1f19216c47d7f/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35210a66edcbea56765493bb6e85e55659b21e59", "url": "https://api.github.com/repos/rust-lang/rust/commits/35210a66edcbea56765493bb6e85e55659b21e59", "html_url": "https://github.com/rust-lang/rust/commit/35210a66edcbea56765493bb6e85e55659b21e59"}, {"sha": "215cd36e1cff1806429806cb5be81f6d1a5f98b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/215cd36e1cff1806429806cb5be81f6d1a5f98b0", "html_url": "https://github.com/rust-lang/rust/commit/215cd36e1cff1806429806cb5be81f6d1a5f98b0"}], "stats": {"total": 692, "additions": 8, "deletions": 684}, "files": [{"sha": "8f156aea2ff5be2e8c6cd3246bad44082f908e0a", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -167,13 +167,6 @@ pub enum GenericArgs {\n }\n \n impl GenericArgs {\n-    pub fn is_parenthesized(&self) -> bool {\n-        match *self {\n-            Parenthesized(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n     pub fn is_angle_bracketed(&self) -> bool {\n         match *self {\n             AngleBracketed(..) => true,\n@@ -857,13 +850,6 @@ impl BinOpKind {\n         }\n     }\n \n-    pub fn is_shift(&self) -> bool {\n-        match *self {\n-            BinOpKind::Shl | BinOpKind::Shr => true,\n-            _ => false,\n-        }\n-    }\n-\n     pub fn is_comparison(&self) -> bool {\n         use BinOpKind::*;\n         // Note for developers: please keep this as is;\n@@ -873,11 +859,6 @@ impl BinOpKind {\n             And | Or | Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr => false,\n         }\n     }\n-\n-    /// Returns `true` if the binary operator takes its arguments by value\n-    pub fn is_by_value(&self) -> bool {\n-        !self.is_comparison()\n-    }\n }\n \n pub type BinOp = Spanned<BinOpKind>;\n@@ -896,14 +877,6 @@ pub enum UnOp {\n }\n \n impl UnOp {\n-    /// Returns `true` if the unary operator takes its argument by value\n-    pub fn is_by_value(u: UnOp) -> bool {\n-        match u {\n-            UnOp::Neg | UnOp::Not => true,\n-            _ => false,\n-        }\n-    }\n-\n     pub fn to_string(op: UnOp) -> &'static str {\n         match op {\n             UnOp::Deref => \"*\",\n@@ -1753,13 +1726,6 @@ impl IntTy {\n         }\n     }\n \n-    pub fn val_to_string(&self, val: i128) -> String {\n-        // Cast to a `u128` so we can correctly print `INT128_MIN`. All integral types\n-        // are parsed as `u128`, so we wouldn't want to print an extra negative\n-        // sign.\n-        format!(\"{}{}\", val as u128, self.name_str())\n-    }\n-\n     pub fn bit_width(&self) -> Option<u64> {\n         Some(match *self {\n             IntTy::Isize => return None,\n@@ -1818,10 +1784,6 @@ impl UintTy {\n         }\n     }\n \n-    pub fn val_to_string(&self, val: u128) -> String {\n-        format!(\"{}{}\", val, self.name_str())\n-    }\n-\n     pub fn bit_width(&self) -> Option<u64> {\n         Some(match *self {\n             UintTy::Usize => return None,"}, {"sha": "8351be222f6bdd4b2dc81a077ff2619ff1923d7f", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -101,11 +101,6 @@ impl NestedMetaItem {\n         self.meta_item().is_some()\n     }\n \n-    /// Returns `true` if the variant is `Literal`.\n-    pub fn is_literal(&self) -> bool {\n-        self.literal().is_some()\n-    }\n-\n     /// Returns `true` if `self` is a `MetaItem` and the meta item is a word.\n     pub fn is_word(&self) -> bool {\n         self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n@@ -232,10 +227,6 @@ impl MetaItem {\n     pub fn is_value_str(&self) -> bool {\n         self.value_str().is_some()\n     }\n-\n-    pub fn is_meta_item_list(&self) -> bool {\n-        self.meta_item_list().is_some()\n-    }\n }\n \n impl AttrItem {"}, {"sha": "ad9c7391939a99b3a1f7c51e5fe800ab8f123515", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -54,16 +54,6 @@ pub enum DelimToken {\n     NoDelim,\n }\n \n-impl DelimToken {\n-    pub fn len(self) -> usize {\n-        if self == NoDelim { 0 } else { 1 }\n-    }\n-\n-    pub fn is_empty(self) -> bool {\n-        self == NoDelim\n-    }\n-}\n-\n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum LitKind {\n     Bool, // AST only, must never appear in a `Token`"}, {"sha": "8acb6b2f375898fbdadd4a79e0a2c256950b05db", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -295,12 +295,6 @@ impl TokenStream {\n                 .collect(),\n         ))\n     }\n-\n-    pub fn map<F: FnMut(TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n-        TokenStream(Lrc::new(\n-            self.0.iter().map(|(tree, is_joint)| (f(tree.clone()), *is_joint)).collect(),\n-        ))\n-    }\n }\n \n // 99.5%+ of the time we have 1 or 2 elements in this vector."}, {"sha": "be5516ef4718b3564514cb930c1aee6a9f022365", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -231,7 +231,6 @@ impl AssocOp {\n     }\n }\n \n-pub const PREC_RESET: i8 = -100;\n pub const PREC_CLOSURE: i8 = -40;\n pub const PREC_JUMP: i8 = -30;\n pub const PREC_RANGE: i8 = -10;"}, {"sha": "53a404ee019444f3e531c21aae4d540160fb457b", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -118,11 +118,6 @@ pub fn SetUnnamedAddress(global: &'a Value, unnamed: UnnamedAddr) {\n     }\n }\n \n-pub fn set_thread_local(global: &'a Value, is_thread_local: bool) {\n-    unsafe {\n-        LLVMSetThreadLocal(global, is_thread_local as Bool);\n-    }\n-}\n pub fn set_thread_local_mode(global: &'a Value, mode: ThreadLocalMode) {\n     unsafe {\n         LLVMSetThreadLocalMode(global, mode);"}, {"sha": "a586b37361e265e6db085b965e042c2f14aecc4a", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -1519,8 +1519,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     }\n }\n \n-pub const CODEGEN_WORKER_ID: usize = usize::MAX;\n-\n /// `FatalError` is explicitly not `Send`.\n #[must_use]\n pub struct WorkerFatalError;"}, {"sha": "9181f3b51a5509b1581102cd06d3062b326b2580", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -479,8 +479,6 @@ fn get_argc_argv<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-pub const CODEGEN_WORKER_ID: usize = usize::MAX;\n-\n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'tcx>,"}, {"sha": "cc562bc1e4d914be4eb6a707a6eae9233ea5b4a0", "filename": "compiler/rustc_data_structures/src/work_queue.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -14,12 +14,6 @@ pub struct WorkQueue<T: Idx> {\n }\n \n impl<T: Idx> WorkQueue<T> {\n-    /// Creates a new work queue with all the elements from (0..len).\n-    #[inline]\n-    pub fn with_all(len: usize) -> Self {\n-        WorkQueue { deque: (0..len).map(T::new).collect(), set: BitSet::new_filled(len) }\n-    }\n-\n     /// Creates a new work queue that starts empty, where elements range from (0..len).\n     #[inline]\n     pub fn with_none(len: usize) -> Self {"}, {"sha": "91bfc6296b1c7413c3bad5e98b6b7d4218faec1e", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -121,11 +121,6 @@ impl Diagnostic {\n         self.level == Level::Cancelled\n     }\n \n-    /// Set the sorting span.\n-    pub fn set_sort_span(&mut self, sp: Span) {\n-        self.sort_span = sp;\n-    }\n-\n     /// Adds a span/label to be included in the resulting snippet.\n     ///\n     /// This is pushed onto the [`MultiSpan`] that was created when the diagnostic\n@@ -535,14 +530,6 @@ impl Diagnostic {\n         &self.message\n     }\n \n-    /// Used by a lint. Copies over all details *but* the \"main\n-    /// message\".\n-    pub fn copy_details_not_message(&mut self, from: &Diagnostic) {\n-        self.span = from.span.clone();\n-        self.code = from.code.clone();\n-        self.children.extend(from.children.iter().cloned())\n-    }\n-\n     /// Convenience function for internal use, clients should use one of the\n     /// public methods above.\n     pub fn sub("}, {"sha": "b5155f8e910d7049654d6a2273ffdbca25a8c98f", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -510,8 +510,6 @@ impl Emitter for SilentEmitter {\n     fn emit_diagnostic(&mut self, _: &Diagnostic) {}\n }\n \n-/// Maximum number of lines we will print for each error; arbitrary.\n-pub const MAX_HIGHLIGHT_LINES: usize = 6;\n /// Maximum number of lines we will print for a multiline suggestion; arbitrary.\n ///\n /// This should be replaced with a more involved mechanism to output multiline suggestions that"}, {"sha": "b0e43a260e91de82cd5aaa6cbeb8f8f9f0bef87c", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -148,17 +148,6 @@ impl Annotatable {\n         }\n     }\n \n-    pub fn map_item_or<F, G>(self, mut f: F, mut or: G) -> Annotatable\n-    where\n-        F: FnMut(P<ast::Item>) -> P<ast::Item>,\n-        G: FnMut(Annotatable) -> Annotatable,\n-    {\n-        match self {\n-            Annotatable::Item(i) => Annotatable::Item(f(i)),\n-            _ => or(self),\n-        }\n-    }\n-\n     pub fn expect_trait_item(self) -> P<ast::AssocItem> {\n         match self {\n             Annotatable::TraitItem(i) => i,\n@@ -1052,9 +1041,6 @@ impl<'a> ExtCtxt<'a> {\n             .chain(components.iter().map(|&s| Ident::with_dummy_span(s)))\n             .collect()\n     }\n-    pub fn name_of(&self, st: &str) -> Symbol {\n-        Symbol::intern(st)\n-    }\n \n     pub fn check_unused_macros(&mut self) {\n         self.resolver.check_unused_macros();"}, {"sha": "1c9bfb902d61a95ae7da7e33e3dc123352d9b83a", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -139,24 +139,6 @@ impl<'a> ExtCtxt<'a> {\n         ast::Lifetime { id: ast::DUMMY_NODE_ID, ident: ident.with_span_pos(span) }\n     }\n \n-    pub fn lifetime_def(\n-        &self,\n-        span: Span,\n-        ident: Ident,\n-        attrs: Vec<ast::Attribute>,\n-        bounds: ast::GenericBounds,\n-    ) -> ast::GenericParam {\n-        let lifetime = self.lifetime(span, ident);\n-        ast::GenericParam {\n-            ident: lifetime.ident,\n-            id: lifetime.id,\n-            attrs: attrs.into(),\n-            bounds,\n-            kind: ast::GenericParamKind::Lifetime,\n-            is_placeholder: false,\n-        }\n-    }\n-\n     pub fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -465,24 +447,6 @@ impl<'a> ExtCtxt<'a> {\n         self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n-    pub fn pat_none(&self, span: Span) -> P<ast::Pat> {\n-        let some = self.std_path(&[sym::option, sym::Option, sym::None]);\n-        let path = self.path_global(span, some);\n-        self.pat_path(span, path)\n-    }\n-\n-    pub fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        let some = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n-        let path = self.path_global(span, some);\n-        self.pat_tuple_struct(span, path, vec![pat])\n-    }\n-\n-    pub fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        let some = self.std_path(&[sym::result, sym::Result, sym::Err]);\n-        let path = self.path_global(span, some);\n-        self.pat_tuple_struct(span, path, vec![pat])\n-    }\n-\n     pub fn arm(&self, span: Span, pat: P<ast::Pat>, expr: P<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n             attrs: vec![],\n@@ -514,26 +478,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr(span, ast::ExprKind::If(cond, self.block_expr(then), els))\n     }\n \n-    pub fn lambda_fn_decl(\n-        &self,\n-        span: Span,\n-        fn_decl: P<ast::FnDecl>,\n-        body: P<ast::Expr>,\n-        fn_decl_span: Span,\n-    ) -> P<ast::Expr> {\n-        self.expr(\n-            span,\n-            ast::ExprKind::Closure(\n-                ast::CaptureBy::Ref,\n-                ast::Async::No,\n-                ast::Movability::Movable,\n-                fn_decl,\n-                body,\n-                fn_decl_span,\n-            ),\n-        )\n-    }\n-\n     pub fn lambda(&self, span: Span, ids: Vec<Ident>, body: P<ast::Expr>) -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.param(span, *id, self.ty(span, ast::TyKind::Infer))).collect(),\n@@ -610,47 +554,6 @@ impl<'a> ExtCtxt<'a> {\n         })\n     }\n \n-    pub fn variant(&self, span: Span, ident: Ident, tys: Vec<P<ast::Ty>>) -> ast::Variant {\n-        let vis_span = span.shrink_to_lo();\n-        let fields: Vec<_> = tys\n-            .into_iter()\n-            .map(|ty| ast::StructField {\n-                span: ty.span,\n-                ty,\n-                ident: None,\n-                vis: ast::Visibility {\n-                    span: vis_span,\n-                    kind: ast::VisibilityKind::Inherited,\n-                    tokens: None,\n-                },\n-                attrs: Vec::new(),\n-                id: ast::DUMMY_NODE_ID,\n-                is_placeholder: false,\n-            })\n-            .collect();\n-\n-        let vdata = if fields.is_empty() {\n-            ast::VariantData::Unit(ast::DUMMY_NODE_ID)\n-        } else {\n-            ast::VariantData::Tuple(fields, ast::DUMMY_NODE_ID)\n-        };\n-\n-        ast::Variant {\n-            attrs: Vec::new(),\n-            data: vdata,\n-            disr_expr: None,\n-            id: ast::DUMMY_NODE_ID,\n-            ident,\n-            vis: ast::Visibility {\n-                span: vis_span,\n-                kind: ast::VisibilityKind::Inherited,\n-                tokens: None,\n-            },\n-            span,\n-            is_placeholder: false,\n-        }\n-    }\n-\n     pub fn item_static(\n         &self,\n         span: Span,"}, {"sha": "7742961e65dbb6198fa9d69a0deed5d8d0e71611", "filename": "compiler/rustc_fs_util/src/lib.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -75,33 +75,6 @@ pub fn link_or_copy<P: AsRef<Path>, Q: AsRef<Path>>(p: P, q: Q) -> io::Result<Li\n     }\n }\n \n-#[derive(Debug)]\n-pub enum RenameOrCopyRemove {\n-    Rename,\n-    CopyRemove,\n-}\n-\n-/// Rename `p` into `q`, preferring to use `rename` if possible.\n-/// If `rename` fails (rename may fail for reasons such as crossing\n-/// filesystem), fallback to copy & remove\n-pub fn rename_or_copy_remove<P: AsRef<Path>, Q: AsRef<Path>>(\n-    p: P,\n-    q: Q,\n-) -> io::Result<RenameOrCopyRemove> {\n-    let p = p.as_ref();\n-    let q = q.as_ref();\n-    match fs::rename(p, q) {\n-        Ok(()) => Ok(RenameOrCopyRemove::Rename),\n-        Err(_) => match fs::copy(p, q) {\n-            Ok(_) => {\n-                fs::remove_file(p)?;\n-                Ok(RenameOrCopyRemove::CopyRemove)\n-            }\n-            Err(e) => Err(e),\n-        },\n-    }\n-}\n-\n #[cfg(unix)]\n pub fn path_to_c_string(p: &Path) -> CString {\n     use std::ffi::OsStr;"}, {"sha": "3f109376a3e34829ac6af07acc02f7acf31c4192", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -188,10 +188,6 @@ pub struct DefPath {\n }\n \n impl DefPath {\n-    pub fn is_local(&self) -> bool {\n-        self.krate == LOCAL_CRATE\n-    }\n-\n     pub fn make<FN>(krate: CrateNum, start_index: DefIndex, mut get_key: FN) -> DefPath\n     where\n         FN: FnMut(DefIndex) -> DefKey,"}, {"sha": "2141d5b1ee7b666777282ab3d74a5b4d10ac1f4b", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -3,7 +3,6 @@ use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n use crate::{itemlikevisit, LangItem};\n \n-use rustc_ast::node_id::NodeMap;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_ast::{self as ast, CrateSugar, LlvmAsmDialect};\n use rustc_ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n@@ -306,10 +305,6 @@ impl GenericArgs<'_> {\n         Self { args: &[], bindings: &[], parenthesized: false }\n     }\n \n-    pub fn is_empty(&self) -> bool {\n-        self.args.is_empty() && self.bindings.is_empty() && !self.parenthesized\n-    }\n-\n     pub fn inputs(&self) -> &[Ty<'_>] {\n         if self.parenthesized {\n             for arg in self.args {\n@@ -467,23 +462,6 @@ impl Generics<'hir> {\n         }\n     }\n \n-    pub fn own_counts(&self) -> GenericParamCount {\n-        // We could cache this as a property of `GenericParamCount`, but\n-        // the aim is to refactor this away entirely eventually and the\n-        // presence of this method will be a constant reminder.\n-        let mut own_counts: GenericParamCount = Default::default();\n-\n-        for param in self.params {\n-            match param.kind {\n-                GenericParamKind::Lifetime { .. } => own_counts.lifetimes += 1,\n-                GenericParamKind::Type { .. } => own_counts.types += 1,\n-                GenericParamKind::Const { .. } => own_counts.consts += 1,\n-            };\n-        }\n-\n-        own_counts\n-    }\n-\n     pub fn get_named(&self, name: Symbol) -> Option<&GenericParam<'_>> {\n         for param in self.params {\n             if name == param.name.ident().name {\n@@ -2679,8 +2657,6 @@ pub struct Upvar {\n     pub span: Span,\n }\n \n-pub type CaptureModeMap = NodeMap<CaptureBy>;\n-\n // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used.\n@@ -2766,32 +2742,4 @@ impl<'hir> Node<'hir> {\n             _ => None,\n         }\n     }\n-\n-    pub fn hir_id(&self) -> Option<HirId> {\n-        match self {\n-            Node::Item(Item { hir_id, .. })\n-            | Node::ForeignItem(ForeignItem { hir_id, .. })\n-            | Node::TraitItem(TraitItem { hir_id, .. })\n-            | Node::ImplItem(ImplItem { hir_id, .. })\n-            | Node::Field(StructField { hir_id, .. })\n-            | Node::AnonConst(AnonConst { hir_id, .. })\n-            | Node::Expr(Expr { hir_id, .. })\n-            | Node::Stmt(Stmt { hir_id, .. })\n-            | Node::Ty(Ty { hir_id, .. })\n-            | Node::Binding(Pat { hir_id, .. })\n-            | Node::Pat(Pat { hir_id, .. })\n-            | Node::Arm(Arm { hir_id, .. })\n-            | Node::Block(Block { hir_id, .. })\n-            | Node::Local(Local { hir_id, .. })\n-            | Node::MacroDef(MacroDef { hir_id, .. })\n-            | Node::Lifetime(Lifetime { hir_id, .. })\n-            | Node::Param(Param { hir_id, .. })\n-            | Node::GenericParam(GenericParam { hir_id, .. }) => Some(*hir_id),\n-            Node::TraitRef(TraitRef { hir_ref_id, .. }) => Some(*hir_ref_id),\n-            Node::PathSegment(PathSegment { hir_id, .. }) => *hir_id,\n-            Node::Variant(Variant { id, .. }) => Some(*id),\n-            Node::Ctor(variant) => variant.ctor_hir_id(),\n-            Node::Crate(_) | Node::Visibility(_) => None,\n-        }\n-    }\n }"}, {"sha": "cc8ac4cf5be51bdda772dffefb22e27db3066e05", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -45,5 +45,3 @@ pub const CRATE_HIR_ID: HirId = HirId {\n     owner: LocalDefId { local_def_index: CRATE_DEF_INDEX },\n     local_id: ItemLocalId::from_u32(0),\n };\n-\n-pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId::MAX;"}, {"sha": "c05d3e44423cff20a2f73cbb0c4a3dde073c0c5d", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -58,25 +58,6 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n }\n \n impl hir::Pat<'_> {\n-    pub fn is_refutable(&self) -> bool {\n-        match self.kind {\n-            PatKind::Lit(_)\n-            | PatKind::Range(..)\n-            | PatKind::Path(hir::QPath::Resolved(Some(..), _) | hir::QPath::TypeRelative(..)) => {\n-                true\n-            }\n-\n-            PatKind::Path(hir::QPath::Resolved(_, ref path))\n-            | PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..)\n-            | PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => match path.res {\n-                Res::Def(DefKind::Variant, _) => true,\n-                _ => false,\n-            },\n-            PatKind::Slice(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n     /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n     /// `match foo() { Some(a) => (), None => () }`\n     pub fn each_binding(&self, mut f: impl FnMut(hir::BindingAnnotation, HirId, Span, Ident)) {\n@@ -117,15 +98,6 @@ impl hir::Pat<'_> {\n         })\n     }\n \n-    /// Checks if the pattern contains any patterns that bind something to\n-    /// an ident or wildcard, e.g., `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n-    pub fn contains_bindings_or_wild(&self) -> bool {\n-        self.satisfies(|p| match p.kind {\n-            PatKind::Binding(..) | PatKind::Wild => true,\n-            _ => false,\n-        })\n-    }\n-\n     /// Checks if the pattern satisfies the given predicate on some sub-pattern.\n     fn satisfies(&self, pred: impl Fn(&hir::Pat<'_>) -> bool) -> bool {\n         let mut satisfies = false;"}, {"sha": "57a38adc169134993f07b958ce15bef00d6dd9d1", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -44,19 +44,13 @@ pub trait PpAnn {\n     fn nested(&self, _state: &mut State<'_>, _nested: Nested) {}\n     fn pre(&self, _state: &mut State<'_>, _node: AnnNode<'_>) {}\n     fn post(&self, _state: &mut State<'_>, _node: AnnNode<'_>) {}\n-    fn try_fetch_item(&self, _: hir::HirId) -> Option<&hir::Item<'_>> {\n-        None\n-    }\n }\n \n pub struct NoAnn;\n impl PpAnn for NoAnn {}\n pub const NO_ANN: &dyn PpAnn = &NoAnn;\n \n impl PpAnn for hir::Crate<'_> {\n-    fn try_fetch_item(&self, item: hir::HirId) -> Option<&hir::Item<'_>> {\n-        Some(self.item(item))\n-    }\n     fn nested(&self, state: &mut State<'_>, nested: Nested) {\n         match nested {\n             Nested::Item(id) => state.print_item(self.item(id.id)),"}, {"sha": "ff7bbf0562f605ddef2734bc25b6420d8afc97da", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -113,13 +113,6 @@ impl Default for RegionckMode {\n }\n \n impl RegionckMode {\n-    pub fn suppressed(self) -> bool {\n-        match self {\n-            Self::Solve => false,\n-            Self::Erase { suppress_errors } => suppress_errors,\n-        }\n-    }\n-\n     /// Indicates that the MIR borrowck will repeat these region\n     /// checks, so we should ignore errors if NLL is (unconditionally)\n     /// enabled.\n@@ -420,15 +413,6 @@ pub enum SubregionOrigin<'tcx> {\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(SubregionOrigin<'_>, 32);\n \n-/// Places that type/region parameters can appear.\n-#[derive(Clone, Copy, Debug)]\n-pub enum ParameterOrigin {\n-    Path,               // foo::bar\n-    MethodCall,         // foo.bar() <-- parameters on impl providing bar()\n-    OverloadedOperator, // a + b when overloaded\n-    OverloadedDeref,    // *a when overloaded\n-}\n-\n /// Times when we replace late-bound regions with variables:\n #[derive(Clone, Copy, Debug)]\n pub enum LateBoundRegionConversionTime {\n@@ -508,21 +492,6 @@ pub enum NLLRegionVariableOrigin {\n     },\n }\n \n-impl NLLRegionVariableOrigin {\n-    pub fn is_universal(self) -> bool {\n-        match self {\n-            NLLRegionVariableOrigin::FreeRegion => true,\n-            NLLRegionVariableOrigin::Placeholder(..) => true,\n-            NLLRegionVariableOrigin::Existential { .. } => false,\n-            NLLRegionVariableOrigin::RootEmptyRegion => false,\n-        }\n-    }\n-\n-    pub fn is_existential(self) -> bool {\n-        !self.is_universal()\n-    }\n-}\n-\n // FIXME(eddyb) investigate overlap between this and `TyOrConstInferVar`.\n #[derive(Copy, Clone, Debug)]\n pub enum FixupError<'tcx> {"}, {"sha": "2fb9f638e360833ffe8ba2ad4614800b73ba1c49", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -28,7 +28,6 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::subst::GenericArg;\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n use std::fmt::Debug;\n \n@@ -119,12 +118,6 @@ pub trait TypeRelatingDelegate<'tcx> {\n     fn forbid_inference_vars() -> bool;\n }\n \n-#[derive(Clone, Debug)]\n-struct ScopesAndKind<'tcx> {\n-    scopes: Vec<BoundRegionScope<'tcx>>,\n-    kind: GenericArg<'tcx>,\n-}\n-\n #[derive(Clone, Debug, Default)]\n struct BoundRegionScope<'tcx> {\n     map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,"}, {"sha": "aaf5e958c269d783658fcfd3914147f4eaca9c93", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -59,9 +59,7 @@ pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(PredicateObligation<'_>, 32);\n \n-pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n-pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n pub type Selection<'tcx> = ImplSource<'tcx, PredicateObligation<'tcx>>;\n "}, {"sha": "48270eb59a0500a9bd4945795549902cf92fa624", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -711,10 +711,6 @@ impl<'tcx> LateContext<'tcx> {\n         }\n     }\n \n-    pub fn current_lint_root(&self) -> hir::HirId {\n-        self.last_node_with_lint_attrs\n-    }\n-\n     /// Check if a `DefId`'s path matches the given absolute type path usage.\n     ///\n     /// Anonymous scopes such as `extern` imports are matched with `kw::Invalid`;"}, {"sha": "b01a55b48da667a6f4b4e97e772182e2fe251fdb", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -313,27 +313,6 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n         Ok(ty)\n     }\n \n-    fn cached_predicate_for_shorthand<F>(\n-        &mut self,\n-        shorthand: usize,\n-        or_insert_with: F,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>,\n-    {\n-        let tcx = self.tcx();\n-\n-        let key = ty::CReaderCacheKey { cnum: self.cdata().cnum, pos: shorthand };\n-\n-        if let Some(&pred) = tcx.pred_rcache.borrow().get(&key) {\n-            return Ok(pred);\n-        }\n-\n-        let pred = or_insert_with(self)?;\n-        tcx.pred_rcache.borrow_mut().insert(key, pred);\n-        Ok(pred)\n-    }\n-\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,"}, {"sha": "254b57a005e8e7438148954c9e17fd05cc50321c", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -3,7 +3,6 @@\n //! which are available for use externally when compiled as a library.\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefIdSet;\n use rustc_hir::HirId;\n use rustc_macros::HashStable;\n use std::fmt;\n@@ -59,7 +58,3 @@ impl<Id: Hash + Eq + fmt::Debug> fmt::Debug for AccessLevels<Id> {\n         fmt::Debug::fmt(&self.map, f)\n     }\n }\n-\n-/// A set containing all exported definitions from external crates.\n-/// The set does not contain any entries from local crates.\n-pub type ExternalExports = DefIdSet;"}, {"sha": "cb8782ce8170a4e61655a0cc10b0f51034291edb", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -56,15 +56,6 @@ impl<'tcx> ConstValue<'tcx> {\n         }\n     }\n \n-    pub fn try_to_str_slice(&self) -> Option<&'tcx str> {\n-        if let ConstValue::Slice { data, start, end } = *self {\n-            std::str::from_utf8(data.inspect_with_uninit_and_ptr_outside_interpreter(start..end))\n-                .ok()\n-        } else {\n-            None\n-        }\n-    }\n-\n     pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n         self.try_to_scalar()?.to_bits(size).ok()\n     }"}, {"sha": "16472c787572c8f614ea7833d40c84107700da0a", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -3,7 +3,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n use crate::mir::coverage::{CodeRegion, CoverageKind};\n-use crate::mir::interpret::{Allocation, ConstValue, GlobalAlloc, Scalar};\n+use crate::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -460,17 +460,6 @@ impl<'tcx> Body<'tcx> {\n         }\n     }\n \n-    /// Checks if `sub` is a sub scope of `sup`\n-    pub fn is_sub_scope(&self, mut sub: SourceScope, sup: SourceScope) -> bool {\n-        while sub != sup {\n-            match self.source_scopes[sub].parent_scope {\n-                None => return false,\n-                Some(p) => sub = p,\n-            }\n-        }\n-        true\n-    }\n-\n     /// Returns the return type; it always return first element from `local_decls` array.\n     #[inline]\n     pub fn return_ty(&self) -> Ty<'tcx> {\n@@ -1978,45 +1967,6 @@ impl<'tcx> Operand<'tcx> {\n         })\n     }\n \n-    /// Convenience helper to make a `Scalar` from the given `Operand`, assuming that `Operand`\n-    /// wraps a constant literal value. Panics if this is not the case.\n-    pub fn scalar_from_const(operand: &Operand<'tcx>) -> Scalar {\n-        match operand {\n-            Operand::Constant(constant) => match constant.literal.val.try_to_scalar() {\n-                Some(scalar) => scalar,\n-                _ => panic!(\"{:?}: Scalar value expected\", constant.literal.val),\n-            },\n-            _ => panic!(\"{:?}: Constant expected\", operand),\n-        }\n-    }\n-\n-    /// Convenience helper to make a literal-like constant from a given `&str` slice.\n-    /// Since this is used to synthesize MIR, assumes `user_ty` is None.\n-    pub fn const_from_str(tcx: TyCtxt<'tcx>, val: &str, span: Span) -> Operand<'tcx> {\n-        let tcx = tcx;\n-        let allocation = Allocation::from_byte_aligned_bytes(val.as_bytes());\n-        let allocation = tcx.intern_const_alloc(allocation);\n-        let const_val = ConstValue::Slice { data: allocation, start: 0, end: val.len() };\n-        let ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, tcx.types.str_);\n-        Operand::Constant(box Constant {\n-            span,\n-            user_ty: None,\n-            literal: ty::Const::from_value(tcx, const_val, ty),\n-        })\n-    }\n-\n-    /// Convenience helper to make a `ConstValue` from the given `Operand`, assuming that `Operand`\n-    /// wraps a constant value (such as a `&str` slice). Panics if this is not the case.\n-    pub fn value_from_const(operand: &Operand<'tcx>) -> ConstValue<'tcx> {\n-        match operand {\n-            Operand::Constant(constant) => match constant.literal.val.try_to_value() {\n-                Some(const_value) => const_value,\n-                _ => panic!(\"{:?}: ConstValue expected\", constant.literal.val),\n-            },\n-            _ => panic!(\"{:?}: Constant expected\", operand),\n-        }\n-    }\n-\n     pub fn to_copy(&self) -> Self {\n         match *self {\n             Operand::Copy(_) | Operand::Constant(_) => self.clone(),\n@@ -2413,10 +2363,6 @@ impl<'tcx> UserTypeProjections {\n         self.contents.is_empty()\n     }\n \n-    pub fn from_projections(projs: impl Iterator<Item = (UserTypeProjection, Span)>) -> Self {\n-        UserTypeProjections { contents: projs.collect() }\n-    }\n-\n     pub fn projections_and_spans(\n         &self,\n     ) -> impl Iterator<Item = &(UserTypeProjection, Span)> + ExactSizeIterator {"}, {"sha": "6022194342d02961a8dfa7fa4a475d0f04134fe6", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -413,18 +413,6 @@ pub struct CoverageInfo {\n /// For more information on why this is needed, consider looking\n /// at the docs for `WithOptConstParam` itself.\n impl<'tcx> TyCtxt<'tcx> {\n-    #[inline]\n-    pub fn mir_borrowck_opt_const_arg(\n-        self,\n-        def: ty::WithOptConstParam<LocalDefId>,\n-    ) -> &'tcx BorrowCheckResult<'tcx> {\n-        if let Some(param_did) = def.const_param_did {\n-            self.mir_borrowck_const_arg((def.did, param_did))\n-        } else {\n-            self.mir_borrowck(def.did)\n-        }\n-    }\n-\n     #[inline]\n     pub fn mir_const_qualif_opt_const_arg(\n         self,"}, {"sha": "58dd0bc00d2040eb761367ee091ebc3cc91ffe53", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -1186,16 +1186,6 @@ impl PlaceContext {\n         )\n     }\n \n-    /// Returns `true` if this place context represents a storage live marker.\n-    pub fn is_storage_live_marker(&self) -> bool {\n-        matches!(self, PlaceContext::NonUse(NonUseContext::StorageLive))\n-    }\n-\n-    /// Returns `true` if this place context represents a storage dead marker.\n-    pub fn is_storage_dead_marker(&self) -> bool {\n-        matches!(self, PlaceContext::NonUse(NonUseContext::StorageDead))\n-    }\n-\n     /// Returns `true` if this place context represents a use that potentially changes the value.\n     pub fn is_mutating_use(&self) -> bool {\n         matches!(self, PlaceContext::MutatingUse(..))"}, {"sha": "aaf6a8570437cf953731d11110a8beaf2a78b5bc", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -182,14 +182,6 @@ pub trait TyDecoder<'tcx>: Decoder {\n     where\n         F: FnOnce(&mut Self) -> Result<Ty<'tcx>, Self::Error>;\n \n-    fn cached_predicate_for_shorthand<F>(\n-        &mut self,\n-        shorthand: usize,\n-        or_insert_with: F,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>;\n-\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R;"}, {"sha": "2e794128eaca06ed17147b9b29c482196fe00634", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -534,10 +534,6 @@ impl<'tcx> TypeckResults<'tcx> {\n         self.node_type(pat.hir_id)\n     }\n \n-    pub fn pat_ty_opt(&self, pat: &hir::Pat<'_>) -> Option<Ty<'tcx>> {\n-        self.node_type_opt(pat.hir_id)\n-    }\n-\n     // Returns the type of an expression as a monotype.\n     //\n     // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in"}, {"sha": "5524d91a6d5331f7b71de2c2bd53062948236843", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 6, "deletions": 45, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -97,9 +97,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_infer_types_or_consts(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_CT_INFER)\n     }\n-    fn has_infer_consts(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_CT_INFER)\n-    }\n     fn needs_infer(&self) -> bool {\n         self.has_type_flags(TypeFlags::NEEDS_INFER)\n     }\n@@ -113,9 +110,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn needs_subst(&self) -> bool {\n         self.has_type_flags(TypeFlags::NEEDS_SUBST)\n     }\n-    fn has_re_placeholders(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_RE_PLACEHOLDER)\n-    }\n     /// \"Free\" regions in this context means that it has any region\n     /// that is not (a) erased or (b) late-bound.\n     fn has_free_regions(&self) -> bool {\n@@ -719,21 +713,15 @@ impl<'tcx> TyCtxt<'tcx> {\n // vars. See comment on `shift_vars_through_binders` method in\n // `subst.rs` for more details.\n \n-enum Direction {\n-    In,\n-    Out,\n-}\n-\n struct Shifter<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     current_index: ty::DebruijnIndex,\n     amount: u32,\n-    direction: Direction,\n }\n \n impl Shifter<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, amount: u32, direction: Direction) -> Self {\n-        Shifter { tcx, current_index: ty::INNERMOST, amount, direction }\n+    pub fn new(tcx: TyCtxt<'tcx>, amount: u32) -> Self {\n+        Shifter { tcx, current_index: ty::INNERMOST, amount }\n     }\n }\n \n@@ -755,13 +743,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     r\n                 } else {\n-                    let debruijn = match self.direction {\n-                        Direction::In => debruijn.shifted_in(self.amount),\n-                        Direction::Out => {\n-                            assert!(debruijn.as_u32() >= self.amount);\n-                            debruijn.shifted_out(self.amount)\n-                        }\n-                    };\n+                    let debruijn = debruijn.shifted_in(self.amount);\n                     let shifted = ty::ReLateBound(debruijn, br);\n                     self.tcx.mk_region(shifted)\n                 }\n@@ -776,13 +758,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     ty\n                 } else {\n-                    let debruijn = match self.direction {\n-                        Direction::In => debruijn.shifted_in(self.amount),\n-                        Direction::Out => {\n-                            assert!(debruijn.as_u32() >= self.amount);\n-                            debruijn.shifted_out(self.amount)\n-                        }\n-                    };\n+                    let debruijn = debruijn.shifted_in(self.amount);\n                     self.tcx.mk_ty(ty::Bound(debruijn, bound_ty))\n                 }\n             }\n@@ -796,13 +772,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n             if self.amount == 0 || debruijn < self.current_index {\n                 ct\n             } else {\n-                let debruijn = match self.direction {\n-                    Direction::In => debruijn.shifted_in(self.amount),\n-                    Direction::Out => {\n-                        assert!(debruijn.as_u32() >= self.amount);\n-                        debruijn.shifted_out(self.amount)\n-                    }\n-                };\n+                let debruijn = debruijn.shifted_in(self.amount);\n                 self.tcx.mk_const(ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty })\n             }\n         } else {\n@@ -830,16 +800,7 @@ where\n {\n     debug!(\"shift_vars(value={:?}, amount={})\", value, amount);\n \n-    value.fold_with(&mut Shifter::new(tcx, amount, Direction::In))\n-}\n-\n-pub fn shift_out_vars<'tcx, T>(tcx: TyCtxt<'tcx>, value: &T, amount: u32) -> T\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    debug!(\"shift_out_vars(value={:?}, amount={})\", value, amount);\n-\n-    value.fold_with(&mut Shifter::new(tcx, amount, Direction::Out))\n+    value.fold_with(&mut Shifter::new(tcx, amount))\n }\n \n /// An \"escaping var\" is a bound var whose binder is not part of `t`. A bound var can be a"}, {"sha": "bf1f5b81c9fd1c1b2d734df02684d5c008a366f2", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -104,14 +104,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         // ```\n         ty.uninhabited_from(self, param_env).contains(self, module)\n     }\n-\n-    pub fn is_ty_uninhabited_from_any_module(\n-        self,\n-        ty: Ty<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n-        !ty.uninhabited_from(self, param_env).is_empty()\n-    }\n }\n \n impl<'tcx> AdtDef {"}, {"sha": "275888b0ce24752c32a3aa8a8de9f9e071377af8", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -7,7 +7,6 @@ pub use self::Variance::*;\n \n use crate::hir::exports::ExportMap;\n use crate::ich::StableHashingContext;\n-use crate::infer::canonical::Canonical;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n use crate::mir::interpret::ErrorHandled;\n@@ -656,8 +655,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n #[rustc_diagnostic_item = \"Ty\"]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct UpvarPath {\n     pub hir_id: hir::HirId,\n@@ -767,10 +764,6 @@ pub enum IntVarValue {\n pub struct FloatVarValue(pub ast::FloatTy);\n \n impl ty::EarlyBoundRegion {\n-    pub fn to_bound_region(&self) -> ty::BoundRegion {\n-        ty::BoundRegion::BrNamed(self.def_id, self.name)\n-    }\n-\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`).\n     pub fn has_name(&self) -> bool {\n@@ -821,14 +814,6 @@ impl GenericParamDef {\n             bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n         }\n     }\n-\n-    pub fn to_bound_region(&self) -> ty::BoundRegion {\n-        if let GenericParamDefKind::Lifetime = self.kind {\n-            self.to_early_bound_region_data().to_bound_region()\n-        } else {\n-            bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n-        }\n-    }\n }\n \n #[derive(Default)]\n@@ -1003,22 +988,6 @@ impl<'tcx> GenericPredicates<'tcx> {\n         instantiated.predicates.extend(self.predicates.iter().map(|(p, _)| p));\n         instantiated.spans.extend(self.predicates.iter().map(|(_, s)| s));\n     }\n-\n-    pub fn instantiate_supertrait(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        poly_trait_ref: &ty::PolyTraitRef<'tcx>,\n-    ) -> InstantiatedPredicates<'tcx> {\n-        assert_eq!(self.parent, None);\n-        InstantiatedPredicates {\n-            predicates: self\n-                .predicates\n-                .iter()\n-                .map(|(pred, _)| pred.subst_supertrait(tcx, poly_trait_ref))\n-                .collect(),\n-            spans: self.predicates.iter().map(|(_, sp)| *sp).collect(),\n-        }\n-    }\n }\n \n #[derive(Debug)]\n@@ -1303,7 +1272,6 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n-pub type PolyOutlivesPredicate<A, B> = ty::Binder<OutlivesPredicate<A, B>>;\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>;\n pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;"}, {"sha": "173e9a31928b5d89f0dfbf56a8abc7569098bc87", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -601,29 +601,6 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n         Ok(ty)\n     }\n \n-    fn cached_predicate_for_shorthand<F>(\n-        &mut self,\n-        shorthand: usize,\n-        or_insert_with: F,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>,\n-    {\n-        let tcx = self.tcx();\n-\n-        let cache_key =\n-            ty::CReaderCacheKey { cnum: CrateNum::ReservedForIncrCompCache, pos: shorthand };\n-\n-        if let Some(&pred) = tcx.pred_rcache.borrow().get(&cache_key) {\n-            return Ok(pred);\n-        }\n-\n-        let pred = or_insert_with(self)?;\n-        // This may overwrite the entry, but it should overwrite with the same value.\n-        tcx.pred_rcache.borrow_mut().insert_same(cache_key, pred);\n-        Ok(pred)\n-    }\n-\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,"}, {"sha": "7d96adb7c8b4e41373726d3d0c122c6c6cecc5e7", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -1,6 +1,5 @@\n // Type substitutions.\n \n-use crate::infer::canonical::Canonical;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts};\n@@ -648,8 +647,6 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n     }\n }\n \n-pub type CanonicalUserSubsts<'tcx> = Canonical<'tcx, UserSubsts<'tcx>>;\n-\n /// Stores the user-given substs to reach some fully qualified path\n /// (e.g., `<T>::Item` or `<T as Trait>::Item`).\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]"}, {"sha": "1b7264f86a2d159348da7d67d0e24c944ef59f56", "filename": "compiler/rustc_mir/src/dataflow/framework/engine.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -62,15 +62,6 @@ where\n         let blocks = mir::traversal::reachable(body);\n         visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n     }\n-\n-    pub fn visit_in_rpo_with(\n-        &self,\n-        body: &'mir mir::Body<'tcx>,\n-        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = A::Domain>,\n-    ) {\n-        let blocks = mir::traversal::reverse_postorder(body);\n-        visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n-    }\n }\n \n /// A solver for dataflow problems."}, {"sha": "25deb46e147514c90ffa04162924661d9c46b0b6", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -114,16 +114,6 @@ pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path, sp: Option<Spa\n     source_file_to_parser(sess, file_to_source_file(sess, path, sp))\n }\n \n-/// Creates a new parser, returning buffered diagnostics if the file doesn't exist,\n-/// or from lexing the initial token stream.\n-pub fn maybe_new_parser_from_file<'a>(\n-    sess: &'a ParseSess,\n-    path: &Path,\n-) -> Result<Parser<'a>, Vec<Diagnostic>> {\n-    let file = try_file_to_source_file(sess, path, None).map_err(|db| vec![db])?;\n-    maybe_source_file_to_parser(sess, file)\n-}\n-\n /// Given a `source_file` and config, returns a parser.\n fn source_file_to_parser(sess: &ParseSess, source_file: Lrc<SourceFile>) -> Parser<'_> {\n     panictry_buffer!(&sess.span_diagnostic, maybe_source_file_to_parser(sess, source_file))\n@@ -146,12 +136,6 @@ fn maybe_source_file_to_parser(\n     Ok(parser)\n }\n \n-// Must preserve old name for now, because `quote!` from the *existing*\n-// compiler expands into it.\n-pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser<'_> {\n-    stream_to_parser(sess, tts.into_iter().collect(), crate::MACRO_ARGUMENTS)\n-}\n-\n // Base abstractions\n \n /// Given a session and a path and an optional span (for error reporting),"}, {"sha": "7808a28dff0b7ed220cb17f4eb0359f437b8c484", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -165,10 +165,6 @@ impl WorkProductId {\n         cgu_name.hash(&mut hasher);\n         WorkProductId { hash: hasher.finish() }\n     }\n-\n-    pub fn from_fingerprint(fingerprint: Fingerprint) -> WorkProductId {\n-        WorkProductId { hash: fingerprint }\n-    }\n }\n \n impl<HCX> HashStable<HCX> for WorkProductId {"}, {"sha": "85335f0ba50c2a5db1bafc607749955122e4bd32", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -402,11 +402,6 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n \n-    #[inline]\n-    pub fn prev_dep_node_index_of(&self, dep_node: &DepNode<K>) -> SerializedDepNodeIndex {\n-        self.data.as_ref().unwrap().previous.node_to_index(dep_node)\n-    }\n-\n     /// Checks whether a previous work product exists for `v` and, if\n     /// so, return the path that leads to it. Used to skip doing work.\n     pub fn previous_work_product(&self, v: &WorkProductId) -> Option<WorkProduct> {"}, {"sha": "a27b716b95aee5fcbc0e84ef11676c6b71e9db0c", "filename": "compiler/rustc_query_system/src/dep_graph/query.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -1,7 +1,5 @@\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::graph::implementation::{\n-    Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n-};\n+use rustc_data_structures::graph::implementation::{Direction, Graph, NodeIndex, INCOMING};\n \n use super::{DepKind, DepNode};\n \n@@ -52,23 +50,8 @@ impl<K: DepKind> DepGraphQuery<K> {\n         }\n     }\n \n-    /// All nodes reachable from `node`. In other words, things that\n-    /// will have to be recomputed if `node` changes.\n-    pub fn transitive_successors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n-        self.reachable_nodes(node, OUTGOING)\n-    }\n-\n     /// All nodes that can reach `node`.\n     pub fn transitive_predecessors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n         self.reachable_nodes(node, INCOMING)\n     }\n-\n-    /// Just the outgoing edges from `node`.\n-    pub fn immediate_successors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n-        if let Some(&index) = self.indices.get(&node) {\n-            self.graph.successor_nodes(index).map(|s| self.graph.node_data(s)).collect()\n-        } else {\n-            vec![]\n-        }\n-    }\n }"}, {"sha": "9143d0a0f5b1e0889eae92b45895828870c03372", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -1586,5 +1586,3 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n     handler.struct_warn(msg).emit();\n }\n-\n-pub type CompileResult = Result<(), ErrorReported>;"}, {"sha": "31f3d8e3791098c434c4711a4ed554239d652e0a", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -619,14 +619,6 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.outer_mark(self))\n     }\n \n-    #[inline]\n-    pub fn outer_mark_with_data(self) -> (ExpnId, Transparency, ExpnData) {\n-        HygieneData::with(|data| {\n-            let (expn_id, transparency) = data.outer_mark(self);\n-            (expn_id, transparency, data.expn_data(expn_id).clone())\n-        })\n-    }\n-\n     pub fn dollar_crate_name(self) -> Symbol {\n         HygieneData::with(|data| data.syntax_context_data[self.0 as usize].dollar_crate_name)\n     }"}, {"sha": "d036c078049909d978628388589673bf56b28d25", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -223,12 +223,6 @@ impl FileName {\n         }\n     }\n \n-    pub fn quote_expansion_source_code(src: &str) -> FileName {\n-        let mut hasher = StableHasher::new();\n-        src.hash(&mut hasher);\n-        FileName::QuoteExpansion(hasher.finish())\n-    }\n-\n     pub fn macro_expansion_source_code(src: &str) -> FileName {\n         let mut hasher = StableHasher::new();\n         src.hash(&mut hasher);"}, {"sha": "3b929c4acb902a99fb2c39d91dc728be3a33f2ae", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -451,15 +451,6 @@ impl SourceMap {\n         }\n     }\n \n-    /// Returns a new `Span` covering the start and end `BytePos`s of the file containing the given\n-    /// `pos`. This can be used to quickly determine if another `BytePos` or `Span` is from the same\n-    /// file.\n-    pub fn lookup_file_span(&self, pos: BytePos) -> Span {\n-        let idx = self.lookup_source_file_idx(pos);\n-        let SourceFile { start_pos, end_pos, .. } = *(*self.files.borrow().source_files)[idx];\n-        Span::with_root_ctxt(start_pos, end_pos)\n-    }\n-\n     /// Returns `Some(span)`, a union of the LHS and RHS span. The LHS must precede the RHS. If\n     /// there are gaps between LHS and RHS, the resulting union will cross these gaps.\n     /// For this to work,"}, {"sha": "0308e9bcdeba3942de61f45a506f15592c9ef99e", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022d20759baa6ebc9dcbe803aec1f19216c47d7f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=022d20759baa6ebc9dcbe803aec1f19216c47d7f", "patch": "@@ -290,10 +290,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn closure_typer(&self) -> &'cx InferCtxt<'cx, 'tcx> {\n-        self.infcx\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //"}]}