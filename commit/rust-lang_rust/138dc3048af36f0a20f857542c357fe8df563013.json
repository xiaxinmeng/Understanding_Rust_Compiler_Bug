{"sha": "138dc3048af36f0a20f857542c357fe8df563013", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzOGRjMzA0OGFmMzZmMGEyMGY4NTc1NDJjMzU3ZmU4ZGY1NjMwMTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-14T21:22:52Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-14T21:24:00Z"}, "message": "libsyntax: Parse \"extern mod foo;\"", "tree": {"sha": "6066f6da929d6223ae4bec956a191c681bd3a7ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6066f6da929d6223ae4bec956a191c681bd3a7ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/138dc3048af36f0a20f857542c357fe8df563013", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/138dc3048af36f0a20f857542c357fe8df563013", "html_url": "https://github.com/rust-lang/rust/commit/138dc3048af36f0a20f857542c357fe8df563013", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/138dc3048af36f0a20f857542c357fe8df563013/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "350668579a4f3037fa4314fa03bcb97461896d4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/350668579a4f3037fa4314fa03bcb97461896d4a", "html_url": "https://github.com/rust-lang/rust/commit/350668579a4f3037fa4314fa03bcb97461896d4a"}], "stats": {"total": 144, "additions": 107, "deletions": 37}, "files": [{"sha": "dd6e9f8531216cae34c8aedb8f027dbc12a9ebe2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 100, "deletions": 37, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/138dc3048af36f0a20f857542c357fe8df563013/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138dc3048af36f0a20f857542c357fe8df563013/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=138dc3048af36f0a20f857542c357fe8df563013", "patch": "@@ -111,6 +111,12 @@ enum item_or_view_item {\n     iovi_view_item(@view_item)\n }\n \n+enum view_item_parse_mode {\n+    VIEW_ITEMS_AND_ITEMS_ALLOWED,\n+    VIEW_ITEMS_ALLOWED,\n+    IMPORTS_AND_ITEMS_ALLOWED\n+}\n+\n /* The expr situation is not as complex as I thought it would be.\n The important thing is to make sure that lookahead doesn't balk\n at INTERPOLATED tokens */\n@@ -2054,7 +2060,7 @@ class parser {\n \n             let item_attrs = vec::append(first_item_attrs, item_attrs);\n \n-            match self.parse_item_or_view_item(item_attrs) {\n+            match self.parse_item_or_view_item(item_attrs, true) {\n               iovi_item(i) => {\n                 let mut hi = i.span.hi;\n                 let decl = @spanned(lo, hi, decl_item(i));\n@@ -2141,8 +2147,17 @@ class parser {\n                          +first_item_attrs: ~[attribute]) -> blk {\n         let mut stmts = ~[];\n         let mut expr = none;\n-        let {attrs_remaining, view_items} =\n-            self.parse_view(first_item_attrs, true);\n+\n+        let {attrs_remaining, view_items, items: items} =\n+            self.parse_items_and_view_items(first_item_attrs,\n+                                            IMPORTS_AND_ITEMS_ALLOWED);\n+\n+        for items.each |item| {\n+            let decl = @spanned(item.span.lo, item.span.hi, decl_item(item));\n+            push(stmts, @spanned(item.span.lo, item.span.hi,\n+                                 stmt_decl(decl, self.get_id())));\n+        }\n+\n         let mut initial_attrs = attrs_remaining;\n \n         if self.token == token::RBRACE && !vec::is_empty(initial_attrs) {\n@@ -2709,9 +2724,11 @@ class parser {\n     fn parse_mod_items(term: token::token,\n                        +first_item_attrs: ~[attribute]) -> _mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        let {attrs_remaining, view_items} =\n-            self.parse_view(first_item_attrs, false);\n-        let mut items: ~[@item] = ~[];\n+        let {attrs_remaining, view_items, items: starting_items} =\n+            self.parse_items_and_view_items(first_item_attrs,\n+                                            VIEW_ITEMS_AND_ITEMS_ALLOWED);\n+        let mut items: ~[@item] = move starting_items;\n+\n         let mut first = true;\n         while self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n@@ -2721,7 +2738,7 @@ class parser {\n             }\n             debug!(\"parse_mod_items: parse_item_or_view_item(attrs=%?)\",\n                    attrs);\n-            match self.parse_item_or_view_item(attrs) {\n+            match self.parse_item_or_view_item(attrs, true) {\n               iovi_item(item) => vec::push(items, item),\n               iovi_view_item(view_item) => {\n                 self.span_fatal(view_item.span, ~\"view items must be \\\n@@ -2797,8 +2814,10 @@ class parser {\n     fn parse_foreign_mod_items(+first_item_attrs: ~[attribute]) ->\n         foreign_mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        let {attrs_remaining, view_items} =\n-            self.parse_view(first_item_attrs, false);\n+        let {attrs_remaining, view_items, items: _} =\n+            self.parse_items_and_view_items(first_item_attrs,\n+                                            VIEW_ITEMS_ALLOWED);\n+\n         let mut items: ~[@foreign_item] = ~[];\n         let mut initial_attrs = attrs_remaining;\n         while self.token != token::RBRACE {\n@@ -2813,7 +2832,8 @@ class parser {\n \n     fn parse_item_foreign_mod(lo: uint,\n                               visibility: visibility,\n-                              attrs: ~[attribute])\n+                              attrs: ~[attribute],\n+                              items_allowed: bool)\n                            -> item_or_view_item {\n         if self.is_keyword(~\"mod\") {\n             self.expect_keyword(~\"mod\");\n@@ -2823,7 +2843,7 @@ class parser {\n         let ident = self.parse_ident();\n \n         // extern mod { ... }\n-        if self.eat(token::LBRACE) {\n+        if items_allowed && self.eat(token::LBRACE) {\n             let extra_attrs = self.parse_inner_attrs_and_next();\n             let m = self.parse_foreign_mod_items(extra_attrs.next);\n             self.expect(token::RBRACE);\n@@ -2836,6 +2856,7 @@ class parser {\n \n         // extern mod foo;\n         let metadata = self.parse_optional_meta();\n+        self.expect(token::SEMI);\n         return iovi_view_item(@{\n             node: view_item_use(ident, metadata, self.get_id()),\n             attrs: attrs,\n@@ -3033,7 +3054,8 @@ class parser {\n         }\n     }\n \n-    fn parse_item_or_view_item(+attrs: ~[attribute]) -> item_or_view_item {\n+    fn parse_item_or_view_item(+attrs: ~[attribute], items_allowed: bool)\n+                            -> item_or_view_item {\n         maybe_whole!{iovi self,nt_item};\n         let lo = self.span.lo;\n \n@@ -3046,25 +3068,26 @@ class parser {\n             visibility = inherited;\n         }\n \n-        if self.eat_keyword(~\"const\") {\n+        if items_allowed && self.eat_keyword(~\"const\") {\n             let (ident, item_, extra_attrs) = self.parse_item_const();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.is_keyword(~\"fn\") &&\n+        } else if items_allowed &&\n+            self.is_keyword(~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n             self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_fn(impure_fn);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"pure\") {\n+        } else if items_allowed && self.eat_keyword(~\"pure\") {\n             self.expect_keyword(~\"fn\");\n             let (ident, item_, extra_attrs) = self.parse_item_fn(pure_fn);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.is_keyword(~\"unsafe\")\n+        } else if items_allowed && self.is_keyword(~\"unsafe\")\n             && self.look_ahead(1u) != token::LBRACE {\n             self.bump();\n             self.expect_keyword(~\"fn\");\n@@ -3073,54 +3096,57 @@ class parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"extern\") {\n-            // XXX: \"extern mod foo;\" syntax as a \"use\" replacement.\n-            if self.eat_keyword(~\"fn\") {\n+            if items_allowed && self.eat_keyword(~\"fn\") {\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(extern_fn);\n                 return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n                                               item_, visibility,\n                                               maybe_append(attrs,\n                                                            extra_attrs)));\n             }\n-            return self.parse_item_foreign_mod(lo, visibility, attrs);\n-        } else if self.eat_keyword(~\"mod\") || self.eat_keyword(~\"module\") {\n+            return self.parse_item_foreign_mod(lo, visibility, attrs,\n+                                               items_allowed);\n+        } else if items_allowed && (self.eat_keyword(~\"mod\") ||\n+                                    self.eat_keyword(~\"module\")) {\n             let (ident, item_, extra_attrs) = self.parse_item_mod();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"type\") {\n+        } else if items_allowed && self.eat_keyword(~\"type\") {\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"enum\") {\n+        } else if items_allowed && self.eat_keyword(~\"enum\") {\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"iface\") {\n+        } else if items_allowed && self.eat_keyword(~\"iface\") {\n             self.warn(~\"`iface` is deprecated; use `trait`\");\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"trait\") {\n+        } else if items_allowed && self.eat_keyword(~\"trait\") {\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"impl\") {\n+        } else if items_allowed && self.eat_keyword(~\"impl\") {\n             let (ident, item_, extra_attrs) = self.parse_item_impl();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"class\") || self.eat_keyword(~\"struct\") {\n+        } else if items_allowed &&\n+                (self.eat_keyword(~\"class\") || self.eat_keyword(~\"struct\")) {\n             let (ident, item_, extra_attrs) = self.parse_item_class();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"use\") {\n             let view_item = self.parse_use();\n+            self.expect(token::SEMI);\n             return iovi_view_item(@{\n                 node: view_item,\n                 attrs: attrs,\n@@ -3129,6 +3155,7 @@ class parser {\n             });\n         } else if self.eat_keyword(~\"import\") {\n             let view_paths = self.parse_view_paths();\n+            self.expect(token::SEMI);\n             return iovi_view_item(@{\n                 node: view_item_import(view_paths),\n                 attrs: attrs,\n@@ -3137,15 +3164,16 @@ class parser {\n             });\n         } else if self.eat_keyword(~\"export\") {\n             let view_paths = self.parse_view_paths();\n+            self.expect(token::SEMI);\n             return iovi_view_item(@{\n                 node: view_item_export(view_paths),\n                 attrs: attrs,\n                 vis: visibility,\n                 span: mk_sp(lo, self.last_span.hi)\n             });\n-        } else if !self.is_any_keyword(copy self.token)\n+        } else if items_allowed && (!self.is_any_keyword(copy self.token)\n                 && self.look_ahead(1) == token::NOT\n-                && is_plain_ident(self.look_ahead(2)) {\n+                && is_plain_ident(self.look_ahead(2))) {\n             // item macro.\n             let pth = self.parse_path_without_tps();\n             self.expect(token::NOT);\n@@ -3173,7 +3201,7 @@ class parser {\n     }\n \n     fn parse_item(+attrs: ~[attribute]) -> option<@ast::item> {\n-        match self.parse_item_or_view_item(attrs) {\n+        match self.parse_item_or_view_item(attrs, true) {\n             iovi_none =>\n                 none,\n             iovi_view_item(_) =>\n@@ -3296,18 +3324,53 @@ class parser {\n           vis: vis, span: mk_sp(lo, self.last_span.hi)}\n     }\n \n-    fn parse_view(+first_item_attrs: ~[attribute],\n-                  only_imports: bool) -> {attrs_remaining: ~[attribute],\n-                                          view_items: ~[@view_item]} {\n+    fn parse_items_and_view_items(+first_item_attrs: ~[attribute],\n+                                  mode: view_item_parse_mode)\n+                               -> {attrs_remaining: ~[attribute],\n+                                   view_items: ~[@view_item],\n+                                   items: ~[@item]} {\n         let mut attrs = vec::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n-        let mut items = ~[];\n-        while if only_imports { self.is_keyword(~\"import\") }\n-        else { self.is_view_item() } {\n-            vec::push(items, self.parse_view_item(attrs));\n+\n+        let items_allowed;\n+        match mode {\n+            VIEW_ITEMS_AND_ITEMS_ALLOWED | IMPORTS_AND_ITEMS_ALLOWED =>\n+                items_allowed = true,\n+            VIEW_ITEMS_ALLOWED =>\n+                items_allowed = false\n+        }\n+\n+        let (view_items, items) = (dvec(), dvec());\n+        loop {\n+            match self.parse_item_or_view_item(attrs, items_allowed) {\n+                iovi_none =>\n+                    break,\n+                iovi_view_item(view_item) => {\n+                    match mode {\n+                        VIEW_ITEMS_AND_ITEMS_ALLOWED |\n+                        VIEW_ITEMS_ALLOWED => {}\n+                        IMPORTS_AND_ITEMS_ALLOWED =>\n+                            match view_item.node {\n+                                view_item_import(_) => {}\n+                                view_item_export(_) | view_item_use(*) =>\n+                                    self.fatal(~\"exports and \\\"extern mod\\\" \\\n+                                                 declarations are not \\\n+                                                 allowed here\")\n+                            }\n+                    }\n+                    view_items.push(view_item);\n+                }\n+                iovi_item(item) => {\n+                    assert items_allowed;\n+                    items.push(item)\n+                }\n+            }\n             attrs = self.parse_outer_attributes();\n         }\n-        {attrs_remaining: attrs, view_items: items}\n+\n+        {attrs_remaining: attrs,\n+         view_items: vec::from_mut(dvec::unwrap(view_items)),\n+         items: vec::from_mut(dvec::unwrap(items))}\n     }\n \n     // Parses a source module as a crate"}, {"sha": "719cda244b5c032c9bda7bb7d9da00aabb26ebbe", "filename": "src/test/run-pass/extern-mod-syntax.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/138dc3048af36f0a20f857542c357fe8df563013/src%2Ftest%2Frun-pass%2Fextern-mod-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138dc3048af36f0a20f857542c357fe8df563013/src%2Ftest%2Frun-pass%2Fextern-mod-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-mod-syntax.rs?ref=138dc3048af36f0a20f857542c357fe8df563013", "patch": "@@ -0,0 +1,7 @@\n+extern mod std;\n+use std::map::hashmap;\n+\n+fn main() {\n+    io::println(\"Hello world!\");\n+}\n+"}]}