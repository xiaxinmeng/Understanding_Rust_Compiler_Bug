{"sha": "02b1c32e4d3c607da8b3a48640e597f089375765", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYjFjMzJlNGQzYzYwN2RhOGIzYTQ4NjQwZTU5N2YwODkzNzU3NjU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-04T22:23:28Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-04T22:46:33Z"}, "message": "core: Remove struct ctors", "tree": {"sha": "aeabef9ffc26c4d9c89dd3eb7a20623cc45f5290", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aeabef9ffc26c4d9c89dd3eb7a20623cc45f5290"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02b1c32e4d3c607da8b3a48640e597f089375765", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02b1c32e4d3c607da8b3a48640e597f089375765", "html_url": "https://github.com/rust-lang/rust/commit/02b1c32e4d3c607da8b3a48640e597f089375765", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02b1c32e4d3c607da8b3a48640e597f089375765/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab9cf45a7ce839cee58e745d8b3472db2e707731", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab9cf45a7ce839cee58e745d8b3472db2e707731", "html_url": "https://github.com/rust-lang/rust/commit/ab9cf45a7ce839cee58e745d8b3472db2e707731"}], "stats": {"total": 241, "additions": 174, "deletions": 67}, "files": [{"sha": "cf146ad8aa0044910e20b3df9acc3b6004e62d1a", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=02b1c32e4d3c607da8b3a48640e597f089375765", "patch": "@@ -99,7 +99,6 @@ fn listen<T: send, U>(f: fn(Chan<T>) -> U) -> U {\n \n struct PortPtr<T:send> {\n   let po: *rust_port;\n-  new(po: *rust_port) { self.po = po; }\n   drop unsafe {\n       do task::unkillable {\n         // Once the port is detached it's guaranteed not to receive further\n@@ -122,6 +121,12 @@ struct PortPtr<T:send> {\n   }\n }\n \n+fn PortPtr<T: send>(po: *rust_port) -> PortPtr<T> {\n+    PortPtr {\n+        po: po\n+    }\n+}\n+\n /**\n  * Internal function for converting from a channel to a port\n  *\n@@ -134,14 +139,19 @@ fn as_raw_port<T: send, U>(ch: comm::Chan<T>, f: fn(*rust_port) -> U) -> U {\n \n     struct PortRef {\n        let p: *rust_port;\n-       new(p: *rust_port) { self.p = p; }\n        drop {\n          if !ptr::is_null(self.p) {\n            rustrt::rust_port_drop(self.p);\n          }\n        }\n     }\n \n+    fn PortRef(p: *rust_port) -> PortRef {\n+        PortRef {\n+            p: p\n+        }\n+    }\n+\n     let p = PortRef(rustrt::rust_port_take(*ch));\n \n     if ptr::is_null(p.p) {"}, {"sha": "483c96206b5cd2c5bb27818f8eaf43da0646204e", "filename": "src/libcore/io.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=02b1c32e4d3c607da8b3a48640e597f089375765", "patch": "@@ -247,10 +247,15 @@ impl<T: Reader, C> {base: T, cleanup: C}: Reader {\n \n struct FILERes {\n     let f: *libc::FILE;\n-    new(f: *libc::FILE) { self.f = f; }\n     drop { libc::fclose(self.f); }\n }\n \n+fn FILERes(f: *libc::FILE) -> FILERes {\n+    FILERes {\n+        f: f\n+    }\n+}\n+\n fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n     if cleanup {\n         {base: f, cleanup: FILERes(f)} as Reader\n@@ -417,10 +422,15 @@ impl fd_t: Writer {\n \n struct FdRes {\n     let fd: fd_t;\n-    new(fd: fd_t) { self.fd = fd; }\n     drop { libc::close(self.fd); }\n }\n \n+fn FdRes(fd: fd_t) -> FdRes {\n+    FdRes {\n+        fd: fd\n+    }\n+}\n+\n fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n     if cleanup {\n         {base: fd, cleanup: FdRes(fd)} as Writer\n@@ -768,7 +778,6 @@ mod fsync {\n     // Artifacts that need to fsync on destruction\n     struct Res<t> {\n         let arg: Arg<t>;\n-        new(-arg: Arg<t>) { self.arg <- arg; }\n         drop {\n           match self.arg.opt_level {\n             option::None => (),\n@@ -780,6 +789,12 @@ mod fsync {\n         }\n     }\n \n+    fn Res<t>(-arg: Arg<t>) -> Res<t>{\n+        Res {\n+            arg: move arg\n+        }\n+    }\n+\n     type Arg<t> = {\n         val: t,\n         opt_level: Option<Level>,"}, {"sha": "dfa02303751f92a1b9fc711ddc035aa0e6a2cae5", "filename": "src/libcore/option.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=02b1c32e4d3c607da8b3a48640e597f089375765", "patch": "@@ -292,9 +292,15 @@ fn test_unwrap_str() {\n fn test_unwrap_resource() {\n     struct R {\n        let i: @mut int;\n-       new(i: @mut int) { self.i = i; }\n        drop { *(self.i) += 1; }\n     }\n+\n+    fn R(i: @mut int) -> R {\n+        R {\n+            i: i\n+        }\n+    }\n+\n     let i = @mut 0;\n     {\n         let x = R(i);"}, {"sha": "f0b656ea649d05b4138c6a5d6228ca0334c91f03", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 54, "deletions": 34, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=02b1c32e4d3c607da8b3a48640e597f089375765", "patch": "@@ -135,12 +135,16 @@ struct BufferHeader {\n     // get away with restricting it to 0 or 1, if we're careful.\n     let mut ref_count: int;\n \n-    new() { self.ref_count = 0; }\n-\n     // We may want a drop, and to be careful about stringing this\n     // thing along.\n }\n \n+fn BufferHeader() -> BufferHeader{\n+    BufferHeader {\n+        ref_count: 0\n+    }\n+}\n+\n // XXX remove me\n #[cfg(stage0)]\n fn buffer_header() -> BufferHeader { BufferHeader() }\n@@ -160,12 +164,6 @@ struct PacketHeader {\n     // to a buffer_header if need be.\n     let mut buffer: *libc::c_void;\n \n-    new() {\n-        self.state = Empty;\n-        self.blocked_task = ptr::null();\n-        self.buffer = ptr::null();\n-    }\n-\n     // Returns the old state.\n     unsafe fn mark_blocked(this: *rust_task) -> State {\n         rustrt::rust_task_ref(this);\n@@ -197,6 +195,14 @@ struct PacketHeader {\n     }\n }\n \n+fn PacketHeader() -> PacketHeader {\n+    PacketHeader {\n+        state: Empty,\n+        blocked_task: ptr::null(),\n+        buffer: ptr::null()\n+    }\n+}\n+\n #[doc(hidden)]\n type Packet<T: send> = {\n     header: PacketHeader,\n@@ -368,12 +374,6 @@ unsafe fn get_buffer<T: send>(p: *PacketHeader) -> ~Buffer<T> {\n // This could probably be done with SharedMutableState to avoid move_it!().\n struct BufferResource<T: send> {\n     let buffer: ~Buffer<T>;\n-    new(+b: ~Buffer<T>) {\n-        //let p = ptr::addr_of(*b);\n-        //error!(\"take %?\", p);\n-        atomic_add_acq(&mut b.header.ref_count, 1);\n-        self.buffer = b;\n-    }\n \n     drop unsafe {\n         let b = move_it!(self.buffer);\n@@ -392,6 +392,16 @@ struct BufferResource<T: send> {\n     }\n }\n \n+fn BufferResource<T: send>(+b: ~Buffer<T>) -> BufferResource<T> {\n+    //let p = ptr::addr_of(*b);\n+    //error!(\"take %?\", p);\n+    atomic_add_acq(&mut b.header.ref_count, 1);\n+\n+    BufferResource {\n+        buffer: b\n+    }\n+}\n+\n #[doc(hidden)]\n fn send<T: send, Tbuffer: send>(+p: SendPacketBuffered<T, Tbuffer>,\n                                 +payload: T) -> bool {\n@@ -770,15 +780,6 @@ fn send_packet<T: send>(p: *packet<T>) -> SendPacket<T> {\n struct SendPacketBuffered<T: send, Tbuffer: send> {\n     let mut p: Option<*Packet<T>>;\n     let mut buffer: Option<BufferResource<Tbuffer>>;\n-    new(p: *Packet<T>) {\n-        //debug!(\"take send %?\", p);\n-        self.p = Some(p);\n-        unsafe {\n-            self.buffer = Some(\n-                BufferResource(\n-                    get_buffer(ptr::addr_of((*p).header))));\n-        };\n-    }\n     drop {\n         //if self.p != none {\n         //    debug!(\"drop send %?\", option::get(self.p));\n@@ -819,6 +820,18 @@ struct SendPacketBuffered<T: send, Tbuffer: send> {\n     }\n }\n \n+fn SendPacketBuffered<T: send, Tbuffer: send>(p: *Packet<T>)\n+    -> SendPacketBuffered<T, Tbuffer> {\n+        //debug!(\"take send %?\", p);\n+    SendPacketBuffered {\n+        p: Some(p),\n+        buffer: unsafe {\n+            Some(BufferResource(\n+                get_buffer(ptr::addr_of((*p).header))))\n+        }\n+    }\n+}\n+\n // XXX remove me\n #[cfg(stage0)]\n #[allow(non_camel_case_types)]\n@@ -848,15 +861,6 @@ fn recv_packet<T: send>(p: *packet<T>) -> RecvPacket<T> {\n struct RecvPacketBuffered<T: send, Tbuffer: send> : Selectable {\n     let mut p: Option<*Packet<T>>;\n     let mut buffer: Option<BufferResource<Tbuffer>>;\n-    new(p: *Packet<T>) {\n-        //debug!(\"take recv %?\", p);\n-        self.p = Some(p);\n-        unsafe {\n-            self.buffer = Some(\n-                BufferResource(\n-                    get_buffer(ptr::addr_of((*p).header))));\n-        };\n-    }\n     drop {\n         //if self.p != none {\n         //    debug!(\"drop recv %?\", option::get(self.p));\n@@ -897,6 +901,18 @@ struct RecvPacketBuffered<T: send, Tbuffer: send> : Selectable {\n     }\n }\n \n+fn RecvPacketBuffered<T: send, Tbuffer: send>(p: *Packet<T>)\n+    -> RecvPacketBuffered<T, Tbuffer> {\n+    //debug!(\"take recv %?\", p);\n+    RecvPacketBuffered {\n+        p: Some(p),\n+        buffer: unsafe {\n+            Some(BufferResource(\n+                get_buffer(ptr::addr_of((*p).header))))\n+        }\n+    }\n+}\n+\n // XXX remove me\n #[cfg(stage0)]\n #[allow(non_camel_case_types)]\n@@ -1083,8 +1099,6 @@ impl<T: send> Port<T>: Recv<T> {\n struct PortSet<T: send> : Recv<T> {\n     let mut ports: ~[pipes::Port<T>];\n \n-    new() { self.ports = ~[]; }\n-\n     fn add(+port: pipes::Port<T>) {\n         vec::push(self.ports, port)\n     }\n@@ -1131,6 +1145,12 @@ struct PortSet<T: send> : Recv<T> {\n     }\n }\n \n+fn PortSet<T: send>() -> PortSet<T>{\n+    PortSet {\n+        ports: ~[]\n+    }\n+}\n+\n impl<T: send> Port<T>: Selectable {\n     pure fn header() -> *PacketHeader unchecked {\n         match self.endp {"}, {"sha": "ae82e59efadfff098f828216fdd8c6ff196237b3", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=02b1c32e4d3c607da8b3a48640e597f089375765", "patch": "@@ -196,11 +196,16 @@ unsafe fn weaken_task(f: fn(comm::Port<()>)) {\n \n     struct Unweaken {\n       let ch: comm::Chan<()>;\n-      new(ch: comm::Chan<()>) { self.ch = ch; }\n       drop unsafe {\n         rustrt::rust_task_unweaken(unsafe::reinterpret_cast(&self.ch));\n       }\n     }\n+\n+    fn Unweaken(ch: comm::Chan<()>) -> Unweaken {\n+        Unweaken {\n+            ch: ch\n+        }\n+    }\n }\n \n #[test]"}, {"sha": "cdead8138992a746bae3bc84976474fd28a73cec", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=02b1c32e4d3c607da8b3a48640e597f089375765", "patch": "@@ -245,10 +245,15 @@ impl Rng {\n \n struct RandRes {\n     let c: *rctx;\n-    new(c: *rctx) { self.c = c; }\n     drop { rustrt::rand_free(self.c); }\n }\n \n+fn RandRes(c: *rctx) -> RandRes {\n+    RandRes {\n+        c: c\n+    }\n+}\n+\n impl @RandRes: Rng {\n     fn next() -> u32 { return rustrt::rand_next((*self).c); }\n }"}, {"sha": "866fcb2275af52e2e88f1edd4d71e0bf844f03dd", "filename": "src/libcore/run.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=02b1c32e4d3c607da8b3a48640e597f089375765", "patch": "@@ -228,10 +228,15 @@ fn start_program(prog: &str, args: &[~str]) -> Program {\n     }\n     struct ProgRes {\n         let r: ProgRepr;\n-        new(+r: ProgRepr) { self.r = r; }\n         drop { destroy_repr(&self.r); }\n     }\n \n+    fn ProgRes(+r: ProgRepr) -> ProgRes {\n+        ProgRes {\n+            r: r\n+        }\n+    }\n+\n     impl ProgRes: Program {\n         fn get_id() -> pid_t { return self.r.pid; }\n         fn input() -> io::Writer { io::fd_writer(self.r.in_fd, false) }"}, {"sha": "0f79a5b6f5f49841b4bde05f324a81a8112d62a0", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=02b1c32e4d3c607da8b3a48640e597f089375765", "patch": "@@ -8,9 +8,11 @@ type Word = uint;\n \n struct Frame {\n     let fp: *Word;\n+}\n \n-    new(fp: *Word) {\n-        self.fp = fp;\n+fn Frame(fp: *Word) -> Frame {\n+    Frame {\n+        fp: fp\n     }\n }\n "}, {"sha": "8d1eb53cc79536471b57df35666d35aaabdfb798", "filename": "src/libcore/task.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=02b1c32e4d3c607da8b3a48640e597f089375765", "patch": "@@ -610,10 +610,15 @@ fn get_task() -> Task {\n unsafe fn unkillable<U>(f: fn() -> U) -> U {\n     struct AllowFailure {\n         let t: *rust_task;\n-        new(t: *rust_task) { self.t = t; }\n         drop { rustrt::rust_task_allow_kill(self.t); }\n     }\n \n+    fn AllowFailure(t: *rust_task) -> AllowFailure{\n+        AllowFailure {\n+            t: t\n+        }\n+    }\n+\n     let t = rustrt::rust_get_task();\n     let _allow_failure = AllowFailure(t);\n     rustrt::rust_task_inhibit_kill(t);\n@@ -624,10 +629,15 @@ unsafe fn unkillable<U>(f: fn() -> U) -> U {\n unsafe fn rekillable<U>(f: fn() -> U) -> U {\n     struct DisallowFailure {\n         let t: *rust_task;\n-        new(t: *rust_task) { self.t = t; }\n         drop { rustrt::rust_task_inhibit_kill(self.t); }\n     }\n \n+    fn DisallowFailure(t: *rust_task) -> DisallowFailure {\n+        DisallowFailure {\n+            t: t\n+        }\n+    }\n+\n     let t = rustrt::rust_get_task();\n     let _allow_failure = DisallowFailure(t);\n     rustrt::rust_task_allow_kill(t);\n@@ -641,12 +651,18 @@ unsafe fn rekillable<U>(f: fn() -> U) -> U {\n unsafe fn atomically<U>(f: fn() -> U) -> U {\n     struct DeferInterrupts {\n         let t: *rust_task;\n-        new(t: *rust_task) { self.t = t; }\n         drop {\n             rustrt::rust_task_allow_yield(self.t);\n             rustrt::rust_task_allow_kill(self.t);\n         }\n     }\n+\n+    fn DeferInterrupts(t: *rust_task) -> DeferInterrupts {\n+        DeferInterrupts {\n+            t: t\n+        }\n+    }\n+\n     let t = rustrt::rust_get_task();\n     let _interrupts = DeferInterrupts(t);\n     rustrt::rust_task_inhibit_kill(t);\n@@ -938,15 +954,6 @@ struct TCB {\n     let mut ancestors: AncestorList;\n     let is_main:       bool;\n     let notifier:      Option<AutoNotify>;\n-    new(me: *rust_task, -tasks: TaskGroupArc, -ancestors: AncestorList,\n-        is_main: bool, -notifier: Option<AutoNotify>) {\n-        self.me        = me;\n-        self.tasks     = tasks;\n-        self.ancestors = ancestors;\n-        self.is_main   = is_main;\n-        self.notifier  = notifier;\n-        self.notifier.iter(|x| { x.failed = false; });\n-    }\n     // Runs on task exit.\n     drop {\n         // If we are failing, the whole taskgroup needs to die.\n@@ -971,19 +978,37 @@ struct TCB {\n     }\n }\n \n+fn TCB(me: *rust_task, +tasks: TaskGroupArc, +ancestors: AncestorList,\n+       is_main: bool, +notifier: Option<AutoNotify>) -> TCB {\n+\n+    let notifier = move notifier;\n+    notifier.iter(|x| { x.failed = false; });\n+\n+    TCB {\n+        me: me,\n+        tasks: tasks,\n+        ancestors: ancestors,\n+        is_main: is_main,\n+        notifier: move notifier\n+    }\n+}\n+\n struct AutoNotify {\n     let notify_chan: comm::Chan<Notification>;\n     let mut failed:  bool;\n-    new(chan: comm::Chan<Notification>) {\n-        self.notify_chan = chan;\n-        self.failed = true; // Un-set above when taskgroup successfully made.\n-    }\n     drop {\n         let result = if self.failed { Failure } else { Success };\n         comm::send(self.notify_chan, Exit(get_task(), result));\n     }\n }\n \n+fn AutoNotify(chan: comm::Chan<Notification>) -> AutoNotify {\n+    AutoNotify {\n+        notify_chan: chan,\n+        failed: true // Un-set above when taskgroup successfully made.\n+    }\n+}\n+\n fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n                        is_member: bool) -> bool {\n     let newstate = util::replace(state, None);"}, {"sha": "e4a73c12921310d4db2f50753d4507ff801fa8b0", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=02b1c32e4d3c607da8b3a48640e597f089375765", "patch": "@@ -95,7 +95,6 @@ struct ArcData<T> {\n \n struct ArcDestruct<T> {\n     mut data: *libc::c_void;\n-    new(data: *libc::c_void) { self.data = data; }\n     drop unsafe {\n         if self.data.is_null() {\n             return; // Happens when destructing an unwrapper's handle.\n@@ -132,6 +131,12 @@ struct ArcDestruct<T> {\n     }\n }\n \n+fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n+    ArcDestruct {\n+        data: data\n+    }\n+}\n+\n unsafe fn unwrap_shared_mutable_state<T: send>(+rc: SharedMutableState<T>)\n         -> T {\n     struct DeathThroes<T> {\n@@ -276,21 +281,29 @@ extern mod rustrt {\n \n struct LittleLock {\n     let l: rust_little_lock;\n-    new() {\n-        self.l = rustrt::rust_create_little_lock();\n-    }\n     drop { rustrt::rust_destroy_little_lock(self.l); }\n }\n \n+fn LittleLock() -> LittleLock {\n+    LittleLock {\n+        l: rustrt::rust_create_little_lock()\n+    }\n+}\n+\n impl LittleLock {\n     #[inline(always)]\n     unsafe fn lock<T>(f: fn() -> T) -> T {\n         struct Unlock {\n             let l: rust_little_lock;\n-            new(l: rust_little_lock) { self.l = l; }\n             drop { rustrt::rust_unlock_little_lock(self.l); }\n         }\n \n+        fn Unlock(l: rust_little_lock) -> Unlock {\n+            Unlock {\n+                l: l\n+            }\n+        }\n+\n         do atomically {\n             rustrt::rust_lock_little_lock(self.l);\n             let _r = Unlock(self.l);"}, {"sha": "57590dbfc3e25805f8f5c91d45dd8c14ec529171", "filename": "src/libcore/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b1c32e4d3c607da8b3a48640e597f089375765/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=02b1c32e4d3c607da8b3a48640e597f089375765", "patch": "@@ -55,10 +55,11 @@ fn replace<T>(dest: &mut T, +src: T) -> T {\n /// A non-copyable dummy type.\n struct NonCopyable {\n     i: ();\n-    new() { self.i = (); }\n     drop { }\n }\n \n+fn NonCopyable() -> NonCopyable { NonCopyable { i: () } }\n+\n mod tests {\n     #[test]\n     fn identity_crisis() {"}]}