{"sha": "3a44ee68fbfa9cf436d5a1afe96427c29d2d94b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNDRlZTY4ZmJmYTljZjQzNmQ1YTFhZmU5NjQyN2MyOWQyZDk0Yjk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-12T23:57:19Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-20T20:12:36Z"}, "message": "resolve: Move derive attribute detection closer to other macro ident resolution code\n\nRefactor away `fn resolve_invoc_to_def`", "tree": {"sha": "1d309c984cb00b112ed9aae4a0e2fd2be257aacc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d309c984cb00b112ed9aae4a0e2fd2be257aacc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a44ee68fbfa9cf436d5a1afe96427c29d2d94b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a44ee68fbfa9cf436d5a1afe96427c29d2d94b9", "html_url": "https://github.com/rust-lang/rust/commit/3a44ee68fbfa9cf436d5a1afe96427c29d2d94b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a44ee68fbfa9cf436d5a1afe96427c29d2d94b9/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "url": "https://api.github.com/repos/rust-lang/rust/commits/1558ae7cfd5e1190d3388dcc6f0f734589e4e478", "html_url": "https://github.com/rust-lang/rust/commit/1558ae7cfd5e1190d3388dcc6f0f734589e4e478"}], "stats": {"total": 116, "additions": 54, "deletions": 62}, "files": [{"sha": "2b1ccff534d3045c10446e2113ef1d166209439f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 53, "deletions": 61, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/3a44ee68fbfa9cf436d5a1afe96427c29d2d94b9/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a44ee68fbfa9cf436d5a1afe96427c29d2d94b9/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=3a44ee68fbfa9cf436d5a1afe96427c29d2d94b9", "patch": "@@ -321,10 +321,18 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n \n     fn resolve_invoc(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n                      -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n-        let def = match invoc.kind {\n-            InvocationKind::Attr { attr: None, .. } => return Ok(None),\n-            _ => self.resolve_invoc_to_def(invoc, scope, force)?,\n+        let (path, macro_kind, derives_in_scope) = match invoc.kind {\n+            InvocationKind::Attr { attr: None, .. } =>\n+                return Ok(None),\n+            InvocationKind::Attr { attr: Some(ref attr), ref traits, .. } =>\n+                (&attr.path, MacroKind::Attr, &traits[..]),\n+            InvocationKind::Bang { ref mac, .. } =>\n+                (&mac.node.path, MacroKind::Bang, &[][..]),\n+            InvocationKind::Derive { ref path, .. } =>\n+                (path, MacroKind::Derive, &[][..]),\n         };\n+        let def = self.resolve_macro_to_def(scope, path, macro_kind, derives_in_scope, force)?;\n+\n         if let Def::Macro(_, MacroKind::ProcMacroStub) = def {\n             self.report_proc_macro_stub(invoc.span());\n             return Err(Determinacy::Determined);\n@@ -396,7 +404,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n \n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n                      -> Result<Lrc<SyntaxExtension>, Determinacy> {\n-        self.resolve_macro_to_def(scope, path, kind, force).and_then(|def| {\n+        self.resolve_macro_to_def(scope, path, kind, &[], force).and_then(|def| {\n             if let Def::Macro(_, MacroKind::ProcMacroStub) = def {\n                 self.report_proc_macro_stub(path.span);\n                 return Err(Determinacy::Determined);\n@@ -437,60 +445,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         self.session.span_err(span, &format!(\"expected a macro, found {}\", def.kind_name()));\n     }\n \n-    fn resolve_invoc_to_def(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n+    fn resolve_macro_to_def(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind,\n+                            derives_in_scope: &[ast::Path], force: bool)\n                             -> Result<Def, Determinacy> {\n-        let (attr, traits) = match invoc.kind {\n-            InvocationKind::Attr { ref attr, ref traits, .. } => (attr, traits),\n-            InvocationKind::Bang { ref mac, .. } => {\n-                return self.resolve_macro_to_def(scope, &mac.node.path, MacroKind::Bang, force);\n-            }\n-            InvocationKind::Derive { ref path, .. } => {\n-                return self.resolve_macro_to_def(scope, path, MacroKind::Derive, force);\n-            }\n-        };\n-\n-        let path = attr.as_ref().unwrap().path.clone();\n-        let def = self.resolve_macro_to_def(scope, &path, MacroKind::Attr, force);\n-        if let Ok(Def::NonMacroAttr(NonMacroAttrKind::Custom)) = def {} else {\n-            return def;\n-        }\n-\n-        // At this point we've found that the `attr` is determinately unresolved and thus can be\n-        // interpreted as a custom attribute. Normally custom attributes are feature gated, but\n-        // it may be a custom attribute whitelisted by a derive macro and they do not require\n-        // a feature gate.\n-        //\n-        // So here we look through all of the derive annotations in scope and try to resolve them.\n-        // If they themselves successfully resolve *and* one of the resolved derive macros\n-        // whitelists this attribute's name, then this is a registered attribute and we can convert\n-        // it from a \"generic custom attrite\" into a \"known derive helper attribute\".\n-        enum ConvertToDeriveHelper { Yes, No, DontKnow }\n-        let mut convert_to_derive_helper = ConvertToDeriveHelper::No;\n-        let attr_name = path.segments[0].ident.name;\n-        for path in traits {\n-            match self.resolve_macro(scope, path, MacroKind::Derive, force) {\n-                Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs, _) = *ext {\n-                    if inert_attrs.contains(&attr_name) {\n-                        convert_to_derive_helper = ConvertToDeriveHelper::Yes;\n-                        break\n-                    }\n-                },\n-                Err(Determinacy::Undetermined) =>\n-                    convert_to_derive_helper = ConvertToDeriveHelper::DontKnow,\n-                Err(Determinacy::Determined) => {}\n-            }\n-        }\n-\n-        match convert_to_derive_helper {\n-            ConvertToDeriveHelper::Yes => Ok(Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper)),\n-            ConvertToDeriveHelper::No => def,\n-            ConvertToDeriveHelper::DontKnow => Err(Determinacy::determined(force)),\n-        }\n-    }\n-\n-    fn resolve_macro_to_def(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n-                            -> Result<Def, Determinacy> {\n-        let def = self.resolve_macro_to_def_inner(scope, path, kind, force);\n+        let def = self.resolve_macro_to_def_inner(scope, path, kind, derives_in_scope, force);\n         if def != Err(Determinacy::Undetermined) {\n             // Do not report duplicated errors on every undetermined resolution.\n             path.segments.iter().find(|segment| segment.args.is_some()).map(|segment| {\n@@ -514,9 +472,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         def\n     }\n \n-    pub fn resolve_macro_to_def_inner(&mut self, scope: Mark, path: &ast::Path,\n-                                  kind: MacroKind, force: bool)\n-                                  -> Result<Def, Determinacy> {\n+    pub fn resolve_macro_to_def_inner(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind,\n+                                      derives_in_scope: &[ast::Path], force: bool)\n+                                      -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n         let mut path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n         let invocation = self.invocations[&scope];\n@@ -575,7 +533,41 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n             .push((scope, path[0], kind, result.ok()));\n \n-        result\n+        if let Ok(Def::NonMacroAttr(NonMacroAttrKind::Custom)) = result {} else {\n+            return result;\n+        }\n+\n+        // At this point we've found that the `attr` is determinately unresolved and thus can be\n+        // interpreted as a custom attribute. Normally custom attributes are feature gated, but\n+        // it may be a custom attribute whitelisted by a derive macro and they do not require\n+        // a feature gate.\n+        //\n+        // So here we look through all of the derive annotations in scope and try to resolve them.\n+        // If they themselves successfully resolve *and* one of the resolved derive macros\n+        // whitelists this attribute's name, then this is a registered attribute and we can convert\n+        // it from a \"generic custom attrite\" into a \"known derive helper attribute\".\n+        assert!(kind == MacroKind::Attr);\n+        enum ConvertToDeriveHelper { Yes, No, DontKnow }\n+        let mut convert_to_derive_helper = ConvertToDeriveHelper::No;\n+        for derive in derives_in_scope {\n+            match self.resolve_macro(scope, derive, MacroKind::Derive, force) {\n+                Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs, _) = *ext {\n+                    if inert_attrs.contains(&path[0].name) {\n+                        convert_to_derive_helper = ConvertToDeriveHelper::Yes;\n+                        break\n+                    }\n+                },\n+                Err(Determinacy::Undetermined) =>\n+                    convert_to_derive_helper = ConvertToDeriveHelper::DontKnow,\n+                Err(Determinacy::Determined) => {}\n+            }\n+        }\n+\n+        match convert_to_derive_helper {\n+            ConvertToDeriveHelper::Yes => Ok(Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper)),\n+            ConvertToDeriveHelper::No => result,\n+            ConvertToDeriveHelper::DontKnow => Err(Determinacy::determined(force)),\n+        }\n     }\n \n     // Resolve the initial segment of a non-global macro path"}, {"sha": "9b9848f794d8aeef772c485a66e7131ec3f7069e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a44ee68fbfa9cf436d5a1afe96427c29d2d94b9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a44ee68fbfa9cf436d5a1afe96427c29d2d94b9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3a44ee68fbfa9cf436d5a1afe96427c29d2d94b9", "patch": "@@ -404,7 +404,7 @@ fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     let mut resolver = cx.resolver.borrow_mut();\n     let mark = Mark::root();\n     let res = resolver\n-        .resolve_macro_to_def_inner(mark, &path, MacroKind::Bang, false);\n+        .resolve_macro_to_def_inner(mark, &path, MacroKind::Bang, &[], false);\n     if let Ok(def) = res {\n         if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n             return Some(def);"}]}