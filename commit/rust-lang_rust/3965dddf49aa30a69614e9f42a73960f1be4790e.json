{"sha": "3965dddf49aa30a69614e9f42a73960f1be4790e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NjVkZGRmNDlhYTMwYTY5NjE0ZTlmNDJhNzM5NjBmMWJlNDc5MGU=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-12-28T03:34:51Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-12-30T07:41:05Z"}, "message": "Make ast_fold take &mut self", "tree": {"sha": "c7706b24bd9b55e2f4deb3a88a593d25f289a06e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7706b24bd9b55e2f4deb3a88a593d25f289a06e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3965dddf49aa30a69614e9f42a73960f1be4790e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3965dddf49aa30a69614e9f42a73960f1be4790e", "html_url": "https://github.com/rust-lang/rust/commit/3965dddf49aa30a69614e9f42a73960f1be4790e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3965dddf49aa30a69614e9f42a73960f1be4790e/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "933def408c48e9b20c478cf4cad9ae2d20b3c5df", "url": "https://api.github.com/repos/rust-lang/rust/commits/933def408c48e9b20c478cf4cad9ae2d20b3c5df", "html_url": "https://github.com/rust-lang/rust/commit/933def408c48e9b20c478cf4cad9ae2d20b3c5df"}], "stats": {"total": 261, "additions": 131, "deletions": 130}, "files": [{"sha": "74e8e0de1d8d07a47bc16b61acc9609cd184cc0c", "filename": "src/librustc/front/assign_node_ids.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs?ref=3965dddf49aa30a69614e9f42a73960f1be4790e", "patch": "@@ -18,14 +18,14 @@ struct NodeIdAssigner {\n }\n \n impl ast_fold for NodeIdAssigner {\n-    fn new_id(&self, old_id: ast::NodeId) -> ast::NodeId {\n+    fn new_id(&mut self, old_id: ast::NodeId) -> ast::NodeId {\n         assert_eq!(old_id, ast::DUMMY_NODE_ID);\n         self.sess.next_node_id()\n     }\n }\n \n pub fn assign_node_ids(sess: Session, crate: ast::Crate) -> ast::Crate {\n-    let fold = NodeIdAssigner {\n+    let mut fold = NodeIdAssigner {\n         sess: sess,\n     };\n     fold.fold_crate(crate)"}, {"sha": "58e7963ca9097c6a4ac9c8673040569109e6ab92", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=3965dddf49aa30a69614e9f42a73960f1be4790e", "patch": "@@ -24,25 +24,25 @@ pub fn strip_unconfigured_items(crate: ast::Crate) -> ast::Crate {\n }\n \n impl<'a> fold::ast_fold for Context<'a> {\n-    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n         fold_mod(self, module)\n     }\n-    fn fold_block(&self, block: ast::P<ast::Block>) -> ast::P<ast::Block> {\n+    fn fold_block(&mut self, block: ast::P<ast::Block>) -> ast::P<ast::Block> {\n         fold_block(self, block)\n     }\n-    fn fold_foreign_mod(&self, foreign_module: &ast::foreign_mod)\n+    fn fold_foreign_mod(&mut self, foreign_module: &ast::foreign_mod)\n                         -> ast::foreign_mod {\n         fold_foreign_mod(self, foreign_module)\n     }\n-    fn fold_item_underscore(&self, item: &ast::item_) -> ast::item_ {\n+    fn fold_item_underscore(&mut self, item: &ast::item_) -> ast::item_ {\n         fold_item_underscore(self, item)\n     }\n }\n \n pub fn strip_items(crate: ast::Crate,\n                    in_cfg: |attrs: &[ast::Attribute]| -> bool)\n                    -> ast::Crate {\n-    let ctxt = Context {\n+    let mut ctxt = Context {\n         in_cfg: in_cfg,\n     };\n     ctxt.fold_crate(crate)\n@@ -57,7 +57,7 @@ fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::view_item)\n     }\n }\n \n-fn fold_mod(cx: &Context, m: &ast::_mod) -> ast::_mod {\n+fn fold_mod(cx: &mut Context, m: &ast::_mod) -> ast::_mod {\n     let filtered_items = m.items.iter()\n             .filter(|&a| item_in_cfg(cx, *a))\n             .flat_map(|&x| cx.fold_item(x).move_iter())\n@@ -80,7 +80,7 @@ fn filter_foreign_item(cx: &Context, item: @ast::foreign_item)\n     }\n }\n \n-fn fold_foreign_mod(cx: &Context, nm: &ast::foreign_mod) -> ast::foreign_mod {\n+fn fold_foreign_mod(cx: &mut Context, nm: &ast::foreign_mod) -> ast::foreign_mod {\n     let filtered_items = nm.items\n                            .iter()\n                            .filter_map(|a| filter_foreign_item(cx, *a))\n@@ -95,7 +95,7 @@ fn fold_foreign_mod(cx: &Context, nm: &ast::foreign_mod) -> ast::foreign_mod {\n     }\n }\n \n-fn fold_item_underscore(cx: &Context, item: &ast::item_) -> ast::item_ {\n+fn fold_item_underscore(cx: &mut Context, item: &ast::item_) -> ast::item_ {\n     let item = match *item {\n         ast::item_impl(ref a, ref b, c, ref methods) => {\n             let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n@@ -129,7 +129,7 @@ fn retain_stmt(cx: &Context, stmt: @ast::Stmt) -> bool {\n     }\n }\n \n-fn fold_block(cx: &Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n+fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n     let resulting_stmts = b.stmts.iter()\n             .filter(|&a| retain_stmt(cx, *a))\n             .flat_map(|&stmt| cx.fold_stmt(stmt).move_iter())"}, {"sha": "13bf867e06be11dfd99df31faf34aa9499e26c60", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=3965dddf49aa30a69614e9f42a73960f1be4790e", "patch": "@@ -56,7 +56,7 @@ struct StandardLibraryInjector {\n }\n \n impl fold::ast_fold for StandardLibraryInjector {\n-    fn fold_crate(&self, crate: ast::Crate) -> ast::Crate {\n+    fn fold_crate(&mut self, crate: ast::Crate) -> ast::Crate {\n         let version = STD_VERSION.to_managed();\n         let vers_item = attr::mk_name_value_item_str(@\"vers\", version);\n         let mut vis = ~[ast::view_item {\n@@ -108,7 +108,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n         }\n     }\n \n-    fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n+    fn fold_item(&mut self, item: @ast::item) -> SmallVector<@ast::item> {\n         if !no_prelude(item.attrs) {\n             // only recur if there wasn't `#[no_implicit_prelude];`\n             // on this item, i.e. this means that the prelude is not\n@@ -119,7 +119,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n         }\n     }\n \n-    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n         let prelude_path = ast::Path {\n             span: dummy_sp(),\n             global: false,\n@@ -158,7 +158,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n }\n \n fn inject_libstd_ref(sess: Session, crate: ast::Crate) -> ast::Crate {\n-    let fold = StandardLibraryInjector {\n+    let mut fold = StandardLibraryInjector {\n         sess: sess,\n     };\n     fold.fold_crate(crate)"}, {"sha": "764935d5305537efc0b8b674df669999b88a8c14", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=3965dddf49aa30a69614e9f42a73960f1be4790e", "patch": "@@ -67,7 +67,7 @@ struct TestHarnessGenerator {\n }\n \n impl fold::ast_fold for TestHarnessGenerator {\n-    fn fold_crate(&self, c: ast::Crate) -> ast::Crate {\n+    fn fold_crate(&mut self, c: ast::Crate) -> ast::Crate {\n         let folded = fold::noop_fold_crate(c, self);\n \n         // Add a special __test module to the crate that will contain code\n@@ -78,7 +78,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n         }\n     }\n \n-    fn fold_item(&self, i: @ast::item) -> SmallVector<@ast::item> {\n+    fn fold_item(&mut self, i: @ast::item) -> SmallVector<@ast::item> {\n         {\n             let mut path = self.cx.path.borrow_mut();\n             path.get().push(i.ident);\n@@ -122,7 +122,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n         res\n     }\n \n-    fn fold_mod(&self, m: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, m: &ast::_mod) -> ast::_mod {\n         // Remove any #[main] from the AST so it doesn't clash with\n         // the one we're going to add. Only if compiling an executable.\n \n@@ -172,7 +172,7 @@ fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n         }\n     });\n \n-    let fold = TestHarnessGenerator {\n+    let mut fold = TestHarnessGenerator {\n         cx: cx\n     };\n     let res = fold.fold_crate(crate);"}, {"sha": "90825289ac39f4f57581929904ecbf95157ff649", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3965dddf49aa30a69614e9f42a73960f1be4790e", "patch": "@@ -301,7 +301,7 @@ struct NestedItemsDropper {\n }\n \n impl fold::ast_fold for NestedItemsDropper {\n-    fn fold_block(&self, blk: ast::P<ast::Block>) -> ast::P<ast::Block> {\n+    fn fold_block(&mut self, blk: ast::P<ast::Block>) -> ast::P<ast::Block> {\n         let stmts_sans_items = blk.stmts.iter().filter_map(|stmt| {\n             match stmt.node {\n                 ast::StmtExpr(_, _) | ast::StmtSemi(_, _) |\n@@ -340,7 +340,7 @@ impl fold::ast_fold for NestedItemsDropper {\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n-    let fld = NestedItemsDropper {\n+    let mut fld = NestedItemsDropper {\n         contents: (),\n     };\n \n@@ -365,17 +365,17 @@ struct AstRenumberer {\n }\n \n impl fold::ast_fold for AstRenumberer {\n-    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n+    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n         self.xcx.tr_id(id)\n     }\n-    fn new_span(&self, span: Span) -> Span {\n+    fn new_span(&mut self, span: Span) -> Span {\n         self.xcx.tr_span(span)\n     }\n }\n \n fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n     -> ast::inlined_item {\n-    let fld = AstRenumberer {\n+    let mut fld = AstRenumberer {\n         xcx: xcx,\n     };\n     match ii {"}, {"sha": "17b46b883b37fdf0525a038a4e115d2b9857a25f", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=3965dddf49aa30a69614e9f42a73960f1be4790e", "patch": "@@ -80,7 +80,7 @@ struct ReadyCtx {\n     fns: ~[ListenerFn]\n }\n \n-fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &CrateSetup)\n+fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &mut CrateSetup)\n             -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n@@ -101,7 +101,7 @@ fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &CrateSetup)\n     }, fold)\n }\n \n-fn fold_item(ctx: @mut ReadyCtx, item: @ast::item, fold: &CrateSetup)\n+fn fold_item(ctx: @mut ReadyCtx, item: @ast::item, fold: &mut CrateSetup)\n              -> SmallVector<@ast::item> {\n     ctx.path.push(item.ident);\n \n@@ -145,10 +145,10 @@ struct CrateSetup {\n }\n \n impl fold::ast_fold for CrateSetup {\n-    fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n+    fn fold_item(&mut self, item: @ast::item) -> SmallVector<@ast::item> {\n         fold_item(self.ctx, item, self)\n     }\n-    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n         fold_mod(self.ctx, module, self)\n     }\n }\n@@ -162,7 +162,7 @@ pub fn ready_crate(sess: session::Session,\n         path: ~[],\n         fns: ~[]\n     };\n-    let fold = CrateSetup {\n+    let mut fold = CrateSetup {\n         ctx: ctx,\n     };\n     fold.fold_crate(crate)"}, {"sha": "842f2bfdffc9ede9f0ec583ccec4bb1f8fa220e9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3965dddf49aa30a69614e9f42a73960f1be4790e", "patch": "@@ -324,11 +324,11 @@ impl ExtCtxt {\n         loop {\n             match e.node {\n                 ast::ExprMac(..) => {\n-                    let expander = expand::MacroExpander {\n+                    let mut expander = expand::MacroExpander {\n                         extsbox: @mut syntax_expander_table(),\n                         cx: self,\n                     };\n-                    e = expand::expand_expr(e, &expander);\n+                    e = expand::expand_expr(e, &mut expander);\n                 }\n                 _ => return e\n             }"}, {"sha": "f5c3c1792c96ce344ae984fd8132196d4187ba3f", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3965dddf49aa30a69614e9f42a73960f1be4790e", "patch": "@@ -908,7 +908,7 @@ struct Duplicator<'a> {\n }\n \n impl<'a> ast_fold for Duplicator<'a> {\n-    fn new_id(&self, _: NodeId) -> NodeId {\n+    fn new_id(&mut self, _: NodeId) -> NodeId {\n         ast::DUMMY_NODE_ID\n     }\n }\n@@ -925,7 +925,7 @@ pub trait Duplicate {\n \n impl Duplicate for @ast::Expr {\n     fn duplicate(&self, cx: &ExtCtxt) -> @ast::Expr {\n-        let folder = Duplicator {\n+        let mut folder = Duplicator {\n             cx: cx,\n         };\n         folder.fold_expr(*self)"}, {"sha": "e20161ea2d093181e8ba262bff46b6e284fa4330", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3965dddf49aa30a69614e9f42a73960f1be4790e", "patch": "@@ -31,7 +31,7 @@ use util::small_vector::SmallVector;\n \n use std::vec;\n \n-pub fn expand_expr(e: @ast::Expr, fld: &MacroExpander) -> @ast::Expr {\n+pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n     match e.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n@@ -210,7 +210,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &MacroExpander) -> @ast::Expr {\n //\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n-pub fn expand_mod_items(module_: &ast::_mod, fld: &MacroExpander) -> ast::_mod {\n+pub fn expand_mod_items(module_: &ast::_mod, fld: &mut MacroExpander) -> ast::_mod {\n     // Fold the contents first:\n     let module_ = noop_fold_mod(module_, fld);\n \n@@ -263,7 +263,8 @@ macro_rules! with_exts_frame (\n static special_block_name : &'static str = \" block\";\n \n // When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(it: @ast::item, fld: &MacroExpander) -> SmallVector<@ast::item> {\n+pub fn expand_item(it: @ast::item, fld: &mut MacroExpander)\n+                   -> SmallVector<@ast::item> {\n     match it.node {\n         ast::item_mac(..) => expand_item_mac(it, fld),\n         ast::item_mod(_) | ast::item_foreign_mod(_) => {\n@@ -286,7 +287,7 @@ pub fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(it: @ast::item, fld: &MacroExpander)\n+pub fn expand_item_mac(it: @ast::item, fld: &mut MacroExpander)\n                        -> SmallVector<@ast::item> {\n     let (pth, tts, ctxt) = match it.node {\n         item_mac(codemap::Spanned {\n@@ -394,7 +395,7 @@ fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n }\n \n // expand a stmt\n-pub fn expand_stmt(s: &Stmt, fld: &MacroExpander) -> SmallVector<@Stmt> {\n+pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n     let (pth, tts, semi, ctxt) = match s.node {\n@@ -487,7 +488,7 @@ pub fn expand_stmt(s: &Stmt, fld: &MacroExpander) -> SmallVector<@Stmt> {\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n-fn expand_non_macro_stmt(s: &Stmt, fld: &MacroExpander)\n+fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                          -> SmallVector<@Stmt> {\n     // is it a let?\n     match s.node {\n@@ -521,7 +522,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &MacroExpander)\n                 let new_name = fresh_name(ident);\n                 new_pending_renames.push((*ident,new_name));\n             }\n-            let rename_fld = renames_to_fold(new_pending_renames);\n+            let mut rename_fld = renames_to_fold(new_pending_renames);\n             // rewrite the pattern using the new names (the old ones\n             // have already been applied):\n             let rewritten_pat = rename_fld.fold_pat(expanded_pat);\n@@ -609,17 +610,17 @@ pub fn new_name_finder(idents: ~[ast::Ident]) -> NewNameFinderContext {\n }\n \n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n-pub fn expand_block(blk: &Block, fld: &MacroExpander) -> P<Block> {\n+pub fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n     // see note below about treatment of exts table\n     with_exts_frame!(fld.extsbox,false,\n                      expand_block_elts(blk, fld))\n }\n \n // expand the elements of a block.\n-pub fn expand_block_elts(b: &Block, fld: &MacroExpander) -> P<Block> {\n+pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n     let block_info = get_block_info(*fld.extsbox);\n     let pending_renames = block_info.pending_renames;\n-    let rename_fld = renames_to_fold(pending_renames);\n+    let mut rename_fld = renames_to_fold(pending_renames);\n     let new_view_items = b.view_items.map(|x| fld.fold_view_item(x));\n     let new_stmts = b.stmts.iter()\n             .map(|x| rename_fld.fold_stmt(*x)\n@@ -651,7 +652,7 @@ struct IdentRenamer {\n }\n \n impl ast_fold for IdentRenamer {\n-    fn fold_ident(&self, id: ast::Ident) -> ast::Ident {\n+    fn fold_ident(&mut self, id: ast::Ident) -> ast::Ident {\n         let new_ctxt = self.renames.iter().fold(id.ctxt, |ctxt, &(from, to)| {\n             new_rename(from, to, ctxt)\n         });\n@@ -664,10 +665,10 @@ impl ast_fold for IdentRenamer {\n \n // given a mutable list of renames, return a tree-folder that applies those\n // renames.\n-pub fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n-    @IdentRenamer {\n+pub fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> IdentRenamer {\n+    IdentRenamer {\n         renames: renames,\n-    } as @ast_fold\n+    }\n }\n \n pub fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n@@ -897,7 +898,7 @@ struct Injector {\n }\n \n impl ast_fold for Injector {\n-    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n         // Just inject the standard macros at the start of the first module\n         // in the crate: that is, at the start of the crate file itself.\n         let items = vec::append(~[ self.sm ], module.items);\n@@ -923,9 +924,9 @@ pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n         None => fail!(\"expected core macros to parse correctly\")\n     };\n \n-    let injector = @Injector {\n+    let mut injector = Injector {\n         sm: sm,\n-    } as @ast_fold;\n+    };\n     injector.fold_crate(c)\n }\n \n@@ -935,27 +936,27 @@ pub struct MacroExpander<'a> {\n }\n \n impl<'a> ast_fold for MacroExpander<'a> {\n-    fn fold_expr(&self, expr: @ast::Expr) -> @ast::Expr {\n+    fn fold_expr(&mut self, expr: @ast::Expr) -> @ast::Expr {\n         expand_expr(expr, self)\n     }\n \n-    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n         expand_mod_items(module, self)\n     }\n \n-    fn fold_item(&self, item: @ast::item) -> SmallVector<@ast::item> {\n+    fn fold_item(&mut self, item: @ast::item) -> SmallVector<@ast::item> {\n         expand_item(item, self)\n     }\n \n-    fn fold_stmt(&self, stmt: &ast::Stmt) -> SmallVector<@ast::Stmt> {\n+    fn fold_stmt(&mut self, stmt: &ast::Stmt) -> SmallVector<@ast::Stmt> {\n         expand_stmt(stmt, self)\n     }\n \n-    fn fold_block(&self, block: P<Block>) -> P<Block> {\n+    fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n         expand_block(block, self)\n     }\n \n-    fn new_span(&self, span: Span) -> Span {\n+    fn new_span(&mut self, span: Span) -> Span {\n         new_span(self.cx, span)\n     }\n }\n@@ -970,7 +971,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     // every method/element of AstFoldFns in fold.rs.\n     let extsbox = syntax_expander_table();\n     let cx = ExtCtxt::new(parse_sess, cfg.clone());\n-    let expander = MacroExpander {\n+    let mut expander = MacroExpander {\n         extsbox: @mut extsbox,\n         cx: &cx,\n     };\n@@ -1046,7 +1047,7 @@ pub struct ContextWrapper {\n }\n \n impl ast_fold for ContextWrapper {\n-    fn fold_ident(&self, id: ast::Ident) -> ast::Ident {\n+    fn fold_ident(&mut self, id: ast::Ident) -> ast::Ident {\n         let ast::Ident {\n             name,\n             ctxt\n@@ -1056,7 +1057,7 @@ impl ast_fold for ContextWrapper {\n             ctxt: self.context_function.f(ctxt),\n         }\n     }\n-    fn fold_mac(&self, m: &ast::mac) -> ast::mac {\n+    fn fold_mac(&mut self, m: &ast::mac) -> ast::mac {\n         let macro = match m.node {\n             mac_invoc_tt(ref path, ref tts, ctxt) => {\n                 mac_invoc_tt(self.fold_path(path),\n@@ -1073,24 +1074,24 @@ impl ast_fold for ContextWrapper {\n \n // given a function from ctxts to ctxts, produce\n // an ast_fold that applies that function to all ctxts:\n-pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @ContextWrapper {\n-    @ContextWrapper {\n+pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> ContextWrapper {\n+    ContextWrapper {\n         context_function: cf as @CtxtFn,\n     }\n }\n \n // just a convenience:\n-pub fn new_mark_folder(m: Mrk) -> @ContextWrapper {\n+pub fn new_mark_folder(m: Mrk) -> ContextWrapper {\n     fun_to_ctxt_folder(@Marker{mark:m})\n }\n \n-pub fn new_rename_folder(from: ast::Ident, to: ast::Name) -> @ContextWrapper {\n+pub fn new_rename_folder(from: ast::Ident, to: ast::Name) -> ContextWrapper {\n     fun_to_ctxt_folder(@Renamer{from:from,to:to})\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n fn mark_tts(tts : &[token_tree], m : Mrk) -> ~[token_tree] {\n-    fold_tts(tts,new_mark_folder(m))\n+    fold_tts(tts, &mut new_mark_folder(m))\n }\n \n // apply a given mark to the given expr. Used following the expansion of a macro.\n@@ -1295,7 +1296,7 @@ mod test {\n         let ident_str = @\"x\";\n         let tts = string_to_tts(ident_str);\n         let fm = fresh_mark();\n-        let marked_once = fold::fold_tts(tts,new_mark_folder(fm));\n+        let marked_once = fold::fold_tts(tts,&mut new_mark_folder(fm));\n         assert_eq!(marked_once.len(),1);\n         let marked_once_ctxt =\n             match marked_once[0] {\n@@ -1317,7 +1318,7 @@ mod test {\n         let item_ast = string_to_crate(@\"fn f() -> int { a }\");\n         let a_name = intern(\"a\");\n         let a2_name = gensym(\"a2\");\n-        let renamer = new_rename_folder(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n+        let mut renamer = new_rename_folder(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n                                         a2_name);\n         let renamed_ast = renamer.fold_crate(item_ast.clone());\n         let mut path_finder = new_path_finder(~[]);"}, {"sha": "9edde7c9c87addba41ee6d837d45a60c3589063c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3965dddf49aa30a69614e9f42a73960f1be4790e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3965dddf49aa30a69614e9f42a73960f1be4790e", "patch": "@@ -17,15 +17,15 @@ use util::small_vector::SmallVector;\n \n // We may eventually want to be able to fold over type parameters, too.\n pub trait ast_fold {\n-    fn fold_crate(&self, c: Crate) -> Crate {\n+    fn fold_crate(&mut self, c: Crate) -> Crate {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&self, meta_items: &[@MetaItem]) -> ~[@MetaItem] {\n+    fn fold_meta_items(&mut self, meta_items: &[@MetaItem]) -> ~[@MetaItem] {\n         meta_items.map(|x| fold_meta_item_(*x, self))\n     }\n \n-    fn fold_view_paths(&self, view_paths: &[@view_path]) -> ~[@view_path] {\n+    fn fold_view_paths(&mut self, view_paths: &[@view_path]) -> ~[@view_path] {\n         view_paths.map(|view_path| {\n             let inner_view_path = match view_path.node {\n                 view_path_simple(ref ident, ref path, node_id) => {\n@@ -62,7 +62,7 @@ pub trait ast_fold {\n         })\n     }\n \n-    fn fold_view_item(&self, vi: &view_item) -> view_item {\n+    fn fold_view_item(&mut self, vi: &view_item) -> view_item {\n         let inner_view_item = match vi.node {\n             view_item_extern_mod(ref ident,\n                                  string,\n@@ -85,7 +85,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_foreign_item(&self, ni: @foreign_item) -> @foreign_item {\n+    fn fold_foreign_item(&mut self, ni: @foreign_item) -> @foreign_item {\n         let fold_attribute = |x| fold_attribute_(x, self);\n \n         @ast::foreign_item {\n@@ -114,11 +114,11 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_item(&self, i: @item) -> SmallVector<@item> {\n+    fn fold_item(&mut self, i: @item) -> SmallVector<@item> {\n         noop_fold_item(i, self)\n     }\n \n-    fn fold_struct_field(&self, sf: &struct_field) -> struct_field {\n+    fn fold_struct_field(&mut self, sf: &struct_field) -> struct_field {\n         let fold_attribute = |x| fold_attribute_(x, self);\n \n         Spanned {\n@@ -132,15 +132,15 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_item_underscore(&self, i: &item_) -> item_ {\n+    fn fold_item_underscore(&mut self, i: &item_) -> item_ {\n         noop_fold_item_underscore(i, self)\n     }\n \n-    fn fold_type_method(&self, m: &TypeMethod) -> TypeMethod {\n+    fn fold_type_method(&mut self, m: &TypeMethod) -> TypeMethod {\n         noop_fold_type_method(m, self)\n     }\n \n-    fn fold_method(&self, m: @method) -> @method {\n+    fn fold_method(&mut self, m: @method) -> @method {\n         @ast::method {\n             ident: self.fold_ident(m.ident),\n             attrs: m.attrs.map(|a| fold_attribute_(*a, self)),\n@@ -156,23 +156,23 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_block(&self, b: P<Block>) -> P<Block> {\n+    fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n         noop_fold_block(b, self)\n     }\n \n-    fn fold_stmt(&self, s: &Stmt) -> SmallVector<@Stmt> {\n+    fn fold_stmt(&mut self, s: &Stmt) -> SmallVector<@Stmt> {\n         noop_fold_stmt(s, self)\n     }\n \n-    fn fold_arm(&self, a: &Arm) -> Arm {\n+    fn fold_arm(&mut self, a: &Arm) -> Arm {\n         Arm {\n             pats: a.pats.map(|x| self.fold_pat(*x)),\n             guard: a.guard.map(|x| self.fold_expr(x)),\n             body: self.fold_block(a.body),\n         }\n     }\n \n-    fn fold_pat(&self, p: @Pat) -> @Pat {\n+    fn fold_pat(&mut self, p: @Pat) -> @Pat {\n         let node = match p.node {\n             PatWild => PatWild,\n             PatWildMulti => PatWildMulti,\n@@ -217,7 +217,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_decl(&self, d: @Decl) -> SmallVector<@Decl> {\n+    fn fold_decl(&mut self, d: @Decl) -> SmallVector<@Decl> {\n         let node = match d.node {\n             DeclLocal(ref l) => SmallVector::one(DeclLocal(self.fold_local(*l))),\n             DeclItem(it) => {\n@@ -233,11 +233,11 @@ pub trait ast_fold {\n         }).collect()\n     }\n \n-    fn fold_expr(&self, e: @Expr) -> @Expr {\n+    fn fold_expr(&mut self, e: @Expr) -> @Expr {\n         noop_fold_expr(e, self)\n     }\n \n-    fn fold_ty(&self, t: P<Ty>) -> P<Ty> {\n+    fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n         let node = match t.node {\n             ty_nil | ty_bot | ty_infer => t.node.clone(),\n             ty_box(ref mt) => ty_box(fold_mt(mt, self)),\n@@ -284,11 +284,11 @@ pub trait ast_fold {\n         })\n     }\n \n-    fn fold_mod(&self, m: &_mod) -> _mod {\n+    fn fold_mod(&mut self, m: &_mod) -> _mod {\n         noop_fold_mod(m, self)\n     }\n \n-    fn fold_foreign_mod(&self, nm: &foreign_mod) -> foreign_mod {\n+    fn fold_foreign_mod(&mut self, nm: &foreign_mod) -> foreign_mod {\n         ast::foreign_mod {\n             abis: nm.abis,\n             view_items: nm.view_items\n@@ -302,7 +302,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_variant(&self, v: &variant) -> P<variant> {\n+    fn fold_variant(&mut self, v: &variant) -> P<variant> {\n         let kind;\n         match v.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n@@ -339,11 +339,11 @@ pub trait ast_fold {\n         })\n     }\n \n-    fn fold_ident(&self, i: Ident) -> Ident {\n+    fn fold_ident(&mut self, i: Ident) -> Ident {\n         i\n     }\n \n-    fn fold_path(&self, p: &Path) -> Path {\n+    fn fold_path(&mut self, p: &Path) -> Path {\n         ast::Path {\n             span: self.new_span(p.span),\n             global: p.global,\n@@ -355,7 +355,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_local(&self, l: @Local) -> @Local {\n+    fn fold_local(&mut self, l: @Local) -> @Local {\n         @Local {\n             ty: self.fold_ty(l.ty),\n             pat: self.fold_pat(l.pat),\n@@ -365,7 +365,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_mac(&self, macro: &mac) -> mac {\n+    fn fold_mac(&mut self, macro: &mac) -> mac {\n         Spanned {\n             node: match macro.node {\n                 mac_invoc_tt(ref p, ref tts, ctxt) => {\n@@ -382,22 +382,22 @@ pub trait ast_fold {\n         es.map(|x| f(*x))\n     }\n \n-    fn new_id(&self, i: NodeId) -> NodeId {\n+    fn new_id(&mut self, i: NodeId) -> NodeId {\n         i\n     }\n \n-    fn new_span(&self, sp: Span) -> Span {\n+    fn new_span(&mut self, sp: Span) -> Span {\n         sp\n     }\n \n-    fn fold_explicit_self(&self, es: &explicit_self) -> explicit_self {\n+    fn fold_explicit_self(&mut self, es: &explicit_self) -> explicit_self {\n         Spanned {\n             span: self.new_span(es.span),\n             node: self.fold_explicit_self_(&es.node)\n         }\n     }\n \n-    fn fold_explicit_self_(&self, es: &explicit_self_) -> explicit_self_ {\n+    fn fold_explicit_self_(&mut self, es: &explicit_self_) -> explicit_self_ {\n         match *es {\n             sty_static | sty_value(_) | sty_uniq(_) | sty_box(_) => {\n                 *es\n@@ -412,7 +412,7 @@ pub trait ast_fold {\n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_<T:ast_fold>(mi: @MetaItem, fld: &T) -> @MetaItem {\n+fn fold_meta_item_<T:ast_fold>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n     @Spanned {\n         node:\n             match mi.node {\n@@ -430,7 +430,7 @@ fn fold_meta_item_<T:ast_fold>(mi: @MetaItem, fld: &T) -> @MetaItem {\n }\n \n //used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_<T:ast_fold>(at: Attribute, fld: &T) -> Attribute {\n+fn fold_attribute_<T:ast_fold>(at: Attribute, fld: &mut T) -> Attribute {\n     Spanned {\n         span: fld.new_span(at.span),\n         node: ast::Attribute_ {\n@@ -442,7 +442,7 @@ fn fold_attribute_<T:ast_fold>(at: Attribute, fld: &T) -> Attribute {\n }\n \n //used in noop_fold_foreign_item and noop_fold_fn_decl\n-fn fold_arg_<T:ast_fold>(a: &arg, fld: &T) -> arg {\n+fn fold_arg_<T:ast_fold>(a: &arg, fld: &mut T) -> arg {\n     ast::arg {\n         ty: fld.fold_ty(a.ty),\n         pat: fld.fold_pat(a.pat),\n@@ -452,7 +452,7 @@ fn fold_arg_<T:ast_fold>(a: &arg, fld: &T) -> arg {\n \n // build a new vector of tts by appling the ast_fold's fold_ident to\n // all of the identifiers in the token trees.\n-pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &T) -> ~[token_tree] {\n+pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &mut T) -> ~[token_tree] {\n     tts.map(|tt| {\n         match *tt {\n             tt_tok(span, ref tok) =>\n@@ -470,7 +470,7 @@ pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &T) -> ~[token_tree] {\n }\n \n // apply ident folder if it's an ident, otherwise leave it alone\n-fn maybe_fold_ident<T:ast_fold>(t: &token::Token, fld: &T) -> token::Token {\n+fn maybe_fold_ident<T:ast_fold>(t: &token::Token, fld: &mut T) -> token::Token {\n     match *t {\n         token::IDENT(id, followed_by_colons) => {\n             token::IDENT(fld.fold_ident(id), followed_by_colons)\n@@ -479,7 +479,7 @@ fn maybe_fold_ident<T:ast_fold>(t: &token::Token, fld: &T) -> token::Token {\n     }\n }\n \n-pub fn fold_fn_decl<T:ast_fold>(decl: &ast::fn_decl, fld: &T)\n+pub fn fold_fn_decl<T:ast_fold>(decl: &ast::fn_decl, fld: &mut T)\n                                 -> P<fn_decl> {\n     P(fn_decl {\n         inputs: decl.inputs.map(|x| fold_arg_(x, fld)), // bad copy\n@@ -489,66 +489,66 @@ pub fn fold_fn_decl<T:ast_fold>(decl: &ast::fn_decl, fld: &T)\n     })\n }\n \n-fn fold_ty_param_bound<T:ast_fold>(tpb: &TyParamBound, fld: &T)\n+fn fold_ty_param_bound<T:ast_fold>(tpb: &TyParamBound, fld: &mut T)\n                                    -> TyParamBound {\n     match *tpb {\n         TraitTyParamBound(ref ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }\n \n-pub fn fold_ty_param<T:ast_fold>(tp: &TyParam, fld: &T) -> TyParam {\n+pub fn fold_ty_param<T:ast_fold>(tp: &TyParam, fld: &mut T) -> TyParam {\n     TyParam {\n         ident: tp.ident,\n         id: fld.new_id(tp.id),\n         bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld)),\n     }\n }\n \n-pub fn fold_ty_params<T:ast_fold>(tps: &OptVec<TyParam>, fld: &T)\n+pub fn fold_ty_params<T:ast_fold>(tps: &OptVec<TyParam>, fld: &mut T)\n                                   -> OptVec<TyParam> {\n     tps.map(|tp| fold_ty_param(tp, fld))\n }\n \n-pub fn fold_lifetime<T:ast_fold>(l: &Lifetime, fld: &T) -> Lifetime {\n+pub fn fold_lifetime<T:ast_fold>(l: &Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n         id: fld.new_id(l.id),\n         span: fld.new_span(l.span),\n         ident: l.ident\n     }\n }\n \n-pub fn fold_lifetimes<T:ast_fold>(lts: &OptVec<Lifetime>, fld: &T)\n+pub fn fold_lifetimes<T:ast_fold>(lts: &OptVec<Lifetime>, fld: &mut T)\n                                   -> OptVec<Lifetime> {\n     lts.map(|l| fold_lifetime(l, fld))\n }\n \n-pub fn fold_opt_lifetime<T:ast_fold>(o_lt: &Option<Lifetime>, fld: &T)\n+pub fn fold_opt_lifetime<T:ast_fold>(o_lt: &Option<Lifetime>, fld: &mut T)\n                                      -> Option<Lifetime> {\n     o_lt.as_ref().map(|lt| fold_lifetime(lt, fld))\n }\n \n-pub fn fold_generics<T:ast_fold>(generics: &Generics, fld: &T) -> Generics {\n+pub fn fold_generics<T:ast_fold>(generics: &Generics, fld: &mut T) -> Generics {\n     Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n               lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n }\n \n-fn fold_struct_def<T:ast_fold>(struct_def: @ast::struct_def, fld: &T)\n+fn fold_struct_def<T:ast_fold>(struct_def: @ast::struct_def, fld: &mut T)\n                                -> @ast::struct_def {\n     @ast::struct_def {\n         fields: struct_def.fields.map(|f| fold_struct_field(f, fld)),\n         ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(cid)),\n     }\n }\n \n-fn fold_trait_ref<T:ast_fold>(p: &trait_ref, fld: &T) -> trait_ref {\n+fn fold_trait_ref<T:ast_fold>(p: &trait_ref, fld: &mut T) -> trait_ref {\n     ast::trait_ref {\n         path: fld.fold_path(&p.path),\n         ref_id: fld.new_id(p.ref_id),\n     }\n }\n \n-fn fold_struct_field<T:ast_fold>(f: &struct_field, fld: &T) -> struct_field {\n+fn fold_struct_field<T:ast_fold>(f: &struct_field, fld: &mut T) -> struct_field {\n     Spanned {\n         node: ast::struct_field_ {\n             kind: f.node.kind,\n@@ -560,22 +560,22 @@ fn fold_struct_field<T:ast_fold>(f: &struct_field, fld: &T) -> struct_field {\n     }\n }\n \n-fn fold_field_<T:ast_fold>(field: Field, folder: &T) -> Field {\n+fn fold_field_<T:ast_fold>(field: Field, folder: &mut T) -> Field {\n     ast::Field {\n         ident: respan(field.ident.span, folder.fold_ident(field.ident.node)),\n         expr: folder.fold_expr(field.expr),\n         span: folder.new_span(field.span),\n     }\n }\n \n-fn fold_mt<T:ast_fold>(mt: &mt, folder: &T) -> mt {\n+fn fold_mt<T:ast_fold>(mt: &mt, folder: &mut T) -> mt {\n     mt {\n         ty: folder.fold_ty(mt.ty),\n         mutbl: mt.mutbl,\n     }\n }\n \n-fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &T)\n+fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &mut T)\n                                -> Option<OptVec<TyParamBound>> {\n     b.as_ref().map(|bounds| {\n         bounds.map(|bound| {\n@@ -584,15 +584,15 @@ fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &T)\n     })\n }\n \n-fn fold_variant_arg_<T:ast_fold>(va: &variant_arg, folder: &T)\n+fn fold_variant_arg_<T:ast_fold>(va: &variant_arg, folder: &mut T)\n                                  -> variant_arg {\n     ast::variant_arg {\n         ty: folder.fold_ty(va.ty),\n         id: folder.new_id(va.id)\n     }\n }\n \n-pub fn noop_fold_block<T:ast_fold>(b: P<Block>, folder: &T) -> P<Block> {\n+pub fn noop_fold_block<T:ast_fold>(b: P<Block>, folder: &mut T) -> P<Block> {\n     let view_items = b.view_items.map(|x| folder.fold_view_item(x));\n     let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n     P(Block {\n@@ -605,7 +605,7 @@ pub fn noop_fold_block<T:ast_fold>(b: P<Block>, folder: &T) -> P<Block> {\n     })\n }\n \n-pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &T) -> item_ {\n+pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &mut T) -> item_ {\n     match *i {\n         item_static(t, m, e) => {\n             item_static(folder.fold_ty(t), m, folder.fold_expr(e))\n@@ -662,7 +662,7 @@ pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &T) -> item_ {\n     }\n }\n \n-pub fn noop_fold_type_method<T:ast_fold>(m: &TypeMethod, fld: &T)\n+pub fn noop_fold_type_method<T:ast_fold>(m: &TypeMethod, fld: &mut T)\n                                          -> TypeMethod {\n     TypeMethod {\n         ident: fld.fold_ident(m.ident),\n@@ -676,7 +676,7 @@ pub fn noop_fold_type_method<T:ast_fold>(m: &TypeMethod, fld: &T)\n     }\n }\n \n-pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &T) -> _mod {\n+pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &mut T) -> _mod {\n     ast::_mod {\n         view_items: m.view_items\n                      .iter()\n@@ -685,7 +685,7 @@ pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &T) -> _mod {\n     }\n }\n \n-pub fn noop_fold_crate<T:ast_fold>(c: Crate, folder: &T) -> Crate {\n+pub fn noop_fold_crate<T:ast_fold>(c: Crate, folder: &mut T) -> Crate {\n     let fold_meta_item = |x| fold_meta_item_(x, folder);\n     let fold_attribute = |x| fold_attribute_(x, folder);\n \n@@ -697,7 +697,7 @@ pub fn noop_fold_crate<T:ast_fold>(c: Crate, folder: &T) -> Crate {\n     }\n }\n \n-pub fn noop_fold_item<T:ast_fold>(i: @ast::item, folder: &T)\n+pub fn noop_fold_item<T:ast_fold>(i: @ast::item, folder: &mut T)\n                                   -> SmallVector<@ast::item> {\n     let fold_attribute = |x| fold_attribute_(x, folder);\n \n@@ -711,23 +711,23 @@ pub fn noop_fold_item<T:ast_fold>(i: @ast::item, folder: &T)\n     })\n }\n \n-pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n+pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &mut T) -> @ast::Expr {\n     let fold_field = |x| fold_field_(x, folder);\n \n     let node = match e.node {\n         ExprVstore(e, v) => {\n             ExprVstore(folder.fold_expr(e), v)\n         }\n         ExprVec(ref exprs, mutt) => {\n-            ExprVec(folder.map_exprs(|x| folder.fold_expr(x), *exprs), mutt)\n+            ExprVec(exprs.map(|&x| folder.fold_expr(x)), mutt)\n         }\n         ExprRepeat(expr, count, mutt) => {\n             ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count), mutt)\n         }\n         ExprTup(ref elts) => ExprTup(elts.map(|x| folder.fold_expr(*x))),\n         ExprCall(f, ref args, blk) => {\n             ExprCall(folder.fold_expr(f),\n-                     folder.map_exprs(|x| folder.fold_expr(x), *args),\n+                     args.map(|&x| folder.fold_expr(x)),\n                      blk)\n         }\n         ExprMethodCall(callee_id, f, i, ref tps, ref args, blk) => {\n@@ -736,7 +736,7 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n                 folder.fold_expr(f),\n                 folder.fold_ident(i),\n                 tps.map(|&x| folder.fold_ty(x)),\n-                folder.map_exprs(|x| folder.fold_expr(x), *args),\n+                args.map(|&x| folder.fold_expr(x)),\n                 blk\n             )\n         }\n@@ -837,7 +837,7 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n     }\n }\n \n-pub fn noop_fold_stmt<T:ast_fold>(s: &Stmt, folder: &T) -> SmallVector<@Stmt> {\n+pub fn noop_fold_stmt<T:ast_fold>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt> {\n     let nodes = match s.node {\n         StmtDecl(d, nid) => {\n             folder.fold_decl(d).move_iter()\n@@ -876,7 +876,7 @@ mod test {\n     struct ToZzIdentFolder;\n \n     impl ast_fold for ToZzIdentFolder {\n-        fn fold_ident(&self, _: ast::Ident) -> ast::Ident {\n+        fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident {\n             token::str_to_ident(\"zz\")\n         }\n     }\n@@ -898,23 +898,23 @@ mod test {\n \n     // make sure idents get transformed everywhere\n     #[test] fn ident_transformation () {\n-        let zz_fold = ToZzIdentFolder;\n+        let mut zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(@\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(&zz_fold.fold_crate(ast),fake_print_crate,\n+                     pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate,\n                                     token::get_ident_interner()),\n                      ~\"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\");\n     }\n \n     // even inside macro defs....\n     #[test] fn ident_transformation_in_defs () {\n-        let zz_fold = ToZzIdentFolder;\n+        let mut zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(@\"macro_rules! a {(b $c:expr $(d $e:token)f+\n => (g $(d $d $e)+))} \");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(&zz_fold.fold_crate(ast),fake_print_crate,\n+                     pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate,\n                                     token::get_ident_interner()),\n                      ~\"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\");\n     }"}]}