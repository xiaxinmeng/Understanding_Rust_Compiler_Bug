{"sha": "081eb744d23def41b3a6800c0e8448c180f4eb99", "node_id": "C_kwDOAAsO6NoAKDA4MWViNzQ0ZDIzZGVmNDFiM2E2ODAwYzBlODQ0OGMxODBmNGViOTk", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-08-27T00:00:56Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-08-27T00:00:56Z"}, "message": "Merge branch 'master' into 2022-08-26_sync_from_rust", "tree": {"sha": "617eb550d68e33ac1708bddbc0995562a2813ff6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/617eb550d68e33ac1708bddbc0995562a2813ff6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/081eb744d23def41b3a6800c0e8448c180f4eb99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/081eb744d23def41b3a6800c0e8448c180f4eb99", "html_url": "https://github.com/rust-lang/rust/commit/081eb744d23def41b3a6800c0e8448c180f4eb99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/081eb744d23def41b3a6800c0e8448c180f4eb99/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b1229eb456891e963fe062f03f93c89c6bda392", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b1229eb456891e963fe062f03f93c89c6bda392", "html_url": "https://github.com/rust-lang/rust/commit/5b1229eb456891e963fe062f03f93c89c6bda392"}, {"sha": "b4eb2c30a262763d59711d285979facc95e1ba56", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4eb2c30a262763d59711d285979facc95e1ba56", "html_url": "https://github.com/rust-lang/rust/commit/b4eb2c30a262763d59711d285979facc95e1ba56"}], "stats": {"total": 4453, "additions": 3883, "deletions": 570}, "files": [{"sha": "4be75efd73a410d4399c65e50289eaf250726714", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -4,14 +4,32 @@ on:\n   - push\n   - pull_request\n \n+env:\n+  # Enable backtraces for easier debugging\n+  RUST_BACKTRACE: 1\n+\n jobs:\n   build:\n     runs-on: ubuntu-latest\n \n     strategy:\n       fail-fast: false\n       matrix:\n-        libgccjit_version: [\"libgccjit.so\", \"libgccjit_without_int128.so\", \"libgccjit12.so\"]\n+        libgccjit_version:\n+          - { gcc: \"libgccjit.so\", extra: \"\" }\n+          - { gcc: \"libgccjit_without_int128.so\", extra: \"\" }\n+          - { gcc: \"libgccjit12.so\", extra: \"--no-default-features\" }\n+        commands: [\n+          \"--mini-tests\",\n+          \"--std-tests\",\n+          \"--test-libcore\",\n+          \"--extended-rand-tests\",\n+          \"--extended-regex-example-tests\",\n+          \"--extended-regex-tests\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 0\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 1\",\n+          \"--test-failing-rustc\",\n+        ]\n \n     steps:\n     - uses: actions/checkout@v2\n@@ -28,7 +46,7 @@ jobs:\n       uses: dawidd6/action-download-artifact@v2\n       with:\n           workflow: main.yml\n-          name: ${{ matrix.libgccjit_version }}\n+          name: ${{ matrix.libgccjit_version.gcc }}\n           path: gcc-build\n           repo: antoyo/gcc\n           search_artifacts: true # Because, instead, the action only check the last job ran and that won't work since we want multiple artifacts.\n@@ -38,13 +56,11 @@ jobs:\n           echo $(readlink -f gcc-build) > gcc_path\n           # NOTE: the filename is still libgccjit.so even when the artifact name is different.\n           ln gcc-build/libgccjit.so gcc-build/libgccjit.so.0\n-\n     - name: Set env\n       run: |\n         echo \"LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n         echo \"LD_LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n         echo \"workspace=\"$GITHUB_WORKSPACE >> $GITHUB_ENV\n-\n     - name: Set RUST_COMPILER_RT_ROOT\n       run: echo \"RUST_COMPILER_RT_ROOT=\"${{ env.workspace }}/llvm/compiler-rt >> $GITHUB_ENV\n \n@@ -77,55 +93,42 @@ jobs:\n         path: target\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n \n-    - name: Build\n-      if: matrix.libgccjit_version != 'libgccjit12.so'\n-      run: |\n-        ./prepare_build.sh\n-        ./build.sh\n-        cargo test\n-        ./clean_all.sh\n+    - name: Cache rust repository\n+      # We only clone the rust repository for rustc tests\n+      if: ${{ contains(matrix.commands, 'rustc') }}\n+      uses: actions/cache@v2\n+      id: cache-rust-repository\n+      with:\n+        path: rust\n+        key: ${{ runner.os }}-packages-${{ hashFiles('rust/.git/HEAD') }}\n \n     - name: Build\n-      if: matrix.libgccjit_version == 'libgccjit12.so'\n       run: |\n         ./prepare_build.sh\n-        ./build.sh --no-default-features\n-        cargo test --no-default-features\n+        ./build.sh ${{ matrix.libgccjit_version.extra }}\n+        cargo test ${{ matrix.libgccjit_version.extra }}\n         ./clean_all.sh\n-\n     - name: Prepare dependencies\n       run: |\n         git config --global user.email \"user@example.com\"\n         git config --global user.name \"User\"\n         ./prepare.sh\n-\n     # Compile is a separate step, as the actions-rs/cargo action supports error annotations\n     - name: Compile\n       uses: actions-rs/cargo@v1.0.3\n       with:\n         command: build\n         args: --release\n \n-    - name: Test\n-      if: matrix.libgccjit_version != 'libgccjit12.so'\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        export COMPILE_RUNS=2\n-        export RUN_RUNS=2\n-\n-        ./test.sh --release\n+    - name: Add more failing tests for GCC 12\n+      if: ${{ matrix.libgccjit_version.gcc == 'libgccjit12.so' }}\n+      run: cat failing-ui-tests12.txt >> failing-ui-tests.txt\n \n-    - name: Test\n-      if: matrix.libgccjit_version == 'libgccjit12.so'\n+    - name: Run tests\n       run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        export COMPILE_RUNS=2\n-        export RUN_RUNS=2\n-\n-        ./test.sh --release --no-default-features\n+        ./test.sh --release --clean --build-sysroot ${{ matrix.commands }} ${{ matrix.libgccjit_version.extra }}\n+  duplicates:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: actions/checkout@v2\n+      - run: python tools/check_intrinsics_duplicates.py"}, {"sha": "3245f5843e549a9c5405a021b4d51453567ebf77", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -41,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#1a60fe3918a5b3b0983c1ea09f4b9445001a6468\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#1a60fe3918a5b3b0983c1ea09f4b9445001a6468\"\n dependencies = [\n  \"libc 0.1.12\",\n ]\n@@ -215,6 +215,7 @@ dependencies = [\n  \"ar\",\n  \"gccjit\",\n  \"lang_tester\",\n+ \"smallvec\",\n  \"target-lexicon\",\n  \"tempfile\",\n ]\n@@ -228,6 +229,12 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"smallvec\"\n+version = \"1.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f2dd574626839106c320a323308629dcb1acfc96e32a8cba364ddc61ac23ee83\"\n+\n [[package]]\n name = \"target-lexicon\"\n version = \"0.10.0\""}, {"sha": "3ac354ea49427c1ae2b75100eeaeaabdcd61eb81", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -27,6 +27,7 @@ gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n # Local copy.\n #gccjit = { path = \"../gccjit.rs\" }\n \n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n target-lexicon = \"0.10.0\"\n \n ar = \"0.8.0\""}, {"sha": "aa3626db4ef5bd80d402910c0847eb1941f70bd7", "filename": "Readme.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -127,6 +127,10 @@ To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo b\n  * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`).\n  * Clean and rebuild the codegen with `debug-current` in the file `rust-toolchain`.\n \n+### How to use [mem-trace](https://github.com/antoyo/mem-trace)\n+\n+`rustc` needs to be built without `jemalloc` so that `mem-trace` can overload `malloc` since `jemalloc` is linked statically, so a `LD_PRELOAD`-ed library won't a chance to intercept the calls to `malloc`.\n+\n ### How to build a cross-compiling libgccjit\n \n #### Building libgccjit\n@@ -142,6 +146,5 @@ To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo b\n  * Since rustc doesn't support this architecture yet, set it back to `TARGET_TRIPLE=\"mips-unknown-linux-gnu\"` (or another target having the same attributes). Alternatively, create a [target specification file](https://book.avr-rust.com/005.1-the-target-specification-json-file.html) (note that the `arch` specified in this file must be supported by the rust compiler).\n  * Set `linker='-Clinker=m68k-linux-gcc'`.\n  * Set the path to the cross-compiling libgccjit in `gcc_path`.\n- * Disable the 128-bit integer types if the target doesn't support them by using `let i128_type = context.new_type::<i64>();` in `context.rs` (same for u128_type).\n  * Comment the line: `context.add_command_line_option(\"-masm=intel\");` in src/base.rs.\n  * (might not be necessary) Disable the compilation of libstd.so (and possibly libcore.so?)."}, {"sha": "717d0d39331f672e4b85d0c95f0baa68e5076662", "filename": "failing-ui-tests.txt", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/failing-ui-tests.txt", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/failing-ui-tests.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/failing-ui-tests.txt?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -0,0 +1,55 @@\n+src/test/ui/alloc-error/default-alloc-error-hook.rs\n+src/test/ui/allocator/custom-in-block.rs\n+src/test/ui/allocator/custom-in-submodule.rs\n+src/test/ui/allocator/custom.rs\n+src/test/ui/allocator/hygiene.rs\n+src/test/ui/allocator/no_std-alloc-error-handler-custom.rs\n+src/test/ui/allocator/no_std-alloc-error-handler-default.rs\n+src/test/ui/allocator/xcrate-use.rs\n+src/test/ui/allocator/xcrate-use2.rs\n+src/test/ui/asm/may_unwind.rs\n+src/test/ui/asm/x86_64/const.rs\n+src/test/ui/asm/x86_64/multiple-clobber-abi.rs\n+src/test/ui/async-await/async-fn-size-moved-locals.rs\n+src/test/ui/async-await/async-fn-size-uninit-locals.rs\n+src/test/ui/backtrace.rs\n+src/test/ui/cfg/cfg-panic.rs\n+src/test/ui/debuginfo/debuginfo-emit-llvm-ir-and-split-debuginfo.rs\n+src/test/ui/functions-closures/parallel-codegen-closures.rs\n+src/test/ui/generator/size-moved-locals.rs\n+src/test/ui/issues/issue-32518.rs\n+src/test/ui/issues/issue-47364.rs\n+src/test/ui/issues/issue-74564-if-expr-stack-overflow.rs\n+src/test/ui/linkage-attr/linkage1.rs\n+src/test/ui/lto/dylib-works.rs\n+src/test/ui/mir/mir_heavy_promoted.rs\n+src/test/ui/numbers-arithmetic/saturating-float-casts.rs\n+src/test/ui/polymorphization/promoted-function.rs\n+src/test/ui/runtime/rt-explody-panic-payloads.rs\n+src/test/ui/sepcomp/sepcomp-cci.rs\n+src/test/ui/sepcomp/sepcomp-extern.rs\n+src/test/ui/sepcomp/sepcomp-fns-backwards.rs\n+src/test/ui/sepcomp/sepcomp-fns.rs\n+src/test/ui/sepcomp/sepcomp-lib.rs\n+src/test/ui/sepcomp/sepcomp-statics.rs\n+src/test/ui/simd/generics.rs\n+src/test/ui/simd/intrinsic/float-math-pass.rs\n+src/test/ui/simd/intrinsic/float-minmax-pass.rs\n+src/test/ui/simd/intrinsic/generic-arithmetic-pass.rs\n+src/test/ui/simd/intrinsic/generic-as.rs\n+src/test/ui/simd/intrinsic/generic-bitmask-pass.rs\n+src/test/ui/simd/intrinsic/generic-comparison-pass.rs\n+src/test/ui/simd/intrinsic/generic-gather-pass.rs\n+src/test/ui/simd/intrinsic/generic-reduction-pass.rs\n+src/test/ui/simd/intrinsic/generic-select-pass.rs\n+src/test/ui/simd/issue-17170.rs\n+src/test/ui/simd/issue-39720.rs\n+src/test/ui/simd/issue-85915-simd-ptrs.rs\n+src/test/ui/simd/issue-89193.rs\n+src/test/ui/simd/libm_std_can_float.rs\n+src/test/ui/simd/simd-bitmask.rs\n+src/test/ui/simd/type-generic-monomorphisation-extern-nonnull-ptr.rs\n+src/test/ui/sse2.rs\n+src/test/ui/statics/issue-91050-1.rs\n+src/test/ui/statics/issue-91050-2.rs\n+src/test/ui/target-feature/missing-plusminus.rs"}, {"sha": "0a50c0a2ce136dc2892197d7f82e850cd2736d31", "filename": "failing-ui-tests12.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/failing-ui-tests12.txt", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/failing-ui-tests12.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/failing-ui-tests12.txt?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -0,0 +1,17 @@\n+src/test/ui/intrinsics/const-eval-select-x86_64.rs\n+src/test/ui/packed/packed-struct-drop-aligned.rs\n+src/test/ui/packed/packed-struct-generic-layout.rs\n+src/test/ui/packed/packed-struct-layout.rs\n+src/test/ui/packed/packed-struct-optimized-enum.rs\n+src/test/ui/packed/packed-struct-size.rs\n+src/test/ui/packed/packed-struct-vec.rs\n+src/test/ui/packed/packed-tuple-struct-layout.rs\n+src/test/ui/simd/array-type.rs\n+src/test/ui/simd/intrinsic/generic-arithmetic-saturating-pass.rs\n+src/test/ui/simd/intrinsic/generic-cast-pass.rs\n+src/test/ui/simd/intrinsic/generic-cast-pointer-width.rs\n+src/test/ui/simd/intrinsic/generic-elements-pass.rs\n+src/test/ui/simd/intrinsic/inlining-issue67557-ice.rs\n+src/test/ui/simd/intrinsic/inlining-issue67557.rs\n+src/test/ui/simd/monomorphize-shuffle-index.rs\n+src/test/ui/simd/shuffle.rs"}, {"sha": "93c63b5dcacfda4c14539665d4a004baeb2ae3c3", "filename": "patches/0001-Add-stdarch-Cargo.toml-for-testing.patch", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/patches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/patches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -0,0 +1,39 @@\n+From c3821e02fbd6cb5ad6e06d759fccdc9073712375 Mon Sep 17 00:00:00 2001\n+From: Antoni Boucher <bouanto@zoho.com>\n+Date: Tue, 7 Jun 2022 21:40:13 -0400\n+Subject: [PATCH] Add stdarch Cargo.toml for testing\n+\n+---\n+ library/stdarch/Cargo.toml | 20 ++++++++++++++++++++\n+ 1 file changed, 20 insertions(+)\n+ create mode 100644 library/stdarch/Cargo.toml\n+\n+diff --git a/library/stdarch/Cargo.toml b/library/stdarch/Cargo.toml\n+new file mode 100644\n+index 0000000..fbe0a95\n+--- /dev/null\n++++ b/library/stdarch/Cargo.toml\n+@@ -0,0 +1,20 @@\n++[workspace]\n++members = [\n++  \"crates/core_arch\",\n++  \"crates/std_detect\",\n++  \"crates/stdarch-gen\",\n++  \"examples/\"\n++]\n++exclude = [\n++  \"crates/wasm-assert-instr-tests\"\n++]\n++\n++[profile.release]\n++debug = true\n++opt-level = 3\n++incremental = true\n++\n++[profile.bench]\n++debug = 1\n++opt-level = 3\n++incremental = true\n+-- \n+2.26.2.7.g19db9cfb68.dirty\n+"}, {"sha": "11482c69d594d059c064f339a5f1237b45210a02", "filename": "src/allocator.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fallocator.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -1,3 +1,5 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::FnAttribute;\n use gccjit::{FunctionType, GlobalKind, ToRValue};\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_middle::bug;\n@@ -50,7 +52,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         let func = context.new_function(None, FunctionType::Exported, output.unwrap_or(void), &args, name, false);\n \n         if tcx.sess.target.options.default_hidden_visibility {\n-            // TODO(antoyo): set visibility.\n+            #[cfg(feature=\"master\")]\n+            func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n         }\n         if tcx.sess.must_emit_unwind_tables() {\n             // TODO(antoyo): emit unwind tables.\n@@ -61,7 +64,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n             .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n             .collect();\n         let callee = context.new_function(None, FunctionType::Extern, output.unwrap_or(void), &args, callee, false);\n-        // TODO(antoyo): set visibility.\n+        #[cfg(feature=\"master\")]\n+        callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n \n         let block = func.new_block(\"entry\");\n \n@@ -90,6 +94,11 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         .collect();\n     let func = context.new_function(None, FunctionType::Exported, void, &args, name, false);\n \n+    if tcx.sess.target.default_hidden_visibility {\n+        #[cfg(feature=\"master\")]\n+        func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+    }\n+\n     let kind =\n         if has_alloc_error_handler {\n             AllocatorKind::Global\n@@ -102,7 +111,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n         .collect();\n     let callee = context.new_function(None, FunctionType::Extern, void, &args, callee, false);\n-    //llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n+    #[cfg(feature=\"master\")]\n+    callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n \n     let block = func.new_block(\"entry\");\n "}, {"sha": "fa40aa80804a1610646af6f68b3b430ca2de9a01", "filename": "src/asm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     use ConstraintOrRegister::*;\n \n                     let (constraint, ty) = match (reg_to_gcc(reg), place) {\n-                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx, false)),\n+                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx)),\n                         // When `reg` is a class and not an explicit register but the out place is not specified,\n                         // we need to create an unused output variable to assign the output to. This var\n                         // needs to be of a type that's \"compatible\" with the register class, but specific type\n@@ -225,7 +225,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     // This decision is also backed by the fact that LLVM needs in and out\n                     // values to be of *exactly the same type*, not just \"compatible\".\n                     // I'm not sure if GCC is so picky too, but better safe than sorry.\n-                    let ty = in_value.layout.gcc_type(self.cx, false);\n+                    let ty = in_value.layout.gcc_type(self.cx);\n                     let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n \n                     // If the out_place is None (i.e `inout(reg) _` syntax was used), we translate\n@@ -285,7 +285,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                             continue\n                         };\n \n-                        let ty = out_place.layout.gcc_type(self.cx, false);\n+                        let ty = out_place.layout.gcc_type(self.cx);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n \n@@ -305,7 +305,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 // `in(\"explicit register\") var`\n                 InlineAsmOperandRef::In { reg, value } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n-                        let ty = value.layout.gcc_type(self.cx, false);\n+                        let ty = value.layout.gcc_type(self.cx);\n                         let reg_var = self.current_func().new_local(None, ty, \"input_register\");\n                         reg_var.set_register_name(reg_name);\n                         self.llbb().add_assignment(None, reg_var, value.immediate());\n@@ -324,7 +324,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n                         // See explanation in the first pass.\n-                        let ty = in_value.layout.gcc_type(self.cx, false);\n+                        let ty = in_value.layout.gcc_type(self.cx);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n "}, {"sha": "243a1a36dd09db20d3d66e9c7b121d54a248d1b6", "filename": "src/attributes.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattributes.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -0,0 +1,112 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::FnAttribute;\n+use gccjit::Function;\n+use rustc_attr::InstructionSetAttr;\n+use rustc_codegen_ssa::target_features::tied_target_features;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty;\n+use rustc_session::Session;\n+use rustc_span::symbol::sym;\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::context::CodegenCx;\n+\n+// Given a map from target_features to whether they are enabled or disabled,\n+// ensure only valid combinations are allowed.\n+pub fn check_tied_features(sess: &Session, features: &FxHashMap<&str, bool>) -> Option<&'static [&'static str]> {\n+    for tied in tied_target_features(sess) {\n+        // Tied features must be set to the same value, or not set at all\n+        let mut tied_iter = tied.iter();\n+        let enabled = features.get(tied_iter.next().unwrap());\n+        if tied_iter.any(|feature| enabled != features.get(feature)) {\n+            return Some(tied);\n+        }\n+    }\n+    None\n+}\n+\n+// TODO(antoyo): maybe move to a new module gcc_util.\n+// To find a list of GCC's names, check https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html\n+fn to_gcc_features<'a>(sess: &Session, s: &'a str) -> SmallVec<[&'a str; 2]> {\n+    let arch = if sess.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.arch };\n+    match (arch, s) {\n+        (\"x86\", \"sse4.2\") => smallvec![\"sse4.2\", \"crc32\"],\n+        (\"x86\", \"pclmulqdq\") => smallvec![\"pclmul\"],\n+        (\"x86\", \"rdrand\") => smallvec![\"rdrnd\"],\n+        (\"x86\", \"bmi1\") => smallvec![\"bmi\"],\n+        (\"x86\", \"cmpxchg16b\") => smallvec![\"cx16\"],\n+        (\"x86\", \"avx512vaes\") => smallvec![\"vaes\"],\n+        (\"x86\", \"avx512gfni\") => smallvec![\"gfni\"],\n+        (\"x86\", \"avx512vpclmulqdq\") => smallvec![\"vpclmulqdq\"],\n+        // NOTE: seems like GCC requires 'avx512bw' for 'avx512vbmi2'.\n+        (\"x86\", \"avx512vbmi2\") => smallvec![\"avx512vbmi2\", \"avx512bw\"],\n+        // NOTE: seems like GCC requires 'avx512bw' for 'avx512bitalg'.\n+        (\"x86\", \"avx512bitalg\") => smallvec![\"avx512bitalg\", \"avx512bw\"],\n+        (\"aarch64\", \"rcpc2\") => smallvec![\"rcpc-immo\"],\n+        (\"aarch64\", \"dpb\") => smallvec![\"ccpp\"],\n+        (\"aarch64\", \"dpb2\") => smallvec![\"ccdp\"],\n+        (\"aarch64\", \"frintts\") => smallvec![\"fptoint\"],\n+        (\"aarch64\", \"fcma\") => smallvec![\"complxnum\"],\n+        (\"aarch64\", \"pmuv3\") => smallvec![\"perfmon\"],\n+        (\"aarch64\", \"paca\") => smallvec![\"pauth\"],\n+        (\"aarch64\", \"pacg\") => smallvec![\"pauth\"],\n+        // Rust ties fp and neon together. In LLVM neon implicitly enables fp,\n+        // but we manually enable neon when a feature only implicitly enables fp\n+        (\"aarch64\", \"f32mm\") => smallvec![\"f32mm\", \"neon\"],\n+        (\"aarch64\", \"f64mm\") => smallvec![\"f64mm\", \"neon\"],\n+        (\"aarch64\", \"fhm\") => smallvec![\"fp16fml\", \"neon\"],\n+        (\"aarch64\", \"fp16\") => smallvec![\"fullfp16\", \"neon\"],\n+        (\"aarch64\", \"jsconv\") => smallvec![\"jsconv\", \"neon\"],\n+        (\"aarch64\", \"sve\") => smallvec![\"sve\", \"neon\"],\n+        (\"aarch64\", \"sve2\") => smallvec![\"sve2\", \"neon\"],\n+        (\"aarch64\", \"sve2-aes\") => smallvec![\"sve2-aes\", \"neon\"],\n+        (\"aarch64\", \"sve2-sm4\") => smallvec![\"sve2-sm4\", \"neon\"],\n+        (\"aarch64\", \"sve2-sha3\") => smallvec![\"sve2-sha3\", \"neon\"],\n+        (\"aarch64\", \"sve2-bitperm\") => smallvec![\"sve2-bitperm\", \"neon\"],\n+        (_, s) => smallvec![s],\n+    }\n+}\n+\n+/// Composite function which sets GCC attributes for function depending on its AST (`#[attribute]`)\n+/// attributes.\n+pub fn from_fn_attrs<'gcc, 'tcx>(\n+    cx: &CodegenCx<'gcc, 'tcx>,\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    func: Function<'gcc>,\n+    instance: ty::Instance<'tcx>,\n+) {\n+    let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n+\n+    let function_features =\n+        codegen_fn_attrs.target_features.iter().map(|features| features.as_str()).collect::<Vec<&str>>();\n+\n+    if let Some(features) = check_tied_features(cx.tcx.sess, &function_features.iter().map(|features| (*features, true)).collect()) {\n+        let span = cx.tcx\n+            .get_attr(instance.def_id(), sym::target_feature)\n+            .map_or_else(|| cx.tcx.def_span(instance.def_id()), |a| a.span);\n+        let msg = format!(\"the target features {} must all be either enabled or disabled together\", features.join(\", \"));\n+        let mut err = cx.tcx.sess.struct_span_err(span, &msg);\n+        err.help(\"add the missing features in a `target_feature` attribute\");\n+        err.emit();\n+        return;\n+    }\n+\n+    let mut function_features = function_features\n+        .iter()\n+        .flat_map(|feat| to_gcc_features(cx.tcx.sess, feat).into_iter())\n+        .chain(codegen_fn_attrs.instruction_set.iter().map(|x| match x {\n+            InstructionSetAttr::ArmA32 => \"-thumb-mode\", // TODO(antoyo): support removing feature.\n+            InstructionSetAttr::ArmT32 => \"thumb-mode\",\n+        }))\n+        .collect::<Vec<_>>();\n+\n+    // TODO(antoyo): check if we really need global backend features. (Maybe they could be applied\n+    // globally?)\n+    let mut global_features = cx.tcx.global_backend_features(()).iter().map(|s| s.as_str());\n+    function_features.extend(&mut global_features);\n+    let target_features = function_features.join(\",\");\n+    if !target_features.is_empty() {\n+        #[cfg(feature=\"master\")]\n+        func.add_attribute(FnAttribute::Target(&target_features));\n+    }\n+}"}, {"sha": "8cc9581e842c8a47b30e27beb783193a9ab70a6e", "filename": "src/base.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -8,6 +8,8 @@ use gccjit::{\n };\n use rustc_middle::dep_graph;\n use rustc_middle::ty::TyCtxt;\n+#[cfg(feature=\"master\")]\n+use rustc_middle::mir::mono::Visibility;\n use rustc_middle::mir::mono::Linkage;\n use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n@@ -20,6 +22,15 @@ use crate::GccContext;\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n \n+#[cfg(feature=\"master\")]\n+pub fn visibility_to_gcc(linkage: Visibility) -> gccjit::Visibility {\n+    match linkage {\n+        Visibility::Default => gccjit::Visibility::Default,\n+        Visibility::Hidden => gccjit::Visibility::Hidden,\n+        Visibility::Protected => gccjit::Visibility::Protected,\n+    }\n+}\n+\n pub fn global_linkage_to_gcc(linkage: Linkage) -> GlobalKind {\n     match linkage {\n         Linkage::External => GlobalKind::Imported,\n@@ -81,11 +92,25 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_\n         // TODO(antoyo): only add the following cli argument if the feature is supported.\n         context.add_command_line_option(\"-msse2\");\n         context.add_command_line_option(\"-mavx2\");\n-        context.add_command_line_option(\"-msha\");\n-        context.add_command_line_option(\"-mpclmul\");\n         // FIXME(antoyo): the following causes an illegal instruction on vmovdqu64 in std_example on my CPU.\n         // Only add if the CPU supports it.\n-        //context.add_command_line_option(\"-mavx512f\");\n+        context.add_command_line_option(\"-msha\");\n+        context.add_command_line_option(\"-mpclmul\");\n+        context.add_command_line_option(\"-mfma\");\n+        context.add_command_line_option(\"-mfma4\");\n+        context.add_command_line_option(\"-m64\");\n+        context.add_command_line_option(\"-mbmi\");\n+        context.add_command_line_option(\"-mgfni\");\n+        context.add_command_line_option(\"-mavxvnni\");\n+        context.add_command_line_option(\"-mf16c\");\n+        context.add_command_line_option(\"-maes\");\n+        context.add_command_line_option(\"-mxsavec\");\n+        context.add_command_line_option(\"-mbmi2\");\n+        context.add_command_line_option(\"-mrtm\");\n+        context.add_command_line_option(\"-mvaes\");\n+        context.add_command_line_option(\"-mvpclmulqdq\");\n+        context.add_command_line_option(\"-mavx\");\n+\n         for arg in &tcx.sess.opts.cg.llvm_args {\n             context.add_command_line_option(arg);\n         }"}, {"sha": "3608b97fcf6ed476a7c4f1de523a87b588868ff6", "filename": "src/builder.rs", "status": "modified", "additions": 74, "deletions": 22, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n-                    if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() && actual_ty.get_size() != expected_ty.get_size() {\n+                    if !actual_ty.is_vector() && !expected_ty.is_vector() && (actual_ty.is_integral() && expected_ty.is_integral()) || (actual_ty.get_pointee().is_some() && expected_ty.get_pointee().is_some()) {\n                         self.context.new_cast(None, actual_val, expected_ty)\n                     }\n                     else if on_stack_param_indices.contains(&index) {\n@@ -222,6 +222,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                     else {\n                         assert!(!((actual_ty.is_vector() && !expected_ty.is_vector()) || (!actual_ty.is_vector() && expected_ty.is_vector())), \"{:?} ({}) -> {:?} ({}), index: {:?}[{}]\", actual_ty, actual_ty.is_vector(), expected_ty, expected_ty.is_vector(), func_ptr, index);\n                         // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n+                        // TODO: remove bitcast now that vector types can be compared?\n                         self.bitcast(actual_val, expected_ty)\n                     }\n                 }\n@@ -275,21 +276,26 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn function_ptr_call(&mut self, func_ptr: RValue<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        let args = self.check_ptr_call(\"call\", func_ptr, args);\n+        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n+        let func_name = format!(\"{:?}\", func_ptr);\n+        let previous_arg_count = args.len();\n+        let orig_args = args;\n+        let args = llvm::adjust_intrinsic_arguments(&self, gcc_func, args.into(), &func_name);\n+        let args_adjusted = args.len() != previous_arg_count;\n+        let args = self.check_ptr_call(\"call\", func_ptr, &*args);\n \n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n-        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         let return_type = gcc_func.get_return_type();\n         let void_type = self.context.new_type::<()>();\n         let current_func = self.block.get_function();\n \n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n-            let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-            let func_name = format!(\"{:?}\", func_ptr);\n-            let args = llvm::adjust_intrinsic_arguments(&self, gcc_func, args, &func_name);\n-            self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+            let return_value = self.cx.context.new_call_through_ptr(None, func_ptr, &args);\n+            let return_value = llvm::adjust_intrinsic_return_value(&self, return_value, &func_name, &args, args_adjusted, orig_args);\n+            let result = current_func.new_local(None, return_value.get_type(), &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            self.block.add_assignment(None, result, return_value);\n             result.to_rvalue()\n         }\n         else {\n@@ -526,6 +532,31 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn frem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): add check in libgccjit since using the binary operator % causes the following error:\n+        // during RTL pass: expand\n+        // libgccjit.so: error: in expmed_mode_index, at expmed.h:240\n+        // 0x7f0101d58dc6 expmed_mode_index\n+        //     ../../../gcc/gcc/expmed.h:240\n+        // 0x7f0101d58e35 expmed_op_cost_ptr\n+        //     ../../../gcc/gcc/expmed.h:262\n+        // 0x7f0101d594a1 sdiv_cost_ptr\n+        //     ../../../gcc/gcc/expmed.h:531\n+        // 0x7f0101d594f3 sdiv_cost\n+        //     ../../../gcc/gcc/expmed.h:549\n+        // 0x7f0101d6af7e expand_divmod(int, tree_code, machine_mode, rtx_def*, rtx_def*, rtx_def*, int, optab_methods)\n+        //     ../../../gcc/gcc/expmed.cc:4356\n+        // 0x7f0101d94f9e expand_expr_divmod\n+        //     ../../../gcc/gcc/expr.cc:8929\n+        // 0x7f0101d97a26 expand_expr_real_2(separate_ops*, rtx_def*, machine_mode, expand_modifier)\n+        //     ../../../gcc/gcc/expr.cc:9566\n+        // 0x7f0101bef6ef expand_gimple_stmt_1\n+        //     ../../../gcc/gcc/cfgexpand.cc:3967\n+        // 0x7f0101bef910 expand_gimple_stmt\n+        //     ../../../gcc/gcc/cfgexpand.cc:4028\n+        // 0x7f0101bf6ee7 expand_gimple_basic_block\n+        //     ../../../gcc/gcc/cfgexpand.cc:6069\n+        // 0x7f0101bf9194 execute\n+        //     ../../../gcc/gcc/cfgexpand.cc:6795\n         if a.get_type().is_compatible_with(self.cx.float_type) {\n             let fmodf = self.context.get_builtin_function(\"fmodf\");\n             // FIXME(antoyo): this seems to produce the wrong result.\n@@ -600,24 +631,29 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         a * b\n     }\n \n-    fn fadd_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fadd_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs + rhs\n     }\n \n-    fn fsub_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fsub_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs - rhs\n     }\n \n-    fn fmul_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fmul_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs * rhs\n     }\n \n-    fn fdiv_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fdiv_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs / rhs\n     }\n \n-    fn frem_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn frem_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        self.frem(lhs, rhs)\n     }\n \n     fn checked_binop(&mut self, oop: OverflowOp, typ: Ty<'_>, lhs: Self::Value, rhs: Self::Value) -> (Self::Value, Self::Value) {\n@@ -710,7 +746,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             }\n             else if place.layout.is_gcc_immediate() {\n                 let load = self.load(\n-                    place.layout.gcc_type(self, false),\n+                    place.layout.gcc_type(self),\n                     place.llval,\n                     place.align,\n                 );\n@@ -721,7 +757,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             }\n             else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n                 let b_offset = a.size(self).align_to(b.align(self).abi);\n-                let pair_type = place.layout.gcc_type(self, false);\n+                let pair_type = place.layout.gcc_type(self);\n \n                 let mut load = |i, scalar: &abi::Scalar, align| {\n                     let llptr = self.struct_gep(pair_type, place.llval, i as u64);\n@@ -1376,18 +1412,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n     {\n         let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_type = vector_type.get_element_type();\n+        let mask_element_type = self.type_ix(element_type.get_size() as u64 * 8);\n         let element_count = vector_type.get_num_units();\n         let mut vector_elements = vec![];\n         for i in 0..element_count {\n             vector_elements.push(i);\n         }\n-        let mask_type = self.context.new_vector_type(self.int_type, element_count as u64);\n+        let mask_type = self.context.new_vector_type(mask_element_type, element_count as u64);\n         let mut shift = 1;\n         let mut res = src;\n         while shift < element_count {\n             let vector_elements: Vec<_> =\n                 vector_elements.iter()\n-                    .map(|i| self.context.new_rvalue_from_int(self.int_type, ((i + shift) % element_count) as i32))\n+                    .map(|i| self.context.new_rvalue_from_int(mask_element_type, ((i + shift) % element_count) as i32))\n                     .collect();\n             let mask = self.context.new_rvalue_from_vector(None, mask_type, &vector_elements);\n             let shifted = self.context.new_rvalue_vector_perm(None, res, res, mask);\n@@ -1399,7 +1437,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(not(feature=\"master\"))]\n-    pub fn vector_reduce<F>(&mut self, src: RValue<'gcc>, op: F) -> RValue<'gcc>\n+    pub fn vector_reduce<F>(&mut self, _src: RValue<'gcc>, _op: F) -> RValue<'gcc>\n     where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n     {\n         unimplemented!();\n@@ -1443,6 +1481,9 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let zeros = self.context.new_rvalue_from_vector(None, cond_type, &zeros);\n \n         let masks = self.context.new_comparison(None, ComparisonOp::NotEquals, cond, zeros);\n+        // NOTE: masks is a vector of integers, but the values can be vectors of floats, so use bitcast to make\n+        // the & operation work.\n+        let masks = self.bitcast_if_needed(masks, then_val.get_type());\n         let then_vals = masks & then_val;\n \n         let ones = vec![self.context.new_rvalue_one(element_type); num_units];\n@@ -1451,6 +1492,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         // NOTE: sometimes, the type of else_val can be different than the type of then_val in\n         // libgccjit (vector of int vs vector of int32_t), but they should be the same for the AND\n         // operation to work.\n+        // TODO: remove bitcast now that vector types can be compared?\n         let else_val = self.context.new_bitcast(None, else_val, then_val.get_type());\n         let else_vals = inverted_masks & else_val;\n \n@@ -1461,6 +1503,16 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n fn difference_or_zero<'gcc>(a: RValue<'gcc>, b: RValue<'gcc>, context: &'gcc Context<'gcc>) -> RValue<'gcc> {\n     let difference = a - b;\n     let masks = context.new_comparison(None, ComparisonOp::GreaterThanEquals, b, a);\n+    // NOTE: masks is a vector of integers, but the values can be vectors of floats, so use bitcast to make\n+    // the & operation work.\n+    let a_type = a.get_type();\n+    let masks =\n+        if masks.get_type() != a_type {\n+            context.new_bitcast(None, masks, a_type)\n+        }\n+        else {\n+            masks\n+        };\n     difference & masks\n }\n "}, {"sha": "be7d48b2279a232af099a1054746dd39fe6ae88a", "filename": "src/callee.rs", "status": "modified", "additions": 97, "deletions": 1, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcallee.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -1,9 +1,12 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::{FnAttribute, Visibility};\n use gccjit::{FunctionType, RValue};\n use rustc_codegen_ssa::traits::BaseTypeMethods;\n use rustc_middle::ty::{self, Instance, TypeVisitable};\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n \n use crate::abi::FnAbiGccExt;\n+use crate::attributes;\n use crate::context::CodegenCx;\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n@@ -67,8 +70,101 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n             cx.linkage.set(FunctionType::Extern);\n             let func = cx.declare_fn(&sym, &fn_abi);\n \n+            attributes::from_fn_attrs(cx, func, instance);\n+\n+            let instance_def_id = instance.def_id();\n+\n             // TODO(antoyo): set linkage and attributes.\n-            func\n+\n+            // Apply an appropriate linkage/visibility value to our item that we\n+            // just declared.\n+            //\n+            // This is sort of subtle. Inside our codegen unit we started off\n+            // compilation by predefining all our own `MonoItem` instances. That\n+            // is, everything we're codegenning ourselves is already defined. That\n+            // means that anything we're actually codegenning in this codegen unit\n+            // will have hit the above branch in `get_declared_value`. As a result,\n+            // we're guaranteed here that we're declaring a symbol that won't get\n+            // defined, or in other words we're referencing a value from another\n+            // codegen unit or even another crate.\n+            //\n+            // So because this is a foreign value we blanket apply an external\n+            // linkage directive because it's coming from a different object file.\n+            // The visibility here is where it gets tricky. This symbol could be\n+            // referencing some foreign crate or foreign library (an `extern`\n+            // block) in which case we want to leave the default visibility. We may\n+            // also, though, have multiple codegen units. It could be a\n+            // monomorphization, in which case its expected visibility depends on\n+            // whether we are sharing generics or not. The important thing here is\n+            // that the visibility we apply to the declaration is the same one that\n+            // has been applied to the definition (wherever that definition may be).\n+            let is_generic = instance.substs.non_erasable_generics().next().is_some();\n+\n+            if is_generic {\n+                // This is a monomorphization. Its expected visibility depends\n+                // on whether we are in share-generics mode.\n+\n+                if cx.tcx.sess.opts.share_generics() {\n+                    // We are in share_generics mode.\n+\n+                    if let Some(instance_def_id) = instance_def_id.as_local() {\n+                        // This is a definition from the current crate. If the\n+                        // definition is unreachable for downstream crates or\n+                        // the current crate does not re-export generics, the\n+                        // definition of the instance will have been declared\n+                        // as `hidden`.\n+                        if cx.tcx.is_unreachable_local_definition(instance_def_id)\n+                            || !cx.tcx.local_crate_exports_generics()\n+                        {\n+                            #[cfg(feature=\"master\")]\n+                            func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                        }\n+                    } else {\n+                        // This is a monomorphization of a generic function\n+                        // defined in an upstream crate.\n+                        if instance.upstream_monomorphization(tcx).is_some() {\n+                            // This is instantiated in another crate. It cannot\n+                            // be `hidden`.\n+                        } else {\n+                            // This is a local instantiation of an upstream definition.\n+                            // If the current crate does not re-export it\n+                            // (because it is a C library or an executable), it\n+                            // will have been declared `hidden`.\n+                            if !cx.tcx.local_crate_exports_generics() {\n+                                #[cfg(feature=\"master\")]\n+                                func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    // When not sharing generics, all instances are in the same\n+                    // crate and have hidden visibility\n+                    #[cfg(feature=\"master\")]\n+                    func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                }\n+            } else {\n+                // This is a non-generic function\n+                if cx.tcx.is_codegened_item(instance_def_id) {\n+                    // This is a function that is instantiated in the local crate\n+\n+                    if instance_def_id.is_local() {\n+                        // This is function that is defined in the local crate.\n+                        // If it is not reachable, it is hidden.\n+                        if !cx.tcx.is_reachable_non_generic(instance_def_id) {\n+                            #[cfg(feature=\"master\")]\n+                            func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                        }\n+                    } else {\n+                        // This is a function from an upstream crate that has\n+                        // been instantiated here. These are always hidden.\n+                        #[cfg(feature=\"master\")]\n+                        func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                    }\n+                }\n+            }\n+\n+            // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n+            unsafe { std::mem::transmute(func) }\n         };\n \n     cx.function_instances.borrow_mut().insert(instance, func);"}, {"sha": "1d44dc486683c1a33a1669bec840e8ca708f5cb2", "filename": "src/common.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -133,7 +133,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             .1;\n         let len = s.len();\n         let cs = self.const_ptrcast(str_global.get_address(None),\n-            self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self, true)),\n+            self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self)),\n         );\n         (cs, self.const_usize(len as u64))\n     }\n@@ -178,8 +178,18 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 }\n \n                 let value = self.const_uint_big(self.type_ix(bitsize), data);\n-                // TODO(bjorn3): assert size is correct\n-                self.const_bitcast(value, ty)\n+                let bytesize = layout.size(self).bytes();\n+                if bitsize > 1 && ty.is_integral() && bytesize as u32 == ty.get_size() {\n+                    // NOTE: since the intrinsic _xabort is called with a bitcast, which\n+                    // is non-const, but expects a constant, do a normal cast instead of a bitcast.\n+                    // FIXME(antoyo): fix bitcast to work in constant contexts.\n+                    // TODO(antoyo): perhaps only use bitcast for pointers?\n+                    self.context.new_cast(None, value, ty)\n+                }\n+                else {\n+                    // TODO(bjorn3): assert size is correct\n+                    self.const_bitcast(value, ty)\n+                }\n             }\n             Scalar::Ptr(ptr, _size) => {\n                 let (alloc_id, offset) = ptr.into_parts();\n@@ -231,7 +241,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     fn from_const_alloc(&self, layout: TyAndLayout<'tcx>, alloc: ConstAllocation<'tcx>, offset: Size) -> PlaceRef<'tcx, RValue<'gcc>> {\n         assert_eq!(alloc.inner().align, layout.align.abi);\n-        let ty = self.type_ptr_to(layout.gcc_type(self, true));\n+        let ty = self.type_ptr_to(layout.gcc_type(self));\n         let value =\n             if layout.size == Size::ZERO {\n                 let value = self.const_usize(alloc.inner().align.bytes());"}, {"sha": "e83cf53f48efdb415f4f27cbe9e3d8d7eafcfb96", "filename": "src/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -80,7 +80,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n \n         let instance = Instance::mono(self.tcx, def_id);\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n-        let gcc_type = self.layout_of(ty).gcc_type(self, true);\n+        let gcc_type = self.layout_of(ty).gcc_type(self);\n \n         // TODO(antoyo): set alignment.\n \n@@ -211,7 +211,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let global =\n             if let Some(def_id) = def_id.as_local() {\n                 let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                let llty = self.layout_of(ty).gcc_type(self, true);\n+                let llty = self.layout_of(ty).gcc_type(self);\n                 // FIXME: refactor this to work without accessing the HIR\n                 let global = match self.tcx.hir().get(id) {\n                     Node::Item(&hir::Item { span, kind: hir::ItemKind::Static(..), .. }) => {\n@@ -356,7 +356,7 @@ pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id\n \n fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str, span: Span) -> LValue<'gcc> {\n     let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-    let llty = cx.layout_of(ty).gcc_type(cx, true);\n+    let llty = cx.layout_of(ty).gcc_type(cx);\n     if let Some(linkage) = attrs.linkage {\n         // If this is a static with a linkage specified, then we need to handle\n         // it a little specially. The typesystem prevents things like &T and\n@@ -365,7 +365,7 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // that the static actually has a null value.\n         let llty2 =\n             if let ty::RawPtr(ref mt) = ty.kind() {\n-                cx.layout_of(mt.ty).gcc_type(cx, true)\n+                cx.layout_of(mt.ty).gcc_type(cx)\n             }\n             else {\n                 cx.sess().span_fatal("}, {"sha": "2699559dc2ad7aeecab00a946091b95057bcce5c", "filename": "src/context.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -1,6 +1,6 @@\n use std::cell::{Cell, RefCell};\n \n-use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Struct, Type};\n+use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Type};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,\n@@ -78,8 +78,6 @@ pub struct CodegenCx<'gcc, 'tcx> {\n \n     pub struct_types: RefCell<FxHashMap<Vec<Type<'gcc>>, Type<'gcc>>>,\n \n-    pub types_with_fields_to_set: RefCell<FxHashMap<Type<'gcc>, (Struct<'gcc>, TyAndLayout<'tcx>)>>,\n-\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, LValue<'gcc>>>,\n     /// Cache function instances of monomorphic and polymorphic items\n@@ -243,7 +241,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             types: Default::default(),\n             tcx,\n             struct_types: Default::default(),\n-            types_with_fields_to_set: Default::default(),\n             local_gen_sym_counter: Cell::new(0),\n             eh_personality: Cell::new(None),\n             pointee_infos: Default::default(),"}, {"sha": "5f6360a7da5309cb1d2c684b7c1cbdb8cf637523", "filename": "src/declare.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdeclare.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -79,12 +79,11 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         unsafe { std::mem::transmute(func) }\n     }\n \n-    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> RValue<'gcc> {\n+    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Function<'gcc> {\n         let (return_type, params, variadic, on_stack_param_indices) = fn_abi.gcc_type(self);\n         let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic);\n         self.on_stack_function_params.borrow_mut().insert(func, on_stack_param_indices);\n-        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-        unsafe { std::mem::transmute(func) }\n+        func\n     }\n \n     pub fn define_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {"}, {"sha": "9d674eb87eb3a60ddff3ec2f31245786a5254ece", "filename": "src/intrinsic/archs.rs", "status": "modified", "additions": 2279, "deletions": 63, "changes": 2342, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fintrinsic%2Farchs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fintrinsic%2Farchs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Farchs.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99"}, {"sha": "20f500e34e90a607d0c99eb8a709fee59a43fb35", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 624, "deletions": 133, "changes": 757, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -1,6 +1,7 @@\n use std::borrow::Cow;\n \n-use gccjit::{Function, FunctionPtrType, RValue, ToRValue};\n+use gccjit::{Function, FunctionPtrType, RValue, ToRValue, UnaryOp};\n+use rustc_codegen_ssa::traits::BuilderMethods;\n \n use crate::{context::CodegenCx, builder::Builder};\n \n@@ -9,151 +10,352 @@ pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc\n     // arguments here.\n     if gcc_func.get_param_count() != args.len() {\n         match &*func_name {\n-            \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n-                // FIXME(antoyo): the following intrinsics has 4 (or 5) arguments according to the doc, but is defined with 2 (or 3) arguments in library/stdarch/crates/core_arch/src/x86/avx512f.rs.\n+            // NOTE: the following intrinsics have a different number of parameters in LLVM and GCC.\n+            \"__builtin_ia32_prold512_mask\" | \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n                 | \"__builtin_ia32_pmaxsd512_mask\" | \"__builtin_ia32_pmaxsq512_mask\" | \"__builtin_ia32_pmaxsq256_mask\"\n-                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\" | \"__builtin_ia32_pmaxuq256_mask\"\n-                | \"__builtin_ia32_pmaxuq128_mask\"\n+                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\"\n                 | \"__builtin_ia32_pminsd512_mask\" | \"__builtin_ia32_pminsq512_mask\" | \"__builtin_ia32_pminsq256_mask\"\n-                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n-                | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\" | \"__builtin_ia32_pminuq256_mask\"\n-                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\"\n+                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\"\n+                | \"__builtin_ia32_prolq512_mask\" | \"__builtin_ia32_prorq512_mask\" | \"__builtin_ia32_pslldi512_mask\"\n+                | \"__builtin_ia32_psrldi512_mask\" | \"__builtin_ia32_psllqi512_mask\" | \"__builtin_ia32_psrlqi512_mask\"\n+                | \"__builtin_ia32_pslld512_mask\" | \"__builtin_ia32_psrld512_mask\" | \"__builtin_ia32_psllq512_mask\"\n+                | \"__builtin_ia32_psrlq512_mask\" | \"__builtin_ia32_psrad512_mask\" | \"__builtin_ia32_psraq512_mask\"\n+                | \"__builtin_ia32_psradi512_mask\" | \"__builtin_ia32_psraqi512_mask\" | \"__builtin_ia32_psrav16si_mask\"\n+                | \"__builtin_ia32_psrav8di_mask\" | \"__builtin_ia32_prolvd512_mask\" | \"__builtin_ia32_prorvd512_mask\"\n+                | \"__builtin_ia32_prolvq512_mask\" | \"__builtin_ia32_prorvq512_mask\" | \"__builtin_ia32_psllv16si_mask\"\n+                | \"__builtin_ia32_psrlv16si_mask\" | \"__builtin_ia32_psllv8di_mask\" | \"__builtin_ia32_psrlv8di_mask\"\n+                | \"__builtin_ia32_permvarsi512_mask\" | \"__builtin_ia32_vpermilvarps512_mask\"\n+                | \"__builtin_ia32_vpermilvarpd512_mask\" | \"__builtin_ia32_permvardi512_mask\"\n+                | \"__builtin_ia32_permvarsf512_mask\" | \"__builtin_ia32_permvarqi512_mask\"\n+                | \"__builtin_ia32_permvarqi256_mask\" | \"__builtin_ia32_permvarqi128_mask\"\n+                | \"__builtin_ia32_vpmultishiftqb512_mask\" | \"__builtin_ia32_vpmultishiftqb256_mask\"\n+                | \"__builtin_ia32_vpmultishiftqb128_mask\"\n                 => {\n-                    // TODO: refactor by separating those intrinsics outside of this branch.\n-                    let add_before_last_arg =\n-                        match &*func_name {\n-                            \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                                | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n-                                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => true,\n-                            _ => false,\n-                        };\n-                    let new_first_arg_is_zero =\n-                        match &*func_name {\n-                            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\"\n-                                | \"__builtin_ia32_pminuq256_mask\" | \"__builtin_ia32_pminuq128_mask\" => true,\n-                            _ => false\n-                        };\n-                    let arg3_index =\n-                        match &*func_name {\n-                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 1,\n-                            _ => 2,\n-                        };\n-                    let mut new_args = args.to_vec();\n-                    let arg3_type = gcc_func.get_param_type(arg3_index);\n-                    let first_arg =\n-                        if new_first_arg_is_zero {\n-                            let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n-                            let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n-                            let num_units = vector_type.get_num_units();\n-                            builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units])\n-                        }\n-                        else {\n-                            builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue()\n-                        };\n-                    if add_before_last_arg {\n-                        new_args.insert(new_args.len() - 1, first_arg);\n-                    }\n-                    else {\n-                        new_args.push(first_arg);\n-                    }\n-                    let arg4_index =\n-                        match &*func_name {\n-                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 2,\n-                            _ => 3,\n-                        };\n-                    let arg4_type = gcc_func.get_param_type(arg4_index);\n-                    let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                    if add_before_last_arg {\n-                        new_args.insert(new_args.len() - 1, minus_one);\n-                    }\n-                    else {\n-                        new_args.push(minus_one);\n-                    }\n-                    args = new_args.into();\n-                },\n-                \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n-                    | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n-                    | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let arg5_type = gcc_func.get_param_type(4);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n-                        new_args.push(minus_one);\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-\n-                        let mut last_arg = None;\n-                        if args.len() == 4 {\n-                            last_arg = new_args.pop();\n-                        }\n-\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-\n-                        if args.len() == 3 {\n-                            // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n-                            // the same GCC intrinsic, but the former has 3 parameters and the\n-                            // latter has 4 so it doesn't require this additional argument.\n-                            let arg5_type = gcc_func.get_param_type(4);\n-                            new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n-                        }\n-\n-                        if let Some(last_arg) = last_arg {\n-                            new_args.push(last_arg);\n-                        }\n-\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n-                        | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n-                        | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n-                        | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let last_arg = new_args.pop().expect(\"last arg\");\n-                        let arg3_type = gcc_func.get_param_type(2);\n-                        let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n-                        new_args.push(undefined);\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-                        new_args.push(last_arg);\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let last_arg = new_args.pop().expect(\"last arg\");\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-                        new_args.push(last_arg);\n-                        args = new_args.into();\n-                    },\n-                    _ => (),\n+                let mut new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let first_arg = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(first_arg);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\" | \"__builtin_ia32_pminuq256_mask\"\n+                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_prold256_mask\" | \"__builtin_ia32_prold128_mask\"\n+                | \"__builtin_ia32_prord512_mask\" | \"__builtin_ia32_prord256_mask\" | \"__builtin_ia32_prord128_mask\"\n+                | \"__builtin_ia32_prolq256_mask\" | \"__builtin_ia32_prolq128_mask\" | \"__builtin_ia32_prorq256_mask\"\n+                | \"__builtin_ia32_prorq128_mask\" | \"__builtin_ia32_psraq256_mask\" | \"__builtin_ia32_psraq128_mask\"\n+                | \"__builtin_ia32_psraqi256_mask\" | \"__builtin_ia32_psraqi128_mask\" | \"__builtin_ia32_psravq256_mask\"\n+                | \"__builtin_ia32_psravq128_mask\" | \"__builtin_ia32_prolvd256_mask\" | \"__builtin_ia32_prolvd128_mask\"\n+                | \"__builtin_ia32_prorvd256_mask\" | \"__builtin_ia32_prorvd128_mask\" | \"__builtin_ia32_prolvq256_mask\"\n+                | \"__builtin_ia32_prolvq128_mask\" | \"__builtin_ia32_prorvq256_mask\" | \"__builtin_ia32_prorvq128_mask\"\n+                | \"__builtin_ia32_permvardi256_mask\" | \"__builtin_ia32_permvardf512_mask\" | \"__builtin_ia32_permvardf256_mask\"\n+                | \"__builtin_ia32_pmulhuw512_mask\" | \"__builtin_ia32_pmulhw512_mask\" | \"__builtin_ia32_pmulhrsw512_mask\"\n+                | \"__builtin_ia32_pmaxuw512_mask\" | \"__builtin_ia32_pmaxub512_mask\" | \"__builtin_ia32_pmaxsw512_mask\"\n+                | \"__builtin_ia32_pmaxsb512_mask\" | \"__builtin_ia32_pminuw512_mask\" | \"__builtin_ia32_pminub512_mask\"\n+                | \"__builtin_ia32_pminsw512_mask\" | \"__builtin_ia32_pminsb512_mask\"\n+                | \"__builtin_ia32_pmaddwd512_mask\" | \"__builtin_ia32_pmaddubsw512_mask\" | \"__builtin_ia32_packssdw512_mask\"\n+                | \"__builtin_ia32_packsswb512_mask\" | \"__builtin_ia32_packusdw512_mask\" | \"__builtin_ia32_packuswb512_mask\"\n+                | \"__builtin_ia32_pavgw512_mask\" | \"__builtin_ia32_pavgb512_mask\" | \"__builtin_ia32_psllw512_mask\"\n+                | \"__builtin_ia32_psllwi512_mask\" | \"__builtin_ia32_psllv32hi_mask\" | \"__builtin_ia32_psrlw512_mask\"\n+                | \"__builtin_ia32_psrlwi512_mask\" | \"__builtin_ia32_psllv16hi_mask\" | \"__builtin_ia32_psllv8hi_mask\"\n+                | \"__builtin_ia32_psrlv32hi_mask\" | \"__builtin_ia32_psraw512_mask\" | \"__builtin_ia32_psrawi512_mask\"\n+                | \"__builtin_ia32_psrlv16hi_mask\" | \"__builtin_ia32_psrlv8hi_mask\" | \"__builtin_ia32_psrav32hi_mask\"\n+                | \"__builtin_ia32_permvarhi512_mask\" | \"__builtin_ia32_pshufb512_mask\" | \"__builtin_ia32_psrav16hi_mask\"\n+                | \"__builtin_ia32_psrav8hi_mask\" | \"__builtin_ia32_permvarhi256_mask\" | \"__builtin_ia32_permvarhi128_mask\"\n+                => {\n+                let mut new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_dbpsadbw512_mask\" | \"__builtin_ia32_dbpsadbw256_mask\" | \"__builtin_ia32_dbpsadbw128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let vector_type = arg4_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg4_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg5_type = gcc_func.get_param_type(4);\n+                let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vplzcntd_512_mask\" | \"__builtin_ia32_vplzcntd_256_mask\" | \"__builtin_ia32_vplzcntd_128_mask\"\n+                | \"__builtin_ia32_vplzcntq_512_mask\" | \"__builtin_ia32_vplzcntq_256_mask\" | \"__builtin_ia32_vplzcntq_128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                // Remove last arg as it doesn't seem to be used in GCC and is always false.\n+                new_args.pop();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let vector_type = arg2_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg2_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpconflictsi_512_mask\" | \"__builtin_ia32_vpconflictsi_256_mask\"\n+                | \"__builtin_ia32_vpconflictsi_128_mask\" | \"__builtin_ia32_vpconflictdi_512_mask\"\n+                | \"__builtin_ia32_vpconflictdi_256_mask\" | \"__builtin_ia32_vpconflictdi_128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let vector_type = arg2_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg2_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n+                | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n+                | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg5_type = gcc_func.get_param_type(4);\n+                let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+\n+                let mut last_arg = None;\n+                if args.len() == 4 {\n+                    last_arg = new_args.pop();\n+                }\n+\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+\n+                if args.len() == 3 {\n+                    // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n+                    // the same GCC intrinsic, but the former has 3 parameters and the\n+                    // latter has 4 so it doesn't require this additional argument.\n+                    let arg5_type = gcc_func.get_param_type(4);\n+                    new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n+                }\n+\n+                if let Some(last_arg) = last_arg {\n+                    new_args.push(last_arg);\n+                }\n+\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n+                | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n+                | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n+                | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n+                | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                |  \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(undefined);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpermi2vard512_mask\" | \"__builtin_ia32_vpermi2vard256_mask\"\n+                | \"__builtin_ia32_vpermi2vard128_mask\" | \"__builtin_ia32_vpermi2varq512_mask\"\n+                | \"__builtin_ia32_vpermi2varq256_mask\" | \"__builtin_ia32_vpermi2varq128_mask\"\n+                | \"__builtin_ia32_vpermi2varps512_mask\" | \"__builtin_ia32_vpermi2varps256_mask\"\n+                | \"__builtin_ia32_vpermi2varps128_mask\" | \"__builtin_ia32_vpermi2varpd512_mask\"\n+                | \"__builtin_ia32_vpermi2varpd256_mask\" | \"__builtin_ia32_vpermi2varpd128_mask\" | \"__builtin_ia32_vpmadd52huq512_mask\"\n+                | \"__builtin_ia32_vpmadd52luq512_mask\" | \"__builtin_ia32_vpmadd52huq256_mask\" | \"__builtin_ia32_vpmadd52luq256_mask\"\n+                | \"__builtin_ia32_vpmadd52huq128_mask\"\n+                => {\n+                let mut new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\"\n+                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let undefined = builder.current_func().new_local(None, arg2_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(undefined);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_stmxcsr\" => {\n+                args = vec![].into();\n+            },\n+            \"__builtin_ia32_addcarryx_u64\" | \"__builtin_ia32_sbb_u64\" | \"__builtin_ia32_addcarryx_u32\" | \"__builtin_ia32_sbb_u32\" => {\n+                let mut new_args = args.to_vec();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let variable = builder.current_func().new_local(None, arg2_type, \"addcarryResult\");\n+                new_args.push(variable.get_address(None));\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpermt2varqi512_mask\" | \"__builtin_ia32_vpermt2varqi256_mask\"\n+                | \"__builtin_ia32_vpermt2varqi128_mask\" | \"__builtin_ia32_vpermt2varhi512_mask\"\n+                | \"__builtin_ia32_vpermt2varhi256_mask\" | \"__builtin_ia32_vpermt2varhi128_mask\"\n+                => {\n+                let new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                args = vec![new_args[1], new_args[0], new_args[2], minus_one].into();\n+            },\n+            \"__builtin_ia32_xrstor\" | \"__builtin_ia32_xsavec\" => {\n+                let new_args = args.to_vec();\n+                let thirty_two = builder.context.new_rvalue_from_int(new_args[1].get_type(), 32);\n+                let arg2 = new_args[1] << thirty_two | new_args[2];\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg2 = builder.context.new_cast(None, arg2, arg2_type);\n+                args = vec![new_args[0], arg2].into();\n+            },\n+            _ => (),\n+        }\n+    }\n+    else {\n+        match &*func_name {\n+            \"__builtin_ia32_rndscaless_mask_round\" | \"__builtin_ia32_rndscalesd_mask_round\" => {\n+                let new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let arg3 = builder.context.new_cast(None, new_args[4], arg3_type);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let arg4 = builder.context.new_bitcast(None, new_args[2], arg4_type);\n+                args = vec![new_args[0], new_args[1], arg3, arg4, new_args[3], new_args[5]].into();\n+            },\n+            // NOTE: the LLVM intrinsic receives 3 floats, but the GCC builtin requires 3 vectors.\n+            // FIXME: the intrinsics like _mm_mask_fmadd_sd should probably directly call the GCC\n+            // instrinsic to avoid this.\n+            \"__builtin_ia32_vfmaddss3_round\" => {\n+                let new_args = args.to_vec();\n+                let arg1_type = gcc_func.get_param_type(0);\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let a = builder.context.new_rvalue_from_vector(None, arg1_type, &[new_args[0]; 4]);\n+                let b = builder.context.new_rvalue_from_vector(None, arg2_type, &[new_args[1]; 4]);\n+                let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 4]);\n+                args = vec![a, b, c, new_args[3]].into();\n+            },\n+            \"__builtin_ia32_vfmaddsd3_round\" => {\n+                let new_args = args.to_vec();\n+                let arg1_type = gcc_func.get_param_type(0);\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let a = builder.context.new_rvalue_from_vector(None, arg1_type, &[new_args[0]; 2]);\n+                let b = builder.context.new_rvalue_from_vector(None, arg2_type, &[new_args[1]; 2]);\n+                let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 2]);\n+                args = vec![a, b, c, new_args[3]].into();\n+            },\n+            \"__builtin_ia32_vfmaddsubpd256\" | \"__builtin_ia32_vfmaddsubps\" | \"__builtin_ia32_vfmaddsubps256\" => {\n+                let mut new_args = args.to_vec();\n+                let arg3 = &mut new_args[2];\n+                *arg3 = builder.context.new_unary_op(None, UnaryOp::Minus, arg3.get_type(), *arg3);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_ldmxcsr\" => {\n+                // The builtin __builtin_ia32_ldmxcsr takes an integer value while llvm.x86.sse.ldmxcsr takes a pointer,\n+                // so dereference the pointer.\n+                let mut new_args = args.to_vec();\n+                let uint_ptr_type = builder.uint_type.make_pointer();\n+                let arg1 = builder.context.new_cast(None, args[0], uint_ptr_type);\n+                new_args[0] = arg1.dereference(None).to_rvalue();\n+                args = new_args.into();\n+            },\n+            _ => (),\n         }\n     }\n \n     args\n }\n \n+pub fn adjust_intrinsic_return_value<'a, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, mut return_value: RValue<'gcc>, func_name: &str, args: &[RValue<'gcc>], args_adjusted: bool, orig_args: &[RValue<'gcc>]) -> RValue<'gcc> {\n+    match func_name {\n+        \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => {\n+            #[cfg(feature=\"master\")]\n+            {\n+                let zero = builder.context.new_rvalue_zero(builder.int_type);\n+                return_value = builder.context.new_vector_access(None, return_value, zero).to_rvalue();\n+            }\n+        },\n+        \"__builtin_ia32_addcarryx_u64\" | \"__builtin_ia32_sbb_u64\" | \"__builtin_ia32_addcarryx_u32\" | \"__builtin_ia32_sbb_u32\" => {\n+            // Both llvm.x86.addcarry.32 and llvm.x86.addcarryx.u32 points to the same GCC builtin,\n+            // but only the former requires adjusting the return value.\n+            // Those 2 LLVM intrinsics differ by their argument count, that's why we check if the\n+            // arguments were adjusted.\n+            if args_adjusted {\n+                let last_arg = args.last().expect(\"last arg\");\n+                let field1 = builder.context.new_field(None, builder.u8_type, \"carryFlag\");\n+                let field2 = builder.context.new_field(None, args[1].get_type(), \"carryResult\");\n+                let struct_type = builder.context.new_struct_type(None, \"addcarryResult\", &[field1, field2]);\n+                return_value = builder.context.new_struct_constructor(None, struct_type.as_type(), None, &[return_value, last_arg.dereference(None).to_rvalue()]);\n+            }\n+        },\n+        \"__builtin_ia32_stmxcsr\" => {\n+            // The builtin __builtin_ia32_stmxcsr returns a value while llvm.x86.sse.stmxcsr writes\n+            // the result in its pointer argument.\n+            // We removed the argument since __builtin_ia32_stmxcsr takes no arguments, so we need\n+            // to get back the original argument to get the pointer we need to write the result to.\n+            let uint_ptr_type = builder.uint_type.make_pointer();\n+            let ptr = builder.context.new_cast(None, orig_args[0], uint_ptr_type);\n+            builder.llbb().add_assignment(None, ptr.dereference(None), return_value);\n+            // The return value was assigned to the result pointer above. In order to not call the\n+            // builtin twice, we overwrite the return value with a dummy value.\n+            return_value = builder.context.new_rvalue_zero(builder.int_type);\n+        },\n+        _ => (),\n+    }\n+\n+    return_value\n+}\n+\n pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n-    // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n-    // last argument type check.\n     // FIXME(antoyo): find a way to refactor in order to avoid this hack.\n     match func_name {\n+        // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n+        // last argument type check.\n         \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n             | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" | \"__builtin_ia32_sqrtps512_mask\"\n             | \"__builtin_ia32_sqrtpd512_mask\" | \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n             | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n             | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n             | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n-            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\"\n+            | \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\" => {\n                 if index == args_len - 1 {\n                     return true;\n                 }\n             },\n+        \"__builtin_ia32_rndscaless_mask_round\" | \"__builtin_ia32_rndscalesd_mask_round\" => {\n+            if index == 2 || index == 3 {\n+                return true;\n+            }\n+        },\n         \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n             // Since there are two LLVM intrinsics that map to each of these GCC builtins and only\n             // one of them has a missing parameter before the last one, we check the number of\n@@ -162,6 +364,14 @@ pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n                 return true;\n             }\n         },\n+        // NOTE: the LLVM intrinsic receives 3 floats, but the GCC builtin requires 3 vectors.\n+        \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => return true,\n+        \"__builtin_ia32_vplzcntd_512_mask\" | \"__builtin_ia32_vplzcntd_256_mask\" | \"__builtin_ia32_vplzcntd_128_mask\"\n+            | \"__builtin_ia32_vplzcntq_512_mask\" | \"__builtin_ia32_vplzcntq_256_mask\" | \"__builtin_ia32_vplzcntq_128_mask\" => {\n+            if index == args_len - 1 {\n+                return true;\n+            }\n+        },\n         _ => (),\n     }\n \n@@ -189,18 +399,10 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.sqrt.v2f64\" => \"__builtin_ia32_sqrtpd\",\n         \"llvm.x86.avx512.pmul.dq.512\" => \"__builtin_ia32_pmuldq512_mask\",\n         \"llvm.x86.avx512.pmulu.dq.512\" => \"__builtin_ia32_pmuludq512_mask\",\n-        \"llvm.x86.avx512.mask.pmaxs.q.256\" => \"__builtin_ia32_pmaxsq256_mask\",\n-        \"llvm.x86.avx512.mask.pmaxs.q.128\" => \"__builtin_ia32_pmaxsq128_mask\",\n         \"llvm.x86.avx512.max.ps.512\" => \"__builtin_ia32_maxps512_mask\",\n         \"llvm.x86.avx512.max.pd.512\" => \"__builtin_ia32_maxpd512_mask\",\n-        \"llvm.x86.avx512.mask.pmaxu.q.256\" => \"__builtin_ia32_pmaxuq256_mask\",\n-        \"llvm.x86.avx512.mask.pmaxu.q.128\" => \"__builtin_ia32_pmaxuq128_mask\",\n-        \"llvm.x86.avx512.mask.pmins.q.256\" => \"__builtin_ia32_pminsq256_mask\",\n-        \"llvm.x86.avx512.mask.pmins.q.128\" => \"__builtin_ia32_pminsq128_mask\",\n         \"llvm.x86.avx512.min.ps.512\" => \"__builtin_ia32_minps512_mask\",\n         \"llvm.x86.avx512.min.pd.512\" => \"__builtin_ia32_minpd512_mask\",\n-        \"llvm.x86.avx512.mask.pminu.q.256\" => \"__builtin_ia32_pminuq256_mask\",\n-        \"llvm.x86.avx512.mask.pminu.q.128\" => \"__builtin_ia32_pminuq128_mask\",\n         \"llvm.fma.v16f32\" => \"__builtin_ia32_vfmaddps512_mask\",\n         \"llvm.fma.v8f64\" => \"__builtin_ia32_vfmaddpd512_mask\",\n         \"llvm.x86.avx512.vfmaddsub.ps.512\" => \"__builtin_ia32_vfmaddsubps512_mask\",\n@@ -221,6 +423,151 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx512.div.pd.512\" => \"__builtin_ia32_divpd512_mask\",\n         \"llvm.x86.avx512.vfmadd.ps.512\" => \"__builtin_ia32_vfmaddps512_mask\",\n         \"llvm.x86.avx512.vfmadd.pd.512\" => \"__builtin_ia32_vfmaddpd512_mask\",\n+        \"llvm.x86.avx512.sitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtdq2ps512_mask\",\n+        \"llvm.x86.avx512.uitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtudq2ps512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.512\" => \"__builtin_ia32_ucmpd512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.256\" => \"__builtin_ia32_ucmpd256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.128\" => \"__builtin_ia32_ucmpd128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.512\" => \"__builtin_ia32_cmpd512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.256\" => \"__builtin_ia32_cmpd256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.128\" => \"__builtin_ia32_cmpd128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.512\" => \"__builtin_ia32_ucmpq512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.256\" => \"__builtin_ia32_ucmpq256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.128\" => \"__builtin_ia32_ucmpq128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.512\" => \"__builtin_ia32_cmpq512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.256\" => \"__builtin_ia32_cmpq256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.128\" => \"__builtin_ia32_cmpq128_mask\",\n+        \"llvm.x86.avx512.mask.max.ss.round\" => \"__builtin_ia32_maxss_mask_round\",\n+        \"llvm.x86.avx512.mask.max.sd.round\" => \"__builtin_ia32_maxsd_mask_round\",\n+        \"llvm.x86.avx512.mask.min.ss.round\" => \"__builtin_ia32_minss_mask_round\",\n+        \"llvm.x86.avx512.mask.min.sd.round\" => \"__builtin_ia32_minsd_mask_round\",\n+        \"llvm.x86.avx512.mask.sqrt.ss\" => \"__builtin_ia32_sqrtss_mask_round\",\n+        \"llvm.x86.avx512.mask.sqrt.sd\" => \"__builtin_ia32_sqrtsd_mask_round\",\n+        \"llvm.x86.avx512.mask.getexp.ss\" => \"__builtin_ia32_getexpss_mask_round\",\n+        \"llvm.x86.avx512.mask.getexp.sd\" => \"__builtin_ia32_getexpsd_mask_round\",\n+        \"llvm.x86.avx512.mask.getmant.ss\" => \"__builtin_ia32_getmantss_mask_round\",\n+        \"llvm.x86.avx512.mask.getmant.sd\" => \"__builtin_ia32_getmantsd_mask_round\",\n+        \"llvm.x86.avx512.mask.rndscale.ss\" => \"__builtin_ia32_rndscaless_mask_round\",\n+        \"llvm.x86.avx512.mask.rndscale.sd\" => \"__builtin_ia32_rndscalesd_mask_round\",\n+        \"llvm.x86.avx512.mask.scalef.ss\" => \"__builtin_ia32_scalefss_mask_round\",\n+        \"llvm.x86.avx512.mask.scalef.sd\" => \"__builtin_ia32_scalefsd_mask_round\",\n+        \"llvm.x86.avx512.vfmadd.f32\" => \"__builtin_ia32_vfmaddss3_round\",\n+        \"llvm.x86.avx512.vfmadd.f64\" => \"__builtin_ia32_vfmaddsd3_round\",\n+        \"llvm.ceil.v4f64\" => \"__builtin_ia32_ceilpd256\",\n+        \"llvm.ceil.v8f32\" => \"__builtin_ia32_ceilps256\",\n+        \"llvm.floor.v4f64\" => \"__builtin_ia32_floorpd256\",\n+        \"llvm.floor.v8f32\" => \"__builtin_ia32_floorps256\",\n+        \"llvm.sqrt.v4f64\" => \"__builtin_ia32_sqrtpd256\",\n+        \"llvm.x86.sse.stmxcsr\" => \"__builtin_ia32_stmxcsr\",\n+        \"llvm.x86.sse.ldmxcsr\" => \"__builtin_ia32_ldmxcsr\",\n+        \"llvm.ctpop.v16i32\" => \"__builtin_ia32_vpopcountd_v16si\",\n+        \"llvm.ctpop.v8i32\" => \"__builtin_ia32_vpopcountd_v8si\",\n+        \"llvm.ctpop.v4i32\" => \"__builtin_ia32_vpopcountd_v4si\",\n+        \"llvm.ctpop.v8i64\" => \"__builtin_ia32_vpopcountq_v8di\",\n+        \"llvm.ctpop.v4i64\" => \"__builtin_ia32_vpopcountq_v4di\",\n+        \"llvm.ctpop.v2i64\" => \"__builtin_ia32_vpopcountq_v2di\",\n+        \"llvm.x86.addcarry.64\" => \"__builtin_ia32_addcarryx_u64\",\n+        \"llvm.x86.subborrow.64\" => \"__builtin_ia32_sbb_u64\",\n+        \"llvm.floor.v2f64\" => \"__builtin_ia32_floorpd\",\n+        \"llvm.floor.v4f32\" => \"__builtin_ia32_floorps\",\n+        \"llvm.ceil.v2f64\" => \"__builtin_ia32_ceilpd\",\n+        \"llvm.ceil.v4f32\" => \"__builtin_ia32_ceilps\",\n+        \"llvm.fma.v2f64\" => \"__builtin_ia32_vfmaddpd\",\n+        \"llvm.fma.v4f64\" => \"__builtin_ia32_vfmaddpd256\",\n+        \"llvm.fma.v4f32\" => \"__builtin_ia32_vfmaddps\",\n+        \"llvm.fma.v8f32\" => \"__builtin_ia32_vfmaddps256\",\n+        \"llvm.ctlz.v16i32\" => \"__builtin_ia32_vplzcntd_512_mask\",\n+        \"llvm.ctlz.v8i32\" => \"__builtin_ia32_vplzcntd_256_mask\",\n+        \"llvm.ctlz.v4i32\" => \"__builtin_ia32_vplzcntd_128_mask\",\n+        \"llvm.ctlz.v8i64\" => \"__builtin_ia32_vplzcntq_512_mask\",\n+        \"llvm.ctlz.v4i64\" => \"__builtin_ia32_vplzcntq_256_mask\",\n+        \"llvm.ctlz.v2i64\" => \"__builtin_ia32_vplzcntq_128_mask\",\n+        \"llvm.ctpop.v32i16\" => \"__builtin_ia32_vpopcountw_v32hi\",\n+        \"llvm.x86.fma.vfmsub.sd\" => \"__builtin_ia32_vfmsubsd3\",\n+        \"llvm.x86.fma.vfmsub.ss\" => \"__builtin_ia32_vfmsubss3\",\n+        \"llvm.x86.fma.vfmsubadd.pd\" => \"__builtin_ia32_vfmaddsubpd\",\n+        \"llvm.x86.fma.vfmsubadd.pd.256\" => \"__builtin_ia32_vfmaddsubpd256\",\n+        \"llvm.x86.fma.vfmsubadd.ps\" => \"__builtin_ia32_vfmaddsubps\",\n+        \"llvm.x86.fma.vfmsubadd.ps.256\" => \"__builtin_ia32_vfmaddsubps256\",\n+        \"llvm.x86.fma.vfnmadd.sd\" => \"__builtin_ia32_vfnmaddsd3\",\n+        \"llvm.x86.fma.vfnmadd.ss\" => \"__builtin_ia32_vfnmaddss3\",\n+        \"llvm.x86.fma.vfnmsub.sd\" => \"__builtin_ia32_vfnmsubsd3\",\n+        \"llvm.x86.fma.vfnmsub.ss\" => \"__builtin_ia32_vfnmsubss3\",\n+        \"llvm.x86.avx512.conflict.d.512\" => \"__builtin_ia32_vpconflictsi_512_mask\",\n+        \"llvm.x86.avx512.conflict.d.256\" => \"__builtin_ia32_vpconflictsi_256_mask\",\n+        \"llvm.x86.avx512.conflict.d.128\" => \"__builtin_ia32_vpconflictsi_128_mask\",\n+        \"llvm.x86.avx512.conflict.q.512\" => \"__builtin_ia32_vpconflictdi_512_mask\",\n+        \"llvm.x86.avx512.conflict.q.256\" => \"__builtin_ia32_vpconflictdi_256_mask\",\n+        \"llvm.x86.avx512.conflict.q.128\" => \"__builtin_ia32_vpconflictdi_128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.512\" => \"__builtin_ia32_vpermt2varqi512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.256\" => \"__builtin_ia32_vpermt2varqi256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.128\" => \"__builtin_ia32_vpermt2varqi128_mask\",\n+        \"llvm.x86.avx512.permvar.qi.512\" => \"__builtin_ia32_permvarqi512_mask\",\n+        \"llvm.x86.avx512.permvar.qi.256\" => \"__builtin_ia32_permvarqi256_mask\",\n+        \"llvm.x86.avx512.permvar.qi.128\" => \"__builtin_ia32_permvarqi128_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.512\" => \"__builtin_ia32_vpmultishiftqb512_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.256\" => \"__builtin_ia32_vpmultishiftqb256_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.128\" => \"__builtin_ia32_vpmultishiftqb128_mask\",\n+        \"llvm.ctpop.v16i16\" => \"__builtin_ia32_vpopcountw_v16hi\",\n+        \"llvm.ctpop.v8i16\" => \"__builtin_ia32_vpopcountw_v8hi\",\n+        \"llvm.ctpop.v64i8\" => \"__builtin_ia32_vpopcountb_v64qi\",\n+        \"llvm.ctpop.v32i8\" => \"__builtin_ia32_vpopcountb_v32qi\",\n+        \"llvm.ctpop.v16i8\" => \"__builtin_ia32_vpopcountb_v16qi\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.512\" => \"__builtin_ia32_vpshufbitqmb512_mask\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.256\" => \"__builtin_ia32_vpshufbitqmb256_mask\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.128\" => \"__builtin_ia32_vpshufbitqmb128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.512\" => \"__builtin_ia32_ucmpw512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.256\" => \"__builtin_ia32_ucmpw256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.128\" => \"__builtin_ia32_ucmpw128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.512\" => \"__builtin_ia32_ucmpb512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.256\" => \"__builtin_ia32_ucmpb256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.128\" => \"__builtin_ia32_ucmpb128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.512\" => \"__builtin_ia32_cmpw512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.256\" => \"__builtin_ia32_cmpw256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.128\" => \"__builtin_ia32_cmpw128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.512\" => \"__builtin_ia32_cmpb512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.256\" => \"__builtin_ia32_cmpb256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.128\" => \"__builtin_ia32_cmpb128_mask\",\n+        \"llvm.x86.xrstor\" => \"__builtin_ia32_xrstor\",\n+        \"llvm.x86.xsavec\" => \"__builtin_ia32_xsavec\",\n+        \"llvm.x86.addcarry.32\" => \"__builtin_ia32_addcarryx_u32\",\n+        \"llvm.x86.subborrow.32\" => \"__builtin_ia32_sbb_u32\",\n+        \"llvm.x86.avx512.mask.compress.store.w.512\" => \"__builtin_ia32_compressstoreuhi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.w.256\" => \"__builtin_ia32_compressstoreuhi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.w.128\" => \"__builtin_ia32_compressstoreuhi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.512\" => \"__builtin_ia32_compressstoreuqi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.256\" => \"__builtin_ia32_compressstoreuqi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.128\" => \"__builtin_ia32_compressstoreuqi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.512\" => \"__builtin_ia32_compresshi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.256\" => \"__builtin_ia32_compresshi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.128\" => \"__builtin_ia32_compresshi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.512\" => \"__builtin_ia32_compressqi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.256\" => \"__builtin_ia32_compressqi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.128\" => \"__builtin_ia32_compressqi128_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.512\" => \"__builtin_ia32_expandhi512_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.256\" => \"__builtin_ia32_expandhi256_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.128\" => \"__builtin_ia32_expandhi128_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.512\" => \"__builtin_ia32_expandqi512_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.256\" => \"__builtin_ia32_expandqi256_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.128\" => \"__builtin_ia32_expandqi128_mask\",\n+        \"llvm.fshl.v8i64\" => \"__builtin_ia32_vpshldv_v8di\",\n+        \"llvm.fshl.v4i64\" => \"__builtin_ia32_vpshldv_v4di\",\n+        \"llvm.fshl.v2i64\" => \"__builtin_ia32_vpshldv_v2di\",\n+        \"llvm.fshl.v16i32\" => \"__builtin_ia32_vpshldv_v16si\",\n+        \"llvm.fshl.v8i32\" => \"__builtin_ia32_vpshldv_v8si\",\n+        \"llvm.fshl.v4i32\" => \"__builtin_ia32_vpshldv_v4si\",\n+        \"llvm.fshl.v32i16\" => \"__builtin_ia32_vpshldv_v32hi\",\n+        \"llvm.fshl.v16i16\" => \"__builtin_ia32_vpshldv_v16hi\",\n+        \"llvm.fshl.v8i16\" => \"__builtin_ia32_vpshldv_v8hi\",\n+        \"llvm.fshr.v8i64\" => \"__builtin_ia32_vpshrdv_v8di\",\n+        \"llvm.fshr.v4i64\" => \"__builtin_ia32_vpshrdv_v4di\",\n+        \"llvm.fshr.v2i64\" => \"__builtin_ia32_vpshrdv_v2di\",\n+        \"llvm.fshr.v16i32\" => \"__builtin_ia32_vpshrdv_v16si\",\n+        \"llvm.fshr.v8i32\" => \"__builtin_ia32_vpshrdv_v8si\",\n+        \"llvm.fshr.v4i32\" => \"__builtin_ia32_vpshrdv_v4si\",\n+        \"llvm.fshr.v32i16\" => \"__builtin_ia32_vpshrdv_v32hi\",\n+        \"llvm.fshr.v16i16\" => \"__builtin_ia32_vpshrdv_v16hi\",\n+        \"llvm.fshr.v8i16\" => \"__builtin_ia32_vpshrdv_v8hi\",\n \n         // The above doc points to unknown builtins for the following, so override them:\n         \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gathersiv4si\",\n@@ -239,7 +586,151 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx2.gather.q.q.256\" => \"__builtin_ia32_gatherdiv4di\",\n         \"llvm.x86.avx2.gather.q.pd\" => \"__builtin_ia32_gatherdiv2df\",\n         \"llvm.x86.avx2.gather.q.pd.256\" => \"__builtin_ia32_gatherdiv4df\",\n-        \"\" => \"\",\n+        \"llvm.x86.avx512.pslli.d.512\" => \"__builtin_ia32_pslldi512_mask\",\n+        \"llvm.x86.avx512.psrli.d.512\" => \"__builtin_ia32_psrldi512_mask\",\n+        \"llvm.x86.avx512.pslli.q.512\" => \"__builtin_ia32_psllqi512_mask\",\n+        \"llvm.x86.avx512.psrli.q.512\" => \"__builtin_ia32_psrlqi512_mask\",\n+        \"llvm.x86.avx512.psll.d.512\" => \"__builtin_ia32_pslld512_mask\",\n+        \"llvm.x86.avx512.psrl.d.512\" => \"__builtin_ia32_psrld512_mask\",\n+        \"llvm.x86.avx512.psll.q.512\" => \"__builtin_ia32_psllq512_mask\",\n+        \"llvm.x86.avx512.psrl.q.512\" => \"__builtin_ia32_psrlq512_mask\",\n+        \"llvm.x86.avx512.psra.d.512\" => \"__builtin_ia32_psrad512_mask\",\n+        \"llvm.x86.avx512.psra.q.512\" => \"__builtin_ia32_psraq512_mask\",\n+        \"llvm.x86.avx512.psra.q.256\" => \"__builtin_ia32_psraq256_mask\",\n+        \"llvm.x86.avx512.psra.q.128\" => \"__builtin_ia32_psraq128_mask\",\n+        \"llvm.x86.avx512.psrai.d.512\" => \"__builtin_ia32_psradi512_mask\",\n+        \"llvm.x86.avx512.psrai.q.512\" => \"__builtin_ia32_psraqi512_mask\",\n+        \"llvm.x86.avx512.psrai.q.256\" => \"__builtin_ia32_psraqi256_mask\",\n+        \"llvm.x86.avx512.psrai.q.128\" => \"__builtin_ia32_psraqi128_mask\",\n+        \"llvm.x86.avx512.psrav.d.512\" => \"__builtin_ia32_psrav16si_mask\",\n+        \"llvm.x86.avx512.psrav.q.512\" => \"__builtin_ia32_psrav8di_mask\",\n+        \"llvm.x86.avx512.psrav.q.256\" => \"__builtin_ia32_psravq256_mask\",\n+        \"llvm.x86.avx512.psrav.q.128\" => \"__builtin_ia32_psravq128_mask\",\n+        \"llvm.x86.avx512.psllv.d.512\" => \"__builtin_ia32_psllv16si_mask\",\n+        \"llvm.x86.avx512.psrlv.d.512\" => \"__builtin_ia32_psrlv16si_mask\",\n+        \"llvm.x86.avx512.psllv.q.512\" => \"__builtin_ia32_psllv8di_mask\",\n+        \"llvm.x86.avx512.psrlv.q.512\" => \"__builtin_ia32_psrlv8di_mask\",\n+        \"llvm.x86.avx512.permvar.si.512\" => \"__builtin_ia32_permvarsi512_mask\",\n+        \"llvm.x86.avx512.vpermilvar.ps.512\" => \"__builtin_ia32_vpermilvarps512_mask\",\n+        \"llvm.x86.avx512.vpermilvar.pd.512\" => \"__builtin_ia32_vpermilvarpd512_mask\",\n+        \"llvm.x86.avx512.permvar.di.512\" => \"__builtin_ia32_permvardi512_mask\",\n+        \"llvm.x86.avx512.permvar.di.256\" => \"__builtin_ia32_permvardi256_mask\",\n+        \"llvm.x86.avx512.permvar.sf.512\" => \"__builtin_ia32_permvarsf512_mask\",\n+        \"llvm.x86.avx512.permvar.df.512\" => \"__builtin_ia32_permvardf512_mask\",\n+        \"llvm.x86.avx512.permvar.df.256\" => \"__builtin_ia32_permvardf256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.512\" => \"__builtin_ia32_vpermi2vard512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.256\" => \"__builtin_ia32_vpermi2vard256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.128\" => \"__builtin_ia32_vpermi2vard128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.512\" => \"__builtin_ia32_vpermi2varq512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.256\" => \"__builtin_ia32_vpermi2varq256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.128\" => \"__builtin_ia32_vpermi2varq128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.512\" => \"__builtin_ia32_vpermi2varps512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.256\" => \"__builtin_ia32_vpermi2varps256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.128\" => \"__builtin_ia32_vpermi2varps128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.512\" => \"__builtin_ia32_vpermi2varpd512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.256\" => \"__builtin_ia32_vpermi2varpd256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.128\" => \"__builtin_ia32_vpermi2varpd128_mask\",\n+        \"llvm.x86.avx512.mask.add.ss.round\" => \"__builtin_ia32_addss_mask_round\",\n+        \"llvm.x86.avx512.mask.add.sd.round\" => \"__builtin_ia32_addsd_mask_round\",\n+        \"llvm.x86.avx512.mask.sub.ss.round\" => \"__builtin_ia32_subss_mask_round\",\n+        \"llvm.x86.avx512.mask.sub.sd.round\" => \"__builtin_ia32_subsd_mask_round\",\n+        \"llvm.x86.avx512.mask.mul.ss.round\" => \"__builtin_ia32_mulss_mask_round\",\n+        \"llvm.x86.avx512.mask.mul.sd.round\" => \"__builtin_ia32_mulsd_mask_round\",\n+        \"llvm.x86.avx512.mask.div.ss.round\" => \"__builtin_ia32_divss_mask_round\",\n+        \"llvm.x86.avx512.mask.div.sd.round\" => \"__builtin_ia32_divsd_mask_round\",\n+        \"llvm.x86.avx512.mask.cvtss2sd.round\" => \"__builtin_ia32_cvtss2sd_mask_round\",\n+        \"llvm.x86.avx512.mask.cvtsd2ss.round\" => \"__builtin_ia32_cvtsd2ss_mask_round\",\n+        \"llvm.x86.avx512.mask.range.ss\" => \"__builtin_ia32_rangess128_mask_round\",\n+        \"llvm.x86.avx512.mask.range.sd\" => \"__builtin_ia32_rangesd128_mask_round\",\n+        \"llvm.x86.avx512.rcp28.ss\" => \"__builtin_ia32_rcp28ss_mask_round\",\n+        \"llvm.x86.avx512.rcp28.sd\" => \"__builtin_ia32_rcp28sd_mask_round\",\n+        \"llvm.x86.avx512.rsqrt28.ss\" => \"__builtin_ia32_rsqrt28ss_mask_round\",\n+        \"llvm.x86.avx512.rsqrt28.sd\" => \"__builtin_ia32_rsqrt28sd_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.add.sh.round\" => \"__builtin_ia32_addsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.div.sh.round\" => \"__builtin_ia32_divsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.getmant.sh\" => \"__builtin_ia32_getmantsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.max.sh.round\" => \"__builtin_ia32_maxsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.min.sh.round\" => \"__builtin_ia32_minsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.mul.sh.round\" => \"__builtin_ia32_mulsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.rndscale.sh\" => \"__builtin_ia32_rndscalesh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.scalef.sh\" => \"__builtin_ia32_scalefsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.sub.sh.round\" => \"__builtin_ia32_subsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtsd2sh.round\" => \"__builtin_ia32_vcvtsd2sh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtsh2sd.round\" => \"__builtin_ia32_vcvtsh2sd_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtsh2ss.round\" => \"__builtin_ia32_vcvtsh2ss_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtss2sh.round\" => \"__builtin_ia32_vcvtss2sh_mask_round\",\n+        \"llvm.x86.aesni.aesenc.256\" => \"__builtin_ia32_vaesenc_v32qi\",\n+        \"llvm.x86.aesni.aesenclast.256\" => \"__builtin_ia32_vaesenclast_v32qi\",\n+        \"llvm.x86.aesni.aesdec.256\" => \"__builtin_ia32_vaesdec_v32qi\",\n+        \"llvm.x86.aesni.aesdeclast.256\" => \"__builtin_ia32_vaesdeclast_v32qi\",\n+        \"llvm.x86.aesni.aesenc.512\" => \"__builtin_ia32_vaesenc_v64qi\",\n+        \"llvm.x86.aesni.aesenclast.512\" => \"__builtin_ia32_vaesenclast_v64qi\",\n+        \"llvm.x86.aesni.aesdec.512\" => \"__builtin_ia32_vaesdec_v64qi\",\n+        \"llvm.x86.aesni.aesdeclast.512\" => \"__builtin_ia32_vaesdeclast_v64qi\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.128\" => \"__builtin_ia32_cvtne2ps2bf16_v8hi\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.256\" => \"__builtin_ia32_cvtne2ps2bf16_v16hi\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.512\" => \"__builtin_ia32_cvtne2ps2bf16_v32hi\",\n+        \"llvm.x86.avx512bf16.cvtneps2bf16.256\" => \"__builtin_ia32_cvtneps2bf16_v8sf\",\n+        \"llvm.x86.avx512bf16.cvtneps2bf16.512\" => \"__builtin_ia32_cvtneps2bf16_v16sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.128\" => \"__builtin_ia32_dpbf16ps_v4sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.256\" => \"__builtin_ia32_dpbf16ps_v8sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.512\" => \"__builtin_ia32_dpbf16ps_v16sf\",\n+        \"llvm.x86.pclmulqdq.512\" => \"__builtin_ia32_vpclmulqdq_v8di\",\n+        \"llvm.x86.pclmulqdq.256\" => \"__builtin_ia32_vpclmulqdq_v4di\",\n+        \"llvm.x86.avx512.pmulhu.w.512\" => \"__builtin_ia32_pmulhuw512_mask\",\n+        \"llvm.x86.avx512.pmulh.w.512\" => \"__builtin_ia32_pmulhw512_mask\",\n+        \"llvm.x86.avx512.pmul.hr.sw.512\" => \"__builtin_ia32_pmulhrsw512_mask\",\n+        \"llvm.x86.avx512.pmaddw.d.512\" => \"__builtin_ia32_pmaddwd512_mask\",\n+        \"llvm.x86.avx512.pmaddubs.w.512\" => \"__builtin_ia32_pmaddubsw512_mask\",\n+        \"llvm.x86.avx512.packssdw.512\" => \"__builtin_ia32_packssdw512_mask\",\n+        \"llvm.x86.avx512.packsswb.512\" => \"__builtin_ia32_packsswb512_mask\",\n+        \"llvm.x86.avx512.packusdw.512\" => \"__builtin_ia32_packusdw512_mask\",\n+        \"llvm.x86.avx512.packuswb.512\" => \"__builtin_ia32_packuswb512_mask\",\n+        \"llvm.x86.avx512.pavg.w.512\" => \"__builtin_ia32_pavgw512_mask\",\n+        \"llvm.x86.avx512.pavg.b.512\" => \"__builtin_ia32_pavgb512_mask\",\n+        \"llvm.x86.avx512.psll.w.512\" => \"__builtin_ia32_psllw512_mask\",\n+        \"llvm.x86.avx512.pslli.w.512\" => \"__builtin_ia32_psllwi512_mask\",\n+        \"llvm.x86.avx512.psllv.w.512\" => \"__builtin_ia32_psllv32hi_mask\",\n+        \"llvm.x86.avx512.psllv.w.256\" => \"__builtin_ia32_psllv16hi_mask\",\n+        \"llvm.x86.avx512.psllv.w.128\" => \"__builtin_ia32_psllv8hi_mask\",\n+        \"llvm.x86.avx512.psrl.w.512\" => \"__builtin_ia32_psrlw512_mask\",\n+        \"llvm.x86.avx512.psrli.w.512\" => \"__builtin_ia32_psrlwi512_mask\",\n+        \"llvm.x86.avx512.psrlv.w.512\" => \"__builtin_ia32_psrlv32hi_mask\",\n+        \"llvm.x86.avx512.psrlv.w.256\" => \"__builtin_ia32_psrlv16hi_mask\",\n+        \"llvm.x86.avx512.psrlv.w.128\" => \"__builtin_ia32_psrlv8hi_mask\",\n+        \"llvm.x86.avx512.psra.w.512\" => \"__builtin_ia32_psraw512_mask\",\n+        \"llvm.x86.avx512.psrai.w.512\" => \"__builtin_ia32_psrawi512_mask\",\n+        \"llvm.x86.avx512.psrav.w.512\" => \"__builtin_ia32_psrav32hi_mask\",\n+        \"llvm.x86.avx512.psrav.w.256\" => \"__builtin_ia32_psrav16hi_mask\",\n+        \"llvm.x86.avx512.psrav.w.128\" => \"__builtin_ia32_psrav8hi_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.512\" => \"__builtin_ia32_vpermt2varhi512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.256\" => \"__builtin_ia32_vpermt2varhi256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.128\" => \"__builtin_ia32_vpermt2varhi128_mask\",\n+        \"llvm.x86.avx512.permvar.hi.512\" => \"__builtin_ia32_permvarhi512_mask\",\n+        \"llvm.x86.avx512.permvar.hi.256\" => \"__builtin_ia32_permvarhi256_mask\",\n+        \"llvm.x86.avx512.permvar.hi.128\" => \"__builtin_ia32_permvarhi128_mask\",\n+        \"llvm.x86.avx512.pshuf.b.512\" => \"__builtin_ia32_pshufb512_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.512\" => \"__builtin_ia32_dbpsadbw512_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.256\" => \"__builtin_ia32_dbpsadbw256_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.128\" => \"__builtin_ia32_dbpsadbw128_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.512\" => \"__builtin_ia32_vpmadd52huq512_mask\",\n+        \"llvm.x86.avx512.vpmadd52l.uq.512\" => \"__builtin_ia32_vpmadd52luq512_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.256\" => \"__builtin_ia32_vpmadd52huq256_mask\",\n+        \"llvm.x86.avx512.vpmadd52l.uq.256\" => \"__builtin_ia32_vpmadd52luq256_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.128\" => \"__builtin_ia32_vpmadd52huq128_mask\",\n+        \"llvm.x86.avx512.vpdpwssd.512\" => \"__builtin_ia32_vpdpwssd_v16si\",\n+        \"llvm.x86.avx512.vpdpwssd.256\" => \"__builtin_ia32_vpdpwssd_v8si\",\n+        \"llvm.x86.avx512.vpdpwssd.128\" => \"__builtin_ia32_vpdpwssd_v4si\",\n+        \"llvm.x86.avx512.vpdpwssds.512\" => \"__builtin_ia32_vpdpwssds_v16si\",\n+        \"llvm.x86.avx512.vpdpwssds.256\" => \"__builtin_ia32_vpdpwssds_v8si\",\n+        \"llvm.x86.avx512.vpdpwssds.128\" => \"__builtin_ia32_vpdpwssds_v4si\",\n+        \"llvm.x86.avx512.vpdpbusd.512\" => \"__builtin_ia32_vpdpbusd_v16si\",\n+        \"llvm.x86.avx512.vpdpbusd.256\" => \"__builtin_ia32_vpdpbusd_v8si\",\n+        \"llvm.x86.avx512.vpdpbusd.128\" => \"__builtin_ia32_vpdpbusd_v4si\",\n+        \"llvm.x86.avx512.vpdpbusds.512\" => \"__builtin_ia32_vpdpbusds_v16si\",\n+        \"llvm.x86.avx512.vpdpbusds.256\" => \"__builtin_ia32_vpdpbusds_v8si\",\n+        \"llvm.x86.avx512.vpdpbusds.128\" => \"__builtin_ia32_vpdpbusds_v4si\",\n+\n         // NOTE: this file is generated by https://github.com/GuillaumeGomez/llvmint/blob/master/generate_list.py\n         _ => include!(\"archs.rs\"),\n     };"}, {"sha": "e3461b97973ecac841fe4df7c81cf469d9dd8a4a", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let name = tcx.item_name(def_id);\n         let name_str = name.as_str();\n \n-        let llret_ty = self.layout_of(ret_ty).gcc_type(self, true);\n+        let llret_ty = self.layout_of(ret_ty).gcc_type(self);\n         let result = PlaceRef::new_sized(llresult, fn_abi.ret.layout);\n \n         let simple = get_simple_intrinsic(self, name);\n@@ -399,7 +399,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     /// Gets the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e., the result of `type_of::type_of`.\n     fn memory_ty(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n-        self.layout.gcc_type(cx, true)\n+        self.layout.gcc_type(cx)\n     }\n \n     /// Stores a direct/indirect value described by this ArgAbi into a"}, {"sha": "dbf6ee6d285d1b6666fff36994c3a80eaed15d8d", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 177, "deletions": 180, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -1,6 +1,6 @@\n-use std::cmp::Ordering;\n-\n-use gccjit::{BinaryOp, RValue, Type, ToRValue};\n+#[cfg_attr(not(feature=\"master\"), allow(unused_imports))]\n+use gccjit::{ToRValue, ComparisonOp, UnaryOp};\n+use gccjit::{BinaryOp, RValue, Type};\n use rustc_codegen_ssa::base::compare_simd_types;\n use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n@@ -215,48 +215,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let vector = args[0].immediate();\n         let index = args[1].immediate();\n         let value = args[2].immediate();\n-        // TODO(antoyo): use a recursive unqualified() here.\n-        let vector_type = vector.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n-        let element_type = vector_type.get_element_type();\n-        // NOTE: we cannot cast to an array and assign to its element here because the value might\n-        // not be an l-value. So, call a builtin to set the element.\n-        // TODO(antoyo): perhaps we could create a new vector or maybe there's a GIMPLE instruction for that?\n-        // TODO(antoyo): don't use target specific builtins here.\n-        let func_name =\n-            match in_len {\n-                2 => {\n-                    if element_type == bx.i64_type {\n-                        \"__builtin_ia32_vec_set_v2di\"\n-                    }\n-                    else {\n-                        unimplemented!();\n-                    }\n-                },\n-                4 => {\n-                    if element_type == bx.i32_type {\n-                        \"__builtin_ia32_vec_set_v4si\"\n-                    }\n-                    else {\n-                        unimplemented!();\n-                    }\n-                },\n-                8 => {\n-                    if element_type == bx.i16_type {\n-                        \"__builtin_ia32_vec_set_v8hi\"\n-                    }\n-                    else {\n-                        unimplemented!();\n-                    }\n-                },\n-                _ => unimplemented!(\"Len: {}\", in_len),\n-            };\n-        let builtin = bx.context.get_target_builtin_function(func_name);\n-        let param1_type = builtin.get_param(0).to_rvalue().get_type();\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        let vector = bx.cx.bitcast_if_needed(vector, param1_type);\n-        let result = bx.context.new_call(None, builtin, &[vector, value, bx.context.new_cast(None, index, bx.int_type)]);\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        return Ok(bx.context.new_bitcast(None, result, vector.get_type()));\n+        let variable = bx.current_func().new_local(None, vector.get_type(), \"new_vector\");\n+        bx.llbb().add_assignment(None, variable, vector);\n+        let lvalue = bx.context.new_vector_access(None, variable.to_rvalue(), index);\n+        // TODO(antoyo): if simd_insert is constant, use BIT_REF.\n+        bx.llbb().add_assignment(None, lvalue, value);\n+        return Ok(variable.to_rvalue());\n     }\n \n     #[cfg(feature=\"master\")]\n@@ -290,6 +254,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n     }\n \n+    #[cfg(feature=\"master\")]\n     if name == sym::simd_cast {\n         require_simd!(ret_ty, \"return\");\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n@@ -309,117 +274,37 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n \n         enum Style {\n             Float,\n-            Int(/* is signed? */ bool),\n+            Int,\n             Unsupported,\n         }\n \n-        let (in_style, in_width) = match in_elem.kind() {\n-            // vectors of pointer-sized integers should've been\n-            // disallowed before here, so this unwrap is safe.\n-            ty::Int(i) => (\n-                Style::Int(true),\n-                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Uint(u) => (\n-                Style::Int(false),\n-                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Float(f) => (Style::Float, f.bit_width()),\n-            _ => (Style::Unsupported, 0),\n-        };\n-        let (out_style, out_width) = match out_elem.kind() {\n-            ty::Int(i) => (\n-                Style::Int(true),\n-                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Uint(u) => (\n-                Style::Int(false),\n-                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Float(f) => (Style::Float, f.bit_width()),\n-            _ => (Style::Unsupported, 0),\n-        };\n-\n-        let extend = |in_type, out_type| {\n-            let vector_type = bx.context.new_vector_type(out_type, 8);\n-            let vector = args[0].immediate();\n-            let array_type = bx.context.new_array_type(None, in_type, 8);\n-            // TODO(antoyo): switch to using new_vector_access or __builtin_convertvector for vector casting.\n-            let array = bx.context.new_bitcast(None, vector, array_type);\n-\n-            let cast_vec_element = |index| {\n-                let index = bx.context.new_rvalue_from_int(bx.int_type, index);\n-                bx.context.new_cast(None, bx.context.new_array_access(None, array, index).to_rvalue(), out_type)\n+        let in_style =\n+            match in_elem.kind() {\n+                ty::Int(_) | ty::Uint(_) => Style::Int,\n+                ty::Float(_) => Style::Float,\n+                 _ => Style::Unsupported,\n             };\n \n-            bx.context.new_rvalue_from_vector(None, vector_type, &[\n-                cast_vec_element(0),\n-                cast_vec_element(1),\n-                cast_vec_element(2),\n-                cast_vec_element(3),\n-                cast_vec_element(4),\n-                cast_vec_element(5),\n-                cast_vec_element(6),\n-                cast_vec_element(7),\n-            ])\n-        };\n+        let out_style =\n+            match out_elem.kind() {\n+                ty::Int(_) | ty::Uint(_) => Style::Int,\n+                ty::Float(_) => Style::Float,\n+                 _ => Style::Unsupported,\n+            };\n \n         match (in_style, out_style) {\n-            (Style::Int(in_is_signed), Style::Int(_)) => {\n-                return Ok(match in_width.cmp(&out_width) {\n-                    Ordering::Greater => bx.trunc(args[0].immediate(), llret_ty),\n-                    Ordering::Equal => args[0].immediate(),\n-                    Ordering::Less => {\n-                        if in_is_signed {\n-                            match (in_width, out_width) {\n-                                // FIXME(antoyo): the function _mm_cvtepi8_epi16 should directly\n-                                // call an intrinsic equivalent to __builtin_ia32_pmovsxbw128 so that\n-                                // we can generate a call to it.\n-                                (8, 16) => extend(bx.i8_type, bx.i16_type),\n-                                (8, 32) => extend(bx.i8_type, bx.i32_type),\n-                                (8, 64) => extend(bx.i8_type, bx.i64_type),\n-                                (16, 32) => extend(bx.i16_type, bx.i32_type),\n-                                (32, 64) => extend(bx.i32_type, bx.i64_type),\n-                                (16, 64) => extend(bx.i16_type, bx.i64_type),\n-                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n-                            }\n-                        } else {\n-                            match (in_width, out_width) {\n-                                (8, 16) => extend(bx.u8_type, bx.u16_type),\n-                                (8, 32) => extend(bx.u8_type, bx.u32_type),\n-                                (8, 64) => extend(bx.u8_type, bx.u64_type),\n-                                (16, 32) => extend(bx.u16_type, bx.u32_type),\n-                                (16, 64) => extend(bx.u16_type, bx.u64_type),\n-                                (32, 64) => extend(bx.u32_type, bx.u64_type),\n-                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n-                            }\n-                        }\n-                    }\n-                });\n-            }\n-            (Style::Int(_), Style::Float) => {\n-                // TODO: add support for internal functions in libgccjit to get access to IFN_VEC_CONVERT which is\n-                // doing like __builtin_convertvector?\n-                // Or maybe provide convert_vector as an API since it might not easy to get the\n-                // types of internal functions.\n-                unimplemented!();\n-            }\n-            (Style::Float, Style::Int(_)) => {\n-                unimplemented!();\n-            }\n-            (Style::Float, Style::Float) => {\n-                unimplemented!();\n-            }\n-            _ => { /* Unsupported. Fallthrough. */ }\n+            (Style::Unsupported, Style::Unsupported) => {\n+                require!(\n+                    false,\n+                    \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n+                    in_ty,\n+                    in_elem,\n+                    ret_ty,\n+                    out_elem\n+                );\n+            },\n+            _ => return Ok(bx.context.convert_vector(None, args[0].immediate(), llret_ty)),\n         }\n-        require!(\n-            false,\n-            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n-        );\n     }\n \n     macro_rules! arith_binary {\n@@ -439,6 +324,67 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         }\n     }\n \n+    if name == sym::simd_bitmask {\n+        // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n+        // vector mask and returns the most significant bit (MSB) of each lane in the form\n+        // of either:\n+        // * an unsigned integer\n+        // * an array of `u8`\n+        // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+        //\n+        // The bit order of the result depends on the byte endianness, LSB-first for little\n+        // endian and MSB-first for big endian.\n+\n+        let vector = args[0].immediate();\n+        let vector_type = vector.get_type().dyncast_vector().expect(\"vector type\");\n+        let elem_type = vector_type.get_element_type();\n+        let mut shifts = vec![];\n+        let mut masks = vec![];\n+        let mut mask = 1;\n+        for i in 0..in_len {\n+            shifts.push(bx.context.new_rvalue_from_int(elem_type, i as i32));\n+            masks.push(bx.context.new_rvalue_from_int(elem_type, mask));\n+            mask <<= 1;\n+        }\n+        masks.reverse();\n+        let shifts = bx.context.new_rvalue_from_vector(None, vector.get_type(), &shifts);\n+        let shifted = vector >> shifts;\n+        let masks = bx.context.new_rvalue_from_vector(None, vector.get_type(), &masks);\n+        let masked = shifted & masks;\n+        let reduced = bx.vector_reduce_op(masked, BinaryOp::BitwiseOr);\n+\n+        let expected_int_bits = in_len.max(8);\n+        let expected_bytes = expected_int_bits / 8 + ((expected_int_bits % 8 > 0) as u64);\n+\n+        match ret_ty.kind() {\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => {\n+                // Zero-extend iN to the bitmask type:\n+                return Ok(bx.zext(reduced, bx.type_ix(expected_int_bits)));\n+            }\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                // Zero-extend iN to the array length:\n+                let ze = bx.zext(reduced, bx.type_ix(expected_bytes * 8));\n+\n+                // Convert the integer to a byte array\n+                let ptr = bx.alloca(bx.type_ix(expected_bytes * 8), Align::ONE);\n+                bx.store(ze, ptr, Align::ONE);\n+                let array_ty = bx.type_array(bx.type_i8(), expected_bytes);\n+                let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n+                return Ok(bx.load(array_ty, ptr, Align::ONE));\n+            }\n+            _ => return_error!(\n+                \"cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+                ret_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            ),\n+        }\n+    }\n+\n     fn simd_simple_float_intrinsic<'gcc, 'tcx>(\n         name: Symbol,\n         in_elem: Ty<'_>,\n@@ -575,40 +521,91 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let rhs = args[1].immediate();\n         let is_add = name == sym::simd_saturating_add;\n         let ptr_bits = bx.tcx().data_layout.pointer_size.bits() as _;\n-        let (signed, elem_width, elem_ty) = match *in_elem.kind() {\n-            ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n-            ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n-            _ => {\n-                return_error!(\n-                    \"expected element type `{}` of vector type `{}` \\\n+        let (signed, elem_width, elem_ty) =\n+            match *in_elem.kind() {\n+                ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_int_from_ty(i)),\n+                ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_uint_from_ty(i)),\n+                _ => {\n+                    return_error!(\n+                        \"expected element type `{}` of vector type `{}` \\\n                      to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                    arg_tys[0]\n-                );\n-            }\n-        };\n-        let builtin_name =\n-            match (signed, is_add, in_len, elem_width) {\n-                (true, true, 32, 8) => \"__builtin_ia32_paddsb256\", // TODO(antoyo): cast arguments to unsigned.\n-                (false, true, 32, 8) => \"__builtin_ia32_paddusb256\",\n-                (true, true, 16, 16) => \"__builtin_ia32_paddsw256\",\n-                (false, true, 16, 16) => \"__builtin_ia32_paddusw256\",\n-                (true, false, 16, 16) => \"__builtin_ia32_psubsw256\",\n-                (false, false, 16, 16) => \"__builtin_ia32_psubusw256\",\n-                (true, false, 32, 8) => \"__builtin_ia32_psubsb256\",\n-                (false, false, 32, 8) => \"__builtin_ia32_psubusb256\",\n-                _ => unimplemented!(\"signed: {}, is_add: {}, in_len: {}, elem_width: {}\", signed, is_add, in_len, elem_width),\n+                     arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                     arg_tys[0]\n+                    );\n+                }\n+            };\n+\n+        let result =\n+            match (signed, is_add) {\n+                (false, true) => {\n+                    let res = lhs + rhs;\n+                    let cmp = bx.context.new_comparison(None, ComparisonOp::LessThan, res, lhs);\n+                    res | cmp\n+                },\n+                (true, true) => {\n+                    // Algorithm from: https://codereview.stackexchange.com/questions/115869/saturated-signed-addition\n+                    // TODO(antoyo): improve using conditional operators if possible.\n+                    let arg_type = lhs.get_type();\n+                    // TODO(antoyo): convert lhs and rhs to unsigned.\n+                    let sum = lhs + rhs;\n+                    let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n+                    let unit = vector_type.get_num_units();\n+                    let a = bx.context.new_rvalue_from_int(elem_ty, ((elem_width as i32) << 3) - 1);\n+                    let width = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![a; unit]);\n+\n+                    let xor1 = lhs ^ rhs;\n+                    let xor2 = lhs ^ sum;\n+                    let and = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, xor1) & xor2;\n+                    let mask = and >> width;\n+\n+                    let one = bx.context.new_rvalue_one(elem_ty);\n+                    let ones = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![one; unit]);\n+                    let shift1 = ones << width;\n+                    let shift2 = sum >> width;\n+                    let mask_min = shift1 ^ shift2;\n+\n+                    let and1 = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, mask) & sum;\n+                    let and2 = mask & mask_min;\n+\n+                    and1 + and2\n+                },\n+                (false, false) => {\n+                    let res = lhs - rhs;\n+                    let cmp = bx.context.new_comparison(None, ComparisonOp::LessThanEquals, res, lhs);\n+                    res & cmp\n+                },\n+                (true, false) => {\n+                    let arg_type = lhs.get_type();\n+                    // TODO(antoyo): this uses the same algorithm from saturating add, but add the\n+                    // negative of the right operand. Find a proper subtraction algorithm.\n+                    let rhs = bx.context.new_unary_op(None, UnaryOp::Minus, arg_type, rhs);\n+\n+                    // TODO(antoyo): convert lhs and rhs to unsigned.\n+                    let sum = lhs + rhs;\n+                    let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n+                    let unit = vector_type.get_num_units();\n+                    let a = bx.context.new_rvalue_from_int(elem_ty, ((elem_width as i32) << 3) - 1);\n+                    let width = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![a; unit]);\n+\n+                    let xor1 = lhs ^ rhs;\n+                    let xor2 = lhs ^ sum;\n+                    let and = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, xor1) & xor2;\n+                    let mask = and >> width;\n+\n+                    let one = bx.context.new_rvalue_one(elem_ty);\n+                    let ones = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![one; unit]);\n+                    let shift1 = ones << width;\n+                    let shift2 = sum >> width;\n+                    let mask_min = shift1 ^ shift2;\n+\n+                    let and1 = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, mask) & sum;\n+                    let and2 = mask & mask_min;\n+\n+                    and1 + and2\n+                }\n             };\n-        let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n-\n-        let func = bx.context.get_target_builtin_function(builtin_name);\n-        let param1_type = func.get_param(0).to_rvalue().get_type();\n-        let param2_type = func.get_param(1).to_rvalue().get_type();\n-        let lhs = bx.cx.bitcast_if_needed(lhs, param1_type);\n-        let rhs = bx.cx.bitcast_if_needed(rhs, param2_type);\n-        let result = bx.context.new_call(None, func, &[lhs, rhs]);\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        return Ok(bx.context.new_bitcast(None, result, vec_ty));\n+\n+        return Ok(result);\n     }\n \n     macro_rules! arith_red {"}, {"sha": "e43ee5cf21dcb540c2adfc962378a8d6df40580a", "filename": "src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -1,7 +1,7 @@\n /*\n  * TODO(antoyo): implement equality in libgccjit based on https://zpz.github.io/blog/overloading-equality-operator-in-cpp-class-hierarchy/ (for type equality?)\n  * TODO(antoyo): support #[inline] attributes.\n- * TODO(antoyo): support LTO (gcc's equivalent to Thin LTO is enabled by -fwhopr: https://stackoverflow.com/questions/64954525/does-gcc-have-thin-lto).\n+ * TODO(antoyo): support LTO (gcc's equivalent to Full LTO is -flto -flto-partition=one \u2014 https://documentation.suse.com/sbp/all/html/SBP-GCC-10/index.html).\n  *\n  * TODO(antoyo): remove the patches.\n  */\n@@ -20,6 +20,7 @@\n #![warn(unused_lifetimes)]\n \n extern crate rustc_ast;\n+extern crate rustc_attr;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n@@ -39,6 +40,7 @@ mod abi;\n mod allocator;\n mod archive;\n mod asm;\n+mod attributes;\n mod back;\n mod base;\n mod builder;\n@@ -310,9 +312,11 @@ pub fn target_features(sess: &Session, allow_unstable: bool) -> Vec<Symbol> {\n         .filter(|_feature| {\n             // TODO(antoyo): implement a way to get enabled feature in libgccjit.\n             // Probably using the equivalent of __builtin_cpu_supports.\n+            // TODO(antoyo): maybe use whatever outputs the following command:\n+            // gcc -march=native -Q --help=target\n             #[cfg(feature=\"master\")]\n             {\n-                _feature.contains(\"sse\") || _feature.contains(\"avx\")\n+                (_feature.contains(\"sse\") || _feature.contains(\"avx\")) && !_feature.contains(\"avx512\")\n             }\n             #[cfg(not(feature=\"master\"))]\n             {"}, {"sha": "ce439d339b6b5d2bf0dc999dadf1ae0243a0ebcf", "filename": "src/mono_item.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_item.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -1,36 +1,61 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::{VarAttribute, FnAttribute};\n use rustc_codegen_ssa::traits::PreDefineMethods;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::{self, Instance, TypeVisitable};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n-use rustc_span::def_id::DefId;\n \n+use crate::attributes;\n use crate::base;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n-    fn predefine_static(&self, def_id: DefId, _linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    fn predefine_static(&self, def_id: DefId, _linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n         let attrs = self.tcx.codegen_fn_attrs(def_id);\n         let instance = Instance::mono(self.tcx, def_id);\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n-        let gcc_type = self.layout_of(ty).gcc_type(self, true);\n+        let gcc_type = self.layout_of(ty).gcc_type(self);\n \n         let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n         let global = self.define_global(symbol_name, gcc_type, is_tls, attrs.link_section);\n+        #[cfg(feature=\"master\")]\n+        global.add_attribute(VarAttribute::Visibility(base::visibility_to_gcc(visibility)));\n \n-        // TODO(antoyo): set linkage and visibility.\n+        // TODO(antoyo): set linkage.\n         self.instances.borrow_mut().insert(instance, global);\n     }\n \n-    fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n         assert!(!instance.substs.needs_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         self.linkage.set(base::linkage_to_gcc(linkage));\n-        let _decl = self.declare_fn(symbol_name, &fn_abi);\n+        let decl = self.declare_fn(symbol_name, &fn_abi);\n         //let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n \n+        attributes::from_fn_attrs(self, decl, instance);\n+\n+        // If we're compiling the compiler-builtins crate, e.g., the equivalent of\n+        // compiler-rt, then we want to implicitly compile everything with hidden\n+        // visibility as we're going to link this object all over the place but\n+        // don't want the symbols to get exported.\n+        if linkage != Linkage::Internal\n+            && linkage != Linkage::Private\n+            && self.tcx.is_compiler_builtins(LOCAL_CRATE)\n+        {\n+            #[cfg(feature=\"master\")]\n+            decl.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+        }\n+        else {\n+            #[cfg(feature=\"master\")]\n+            decl.add_attribute(FnAttribute::Visibility(base::visibility_to_gcc(visibility)));\n+        }\n+\n         // TODO(antoyo): call set_link_section() to allow initializing argc/argv.\n         // TODO(antoyo): set unique comdat.\n         // TODO(antoyo): use inline attribute from there in linkage.set() above."}, {"sha": "c97e9586005bbdb11401a9961156a4576fe5b128", "filename": "src/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -273,7 +273,7 @@ pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout\n         assert_eq!(offset.align_to(padding_align) + padding, target_offset);\n         result.push(cx.type_padding_filler(padding, padding_align));\n \n-        result.push(field.gcc_type(cx, !field.ty.is_any_ptr())); // FIXME(antoyo): might need to check if the type is inside another, like Box<Type>.\n+        result.push(field.gcc_type(cx));\n         offset = target_offset + field.size;\n         prev_effective_align = effective_field_align;\n     }"}, {"sha": "29d394dbba4addb2071fdafd882a30b80ceec9b7", "filename": "src/type_of.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/src%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_of.rs?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -50,7 +50,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n-pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {\n+fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {\n     match layout.abi {\n         Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n         Abi::Vector { ref element, count } => {\n@@ -114,7 +114,7 @@ pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLa\n                 },\n             }\n         }\n-        FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).gcc_type(cx, true), count),\n+        FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).gcc_type(cx), count),\n         FieldsShape::Arbitrary { .. } =>\n             match name {\n                 None => {\n@@ -133,7 +133,7 @@ pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLa\n pub trait LayoutGccExt<'tcx> {\n     fn is_gcc_immediate(&self) -> bool;\n     fn is_gcc_scalar_pair(&self) -> bool;\n-    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, set_fields: bool) -> Type<'gcc>;\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n     fn immediate_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n     fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc>;\n     fn scalar_pair_element_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, index: usize, immediate: bool) -> Type<'gcc>;\n@@ -168,8 +168,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n     /// with the inner-most trailing unsized field using the \"minimal unit\"\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n-    //TODO(antoyo): do we still need the set_fields parameter?\n-    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, set_fields: bool) -> Type<'gcc> {\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n         if let Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n@@ -179,10 +178,10 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             let ty =\n                 match *self.ty.kind() {\n                     ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                        cx.type_ptr_to(cx.layout_of(ty).gcc_type(cx, set_fields))\n+                        cx.type_ptr_to(cx.layout_of(ty).gcc_type(cx))\n                     }\n                     ty::Adt(def, _) if def.is_box() => {\n-                        cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).gcc_type(cx, true))\n+                        cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).gcc_type(cx))\n                     }\n                     ty::FnPtr(sig) => cx.fn_ptr_backend_type(&cx.fn_abi_of_fn_ptr(sig, ty::List::empty())),\n                     _ => self.scalar_gcc_type_at(cx, scalar, Size::ZERO),\n@@ -199,13 +198,6 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             };\n         let cached_type = cx.types.borrow().get(&(self.ty, variant_index)).cloned();\n         if let Some(ty) = cached_type {\n-            let type_to_set_fields = cx.types_with_fields_to_set.borrow_mut().remove(&ty);\n-            if let Some((struct_type, layout)) = type_to_set_fields {\n-                // Since we might be trying to generate a type containing another type which is not\n-                // completely generated yet, we deferred setting the fields until now.\n-                let (fields, packed) = struct_fields(cx, layout);\n-                cx.set_struct_body(struct_type, &fields, packed);\n-            }\n             return ty;\n         }\n \n@@ -222,17 +214,17 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                 if let Some(v) = variant_index {\n                     layout = layout.for_variant(cx, v);\n                 }\n-                layout.gcc_type(cx, true)\n+                layout.gcc_type(cx)\n             }\n             else {\n                 uncached_gcc_type(cx, *self, &mut defer)\n             };\n \n         cx.types.borrow_mut().insert((self.ty, variant_index), ty);\n \n-        if let Some((ty, layout)) = defer {\n+        if let Some((deferred_ty, layout)) = defer {\n             let (fields, packed) = struct_fields(cx, layout);\n-            cx.set_struct_body(ty, &fields, packed);\n+            cx.set_struct_body(deferred_ty, &fields, packed);\n         }\n \n         ty\n@@ -244,7 +236,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                 return cx.type_i1();\n             }\n         }\n-        self.gcc_type(cx, true)\n+        self.gcc_type(cx)\n     }\n \n     fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc> {\n@@ -273,7 +265,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n         match self.ty.kind() {\n             ty::Ref(..) | ty::RawPtr(_) => {\n-                return self.field(cx, index).gcc_type(cx, true);\n+                return self.field(cx, index).gcc_type(cx);\n             }\n             // only wide pointer boxes are handled as pointers\n             // thin pointer boxes with scalar allocators are handled by the general logic below\n@@ -343,7 +335,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n \n impl<'gcc, 'tcx> LayoutTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     fn backend_type(&self, layout: TyAndLayout<'tcx>) -> Type<'gcc> {\n-        layout.gcc_type(self, true)\n+        layout.gcc_type(self)\n     }\n \n     fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> Type<'gcc> {"}, {"sha": "06f608ad422ad4fdb2f3e5967110f422e105add9", "filename": "test.sh", "status": "modified", "additions": 128, "deletions": 24, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -17,13 +17,16 @@ export LIBRARY_PATH=\"$GCC_PATH\"\n flags=\n gcc_master_branch=1\n channel=\"debug\"\n-func=all\n+funcs=()\n build_only=0\n+nb_parts=0\n+current_part=0\n \n while [[ $# -gt 0 ]]; do\n     case $1 in\n         --release)\n             codegen_channel=release\n+            channel=\"release\"\n             shift\n             ;;\n         --release-sysroot)\n@@ -40,43 +43,78 @@ while [[ $# -gt 0 ]]; do\n             flags=\"$flags --features $1\"\n             shift\n             ;;\n-        --release)\n-            channel=\"release\"\n+        \"--test-rustc\")\n+            funcs=(test_rustc)\n             shift\n             ;;\n-        \"--test-rustc\")\n-            func=test_rustc\n+        \"--test-successful-rustc\")\n+            funcs+=(test_successful_rustc)\n+            shift\n+            ;;\n+        \"--test-failing-rustc\")\n+            funcs+=(test_failing_rustc)\n             shift\n             ;;\n \n         \"--test-libcore\")\n-            func=test_libcore\n+            funcs+=(test_libcore)\n             shift\n             ;;\n \n         \"--clean-ui-tests\")\n-            func=clean_ui_tests\n+            funcs+=(clean_ui_tests)\n+            shift\n+            ;;\n+        \"--clean\")\n+            funcs+=(clean)\n             shift\n             ;;\n \n         \"--std-tests\")\n-            func=std_tests\n+            funcs+=(std_tests)\n             shift\n             ;;\n \n         \"--extended-tests\")\n-            func=extended_sysroot_tests\n+            funcs+=(extended_sysroot_tests)\n+            shift\n+            ;;\n+        \"--extended-rand-tests\")\n+            funcs+=(extended_rand_tests)\n+            shift\n+            ;;\n+        \"--extended-regex-example-tests\")\n+            funcs+=(extended_regex_example_tests)\n+            shift\n+            ;;\n+        \"--extended-regex-tests\")\n+            funcs+=(extended_regex_tests)\n+            shift\n+            ;;\n+\n+        \"--mini-tests\")\n+            funcs+=(mini_tests)\n             shift\n             ;;\n \n         \"--build-sysroot\")\n-            func=build_sysroot\n+            funcs+=(build_sysroot)\n             shift\n             ;;\n         \"--build\")\n             build_only=1\n             shift\n             ;;\n+        \"--nb-parts\")\n+            shift\n+            nb_parts=$1\n+            shift\n+            ;;\n+        \"--current-part\")\n+            shift\n+            current_part=$1\n+            shift\n+            ;;\n         *)\n             echo \"Unknown option $1\"\n             exit 1\n@@ -87,14 +125,14 @@ done\n if [[ $channel == \"release\" ]]; then\n     export CHANNEL='release'\n     CARGO_INCREMENTAL=1 cargo rustc --release $flags\n-    shift\n else\n     echo $LD_LIBRARY_PATH\n     export CHANNEL='debug'\n     cargo rustc $flags\n fi\n \n if (( $build_only == 1 )); then\n+    echo \"Since it's 'build-only', exiting...\"\n     exit\n fi\n \n@@ -187,7 +225,7 @@ function test_libcore() {\n #echo \"[BENCH RUN] mod_bench\"\n #hyperfine --runs ${RUN_RUNS:-10} ./target/out/mod_bench{,_inline} ./target/out/mod_bench_llvm_*\n \n-function extended_sysroot_tests() {\n+function extended_rand_tests() {\n     if (( $gcc_master_branch == 0 )); then\n         return\n     fi\n@@ -197,17 +235,12 @@ function extended_sysroot_tests() {\n     echo \"[TEST] rust-random/rand\"\n     ../cargo.sh test --workspace\n     popd\n+}\n \n-    #pushd simple-raytracer\n-    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n-    #hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"cargo clean\" \\\n-    #\"RUSTC=rustc RUSTFLAGS='' cargo build\" \\\n-    #\"../cargo.sh build\"\n-\n-    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n-    #cp ./target/debug/main ./raytracer_cg_gcc\n-    #hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_gcc\n-    #popd\n+function extended_regex_example_tests() {\n+    if (( $gcc_master_branch == 0 )); then\n+        return\n+    fi\n \n     pushd regex\n     echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n@@ -219,12 +252,38 @@ function extended_sysroot_tests() {\n         | ../cargo.sh run --example shootout-regex-dna \\\n         | grep -v \"Spawned thread\" > res.txt\n     diff -u res.txt examples/regexdna-output.txt\n+    popd\n+}\n+\n+function extended_regex_tests() {\n+    if (( $gcc_master_branch == 0 )); then\n+        return\n+    fi\n \n+    pushd regex\n     echo \"[TEST] rust-lang/regex tests\"\n+    export CG_RUSTFLAGS=\"--cap-lints warn\" # newer aho_corasick versions throw a deprecation warning\n     ../cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n     popd\n }\n \n+function extended_sysroot_tests() {\n+    #pushd simple-raytracer\n+    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n+    #hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"cargo clean\" \\\n+    #\"RUSTC=rustc RUSTFLAGS='' cargo build\" \\\n+    #\"../cargo.sh build\"\n+\n+    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n+    #cp ./target/debug/main ./raytracer_cg_gcc\n+    #hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_gcc\n+    #popd\n+\n+    extended_rand_tests\n+    extended_regex_example_tests\n+    extended_regex_tests\n+}\n+\n function test_rustc() {\n     echo\n     echo \"[TEST] rust-lang/rust\"\n@@ -261,19 +320,57 @@ EOF\n \n     git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n \n-    rm -r src/test/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,test*,*lto*.rs} || true\n+    rm -r src/test/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,chalkify/bugs/,test*,*lto*.rs,consts/const-float-bits-reject-conv.rs,consts/issue-miri-1910.rs} || true\n     for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" src/test/ui); do\n       rm $test\n     done\n+    git checkout src/test/ui/lto/auxiliary/dylib.rs\n     git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n     git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n \n     RUSTC_ARGS=\"-Zpanic-abort-tests -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n \n+    if [ $# -eq 0 ]; then\n+        # No argument supplied to the function. Doing nothing.\n+        echo \"No argument provided. Keeping all UI tests\"\n+    elif [ $1 = \"0\" ]; then\n+        # Removing the failing tests.\n+        xargs -a ../failing-ui-tests.txt -d'\\n' rm\n+    else\n+        # Removing all tests.\n+        find src/test/ui -type f -name '*.rs' -exec rm {} \\;\n+        # Putting back only the failing ones.\n+        xargs -a ../failing-ui-tests.txt -d'\\n' git checkout --\n+    fi\n+\n+    if [ $nb_parts -gt 0 ]; then\n+        echo \"Splitting ui_test into $nb_parts parts (and running part $current_part)\"\n+        find src/test/ui -type f -name '*.rs' -not -path \"*/auxiliary/*\" > ui_tests\n+        # To ensure it'll be always the same sub files, we sort the content.\n+        sort ui_tests -o ui_tests\n+        count=$((`wc -l < ui_tests` / $nb_parts))\n+        # We increment the number of tests by one because if this is an odd number, we would skip\n+        # one test.\n+        count=$((count + 1))\n+        split -d -l $count -a 1 ui_tests ui_tests.split\n+        # Removing all tests.\n+        find src/test/ui -type f -name '*.rs' -not -path \"*/auxiliary/*\" -exec rm {} \\;\n+        # Putting back only the ones we want to test.\n+        xargs -a \"ui_tests.split$current_part\" -d'\\n' git checkout --\n+    fi\n+\n     echo \"[TEST] rustc test suite\"\n     COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 src/test/ui/ --rustc-args \"$RUSTC_ARGS\"\n }\n \n+function test_failing_rustc() {\n+    test_rustc \"1\"\n+}\n+\n+function test_successful_rustc() {\n+    test_rustc \"0\"\n+}\n+\n function clean_ui_tests() {\n     find rust/build/x86_64-unknown-linux-gnu/test/ui/ -name stamp -exec rm -rf {} \\;\n }\n@@ -288,4 +385,11 @@ function all() {\n     test_rustc\n }\n \n-$func\n+if [ ${#funcs[@]} -eq 0 ]; then\n+    echo \"No command passed, running '--all'...\"\n+    all\n+else\n+    for t in ${funcs[@]}; do\n+        $t\n+    done\n+fi"}, {"sha": "c09fb3c759f3b10189ac2780096a6731d43ad974", "filename": "tools/check_intrinsics_duplicates.py", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/tools%2Fcheck_intrinsics_duplicates.py", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/tools%2Fcheck_intrinsics_duplicates.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tools%2Fcheck_intrinsics_duplicates.py?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -0,0 +1,67 @@\n+import sys\n+\n+\n+def check_duplicates():\n+    auto_content = \"\"\n+    manual_content = \"\"\n+\n+    with open(\"src/intrinsic/llvm.rs\", \"r\", encoding=\"utf8\") as f:\n+        manual_content = f.read()\n+    with open(\"src/intrinsic/archs.rs\", \"r\", encoding=\"utf8\") as f:\n+        auto_content = f.read()\n+\n+    intrinsics_map = {}\n+    for line in auto_content.splitlines():\n+        line = line.strip()\n+        if not line.startswith('\"'):\n+            continue\n+        parts = line.split('\"')\n+        if len(parts) != 5:\n+            continue\n+        intrinsics_map[parts[1]] = parts[3]\n+\n+    if len(intrinsics_map) == 0:\n+        print(\"No intrinsics found in auto code... Aborting.\")\n+        return 1\n+    print(\"Found {} intrinsics in auto code\".format(len(intrinsics_map)))\n+    errors = []\n+    lines = manual_content.splitlines()\n+    pos = 0\n+    found = 0\n+    while pos < len(lines):\n+        line = lines[pos].strip()\n+        # This is our marker.\n+        if line == \"let gcc_name = match name {\":\n+            while pos < len(lines):\n+                line = lines[pos].strip()\n+                pos += 1\n+                if line == \"};\":\n+                    # We're done!\n+                    if found == 0:\n+                        print(\"No intrinsics found in manual code even though we found the \"\n+                            \"marker... Aborting...\")\n+                        return 1\n+                    for error in errors:\n+                        print(\"ERROR => {}\".format(error))\n+                    return 1 if len(errors) != 0 else 0\n+                parts = line.split('\"')\n+                if len(parts) != 5:\n+                    continue\n+                found += 1\n+                if parts[1] in intrinsics_map:\n+                    if parts[3] != intrinsics_map[parts[1]]:\n+                        print(\"Same intrinsics (`{}` at line {}) but different GCC \"\n+                            \"translations: `{}` != `{}`\".format(\n+                                parts[1], pos, intrinsics_map[parts[1]], parts[3]))\n+                    else:\n+                        errors.append(\"Duplicated intrinsics: `{}` at line {}. Please remove it \"\n+                            \" from manual code\".format(parts[1], pos))\n+            # Weird but whatever...\n+            return 1 if len(errors) != 0 else 0\n+        pos += 1\n+    print(\"No intrinsics found in manual code... Aborting\")\n+    return 1\n+\n+\n+if __name__ == \"__main__\":\n+    sys.exit(check_duplicates())"}, {"sha": "6188924b0d50a52ef4ac4ca30ee28ebd02eac216", "filename": "tools/generate_intrinsics.py", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/081eb744d23def41b3a6800c0e8448c180f4eb99/tools%2Fgenerate_intrinsics.py", "raw_url": "https://github.com/rust-lang/rust/raw/081eb744d23def41b3a6800c0e8448c180f4eb99/tools%2Fgenerate_intrinsics.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tools%2Fgenerate_intrinsics.py?ref=081eb744d23def41b3a6800c0e8448c180f4eb99", "patch": "@@ -13,7 +13,7 @@ def run_command(command, cwd=None):\n         sys.exit(1)\n \n \n-def clone_repository(repo_name, path, repo_url, sub_path=None):\n+def clone_repository(repo_name, path, repo_url, sub_paths=None):\n     if os.path.exists(path):\n         while True:\n             choice = input(\"There is already a `{}` folder, do you want to update it? [y/N]\".format(path))\n@@ -27,69 +27,58 @@ def clone_repository(repo_name, path, repo_url, sub_path=None):\n             else:\n                 print(\"Didn't understand answer...\")\n     print(\"Cloning {} repository...\".format(repo_name))\n-    if sub_path is None:\n+    if sub_paths is None:\n         run_command([\"git\", \"clone\", repo_url, \"--depth\", \"1\", path])\n     else:\n         run_command([\"git\", \"clone\", repo_url, \"--filter=tree:0\", \"--no-checkout\", path])\n         run_command([\"git\", \"sparse-checkout\", \"init\"], cwd=path)\n-        run_command([\"git\", \"sparse-checkout\", \"set\", \"add\", sub_path], cwd=path)\n+        run_command([\"git\", \"sparse-checkout\", \"set\", *sub_paths], cwd=path)\n         run_command([\"git\", \"checkout\"], cwd=path)\n \n \n def append_intrinsic(array, intrinsic_name, translation):\n     array.append((intrinsic_name, translation))\n \n \n-def extract_instrinsics(intrinsics, file):\n-    print(\"Extracting intrinsics from `{}`...\".format(file))\n-    with open(file, \"r\", encoding=\"utf8\") as f:\n-        content = f.read()\n+def convert_to_string(content):\n+    if content.__class__.__name__ == 'bytes':\n+        return content.decode('utf-8')\n+    return content\n \n-    lines = content.splitlines()\n+\n+def extract_instrinsics_from_llvm(llvm_path, intrinsics):\n+    p = subprocess.Popen(\n+        [\"llvm-tblgen\", \"llvm/IR/Intrinsics.td\"],\n+        cwd=os.path.join(llvm_path, \"llvm/include\"),\n+        stdout=subprocess.PIPE)\n+    output, err = p.communicate()\n+    lines = convert_to_string(output).splitlines()\n     pos = 0\n-    current_arch = None\n     while pos < len(lines):\n-        line = lines[pos].strip()\n-        if line.startswith(\"let TargetPrefix =\"):\n-            current_arch = line.split('\"')[1].strip()\n-            if len(current_arch) == 0:\n-                current_arch = None\n-        elif current_arch is None:\n-            pass\n-        elif line == \"}\":\n-            current_arch = None\n-        elif line.startswith(\"def \"):\n-            content = \"\"\n-            while not content.endswith(\";\") and not content.endswith(\"}\") and pos < len(lines):\n-                line = lines[pos].split(\" // \")[0].strip()\n-                content += line\n-                pos += 1\n-            entries = re.findall('GCCBuiltin<\"(\\\\w+)\">', content)\n-            if len(entries) > 0:\n-                intrinsic = content.split(\"def \")[1].strip().split(\":\")[0].strip()\n-                intrinsic = intrinsic.split(\"_\")\n-                if len(intrinsic) < 2 or intrinsic[0] != \"int\":\n-                    continue\n-                intrinsic[0] = \"llvm\"\n-                intrinsic = \".\".join(intrinsic)\n-                if current_arch not in intrinsics:\n-                    intrinsics[current_arch] = []\n-                for entry in entries:\n-                    append_intrinsic(intrinsics[current_arch], intrinsic, entry)\n+        line = lines[pos]\n+        if not line.startswith(\"def \"):\n+            pos += 1\n             continue\n-        pos += 1\n-        continue\n-    print(\"Done!\")\n-\n-\n-def extract_instrinsics_from_llvm(llvm_path, intrinsics):\n-    files = []\n-    intrinsics_path = os.path.join(llvm_path, \"llvm/include/llvm/IR\")\n-    for (dirpath, dirnames, filenames) in walk(intrinsics_path):\n-        files.extend([os.path.join(intrinsics_path, f) for f in filenames if f.endswith(\".td\")])\n-\n-    for file in files:\n-        extract_instrinsics(intrinsics, file)\n+        intrinsic = line.split(\" \")[1].strip()\n+        content = line\n+        while pos < len(lines):\n+            line = lines[pos].split(\" // \")[0].strip()\n+            content += line\n+            pos += 1\n+            if line == \"}\":\n+                break\n+        entries = re.findall('string ClangBuiltinName = \"(\\\\w+)\";', content)\n+        current_arch = re.findall('string TargetPrefix = \"(\\\\w+)\";', content)\n+        if len(entries) == 1 and len(current_arch) == 1:\n+            current_arch = current_arch[0]\n+            intrinsic = intrinsic.split(\"_\")\n+            if len(intrinsic) < 2 or intrinsic[0] != \"int\":\n+                continue\n+            intrinsic[0] = \"llvm\"\n+            intrinsic = \".\".join(intrinsic)\n+            if current_arch not in intrinsics:\n+                intrinsics[current_arch] = []\n+            append_intrinsic(intrinsics[current_arch], intrinsic, entries[0])\n \n \n def append_translation(json_data, p, array):\n@@ -193,6 +182,8 @@ def update_intrinsics(llvm_path, llvmint, llvmint2):\n             for entry in intrinsics[arch]:\n                 if entry[2] == True: # if it is a duplicate\n                     out.write('    // [DUPLICATE]: \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n+                elif \"_round_mask\" in entry[1]:\n+                    out.write('    // [INVALID CONVERSION]: \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n                 else:\n                     out.write('    \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n         out.write('    _ => unimplemented!(\"***** unsupported LLVM intrinsic {}\", name),\\n')\n@@ -219,7 +210,7 @@ def main():\n         \"llvm-project\",\n         llvm_path,\n         \"https://github.com/llvm/llvm-project\",\n-        sub_path=\"llvm/include/llvm/IR\",\n+        sub_paths=[\"llvm/include/llvm/IR\", \"llvm/include/llvm/CodeGen/\"],\n     )\n     clone_repository(\n         \"llvmint\","}]}