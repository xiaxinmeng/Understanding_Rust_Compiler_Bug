{"sha": "8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZTk4OWRkNzY4ZjVkZmRiMGZjOTA5MzNmM2Y3NGZhNDU3OWZlZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-16T22:14:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-16T22:14:32Z"}, "message": "Auto merge of #81611 - cjgillot:meowner, r=estebank\n\nOnly store a LocalDefId in some HIR nodes\n\nSome HIR nodes are guaranteed to be HIR owners: Item, TraitItem, ImplItem, ForeignItem and MacroDef.\nAs a consequence, we do not need to store the `HirId`'s `local_id`, and we can directly store a `LocalDefId`.\n\nThis allows to avoid a bit of the dance with `tcx.hir().local_def_id` and `tcx.hir().local_def_id_to_hir_id` mappings.", "tree": {"sha": "b343f190d8e1bca405fba9548778befb1986087a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b343f190d8e1bca405fba9548778befb1986087a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "html_url": "https://github.com/rust-lang/rust/commit/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a143517d44cac50b20cbd3a0b579addab40dd399", "url": "https://api.github.com/repos/rust-lang/rust/commits/a143517d44cac50b20cbd3a0b579addab40dd399", "html_url": "https://github.com/rust-lang/rust/commit/a143517d44cac50b20cbd3a0b579addab40dd399"}, {"sha": "91d8e59ccaacf7df2af847037d30871ed0bd90b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/91d8e59ccaacf7df2af847037d30871ed0bd90b6", "html_url": "https://github.com/rust-lang/rust/commit/91d8e59ccaacf7df2af847037d30871ed0bd90b6"}], "stats": {"total": 2316, "additions": 1126, "deletions": 1190}, "files": [{"sha": "cad2a21d1a4a7190e43687fc7c5f7c3f137fe0b0", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -35,10 +35,10 @@ impl ItemLowerer<'_, '_, '_> {\n \n impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     fn visit_mod(&mut self, m: &'a Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n-        let hir_id = self.lctx.lower_node_id(n);\n+        let def_id = self.lctx.lower_node_id(n).expect_owner();\n \n         self.lctx.modules.insert(\n-            hir_id,\n+            def_id,\n             hir::ModuleItems {\n                 items: BTreeSet::new(),\n                 trait_items: BTreeSet::new(),\n@@ -48,7 +48,7 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         );\n \n         let old = self.lctx.current_module;\n-        self.lctx.current_module = hir_id;\n+        self.lctx.current_module = def_id;\n         visit::walk_mod(self, m);\n         self.lctx.current_module = old;\n     }\n@@ -58,8 +58,8 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n             lctx.without_in_scope_lifetime_defs(|lctx| {\n                 if let Some(hir_item) = lctx.lower_item(item) {\n-                    item_hir_id = Some(hir_item.hir_id);\n-                    lctx.insert_item(hir_item);\n+                    let id = lctx.insert_item(hir_item);\n+                    item_hir_id = Some(id);\n                 }\n             })\n         });\n@@ -92,13 +92,13 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n             AssocCtxt::Trait => {\n                 let hir_item = lctx.lower_trait_item(item);\n-                let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n+                let id = hir_item.trait_item_id();\n                 lctx.trait_items.insert(id, hir_item);\n                 lctx.modules.get_mut(&lctx.current_module).unwrap().trait_items.insert(id);\n             }\n             AssocCtxt::Impl => {\n                 let hir_item = lctx.lower_impl_item(item);\n-                let id = hir::ImplItemId { hir_id: hir_item.hir_id };\n+                let id = hir_item.impl_item_id();\n                 lctx.impl_items.insert(id, hir_item);\n                 lctx.modules.get_mut(&lctx.current_module).unwrap().impl_items.insert(id);\n             }\n@@ -111,7 +111,7 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         self.lctx.allocate_hir_id_counter(item.id);\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n             let hir_item = lctx.lower_foreign_item(item);\n-            let id = hir::ForeignItemId { hir_id: hir_item.hir_id };\n+            let id = hir_item.foreign_item_id();\n             lctx.foreign_items.insert(id, hir_item);\n             lctx.modules.get_mut(&lctx.current_module).unwrap().foreign_items.insert(id);\n         });\n@@ -128,7 +128,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     // only used when lowering a child item of a trait or impl.\n     fn with_parent_item_lifetime_defs<T>(\n         &mut self,\n-        parent_hir_id: hir::HirId,\n+        parent_hir_id: hir::ItemId,\n         f: impl FnOnce(&mut LoweringContext<'_, '_>) -> T,\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n@@ -197,7 +197,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         node_ids\n             .into_iter()\n-            .map(|node_id| hir::ItemId { id: self.allocate_hir_id_counter(node_id) })\n+            .map(|node_id| hir::ItemId {\n+                def_id: self.allocate_hir_id_counter(node_id).expect_owner(),\n+            })\n             .collect()\n     }\n \n@@ -232,13 +234,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         if let ItemKind::MacroDef(MacroDef { ref body, macro_rules }) = i.kind {\n             if !macro_rules || self.sess.contains_name(&i.attrs, sym::macro_export) {\n-                let hir_id = self.lower_node_id(i.id);\n+                let def_id = self.lower_node_id(i.id).expect_owner();\n                 let body = P(self.lower_mac_args(body));\n                 self.exported_macros.push(hir::MacroDef {\n                     ident,\n                     vis,\n                     attrs,\n-                    hir_id,\n+                    def_id,\n                     span: i.span,\n                     ast: MacroDef { body, macro_rules },\n                 });\n@@ -250,7 +252,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let kind = self.lower_item_kind(i.span, i.id, &mut ident, attrs, &mut vis, &i.kind);\n \n-        Some(hir::Item { hir_id: self.lower_node_id(i.id), ident, attrs, kind, vis, span: i.span })\n+        Some(hir::Item {\n+            def_id: self.lower_node_id(i.id).expect_owner(),\n+            ident,\n+            attrs,\n+            kind,\n+            vis,\n+            span: i.span,\n+        })\n     }\n \n     fn lower_item_kind(\n@@ -387,8 +396,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self_ty: ref ty,\n                 items: ref impl_items,\n             }) => {\n-                let def_id = self.resolver.local_def_id(id);\n-\n                 // Lower the \"impl header\" first. This ordering is important\n                 // for in-band lifetimes! Consider `'a` here:\n                 //\n@@ -402,10 +409,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // method, it will not be considered an in-band\n                 // lifetime to be added, but rather a reference to a\n                 // parent lifetime.\n-                let lowered_trait_impl_id = self.lower_node_id(id);\n+                let lowered_trait_def_id = self.lower_node_id(id).expect_owner();\n                 let (generics, (trait_ref, lowered_ty)) = self.add_in_band_defs(\n                     ast_generics,\n-                    def_id,\n+                    lowered_trait_def_id,\n                     AnonymousLifetimeMode::CreateParameter,\n                     |this, _| {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n@@ -417,7 +424,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                 this.trait_impls\n                                     .entry(def_id)\n                                     .or_default()\n-                                    .push(lowered_trait_impl_id);\n+                                    .push(lowered_trait_def_id);\n                             }\n                         }\n \n@@ -557,7 +564,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let vis = this.rebuild_vis(&vis);\n \n                         this.insert_item(hir::Item {\n-                            hir_id: new_id,\n+                            def_id: new_id.expect_owner(),\n                             ident,\n                             attrs,\n                             kind,\n@@ -629,7 +636,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             this.lower_use_tree(use_tree, &prefix, id, &mut vis, &mut ident, attrs);\n \n                         this.insert_item(hir::Item {\n-                            hir_id: new_hir_id,\n+                            def_id: new_hir_id.expect_owner(),\n                             ident,\n                             attrs,\n                             kind,\n@@ -702,7 +709,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem<'hir> {\n         let def_id = self.resolver.local_def_id(i.id);\n         hir::ForeignItem {\n-            hir_id: self.lower_node_id(i.id),\n+            def_id,\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n             kind: match i.kind {\n@@ -737,7 +744,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef<'hir> {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { hir_id: self.lower_node_id(i.id) },\n+            id: hir::ForeignItemId { def_id: self.lower_node_id(i.id).expect_owner() },\n             ident: i.ident,\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n@@ -837,7 +844,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         hir::TraitItem {\n-            hir_id: self.lower_node_id(i.id),\n+            def_id: trait_item_def_id,\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n             generics,\n@@ -857,7 +864,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::MacCall(..) => unimplemented!(),\n         };\n-        let id = hir::TraitItemId { hir_id: self.lower_node_id(i.id) };\n+        let id = hir::TraitItemId { def_id: self.lower_node_id(i.id).expect_owner() };\n         let defaultness = hir::Defaultness::Default { has_value: has_default };\n         hir::TraitItemRef { id, ident: i.ident, span: i.span, defaultness, kind }\n     }\n@@ -922,7 +929,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n         hir::ImplItem {\n-            hir_id: self.lower_node_id(i.id),\n+            def_id: self.lower_node_id(i.id).expect_owner(),\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n             generics,\n@@ -938,7 +945,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { hir_id: self.lower_node_id(i.id) },\n+            id: hir::ImplItemId { def_id: self.lower_node_id(i.id).expect_owner() },\n             ident: i.ident,\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),"}, {"sha": "9d0b2cd5c675d0667d7fe2ad75447158b0554aea", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -48,7 +48,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n-use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n use rustc_hir::intravisit;\n use rustc_hir::{ConstArg, GenericArg, ParamName};\n@@ -99,7 +99,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     arena: &'hir Arena<'hir>,\n \n     /// The items being lowered are collected here.\n-    items: BTreeMap<hir::HirId, hir::Item<'hir>>,\n+    items: BTreeMap<hir::ItemId, hir::Item<'hir>>,\n \n     trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem<'hir>>,\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem<'hir>>,\n@@ -108,9 +108,9 @@ struct LoweringContext<'a, 'hir: 'a> {\n     exported_macros: Vec<hir::MacroDef<'hir>>,\n     non_exported_macro_attrs: Vec<ast::Attribute>,\n \n-    trait_impls: BTreeMap<DefId, Vec<hir::HirId>>,\n+    trait_impls: BTreeMap<DefId, Vec<LocalDefId>>,\n \n-    modules: BTreeMap<hir::HirId, hir::ModuleItems>,\n+    modules: BTreeMap<LocalDefId, hir::ModuleItems>,\n \n     generator_kind: Option<hir::GeneratorKind>,\n \n@@ -158,7 +158,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// vector.\n     in_scope_lifetimes: Vec<ParamName>,\n \n-    current_module: hir::HirId,\n+    current_module: LocalDefId,\n \n     type_def_lifetime_params: DefIdMap<usize>,\n \n@@ -314,8 +314,8 @@ pub fn lower_crate<'a, 'hir>(\n         is_in_dyn_type: false,\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n         type_def_lifetime_params: Default::default(),\n-        current_module: hir::CRATE_HIR_ID,\n-        current_hir_id_owner: vec![(LocalDefId { local_def_index: CRATE_DEF_INDEX }, 0)],\n+        current_module: CRATE_DEF_ID,\n+        current_hir_id_owner: vec![(CRATE_DEF_ID, 0)],\n         item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n         generator_kind: None,\n@@ -605,12 +605,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn insert_item(&mut self, item: hir::Item<'hir>) {\n-        let id = item.hir_id;\n-        // FIXME: Use `debug_asset-rt`.\n-        assert_eq!(id.local_id, hir::ItemLocalId::from_u32(0));\n+    fn insert_item(&mut self, item: hir::Item<'hir>) -> hir::ItemId {\n+        let id = hir::ItemId { def_id: item.def_id };\n         self.items.insert(id, item);\n         self.modules.get_mut(&self.current_module).unwrap().items.insert(id);\n+        id\n     }\n \n     fn allocate_hir_id_counter(&mut self, owner: NodeId) -> hir::HirId {\n@@ -1547,29 +1546,27 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             };\n \n             trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_id);\n-            let opaque_ty_id =\n-                lctx.generate_opaque_type(opaque_ty_node_id, opaque_ty_item, span, opaque_ty_span);\n+            lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span);\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-            hir::TyKind::OpaqueDef(hir::ItemId { id: opaque_ty_id }, lifetimes)\n+            hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, lifetimes)\n         })\n     }\n \n     /// Registers a new opaque type with the proper `NodeId`s and\n     /// returns the lowered node-ID for the opaque type.\n     fn generate_opaque_type(\n         &mut self,\n-        opaque_ty_node_id: NodeId,\n+        opaque_ty_id: LocalDefId,\n         opaque_ty_item: hir::OpaqueTy<'hir>,\n         span: Span,\n         opaque_ty_span: Span,\n-    ) -> hir::HirId {\n+    ) {\n         let opaque_ty_item_kind = hir::ItemKind::OpaqueTy(opaque_ty_item);\n-        let opaque_ty_id = self.lower_node_id(opaque_ty_node_id);\n         // Generate an `type Foo = impl Trait;` declaration.\n         trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n         let opaque_ty_item = hir::Item {\n-            hir_id: opaque_ty_id,\n+            def_id: opaque_ty_id,\n             ident: Ident::invalid(),\n             attrs: Default::default(),\n             kind: opaque_ty_item_kind,\n@@ -1581,7 +1578,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // automatically for all AST items. But this opaque type item\n         // does not actually exist in the AST.\n         self.insert_item(opaque_ty_item);\n-        opaque_ty_id\n     }\n \n     fn lifetimes_from_impl_trait_bounds(\n@@ -2010,7 +2006,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // grow.\n         let input_lifetimes_count = self.in_scope_lifetimes.len() + self.lifetimes_to_define.len();\n \n-        let (opaque_ty_id, lifetime_params) = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n+        let lifetime_params = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n             // We have to be careful to get elision right here. The\n             // idea is that we create a lifetime parameter for each\n             // lifetime in the return type.  So, given a return type\n@@ -2061,10 +2057,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             };\n \n             trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n-            let opaque_ty_id =\n-                this.generate_opaque_type(opaque_ty_node_id, opaque_ty_item, span, opaque_ty_span);\n+            this.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span);\n \n-            (opaque_ty_id, lifetime_params)\n+            lifetime_params\n         });\n \n         // As documented above on the variable\n@@ -2107,7 +2102,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Foo = impl Trait` is, internally, created as a child of the\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n-        let opaque_ty_ref = hir::TyKind::OpaqueDef(hir::ItemId { id: opaque_ty_id }, generic_args);\n+        let opaque_ty_ref =\n+            hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, generic_args);\n         let opaque_ty = self.ty(opaque_ty_span, opaque_ty_ref);\n         hir::FnRetTy::Return(self.arena.alloc(opaque_ty))\n     }\n@@ -2432,7 +2428,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let mut ids: SmallVec<[hir::Stmt<'hir>; 1]> = item_ids\n                     .into_iter()\n                     .map(|item_id| {\n-                        let item_id = hir::ItemId { id: self.lower_node_id(item_id) };\n+                        let item_id = hir::ItemId {\n+                            // All the items that `lower_local` finds are `impl Trait` types.\n+                            def_id: self.lower_node_id(item_id).expect_owner(),\n+                        };\n                         self.stmt(s.span, hir::StmtKind::Item(item_id))\n                     })\n                     .collect();"}, {"sha": "c9e503a43b9e1014f41ccdf207e2b02e79085d6f", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -164,8 +164,8 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n             MonoItem::Static(def_id) => {\n                 crate::constant::codegen_static(&mut cx.constants_cx, def_id)\n             }\n-            MonoItem::GlobalAsm(hir_id) => {\n-                let item = cx.tcx.hir().expect_item(hir_id);\n+            MonoItem::GlobalAsm(item_id) => {\n+                let item = cx.tcx.hir().item(item_id);\n                 if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n                     cx.global_asm.push_str(&*asm.as_str());\n                     cx.global_asm.push_str(\"\\n\\n\");"}, {"sha": "f784d8d27cc7423de24c787030cf680637214ec4", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -93,10 +93,9 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n                 MonoItem::Static(def_id) => {\n                     crate::constant::codegen_static(&mut cx.constants_cx, def_id);\n                 }\n-                MonoItem::GlobalAsm(hir_id) => {\n-                    let item = cx.tcx.hir().expect_item(hir_id);\n-                    tcx.sess\n-                        .span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n+                MonoItem::GlobalAsm(item_id) => {\n+                    let item = cx.tcx.hir().item(item_id);\n+                    tcx.sess.span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n                 }\n             }\n         }"}, {"sha": "8e79193759eb45bda1d576b43303d046d4b4eb8e", "filename": "compiler/rustc_codegen_ssa/src/mono_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -30,8 +30,8 @@ impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n             MonoItem::Static(def_id) => {\n                 cx.codegen_static(def_id, cx.tcx().is_mutable_static(def_id));\n             }\n-            MonoItem::GlobalAsm(hir_id) => {\n-                let item = cx.tcx().hir().expect_item(hir_id);\n+            MonoItem::GlobalAsm(item_id) => {\n+                let item = cx.tcx().hir().item(item_id);\n                 if let hir::ItemKind::GlobalAsm(ref ga) = item.kind {\n                     cx.codegen_global_asm(ga);\n                 } else {"}, {"sha": "b2e201c5ff2a8c5a145df807252589eaced1be8a", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -237,7 +237,7 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n             pprust_hir::AnnNode::Name(_) => {}\n             pprust_hir::AnnNode::Item(item) => {\n                 s.s.space();\n-                s.synth_comment(format!(\"hir_id: {}\", item.hir_id));\n+                s.synth_comment(format!(\"hir_id: {}\", item.hir_id()));\n             }\n             pprust_hir::AnnNode::SubItem(id) => {\n                 s.s.space();"}, {"sha": "6ac1c570cfe1b794ca61ffd92ead4495ad20c969", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 116, "deletions": 28, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -619,7 +619,7 @@ pub struct WhereEqPredicate<'hir> {\n pub struct ModuleItems {\n     // Use BTreeSets here so items are in the same order as in the\n     // list of all items in Crate\n-    pub items: BTreeSet<HirId>,\n+    pub items: BTreeSet<ItemId>,\n     pub trait_items: BTreeSet<TraitItemId>,\n     pub impl_items: BTreeSet<ImplItemId>,\n     pub foreign_items: BTreeSet<ForeignItemId>,\n@@ -652,13 +652,13 @@ pub struct Crate<'hir> {\n     // does, because it can affect the order in which errors are\n     // detected, which in turn can make UI tests yield\n     // slightly different results.\n-    pub items: BTreeMap<HirId, Item<'hir>>,\n+    pub items: BTreeMap<ItemId, Item<'hir>>,\n \n     pub trait_items: BTreeMap<TraitItemId, TraitItem<'hir>>,\n     pub impl_items: BTreeMap<ImplItemId, ImplItem<'hir>>,\n     pub foreign_items: BTreeMap<ForeignItemId, ForeignItem<'hir>>,\n     pub bodies: BTreeMap<BodyId, Body<'hir>>,\n-    pub trait_impls: BTreeMap<DefId, Vec<HirId>>,\n+    pub trait_impls: BTreeMap<DefId, Vec<LocalDefId>>,\n \n     /// A list of the body ids written out in the order in which they\n     /// appear in the crate. If you're going to process all the bodies\n@@ -668,7 +668,7 @@ pub struct Crate<'hir> {\n \n     /// A list of modules written out in the order in which they\n     /// appear in the crate. This includes the main crate module.\n-    pub modules: BTreeMap<HirId, ModuleItems>,\n+    pub modules: BTreeMap<LocalDefId, ModuleItems>,\n     /// A list of proc macro HirIds, written out in the order in which\n     /// they are declared in the static array generated by proc_macro_harness.\n     pub proc_macros: Vec<HirId>,\n@@ -677,7 +677,7 @@ pub struct Crate<'hir> {\n }\n \n impl Crate<'hir> {\n-    pub fn item(&self, id: HirId) -> &Item<'hir> {\n+    pub fn item(&self, id: ItemId) -> &Item<'hir> {\n         &self.items[&id]\n     }\n \n@@ -761,16 +761,22 @@ impl Crate<'_> {\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug)]\n pub struct MacroDef<'hir> {\n     pub ident: Ident,\n     pub vis: Visibility<'hir>,\n     pub attrs: &'hir [Attribute],\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n     pub span: Span,\n     pub ast: ast::MacroDef,\n }\n \n+impl MacroDef<'_> {\n+    pub fn hir_id(&self) -> HirId {\n+        HirId::make_owner(self.def_id)\n+    }\n+}\n+\n /// A block of statements `{ .. }`, which may have a label (in this case the\n /// `targeted_by_break` field will be `true`) and may be `unsafe` by means of\n /// the `rules` being anything but `DefaultBlock`.\n@@ -1413,10 +1419,6 @@ pub struct Expr<'hir> {\n     pub span: Span,\n }\n \n-// `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n-rustc_data_structures::static_assert_size!(Expr<'static>, 72);\n-\n impl Expr<'_> {\n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.kind {\n@@ -1911,7 +1913,14 @@ pub struct FnSig<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n pub struct TraitItemId {\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n+}\n+\n+impl TraitItemId {\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n }\n \n /// Represents an item declaration within a trait declaration,\n@@ -1921,13 +1930,24 @@ pub struct TraitItemId {\n #[derive(Debug)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n     pub attrs: &'hir [Attribute],\n     pub generics: Generics<'hir>,\n     pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n }\n \n+impl TraitItem<'_> {\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n+\n+    pub fn trait_item_id(&self) -> TraitItemId {\n+        TraitItemId { def_id: self.def_id }\n+    }\n+}\n+\n /// Represents a trait method's body (or just argument names).\n #[derive(Encodable, Debug, HashStable_Generic)]\n pub enum TraitFn<'hir> {\n@@ -1955,14 +1975,21 @@ pub enum TraitItemKind<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n pub struct ImplItemId {\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n+}\n+\n+impl ImplItemId {\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n }\n \n /// Represents anything within an `impl` block.\n #[derive(Debug)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n     pub vis: Visibility<'hir>,\n     pub defaultness: Defaultness,\n     pub attrs: &'hir [Attribute],\n@@ -1971,6 +1998,17 @@ pub struct ImplItem<'hir> {\n     pub span: Span,\n }\n \n+impl ImplItem<'_> {\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n+\n+    pub fn impl_item_id(&self) -> ImplItemId {\n+        ImplItemId { def_id: self.def_id }\n+    }\n+}\n+\n /// Represents various kinds of content within an `impl`.\n #[derive(Debug, HashStable_Generic)]\n pub enum ImplItemKind<'hir> {\n@@ -2545,9 +2583,16 @@ impl VariantData<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the hir-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, Encodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug, Hash)]\n pub struct ItemId {\n-    pub id: HirId,\n+    pub def_id: LocalDefId,\n+}\n+\n+impl ItemId {\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n }\n \n /// An item\n@@ -2556,13 +2601,24 @@ pub struct ItemId {\n #[derive(Debug)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n     pub attrs: &'hir [Attribute],\n     pub kind: ItemKind<'hir>,\n     pub vis: Visibility<'hir>,\n     pub span: Span,\n }\n \n+impl Item<'_> {\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n+\n+    pub fn item_id(&self) -> ItemId {\n+        ItemId { def_id: self.def_id }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n #[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum Unsafety {\n@@ -2733,7 +2789,14 @@ pub enum AssocItemKind {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n pub struct ForeignItemId {\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n+}\n+\n+impl ForeignItemId {\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n }\n \n /// A reference from a foreign block to one of its items. This\n@@ -2751,17 +2814,27 @@ pub struct ForeignItemRef<'hir> {\n     pub vis: Visibility<'hir>,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug)]\n pub struct ForeignItem<'hir> {\n-    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub attrs: &'hir [Attribute],\n     pub kind: ForeignItemKind<'hir>,\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n     pub span: Span,\n     pub vis: Visibility<'hir>,\n }\n \n+impl ForeignItem<'_> {\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n+\n+    pub fn foreign_item_id(&self) -> ForeignItemId {\n+        ForeignItemId { def_id: self.def_id }\n+    }\n+}\n+\n /// An item within an `extern` block.\n #[derive(Debug, HashStable_Generic)]\n pub enum ForeignItemKind<'hir> {\n@@ -2871,11 +2944,12 @@ impl<'hir> Node<'hir> {\n \n     pub fn hir_id(&self) -> Option<HirId> {\n         match self {\n-            Node::Item(Item { hir_id, .. })\n-            | Node::ForeignItem(ForeignItem { hir_id, .. })\n-            | Node::TraitItem(TraitItem { hir_id, .. })\n-            | Node::ImplItem(ImplItem { hir_id, .. })\n-            | Node::Field(StructField { hir_id, .. })\n+            Node::Item(Item { def_id, .. })\n+            | Node::TraitItem(TraitItem { def_id, .. })\n+            | Node::ImplItem(ImplItem { def_id, .. })\n+            | Node::ForeignItem(ForeignItem { def_id, .. })\n+            | Node::MacroDef(MacroDef { def_id, .. }) => Some(HirId::make_owner(*def_id)),\n+            Node::Field(StructField { hir_id, .. })\n             | Node::AnonConst(AnonConst { hir_id, .. })\n             | Node::Expr(Expr { hir_id, .. })\n             | Node::Stmt(Stmt { hir_id, .. })\n@@ -2885,7 +2959,6 @@ impl<'hir> Node<'hir> {\n             | Node::Arm(Arm { hir_id, .. })\n             | Node::Block(Block { hir_id, .. })\n             | Node::Local(Local { hir_id, .. })\n-            | Node::MacroDef(MacroDef { hir_id, .. })\n             | Node::Lifetime(Lifetime { hir_id, .. })\n             | Node::Param(Param { hir_id, .. })\n             | Node::GenericParam(GenericParam { hir_id, .. }) => Some(*hir_id),\n@@ -2897,3 +2970,18 @@ impl<'hir> Node<'hir> {\n         }\n     }\n }\n+\n+// Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+mod size_asserts {\n+    rustc_data_structures::static_assert_size!(super::Block<'static>, 48);\n+    rustc_data_structures::static_assert_size!(super::Expr<'static>, 72);\n+    rustc_data_structures::static_assert_size!(super::Pat<'static>, 88);\n+    rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n+    rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);\n+\n+    rustc_data_structures::static_assert_size!(super::Item<'static>, 200);\n+    rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 144);\n+    rustc_data_structures::static_assert_size!(super::ImplItem<'static>, 168);\n+    rustc_data_structures::static_assert_size!(super::ForeignItem<'static>, 152);\n+}"}, {"sha": "dd5cddd8525c1bcf5a5b0d59825ae0195fdaabb8", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -18,6 +18,21 @@ pub struct HirId {\n     pub local_id: ItemLocalId,\n }\n \n+impl HirId {\n+    pub fn expect_owner(self) -> LocalDefId {\n+        assert_eq!(self.local_id.index(), 0);\n+        self.owner\n+    }\n+\n+    pub fn as_owner(self) -> Option<LocalDefId> {\n+        if self.local_id.index() == 0 { Some(self.owner) } else { None }\n+    }\n+\n+    pub fn make_owner(owner: LocalDefId) -> Self {\n+        Self { owner, local_id: ItemLocalId::from_u32(0) }\n+    }\n+}\n+\n impl fmt::Display for HirId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{:?}\", self)"}, {"sha": "6a2719c2d66778ebeeed059a061bbd941c46ee34", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -133,7 +133,7 @@ pub trait Map<'hir> {\n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     fn find(&self, hir_id: HirId) -> Option<Node<'hir>>;\n     fn body(&self, id: BodyId) -> &'hir Body<'hir>;\n-    fn item(&self, id: HirId) -> &'hir Item<'hir>;\n+    fn item(&self, id: ItemId) -> &'hir Item<'hir>;\n     fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir>;\n     fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir>;\n     fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir>;\n@@ -150,7 +150,7 @@ impl<'hir> Map<'hir> for ErasedMap<'hir> {\n     fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n         self.0.body(id)\n     }\n-    fn item(&self, id: HirId) -> &'hir Item<'hir> {\n+    fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n         self.0.item(id)\n     }\n     fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n@@ -269,7 +269,7 @@ pub trait Visitor<'v>: Sized {\n     /// reason to override this method is if you want a nested pattern\n     /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n     fn visit_nested_item(&mut self, id: ItemId) {\n-        let opt_item = self.nested_visit_map().inter().map(|map| map.item(id.id));\n+        let opt_item = self.nested_visit_map().inter().map(|map| map.item(id));\n         walk_list!(self, visit_item, opt_item);\n     }\n \n@@ -489,7 +489,7 @@ pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate<'v>) {\n }\n \n pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef<'v>) {\n-    visitor.visit_id(macro_def.hir_id);\n+    visitor.visit_id(macro_def.hir_id());\n     visitor.visit_ident(macro_def.ident);\n     walk_list!(visitor, visit_attribute, macro_def.attrs);\n }\n@@ -565,16 +565,16 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n     visitor.visit_ident(item.ident);\n     match item.kind {\n         ItemKind::ExternCrate(orig_name) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             if let Some(orig_name) = orig_name {\n                 visitor.visit_name(item.span, orig_name);\n             }\n         }\n         ItemKind::Use(ref path, _) => {\n-            visitor.visit_use(path, item.hir_id);\n+            visitor.visit_use(path, item.hir_id());\n         }\n         ItemKind::Static(ref typ, _, body) | ItemKind::Const(ref typ, body) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_ty(typ);\n             visitor.visit_nested_body(body);\n         }\n@@ -583,33 +583,33 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             &sig.decl,\n             body_id,\n             item.span,\n-            item.hir_id,\n+            item.hir_id(),\n         ),\n         ItemKind::Mod(ref module) => {\n             // `visit_mod()` takes care of visiting the `Item`'s `HirId`.\n-            visitor.visit_mod(module, item.span, item.hir_id)\n+            visitor.visit_mod(module, item.span, item.hir_id())\n         }\n         ItemKind::ForeignMod { abi: _, items } => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             walk_list!(visitor, visit_foreign_item_ref, items);\n         }\n         ItemKind::GlobalAsm(_) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n         }\n         ItemKind::TyAlias(ref ty, ref generics) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_ty(ty);\n             visitor.visit_generics(generics)\n         }\n         ItemKind::OpaqueTy(OpaqueTy { ref generics, bounds, .. }) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             walk_generics(visitor, generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n         ItemKind::Enum(ref enum_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             // `visit_enum_def()` takes care of visiting the `Item`'s `HirId`.\n-            visitor.visit_enum_def(enum_definition, generics, item.hir_id, item.span)\n+            visitor.visit_enum_def(enum_definition, generics, item.hir_id(), item.span)\n         }\n         ItemKind::Impl(Impl {\n             unsafety: _,\n@@ -622,7 +622,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             ref self_ty,\n             items,\n         }) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_trait_ref, of_trait);\n             visitor.visit_ty(self_ty);\n@@ -631,23 +631,23 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n         ItemKind::Struct(ref struct_definition, ref generics)\n         | ItemKind::Union(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_variant_data(\n                 struct_definition,\n                 item.ident.name,\n                 generics,\n-                item.hir_id,\n+                item.hir_id(),\n                 item.span,\n             );\n         }\n         ItemKind::Trait(.., ref generics, bounds, trait_item_refs) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_trait_item_ref, trait_item_refs);\n         }\n         ItemKind::TraitAlias(ref generics, bounds) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n@@ -836,7 +836,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n }\n \n pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n-    visitor.visit_id(foreign_item.hir_id);\n+    visitor.visit_id(foreign_item.hir_id());\n     visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_ident(foreign_item.ident);\n \n@@ -964,12 +964,12 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n     visitor.visit_generics(&trait_item.generics);\n     match trait_item.kind {\n         TraitItemKind::Const(ref ty, default) => {\n-            visitor.visit_id(trait_item.hir_id);\n+            visitor.visit_id(trait_item.hir_id());\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_nested_body, default);\n         }\n         TraitItemKind::Fn(ref sig, TraitFn::Required(param_names)) => {\n-            visitor.visit_id(trait_item.hir_id);\n+            visitor.visit_id(trait_item.hir_id());\n             visitor.visit_fn_decl(&sig.decl);\n             for &param_name in param_names {\n                 visitor.visit_ident(param_name);\n@@ -981,11 +981,11 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n                 &sig.decl,\n                 body_id,\n                 trait_item.span,\n-                trait_item.hir_id,\n+                trait_item.hir_id(),\n             );\n         }\n         TraitItemKind::Type(bounds, ref default) => {\n-            visitor.visit_id(trait_item.hir_id);\n+            visitor.visit_id(trait_item.hir_id());\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_ty, default);\n         }\n@@ -1004,7 +1004,7 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItem {\n-        hir_id: _,\n+        def_id: _,\n         ident,\n         ref vis,\n         ref defaultness,\n@@ -1021,7 +1021,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     visitor.visit_generics(generics);\n     match *kind {\n         ImplItemKind::Const(ref ty, body) => {\n-            visitor.visit_id(impl_item.hir_id);\n+            visitor.visit_id(impl_item.hir_id());\n             visitor.visit_ty(ty);\n             visitor.visit_nested_body(body);\n         }\n@@ -1031,11 +1031,11 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n                 &sig.decl,\n                 body_id,\n                 impl_item.span,\n-                impl_item.hir_id,\n+                impl_item.hir_id(),\n             );\n         }\n         ImplItemKind::TyAlias(ref ty) => {\n-            visitor.visit_id(impl_item.hir_id);\n+            visitor.visit_id(impl_item.hir_id());\n             visitor.visit_ty(ty);\n         }\n     }"}, {"sha": "5fb4b8a58c210bd45eeb6de4d726d40dffc5399e", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 55, "deletions": 18, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -1,8 +1,8 @@\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n \n use crate::hir::{\n-    BodyId, Expr, ForeignItemId, ImplItem, ImplItemId, Item, ItemId, Mod, TraitItem, TraitItemId,\n-    Ty, VisibilityKind,\n+    BodyId, Expr, ForeignItem, ForeignItemId, ImplItem, ImplItemId, Item, ItemId, MacroDef, Mod,\n+    TraitItem, TraitItemId, Ty, VisibilityKind,\n };\n use crate::hir_id::{HirId, ItemLocalId};\n use rustc_span::def_id::{DefPathHash, LocalDefId};\n@@ -34,30 +34,39 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for HirId {\n     }\n }\n \n+impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ItemId {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n+        hcx.local_def_path_hash(self.def_id)\n+    }\n+}\n+\n impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for TraitItemId {\n-    type KeyType = (DefPathHash, ItemLocalId);\n+    type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &HirCtx) -> (DefPathHash, ItemLocalId) {\n-        self.hir_id.to_stable_hash_key(hcx)\n+    fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n+        hcx.local_def_path_hash(self.def_id)\n     }\n }\n \n impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ImplItemId {\n-    type KeyType = (DefPathHash, ItemLocalId);\n+    type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &HirCtx) -> (DefPathHash, ItemLocalId) {\n-        self.hir_id.to_stable_hash_key(hcx)\n+    fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n+        hcx.local_def_path_hash(self.def_id)\n     }\n }\n \n impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ForeignItemId {\n-    type KeyType = (DefPathHash, ItemLocalId);\n+    type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &HirCtx) -> (DefPathHash, ItemLocalId) {\n-        self.hir_id.to_stable_hash_key(hcx)\n+    fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n+        hcx.local_def_path_hash(self.def_id)\n     }\n }\n \n@@ -82,25 +91,25 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for BodyId {\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ItemId {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.id, hasher)\n+        hcx.hash_reference_to_item(self.hir_id(), hasher)\n     }\n }\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ForeignItemId {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.hir_id, hasher)\n+        hcx.hash_reference_to_item(self.hir_id(), hasher)\n     }\n }\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ImplItemId {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.hir_id, hasher)\n+        hcx.hash_reference_to_item(self.hir_id(), hasher)\n     }\n }\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitItemId {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.hir_id, hasher)\n+        hcx.hash_reference_to_item(self.hir_id(), hasher)\n     }\n }\n \n@@ -130,7 +139,7 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for VisibilityKind<'_>\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitItem<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let TraitItem { hir_id: _, ident, ref attrs, ref generics, ref kind, span } = *self;\n+        let TraitItem { def_id: _, ident, ref attrs, ref generics, ref kind, span } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n@@ -145,7 +154,7 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitItem<'_> {\n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ImplItem<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n         let ImplItem {\n-            hir_id: _,\n+            def_id: _,\n             ident,\n             ref vis,\n             defaultness,\n@@ -167,9 +176,23 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ImplItem<'_> {\n     }\n }\n \n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ForeignItem<'_> {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        let ForeignItem { def_id: _, ident, ref attrs, ref kind, span, ref vis } = *self;\n+\n+        hcx.hash_hir_item_like(|hcx| {\n+            ident.name.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n+            kind.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+            vis.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Item<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let Item { ident, ref attrs, hir_id: _, ref kind, ref vis, span } = *self;\n+        let Item { ident, ref attrs, def_id: _, ref kind, ref vis, span } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n@@ -180,3 +203,17 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Item<'_> {\n         });\n     }\n }\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for MacroDef<'_> {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        let MacroDef { ident, ref attrs, def_id: _, ref ast, ref vis, span } = *self;\n+\n+        hcx.hash_hir_item_like(|hcx| {\n+            ident.name.hash_stable(hcx, hasher);\n+            attrs.hash_stable(hcx, hasher);\n+            ast.hash_stable(hcx, hasher);\n+            vis.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        });\n+    }\n+}"}, {"sha": "416918e3344ee4c2adb5dbb62f0c9137b73251f9", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -54,7 +54,7 @@ pub const NO_ANN: &dyn PpAnn = &NoAnn;\n impl PpAnn for hir::Crate<'_> {\n     fn nested(&self, state: &mut State<'_>, nested: Nested) {\n         match nested {\n-            Nested::Item(id) => state.print_item(self.item(id.id)),\n+            Nested::Item(id) => state.print_item(self.item(id)),\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::ForeignItem(id) => state.print_foreign_item(self.foreign_item(id)),\n@@ -69,7 +69,7 @@ impl PpAnn for hir::Crate<'_> {\n impl PpAnn for &dyn rustc_hir::intravisit::Map<'_> {\n     fn nested(&self, state: &mut State<'_>, nested: Nested) {\n         match nested {\n-            Nested::Item(id) => state.print_item(self.item(id.id)),\n+            Nested::Item(id) => state.print_item(self.item(id)),\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::ForeignItem(id) => state.print_foreign_item(self.foreign_item(id)),\n@@ -934,7 +934,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem<'_>) {\n-        self.ann.pre(self, AnnNode::SubItem(ti.hir_id));\n+        self.ann.pre(self, AnnNode::SubItem(ti.hir_id()));\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(ti.span.lo());\n         self.print_outer_attributes(&ti.attrs);\n@@ -969,11 +969,11 @@ impl<'a> State<'a> {\n                 );\n             }\n         }\n-        self.ann.post(self, AnnNode::SubItem(ti.hir_id))\n+        self.ann.post(self, AnnNode::SubItem(ti.hir_id()))\n     }\n \n     pub fn print_impl_item(&mut self, ii: &hir::ImplItem<'_>) {\n-        self.ann.pre(self, AnnNode::SubItem(ii.hir_id));\n+        self.ann.pre(self, AnnNode::SubItem(ii.hir_id()));\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(ii.span.lo());\n         self.print_outer_attributes(&ii.attrs);\n@@ -995,7 +995,7 @@ impl<'a> State<'a> {\n                 self.print_associated_type(ii.ident, &ii.generics, None, Some(ty));\n             }\n         }\n-        self.ann.post(self, AnnNode::SubItem(ii.hir_id))\n+        self.ann.post(self, AnnNode::SubItem(ii.hir_id()))\n     }\n \n     pub fn print_local(&mut self, init: Option<&hir::Expr<'_>>, decl: impl Fn(&mut Self)) {"}, {"sha": "1162379d3d9817616204f187b4cdd81bb3fef914", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -167,17 +167,17 @@ impl Visitor<'tcx> for IfThisChanged<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.process_attrs(item.hir_id, &item.attrs);\n+        self.process_attrs(item.hir_id(), &item.attrs);\n         intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.process_attrs(trait_item.hir_id, &trait_item.attrs);\n+        self.process_attrs(trait_item.hir_id(), &trait_item.attrs);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.process_attrs(impl_item.hir_id, &impl_item.attrs);\n+        self.process_attrs(impl_item.hir_id(), &impl_item.attrs);\n         intravisit::walk_impl_item(self, impl_item);\n     }\n "}, {"sha": "8a83149d732355ec9efbee689462ed1ea1bb1047", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -17,7 +17,7 @@ use rustc_ast::{self as ast, Attribute, NestedMetaItem};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::Node as HirNode;\n@@ -179,7 +179,7 @@ pub struct DirtyCleanVisitor<'tcx> {\n \n impl DirtyCleanVisitor<'tcx> {\n     /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n-    fn assertion_maybe(&mut self, item_id: hir::HirId, attr: &Attribute) -> Option<Assertion> {\n+    fn assertion_maybe(&mut self, item_id: LocalDefId, attr: &Attribute) -> Option<Assertion> {\n         let is_clean = if self.tcx.sess.check_name(attr, sym::rustc_dirty) {\n             false\n         } else if self.tcx.sess.check_name(attr, sym::rustc_clean) {\n@@ -207,7 +207,7 @@ impl DirtyCleanVisitor<'tcx> {\n     /// Gets the \"auto\" assertion on pre-validated attr, along with the `except` labels.\n     fn assertion_auto(\n         &mut self,\n-        item_id: hir::HirId,\n+        item_id: LocalDefId,\n         attr: &Attribute,\n         is_clean: bool,\n     ) -> Assertion {\n@@ -253,8 +253,9 @@ impl DirtyCleanVisitor<'tcx> {\n \n     /// Return all DepNode labels that should be asserted for this item.\n     /// index=0 is the \"name\" used for error messages\n-    fn auto_labels(&mut self, item_id: hir::HirId, attr: &Attribute) -> (&'static str, Labels) {\n-        let node = self.tcx.hir().get(item_id);\n+    fn auto_labels(&mut self, item_id: LocalDefId, attr: &Attribute) -> (&'static str, Labels) {\n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(item_id);\n+        let node = self.tcx.hir().get(hir_id);\n         let (name, labels) = match node {\n             HirNode::Item(item) => {\n                 match item.kind {\n@@ -430,18 +431,17 @@ impl DirtyCleanVisitor<'tcx> {\n         }\n     }\n \n-    fn check_item(&mut self, item_id: hir::HirId, item_span: Span) {\n-        let def_id = self.tcx.hir().local_def_id(item_id);\n-        for attr in self.tcx.get_attrs(def_id.to_def_id()).iter() {\n+    fn check_item(&mut self, item_id: LocalDefId, item_span: Span) {\n+        for attr in self.tcx.get_attrs(item_id.to_def_id()).iter() {\n             let assertion = match self.assertion_maybe(item_id, attr) {\n                 Some(a) => a,\n                 None => continue,\n             };\n             self.checked_attrs.insert(attr.id);\n-            for dep_node in self.dep_nodes(&assertion.clean, def_id.to_def_id()) {\n+            for dep_node in self.dep_nodes(&assertion.clean, item_id.to_def_id()) {\n                 self.assert_clean(item_span, dep_node);\n             }\n-            for dep_node in self.dep_nodes(&assertion.dirty, def_id.to_def_id()) {\n+            for dep_node in self.dep_nodes(&assertion.dirty, item_id.to_def_id()) {\n                 self.assert_dirty(item_span, dep_node);\n             }\n         }\n@@ -450,19 +450,19 @@ impl DirtyCleanVisitor<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.check_item(item.hir_id, item.span);\n+        self.check_item(item.def_id, item.span);\n     }\n \n     fn visit_trait_item(&mut self, item: &hir::TraitItem<'_>) {\n-        self.check_item(item.hir_id, item.span);\n+        self.check_item(item.def_id, item.span);\n     }\n \n     fn visit_impl_item(&mut self, item: &hir::ImplItem<'_>) {\n-        self.check_item(item.hir_id, item.span);\n+        self.check_item(item.def_id, item.span);\n     }\n \n     fn visit_foreign_item(&mut self, item: &hir::ForeignItem<'_>) {\n-        self.check_item(item.hir_id, item.span);\n+        self.check_item(item.def_id, item.span);\n     }\n }\n "}, {"sha": "fa0d5b8301349a6fa752519454b3778dc356f754", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -7,10 +7,7 @@ use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{\n-    self as hir, GenericBound, ImplItem, Item, ItemKind, Lifetime, LifetimeName, Node, TraitItem,\n-    TyKind,\n-};\n+use rustc_hir::{self as hir, GenericBound, Item, ItemKind, Lifetime, LifetimeName, Node, TyKind};\n use rustc_middle::ty::{self, AssocItemContainer, RegionKind, Ty, TypeFoldable, TypeVisitor};\n use rustc_span::symbol::Ident;\n use rustc_span::{MultiSpan, Span};\n@@ -234,7 +231,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n             match fn_return.kind {\n                 TyKind::OpaqueDef(item_id, _) => {\n-                    let item = tcx.hir().item(item_id.id);\n+                    let item = tcx.hir().item(item_id);\n                     let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n                         opaque\n                     } else {\n@@ -343,17 +340,17 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n         let tcx = self.tcx();\n         match tcx.hir().get_if_local(def_id) {\n-            Some(Node::ImplItem(ImplItem { ident, hir_id, .. })) => {\n-                match tcx.hir().find(tcx.hir().get_parent_item(*hir_id)) {\n+            Some(Node::ImplItem(impl_item)) => {\n+                match tcx.hir().find(tcx.hir().get_parent_item(impl_item.hir_id())) {\n                     Some(Node::Item(Item {\n                         kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n                         ..\n-                    })) => Some((*ident, self_ty)),\n+                    })) => Some((impl_item.ident, self_ty)),\n                     _ => None,\n                 }\n             }\n-            Some(Node::TraitItem(TraitItem { ident, hir_id, .. })) => {\n-                let parent_id = tcx.hir().get_parent_item(*hir_id);\n+            Some(Node::TraitItem(trait_item)) => {\n+                let parent_id = tcx.hir().get_parent_item(trait_item.hir_id());\n                 match tcx.hir().find(parent_id) {\n                     Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n                         // The method being called is defined in the `trait`, but the `'static`\n@@ -364,8 +361,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             .hir()\n                             .trait_impls(trait_did)\n                             .iter()\n-                            .filter_map(|impl_node| {\n-                                let impl_did = tcx.hir().local_def_id(*impl_node);\n+                            .filter_map(|&impl_did| {\n                                 match tcx.hir().get_if_local(impl_did.to_def_id()) {\n                                     Some(Node::Item(Item {\n                                         kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n@@ -389,7 +385,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             })\n                             .next()\n                         {\n-                            Some(self_ty) => Some((*ident, self_ty)),\n+                            Some(self_ty) => Some((trait_item.ident, self_ty)),\n                             _ => None,\n                         }\n                     }"}, {"sha": "544da4cd9aa7d44cd6f9df777b659011358932f0", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -831,12 +831,11 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n             },\n             {\n                 par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                    let local_def_id = tcx.hir().local_def_id(module);\n-                    tcx.ensure().check_mod_loops(local_def_id);\n-                    tcx.ensure().check_mod_attrs(local_def_id);\n-                    tcx.ensure().check_mod_naked_functions(local_def_id);\n-                    tcx.ensure().check_mod_unstable_api_usage(local_def_id);\n-                    tcx.ensure().check_mod_const_bodies(local_def_id);\n+                    tcx.ensure().check_mod_loops(module);\n+                    tcx.ensure().check_mod_attrs(module);\n+                    tcx.ensure().check_mod_naked_functions(module);\n+                    tcx.ensure().check_mod_unstable_api_usage(module);\n+                    tcx.ensure().check_mod_const_bodies(module);\n                 });\n             }\n         );\n@@ -861,10 +860,8 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                         // \"not all control paths return a value\" is reported here.\n                         //\n                         // maybe move the check to a MIR pass?\n-                        let local_def_id = tcx.hir().local_def_id(module);\n-\n-                        tcx.ensure().check_mod_liveness(local_def_id);\n-                        tcx.ensure().check_mod_intrinsics(local_def_id);\n+                        tcx.ensure().check_mod_liveness(module);\n+                        tcx.ensure().check_mod_intrinsics(module);\n                     });\n                 });\n             }\n@@ -926,7 +923,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n             {\n                 sess.time(\"privacy_checking_modules\", || {\n                     par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                        tcx.ensure().check_mod_privacy(tcx.hir().local_def_id(module));\n+                        tcx.ensure().check_mod_privacy(module);\n                     });\n                 });\n             }"}, {"sha": "d0262935c894cc8b035718092ea0169ec3352a84", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -26,7 +26,7 @@ struct Finder<'tcx> {\n impl<'v> ItemLikeVisitor<'v> for Finder<'_> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if self.tcx.sess.contains_name(&item.attrs, sym::rustc_proc_macro_decls) {\n-            self.decls = Some(item.hir_id);\n+            self.decls = Some(item.hir_id());\n         }\n     }\n "}, {"sha": "71017fcde876ff706ec734f28e9311fca5ae590c", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 40, "deletions": 50, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -36,9 +36,9 @@ use rustc_feature::{deprecated_attributes, AttributeGate, AttributeTemplate, Att\n use rustc_feature::{GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet};\n use rustc_hir::{ForeignItemKind, GenericParamKind, PatKind};\n-use rustc_hir::{HirId, HirIdSet, Node};\n+use rustc_hir::{HirId, Node};\n use rustc_index::vec::Idx;\n use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -173,8 +173,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxPointers {\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..) => {\n-                let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n-                self.check_heap_type(cx, it.span, cx.tcx.type_of(def_id))\n+                self.check_heap_type(cx, it.span, cx.tcx.type_of(it.def_id))\n             }\n             _ => (),\n         }\n@@ -585,9 +584,9 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 // Issue #11592: traits are always considered exported, even when private.\n                 if let hir::VisibilityKind::Inherited = it.vis.node {\n-                    self.private_traits.insert(it.hir_id);\n+                    self.private_traits.insert(it.hir_id());\n                     for trait_item_ref in trait_item_refs {\n-                        self.private_traits.insert(trait_item_ref.id.hir_id);\n+                        self.private_traits.insert(trait_item_ref.id.hir_id());\n                     }\n                     return;\n                 }\n@@ -601,7 +600,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n                     if let Some(Node::Item(item)) = cx.tcx.hir().find(hir_id) {\n                         if let hir::VisibilityKind::Inherited = item.vis.node {\n                             for impl_item_ref in items {\n-                                self.private_traits.insert(impl_item_ref.id.hir_id);\n+                                self.private_traits.insert(impl_item_ref.id.hir_id());\n                             }\n                         }\n                     }\n@@ -621,23 +620,21 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             _ => return,\n         };\n \n-        let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, Some(it.hir_id), &it.attrs, it.span, article, desc);\n+        self.check_missing_docs_attrs(cx, Some(it.hir_id()), &it.attrs, it.span, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, trait_item: &hir::TraitItem<'_>) {\n-        if self.private_traits.contains(&trait_item.hir_id) {\n+        if self.private_traits.contains(&trait_item.hir_id()) {\n             return;\n         }\n \n-        let def_id = cx.tcx.hir().local_def_id(trait_item.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n \n         self.check_missing_docs_attrs(\n             cx,\n-            Some(trait_item.hir_id),\n+            Some(trait_item.hir_id()),\n             &trait_item.attrs,\n             trait_item.span,\n             article,\n@@ -647,15 +644,14 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n         // If the method is an impl for a trait, don't doc.\n-        if method_context(cx, impl_item.hir_id) == MethodLateContext::TraitImpl {\n+        if method_context(cx, impl_item.hir_id()) == MethodLateContext::TraitImpl {\n             return;\n         }\n \n-        let def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n         self.check_missing_docs_attrs(\n             cx,\n-            Some(impl_item.hir_id),\n+            Some(impl_item.hir_id()),\n             &impl_item.attrs,\n             impl_item.span,\n             article,\n@@ -664,11 +660,10 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'_>) {\n-        let def_id = cx.tcx.hir().local_def_id(foreign_item.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(foreign_item.def_id.to_def_id());\n         self.check_missing_docs_attrs(\n             cx,\n-            Some(foreign_item.hir_id),\n+            Some(foreign_item.hir_id()),\n             &foreign_item.attrs,\n             foreign_item.span,\n             article,\n@@ -732,29 +727,29 @@ declare_lint_pass!(MissingCopyImplementations => [MISSING_COPY_IMPLEMENTATIONS])\n \n impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.hir_id) {\n+        if !cx.access_levels.is_reachable(item.hir_id()) {\n             return;\n         }\n         let (def, ty) = match item.kind {\n             hir::ItemKind::Struct(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.hir_id));\n+                let def = cx.tcx.adt_def(item.def_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Union(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.hir_id));\n+                let def = cx.tcx.adt_def(item.def_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Enum(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.hir_id));\n+                let def = cx.tcx.adt_def(item.def_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             _ => return,\n@@ -812,14 +807,14 @@ declare_lint! {\n \n #[derive(Default)]\n pub struct MissingDebugImplementations {\n-    impling_types: Option<HirIdSet>,\n+    impling_types: Option<LocalDefIdSet>,\n }\n \n impl_lint_pass!(MissingDebugImplementations => [MISSING_DEBUG_IMPLEMENTATIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.hir_id) {\n+        if !cx.access_levels.is_reachable(item.hir_id()) {\n             return;\n         }\n \n@@ -834,11 +829,11 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let mut impls = HirIdSet::default();\n+            let mut impls = LocalDefIdSet::default();\n             cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n                     if let Some(def_id) = ty_def.did.as_local() {\n-                        impls.insert(cx.tcx.hir().local_def_id_to_hir_id(def_id));\n+                        impls.insert(def_id);\n                     }\n                 }\n             });\n@@ -847,7 +842,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n             debug!(\"{:?}\", self.impling_types);\n         }\n \n-        if !self.impling_types.as_ref().unwrap().contains(&item.hir_id) {\n+        if !self.impling_types.as_ref().unwrap().contains(&item.def_id) {\n             cx.struct_span_lint(MISSING_DEBUG_IMPLEMENTATIONS, item.span, |lint| {\n                 lint.build(&format!(\n                     \"type does not implement `{}`; consider adding `#[derive(Debug)]` \\\n@@ -1362,14 +1357,14 @@ impl UnreachablePub {\n \n impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        self.perform_lint(cx, \"item\", item.hir_id, &item.vis, item.span, true);\n+        self.perform_lint(cx, \"item\", item.hir_id(), &item.vis, item.span, true);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'tcx>) {\n         self.perform_lint(\n             cx,\n             \"item\",\n-            foreign_item.hir_id,\n+            foreign_item.hir_id(),\n             &foreign_item.vis,\n             foreign_item.span,\n             true,\n@@ -1381,7 +1376,7 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n-        self.perform_lint(cx, \"item\", impl_item.hir_id, &impl_item.vis, impl_item.span, false);\n+        self.perform_lint(cx, \"item\", impl_item.hir_id(), &impl_item.vis, impl_item.span, false);\n     }\n }\n \n@@ -1603,8 +1598,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n         use rustc_middle::ty::PredicateKind::*;\n \n         if cx.tcx.features().trivial_bounds {\n-            let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-            let predicates = cx.tcx.predicates_of(def_id);\n+            let predicates = cx.tcx.predicates_of(item.def_id);\n             for &(predicate, span) in predicates.predicates {\n                 let predicate_kind_name = match predicate.kind().skip_binder() {\n                     Trait(..) => \"Trait\",\n@@ -1810,7 +1804,7 @@ declare_lint! {\n }\n \n pub struct UnnameableTestItems {\n-    boundary: Option<hir::HirId>, // HirId of the item under which things are not nameable\n+    boundary: Option<LocalDefId>, // Id of the item under which things are not nameable\n     items_nameable: bool,\n }\n \n@@ -1828,7 +1822,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n             if let hir::ItemKind::Mod(..) = it.kind {\n             } else {\n                 self.items_nameable = false;\n-                self.boundary = Some(it.hir_id);\n+                self.boundary = Some(it.def_id);\n             }\n             return;\n         }\n@@ -1841,7 +1835,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n     }\n \n     fn check_item_post(&mut self, _cx: &LateContext<'_>, it: &hir::Item<'_>) {\n-        if !self.items_nameable && self.boundary == Some(it.hir_id) {\n+        if !self.items_nameable && self.boundary == Some(it.def_id) {\n             self.items_nameable = true;\n         }\n     }\n@@ -2125,7 +2119,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n         let infer_static = cx.tcx.features().infer_static_outlives_requirements;\n-        let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n+        let def_id = item.def_id;\n         if let hir::ItemKind::Struct(_, ref hir_generics)\n         | hir::ItemKind::Enum(_, ref hir_generics)\n         | hir::ItemKind::Union(_, ref hir_generics) = item.kind\n@@ -2680,10 +2674,7 @@ impl ClashingExternDeclarations {\n     /// Insert a new foreign item into the seen set. If a symbol with the same name already exists\n     /// for the item, return its HirId without updating the set.\n     fn insert(&mut self, tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> Option<HirId> {\n-        let hid = fi.hir_id;\n-\n-        let local_did = tcx.hir().local_def_id(fi.hir_id);\n-        let did = local_did.to_def_id();\n+        let did = fi.def_id.to_def_id();\n         let instance = Instance::new(did, ty::List::identity_for_item(tcx, did));\n         let name = Symbol::intern(tcx.symbol_name(instance).name);\n         if let Some(&hir_id) = self.seen_decls.get(&name) {\n@@ -2692,24 +2683,23 @@ impl ClashingExternDeclarations {\n             // This lets us avoid emitting \"knock-on\" diagnostics.\n             Some(hir_id)\n         } else {\n-            self.seen_decls.insert(name, hid)\n+            self.seen_decls.insert(name, fi.hir_id())\n         }\n     }\n \n     /// Get the name of the symbol that's linked against for a given extern declaration. That is,\n     /// the name specified in a #[link_name = ...] attribute if one was specified, else, just the\n     /// symbol's name.\n     fn name_of_extern_decl(tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> SymbolName {\n-        let did = tcx.hir().local_def_id(fi.hir_id);\n         if let Some((overridden_link_name, overridden_link_name_span)) =\n-            tcx.codegen_fn_attrs(did).link_name.map(|overridden_link_name| {\n+            tcx.codegen_fn_attrs(fi.def_id).link_name.map(|overridden_link_name| {\n                 // FIXME: Instead of searching through the attributes again to get span\n                 // information, we could have codegen_fn_attrs also give span information back for\n                 // where the attribute was defined. However, until this is found to be a\n                 // bottleneck, this does just fine.\n                 (\n                     overridden_link_name,\n-                    tcx.get_attrs(did.to_def_id())\n+                    tcx.get_attrs(fi.def_id.to_def_id())\n                         .iter()\n                         .find(|at| tcx.sess.check_name(at, sym::link_name))\n                         .unwrap()\n@@ -2937,10 +2927,10 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n             let tcx = cx.tcx;\n             if let Some(existing_hid) = self.insert(tcx, this_fi) {\n                 let existing_decl_ty = tcx.type_of(tcx.hir().local_def_id(existing_hid));\n-                let this_decl_ty = tcx.type_of(tcx.hir().local_def_id(this_fi.hir_id));\n+                let this_decl_ty = tcx.type_of(this_fi.def_id);\n                 debug!(\n                     \"ClashingExternDeclarations: Comparing existing {:?}: {:?} to this {:?}: {:?}\",\n-                    existing_hid, existing_decl_ty, this_fi.hir_id, this_decl_ty\n+                    existing_hid, existing_decl_ty, this_fi.def_id, this_decl_ty\n                 );\n                 // Check that the declarations match.\n                 if !Self::structurally_same_type(\n@@ -2962,7 +2952,7 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                     // Finally, emit the diagnostic.\n                     tcx.struct_span_lint_hir(\n                         CLASHING_EXTERN_DECLARATIONS,\n-                        this_fi.hir_id,\n+                        this_fi.hir_id(),\n                         get_relevant_span(this_fi),\n                         |lint| {\n                             let mut expected_str = DiagnosticStyledString::new();"}, {"sha": "e019b621aa359a378069ce079a0623471446188f", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -142,8 +142,8 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         self.context.generics = it.kind.generics();\n         let old_cached_typeck_results = self.context.cached_typeck_results.take();\n         let old_enclosing_body = self.context.enclosing_body.take();\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.hir_id, |cx| {\n+        self.with_lint_attrs(it.hir_id(), &it.attrs, |cx| {\n+            cx.with_param_env(it.hir_id(), |cx| {\n                 lint_callback!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n                 lint_callback!(cx, check_item_post, it);\n@@ -155,8 +155,8 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.hir_id, |cx| {\n+        self.with_lint_attrs(it.hir_id(), &it.attrs, |cx| {\n+            cx.with_param_env(it.hir_id(), |cx| {\n                 lint_callback!(cx, check_foreign_item, it);\n                 hir_visit::walk_foreign_item(cx, it);\n                 lint_callback!(cx, check_foreign_item_post, it);\n@@ -178,7 +178,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n-        let get_item = |id: hir::ItemId| self.context.tcx.hir().item(id.id);\n+        let get_item = |id: hir::ItemId| self.context.tcx.hir().item(id);\n         let attrs = &s.kind.attrs(get_item);\n         // See `EarlyContextAndPass::visit_stmt` for an explanation\n         // of why we call `walk_stmt` outside of `with_lint_attrs`\n@@ -301,8 +301,8 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         let generics = self.context.generics.take();\n         self.context.generics = Some(&trait_item.generics);\n-        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n-            cx.with_param_env(trait_item.hir_id, |cx| {\n+        self.with_lint_attrs(trait_item.hir_id(), &trait_item.attrs, |cx| {\n+            cx.with_param_env(trait_item.hir_id(), |cx| {\n                 lint_callback!(cx, check_trait_item, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n                 lint_callback!(cx, check_trait_item_post, trait_item);\n@@ -314,8 +314,8 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         let generics = self.context.generics.take();\n         self.context.generics = Some(&impl_item.generics);\n-        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n-            cx.with_param_env(impl_item.hir_id, |cx| {\n+        self.with_lint_attrs(impl_item.hir_id(), &impl_item.attrs, |cx| {\n+            cx.with_param_env(impl_item.hir_id(), |cx| {\n                 lint_callback!(cx, check_impl_item, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n                 lint_callback!(cx, check_impl_item_post, impl_item);\n@@ -496,7 +496,7 @@ pub fn check_crate<'tcx, T: LateLintPass<'tcx>>(\n             tcx.sess.time(\"module_lints\", || {\n                 // Run per-module lints\n                 par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                    tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n+                    tcx.ensure().lint_mod(module);\n                 });\n             });\n         },"}, {"sha": "cc5b7ef098756b078f91f67107898febc796a363", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -41,7 +41,7 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> LintLevelMap {\n     let push = builder.levels.push(&krate.item.attrs, &store, true);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n     for macro_def in krate.exported_macros {\n-        builder.levels.register_id(macro_def.hir_id);\n+        builder.levels.register_id(macro_def.hir_id());\n     }\n     intravisit::walk_crate(&mut builder, krate);\n     builder.levels.pop(push);\n@@ -577,13 +577,13 @@ impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id(), &it.attrs, |builder| {\n             intravisit::walk_item(builder, it);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id(), &it.attrs, |builder| {\n             intravisit::walk_foreign_item(builder, it);\n         })\n     }\n@@ -631,13 +631,13 @@ impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |builder| {\n+        self.with_lint_attrs(trait_item.hir_id(), &trait_item.attrs, |builder| {\n             intravisit::walk_trait_item(builder, trait_item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |builder| {\n+        self.with_lint_attrs(impl_item.hir_id(), &impl_item.attrs, |builder| {\n             intravisit::walk_impl_item(builder, impl_item);\n         });\n     }"}, {"sha": "e632f29e672c08126edec6d1eb02b4a75d8d15f6", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -47,8 +47,7 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::PredicateKind::*;\n \n-        let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-        let predicates = cx.tcx.explicit_predicates_of(def_id);\n+        let predicates = cx.tcx.explicit_predicates_of(item.def_id);\n         for &(predicate, span) in predicates.predicates {\n             let trait_predicate = match predicate.kind().skip_binder() {\n                 Trait(trait_predicate, _constness) => trait_predicate,"}, {"sha": "4d70e33c607df7fee88f008abb20210bc6b5eb08", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -1262,15 +1262,15 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDeclarations {\n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, it: &hir::ForeignItem<'_>) {\n         let mut vis = ImproperCTypesVisitor { cx, mode: CItemKind::Declaration };\n-        let abi = cx.tcx.hir().get_foreign_abi(it.hir_id);\n+        let abi = cx.tcx.hir().get_foreign_abi(it.hir_id());\n \n         if !vis.is_internal_abi(abi) {\n             match it.kind {\n                 hir::ForeignItemKind::Fn(ref decl, _, _) => {\n-                    vis.check_foreign_fn(it.hir_id, decl);\n+                    vis.check_foreign_fn(it.hir_id(), decl);\n                 }\n                 hir::ForeignItemKind::Static(ref ty, _) => {\n-                    vis.check_foreign_static(it.hir_id, ty.span);\n+                    vis.check_foreign_static(it.hir_id(), ty.span);\n                 }\n                 hir::ForeignItemKind::Type => (),\n             }\n@@ -1308,8 +1308,7 @@ declare_lint_pass!(VariantSizeDifferences => [VARIANT_SIZE_DIFFERENCES]);\n impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.kind {\n-            let item_def_id = cx.tcx.hir().local_def_id(it.hir_id);\n-            let t = cx.tcx.type_of(item_def_id);\n+            let t = cx.tcx.type_of(it.def_id);\n             let ty = cx.tcx.erase_regions(t);\n             let layout = match cx.layout_of(ty) {\n                 Ok(layout) => layout,"}, {"sha": "3d3071c18f2497c367d337966ed625a0bf87c3a1", "filename": "compiler/rustc_metadata/src/foreign_modules.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -4,29 +4,24 @@ use rustc_middle::middle::cstore::ForeignModule;\n use rustc_middle::ty::TyCtxt;\n \n crate fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n-    let mut collector = Collector { tcx, modules: Vec::new() };\n+    let mut collector = Collector { modules: Vec::new() };\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n     collector.modules\n }\n \n-struct Collector<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct Collector {\n     modules: Vec<ForeignModule>,\n }\n \n-impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n+impl ItemLikeVisitor<'tcx> for Collector {\n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n         let items = match it.kind {\n             hir::ItemKind::ForeignMod { items, .. } => items,\n             _ => return,\n         };\n \n-        let foreign_items =\n-            items.iter().map(|it| self.tcx.hir().local_def_id(it.id.hir_id).to_def_id()).collect();\n-        self.modules.push(ForeignModule {\n-            foreign_items,\n-            def_id: self.tcx.hir().local_def_id(it.hir_id).to_def_id(),\n-        });\n+        let foreign_items = items.iter().map(|it| it.id.def_id.to_def_id()).collect();\n+        self.modules.push(ForeignModule { foreign_items, def_id: it.def_id.to_def_id() });\n     }\n \n     fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem<'tcx>) {}"}, {"sha": "4d63b6d074af0fc581a18332882d170d2c4ae45d", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -53,7 +53,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                 name: None,\n                 kind: NativeLibKind::Unspecified,\n                 cfg: None,\n-                foreign_module: Some(self.tcx.hir().local_def_id(it.hir_id).to_def_id()),\n+                foreign_module: Some(it.def_id.to_def_id()),\n                 wasm_import_module: None,\n             };\n             let mut kind_specified = false;"}, {"sha": "3314385dbf0a3499ae39111c65b1b1c68d34793c", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -7,7 +7,9 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{join, par_iter, Lrc, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{\n+    CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE,\n+};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -431,7 +433,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n-        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.item.module);\n+        self.encode_info_for_mod(CRATE_DEF_ID, &krate.item.module);\n \n         // Proc-macro crates only export proc-macro items, which are looked\n         // up using `proc_macro_data`\n@@ -932,9 +934,8 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_inferred_outlives(def_id);\n     }\n \n-    fn encode_info_for_mod(&mut self, id: hir::HirId, md: &hir::Mod<'_>) {\n+    fn encode_info_for_mod(&mut self, local_def_id: LocalDefId, md: &hir::Mod<'_>) {\n         let tcx = self.tcx;\n-        let local_def_id = tcx.hir().local_def_id(id);\n         let def_id = local_def_id.to_def_id();\n         debug!(\"EncodeContext::encode_info_for_mod({:?})\", def_id);\n \n@@ -969,7 +970,7 @@ impl EncodeContext<'a, 'tcx> {\n             record!(self.tables.children[def_id] <- &[]);\n         } else {\n             record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n-                tcx.hir().local_def_id(item_id.id).local_def_index\n+                item_id.def_id.local_def_index\n             }));\n         }\n     }\n@@ -1312,7 +1313,7 @@ impl EncodeContext<'a, 'tcx> {\n                 EntryKind::Fn(self.lazy(data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(item.hir_id, m);\n+                return self.encode_info_for_mod(item.def_id, m);\n             }\n             hir::ItemKind::ForeignMod { .. } => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n@@ -1410,8 +1411,7 @@ impl EncodeContext<'a, 'tcx> {\n             hir::ItemKind::ForeignMod { items, .. } => record!(self.tables.children[def_id] <-\n                 items\n                     .iter()\n-                    .map(|foreign_item| tcx.hir().local_def_id(\n-                        foreign_item.id.hir_id).local_def_index)\n+                    .map(|foreign_item| foreign_item.id.def_id.local_def_index)\n             ),\n             hir::ItemKind::Enum(..) => record!(self.tables.children[def_id] <-\n                 self.tcx.adt_def(def_id).variants.iter().map(|v| {\n@@ -1494,7 +1494,7 @@ impl EncodeContext<'a, 'tcx> {\n \n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef<'_>) {\n-        let def_id = self.tcx.hir().local_def_id(macro_def.hir_id).to_def_id();\n+        let def_id = macro_def.def_id.to_def_id();\n         record!(self.tables.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n         self.encode_ident_span(def_id, macro_def.ident);\n     }\n@@ -1850,17 +1850,15 @@ impl Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         intravisit::walk_item(self, item);\n-        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.kind {\n             hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {} // ignore these\n-            _ => self.encode_info_for_item(def_id.to_def_id(), item),\n+            _ => self.encode_info_for_item(item.def_id.to_def_id(), item),\n         }\n         self.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem<'tcx>) {\n         intravisit::walk_foreign_item(self, ni);\n-        let def_id = self.tcx.hir().local_def_id(ni.hir_id);\n-        self.encode_info_for_foreign_item(def_id.to_def_id(), ni);\n+        self.encode_info_for_foreign_item(ni.def_id.to_def_id(), ni);\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         intravisit::walk_generics(self, generics);\n@@ -1920,7 +1918,6 @@ impl EncodeContext<'a, 'tcx> {\n     /// so it's easier to do that here then to wait until we would encounter\n     /// normally in the visitor walk.\n     fn encode_addl_info_for_item(&mut self, item: &hir::Item<'_>) {\n-        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.kind {\n             hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n@@ -1936,7 +1933,7 @@ impl EncodeContext<'a, 'tcx> {\n                 // no sub-item recording needed in these cases\n             }\n             hir::ItemKind::Enum(..) => {\n-                let def = self.tcx.adt_def(def_id.to_def_id());\n+                let def = self.tcx.adt_def(item.def_id.to_def_id());\n                 self.encode_fields(def);\n \n                 for (i, variant) in def.variants.iter_enumerated() {\n@@ -1948,7 +1945,7 @@ impl EncodeContext<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Struct(ref struct_def, _) => {\n-                let def = self.tcx.adt_def(def_id.to_def_id());\n+                let def = self.tcx.adt_def(item.def_id.to_def_id());\n                 self.encode_fields(def);\n \n                 // If the struct has a constructor, encode it.\n@@ -1958,18 +1955,19 @@ impl EncodeContext<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Union(..) => {\n-                let def = self.tcx.adt_def(def_id.to_def_id());\n+                let def = self.tcx.adt_def(item.def_id.to_def_id());\n                 self.encode_fields(def);\n             }\n             hir::ItemKind::Impl { .. } => {\n                 for &trait_item_def_id in\n-                    self.tcx.associated_item_def_ids(def_id.to_def_id()).iter()\n+                    self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n                 {\n                     self.encode_info_for_impl_item(trait_item_def_id);\n                 }\n             }\n             hir::ItemKind::Trait(..) => {\n-                for &item_def_id in self.tcx.associated_item_def_ids(def_id.to_def_id()).iter() {\n+                for &item_def_id in self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n+                {\n                     self.encode_info_for_trait_item(item_def_id);\n                 }\n             }\n@@ -1985,15 +1983,14 @@ struct ImplVisitor<'tcx> {\n impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Impl { .. } = item.kind {\n-            let impl_id = self.tcx.hir().local_def_id(item.hir_id);\n-            if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id.to_def_id()) {\n+            if let Some(trait_ref) = self.tcx.impl_trait_ref(item.def_id.to_def_id()) {\n                 let simplified_self_ty =\n                     ty::fast_reject::simplify_type(self.tcx, trait_ref.self_ty(), false);\n \n                 self.impls\n                     .entry(trait_ref.def_id)\n                     .or_default()\n-                    .push((impl_id.local_def_index, simplified_self_ty));\n+                    .push((item.def_id.local_def_index, simplified_self_ty));\n             }\n         }\n     }"}, {"sha": "9222ce1015ebaea69126cafb47f825fce23ce66c", "filename": "compiler/rustc_middle/src/hir/map/blocks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -215,7 +215,7 @@ impl<'a> FnLikeNode<'a> {\n         match self.node {\n             Node::Item(i) => match i.kind {\n                 hir::ItemKind::Fn(ref sig, ref generics, block) => item_fn(ItemFnParts {\n-                    id: i.hir_id,\n+                    id: i.hir_id(),\n                     ident: i.ident,\n                     decl: &sig.decl,\n                     body: block,\n@@ -229,13 +229,13 @@ impl<'a> FnLikeNode<'a> {\n             },\n             Node::TraitItem(ti) => match ti.kind {\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                    method(ti.hir_id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n+                    method(ti.hir_id(), ti.ident, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             Node::ImplItem(ii) => match ii.kind {\n                 hir::ImplItemKind::Fn(ref sig, body) => {\n-                    method(ii.hir_id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n+                    method(ii.hir_id(), ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                 }\n                 _ => bug!(\"impl method FnLikeNode that is not fn-like\"),\n             },"}, {"sha": "a5ffa9c7a54b0529760daf2600e405ec6f634f15", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 24, "deletions": 57, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -55,22 +55,19 @@ fn insert_vec_map<K: Idx, V: Clone>(map: &mut IndexVec<K, Option<V>>, k: K, v: V\n     map[k] = Some(v);\n }\n \n-fn hash(\n-    hcx: &mut StableHashingContext<'_>,\n-    input: impl for<'a> HashStable<StableHashingContext<'a>>,\n-) -> Fingerprint {\n-    let mut stable_hasher = StableHasher::new();\n-    input.hash_stable(hcx, &mut stable_hasher);\n-    stable_hasher.finish()\n-}\n-\n fn hash_body(\n     hcx: &mut StableHashingContext<'_>,\n     def_path_hash: DefPathHash,\n     item_like: impl for<'a> HashStable<StableHashingContext<'a>>,\n     hir_body_nodes: &mut Vec<(DefPathHash, Fingerprint)>,\n ) -> Fingerprint {\n-    let hash = hash(hcx, HirItemLike { item_like: &item_like });\n+    let hash = {\n+        let mut stable_hasher = StableHasher::new();\n+        hcx.while_hashing_hir_bodies(true, |hcx| {\n+            item_like.hash_stable(hcx, &mut stable_hasher);\n+        });\n+        stable_hasher.finish()\n+    };\n     hir_body_nodes.push((def_path_hash, hash));\n     hash\n }\n@@ -309,7 +306,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        self.visit_item(self.krate.item(item.id));\n+        self.visit_item(self.krate.item(item));\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n@@ -338,13 +335,10 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n         debug!(\"visit_item: {:?}\", i);\n-        debug_assert_eq!(\n-            i.hir_id.owner,\n-            self.definitions.opt_hir_id_to_local_def_id(i.hir_id).unwrap()\n-        );\n-        self.with_dep_node_owner(i.hir_id.owner, i, |this, hash| {\n-            this.insert_with_hash(i.span, i.hir_id, Node::Item(i), hash);\n-            this.with_parent(i.hir_id, |this| {\n+        self.with_dep_node_owner(i.def_id, i, |this, hash| {\n+            let hir_id = i.hir_id();\n+            this.insert_with_hash(i.span, hir_id, Node::Item(i), hash);\n+            this.with_parent(hir_id, |this| {\n                 if let ItemKind::Struct(ref struct_def, _) = i.kind {\n                     // If this is a tuple or unit-like struct, register the constructor.\n                     if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n@@ -357,14 +351,10 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_foreign_item(&mut self, fi: &'hir ForeignItem<'hir>) {\n-        debug_assert_eq!(\n-            fi.hir_id.owner,\n-            self.definitions.opt_hir_id_to_local_def_id(fi.hir_id).unwrap()\n-        );\n-        self.with_dep_node_owner(fi.hir_id.owner, fi, |this, hash| {\n-            this.insert_with_hash(fi.span, fi.hir_id, Node::ForeignItem(fi), hash);\n+        self.with_dep_node_owner(fi.def_id, fi, |this, hash| {\n+            this.insert_with_hash(fi.span, fi.hir_id(), Node::ForeignItem(fi), hash);\n \n-            this.with_parent(fi.hir_id, |this| {\n+            this.with_parent(fi.hir_id(), |this| {\n                 intravisit::walk_foreign_item(this, fi);\n             });\n         });\n@@ -394,28 +384,20 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n-        debug_assert_eq!(\n-            ti.hir_id.owner,\n-            self.definitions.opt_hir_id_to_local_def_id(ti.hir_id).unwrap()\n-        );\n-        self.with_dep_node_owner(ti.hir_id.owner, ti, |this, hash| {\n-            this.insert_with_hash(ti.span, ti.hir_id, Node::TraitItem(ti), hash);\n+        self.with_dep_node_owner(ti.def_id, ti, |this, hash| {\n+            this.insert_with_hash(ti.span, ti.hir_id(), Node::TraitItem(ti), hash);\n \n-            this.with_parent(ti.hir_id, |this| {\n+            this.with_parent(ti.hir_id(), |this| {\n                 intravisit::walk_trait_item(this, ti);\n             });\n         });\n     }\n \n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n-        debug_assert_eq!(\n-            ii.hir_id.owner,\n-            self.definitions.opt_hir_id_to_local_def_id(ii.hir_id).unwrap()\n-        );\n-        self.with_dep_node_owner(ii.hir_id.owner, ii, |this, hash| {\n-            this.insert_with_hash(ii.span, ii.hir_id, Node::ImplItem(ii), hash);\n+        self.with_dep_node_owner(ii.def_id, ii, |this, hash| {\n+            this.insert_with_hash(ii.span, ii.hir_id(), Node::ImplItem(ii), hash);\n \n-            this.with_parent(ii.hir_id, |this| {\n+            this.with_parent(ii.hir_id(), |this| {\n                 intravisit::walk_impl_item(this, ii);\n             });\n         });\n@@ -532,15 +514,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         // Exported macros are visited directly from the crate root,\n         // so they do not have `parent_node` set.\n         // Find the correct enclosing module from their DefKey.\n-        let def_key = self.definitions.def_key(macro_def.hir_id.owner);\n+        let def_key = self.definitions.def_key(macro_def.def_id);\n         let parent = def_key.parent.map_or(hir::CRATE_HIR_ID, |local_def_index| {\n             self.definitions.local_def_id_to_hir_id(LocalDefId { local_def_index })\n         });\n         self.with_parent(parent, |this| {\n-            this.with_dep_node_owner(macro_def.hir_id.owner, macro_def, |this, hash| {\n+            this.with_dep_node_owner(macro_def.def_id, macro_def, |this, hash| {\n                 this.insert_with_hash(\n                     macro_def.span,\n-                    macro_def.hir_id,\n+                    macro_def.hir_id(),\n                     Node::MacroDef(macro_def),\n                     hash,\n                 );\n@@ -590,18 +572,3 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.visit_nested_foreign_item(id);\n     }\n }\n-\n-struct HirItemLike<T> {\n-    item_like: T,\n-}\n-\n-impl<'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n-where\n-    T: HashStable<StableHashingContext<'hir>>,\n-{\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'hir>, hasher: &mut StableHasher) {\n-        hcx.while_hashing_hir_bodies(true, |hcx| {\n-            self.item_like.hash_stable(hcx, hasher);\n-        });\n-    }\n-}"}, {"sha": "5c2bd575e7d55df117e388dc83fb7ff65bff86eb", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 13, "deletions": 54, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -300,29 +300,29 @@ impl<'hir> Map<'hir> {\n         self.find_entry(id).unwrap()\n     }\n \n-    pub fn item(&self, id: HirId) -> &'hir Item<'hir> {\n-        match self.find(id).unwrap() {\n+    pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n+        match self.find(id.hir_id()).unwrap() {\n             Node::Item(item) => item,\n             _ => bug!(),\n         }\n     }\n \n     pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n-        match self.find(id.hir_id).unwrap() {\n+        match self.find(id.hir_id()).unwrap() {\n             Node::TraitItem(item) => item,\n             _ => bug!(),\n         }\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n-        match self.find(id.hir_id).unwrap() {\n+        match self.find(id.hir_id()).unwrap() {\n             Node::ImplItem(item) => item,\n             _ => bug!(),\n         }\n     }\n \n     pub fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        match self.find(id.hir_id).unwrap() {\n+        match self.find(id.hir_id()).unwrap() {\n             Node::ForeignItem(item) => item,\n             _ => bug!(),\n         }\n@@ -449,7 +449,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn trait_impls(&self, trait_did: DefId) -> &'hir [HirId] {\n+    pub fn trait_impls(&self, trait_did: DefId) -> &'hir [LocalDefId] {\n         self.tcx.all_local_trait_impls(LOCAL_CRATE).get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n@@ -479,19 +479,19 @@ impl<'hir> Map<'hir> {\n         let module = self.tcx.hir_module_items(module);\n \n         for id in &module.items {\n-            visitor.visit_item(self.expect_item(*id));\n+            visitor.visit_item(self.item(*id));\n         }\n \n         for id in &module.trait_items {\n-            visitor.visit_trait_item(self.expect_trait_item(id.hir_id));\n+            visitor.visit_trait_item(self.trait_item(*id));\n         }\n \n         for id in &module.impl_items {\n-            visitor.visit_impl_item(self.expect_impl_item(id.hir_id));\n+            visitor.visit_impl_item(self.impl_item(*id));\n         }\n \n         for id in &module.foreign_items {\n-            visitor.visit_foreign_item(self.expect_foreign_item(id.hir_id));\n+            visitor.visit_foreign_item(self.foreign_item(*id));\n         }\n     }\n \n@@ -500,7 +500,7 @@ impl<'hir> Map<'hir> {\n         V: Visitor<'hir>,\n     {\n         for id in self.krate().exported_macros {\n-            visitor.visit_macro_def(self.expect_macro_def(id.hir_id));\n+            visitor.visit_macro_def(self.expect_macro_def(id.hir_id()));\n         }\n     }\n \n@@ -863,7 +863,7 @@ impl<'hir> Map<'hir> {\n             Node::Variant(ref v) => v.attrs,\n             Node::Field(ref f) => f.attrs,\n             Node::Expr(ref e) => &*e.attrs,\n-            Node::Stmt(ref s) => s.kind.attrs(|id| self.item(id.id)),\n+            Node::Stmt(ref s) => s.kind.attrs(|id| self.item(id)),\n             Node::Arm(ref a) => &*a.attrs,\n             Node::GenericParam(param) => param.attrs,\n             // Unit/tuple structs/variants take the attributes straight from\n@@ -977,7 +977,7 @@ impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n         self.body(id)\n     }\n \n-    fn item(&self, id: HirId) -> &'hir Item<'hir> {\n+    fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n         self.item(id)\n     }\n \n@@ -994,47 +994,6 @@ impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n     }\n }\n \n-trait Named {\n-    fn name(&self) -> Symbol;\n-}\n-\n-impl<T: Named> Named for Spanned<T> {\n-    fn name(&self) -> Symbol {\n-        self.node.name()\n-    }\n-}\n-\n-impl Named for Item<'_> {\n-    fn name(&self) -> Symbol {\n-        self.ident.name\n-    }\n-}\n-impl Named for ForeignItem<'_> {\n-    fn name(&self) -> Symbol {\n-        self.ident.name\n-    }\n-}\n-impl Named for Variant<'_> {\n-    fn name(&self) -> Symbol {\n-        self.ident.name\n-    }\n-}\n-impl Named for StructField<'_> {\n-    fn name(&self) -> Symbol {\n-        self.ident.name\n-    }\n-}\n-impl Named for TraitItem<'_> {\n-    fn name(&self) -> Symbol {\n-        self.ident.name\n-    }\n-}\n-impl Named for ImplItem<'_> {\n-    fn name(&self) -> Symbol {\n-        self.ident.name\n-    }\n-}\n-\n pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> &'tcx IndexedHir<'tcx> {\n     assert_eq!(cnum, LOCAL_CRATE);\n "}, {"sha": "5f9cf8771eadab2a6ffc8befbecec0815d728d12", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -73,11 +73,7 @@ pub fn provide(providers: &mut Providers) {\n     };\n     providers.hir_crate = |tcx, _| tcx.untracked_crate;\n     providers.index_hir = map::index_hir;\n-    providers.hir_module_items = |tcx, id| {\n-        let hir = tcx.hir();\n-        let module = hir.local_def_id_to_hir_id(id);\n-        &tcx.untracked_crate.modules[&module]\n-    };\n+    providers.hir_module_items = |tcx, id| &tcx.untracked_crate.modules[&id];\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;\n     providers.hir_owner_nodes = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_deref();\n     providers.def_span = |tcx, def_id| tcx.hir().span_if_local(def_id).unwrap_or(DUMMY_SP);"}, {"sha": "5ef70a89051eaf1764ecfef051b12e5abced0c66", "filename": "compiler/rustc_middle/src/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -55,8 +55,7 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n         let item_ids_hash = item_ids\n             .iter()\n             .map(|id| {\n-                let (def_path_hash, local_id) = id.id.to_stable_hash_key(hcx);\n-                debug_assert_eq!(local_id, hir::ItemLocalId::from_u32(0));\n+                let def_path_hash = id.to_stable_hash_key(hcx);\n                 def_path_hash.0\n             })\n             .fold(Fingerprint::ZERO, |a, b| a.combine_commutative(b));"}, {"sha": "6c2468b9ffe0b1c937d2a1fc53d5fb331d35668d", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::HirId;\n+use rustc_hir::{HirId, ItemId};\n use rustc_session::config::OptLevel;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n@@ -43,7 +43,7 @@ pub enum InstantiationMode {\n pub enum MonoItem<'tcx> {\n     Fn(Instance<'tcx>),\n     Static(DefId),\n-    GlobalAsm(HirId),\n+    GlobalAsm(ItemId),\n }\n \n impl<'tcx> MonoItem<'tcx> {\n@@ -71,9 +71,8 @@ impl<'tcx> MonoItem<'tcx> {\n         match *self {\n             MonoItem::Fn(instance) => tcx.symbol_name(instance),\n             MonoItem::Static(def_id) => tcx.symbol_name(Instance::mono(tcx, def_id)),\n-            MonoItem::GlobalAsm(hir_id) => {\n-                let def_id = tcx.hir().local_def_id(hir_id);\n-                SymbolName::new(tcx, &format!(\"global_asm_{:?}\", def_id))\n+            MonoItem::GlobalAsm(item_id) => {\n+                SymbolName::new(tcx, &format!(\"global_asm_{:?}\", item_id.def_id))\n             }\n         }\n     }\n@@ -178,7 +177,7 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::Static(def_id) => {\n                 def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n             }\n-            MonoItem::GlobalAsm(hir_id) => Some(hir_id),\n+            MonoItem::GlobalAsm(item_id) => Some(item_id.hir_id()),\n         }\n         .map(|hir_id| tcx.hir().span(hir_id))\n     }\n@@ -195,9 +194,9 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {\n             MonoItem::Static(def_id) => {\n                 def_id.hash_stable(hcx, hasher);\n             }\n-            MonoItem::GlobalAsm(node_id) => {\n+            MonoItem::GlobalAsm(item_id) => {\n                 hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                    node_id.hash_stable(hcx, hasher);\n+                    item_id.hash_stable(hcx, hasher);\n                 })\n             }\n         }\n@@ -351,7 +350,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n                     MonoItem::Static(def_id) => {\n                         def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n                     }\n-                    MonoItem::GlobalAsm(hir_id) => Some(hir_id),\n+                    MonoItem::GlobalAsm(item_id) => Some(item_id.hir_id()),\n                 },\n                 item.symbol_name(tcx),\n             )"}, {"sha": "475f47c65bd2582e20dcabe36279e4ee8a963369", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -956,7 +956,7 @@ rustc_queries! {\n     /// Passing in any other crate will cause an ICE.\n     ///\n     /// [`LOCAL_CRATE`]: rustc_hir::def_id::LOCAL_CRATE\n-    query all_local_trait_impls(local_crate: CrateNum) -> &'tcx BTreeMap<DefId, Vec<hir::HirId>> {\n+    query all_local_trait_impls(local_crate: CrateNum) -> &'tcx BTreeMap<DefId, Vec<LocalDefId>> {\n         desc { \"local trait impls\" }\n     }\n "}, {"sha": "3b7dc25b6cf50ccfb13189e4abca68eeec2a61e3", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -289,7 +289,7 @@ impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor<'v> {\n             }\n             hir::TyKind::OpaqueDef(item_id, _) => {\n                 self.0.push(ty);\n-                let item = self.1.expect_item(item_id.id);\n+                let item = self.1.item(item_id);\n                 hir::intravisit::walk_item(self, item);\n             }\n             _ => {}"}, {"sha": "a6db2e3aa2886c6d02bbfe9c36711a2d33eccff4", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -821,7 +821,7 @@ fn foo(&self) -> Self::T { String::new() }\n                             // an assoc type as a return type (#72076).\n                             if let hir::Defaultness::Default { has_value: true } = item.defaultness\n                             {\n-                                if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n+                                if self.type_of(item.id.def_id) == found {\n                                     db.span_label(\n                                         item.span,\n                                         \"associated type defaults can't be assumed inside the \\\n@@ -841,7 +841,7 @@ fn foo(&self) -> Self::T { String::new() }\n             })) => {\n                 for item in &items[..] {\n                     if let hir::AssocItemKind::Type = item.kind {\n-                        if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n+                        if self.type_of(item.id.def_id) == found {\n                             db.span_label(item.span, \"expected this associated type\");\n                             return true;\n                         }"}, {"sha": "286041a7c548bc20670fcc72292deb0f93c819ce", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -2107,11 +2107,9 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n             continue;\n         }\n \n-        if let Some(local_def_id) = hir.definitions().opt_hir_id_to_local_def_id(item.hir_id) {\n-            let def_id = local_def_id.to_def_id();\n-            let ns = tcx.def_kind(def_id).ns().unwrap_or(Namespace::TypeNS);\n-            collect_fn(&item.ident, ns, def_id);\n-        }\n+        let def_id = item.def_id.to_def_id();\n+        let ns = tcx.def_kind(def_id).ns().unwrap_or(Namespace::TypeNS);\n+        collect_fn(&item.ident, ns, def_id);\n     }\n \n     // Now take care of extern crate items."}, {"sha": "ce17a724e25d3ba2dd0f5cc71bf8f6eeb096f138", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -4,9 +4,8 @@ use crate::ty::fast_reject;\n use crate::ty::fold::TypeFoldable;\n use crate::ty::{Ty, TyCtxt};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_hir::definitions::DefPathHash;\n-use rustc_hir::HirId;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -201,7 +200,7 @@ impl<'tcx> TyCtxt<'tcx> {\n pub(super) fn all_local_trait_impls<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     krate: CrateNum,\n-) -> &'tcx BTreeMap<DefId, Vec<HirId>> {\n+) -> &'tcx BTreeMap<DefId, Vec<LocalDefId>> {\n     &tcx.hir_crate(krate).trait_impls\n }\n \n@@ -229,8 +228,8 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n         }\n     }\n \n-    for &hir_id in tcx.hir().trait_impls(trait_id) {\n-        let impl_def_id = tcx.hir().local_def_id(hir_id).to_def_id();\n+    for &impl_def_id in tcx.hir().trait_impls(trait_id) {\n+        let impl_def_id = impl_def_id.to_def_id();\n \n         let impl_self_ty = tcx.type_of(impl_def_id);\n         if impl_self_ty.references_error() {"}, {"sha": "63a3e269d6157019d267da3ad354330251acbeda", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -767,7 +767,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         let hir = self.infcx.tcx.hir();\n \n         if let hir::TyKind::OpaqueDef(id, _) = hir_ty.kind {\n-            let opaque_ty = hir.item(id.id);\n+            let opaque_ty = hir.item(id);\n             if let hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                 bounds:\n                     [hir::GenericBound::LangItemTrait("}, {"sha": "20cb989196a983ed75d3da85a20845afbf9e6c98", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -1013,13 +1013,12 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n             | hir::ItemKind::Union(_, ref generics) => {\n                 if generics.params.is_empty() {\n                     if self.mode == MonoItemCollectionMode::Eager {\n-                        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                         debug!(\n                             \"RootCollector: ADT drop-glue for {}\",\n-                            self.tcx.def_path_str(def_id.to_def_id())\n+                            self.tcx.def_path_str(item.def_id.to_def_id())\n                         );\n \n-                        let ty = Instance::new(def_id.to_def_id(), InternalSubsts::empty())\n+                        let ty = Instance::new(item.def_id.to_def_id(), InternalSubsts::empty())\n                             .ty(self.tcx, ty::ParamEnv::reveal_all());\n                         visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n                     }\n@@ -1028,29 +1027,28 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n             hir::ItemKind::GlobalAsm(..) => {\n                 debug!(\n                     \"RootCollector: ItemKind::GlobalAsm({})\",\n-                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.hir_id).to_def_id())\n+                    self.tcx.def_path_str(item.def_id.to_def_id())\n                 );\n-                self.output.push(dummy_spanned(MonoItem::GlobalAsm(item.hir_id)));\n+                self.output.push(dummy_spanned(MonoItem::GlobalAsm(item.item_id())));\n             }\n             hir::ItemKind::Static(..) => {\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id).to_def_id();\n-                debug!(\"RootCollector: ItemKind::Static({})\", self.tcx.def_path_str(def_id));\n-                self.output.push(dummy_spanned(MonoItem::Static(def_id)));\n+                debug!(\n+                    \"RootCollector: ItemKind::Static({})\",\n+                    self.tcx.def_path_str(item.def_id.to_def_id())\n+                );\n+                self.output.push(dummy_spanned(MonoItem::Static(item.def_id.to_def_id())));\n             }\n             hir::ItemKind::Const(..) => {\n                 // const items only generate mono items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n \n                 // but even just declaring them must collect the items they refer to\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-\n-                if let Ok(val) = self.tcx.const_eval_poly(def_id.to_def_id()) {\n+                if let Ok(val) = self.tcx.const_eval_poly(item.def_id.to_def_id()) {\n                     collect_const_value(self.tcx, val, &mut self.output);\n                 }\n             }\n             hir::ItemKind::Fn(..) => {\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                self.push_if_root(def_id);\n+                self.push_if_root(item.def_id);\n             }\n         }\n     }\n@@ -1062,8 +1060,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem<'v>) {\n         if let hir::ImplItemKind::Fn(hir::FnSig { .. }, _) = ii.kind {\n-            let def_id = self.tcx.hir().local_def_id(ii.hir_id);\n-            self.push_if_root(def_id);\n+            self.push_if_root(ii.def_id);\n         }\n     }\n \n@@ -1156,14 +1153,12 @@ fn create_mono_items_for_default_impls<'tcx>(\n                 }\n             }\n \n-            let impl_def_id = tcx.hir().local_def_id(item.hir_id);\n-\n             debug!(\n                 \"create_mono_items_for_default_impls(item={})\",\n-                tcx.def_path_str(impl_def_id.to_def_id())\n+                tcx.def_path_str(item.def_id.to_def_id())\n             );\n \n-            if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n+            if let Some(trait_ref) = tcx.impl_trait_ref(item.def_id) {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n                 let overridden_methods: FxHashSet<_> ="}, {"sha": "edd46310f20d4f3fc28f5feecdce99ba1cdbf603", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/default.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -314,7 +314,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n             Some(def_id)\n         }\n         MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(hir_id) => Some(tcx.hir().local_def_id(hir_id).to_def_id()),\n+        MonoItem::GlobalAsm(item_id) => Some(item_id.def_id.to_def_id()),\n     }\n }\n \n@@ -405,11 +405,10 @@ fn mono_item_visibility(\n                 Visibility::Hidden\n             };\n         }\n-        MonoItem::GlobalAsm(hir_id) => {\n-            let def_id = tcx.hir().local_def_id(*hir_id);\n-            return if tcx.is_reachable_non_generic(def_id) {\n+        MonoItem::GlobalAsm(item_id) => {\n+            return if tcx.is_reachable_non_generic(item_id.def_id) {\n                 *can_be_internalized = false;\n-                default_visibility(tcx, def_id.to_def_id(), false)\n+                default_visibility(tcx, item_id.def_id.to_def_id(), false)\n             } else {\n                 Visibility::Hidden\n             };"}, {"sha": "bf9b7e588bd4b471feec430408cb1fefb31da572", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -29,7 +29,7 @@ pub(crate) fn target_from_impl_item<'tcx>(\n     match impl_item.kind {\n         hir::ImplItemKind::Const(..) => Target::AssocConst,\n         hir::ImplItemKind::Fn(..) => {\n-            let parent_hir_id = tcx.hir().get_parent_item(impl_item.hir_id);\n+            let parent_hir_id = tcx.hir().get_parent_item(impl_item.hir_id());\n             let containing_item = tcx.hir().expect_item(parent_hir_id);\n             let containing_impl_is_for_trait = match &containing_item.kind {\n                 hir::ItemKind::Impl(impl_) => impl_.of_trait.is_some(),\n@@ -1058,7 +1058,7 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n         let target = Target::from_item(item);\n         self.check_attributes(\n-            item.hir_id,\n+            item.hir_id(),\n             item.attrs,\n             &item.span,\n             target,\n@@ -1081,7 +1081,13 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx TraitItem<'tcx>) {\n         let target = Target::from_trait_item(trait_item);\n-        self.check_attributes(trait_item.hir_id, &trait_item.attrs, &trait_item.span, target, None);\n+        self.check_attributes(\n+            trait_item.hir_id(),\n+            &trait_item.attrs,\n+            &trait_item.span,\n+            target,\n+            None,\n+        );\n         intravisit::walk_trait_item(self, trait_item)\n     }\n \n@@ -1104,7 +1110,7 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n     fn visit_foreign_item(&mut self, f_item: &'tcx ForeignItem<'tcx>) {\n         let target = Target::from_foreign_item(f_item);\n         self.check_attributes(\n-            f_item.hir_id,\n+            f_item.hir_id(),\n             &f_item.attrs,\n             &f_item.span,\n             target,\n@@ -1115,7 +1121,7 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         let target = target_from_impl_item(self.tcx, impl_item);\n-        self.check_attributes(impl_item.hir_id, &impl_item.attrs, &impl_item.span, target, None);\n+        self.check_attributes(impl_item.hir_id(), &impl_item.attrs, &impl_item.span, target, None);\n         intravisit::walk_impl_item(self, impl_item)\n     }\n \n@@ -1149,7 +1155,7 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n \n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef<'tcx>) {\n         self.check_attributes(\n-            macro_def.hir_id,\n+            macro_def.hir_id(),\n             macro_def.attrs,\n             &macro_def.span,\n             Target::MacroDef,"}, {"sha": "d51b501f7ae3da9d4828444ceed8088a1a827c21", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -188,8 +188,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n         match node {\n             Node::Item(item) => match item.kind {\n                 hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                    let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                    let def = self.tcx.adt_def(def_id);\n+                    let def = self.tcx.adt_def(item.def_id);\n                     self.repr_has_repr_c = def.repr.c();\n \n                     intravisit::walk_item(self, &item);\n@@ -329,7 +328,7 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         if let TyKind::OpaqueDef(item_id, _) = ty.kind {\n-            let item = self.tcx.hir().expect_item(item_id.id);\n+            let item = self.tcx.hir().item(item_id);\n             intravisit::walk_item(self, item);\n         }\n         intravisit::walk_ty(self, ty);\n@@ -395,9 +394,10 @@ struct LifeSeeder<'k, 'tcx> {\n \n impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let allow_dead_code = has_allow_dead_code_or_lang_attr(self.tcx, item.hir_id, &item.attrs);\n+        let allow_dead_code =\n+            has_allow_dead_code_or_lang_attr(self.tcx, item.hir_id(), &item.attrs);\n         if allow_dead_code {\n-            self.worklist.push(item.hir_id);\n+            self.worklist.push(item.hir_id());\n         }\n         match item.kind {\n             hir::ItemKind::Enum(ref enum_def, _) => {\n@@ -413,24 +413,24 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n             }\n             hir::ItemKind::Impl(hir::Impl { ref of_trait, items, .. }) => {\n                 if of_trait.is_some() {\n-                    self.worklist.push(item.hir_id);\n+                    self.worklist.push(item.hir_id());\n                 }\n                 for impl_item_ref in items {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if of_trait.is_some()\n                         || has_allow_dead_code_or_lang_attr(\n                             self.tcx,\n-                            impl_item.hir_id,\n+                            impl_item.hir_id(),\n                             &impl_item.attrs,\n                         )\n                     {\n-                        self.worklist.push(impl_item_ref.id.hir_id);\n+                        self.worklist.push(impl_item_ref.id.hir_id());\n                     }\n                 }\n             }\n             hir::ItemKind::Struct(ref variant_data, _) => {\n                 if let Some(ctor_hir_id) = variant_data.ctor_hir_id() {\n-                    self.struct_constructors.insert(ctor_hir_id, item.hir_id);\n+                    self.struct_constructors.insert(ctor_hir_id, item.hir_id());\n                 }\n             }\n             _ => (),\n@@ -440,9 +440,9 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n         use hir::TraitItemKind::{Const, Fn};\n         if matches!(trait_item.kind, Const(_, Some(_)) | Fn(_, hir::TraitFn::Provided(_)))\n-            && has_allow_dead_code_or_lang_attr(self.tcx, trait_item.hir_id, &trait_item.attrs)\n+            && has_allow_dead_code_or_lang_attr(self.tcx, trait_item.hir_id(), &trait_item.attrs)\n         {\n-            self.worklist.push(trait_item.hir_id);\n+            self.worklist.push(trait_item.hir_id());\n         }\n     }\n \n@@ -453,9 +453,13 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem<'_>) {\n         use hir::ForeignItemKind::{Fn, Static};\n         if matches!(foreign_item.kind, Static(..) | Fn(..))\n-            && has_allow_dead_code_or_lang_attr(self.tcx, foreign_item.hir_id, &foreign_item.attrs)\n+            && has_allow_dead_code_or_lang_attr(\n+                self.tcx,\n+                foreign_item.hir_id(),\n+                &foreign_item.attrs,\n+            )\n         {\n-            self.worklist.push(foreign_item.hir_id);\n+            self.worklist.push(foreign_item.hir_id());\n         }\n     }\n }\n@@ -525,7 +529,7 @@ impl DeadVisitor<'tcx> {\n                 | hir::ItemKind::Struct(..)\n                 | hir::ItemKind::Union(..)\n         );\n-        should_warn && !self.symbol_is_live(item.hir_id)\n+        should_warn && !self.symbol_is_live(item.hir_id())\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField<'_>) -> bool {\n@@ -542,8 +546,8 @@ impl DeadVisitor<'tcx> {\n     }\n \n     fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem<'_>) -> bool {\n-        !self.symbol_is_live(fi.hir_id)\n-            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.hir_id, &fi.attrs)\n+        !self.symbol_is_live(fi.hir_id())\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.hir_id(), &fi.attrs)\n     }\n \n     // id := HIR id of an item's definition.\n@@ -627,7 +631,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 hir::ItemKind::Struct(..) => \"constructed\", // Issue #52325\n                 _ => \"used\",\n             };\n-            self.warn_dead_code(item.hir_id, span, item.ident.name, participle);\n+            self.warn_dead_code(item.hir_id(), span, item.ident.name, participle);\n         } else {\n             // Only continue if we didn't warn\n             intravisit::walk_item(self, item);\n@@ -649,7 +653,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n \n     fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem<'tcx>) {\n         if self.should_warn_about_foreign_item(fi) {\n-            self.warn_dead_code(fi.hir_id, fi.span, fi.ident.name, \"used\");\n+            self.warn_dead_code(fi.hir_id(), fi.span, fi.ident.name, \"used\");\n         }\n         intravisit::walk_foreign_item(self, fi);\n     }\n@@ -664,9 +668,9 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         match impl_item.kind {\n             hir::ImplItemKind::Const(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.hir_id) {\n+                if !self.symbol_is_live(impl_item.hir_id()) {\n                     self.warn_dead_code(\n-                        impl_item.hir_id,\n+                        impl_item.hir_id(),\n                         impl_item.span,\n                         impl_item.ident.name,\n                         \"used\",\n@@ -675,7 +679,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Fn(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.hir_id) {\n+                if !self.symbol_is_live(impl_item.hir_id()) {\n                     // FIXME(66095): Because impl_item.span is annotated with things\n                     // like expansion data, and ident.span isn't, we use the\n                     // def_span method if it's part of a macro invocation\n@@ -687,7 +691,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                     } else {\n                         impl_item.ident.span\n                     };\n-                    self.warn_dead_code(impl_item.hir_id, span, impl_item.ident.name, \"used\");\n+                    self.warn_dead_code(impl_item.hir_id(), span, impl_item.ident.name, \"used\");\n                 }\n                 self.visit_nested_body(body_id)\n             }"}, {"sha": "3ec7ea39248bfc57b33955d9afb16fcc76299115", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -16,7 +16,7 @@ use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n-use rustc_span::def_id::{DefId, LOCAL_CRATE};\n+use rustc_span::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_span::symbol::{sym, Symbol};\n \n struct DiagnosticItemCollector<'tcx> {\n@@ -27,19 +27,19 @@ struct DiagnosticItemCollector<'tcx> {\n \n impl<'v, 'tcx> ItemLikeVisitor<'v> for DiagnosticItemCollector<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        self.observe_item(&item.attrs, item.hir_id);\n+        self.observe_item(&item.attrs, item.def_id);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n-        self.observe_item(&trait_item.attrs, trait_item.hir_id);\n+        self.observe_item(&trait_item.attrs, trait_item.def_id);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n-        self.observe_item(&impl_item.attrs, impl_item.hir_id);\n+        self.observe_item(&impl_item.attrs, impl_item.def_id);\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem<'_>) {\n-        self.observe_item(foreign_item.attrs, foreign_item.hir_id);\n+        self.observe_item(foreign_item.attrs, foreign_item.def_id);\n     }\n }\n \n@@ -48,9 +48,8 @@ impl<'tcx> DiagnosticItemCollector<'tcx> {\n         DiagnosticItemCollector { tcx, items: Default::default() }\n     }\n \n-    fn observe_item(&mut self, attrs: &[ast::Attribute], hir_id: hir::HirId) {\n+    fn observe_item(&mut self, attrs: &[ast::Attribute], def_id: LocalDefId) {\n         if let Some(name) = extract(&self.tcx.sess, attrs) {\n-            let def_id = self.tcx.hir().local_def_id(hir_id);\n             // insert into our table\n             collect_item(self.tcx, &mut self.items, name, def_id.to_def_id());\n         }\n@@ -106,7 +105,7 @@ fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> FxHashMap<Symbol, DefId> {\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n     for m in tcx.hir().krate().exported_macros {\n-        collector.observe_item(m.attrs, m.hir_id);\n+        collector.observe_item(m.attrs, m.def_id);\n     }\n \n     collector.items"}, {"sha": "0d3a7ea3a8a00cbe3ee33bcb69b01a5f6c5cacdd", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -32,8 +32,7 @@ struct EntryContext<'a, 'tcx> {\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n-        let def_id = self.map.local_def_id(item.hir_id);\n-        let def_key = self.map.def_key(def_id);\n+        let def_key = self.map.def_key(item.def_id);\n         let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n         find_item(item, self, at_root);\n     }\n@@ -116,18 +115,18 @@ fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n         }\n         EntryPointType::MainNamed => {\n             if ctxt.main_fn.is_none() {\n-                ctxt.main_fn = Some((item.hir_id, item.span));\n+                ctxt.main_fn = Some((item.hir_id(), item.span));\n             } else {\n                 struct_span_err!(ctxt.session, item.span, E0136, \"multiple `main` functions\")\n                     .emit();\n             }\n         }\n         EntryPointType::OtherMain => {\n-            ctxt.non_main_fns.push((item.hir_id, item.span));\n+            ctxt.non_main_fns.push((item.hir_id(), item.span));\n         }\n         EntryPointType::MainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n-                ctxt.attr_main_fn = Some((item.hir_id, item.span));\n+                ctxt.attr_main_fn = Some((item.hir_id(), item.span));\n             } else {\n                 struct_span_err!(\n                     ctxt.session,\n@@ -142,7 +141,7 @@ fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n         }\n         EntryPointType::Start => {\n             if ctxt.start_fn.is_none() {\n-                ctxt.start_fn = Some((item.hir_id, item.span));\n+                ctxt.start_fn = Some((item.hir_id(), item.span));\n             } else {\n                 struct_span_err!(ctxt.session, item.span, E0138, \"multiple `start` functions\")\n                     .span_label(ctxt.start_fn.unwrap().1, \"previous `#[start]` function here\")"}, {"sha": "79e3b5952acaf22aa28f438d2cc52403fb63b851", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -14,12 +14,9 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n     let errors = Lock::new(Vec::new());\n     let hir_map = tcx.hir();\n \n-    par_iter(&hir_map.krate().modules).for_each(|(module_id, _)| {\n-        let local_def_id = hir_map.local_def_id(*module_id);\n-        hir_map.visit_item_likes_in_module(\n-            local_def_id,\n-            &mut OuterVisitor { hir_map, errors: &errors },\n-        );\n+    par_iter(&hir_map.krate().modules).for_each(|(&module_id, _)| {\n+        hir_map\n+            .visit_item_likes_in_module(module_id, &mut OuterVisitor { hir_map, errors: &errors });\n     });\n \n     let errors = errors.into_inner();\n@@ -56,22 +53,22 @@ impl<'a, 'hir> OuterVisitor<'a, 'hir> {\n impl<'a, 'hir> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n     fn visit_item(&mut self, i: &'hir hir::Item<'hir>) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.hir_id, |this| intravisit::walk_item(this, i));\n+        inner_visitor.check(i.hir_id(), |this| intravisit::walk_item(this, i));\n     }\n \n     fn visit_trait_item(&mut self, i: &'hir hir::TraitItem<'hir>) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.hir_id, |this| intravisit::walk_trait_item(this, i));\n+        inner_visitor.check(i.hir_id(), |this| intravisit::walk_trait_item(this, i));\n     }\n \n     fn visit_impl_item(&mut self, i: &'hir hir::ImplItem<'hir>) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.hir_id, |this| intravisit::walk_impl_item(this, i));\n+        inner_visitor.check(i.hir_id(), |this| intravisit::walk_impl_item(this, i));\n     }\n \n     fn visit_foreign_item(&mut self, i: &'hir hir::ForeignItem<'hir>) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.hir_id, |this| intravisit::walk_foreign_item(this, i));\n+        inner_visitor.check(i.hir_id(), |this| intravisit::walk_foreign_item(this, i));\n     }\n }\n "}, {"sha": "e35ad10968d33a198fd1e696b3839bdd9a2db06f", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -100,7 +100,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_nested_item(&mut self, id: hir::ItemId) {\n-        let nested_item = self.krate.unwrap().item(id.id);\n+        let nested_item = self.krate.unwrap().item(id);\n         self.visit_item(nested_item)\n     }\n \n@@ -120,7 +120,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_item(&mut self, i: &'v hir::Item<'v>) {\n-        self.record(\"Item\", Id::Node(i.hir_id), i);\n+        self.record(\"Item\", Id::Node(i.hir_id()), i);\n         hir_visit::walk_item(self, i)\n     }\n \n@@ -130,7 +130,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &'v hir::ForeignItem<'v>) {\n-        self.record(\"ForeignItem\", Id::Node(i.hir_id), i);\n+        self.record(\"ForeignItem\", Id::Node(i.hir_id()), i);\n         hir_visit::walk_foreign_item(self, i)\n     }\n \n@@ -187,12 +187,12 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'v hir::TraitItem<'v>) {\n-        self.record(\"TraitItem\", Id::Node(ti.hir_id), ti);\n+        self.record(\"TraitItem\", Id::Node(ti.hir_id()), ti);\n         hir_visit::walk_trait_item(self, ti)\n     }\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem<'v>) {\n-        self.record(\"ImplItem\", Id::Node(ii.hir_id), ii);\n+        self.record(\"ImplItem\", Id::Node(ii.hir_id()), ii);\n         hir_visit::walk_impl_item(self, ii)\n     }\n \n@@ -246,7 +246,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'v hir::MacroDef<'v>) {\n-        self.record(\"MacroDef\", Id::Node(macro_def.hir_id), macro_def);\n+        self.record(\"MacroDef\", Id::Node(macro_def.hir_id()), macro_def);\n         hir_visit::walk_macro_def(self, macro_def)\n     }\n }"}, {"sha": "8e2ad7f783e9bc8fc11c5911e58e4bb270d27407", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -30,7 +30,7 @@ struct LanguageItemCollector<'tcx> {\n \n impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        self.check_for_lang(Target::from_item(item), item.hir_id, item.attrs);\n+        self.check_for_lang(Target::from_item(item), item.hir_id(), item.attrs);\n \n         if let hir::ItemKind::Enum(def, ..) = &item.kind {\n             for variant in def.variants {\n@@ -42,15 +42,15 @@ impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n         self.check_for_lang(\n             Target::from_trait_item(trait_item),\n-            trait_item.hir_id,\n+            trait_item.hir_id(),\n             trait_item.attrs,\n         )\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n         self.check_for_lang(\n             target_from_impl_item(self.tcx, impl_item),\n-            impl_item.hir_id,\n+            impl_item.hir_id(),\n             impl_item.attrs,\n         )\n     }"}, {"sha": "18c1d647060b11385b25a5264d96ef6456e83263", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -21,16 +21,14 @@ struct LayoutTest<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n-\n         match item.kind {\n             ItemKind::TyAlias(..)\n             | ItemKind::Enum(..)\n             | ItemKind::Struct(..)\n             | ItemKind::Union(..) => {\n-                for attr in self.tcx.get_attrs(item_def_id.to_def_id()).iter() {\n+                for attr in self.tcx.get_attrs(item.def_id.to_def_id()).iter() {\n                     if self.tcx.sess.check_name(attr, sym::rustc_layout) {\n-                        self.dump_layout_of(item_def_id, item, attr);\n+                        self.dump_layout_of(item.def_id, item, attr);\n                     }\n                 }\n             }"}, {"sha": "20aaaea5b9809703bd01870bb71756467962e0d5", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -31,7 +31,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>, attrs: &Codege\n     match item.kind {\n         hir::ItemKind::Fn(ref sig, ..) if sig.header.is_const() => true,\n         hir::ItemKind::Impl { .. } | hir::ItemKind::Fn(..) => {\n-            let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n+            let generics = tcx.generics_of(item.def_id);\n             generics.requires_monomorphization(tcx)\n         }\n         _ => false,\n@@ -43,8 +43,8 @@ fn method_might_be_inlined(\n     impl_item: &hir::ImplItem<'_>,\n     impl_src: LocalDefId,\n ) -> bool {\n-    let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner.to_def_id());\n-    let generics = tcx.generics_of(tcx.hir().local_def_id(impl_item.hir_id));\n+    let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id().owner.to_def_id());\n+    let generics = tcx.generics_of(impl_item.def_id);\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true;\n     }\n@@ -218,8 +218,7 @@ impl<'tcx> ReachableContext<'tcx> {\n                 } else {\n                     false\n                 };\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n+                let codegen_attrs = self.tcx.codegen_fn_attrs(item.def_id);\n                 let is_extern = codegen_attrs.contains_extern_indicator();\n                 let std_internal =\n                     codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL);\n@@ -239,9 +238,11 @@ impl<'tcx> ReachableContext<'tcx> {\n             Node::Item(item) => {\n                 match item.kind {\n                     hir::ItemKind::Fn(.., body) => {\n-                        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                        if item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id))\n-                        {\n+                        if item_might_be_inlined(\n+                            self.tcx,\n+                            &item,\n+                            self.tcx.codegen_fn_attrs(item.def_id),\n+                        ) {\n                             self.visit_nested_body(body);\n                         }\n                     }\n@@ -341,23 +342,21 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n         // Anything which has custom linkage gets thrown on the worklist no\n         // matter where it is in the crate, along with \"special std symbols\"\n         // which are currently akin to allocator symbols.\n-        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-        let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n+        let codegen_attrs = self.tcx.codegen_fn_attrs(item.def_id);\n         if codegen_attrs.contains_extern_indicator()\n             || codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n         {\n-            self.worklist.push(def_id);\n+            self.worklist.push(item.def_id);\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n         if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n             item.kind\n         {\n-            if !self.access_levels.is_reachable(item.hir_id) {\n+            if !self.access_levels.is_reachable(item.hir_id()) {\n                 // FIXME(#53488) remove `let`\n                 let tcx = self.tcx;\n-                self.worklist\n-                    .extend(items.iter().map(|ii_ref| tcx.hir().local_def_id(ii_ref.id.hir_id)));\n+                self.worklist.extend(items.iter().map(|ii_ref| ii_ref.id.def_id));\n \n                 let trait_def_id = match trait_ref.path.res {\n                     Res::Def(DefKind::Trait, def_id) => def_id,"}, {"sha": "f538427efd9ff3433f14c2a018413f4ec44fb121", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -376,7 +376,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         }\n \n         self.annotate(\n-            i.hir_id,\n+            i.hir_id(),\n             &i.attrs,\n             i.span,\n             kind,\n@@ -389,7 +389,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n         self.annotate(\n-            ti.hir_id,\n+            ti.hir_id(),\n             &ti.attrs,\n             ti.span,\n             AnnotationKind::Required,\n@@ -405,7 +405,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         let kind =\n             if self.in_trait_impl { AnnotationKind::Prohibited } else { AnnotationKind::Required };\n         self.annotate(\n-            ii.hir_id,\n+            ii.hir_id(),\n             &ii.attrs,\n             ii.span,\n             kind,\n@@ -459,7 +459,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n         self.annotate(\n-            i.hir_id,\n+            i.hir_id(),\n             &i.attrs,\n             i.span,\n             AnnotationKind::Required,\n@@ -473,7 +473,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n         self.annotate(\n-            md.hir_id,\n+            md.hir_id(),\n             &md.attrs,\n             md.span,\n             AnnotationKind::Required,\n@@ -556,29 +556,29 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n             hir::ItemKind::Impl(hir::Impl { of_trait: None, .. })\n                 | hir::ItemKind::ForeignMod { .. }\n         ) {\n-            self.check_missing_stability(i.hir_id, i.span);\n+            self.check_missing_stability(i.hir_id(), i.span);\n         }\n \n         // Ensure `const fn` that are `stable` have one of `rustc_const_unstable` or\n         // `rustc_const_stable`.\n         if self.tcx.features().staged_api\n             && matches!(&i.kind, hir::ItemKind::Fn(sig, ..) if sig.header.is_const())\n         {\n-            self.check_missing_const_stability(i.hir_id, i.span);\n+            self.check_missing_const_stability(i.hir_id(), i.span);\n         }\n \n         intravisit::walk_item(self, i)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n-        self.check_missing_stability(ti.hir_id, ti.span);\n+        self.check_missing_stability(ti.hir_id(), ti.span);\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n-        let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent_item(ii.hir_id));\n+        let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent_item(ii.hir_id()));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n-            self.check_missing_stability(ii.hir_id, ii.span);\n+            self.check_missing_stability(ii.hir_id(), ii.span);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n@@ -594,12 +594,12 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n-        self.check_missing_stability(i.hir_id, i.span);\n+        self.check_missing_stability(i.hir_id(), i.span);\n         intravisit::walk_foreign_item(self, i);\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n-        self.check_missing_stability(md.hir_id, md.span);\n+        self.check_missing_stability(md.hir_id(), md.span);\n     }\n \n     // Note that we don't need to `check_missing_stability` for default generic parameters,\n@@ -712,13 +712,12 @@ impl Visitor<'tcx> for Checker<'tcx> {\n                     return;\n                 }\n \n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let cnum = match self.tcx.extern_mod_stmt_cnum(def_id) {\n+                let cnum = match self.tcx.extern_mod_stmt_cnum(item.def_id) {\n                     Some(cnum) => cnum,\n                     None => return,\n                 };\n                 let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-                self.tcx.check_stability(def_id, Some(item.hir_id), item.span);\n+                self.tcx.check_stability(def_id, Some(item.hir_id()), item.span);\n             }\n \n             // For implementations of traits, check the stability of each item\n@@ -744,7 +743,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n                                 .map_or(item.span, |a| a.span);\n                             self.tcx.struct_span_lint_hir(\n                                 INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n-                                item.hir_id,\n+                                item.hir_id(),\n                                 span,\n                                 |lint| lint\n                                     .build(\"an `#[unstable]` annotation here has no effect\")\n@@ -775,15 +774,14 @@ impl Visitor<'tcx> for Checker<'tcx> {\n             // There's no good place to insert stability check for non-Copy unions,\n             // so semi-randomly perform it here in stability.rs\n             hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let ty = self.tcx.type_of(def_id);\n+                let ty = self.tcx.type_of(item.def_id);\n                 let (adt_def, substs) = match ty.kind() {\n                     ty::Adt(adt_def, substs) => (adt_def, substs),\n                     _ => bug!(),\n                 };\n \n                 // Non-`Copy` fields are unstable, except for `ManuallyDrop`.\n-                let param_env = self.tcx.param_env(def_id);\n+                let param_env = self.tcx.param_env(item.def_id);\n                 for field in &adt_def.non_enum_variant().fields {\n                     let field_ty = field.ty(self.tcx, substs);\n                     if !field_ty.ty_adt_def().map_or(false, |adt_def| adt_def.is_manually_drop())"}, {"sha": "d5c287fb3bcb3b30d2ace94e9e10a81408ba11c3", "filename": "compiler/rustc_plugin_impl/src/build.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_plugin_impl%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_plugin_impl%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fsrc%2Fbuild.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -1,7 +1,7 @@\n //! Used by `rustc` when compiling a plugin crate.\n \n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n@@ -10,14 +10,14 @@ use rustc_span::Span;\n \n struct RegistrarFinder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    registrars: Vec<(hir::HirId, Span)>,\n+    registrars: Vec<(LocalDefId, Span)>,\n }\n \n impl<'v, 'tcx> ItemLikeVisitor<'v> for RegistrarFinder<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Fn(..) = item.kind {\n             if self.tcx.sess.contains_name(&item.attrs, sym::plugin_registrar) {\n-                self.registrars.push((item.hir_id, item.span));\n+                self.registrars.push((item.def_id, item.span));\n             }\n         }\n     }\n@@ -43,8 +43,8 @@ fn plugin_registrar_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n     match finder.registrars.len() {\n         0 => None,\n         1 => {\n-            let (hir_id, _) = finder.registrars.pop().unwrap();\n-            Some(tcx.hir().local_def_id(hir_id).to_def_id())\n+            let (def_id, _) = finder.registrars.pop().unwrap();\n+            Some(def_id.to_def_id())\n         }\n         _ => {\n             let diagnostic = tcx.sess.diagnostic();"}, {"sha": "890493fa85387a2c946798835a4dc053e0d66756", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 58, "deletions": 62, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -454,11 +454,9 @@ impl EmbargoVisitor<'tcx> {\n         let module_def_id = self.tcx.hir().local_def_id(reachable_mod);\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n-            let hir_id = item_id.id;\n-            let item_def_id = self.tcx.hir().local_def_id(hir_id);\n-            let def_kind = self.tcx.def_kind(item_def_id);\n-            let vis = self.tcx.visibility(item_def_id);\n-            self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n+            let def_kind = self.tcx.def_kind(item_id.def_id);\n+            let vis = self.tcx.visibility(item_id.def_id);\n+            self.update_macro_reachable_def(item_id.hir_id(), def_kind, vis, defining_mod);\n         }\n         if let Some(exports) = self.tcx.module_exports(module_def_id) {\n             for export in exports {\n@@ -588,14 +586,17 @@ impl EmbargoVisitor<'tcx> {\n                 .map(|module_hir_id| self.tcx.hir().expect_item(module_hir_id))\n             {\n                 if let hir::ItemKind::Mod(m) = &item.kind {\n-                    for item_id in m.item_ids {\n-                        let item = self.tcx.hir().expect_item(item_id.id);\n-                        let def_id = self.tcx.hir().local_def_id(item_id.id);\n-                        if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id.to_def_id()) {\n+                    for &item_id in m.item_ids {\n+                        let item = self.tcx.hir().item(item_id);\n+                        if !self.tcx.hygienic_eq(\n+                            segment.ident,\n+                            item.ident,\n+                            item_id.def_id.to_def_id(),\n+                        ) {\n                             continue;\n                         }\n                         if let hir::ItemKind::Use(..) = item.kind {\n-                            self.update(item.hir_id, Some(AccessLevel::Exported));\n+                            self.update(item.hir_id(), Some(AccessLevel::Exported));\n                         }\n                     }\n                 }\n@@ -616,7 +617,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let inherited_item_level = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n-                Option::<AccessLevel>::of_impl(item.hir_id, self.tcx, &self.access_levels)\n+                Option::<AccessLevel>::of_impl(item.hir_id(), self.tcx, &self.access_levels)\n             }\n             // Foreign modules inherit level from parents.\n             hir::ItemKind::ForeignMod { .. } => self.prev_level,\n@@ -644,7 +645,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         };\n \n         // Update level of the item itself.\n-        let item_level = self.update(item.hir_id, inherited_item_level);\n+        let item_level = self.update(item.hir_id(), inherited_item_level);\n \n         // Update levels of nested things.\n         match item.kind {\n@@ -662,13 +663,13 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             hir::ItemKind::Impl(ref impl_) => {\n                 for impl_item_ref in impl_.items {\n                     if impl_.of_trait.is_some() || impl_item_ref.vis.node.is_pub() {\n-                        self.update(impl_item_ref.id.hir_id, item_level);\n+                        self.update(impl_item_ref.id.hir_id(), item_level);\n                     }\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.hir_id, item_level);\n+                    self.update(trait_item_ref.id.hir_id(), item_level);\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n@@ -684,7 +685,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n                     if foreign_item.vis.node.is_pub() {\n-                        self.update(foreign_item.id.hir_id, item_level);\n+                        self.update(foreign_item.id.hir_id(), item_level);\n                     }\n                 }\n             }\n@@ -727,7 +728,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n                     let exist_level =\n                         cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n-                    self.reach(item.hir_id, exist_level).generics().predicates().ty();\n+                    self.reach(item.hir_id(), exist_level).generics().predicates().ty();\n                 }\n             }\n             // Visit everything.\n@@ -736,15 +737,15 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id, item_level).generics().predicates().ty();\n+                    self.reach(item.hir_id(), item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id, item_level).generics().predicates();\n+                    self.reach(item.hir_id(), item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n-                        let mut reach = self.reach(trait_item_ref.id.hir_id, item_level);\n+                        let mut reach = self.reach(trait_item_ref.id.hir_id(), item_level);\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n@@ -759,18 +760,18 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id, item_level).generics().predicates();\n+                    self.reach(item.hir_id(), item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id, item_level).generics().predicates().ty().trait_ref();\n+                    self.reach(item.hir_id(), item_level).generics().predicates().ty().trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        let impl_item_level = self.get(impl_item_ref.id.hir_id);\n+                        let impl_item_level = self.get(impl_item_ref.id.hir_id());\n                         if impl_item_level.is_some() {\n-                            self.reach(impl_item_ref.id.hir_id, impl_item_level)\n+                            self.reach(impl_item_ref.id.hir_id(), impl_item_level)\n                                 .generics()\n                                 .predicates()\n                                 .ty();\n@@ -782,7 +783,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id, item_level).generics().predicates();\n+                    self.reach(item.hir_id(), item_level).generics().predicates();\n                 }\n                 for variant in def.variants {\n                     let variant_level = self.get(variant.id);\n@@ -792,16 +793,16 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.update(item.hir_id, variant_level);\n+                        self.update(item.hir_id(), variant_level);\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let foreign_item_level = self.get(foreign_item.id.hir_id);\n+                    let foreign_item_level = self.get(foreign_item.id.hir_id());\n                     if foreign_item_level.is_some() {\n-                        self.reach(foreign_item.id.hir_id, foreign_item_level)\n+                        self.reach(foreign_item.id.hir_id(), foreign_item_level)\n                             .generics()\n                             .predicates()\n                             .ty();\n@@ -811,7 +812,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.hir_id, item_level).generics().predicates();\n+                    self.reach(item.hir_id(), item_level).generics().predicates();\n                     for field in struct_def.fields() {\n                         let field_level = self.get(field.hir_id);\n                         if field_level.is_some() {\n@@ -866,14 +867,12 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // `#[macro_export]`-ed `macro_rules!` are `Public` since they\n             // ignore their containing path to always appear at the crate root.\n             if md.ast.macro_rules {\n-                self.update(md.hir_id, Some(AccessLevel::Public));\n+                self.update(md.hir_id(), Some(AccessLevel::Public));\n             }\n             return;\n         }\n \n-        let macro_module_def_id =\n-            ty::DefIdTree::parent(self.tcx, self.tcx.hir().local_def_id(md.hir_id).to_def_id())\n-                .unwrap();\n+        let macro_module_def_id = ty::DefIdTree::parent(self.tcx, md.def_id.to_def_id()).unwrap();\n         let hir_id = macro_module_def_id\n             .as_local()\n             .map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id));\n@@ -883,7 +882,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             _ => return,\n         };\n         let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n-        let new_level = self.update(md.hir_id, level);\n+        let new_level = self.update(md.hir_id(), level);\n         if new_level.is_none() {\n             return;\n         }\n@@ -1037,7 +1036,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = self.current_item.replace(item.hir_id);\n+        let orig_current_item = self.current_item.replace(item.hir_id());\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n     }\n@@ -1322,8 +1321,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n \n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item =\n-            mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.hir_id));\n+        let orig_current_item = mem::replace(&mut self.current_item, item.def_id);\n         let old_maybe_typeck_results = self.maybe_typeck_results.take();\n         intravisit::walk_item(self, item);\n         self.maybe_typeck_results = old_maybe_typeck_results;\n@@ -1463,7 +1461,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::ForeignMod { .. } => {}\n \n             hir::ItemKind::Trait(.., ref bounds, _) => {\n-                if !self.trait_is_public(item.hir_id) {\n+                if !self.trait_is_public(item.hir_id()) {\n                     return;\n                 }\n \n@@ -1526,7 +1524,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         match impl_item.kind {\n                             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..) => {\n-                                self.access_levels.is_reachable(impl_item_ref.id.hir_id)\n+                                self.access_levels.is_reachable(impl_item_ref.id.hir_id())\n                             }\n                             hir::ImplItemKind::TyAlias(_) => false,\n                         }\n@@ -1546,8 +1544,10 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                                 match impl_item.kind {\n                                     hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..)\n-                                        if self\n-                                            .item_is_public(&impl_item.hir_id, &impl_item.vis) =>\n+                                        if self.item_is_public(\n+                                            &impl_item.hir_id(),\n+                                            &impl_item.vis,\n+                                        ) =>\n                                     {\n                                         intravisit::walk_impl_item(self, impl_item)\n                                     }\n@@ -1588,7 +1588,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_.items {\n-                        if self.item_is_public(&impl_item_ref.id.hir_id, &impl_item_ref.vis) {\n+                        if self.item_is_public(&impl_item_ref.id.hir_id(), &impl_item_ref.vis) {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n                                 AssocItemKind::Const => {\n@@ -1615,7 +1615,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::TyAlias(..) => return,\n \n             // Not at all public, so we don't care.\n-            _ if !self.item_is_public(&item.hir_id, &item.vis) => {\n+            _ if !self.item_is_public(&item.hir_id(), &item.vis) => {\n                 return;\n             }\n \n@@ -1651,7 +1651,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        if self.access_levels.is_reachable(item.hir_id) {\n+        if self.access_levels.is_reachable(item.hir_id()) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n@@ -1926,7 +1926,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let tcx = self.tcx;\n-        let item_visibility = tcx.visibility(tcx.hir().local_def_id(item.hir_id).to_def_id());\n+        let item_visibility = tcx.visibility(item.def_id);\n \n         match item.kind {\n             // Crates are always public.\n@@ -1942,34 +1942,34 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n-                self.check(item.hir_id, item_visibility).generics().predicates().ty();\n+                self.check(item.hir_id(), item_visibility).generics().predicates().ty();\n             }\n             hir::ItemKind::OpaqueTy(..) => {\n                 // `ty()` for opaque types is the underlying type,\n                 // it's not a part of interface, so we skip it.\n-                self.check(item.hir_id, item_visibility).generics().bounds();\n+                self.check(item.hir_id(), item_visibility).generics().bounds();\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n-                self.check(item.hir_id, item_visibility).generics().predicates();\n+                self.check(item.hir_id(), item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n                     self.check_assoc_item(\n-                        trait_item_ref.id.hir_id,\n+                        trait_item_ref.id.hir_id(),\n                         trait_item_ref.kind,\n                         trait_item_ref.defaultness,\n                         item_visibility,\n                     );\n \n                     if let AssocItemKind::Type = trait_item_ref.kind {\n-                        self.check(trait_item_ref.id.hir_id, item_visibility).bounds();\n+                        self.check(trait_item_ref.id.hir_id(), item_visibility).bounds();\n                     }\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                self.check(item.hir_id, item_visibility).generics().predicates();\n+                self.check(item.hir_id(), item_visibility).generics().predicates();\n             }\n             hir::ItemKind::Enum(ref def, _) => {\n-                self.check(item.hir_id, item_visibility).generics().predicates();\n+                self.check(item.hir_id(), item_visibility).generics().predicates();\n \n                 for variant in def.variants {\n                     for field in variant.data.fields() {\n@@ -1980,13 +1980,13 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of foreign modules have their own publicity.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let vis = tcx.visibility(tcx.hir().local_def_id(foreign_item.id.hir_id));\n-                    self.check(foreign_item.id.hir_id, vis).generics().predicates().ty();\n+                    let vis = tcx.visibility(foreign_item.id.def_id);\n+                    self.check(foreign_item.id.hir_id(), vis).generics().predicates().ty();\n                 }\n             }\n             // Subitems of structs and unions have their own publicity.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                self.check(item.hir_id, item_visibility).generics().predicates();\n+                self.check(item.hir_id(), item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n                     let field_visibility = tcx.visibility(tcx.hir().local_def_id(field.hir_id));\n@@ -1998,20 +1998,16 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n             hir::ItemKind::Impl(ref impl_) => {\n-                let impl_vis = ty::Visibility::of_impl(item.hir_id, tcx, &Default::default());\n-                self.check(item.hir_id, impl_vis).generics().predicates();\n+                let impl_vis = ty::Visibility::of_impl(item.hir_id(), tcx, &Default::default());\n+                self.check(item.hir_id(), impl_vis).generics().predicates();\n                 for impl_item_ref in impl_.items {\n                     let impl_item_vis = if impl_.of_trait.is_none() {\n-                        min(\n-                            tcx.visibility(tcx.hir().local_def_id(impl_item_ref.id.hir_id)),\n-                            impl_vis,\n-                            tcx,\n-                        )\n+                        min(tcx.visibility(impl_item_ref.id.def_id), impl_vis, tcx)\n                     } else {\n                         impl_vis\n                     };\n                     self.check_assoc_item(\n-                        impl_item_ref.id.hir_id,\n+                        impl_item_ref.id.hir_id(),\n                         impl_item_ref.kind,\n                         impl_item_ref.defaultness,\n                         impl_item_vis,"}, {"sha": "c0e4a1bdf07a47040ee5e143e438e6c585c40a97", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -587,7 +587,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `type MyAnonTy<'b> = impl MyTrait<'b>;`\n                 //                 ^                  ^ this gets resolved in the scope of\n                 //                                      the opaque_ty generics\n-                let opaque_ty = self.tcx.hir().expect_item(item_id.id);\n+                let opaque_ty = self.tcx.hir().item(item_id);\n                 let (generics, bounds) = match opaque_ty.kind {\n                     // Named opaque `impl Trait` types are reached via `TyKind::Path`.\n                     // This arm is for `impl Trait` in the types of statics, constants and locals.\n@@ -632,20 +632,32 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                                 // Ensure that the parent of the def is an item, not HRTB\n                                 let parent_id = self.tcx.hir().get_parent_node(hir_id);\n-                                let parent_impl_id = hir::ImplItemId { hir_id: parent_id };\n-                                let parent_trait_id = hir::TraitItemId { hir_id: parent_id };\n-                                let krate = self.tcx.hir().krate();\n-\n-                                if !(krate.items.contains_key(&parent_id)\n-                                    || krate.impl_items.contains_key(&parent_impl_id)\n-                                    || krate.trait_items.contains_key(&parent_trait_id))\n+                                let parent_is_item = if let Some(parent_def_id) =\n+                                    parent_id.as_owner()\n                                 {\n+                                    let parent_item_id = hir::ItemId { def_id: parent_def_id };\n+                                    let parent_impl_id = hir::ImplItemId { def_id: parent_def_id };\n+                                    let parent_trait_id =\n+                                        hir::TraitItemId { def_id: parent_def_id };\n+                                    let parent_foreign_id =\n+                                        hir::ForeignItemId { def_id: parent_def_id };\n+                                    let krate = self.tcx.hir().krate();\n+\n+                                    krate.items.contains_key(&parent_item_id)\n+                                        || krate.impl_items.contains_key(&parent_impl_id)\n+                                        || krate.trait_items.contains_key(&parent_trait_id)\n+                                        || krate.foreign_items.contains_key(&parent_foreign_id)\n+                                } else {\n+                                    false\n+                                };\n+\n+                                if !parent_is_item {\n                                     struct_span_err!(\n                                         self.tcx.sess,\n                                         lifetime.span,\n                                         E0657,\n                                         \"`impl Trait` can only capture lifetimes \\\n-                                         bound at the fn or impl level\"\n+                                             bound at the fn or impl level\"\n                                     )\n                                     .emit();\n                                     self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n@@ -738,7 +750,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir().get_parent_item(trait_item.hir_id)),\n+                    Some(tcx.hir().get_parent_item(trait_item.hir_id())),\n                     &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n@@ -800,7 +812,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir().get_parent_item(impl_item.hir_id)),\n+                    Some(tcx.hir().get_parent_item(impl_item.hir_id())),\n                     &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n@@ -1255,7 +1267,7 @@ fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifet\n                     tcx.sess.span_err(item.span, &object_lifetime_default_reprs);\n                 }\n \n-                map.insert(item.hir_id, result);\n+                map.insert(item.hir_id(), result);\n             }\n             _ => {}\n         }\n@@ -2111,7 +2123,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n                 {\n                     assoc_item_kind =\n-                        trait_items.iter().find(|ti| ti.id.hir_id == parent).map(|ti| ti.kind);\n+                        trait_items.iter().find(|ti| ti.id.hir_id() == parent).map(|ti| ti.kind);\n                 }\n                 match *m {\n                     hir::TraitFn::Required(_) => None,\n@@ -2125,7 +2137,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 {\n                     impl_self = Some(self_ty);\n                     assoc_item_kind =\n-                        items.iter().find(|ii| ii.id.hir_id == parent).map(|ii| ii.kind);\n+                        items.iter().find(|ii| ii.id.hir_id() == parent).map(|ii| ii.kind);\n                 }\n                 Some(body)\n             }"}, {"sha": "625d7c831202b45ff32b15f273875ff2b83d383e", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 54, "deletions": 90, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -373,14 +373,14 @@ impl<'tcx> DumpVisitor<'tcx> {\n         body: hir::BodyId,\n     ) {\n         let map = &self.tcx.hir();\n-        self.nest_typeck_results(map.local_def_id(item.hir_id), |v| {\n+        self.nest_typeck_results(item.def_id, |v| {\n             let body = map.body(body);\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(fn_data, DefData, item.span);\n                 v.process_formals(body.params, &fn_data.qualname);\n-                v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id);\n+                v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id());\n \n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id), fn_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id()), fn_data);\n             }\n \n             for arg in decl.inputs {\n@@ -401,10 +401,10 @@ impl<'tcx> DumpVisitor<'tcx> {\n         typ: &'tcx hir::Ty<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) {\n-        self.nest_typeck_results(self.tcx.hir().local_def_id(item.hir_id), |v| {\n+        self.nest_typeck_results(item.def_id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id), var_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id()), var_data);\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n@@ -465,10 +465,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     ) {\n         debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n-        let qualname = format!(\n-            \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.hir_id).to_def_id())\n-        );\n+        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.def_id.to_def_id()));\n \n         let kind = match item.kind {\n             hir::ItemKind::Struct(_, _) => DefKind::Struct,\n@@ -500,10 +497,10 @@ impl<'tcx> DumpVisitor<'tcx> {\n         if !self.span.filter_generated(item.ident.span) {\n             let span = self.span_from_span(item.ident.span);\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item, item.hir_id),\n+                &access_from!(self.save_ctxt, item, item.hir_id()),\n                 Def {\n                     kind,\n-                    id: id_from_hir_id(item.hir_id, &self.save_ctxt),\n+                    id: id_from_def_id(item.def_id.to_def_id()),\n                     span,\n                     name,\n                     qualname: qualname.clone(),\n@@ -518,13 +515,13 @@ impl<'tcx> DumpVisitor<'tcx> {\n             );\n         }\n \n-        self.nest_typeck_results(self.tcx.hir().local_def_id(item.hir_id), |v| {\n+        self.nest_typeck_results(item.def_id, |v| {\n             for field in def.fields() {\n-                v.process_struct_field_def(field, item.hir_id);\n+                v.process_struct_field_def(field, item.hir_id());\n                 v.visit_ty(&field.ty);\n             }\n \n-            v.process_generic_params(ty_params, &qualname, item.hir_id);\n+            v.process_generic_params(ty_params, &qualname, item.hir_id());\n         });\n     }\n \n@@ -541,7 +538,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let access = access_from!(self.save_ctxt, item, item.hir_id);\n+        let access = access_from!(self.save_ctxt, item, item.hir_id());\n \n         for variant in enum_definition.variants {\n             let name = variant.ident.name.to_string();\n@@ -556,7 +553,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n                         let id = id_from_hir_id(variant.id, &self.save_ctxt);\n-                        let parent = Some(id_from_hir_id(item.hir_id, &self.save_ctxt));\n+                        let parent = Some(id_from_def_id(item.def_id.to_def_id()));\n \n                         self.dumper.dump_def(\n                             &access,\n@@ -596,7 +593,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n                         let id = id_from_hir_id(variant.id, &self.save_ctxt);\n-                        let parent = Some(id_from_hir_id(item.hir_id, &self.save_ctxt));\n+                        let parent = Some(id_from_def_id(item.def_id.to_def_id()));\n \n                         self.dumper.dump_def(\n                             &access,\n@@ -627,7 +624,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.visit_ty(field.ty);\n             }\n         }\n-        self.process_generic_params(ty_params, &enum_data.qualname, item.hir_id);\n+        self.process_generic_params(ty_params, &enum_data.qualname, item.hir_id());\n         self.dumper.dump_def(&access, enum_data);\n     }\n \n@@ -644,17 +641,14 @@ impl<'tcx> DumpVisitor<'tcx> {\n         }\n \n         let map = &self.tcx.hir();\n-        self.nest_typeck_results(map.local_def_id(item.hir_id), |v| {\n+        self.nest_typeck_results(item.def_id, |v| {\n             v.visit_ty(&impl_.self_ty);\n             if let Some(trait_ref) = &impl_.of_trait {\n                 v.process_path(trait_ref.hir_ref_id, &hir::QPath::Resolved(None, &trait_ref.path));\n             }\n-            v.process_generic_params(&impl_.generics, \"\", item.hir_id);\n+            v.process_generic_params(&impl_.generics, \"\", item.hir_id());\n             for impl_item in impl_.items {\n-                v.process_impl_item(\n-                    map.impl_item(impl_item.id),\n-                    map.local_def_id(item.hir_id).to_def_id(),\n-                );\n+                v.process_impl_item(map.impl_item(impl_item.id), item.def_id.to_def_id());\n             }\n         });\n     }\n@@ -667,10 +661,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         methods: &'tcx [hir::TraitItemRef],\n     ) {\n         let name = item.ident.to_string();\n-        let qualname = format!(\n-            \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id(item.hir_id).to_def_id())\n-        );\n+        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.def_id.to_def_id()));\n         let mut val = name.clone();\n         if !generics.params.is_empty() {\n             val.push_str(&generic_params_to_string(generics.params));\n@@ -680,12 +671,12 @@ impl<'tcx> DumpVisitor<'tcx> {\n             val.push_str(&bounds_to_string(trait_refs));\n         }\n         if !self.span.filter_generated(item.ident.span) {\n-            let id = id_from_hir_id(item.hir_id, &self.save_ctxt);\n+            let id = id_from_def_id(item.def_id.to_def_id());\n             let span = self.span_from_span(item.ident.span);\n             let children =\n-                methods.iter().map(|i| id_from_hir_id(i.id.hir_id, &self.save_ctxt)).collect();\n+                methods.iter().map(|i| id_from_def_id(i.id.def_id.to_def_id())).collect();\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item, item.hir_id),\n+                &access_from!(self.save_ctxt, item, item.hir_id()),\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -729,28 +720,25 @@ impl<'tcx> DumpVisitor<'tcx> {\n                         kind: RelationKind::SuperTrait,\n                         span,\n                         from: id_from_def_id(id),\n-                        to: id_from_hir_id(item.hir_id, &self.save_ctxt),\n+                        to: id_from_def_id(item.def_id.to_def_id()),\n                     });\n                 }\n             }\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, &qualname, item.hir_id);\n+        self.process_generic_params(generics, &qualname, item.hir_id());\n         for method in methods {\n             let map = &self.tcx.hir();\n-            self.process_trait_item(\n-                map.trait_item(method.id),\n-                map.local_def_id(item.hir_id).to_def_id(),\n-            )\n+            self.process_trait_item(map.trait_item(method.id), item.def_id.to_def_id())\n         }\n     }\n \n     // `item` is the module in question, represented as an( item.\n     fn process_mod(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item, item.hir_id), mod_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item, item.hir_id()), mod_data);\n         }\n     }\n \n@@ -1011,7 +999,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let body = body.map(|b| &self.tcx.hir().body(b).value);\n                 let respan = respan(vis_span, hir::VisibilityKind::Public);\n                 self.process_assoc_const(\n-                    trait_item.hir_id,\n+                    trait_item.hir_id(),\n                     trait_item.ident,\n                     &ty,\n                     body,\n@@ -1027,7 +1015,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.process_method(\n                     sig,\n                     body,\n-                    trait_item.hir_id,\n+                    trait_item.hir_id(),\n                     trait_item.ident,\n                     &trait_item.generics,\n                     &respan,\n@@ -1037,15 +1025,12 @@ impl<'tcx> DumpVisitor<'tcx> {\n             hir::TraitItemKind::Type(ref bounds, ref default_ty) => {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n-                let qualname = format!(\n-                    \"::{}\",\n-                    self.tcx\n-                        .def_path_str(self.tcx.hir().local_def_id(trait_item.hir_id).to_def_id())\n-                );\n+                let qualname =\n+                    format!(\"::{}\", self.tcx.def_path_str(trait_item.def_id.to_def_id()));\n \n                 if !self.span.filter_generated(trait_item.ident.span) {\n                     let span = self.span_from_span(trait_item.ident.span);\n-                    let id = id_from_hir_id(trait_item.hir_id, &self.save_ctxt);\n+                    let id = id_from_def_id(trait_item.def_id.to_def_id());\n \n                     self.dumper.dump_def(\n                         &Access { public: true, reachable: true },\n@@ -1061,7 +1046,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                             decl_id: None,\n                             docs: self.save_ctxt.docs_for_attrs(&trait_item.attrs),\n                             sig: sig::assoc_type_signature(\n-                                trait_item.hir_id,\n+                                trait_item.hir_id(),\n                                 trait_item.ident,\n                                 Some(bounds),\n                                 default_ty.as_ref().map(|ty| &**ty),\n@@ -1088,7 +1073,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             hir::ImplItemKind::Const(ref ty, body) => {\n                 let body = self.tcx.hir().body(body);\n                 self.process_assoc_const(\n-                    impl_item.hir_id,\n+                    impl_item.hir_id(),\n                     impl_item.ident,\n                     &ty,\n                     Some(&body.value),\n@@ -1101,7 +1086,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.process_method(\n                     sig,\n                     Some(body),\n-                    impl_item.hir_id,\n+                    impl_item.hir_id(),\n                     impl_item.ident,\n                     &impl_item.generics,\n                     &impl_item.vis,\n@@ -1130,7 +1115,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             .module\n             .item_ids\n             .iter()\n-            .map(|i| id_from_hir_id(i.id, &self.save_ctxt))\n+            .map(|i| id_from_def_id(i.def_id.to_def_id()))\n             .collect();\n         let span = self.span_from_span(krate.item.span);\n \n@@ -1179,16 +1164,11 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             hir::ItemKind::Use(path, hir::UseKind::Single) => {\n                 let sub_span = path.segments.last().unwrap().ident.span;\n                 if !self.span.filter_generated(sub_span) {\n-                    let access = access_from!(self.save_ctxt, item, item.hir_id);\n-                    let ref_id = self.lookup_def_id(item.hir_id).map(id_from_def_id);\n+                    let access = access_from!(self.save_ctxt, item, item.hir_id());\n+                    let ref_id = self.lookup_def_id(item.hir_id()).map(id_from_def_id);\n                     let span = self.span_from_span(sub_span);\n-                    let parent = self\n-                        .save_ctxt\n-                        .tcx\n-                        .hir()\n-                        .opt_local_def_id(item.hir_id)\n-                        .and_then(|id| self.save_ctxt.tcx.parent(id.to_def_id()))\n-                        .map(id_from_def_id);\n+                    let parent =\n+                        self.save_ctxt.tcx.parent(item.def_id.to_def_id()).map(id_from_def_id);\n                     self.dumper.import(\n                         &access,\n                         Import {\n@@ -1206,23 +1186,17 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             }\n             hir::ItemKind::Use(path, hir::UseKind::Glob) => {\n                 // Make a comma-separated list of names of imported modules.\n-                let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let names = self.tcx.names_imported_by_glob_use(def_id);\n+                let names = self.tcx.names_imported_by_glob_use(item.def_id);\n                 let names: Vec<_> = names.iter().map(|n| n.to_string()).collect();\n \n                 // Otherwise it's a span with wrong macro expansion info, which\n                 // we don't want to track anyway, since it's probably macro-internal `use`\n                 if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n                     if !self.span.filter_generated(item.span) {\n-                        let access = access_from!(self.save_ctxt, item, item.hir_id);\n+                        let access = access_from!(self.save_ctxt, item, item.hir_id());\n                         let span = self.span_from_span(sub_span);\n-                        let parent = self\n-                            .save_ctxt\n-                            .tcx\n-                            .hir()\n-                            .opt_local_def_id(item.hir_id)\n-                            .and_then(|id| self.save_ctxt.tcx.parent(id.to_def_id()))\n-                            .map(id_from_def_id);\n+                        let parent =\n+                            self.save_ctxt.tcx.parent(item.def_id.to_def_id()).map(id_from_def_id);\n                         self.dumper.import(\n                             &access,\n                             Import {\n@@ -1243,13 +1217,8 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 let name_span = item.ident.span;\n                 if !self.span.filter_generated(name_span) {\n                     let span = self.span_from_span(name_span);\n-                    let parent = self\n-                        .save_ctxt\n-                        .tcx\n-                        .hir()\n-                        .opt_local_def_id(item.hir_id)\n-                        .and_then(|id| self.save_ctxt.tcx.parent(id.to_def_id()))\n-                        .map(id_from_def_id);\n+                    let parent =\n+                        self.save_ctxt.tcx.parent(item.def_id.to_def_id()).map(id_from_def_id);\n                     self.dumper.import(\n                         &Access { public: false, reachable: false },\n                         Import {\n@@ -1286,20 +1255,17 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 self.process_mod(item);\n-                intravisit::walk_mod(self, m, item.hir_id);\n+                intravisit::walk_mod(self, m, item.hir_id());\n             }\n             hir::ItemKind::TyAlias(ty, ref generics) => {\n-                let qualname = format!(\n-                    \"::{}\",\n-                    self.tcx.def_path_str(self.tcx.hir().local_def_id(item.hir_id).to_def_id())\n-                );\n+                let qualname = format!(\"::{}\", self.tcx.def_path_str(item.def_id.to_def_id()));\n                 let value = ty_to_string(&ty);\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n-                    let id = id_from_hir_id(item.hir_id, &self.save_ctxt);\n+                    let id = id_from_def_id(item.def_id.to_def_id());\n \n                     self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item, item.hir_id),\n+                        &access_from!(self.save_ctxt, item, item.hir_id()),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1318,7 +1284,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 }\n \n                 self.visit_ty(ty);\n-                self.process_generic_params(generics, &qualname, item.hir_id);\n+                self.process_generic_params(generics, &qualname, item.hir_id());\n             }\n             _ => intravisit::walk_item(self, item),\n         }\n@@ -1382,10 +1348,8 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 });\n             }\n             hir::TyKind::OpaqueDef(item_id, _) => {\n-                let item = self.tcx.hir().item(item_id.id);\n-                self.nest_typeck_results(self.tcx.hir().local_def_id(item_id.id), |v| {\n-                    v.visit_item(item)\n-                });\n+                let item = self.tcx.hir().item(item_id);\n+                self.nest_typeck_results(item_id.def_id, |v| v.visit_item(item));\n             }\n             _ => intravisit::walk_ty(self, t),\n         }\n@@ -1485,14 +1449,14 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        let access = access_from!(self.save_ctxt, item, item.hir_id);\n+        let access = access_from!(self.save_ctxt, item, item.hir_id());\n \n         match item.kind {\n             hir::ForeignItemKind::Fn(decl, _, ref generics) => {\n                 if let Some(fn_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(fn_data, DefData, item.span);\n \n-                    self.process_generic_params(generics, &fn_data.qualname, item.hir_id);\n+                    self.process_generic_params(generics, &fn_data.qualname, item.hir_id());\n                     self.dumper.dump_def(&access, fn_data);\n                 }\n "}, {"sha": "b3f281bcabcec597f58f07fa6f25dfe60c29372c", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -137,7 +137,7 @@ impl<'tcx> SaveContext<'tcx> {\n     }\n \n     pub fn get_extern_item_data(&self, item: &hir::ForeignItem<'_>) -> Option<Data> {\n-        let def_id = self.tcx.hir().local_def_id(item.hir_id).to_def_id();\n+        let def_id = item.def_id.to_def_id();\n         let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n         match item.kind {\n             hir::ForeignItemKind::Fn(ref decl, arg_names, ref generics) => {\n@@ -156,7 +156,7 @@ impl<'tcx> SaveContext<'tcx> {\n                             unsafety: hir::Unsafety::Unsafe,\n                             // functions in extern block cannot be const\n                             constness: hir::Constness::NotConst,\n-                            abi: self.tcx.hir().get_foreign_abi(item.hir_id),\n+                            abi: self.tcx.hir().get_foreign_abi(item.hir_id()),\n                             // functions in extern block cannot be async\n                             asyncness: hir::IsAsync::NotAsync,\n                         },\n@@ -201,7 +201,7 @@ impl<'tcx> SaveContext<'tcx> {\n     }\n \n     pub fn get_item_data(&self, item: &hir::Item<'_>) -> Option<Data> {\n-        let def_id = self.tcx.hir().local_def_id(item.hir_id).to_def_id();\n+        let def_id = item.def_id.to_def_id();\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, ref generics, _) => {\n                 let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n@@ -290,7 +290,11 @@ impl<'tcx> SaveContext<'tcx> {\n                     span: self.span_from_span(item.ident.span),\n                     value: filename.to_string(),\n                     parent: None,\n-                    children: m.item_ids.iter().map(|i| id_from_hir_id(i.id, self)).collect(),\n+                    children: m\n+                        .item_ids\n+                        .iter()\n+                        .map(|i| id_from_def_id(i.def_id.to_def_id()))\n+                        .collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),\n                     sig: sig::item_signature(item, self),\n@@ -354,7 +358,7 @@ impl<'tcx> SaveContext<'tcx> {\n                                 parent: None,\n                                 children: items\n                                     .iter()\n-                                    .map(|i| id_from_hir_id(i.id.hir_id, self))\n+                                    .map(|i| id_from_def_id(i.id.def_id.to_def_id()))\n                                     .collect(),\n                                 docs: String::new(),\n                                 sig: None,"}, {"sha": "33db189af37a6726ddc836b50721bac346ab9853", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -317,8 +317,8 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                 Ok(replace_text(nested_ty, text))\n             }\n             hir::TyKind::OpaqueDef(item_id, _) => {\n-                let item = scx.tcx.hir().item(item_id.id);\n-                item.make(offset, Some(item_id.id), scx)\n+                let item = scx.tcx.hir().item(item_id);\n+                item.make(offset, Some(item_id.hir_id()), scx)\n             }\n             hir::TyKind::Typeof(_) | hir::TyKind::Infer | hir::TyKind::Err => Err(\"Ty\"),\n         }\n@@ -327,7 +327,7 @@ impl<'hir> Sig for hir::Ty<'hir> {\n \n impl<'hir> Sig for hir::Item<'hir> {\n     fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n-        let id = Some(self.hir_id);\n+        let id = Some(self.hir_id());\n \n         match self.kind {\n             hir::ItemKind::Static(ref ty, m, ref body) => {\n@@ -337,7 +337,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 }\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_hir_id(self.hir_id, scx),\n+                    id: id_from_def_id(self.def_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -359,7 +359,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 let mut text = \"const \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_hir_id(self.hir_id, scx),\n+                    id: id_from_def_id(self.def_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -391,7 +391,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 text.push_str(\"fn \");\n \n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n \n                 sig.text.push('(');\n                 for i in decl.inputs {\n@@ -420,7 +420,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 let mut text = \"mod \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_hir_id(self.hir_id, scx),\n+                    id: id_from_def_id(self.def_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -433,7 +433,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n             hir::ItemKind::TyAlias(ref ty, ref generics) => {\n                 let text = \"type \".to_owned();\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n \n                 sig.text.push_str(\" = \");\n                 let ty = ty.make(offset + sig.text.len(), id, scx)?;\n@@ -445,21 +445,21 @@ impl<'hir> Sig for hir::Item<'hir> {\n             hir::ItemKind::Enum(_, ref generics) => {\n                 let text = \"enum \".to_owned();\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n             hir::ItemKind::Struct(_, ref generics) => {\n                 let text = \"struct \".to_owned();\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n             hir::ItemKind::Union(_, ref generics) => {\n                 let text = \"union \".to_owned();\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n                 sig.text.push_str(\" {}\");\n                 Ok(sig)\n             }\n@@ -475,7 +475,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 }\n                 text.push_str(\"trait \");\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n \n                 if !bounds.is_empty() {\n                     sig.text.push_str(\": \");\n@@ -490,7 +490,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 let mut text = String::new();\n                 text.push_str(\"trait \");\n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n \n                 if !bounds.is_empty() {\n                     sig.text.push_str(\" = \");\n@@ -736,14 +736,14 @@ impl<'hir> Sig for hir::Variant<'hir> {\n \n impl<'hir> Sig for hir::ForeignItem<'hir> {\n     fn make(&self, offset: usize, _parent_id: Option<hir::HirId>, scx: &SaveContext<'_>) -> Result {\n-        let id = Some(self.hir_id);\n+        let id = Some(self.hir_id());\n         match self.kind {\n             hir::ForeignItemKind::Fn(decl, _, ref generics) => {\n                 let mut text = String::new();\n                 text.push_str(\"fn \");\n \n                 let mut sig =\n-                    name_and_generics(text, offset, generics, self.hir_id, self.ident, scx)?;\n+                    name_and_generics(text, offset, generics, self.hir_id(), self.ident, scx)?;\n \n                 sig.text.push('(');\n                 for i in decl.inputs {\n@@ -774,7 +774,7 @@ impl<'hir> Sig for hir::ForeignItem<'hir> {\n                 }\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_hir_id(self.hir_id, scx),\n+                    id: id_from_def_id(self.def_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -790,7 +790,7 @@ impl<'hir> Sig for hir::ForeignItem<'hir> {\n                 let mut text = \"type \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_hir_id(self.hir_id, scx),\n+                    id: id_from_def_id(self.def_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];"}, {"sha": "70e9526f626da934f8ab49f237b5ad448d706785", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -227,6 +227,8 @@ pub struct LocalDefId {\n     pub local_def_index: DefIndex,\n }\n \n+pub const CRATE_DEF_ID: LocalDefId = LocalDefId { local_def_index: CRATE_DEF_INDEX };\n+\n impl Idx for LocalDefId {\n     #[inline]\n     fn new(idx: usize) -> Self {\n@@ -268,6 +270,8 @@ impl<D: Decoder> Decodable<D> for LocalDefId {\n     }\n }\n \n+rustc_data_structures::define_id_collections!(LocalDefIdMap, LocalDefIdSet, LocalDefId);\n+\n impl<CTX: HashStableContext> HashStable<CTX> for DefId {\n     fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         hcx.hash_def_id(*self, hasher)"}, {"sha": "bfe9c4d6de3de853e913c5db8895fbe9cc693675", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -5,6 +5,7 @@\n //! paths etc in all kinds of annoying scenarios.\n \n use rustc_hir as hir;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{subst::InternalSubsts, Instance, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n@@ -31,9 +32,8 @@ struct SymbolNamesTest<'tcx> {\n }\n \n impl SymbolNamesTest<'tcx> {\n-    fn process_attrs(&mut self, hir_id: hir::HirId) {\n+    fn process_attrs(&mut self, def_id: LocalDefId) {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir().local_def_id(hir_id);\n         for attr in tcx.get_attrs(def_id.to_def_id()).iter() {\n             if tcx.sess.check_name(attr, SYMBOL_NAME) {\n                 let def_id = def_id.to_def_id();\n@@ -61,18 +61,18 @@ impl SymbolNamesTest<'tcx> {\n \n impl hir::itemlikevisit::ItemLikeVisitor<'tcx> for SymbolNamesTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.process_attrs(item.hir_id);\n+        self.process_attrs(item.def_id);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.process_attrs(trait_item.hir_id);\n+        self.process_attrs(trait_item.def_id);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.process_attrs(impl_item.hir_id);\n+        self.process_attrs(impl_item.def_id);\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'tcx hir::ForeignItem<'tcx>) {\n-        self.process_attrs(foreign_item.hir_id);\n+        self.process_attrs(foreign_item.def_id);\n     }\n }"}, {"sha": "76d27c292262d8005500a67b5be2ca99cf80b1dc", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -82,7 +82,7 @@ fn associated_item_from_trait_item_ref(\n     parent_def_id: LocalDefId,\n     trait_item_ref: &hir::TraitItemRef,\n ) -> ty::AssocItem {\n-    let def_id = tcx.hir().local_def_id(trait_item_ref.id.hir_id);\n+    let def_id = trait_item_ref.id.def_id;\n     let (kind, has_self) = match trait_item_ref.kind {\n         hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n         hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n@@ -105,7 +105,7 @@ fn associated_item_from_impl_item_ref(\n     parent_def_id: LocalDefId,\n     impl_item_ref: &hir::ImplItemRef<'_>,\n ) -> ty::AssocItem {\n-    let def_id = tcx.hir().local_def_id(impl_item_ref.id.hir_id);\n+    let def_id = impl_item_ref.id.def_id;\n     let (kind, has_self) = match impl_item_ref.kind {\n         hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n         hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n@@ -130,7 +130,9 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n     let parent_item = tcx.hir().expect_item(parent_id);\n     match parent_item.kind {\n         hir::ItemKind::Impl(ref impl_) => {\n-            if let Some(impl_item_ref) = impl_.items.iter().find(|i| i.id.hir_id == id) {\n+            if let Some(impl_item_ref) =\n+                impl_.items.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n+            {\n                 let assoc_item =\n                     associated_item_from_impl_item_ref(tcx, parent_def_id, impl_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n@@ -139,7 +141,9 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n         }\n \n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-            if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.hir_id == id) {\n+            if let Some(trait_item_ref) =\n+                trait_item_refs.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n+            {\n                 let assoc_item =\n                     associated_item_from_trait_item_ref(tcx, parent_def_id, trait_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n@@ -196,17 +200,10 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     let item = tcx.hir().expect_item(id);\n     match item.kind {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n-            trait_item_refs\n-                .iter()\n-                .map(|trait_item_ref| trait_item_ref.id)\n-                .map(|id| tcx.hir().local_def_id(id.hir_id).to_def_id()),\n+            trait_item_refs.iter().map(|trait_item_ref| trait_item_ref.id.def_id.to_def_id()),\n         ),\n         hir::ItemKind::Impl(ref impl_) => tcx.arena.alloc_from_iter(\n-            impl_\n-                .items\n-                .iter()\n-                .map(|impl_item_ref| impl_item_ref.id)\n-                .map(|id| tcx.hir().local_def_id(id.hir_id).to_def_id()),\n+            impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.def_id.to_def_id()),\n         ),\n         hir::ItemKind::TraitAlias(..) => &[],\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),"}, {"sha": "2e1fb44d3b5739b57658f19bbf65b5304aac3909", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -2210,8 +2210,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 self.res_to_ty(opt_self_ty, path, false)\n             }\n             hir::TyKind::OpaqueDef(item_id, ref lifetimes) => {\n-                let opaque_ty = tcx.hir().expect_item(item_id.id);\n-                let def_id = tcx.hir().local_def_id(item_id.id).to_def_id();\n+                let opaque_ty = tcx.hir().item(item_id);\n+                let def_id = item_id.def_id.to_def_id();\n \n                 match opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => {"}, {"sha": "7729df6af349dded4f5b1e2b0388ba709a44c3c8", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -373,8 +373,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n     (fcx, gen_ty)\n }\n \n-pub(super) fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n-    let def_id = tcx.hir().local_def_id(id);\n+fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) {\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n@@ -387,8 +386,7 @@ pub(super) fn check_struct(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     check_packed(tcx, span, def);\n }\n \n-fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n-    let def_id = tcx.hir().local_def_id(id);\n+fn check_union(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) {\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n@@ -683,34 +681,32 @@ fn check_opaque_meets_bounds<'tcx>(\n \n pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n     debug!(\n-        \"check_item_type(it.hir_id={}, it.name={})\",\n-        it.hir_id,\n-        tcx.def_path_str(tcx.hir().local_def_id(it.hir_id).to_def_id())\n+        \"check_item_type(it.def_id={:?}, it.name={})\",\n+        it.def_id,\n+        tcx.def_path_str(it.def_id.to_def_id())\n     );\n     let _indenter = indenter();\n     match it.kind {\n         // Consts can play a role in type-checking, so they are included here.\n         hir::ItemKind::Static(..) => {\n-            let def_id = tcx.hir().local_def_id(it.hir_id);\n-            tcx.ensure().typeck(def_id);\n-            maybe_check_static_with_link_section(tcx, def_id, it.span);\n-            check_static_inhabited(tcx, def_id, it.span);\n+            tcx.ensure().typeck(it.def_id);\n+            maybe_check_static_with_link_section(tcx, it.def_id, it.span);\n+            check_static_inhabited(tcx, it.def_id, it.span);\n         }\n         hir::ItemKind::Const(..) => {\n-            tcx.ensure().typeck(tcx.hir().local_def_id(it.hir_id));\n+            tcx.ensure().typeck(it.def_id);\n         }\n         hir::ItemKind::Enum(ref enum_definition, _) => {\n-            check_enum(tcx, it.span, &enum_definition.variants, it.hir_id);\n+            check_enum(tcx, it.span, &enum_definition.variants, it.def_id);\n         }\n         hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n         hir::ItemKind::Impl(ref impl_) => {\n-            debug!(\"ItemKind::Impl {} with id {}\", it.ident, it.hir_id);\n-            let impl_def_id = tcx.hir().local_def_id(it.hir_id);\n-            if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n+            debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.def_id);\n+            if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.def_id) {\n                 check_impl_items_against_trait(\n                     tcx,\n                     it.span,\n-                    impl_def_id,\n+                    it.def_id,\n                     impl_trait_ref,\n                     &impl_.items,\n                 );\n@@ -719,8 +715,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n             }\n         }\n         hir::ItemKind::Trait(_, _, _, _, ref items) => {\n-            let def_id = tcx.hir().local_def_id(it.hir_id);\n-            check_on_unimplemented(tcx, def_id.to_def_id(), it);\n+            check_on_unimplemented(tcx, it.def_id.to_def_id(), it);\n \n             for item in items.iter() {\n                 let item = tcx.hir().trait_item(item.id);\n@@ -730,44 +725,40 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                         fn_maybe_err(tcx, item.ident.span, abi);\n                     }\n                     hir::TraitItemKind::Type(.., Some(_default)) => {\n-                        let item_def_id = tcx.hir().local_def_id(item.hir_id).to_def_id();\n-                        let assoc_item = tcx.associated_item(item_def_id);\n+                        let assoc_item = tcx.associated_item(item.def_id);\n                         let trait_substs =\n-                            InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                            InternalSubsts::identity_for_item(tcx, it.def_id.to_def_id());\n                         let _: Result<_, rustc_errors::ErrorReported> = check_type_bounds(\n                             tcx,\n                             assoc_item,\n                             assoc_item,\n                             item.span,\n-                            ty::TraitRef { def_id: def_id.to_def_id(), substs: trait_substs },\n+                            ty::TraitRef { def_id: it.def_id.to_def_id(), substs: trait_substs },\n                         );\n                     }\n                     _ => {}\n                 }\n             }\n         }\n         hir::ItemKind::Struct(..) => {\n-            check_struct(tcx, it.hir_id, it.span);\n+            check_struct(tcx, it.def_id, it.span);\n         }\n         hir::ItemKind::Union(..) => {\n-            check_union(tcx, it.hir_id, it.span);\n+            check_union(tcx, it.def_id, it.span);\n         }\n         hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n             // HACK(jynelson): trying to infer the type of `impl trait` breaks documenting\n             // `async-std` (and `pub async fn` in general).\n             // Since rustdoc doesn't care about the concrete type behind `impl Trait`, just don't look at it!\n             // See https://github.com/rust-lang/rust/issues/75100\n             if !tcx.sess.opts.actually_rustdoc {\n-                let def_id = tcx.hir().local_def_id(it.hir_id);\n-\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n-                check_opaque(tcx, def_id, substs, it.span, &origin);\n+                let substs = InternalSubsts::identity_for_item(tcx, it.def_id.to_def_id());\n+                check_opaque(tcx, it.def_id, substs, it.span, &origin);\n             }\n         }\n         hir::ItemKind::TyAlias(..) => {\n-            let def_id = tcx.hir().local_def_id(it.hir_id);\n-            let pty_ty = tcx.type_of(def_id);\n-            let generics = tcx.generics_of(def_id);\n+            let pty_ty = tcx.type_of(it.def_id);\n+            let generics = tcx.generics_of(it.def_id);\n             check_type_params_are_used(tcx, &generics, pty_ty);\n         }\n         hir::ItemKind::ForeignMod { abi, items } => {\n@@ -785,7 +776,7 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                 }\n             } else {\n                 for item in items {\n-                    let def_id = tcx.hir().local_def_id(item.id.hir_id);\n+                    let def_id = item.id.def_id;\n                     let generics = tcx.generics_of(def_id);\n                     let own_counts = generics.own_counts();\n                     if generics.params.len() - own_counts.lifetimes != 0 {\n@@ -835,9 +826,8 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n }\n \n pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, trait_def_id: DefId, item: &hir::Item<'_>) {\n-    let item_def_id = tcx.hir().local_def_id(item.hir_id);\n     // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id.to_def_id());\n+    let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item.def_id.to_def_id());\n }\n \n pub(super) fn check_specialization_validity<'tcx>(\n@@ -938,7 +928,7 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n-        let ty_impl_item = tcx.associated_item(tcx.hir().local_def_id(impl_item.hir_id));\n+        let ty_impl_item = tcx.associated_item(impl_item.def_id);\n \n         let mut items =\n             associated_items.filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id);\n@@ -1345,13 +1335,12 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: &'tcx ty\n }\n \n #[allow(trivial_numeric_casts)]\n-pub fn check_enum<'tcx>(\n+fn check_enum<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     vs: &'tcx [hir::Variant<'tcx>],\n-    id: hir::HirId,\n+    def_id: LocalDefId,\n ) {\n-    let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n "}, {"sha": "a30a81079335d7ab8ac07485c4adbc80c9d1c1a7", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -823,11 +823,11 @@ fn compare_synthetic_generics<'tcx>(\n                         // FIXME: this is obviously suboptimal since the name can already be used\n                         // as another generic argument\n                         let new_name = tcx.sess.source_map().span_to_snippet(trait_span).ok()?;\n-                        let trait_m = tcx.hir().local_def_id_to_hir_id(trait_m.def_id.as_local()?);\n-                        let trait_m = tcx.hir().trait_item(hir::TraitItemId { hir_id: trait_m });\n+                        let trait_m = trait_m.def_id.as_local()?;\n+                        let trait_m = tcx.hir().trait_item(hir::TraitItemId { def_id: trait_m });\n \n-                        let impl_m = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.as_local()?);\n-                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n+                        let impl_m = impl_m.def_id.as_local()?;\n+                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { def_id: impl_m });\n \n                         // in case there are no generics, take the spot between the function name\n                         // and the opening paren of the argument list\n@@ -860,8 +860,8 @@ fn compare_synthetic_generics<'tcx>(\n                 (None, Some(hir::SyntheticTyParamKind::ImplTrait)) => {\n                     err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n                     (|| {\n-                        let impl_m = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.as_local()?);\n-                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n+                        let impl_m = impl_m.def_id.as_local()?;\n+                        let impl_m = tcx.hir().impl_item(hir::ImplItemId { def_id: impl_m });\n                         let input_tys = match impl_m.kind {\n                             hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n                             _ => unreachable!(),"}, {"sha": "dedf96863eaf62875ba086d3248cf86920df2cd1", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -9,7 +9,6 @@ use crate::require_same_types;\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::traits::{ObligationCause, ObligationCauseCode};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, TyCtxt};\n@@ -21,7 +20,6 @@ use std::iter;\n fn equate_intrinsic_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     it: &hir::ForeignItem<'_>,\n-    def_id: DefId,\n     n_tps: usize,\n     sig: ty::PolyFnSig<'tcx>,\n ) {\n@@ -35,7 +33,7 @@ fn equate_intrinsic_type<'tcx>(\n         }\n     }\n \n-    let i_n_tps = tcx.generics_of(def_id).own_counts().types;\n+    let i_n_tps = tcx.generics_of(it.def_id).own_counts().types;\n     if i_n_tps != n_tps {\n         let span = match it.kind {\n             hir::ForeignItemKind::Fn(_, _, ref generics) => generics.span,\n@@ -51,8 +49,8 @@ fn equate_intrinsic_type<'tcx>(\n     }\n \n     let fty = tcx.mk_fn_ptr(sig);\n-    let cause = ObligationCause::new(it.span, it.hir_id, ObligationCauseCode::IntrinsicType);\n-    require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(def_id)), fty);\n+    let cause = ObligationCause::new(it.span, it.hir_id(), ObligationCauseCode::IntrinsicType);\n+    require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(it.def_id)), fty);\n }\n \n /// Returns `true` if the given intrinsic is unsafe to call or not.\n@@ -100,8 +98,7 @@ pub fn intrinsic_operation_unsafety(intrinsic: Symbol) -> hir::Unsafety {\n /// and in `library/core/src/intrinsics.rs`.\n pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)));\n-    let def_id = tcx.hir().local_def_id(it.hir_id).to_def_id();\n-    let intrinsic_name = tcx.item_name(def_id);\n+    let intrinsic_name = tcx.item_name(it.def_id.to_def_id());\n     let name_str = intrinsic_name.as_str();\n \n     let mk_va_list_ty = |mutbl| {\n@@ -370,7 +367,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     };\n     let sig = tcx.mk_fn_sig(inputs.into_iter(), output, false, unsafety, Abi::RustIntrinsic);\n     let sig = ty::Binder::bind(sig);\n-    equate_intrinsic_type(tcx, it, def_id, n_tps, sig)\n+    equate_intrinsic_type(tcx, it, n_tps, sig)\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n@@ -380,7 +377,6 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n         tcx.mk_ty_param(n, name)\n     };\n \n-    let def_id = tcx.hir().local_def_id(it.hir_id).to_def_id();\n     let name = it.ident.name;\n \n     let (n_tps, inputs, output) = match name {\n@@ -464,5 +460,5 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n         Abi::PlatformIntrinsic,\n     );\n     let sig = ty::Binder::dummy(sig);\n-    equate_intrinsic_type(tcx, it, def_id, n_tps, sig)\n+    equate_intrinsic_type(tcx, it, n_tps, sig)\n }"}, {"sha": "faa47230d3a068f5dae9404f7a771b297bc20726", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -11,7 +11,6 @@ use rustc_hir::intravisit;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::fast_reject::simplify_type;\n use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::{\n@@ -1352,17 +1351,15 @@ fn compute_all_traits(tcx: TyCtxt<'_>) -> Vec<DefId> {\n \n     // Crate-local:\n \n-    struct Visitor<'a, 'tcx> {\n-        map: &'a hir_map::Map<'tcx>,\n+    struct Visitor<'a> {\n         traits: &'a mut Vec<DefId>,\n     }\n \n-    impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n+    impl<'v, 'a> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a> {\n         fn visit_item(&mut self, i: &'v hir::Item<'v>) {\n             match i.kind {\n                 hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..) => {\n-                    let def_id = self.map.local_def_id(i.hir_id);\n-                    self.traits.push(def_id.to_def_id());\n+                    self.traits.push(i.def_id.to_def_id());\n                 }\n                 _ => (),\n             }\n@@ -1375,7 +1372,7 @@ fn compute_all_traits(tcx: TyCtxt<'_>) -> Vec<DefId> {\n         fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {}\n     }\n \n-    tcx.hir().krate().visit_all_item_likes(&mut Visitor { map: &tcx.hir(), traits: &mut traits });\n+    tcx.hir().krate().visit_all_item_likes(&mut Visitor { traits: &mut traits });\n \n     // Cross-crate:\n \n@@ -1445,8 +1442,8 @@ impl intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n             return;\n         }\n         // Find a `use` statement.\n-        for item_id in module.item_ids {\n-            let item = self.tcx.hir().expect_item(item_id.id);\n+        for &item_id in module.item_ids {\n+            let item = self.tcx.hir().item(item_id);\n             match item.kind {\n                 hir::ItemKind::Use(..) => {\n                     // Don't suggest placing a `use` before the prelude"}, {"sha": "00c6550835b435bfd872ddfb53b7ef2df1223338", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 30, "deletions": 39, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -80,8 +80,8 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let item = tcx.hir().expect_item(hir_id);\n \n     debug!(\n-        \"check_item_well_formed(it.hir_id={:?}, it.name={})\",\n-        item.hir_id,\n+        \"check_item_well_formed(it.def_id={:?}, it.name={})\",\n+        item.def_id,\n         tcx.def_path_str(def_id.to_def_id())\n     );\n \n@@ -105,7 +105,7 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         // for `T`\n         hir::ItemKind::Impl(ref impl_) => {\n             let is_auto = tcx\n-                .impl_trait_ref(tcx.hir().local_def_id(item.hir_id))\n+                .impl_trait_ref(item.def_id)\n                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n             if let (hir::Defaultness::Default { .. }, true) = (impl_.defaultness, is_auto) {\n                 let sp = impl_.of_trait.as_ref().map_or(item.span, |t| t.path.span);\n@@ -141,23 +141,23 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n             }\n         }\n         hir::ItemKind::Fn(ref sig, ..) => {\n-            check_item_fn(tcx, item.hir_id, item.ident, item.span, sig.decl);\n+            check_item_fn(tcx, item.hir_id(), item.ident, item.span, sig.decl);\n         }\n         hir::ItemKind::Static(ref ty, ..) => {\n-            check_item_type(tcx, item.hir_id, ty.span, false);\n+            check_item_type(tcx, item.hir_id(), ty.span, false);\n         }\n         hir::ItemKind::Const(ref ty, ..) => {\n-            check_item_type(tcx, item.hir_id, ty.span, false);\n+            check_item_type(tcx, item.hir_id(), ty.span, false);\n         }\n         hir::ItemKind::ForeignMod { items, .. } => {\n             for it in items.iter() {\n                 let it = tcx.hir().foreign_item(it.id);\n                 match it.kind {\n                     hir::ForeignItemKind::Fn(ref decl, ..) => {\n-                        check_item_fn(tcx, it.hir_id, it.ident, it.span, decl)\n+                        check_item_fn(tcx, it.hir_id(), it.ident, it.span, decl)\n                     }\n                     hir::ForeignItemKind::Static(ref ty, ..) => {\n-                        check_item_type(tcx, it.hir_id, ty.span, true)\n+                        check_item_type(tcx, it.hir_id(), ty.span, true)\n                     }\n                     hir::ForeignItemKind::Type => (),\n                 }\n@@ -197,7 +197,7 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         _ => None,\n     };\n     check_object_unsafe_self_trait_by_name(tcx, &trait_item);\n-    check_associated_item(tcx, trait_item.hir_id, trait_item.span, method_sig);\n+    check_associated_item(tcx, trait_item.hir_id(), trait_item.span, method_sig);\n }\n \n fn could_be_self(trait_def_id: LocalDefId, ty: &hir::Ty<'_>) -> bool {\n@@ -213,9 +213,9 @@ fn could_be_self(trait_def_id: LocalDefId, ty: &hir::Ty<'_>) -> bool {\n /// Detect when an object unsafe trait is referring to itself in one of its associated items.\n /// When this is done, suggest using `Self` instead.\n fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem<'_>) {\n-    let (trait_name, trait_def_id) = match tcx.hir().get(tcx.hir().get_parent_item(item.hir_id)) {\n+    let (trait_name, trait_def_id) = match tcx.hir().get(tcx.hir().get_parent_item(item.hir_id())) {\n         hir::Node::Item(item) => match item.kind {\n-            hir::ItemKind::Trait(..) => (item.ident, tcx.hir().local_def_id(item.hir_id)),\n+            hir::ItemKind::Trait(..) => (item.ident, item.def_id),\n             _ => return,\n         },\n         _ => return,\n@@ -271,7 +271,7 @@ pub fn check_impl_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         _ => None,\n     };\n \n-    check_associated_item(tcx, impl_item.hir_id, impl_item.span, method_sig);\n+    check_associated_item(tcx, impl_item.hir_id(), impl_item.span, method_sig);\n }\n \n fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n@@ -432,7 +432,7 @@ fn check_associated_item(\n }\n \n fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<'tcx> {\n-    for_id(tcx, item.hir_id, item.span)\n+    for_id(tcx, item.hir_id(), item.span)\n }\n \n fn for_id(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) -> CheckWfFcxBuilder<'_> {\n@@ -465,8 +465,7 @@ fn check_type_defn<'tcx, F>(\n {\n     for_item(tcx, item).with_fcx(|fcx, fcx_tcx| {\n         let variants = lookup_fields(fcx);\n-        let def_id = fcx.tcx.hir().local_def_id(item.hir_id);\n-        let packed = fcx.tcx.adt_def(def_id).repr.packed();\n+        let packed = fcx.tcx.adt_def(item.def_id).repr.packed();\n \n         for variant in &variants {\n             // For DST, or when drop needs to copy things around, all\n@@ -482,7 +481,7 @@ fn check_type_defn<'tcx, F>(\n                         // Just treat unresolved type expression as if it needs drop.\n                         true\n                     } else {\n-                        ty.needs_drop(fcx_tcx, fcx_tcx.param_env(def_id))\n+                        ty.needs_drop(fcx_tcx, fcx_tcx.param_env(item.def_id))\n                     }\n                 }\n             };\n@@ -541,23 +540,21 @@ fn check_type_defn<'tcx, F>(\n             }\n         }\n \n-        check_where_clauses(tcx, fcx, item.span, def_id.to_def_id(), None);\n+        check_where_clauses(tcx, fcx, item.span, item.def_id.to_def_id(), None);\n \n         // No implied bounds in a struct definition.\n         vec![]\n     });\n }\n \n fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n-    debug!(\"check_trait: {:?}\", item.hir_id);\n+    debug!(\"check_trait: {:?}\", item.def_id);\n \n-    let trait_def_id = tcx.hir().local_def_id(item.hir_id);\n-\n-    let trait_def = tcx.trait_def(trait_def_id);\n+    let trait_def = tcx.trait_def(item.def_id);\n     if trait_def.is_marker\n         || matches!(trait_def.specialization_kind, TraitSpecializationKind::Marker)\n     {\n-        for associated_def_id in &*tcx.associated_item_def_ids(trait_def_id) {\n+        for associated_def_id in &*tcx.associated_item_def_ids(item.def_id) {\n             struct_span_err!(\n                 tcx.sess,\n                 tcx.def_span(*associated_def_id),\n@@ -569,7 +566,7 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     }\n \n     for_item(tcx, item).with_fcx(|fcx, _| {\n-        check_where_clauses(tcx, fcx, item.span, trait_def_id.to_def_id(), None);\n+        check_where_clauses(tcx, fcx, item.span, item.def_id.to_def_id(), None);\n \n         vec![]\n     });\n@@ -665,14 +662,12 @@ fn check_impl<'tcx>(\n     debug!(\"check_impl: {:?}\", item);\n \n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n-        let item_def_id = fcx.tcx.hir().local_def_id(item.hir_id);\n-\n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n-                let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n+                let trait_ref = fcx.tcx.impl_trait_ref(item.def_id).unwrap();\n                 let trait_ref =\n                     fcx.normalize_associated_types_in(ast_trait_ref.path.span, trait_ref);\n                 let obligations = traits::wf::trait_obligations(\n@@ -688,7 +683,7 @@ fn check_impl<'tcx>(\n                 }\n             }\n             None => {\n-                let self_ty = fcx.tcx.type_of(item_def_id);\n+                let self_ty = fcx.tcx.type_of(item.def_id);\n                 let self_ty = fcx.normalize_associated_types_in(item.span, self_ty);\n                 fcx.register_wf_obligation(\n                     self_ty.into(),\n@@ -698,9 +693,9 @@ fn check_impl<'tcx>(\n             }\n         }\n \n-        check_where_clauses(tcx, fcx, item.span, item_def_id.to_def_id(), None);\n+        check_where_clauses(tcx, fcx, item.span, item.def_id.to_def_id(), None);\n \n-        fcx.impl_implied_bounds(item_def_id.to_def_id(), item.span)\n+        fcx.impl_implied_bounds(item.def_id.to_def_id(), item.span)\n     });\n }\n \n@@ -1238,15 +1233,14 @@ fn check_variances_for_type_defn<'tcx>(\n     item: &hir::Item<'tcx>,\n     hir_generics: &hir::Generics<'_>,\n ) {\n-    let item_def_id = tcx.hir().local_def_id(item.hir_id);\n-    let ty = tcx.type_of(item_def_id);\n+    let ty = tcx.type_of(item.def_id);\n     if tcx.has_error_field(ty) {\n         return;\n     }\n \n-    let ty_predicates = tcx.predicates_of(item_def_id);\n+    let ty_predicates = tcx.predicates_of(item.def_id);\n     assert_eq!(ty_predicates.parent, None);\n-    let variances = tcx.variances_of(item_def_id);\n+    let variances = tcx.variances_of(item.def_id);\n \n     let mut constrained_parameters: FxHashSet<_> = variances\n         .iter()\n@@ -1354,22 +1348,19 @@ impl Visitor<'tcx> for CheckTypeWellFormedVisitor<'tcx> {\n \n     fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n         debug!(\"visit_item: {:?}\", i);\n-        let def_id = self.tcx.hir().local_def_id(i.hir_id);\n-        self.tcx.ensure().check_item_well_formed(def_id);\n+        self.tcx.ensure().check_item_well_formed(i.def_id);\n         hir_visit::walk_item(self, i);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n-        let def_id = self.tcx.hir().local_def_id(trait_item.hir_id);\n-        self.tcx.ensure().check_trait_item_well_formed(def_id);\n+        self.tcx.ensure().check_trait_item_well_formed(trait_item.def_id);\n         hir_visit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n-        let def_id = self.tcx.hir().local_def_id(impl_item.hir_id);\n-        self.tcx.ensure().check_impl_item_well_formed(def_id);\n+        self.tcx.ensure().check_impl_item_well_formed(impl_item.def_id);\n         hir_visit::walk_impl_item(self, impl_item);\n     }\n "}, {"sha": "e1743a5dfc1ced6eddd9a0a6720add44d49f8aa6", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -28,7 +28,7 @@ impl ItemLikeVisitor<'v> for CheckVisitor<'tcx> {\n             return;\n         }\n         if let hir::ItemKind::Use(ref path, _) = item.kind {\n-            self.check_import(item.hir_id, path.span);\n+            self.check_import(item.item_id(), path.span);\n         }\n     }\n \n@@ -45,24 +45,28 @@ struct CheckVisitor<'tcx> {\n }\n \n impl CheckVisitor<'tcx> {\n-    fn check_import(&self, id: hir::HirId, span: Span) {\n-        let def_id = self.tcx.hir().local_def_id(id);\n-        if !self.tcx.maybe_unused_trait_import(def_id) {\n+    fn check_import(&self, item_id: hir::ItemId, span: Span) {\n+        if !self.tcx.maybe_unused_trait_import(item_id.def_id) {\n             return;\n         }\n \n-        if self.used_trait_imports.contains(&def_id) {\n+        if self.used_trait_imports.contains(&item_id.def_id) {\n             return;\n         }\n \n-        self.tcx.struct_span_lint_hir(lint::builtin::UNUSED_IMPORTS, id, span, |lint| {\n-            let msg = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                format!(\"unused import: `{}`\", snippet)\n-            } else {\n-                \"unused import\".to_owned()\n-            };\n-            lint.build(&msg).emit();\n-        });\n+        self.tcx.struct_span_lint_hir(\n+            lint::builtin::UNUSED_IMPORTS,\n+            item_id.hir_id(),\n+            span,\n+            |lint| {\n+                let msg = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                    format!(\"unused import: `{}`\", snippet)\n+                } else {\n+                    \"unused import\".to_owned()\n+                };\n+                lint.build(&msg).emit();\n+            },\n+        );\n     }\n }\n \n@@ -109,7 +113,6 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     // Collect all the extern crates (in a reliable order).\n     let mut crates_to_lint = vec![];\n     tcx.hir().krate().visit_all_item_likes(&mut CollectExternCrateVisitor {\n-        tcx,\n         crates_to_lint: &mut crates_to_lint,\n     });\n \n@@ -189,8 +192,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     }\n }\n \n-struct CollectExternCrateVisitor<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct CollectExternCrateVisitor<'a> {\n     crates_to_lint: &'a mut Vec<ExternCrateToLint>,\n }\n \n@@ -211,12 +213,11 @@ struct ExternCrateToLint {\n     warn_if_unused: bool,\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n+impl<'a, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n-            let extern_crate_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             self.crates_to_lint.push(ExternCrateToLint {\n-                def_id: extern_crate_def_id.to_def_id(),\n+                def_id: item.def_id.to_def_id(),\n                 span: item.span,\n                 orig_name,\n                 warn_if_unused: !item.ident.as_str().starts_with('_'),"}, {"sha": "5b44cb7eae51649650b83cdea4d29dc148407166", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -38,8 +38,7 @@ impl<'tcx> Checker<'tcx> {\n         F: FnMut(TyCtxt<'tcx>, LocalDefId),\n     {\n         if Some(self.trait_def_id) == trait_def_id {\n-            for &impl_id in self.tcx.hir().trait_impls(self.trait_def_id) {\n-                let impl_def_id = self.tcx.hir().local_def_id(impl_id);\n+            for &impl_def_id in self.tcx.hir().trait_impls(self.trait_def_id) {\n                 f(self.tcx, impl_def_id);\n             }\n         }"}, {"sha": "cc592c7a260f12bb946a8bb3f74416a09f5dd063", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -50,8 +50,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             _ => return,\n         };\n \n-        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-        let self_ty = self.tcx.type_of(def_id);\n+        let self_ty = self.tcx.type_of(item.def_id);\n         let lang_items = self.tcx.lang_items();\n         match *self_ty.kind() {\n             ty::Adt(def, _) => {\n@@ -65,7 +64,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Bool => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.bool_impl(),\n                     None,\n                     \"bool\",\n@@ -76,7 +75,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Char => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.char_impl(),\n                     None,\n                     \"char\",\n@@ -87,7 +86,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Str => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.str_impl(),\n                     lang_items.str_alloc_impl(),\n                     \"str\",\n@@ -98,7 +97,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Slice(slice_item) if slice_item == self.tcx.types.u8 => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.slice_u8_impl(),\n                     lang_items.slice_u8_alloc_impl(),\n                     \"slice_u8\",\n@@ -109,7 +108,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Slice(_) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.slice_impl(),\n                     lang_items.slice_alloc_impl(),\n                     \"slice\",\n@@ -120,7 +119,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Array(_, _) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.array_impl(),\n                     None,\n                     \"array\",\n@@ -133,7 +132,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                 if matches!(inner.kind(), ty::Slice(_)) =>\n             {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.const_slice_ptr_impl(),\n                     None,\n                     \"const_slice_ptr\",\n@@ -146,7 +145,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                 if matches!(inner.kind(), ty::Slice(_)) =>\n             {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.mut_slice_ptr_impl(),\n                     None,\n                     \"mut_slice_ptr\",\n@@ -157,7 +156,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Not }) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.const_ptr_impl(),\n                     None,\n                     \"const_ptr\",\n@@ -168,7 +167,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mut }) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.mut_ptr_impl(),\n                     None,\n                     \"mut_ptr\",\n@@ -179,7 +178,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Int(ty::IntTy::I8) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.i8_impl(),\n                     None,\n                     \"i8\",\n@@ -190,7 +189,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Int(ty::IntTy::I16) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.i16_impl(),\n                     None,\n                     \"i16\",\n@@ -201,7 +200,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Int(ty::IntTy::I32) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.i32_impl(),\n                     None,\n                     \"i32\",\n@@ -212,7 +211,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Int(ty::IntTy::I64) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.i64_impl(),\n                     None,\n                     \"i64\",\n@@ -223,7 +222,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Int(ty::IntTy::I128) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.i128_impl(),\n                     None,\n                     \"i128\",\n@@ -234,7 +233,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Int(ty::IntTy::Isize) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.isize_impl(),\n                     None,\n                     \"isize\",\n@@ -245,7 +244,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Uint(ty::UintTy::U8) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.u8_impl(),\n                     None,\n                     \"u8\",\n@@ -256,7 +255,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Uint(ty::UintTy::U16) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.u16_impl(),\n                     None,\n                     \"u16\",\n@@ -267,7 +266,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Uint(ty::UintTy::U32) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.u32_impl(),\n                     None,\n                     \"u32\",\n@@ -278,7 +277,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Uint(ty::UintTy::U64) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.u64_impl(),\n                     None,\n                     \"u64\",\n@@ -289,7 +288,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Uint(ty::UintTy::U128) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.u128_impl(),\n                     None,\n                     \"u128\",\n@@ -300,7 +299,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Uint(ty::UintTy::Usize) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.usize_impl(),\n                     None,\n                     \"usize\",\n@@ -311,7 +310,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Float(ty::FloatTy::F32) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.f32_impl(),\n                     lang_items.f32_runtime_impl(),\n                     \"f32\",\n@@ -322,7 +321,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             }\n             ty::Float(ty::FloatTy::F64) => {\n                 self.check_primitive_impl(\n-                    def_id,\n+                    item.def_id,\n                     lang_items.f64_impl(),\n                     lang_items.f64_runtime_impl(),\n                     \"f64\",\n@@ -369,9 +368,8 @@ impl InherentCollect<'tcx> {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n-            let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             let vec = self.impls_map.inherent_impls.entry(def_id).or_default();\n-            vec.push(impl_def_id.to_def_id());\n+            vec.push(item.def_id.to_def_id());\n         } else {\n             struct_span_err!(\n                 self.tcx.sess,"}, {"sha": "29654099992029e45ce61ca8bd4ea1286c8ee9fd", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -123,8 +123,7 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Trait(..)\n             | hir::ItemKind::Union(..) => {\n-                let ty_def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let impls = self.tcx.inherent_impls(ty_def_id);\n+                let impls = self.tcx.inherent_impls(item.def_id);\n \n                 // If there is only one inherent impl block,\n                 // there is nothing to overlap check it with"}, {"sha": "05906817914c676ee22b02d30d27035166b9d7d1", "filename": "compiler/rustc_typeck/src/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -172,8 +172,7 @@ fn coherent_trait(tcx: TyCtxt<'_>, def_id: DefId) {\n     tcx.ensure().specialization_graph_of(def_id);\n \n     let impls = tcx.hir().trait_impls(def_id);\n-    for &hir_id in impls {\n-        let impl_def_id = tcx.hir().local_def_id(hir_id);\n+    for &impl_def_id in impls {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n \n         check_impl(tcx, impl_def_id, trait_ref);"}, {"sha": "05932427bcf7a4299691c027b54bcd660a187856", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -24,21 +24,20 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n     /// to prevent inundating the user with a bunch of similar error\n     /// reports.\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         // \"Trait\" impl\n         if let hir::ItemKind::Impl(hir::Impl {\n             generics, of_trait: Some(ref tr), self_ty, ..\n         }) = &item.kind\n         {\n             debug!(\n                 \"coherence2::orphan check: trait impl {}\",\n-                self.tcx.hir().node_to_string(item.hir_id)\n+                self.tcx.hir().node_to_string(item.hir_id())\n             );\n-            let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n+            let trait_ref = self.tcx.impl_trait_ref(item.def_id).unwrap();\n             let trait_def_id = trait_ref.def_id;\n             let sm = self.tcx.sess.source_map();\n             let sp = sm.guess_head_span(item.span);\n-            match traits::orphan_check(self.tcx, def_id.to_def_id()) {\n+            match traits::orphan_check(self.tcx, item.def_id.to_def_id()) {\n                 Ok(()) => {}\n                 Err(traits::OrphanCheckErr::NonLocalInputType(tys)) => {\n                     let mut err = struct_span_err!("}, {"sha": "6b995b9738612bbf4eea56389b1bfc19ce781e6d", "filename": "compiler/rustc_typeck/src/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Funsafety.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -24,8 +24,7 @@ impl UnsafetyChecker<'tcx> {\n         unsafety: hir::Unsafety,\n         polarity: hir::ImplPolarity,\n     ) {\n-        let local_did = self.tcx.hir().local_def_id(item.hir_id);\n-        if let Some(trait_ref) = self.tcx.impl_trait_ref(local_did) {\n+        if let Some(trait_ref) = self.tcx.impl_trait_ref(item.def_id) {\n             let trait_def = self.tcx.trait_def(trait_ref.def_id);\n             let unsafe_attr = impl_generics.and_then(|generics| {\n                 generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\")"}, {"sha": "fc8e50b4b65ba850738d346394dcd192742bcbbf", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -240,7 +240,7 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        convert_item(self.tcx, item.hir_id);\n+        convert_item(self.tcx, item.item_id());\n         reject_placeholder_type_signatures_in_item(self.tcx, item);\n         intravisit::walk_item(self, item);\n     }\n@@ -274,12 +274,12 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        convert_trait_item(self.tcx, trait_item.hir_id);\n+        convert_trait_item(self.tcx, trait_item.trait_item_id());\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        convert_impl_item(self.tcx, impl_item.hir_id);\n+        convert_impl_item(self.tcx, impl_item.impl_item_id());\n         intravisit::walk_impl_item(self, impl_item);\n     }\n }\n@@ -707,10 +707,10 @@ fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty<'_>, param_id: hir::HirId) -> bool\n     }\n }\n \n-fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n-    let it = tcx.hir().expect_item(item_id);\n-    debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n-    let def_id = tcx.hir().local_def_id(item_id);\n+fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n+    let it = tcx.hir().item(item_id);\n+    debug!(\"convert: item {} with id {}\", it.ident, it.hir_id());\n+    let def_id = item_id.def_id;\n \n     match it.kind {\n         // These don't define types.\n@@ -721,12 +721,11 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n         hir::ItemKind::ForeignMod { items, .. } => {\n             for item in items {\n                 let item = tcx.hir().foreign_item(item.id);\n-                let def_id = tcx.hir().local_def_id(item.hir_id);\n-                tcx.ensure().generics_of(def_id);\n-                tcx.ensure().type_of(def_id);\n-                tcx.ensure().predicates_of(def_id);\n+                tcx.ensure().generics_of(item.def_id);\n+                tcx.ensure().type_of(item.def_id);\n+                tcx.ensure().predicates_of(item.def_id);\n                 if let hir::ForeignItemKind::Fn(..) = item.kind {\n-                    tcx.ensure().fn_sig(def_id);\n+                    tcx.ensure().fn_sig(item.def_id);\n                 }\n             }\n         }\n@@ -797,40 +796,39 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n     }\n }\n \n-fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n-    let trait_item = tcx.hir().expect_trait_item(trait_item_id);\n-    let def_id = tcx.hir().local_def_id(trait_item.hir_id);\n-    tcx.ensure().generics_of(def_id);\n+fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n+    let trait_item = tcx.hir().trait_item(trait_item_id);\n+    tcx.ensure().generics_of(trait_item_id.def_id);\n \n     match trait_item.kind {\n         hir::TraitItemKind::Fn(..) => {\n-            tcx.ensure().type_of(def_id);\n-            tcx.ensure().fn_sig(def_id);\n+            tcx.ensure().type_of(trait_item_id.def_id);\n+            tcx.ensure().fn_sig(trait_item_id.def_id);\n         }\n \n         hir::TraitItemKind::Const(.., Some(_)) => {\n-            tcx.ensure().type_of(def_id);\n+            tcx.ensure().type_of(trait_item_id.def_id);\n         }\n \n         hir::TraitItemKind::Const(..) => {\n-            tcx.ensure().type_of(def_id);\n+            tcx.ensure().type_of(trait_item_id.def_id);\n             // Account for `const C: _;`.\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_trait_item(trait_item);\n             placeholder_type_error(tcx, None, &[], visitor.0, false, None);\n         }\n \n         hir::TraitItemKind::Type(_, Some(_)) => {\n-            tcx.ensure().item_bounds(def_id);\n-            tcx.ensure().type_of(def_id);\n+            tcx.ensure().item_bounds(trait_item_id.def_id);\n+            tcx.ensure().type_of(trait_item_id.def_id);\n             // Account for `type T = _;`.\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_trait_item(trait_item);\n             placeholder_type_error(tcx, None, &[], visitor.0, false, None);\n         }\n \n         hir::TraitItemKind::Type(_, None) => {\n-            tcx.ensure().item_bounds(def_id);\n+            tcx.ensure().item_bounds(trait_item_id.def_id);\n             // #74612: Visit and try to find bad placeholders\n             // even if there is no concrete type.\n             let mut visitor = PlaceholderHirTyCollector::default();\n@@ -840,15 +838,15 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n         }\n     };\n \n-    tcx.ensure().predicates_of(def_id);\n+    tcx.ensure().predicates_of(trait_item_id.def_id);\n }\n \n-fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n-    let def_id = tcx.hir().local_def_id(impl_item_id);\n+fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n+    let def_id = impl_item_id.def_id;\n     tcx.ensure().generics_of(def_id);\n     tcx.ensure().type_of(def_id);\n     tcx.ensure().predicates_of(def_id);\n-    let impl_item = tcx.hir().expect_impl_item(impl_item_id);\n+    let impl_item = tcx.hir().impl_item(impl_item_id);\n     match impl_item.kind {\n         hir::ImplItemKind::Fn(..) => {\n             tcx.ensure().fn_sig(def_id);\n@@ -1115,7 +1113,7 @@ fn super_predicates_that_define_assoc_type(\n         let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n         let superbounds2 = icx.type_parameter_bounds_in_generics(\n             generics,\n-            item.hir_id,\n+            item.hir_id(),\n             self_param_ty,\n             OnlySelfBounds(!is_trait_alias),\n             assoc_name,\n@@ -1439,12 +1437,12 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                     //\n                     // Something of a hack: use the node id for the trait, also as\n                     // the node id for the Self type parameter.\n-                    let param_id = item.hir_id;\n+                    let param_id = item.def_id;\n \n                     opt_self = Some(ty::GenericParamDef {\n                         index: 0,\n                         name: kw::SelfUpper,\n-                        def_id: tcx.hir().local_def_id(param_id).to_def_id(),\n+                        def_id: param_id.to_def_id(),\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n                             has_default: false,"}, {"sha": "a2aa3b308ec77bc17e67172b74d8f366fe4c2c55", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -582,26 +582,23 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if def_id.to_def_id() != self.def_id {\n-                self.check(def_id);\n+            if it.def_id.to_def_id() != self.def_id {\n+                self.check(it.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if def_id.to_def_id() != self.def_id {\n-                self.check(def_id);\n+            if it.def_id.to_def_id() != self.def_id {\n+                self.check(it.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n-            self.check(def_id);\n+            self.check(it.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n     }"}, {"sha": "7713381e62e467b8c739cf026e1e6b92f983591d", "filename": "compiler/rustc_typeck/src/impl_wf_check.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -59,7 +59,7 @@ pub fn impl_wf_check(tcx: TyCtxt<'_>) {\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n     for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id(module));\n+        tcx.ensure().check_mod_impl_wf(module);\n     }\n }\n \n@@ -81,11 +81,10 @@ struct ImplWfCheck<'tcx> {\n impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if let hir::ItemKind::Impl(ref impl_) = item.kind {\n-            let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n-            enforce_impl_params_are_constrained(self.tcx, impl_def_id, impl_.items);\n+            enforce_impl_params_are_constrained(self.tcx, item.def_id, impl_.items);\n             enforce_impl_items_are_distinct(self.tcx, impl_.items);\n             if self.min_specialization {\n-                check_min_specialization(self.tcx, impl_def_id.to_def_id(), item.span);\n+                check_min_specialization(self.tcx, item.def_id.to_def_id(), item.span);\n             }\n         }\n     }\n@@ -131,7 +130,7 @@ fn enforce_impl_params_are_constrained(\n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n     let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs\n         .iter()\n-        .map(|item_ref| tcx.hir().local_def_id(item_ref.id.hir_id))\n+        .map(|item_ref| item_ref.id.def_id)\n         .flat_map(|def_id| {\n             let item = tcx.associated_item(def_id);\n             match item.kind {"}, {"sha": "6ddc26efeae35ac8a402f452edfe5182df83b817", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -369,7 +369,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n     tcx.sess.track_errors(|| {\n         tcx.sess.time(\"type_collecting\", || {\n             for &module in tcx.hir().krate().modules.keys() {\n-                tcx.ensure().collect_mod_item_types(tcx.hir().local_def_id(module));\n+                tcx.ensure().collect_mod_item_types(module);\n             }\n         });\n     })?;\n@@ -401,7 +401,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n     // NOTE: This is copy/pasted in librustdoc/core.rs and should be kept in sync.\n     tcx.sess.time(\"item_types_checking\", || {\n         for &module in tcx.hir().krate().modules.keys() {\n-            tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n+            tcx.ensure().check_mod_item_types(module);\n         }\n     });\n "}, {"sha": "6e6ecf6a22b51815c0976a62b36d6c467ff5901d", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -2,7 +2,6 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::Node;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n@@ -53,16 +52,10 @@ pub struct InferVisitor<'cx, 'tcx> {\n \n impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let item_did = self.tcx.hir().local_def_id(item.hir_id);\n+        let item_did = item.def_id;\n \n         debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n \n-        let hir_id = self.tcx.hir().local_def_id_to_hir_id(item_did);\n-        let item = match self.tcx.hir().get(hir_id) {\n-            Node::Item(item) => item,\n-            _ => bug!(),\n-        };\n-\n         let mut item_required_predicates = RequiredPredicates::default();\n         match item.kind {\n             hir::ItemKind::Union(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Struct(..) => {"}, {"sha": "d4bef0c409a8f1f9a9e7fa6a8f8d614121744111", "filename": "compiler/rustc_typeck/src/outlives/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Ftest.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -14,12 +14,10 @@ struct OutlivesTest<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for OutlivesTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n-\n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id.to_def_id(), sym::rustc_outlives) {\n-            let inferred_outlives_of = self.tcx.inferred_outlives_of(item_def_id);\n+        if self.tcx.has_attr(item.def_id.to_def_id(), sym::rustc_outlives) {\n+            let inferred_outlives_of = self.tcx.inferred_outlives_of(item.def_id);\n             struct_span_err!(self.tcx.sess, item.span, E0640, \"{:?}\", inferred_outlives_of).emit();\n         }\n     }"}, {"sha": "f5355ea042bdf4a13dce6a5ad7e0d43316ae4e69", "filename": "compiler/rustc_typeck/src/variance/constraints.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -71,15 +71,15 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         match item.kind {\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                self.visit_node_helper(item.hir_id);\n+                self.visit_node_helper(item.hir_id());\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n                     self.visit_node_helper(struct_def.ctor_hir_id().unwrap());\n                 }\n             }\n \n             hir::ItemKind::Enum(ref enum_def, _) => {\n-                self.visit_node_helper(item.hir_id);\n+                self.visit_node_helper(item.hir_id());\n \n                 for variant in enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.data {\n@@ -89,7 +89,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             }\n \n             hir::ItemKind::Fn(..) => {\n-                self.visit_node_helper(item.hir_id);\n+                self.visit_node_helper(item.hir_id());\n             }\n \n             _ => {}\n@@ -98,19 +98,19 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n         if let hir::TraitItemKind::Fn(..) = trait_item.kind {\n-            self.visit_node_helper(trait_item.hir_id);\n+            self.visit_node_helper(trait_item.hir_id());\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n         if let hir::ImplItemKind::Fn(..) = impl_item.kind {\n-            self.visit_node_helper(impl_item.hir_id);\n+            self.visit_node_helper(impl_item.hir_id());\n         }\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem<'_>) {\n         if let hir::ForeignItemKind::Fn(..) = foreign_item.kind {\n-            self.visit_node_helper(foreign_item.hir_id);\n+            self.visit_node_helper(foreign_item.hir_id());\n         }\n     }\n }"}, {"sha": "5d5baf78d33c3f064653d31015a1eaa276a31307", "filename": "compiler/rustc_typeck/src/variance/terms.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fterms.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -128,19 +128,19 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        debug!(\"add_inferreds for item {}\", self.tcx.hir().node_to_string(item.hir_id));\n+        debug!(\"add_inferreds for item {}\", self.tcx.hir().node_to_string(item.hir_id()));\n \n         match item.kind {\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                self.add_inferreds_for_item(item.hir_id);\n+                self.add_inferreds_for_item(item.hir_id());\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n                     self.add_inferreds_for_item(struct_def.ctor_hir_id().unwrap());\n                 }\n             }\n \n             hir::ItemKind::Enum(ref enum_def, _) => {\n-                self.add_inferreds_for_item(item.hir_id);\n+                self.add_inferreds_for_item(item.hir_id());\n \n                 for variant in enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.data {\n@@ -150,7 +150,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n             }\n \n             hir::ItemKind::Fn(..) => {\n-                self.add_inferreds_for_item(item.hir_id);\n+                self.add_inferreds_for_item(item.hir_id());\n             }\n \n             _ => {}\n@@ -159,19 +159,19 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n         if let hir::TraitItemKind::Fn(..) = trait_item.kind {\n-            self.add_inferreds_for_item(trait_item.hir_id);\n+            self.add_inferreds_for_item(trait_item.hir_id());\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n         if let hir::ImplItemKind::Fn(..) = impl_item.kind {\n-            self.add_inferreds_for_item(impl_item.hir_id);\n+            self.add_inferreds_for_item(impl_item.hir_id());\n         }\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem<'_>) {\n         if let hir::ForeignItemKind::Fn(..) = foreign_item.kind {\n-            self.add_inferreds_for_item(foreign_item.hir_id);\n+            self.add_inferreds_for_item(foreign_item.hir_id());\n         }\n     }\n }"}, {"sha": "2a0d950c87dabd68a2079ef64820e0e9c8d83eb5", "filename": "compiler/rustc_typeck/src/variance/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Ftest.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -14,12 +14,10 @@ struct VarianceTest<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n-\n         // For unit testing: check for a special \"rustc_variance\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id.to_def_id(), sym::rustc_variance) {\n-            let variances_of = self.tcx.variances_of(item_def_id);\n+        if self.tcx.has_attr(item.def_id.to_def_id(), sym::rustc_variance) {\n+            let variances_of = self.tcx.variances_of(item.def_id);\n             struct_span_err!(self.tcx.sess, item.span, E0208, \"{:?}\", variances_of).emit();\n         }\n     }"}, {"sha": "1b3d3b52cdbdf9cad2a8558ba5b6c89cc9b01b39", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -133,18 +133,17 @@ impl Clean<ExternalCrate> for CrateNum {\n                 .item_ids\n                 .iter()\n                 .filter_map(|&id| {\n-                    let item = cx.tcx.hir().expect_item(id.id);\n+                    let item = cx.tcx.hir().item(id);\n                     match item.kind {\n-                        hir::ItemKind::Mod(_) => as_primitive(Res::Def(\n-                            DefKind::Mod,\n-                            cx.tcx.hir().local_def_id(id.id).to_def_id(),\n-                        )),\n+                        hir::ItemKind::Mod(_) => {\n+                            as_primitive(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n+                        }\n                         hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                             if item.vis.node.is_pub() =>\n                         {\n                             as_primitive(path.res).map(|(_, prim)| {\n                                 // Pretend the primitive is local.\n-                                (cx.tcx.hir().local_def_id(id.id).to_def_id(), prim)\n+                                (id.def_id.to_def_id(), prim)\n                             })\n                         }\n                         _ => None,\n@@ -185,18 +184,15 @@ impl Clean<ExternalCrate> for CrateNum {\n                 .item_ids\n                 .iter()\n                 .filter_map(|&id| {\n-                    let item = cx.tcx.hir().expect_item(id.id);\n+                    let item = cx.tcx.hir().item(id);\n                     match item.kind {\n-                        hir::ItemKind::Mod(_) => as_keyword(Res::Def(\n-                            DefKind::Mod,\n-                            cx.tcx.hir().local_def_id(id.id).to_def_id(),\n-                        )),\n+                        hir::ItemKind::Mod(_) => {\n+                            as_keyword(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n+                        }\n                         hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                             if item.vis.node.is_pub() =>\n                         {\n-                            as_keyword(path.res).map(|(_, prim)| {\n-                                (cx.tcx.hir().local_def_id(id.id).to_def_id(), prim)\n-                            })\n+                            as_keyword(path.res).map(|(_, prim)| (id.def_id.to_def_id(), prim))\n                         }\n                         _ => None,\n                     }\n@@ -912,7 +908,7 @@ fn clean_fn_or_proc_macro(\n         }\n         None => {\n             let mut func = (sig, generics, body_id).clean(cx);\n-            let def_id = cx.tcx.hir().local_def_id(item.hir_id).to_def_id();\n+            let def_id = item.def_id.to_def_id();\n             func.header.constness =\n                 if is_const_fn(cx.tcx, def_id) && is_unstable_const_fn(cx.tcx, def_id).is_none() {\n                     hir::Constness::Const\n@@ -1048,7 +1044,7 @@ impl Clean<TypeKind> for hir::def::DefKind {\n \n impl Clean<Item> for hir::TraitItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let local_did = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n+        let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, || {\n             let inner = match self.kind {\n                 hir::TraitItemKind::Const(ref ty, default) => {\n@@ -1089,7 +1085,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n \n impl Clean<Item> for hir::ImplItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let local_did = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n+        let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, || {\n             let inner = match self.kind {\n                 hir::ImplItemKind::Const(ref ty, expr) => {\n@@ -1120,7 +1116,7 @@ impl Clean<Item> for hir::ImplItem<'_> {\n \n             let what_rustc_thinks =\n                 Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx);\n-            let parent_item = cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(self.hir_id));\n+            let parent_item = cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(self.hir_id()));\n             if let hir::ItemKind::Impl(impl_) = &parent_item.kind {\n                 if impl_.of_trait.is_some() {\n                     // Trait impl items always inherit the impl's visibility --\n@@ -1475,7 +1471,7 @@ impl Clean<Type> for hir::Ty<'_> {\n             }\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n             TyKind::OpaqueDef(item_id, _) => {\n-                let item = cx.tcx.hir().expect_item(item_id.id);\n+                let item = cx.tcx.hir().item(item_id);\n                 if let hir::ItemKind::OpaqueTy(ref ty) = item.kind {\n                     ImplTrait(ty.bounds.clean(cx))\n                 } else {\n@@ -1950,8 +1946,8 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n         use hir::ItemKind;\n \n         let (item, renamed) = self;\n-        let def_id = cx.tcx.hir().local_def_id(item.hir_id).to_def_id();\n-        let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id));\n+        let def_id = item.def_id.to_def_id();\n+        let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n         cx.with_param_env(def_id, || {\n             let kind = match item.kind {\n                 ItemKind::Static(ty, mutability, body_id) => {\n@@ -1999,7 +1995,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                     fields: variant_data.fields().clean(cx),\n                     fields_stripped: false,\n                 }),\n-                ItemKind::Impl(ref impl_) => return clean_impl(impl_, item.hir_id, cx),\n+                ItemKind::Impl(ref impl_) => return clean_impl(impl_, item.hir_id(), cx),\n                 // proc macros can have a name set by attributes\n                 ItemKind::Fn(ref sig, ref generics, body_id) => {\n                     clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n@@ -2107,8 +2103,7 @@ fn clean_extern_crate(\n     cx: &DocContext<'_>,\n ) -> Vec<Item> {\n     // this is the ID of the `extern crate` statement\n-    let def_id = cx.tcx.hir().local_def_id(krate.hir_id);\n-    let cnum = cx.tcx.extern_mod_stmt_cnum(def_id).unwrap_or(LOCAL_CRATE);\n+    let cnum = cx.tcx.extern_mod_stmt_cnum(krate.def_id).unwrap_or(LOCAL_CRATE);\n     // this is the ID of the crate itself\n     let crate_def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n     let please_inline = krate.vis.node.is_pub()\n@@ -2127,7 +2122,7 @@ fn clean_extern_crate(\n \n         if let Some(items) = inline::try_inline(\n             cx,\n-            cx.tcx.parent_module(krate.hir_id).to_def_id(),\n+            cx.tcx.parent_module(krate.hir_id()).to_def_id(),\n             res,\n             name,\n             Some(krate.attrs),\n@@ -2196,7 +2191,6 @@ fn clean_use_statement(\n \n     // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n     // crate in Rust 2018+\n-    let def_id = cx.tcx.hir().local_def_id(import.hir_id).to_def_id();\n     let path = path.clean(cx);\n     let inner = if kind == hir::UseKind::Glob {\n         if !denied {\n@@ -2221,14 +2215,14 @@ fn clean_use_statement(\n \n             if let Some(mut items) = inline::try_inline(\n                 cx,\n-                cx.tcx.parent_module(import.hir_id).to_def_id(),\n+                cx.tcx.parent_module(import.hir_id()).to_def_id(),\n                 path.res,\n                 name,\n                 Some(import.attrs),\n                 &mut visited,\n             ) {\n                 items.push(Item::from_def_id_and_parts(\n-                    def_id,\n+                    import.def_id.to_def_id(),\n                     None,\n                     ImportItem(Import::new_simple(name, resolve_use_source(cx, path), false)),\n                     cx,\n@@ -2239,16 +2233,16 @@ fn clean_use_statement(\n         Import::new_simple(name, resolve_use_source(cx, path), true)\n     };\n \n-    vec![Item::from_def_id_and_parts(def_id, None, ImportItem(inner), cx)]\n+    vec![Item::from_def_id_and_parts(import.def_id.to_def_id(), None, ImportItem(inner), cx)]\n }\n \n impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let (item, renamed) = self;\n-        cx.with_param_env(cx.tcx.hir().local_def_id(item.hir_id).to_def_id(), || {\n+        cx.with_param_env(item.def_id.to_def_id(), || {\n             let kind = match item.kind {\n                 hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n-                    let abi = cx.tcx.hir().get_foreign_abi(item.hir_id);\n+                    let abi = cx.tcx.hir().get_foreign_abi(item.hir_id());\n                     let (generics, decl) = enter_impl_trait(cx, || {\n                         (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n                     });\n@@ -2270,7 +2264,7 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n             };\n \n             Item::from_hir_id_and_parts(\n-                item.hir_id,\n+                item.hir_id(),\n                 Some(renamed.unwrap_or(item.ident.name)),\n                 kind,\n                 cx,\n@@ -2297,7 +2291,7 @@ impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n             )\n         } else {\n             let vis = item.vis.clean(cx);\n-            let def_id = cx.tcx.hir().local_def_id(item.hir_id).to_def_id();\n+            let def_id = item.def_id.to_def_id();\n \n             if matchers.len() <= 1 {\n                 format!(\n@@ -2320,7 +2314,7 @@ impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n         };\n \n         Item::from_hir_id_and_parts(\n-            item.hir_id,\n+            item.hir_id(),\n             Some(name),\n             MacroItem(Macro { source, imported_from: None }),\n             cx,"}, {"sha": "d79c47bbe3de652fe804204259b91df3d63ff977", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -479,7 +479,7 @@ crate fn run_global_ctxt(\n     // NOTE: This is copy/pasted from typeck/lib.rs and should be kept in sync with those changes.\n     tcx.sess.time(\"item_types_checking\", || {\n         for &module in tcx.hir().krate().modules.keys() {\n-            tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n+            tcx.ensure().check_mod_item_types(module);\n         }\n     });\n     tcx.sess.abort_if_errors();\n@@ -488,8 +488,7 @@ crate fn run_global_ctxt(\n     });\n     tcx.sess.time(\"check_mod_attrs\", || {\n         for &module in tcx.hir().krate().modules.keys() {\n-            let local_def_id = tcx.hir().local_def_id(module);\n-            tcx.ensure().check_mod_attrs(local_def_id);\n+            tcx.ensure().check_mod_attrs(module);\n         }\n     });\n "}, {"sha": "c3b9fd5a1dd4284d681e0fdc726fe0cb11c43ffb", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -1050,27 +1050,45 @@ impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx>\n             item.ident.to_string()\n         };\n \n-        self.visit_testable(name, &item.attrs, item.hir_id, item.span, |this| {\n+        self.visit_testable(name, &item.attrs, item.hir_id(), item.span, |this| {\n             intravisit::walk_item(this, item);\n         });\n     }\n \n     fn visit_trait_item(&mut self, item: &'hir hir::TraitItem<'_>) {\n-        self.visit_testable(item.ident.to_string(), &item.attrs, item.hir_id, item.span, |this| {\n-            intravisit::walk_trait_item(this, item);\n-        });\n+        self.visit_testable(\n+            item.ident.to_string(),\n+            &item.attrs,\n+            item.hir_id(),\n+            item.span,\n+            |this| {\n+                intravisit::walk_trait_item(this, item);\n+            },\n+        );\n     }\n \n     fn visit_impl_item(&mut self, item: &'hir hir::ImplItem<'_>) {\n-        self.visit_testable(item.ident.to_string(), &item.attrs, item.hir_id, item.span, |this| {\n-            intravisit::walk_impl_item(this, item);\n-        });\n+        self.visit_testable(\n+            item.ident.to_string(),\n+            &item.attrs,\n+            item.hir_id(),\n+            item.span,\n+            |this| {\n+                intravisit::walk_impl_item(this, item);\n+            },\n+        );\n     }\n \n     fn visit_foreign_item(&mut self, item: &'hir hir::ForeignItem<'_>) {\n-        self.visit_testable(item.ident.to_string(), &item.attrs, item.hir_id, item.span, |this| {\n-            intravisit::walk_foreign_item(this, item);\n-        });\n+        self.visit_testable(\n+            item.ident.to_string(),\n+            &item.attrs,\n+            item.hir_id(),\n+            item.span,\n+            |this| {\n+                intravisit::walk_foreign_item(this, item);\n+            },\n+        );\n     }\n \n     fn visit_variant(\n@@ -1094,7 +1112,7 @@ impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx>\n         self.visit_testable(\n             macro_def.ident.to_string(),\n             &macro_def.attrs,\n-            macro_def.hir_id,\n+            macro_def.hir_id(),\n             macro_def.span,\n             |_| (),\n         );"}, {"sha": "0951a9c2c9794169314d256befd671a670e1e05c", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -58,8 +58,8 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     // doesn't work with it anyway, so pull them from the HIR map instead\n     let mut extra_attrs = Vec::new();\n     for &trait_did in cx.tcx.all_traits(LOCAL_CRATE).iter() {\n-        for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n-            let impl_did = cx.tcx.hir().local_def_id(impl_node).to_def_id();\n+        for &impl_did in cx.tcx.hir().trait_impls(trait_did) {\n+            let impl_did = impl_did.to_def_id();\n             cx.tcx.sess.prof.generic_activity(\"build_local_trait_impl\").run(|| {\n                 let mut parent = cx.tcx.parent(impl_did);\n                 while let Some(did) = parent {"}, {"sha": "e92ea55caa7377b626beabc0fcada545bca63427", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             // (since a direct parent isn't necessarily a module, c.f. #77828).\n             let macro_parent_def_id = {\n                 use rustc_middle::ty::DefIdTree;\n-                tcx.parent(tcx.hir().local_def_id(def.hir_id).to_def_id()).unwrap()\n+                tcx.parent(def.def_id.to_def_id()).unwrap()\n             };\n             let macro_parent_path = tcx.def_path(macro_parent_def_id);\n             // HACK: rustdoc has no way to lookup `doctree::Module`s by their HirId. Instead,\n@@ -132,8 +132,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= vis.node.is_pub();\n-        for i in m.item_ids {\n-            let item = self.cx.tcx.hir().expect_item(i.id);\n+        for &i in m.item_ids {\n+            let item = self.cx.tcx.hir().item(i);\n             self.visit_item(item, None, &mut om);\n         }\n         self.inside_public_path = orig_inside_public_path;\n@@ -231,8 +231,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let ret = match tcx.hir().get(res_hir_id) {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                for i in m.item_ids {\n-                    let i = self.cx.tcx.hir().expect_item(i.id);\n+                for &i in m.item_ids {\n+                    let i = self.cx.tcx.hir().item(i);\n                     self.visit_item(i, None, om);\n                 }\n                 self.inlining = prev;\n@@ -270,8 +270,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let name = renamed.unwrap_or(item.ident.name);\n \n         if item.vis.node.is_pub() {\n-            let def_id = self.cx.tcx.hir().local_def_id(item.hir_id);\n-            self.store_path(def_id.to_def_id());\n+            self.store_path(item.def_id.to_def_id());\n         }\n \n         match item.kind {\n@@ -305,7 +304,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     });\n                     let ident = if is_glob { None } else { Some(name) };\n                     if self.maybe_inline_local(\n-                        item.hir_id,\n+                        item.hir_id(),\n                         path.res,\n                         ident,\n                         is_glob,\n@@ -322,7 +321,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.mods.push(self.visit_mod_contents(\n                     item.span,\n                     &item.vis,\n-                    item.hir_id,\n+                    item.hir_id(),\n                     m,\n                     Some(name),\n                 ));"}, {"sha": "004bce5f62a8f74e4e850a1ecd0ca2d0b51a4f23", "filename": "src/tools/clippy/clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -38,7 +38,7 @@ impl<'tcx> LateLintPass<'tcx> for CopyIterator {\n             ..\n         }) = item.kind\n         {\n-            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.hir_id));\n+            let ty = cx.tcx.type_of(item.def_id);\n \n             if is_copy(cx, ty) && match_path(&trait_ref.path, &paths::ITERATOR) {\n                 span_lint_and_note("}, {"sha": "e8510bde9adcd4fb74a505092b99b912236bfdc7", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -169,7 +169,7 @@ impl<'tcx> LateLintPass<'tcx> for Derive {\n             ..\n         }) = item.kind\n         {\n-            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.hir_id));\n+            let ty = cx.tcx.type_of(item.def_id);\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);"}, {"sha": "67b7cf91958655e65e93e671a3e3ac1499f67acc", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -216,18 +216,17 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n         let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, _, body_id) => {\n-                if !(is_entrypoint_fn(cx, cx.tcx.hir().local_def_id(item.hir_id).to_def_id())\n+                if !(is_entrypoint_fn(cx, item.def_id.to_def_id())\n                     || in_external_macro(cx.tcx.sess, item.span))\n                 {\n                     let body = cx.tcx.hir().body(body_id);\n-                    let impl_item_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n                     let mut fpu = FindPanicUnwrap {\n                         cx,\n-                        typeck_results: cx.tcx.typeck(impl_item_def_id),\n+                        typeck_results: cx.tcx.typeck(item.def_id),\n                         panic_span: None,\n                     };\n                     fpu.visit_expr(&body.value);\n-                    lint_for_missing_headers(cx, item.hir_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n+                    lint_for_missing_headers(cx, item.hir_id(), item.span, sig, headers, Some(body_id), fpu.panic_span);\n                 }\n             },\n             hir::ItemKind::Impl(ref impl_) => {\n@@ -247,7 +246,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n         let headers = check_attrs(cx, &self.valid_idents, &item.attrs);\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n             if !in_external_macro(cx.tcx.sess, item.span) {\n-                lint_for_missing_headers(cx, item.hir_id, item.span, sig, headers, None, None);\n+                lint_for_missing_headers(cx, item.hir_id(), item.span, sig, headers, None, None);\n             }\n         }\n     }\n@@ -259,14 +258,13 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n         }\n         if let hir::ImplItemKind::Fn(ref sig, body_id) = item.kind {\n             let body = cx.tcx.hir().body(body_id);\n-            let impl_item_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n             let mut fpu = FindPanicUnwrap {\n                 cx,\n-                typeck_results: cx.tcx.typeck(impl_item_def_id),\n+                typeck_results: cx.tcx.typeck(item.def_id),\n                 panic_span: None,\n             };\n             fpu.visit_expr(&body.value);\n-            lint_for_missing_headers(cx, item.hir_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n+            lint_for_missing_headers(cx, item.hir_id(), item.span, sig, headers, Some(body_id), fpu.panic_span);\n         }\n     }\n }"}, {"sha": "077c3b75fb8c837508fef72290b42571f59715c1", "filename": "src/tools/clippy/clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -49,9 +49,8 @@ impl<'tcx> LateLintPass<'tcx> for EmptyEnum {\n             return;\n         }\n \n-        let did = cx.tcx.hir().local_def_id(item.hir_id);\n         if let ItemKind::Enum(..) = item.kind {\n-            let ty = cx.tcx.type_of(did);\n+            let ty = cx.tcx.type_of(item.def_id);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n             if adt.variants.is_empty() {\n                 span_lint_and_help("}, {"sha": "f8ef2a464d5c31aa929ce65aba6a53f64307f92d", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -87,11 +87,11 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n             // find `self` ty for this trait if relevant\n             if let ItemKind::Trait(_, _, _, _, items) = item.kind {\n                 for trait_item in items {\n-                    if trait_item.id.hir_id == hir_id {\n+                    if trait_item.id.hir_id() == hir_id {\n                         // be sure we have `self` parameter in this function\n                         if let AssocItemKind::Fn { has_self: true } = trait_item.kind {\n                             trait_self_ty =\n-                                Some(TraitRef::identity(cx.tcx, trait_item.id.hir_id.owner.to_def_id()).self_ty());\n+                                Some(TraitRef::identity(cx.tcx, trait_item.id.def_id.to_def_id()).self_ty());\n                         }\n                     }\n                 }"}, {"sha": "ab9be3398bfa6749e3ab6e25d382776ed849a9dc", "filename": "src/tools/clippy/clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -72,7 +72,7 @@ impl LateLintPass<'_> for ExhaustiveItems {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         if_chain! {\n             if let ItemKind::Enum(..) | ItemKind::Struct(..) = item.kind;\n-            if cx.access_levels.is_exported(item.hir_id);\n+            if cx.access_levels.is_exported(item.hir_id());\n             if !item.attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n             then {\n                 let (lint, msg) = if let ItemKind::Struct(ref v, ..) = item.kind {"}, {"sha": "6d522c7ef3398d231cdd10244b2e8c47054b45fd", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -52,10 +52,9 @@ declare_lint_pass!(FallibleImplFrom => [FALLIBLE_IMPL_FROM]);\n impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         // check for `impl From<???> for ..`\n-        let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         if_chain! {\n             if let hir::ItemKind::Impl(impl_) = &item.kind;\n-            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(item.def_id);\n             if cx.tcx.is_diagnostic_item(sym::from_trait, impl_trait_ref.def_id);\n             then {\n                 lint_impl_body(cx, item.span, impl_.items);\n@@ -117,10 +116,9 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n             then {\n                 // check the body for `begin_panic` or `unwrap`\n                 let body = cx.tcx.hir().body(body_id);\n-                let impl_item_def_id = cx.tcx.hir().local_def_id(impl_item.id.hir_id);\n                 let mut fpu = FindPanicUnwrap {\n                     lcx: cx,\n-                    typeck_results: cx.tcx.typeck(impl_item_def_id),\n+                    typeck_results: cx.tcx.typeck(impl_item.id.def_id),\n                     result: Vec::new(),\n                 };\n                 fpu.visit_expr(&body.value);"}, {"sha": "b644bb079908f821a0a699506aae9cb0ad5d132a", "filename": "src/tools/clippy/clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -60,10 +60,9 @@ impl LateLintPass<'_> for FromOverInto {\n             return;\n         }\n \n-        let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         if_chain! {\n             if let hir::ItemKind::Impl{ .. } = &item.kind;\n-            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(item.def_id);\n             if match_def_path(cx, impl_trait_ref.def_id, &INTO);\n \n             then {"}, {"sha": "0c6bf8bbdf24adc943cbebbdf2cb196274c9b3ca", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -283,13 +283,13 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         let attr = must_use_attr(&item.attrs);\n         if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n-            let is_public = cx.access_levels.is_exported(item.hir_id);\n+            let is_public = cx.access_levels.is_exported(item.hir_id());\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             if is_public {\n                 check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n             }\n             if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n+                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n                 return;\n             }\n             if is_public && !is_proc_macro(cx.sess(), &item.attrs) && attr_by_name(&item.attrs, \"no_mangle\").is_none() {\n@@ -298,7 +298,7 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n                     &sig.decl,\n                     cx.tcx.hir().body(*body_id),\n                     item.span,\n-                    item.hir_id,\n+                    item.hir_id(),\n                     item.span.with_hi(sig.decl.output.span().hi()),\n                     \"this function could have a `#[must_use]` attribute\",\n                 );\n@@ -308,24 +308,24 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n         if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n-            let is_public = cx.access_levels.is_exported(item.hir_id);\n+            let is_public = cx.access_levels.is_exported(item.hir_id());\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-            if is_public && trait_ref_of_method(cx, item.hir_id).is_none() {\n+            if is_public && trait_ref_of_method(cx, item.hir_id()).is_none() {\n                 check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n             }\n             let attr = must_use_attr(&item.attrs);\n             if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n+                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n             } else if is_public\n                 && !is_proc_macro(cx.sess(), &item.attrs)\n-                && trait_ref_of_method(cx, item.hir_id).is_none()\n+                && trait_ref_of_method(cx, item.hir_id()).is_none()\n             {\n                 check_must_use_candidate(\n                     cx,\n                     &sig.decl,\n                     cx.tcx.hir().body(*body_id),\n                     item.span,\n-                    item.hir_id,\n+                    item.hir_id(),\n                     item.span.with_hi(sig.decl.output.span().hi()),\n                     \"this method could have a `#[must_use]` attribute\",\n                 );\n@@ -339,27 +339,27 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n             if sig.header.abi == Abi::Rust {\n                 self.check_arg_number(cx, &sig.decl, item.span.with_hi(sig.decl.output.span().hi()));\n             }\n-            let is_public = cx.access_levels.is_exported(item.hir_id);\n+            let is_public = cx.access_levels.is_exported(item.hir_id());\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             if is_public {\n                 check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n             }\n \n             let attr = must_use_attr(&item.attrs);\n             if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n+                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n             }\n             if let hir::TraitFn::Provided(eid) = *eid {\n                 let body = cx.tcx.hir().body(eid);\n-                Self::check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id);\n+                Self::check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id());\n \n                 if attr.is_none() && is_public && !is_proc_macro(cx.sess(), &item.attrs) {\n                     check_must_use_candidate(\n                         cx,\n                         &sig.decl,\n                         body,\n                         item.span,\n-                        item.hir_id,\n+                        item.hir_id(),\n                         item.span.with_hi(sig.decl.output.span().hi()),\n                         \"this method could have a `#[must_use]` attribute\",\n                     );"}, {"sha": "005c461f105e60a7e3f4582788572d84cd81547b", "filename": "src/tools/clippy/clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_impl.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -59,20 +59,15 @@ impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n             // but filter out implementations that have generic params (type or lifetime)\n             // or are derived from a macro\n             if !in_macro(item.span) && generics.params.is_empty() {\n-                self.impls.insert(item.hir_id.owner.to_def_id(), item.span);\n+                self.impls.insert(item.def_id.to_def_id(), item.span);\n             }\n         }\n     }\n \n     fn check_crate_post(&mut self, cx: &LateContext<'tcx>, krate: &'tcx Crate<'_>) {\n-        if let Some(item) = krate.items.values().next() {\n+        if !krate.items.is_empty() {\n             // Retrieve all inherent implementations from the crate, grouped by type\n-            for impls in cx\n-                .tcx\n-                .crate_inherent_impls(item.hir_id.owner.to_def_id().krate)\n-                .inherent_impls\n-                .values()\n-            {\n+            for impls in cx.tcx.crate_inherent_impls(def_id::LOCAL_CRATE).inherent_impls.values() {\n                 // Filter out implementations that have generic params (type or lifetime)\n                 let mut impl_spans = impls.iter().filter_map(|impl_def| self.impls.get(impl_def));\n                 if let Some(initial_span) = impl_spans.next() {"}, {"sha": "76e7a4992d345c4c57738d2a9636adb3ec582472", "filename": "src/tools/clippy/clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -108,10 +108,10 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n             if decl.inputs.len() == 1;\n \n             // Check if return type is String\n-            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym::string_type);\n+            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id()), sym::string_type);\n \n             // Filters instances of to_string which are required by a trait\n-            if trait_ref_of_method(cx, impl_item.hir_id).is_none();\n+            if trait_ref_of_method(cx, impl_item.hir_id()).is_none();\n \n             then {\n                 show_lint(cx, impl_item);\n@@ -124,8 +124,7 @@ fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n     let display_trait_id = get_trait_def_id(cx, &paths::DISPLAY_TRAIT).expect(\"Failed to get trait ID of `Display`!\");\n \n     // Get the real type of 'self'\n-    let fn_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-    let self_type = cx.tcx.fn_sig(fn_def_id).input(0);\n+    let self_type = cx.tcx.fn_sig(item.def_id).input(0);\n     let self_type = self_type.skip_binder().peel_refs();\n \n     // Emit either a warning or an error"}, {"sha": "ab4cb33612d380f0cddb11b0d1b5eec75bf4c253", "filename": "src/tools/clippy/clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -62,9 +62,8 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n         if in_external_macro(cx.tcx.sess, item.span) {\n             return;\n         }\n-        let did = cx.tcx.hir().local_def_id(item.hir_id);\n         if let ItemKind::Enum(ref def, _) = item.kind {\n-            let ty = cx.tcx.type_of(did);\n+            let ty = cx.tcx.type_of(item.def_id);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n \n             let mut largest_variant: Option<(_, _)> = None;"}, {"sha": "dab3e0565cafb30d8dd4e0240a782909355dbb81", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -159,10 +159,7 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n     fn is_named_self(cx: &LateContext<'_>, item: &TraitItemRef, name: &str) -> bool {\n         item.ident.name.as_str() == name\n             && if let AssocItemKind::Fn { has_self } = item.kind {\n-                has_self && {\n-                    let did = cx.tcx.hir().local_def_id(item.id.hir_id);\n-                    cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n-                }\n+                has_self && { cx.tcx.fn_sig(item.id.def_id).inputs().skip_binder().len() == 1 }\n             } else {\n                 false\n             }\n@@ -177,10 +174,9 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.hir_id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n+    if cx.access_levels.is_exported(visited_trait.hir_id()) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n         let mut current_and_super_traits = FxHashSet::default();\n-        let visited_trait_def_id = cx.tcx.hir().local_def_id(visited_trait.hir_id);\n-        fill_trait_set(visited_trait_def_id.to_def_id(), &mut current_and_super_traits, cx);\n+        fill_trait_set(visited_trait.def_id.to_def_id(), &mut current_and_super_traits, cx);\n \n         let is_empty_method_found = current_and_super_traits\n             .iter()\n@@ -210,17 +206,14 @@ fn check_impl_items(cx: &LateContext<'_>, item: &Item<'_>, impl_items: &[ImplIte\n     fn is_named_self(cx: &LateContext<'_>, item: &ImplItemRef<'_>, name: &str) -> bool {\n         item.ident.name.as_str() == name\n             && if let AssocItemKind::Fn { has_self } = item.kind {\n-                has_self && {\n-                    let did = cx.tcx.hir().local_def_id(item.id.hir_id);\n-                    cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n-                }\n+                has_self && cx.tcx.fn_sig(item.id.def_id).inputs().skip_binder().len() == 1\n             } else {\n                 false\n             }\n     }\n \n     let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n-        if cx.access_levels.is_exported(is_empty.id.hir_id) {\n+        if cx.access_levels.is_exported(is_empty.id.hir_id()) {\n             return;\n         }\n         \"a private\"\n@@ -229,9 +222,8 @@ fn check_impl_items(cx: &LateContext<'_>, item: &Item<'_>, impl_items: &[ImplIte\n     };\n \n     if let Some(i) = impl_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n-        if cx.access_levels.is_exported(i.id.hir_id) {\n-            let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-            let ty = cx.tcx.type_of(def_id);\n+        if cx.access_levels.is_exported(i.id.hir_id()) {\n+            let ty = cx.tcx.type_of(item.def_id);\n \n             span_lint(\n                 cx,"}, {"sha": "50e6383263dd3fd0ec424b32f77e35a9c39e02c8", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Fn(ref sig, id) = item.kind {\n-            let report_extra_lifetimes = trait_ref_of_method(cx, item.hir_id).is_none();\n+            let report_extra_lifetimes = trait_ref_of_method(cx, item.hir_id()).is_none();\n             check_fn_inner(\n                 cx,\n                 &sig.decl,\n@@ -375,7 +375,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n         match ty.kind {\n             TyKind::OpaqueDef(item, _) => {\n                 let map = self.cx.tcx.hir();\n-                let item = map.expect_item(item.id);\n+                let item = map.item(item);\n                 walk_item(self, item);\n                 walk_ty(self, ty);\n             },"}, {"sha": "2e2e693592c8853d22eaffafffd45f0f72992626", "filename": "src/tools/clippy/clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -102,7 +102,7 @@ fn future_trait_ref<'tcx>(\n ) -> Option<(&'tcx TraitRef<'tcx>, Vec<LifetimeName>)> {\n     if_chain! {\n         if let TyKind::OpaqueDef(item_id, bounds) = ty.kind;\n-        let item = cx.tcx.hir().item(item_id.id);\n+        let item = cx.tcx.hir().item(item_id);\n         if let ItemKind::OpaqueTy(opaque) = &item.kind;\n         if let Some(trait_ref) = opaque.bounds.iter().find_map(|bound| {\n             if let GenericBound::Trait(poly, _) = bound {"}, {"sha": "55660cc95a8e07df19f11a9f928691fb65fed724", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -1685,10 +1685,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             return;\n         }\n         let name = impl_item.ident.name.as_str();\n-        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id);\n+        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n         let item = cx.tcx.hir().expect_item(parent);\n-        let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-        let self_ty = cx.tcx.type_of(def_id);\n+        let self_ty = cx.tcx.type_of(item.def_id);\n \n         // if this impl block implements a trait, lint in trait definition instead\n         if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = item.kind {\n@@ -1699,8 +1698,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind;\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n \n-            let method_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n-            let method_sig = cx.tcx.fn_sig(method_def_id);\n+            let method_sig = cx.tcx.fn_sig(impl_item.def_id);\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n \n             let first_arg_ty = &method_sig.inputs().iter().next();\n@@ -1709,7 +1707,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if let Some(first_arg_ty) = first_arg_ty;\n \n             then {\n-                if cx.access_levels.is_exported(impl_item.hir_id) {\n+                if cx.access_levels.is_exported(impl_item.hir_id()) {\n                     // check missing trait implementations\n                     for method_config in &TRAIT_METHODS {\n                         if name == method_config.method_name &&\n@@ -1751,7 +1749,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         }\n \n         if let hir::ImplItemKind::Fn(_, _) = impl_item.kind {\n-            let ret_ty = return_ty(cx, impl_item.hir_id);\n+            let ret_ty = return_ty(cx, impl_item.hir_id());\n \n             // walk the return type and check for Self (this does not check associated types)\n             if contains_ty(ret_ty, self_ty) {\n@@ -1792,7 +1790,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if let Some(first_arg_ty) = sig.decl.inputs.iter().next();\n             let first_arg_span = first_arg_ty.span;\n             let first_arg_ty = hir_ty_to_ty(cx.tcx, first_arg_ty);\n-            let self_ty = TraitRef::identity(cx.tcx, item.hir_id.owner.to_def_id()).self_ty();\n+            let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty();\n \n             then {\n                 lint_wrong_self_convention(cx, &item.ident.name.as_str(), false, self_ty, first_arg_ty, first_arg_span);\n@@ -1802,8 +1800,8 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         if_chain! {\n             if item.ident.name == sym::new;\n             if let TraitItemKind::Fn(_, _) = item.kind;\n-            let ret_ty = return_ty(cx, item.hir_id);\n-            let self_ty = TraitRef::identity(cx.tcx, item.hir_id.owner.to_def_id()).self_ty();\n+            let ret_ty = return_ty(cx, item.hir_id());\n+            let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty();\n             if !contains_ty(ret_ty, self_ty);\n \n             then {"}, {"sha": "761b9261772b2a170fc71f209c325b2918c9036f", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -135,8 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.ident.name == sym::main {\n-                    let def_id = it.hir_id.owner;\n-                    let def_key = cx.tcx.hir().def_key(def_id);\n+                    let def_key = cx.tcx.hir().def_key(it.def_id);\n                     if def_key.parent == Some(hir::def_id::CRATE_DEF_INDEX) {\n                         return;\n                     }\n@@ -159,23 +158,20 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             | hir::ItemKind::Use(..) => return,\n         };\n \n-        let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n \n         self.check_missing_docs_attrs(cx, &it.attrs, it.span, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx hir::TraitItem<'_>) {\n-        let def_id = cx.tcx.hir().local_def_id(trait_item.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n \n         self.check_missing_docs_attrs(cx, &trait_item.attrs, trait_item.span, article, desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n         // If the method is an impl for a trait, don't doc.\n-        let def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n-        match cx.tcx.associated_item(def_id).container {\n+        match cx.tcx.associated_item(impl_item.def_id).container {\n             ty::TraitContainer(_) => return,\n             ty::ImplContainer(cid) => {\n                 if cx.tcx.impl_trait_ref(cid).is_some() {\n@@ -184,7 +180,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             },\n         }\n \n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n         self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, article, desc);\n     }\n "}, {"sha": "47d7c5306c4331b45a6f48efeefac69eef59ac65", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             return;\n         }\n \n-        if !cx.access_levels.is_exported(it.hir_id) {\n+        if !cx.access_levels.is_exported(it.hir_id()) {\n             return;\n         }\n         match it.kind {\n@@ -107,7 +107,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n                                 // trait method with default body needs inline in case\n                                 // an impl is not provided\n                                 let desc = \"a default trait method\";\n-                                let item = cx.tcx.hir().expect_trait_item(tit.id.hir_id);\n+                                let item = cx.tcx.hir().trait_item(tit.id);\n                                 check_missing_inline_attrs(cx, &item.attrs, item.span, desc);\n                             }\n                         },\n@@ -138,7 +138,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n         }\n \n         // If the item being implemented is not exported, then we don't need #[inline]\n-        if !cx.access_levels.is_exported(impl_item.hir_id) {\n+        if !cx.access_levels.is_exported(impl_item.hir_id()) {\n             return;\n         }\n \n@@ -147,14 +147,13 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             hir::ImplItemKind::Const(..) | hir::ImplItemKind::TyAlias(_) => return,\n         };\n \n-        let def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n-        let trait_def_id = match cx.tcx.associated_item(def_id).container {\n+        let trait_def_id = match cx.tcx.associated_item(impl_item.def_id).container {\n             TraitContainer(cid) => Some(cid),\n             ImplContainer(cid) => cx.tcx.impl_trait_ref(cid).map(|t| t.def_id),\n         };\n \n         if let Some(trait_def_id) = trait_def_id {\n-            if trait_def_id.is_local() && !cx.access_levels.is_exported(impl_item.hir_id) {\n+            if trait_def_id.is_local() && !cx.access_levels.is_exported(impl_item.hir_id()) {\n                 // If a trait is being implemented for an item, and the\n                 // trait is not exported, we don't need #[inline]\n                 return;"}, {"sha": "908b7bb7ce00d13359c619bda5f54d812e89fb95", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -57,21 +57,21 @@ declare_lint_pass!(MutableKeyType => [ MUTABLE_KEY_TYPE ]);\n impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         if let hir::ItemKind::Fn(ref sig, ..) = item.kind {\n-            check_sig(cx, item.hir_id, &sig.decl);\n+            check_sig(cx, item.hir_id(), &sig.decl);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'tcx>) {\n         if let hir::ImplItemKind::Fn(ref sig, ..) = item.kind {\n-            if trait_ref_of_method(cx, item.hir_id).is_none() {\n-                check_sig(cx, item.hir_id, &sig.decl);\n+            if trait_ref_of_method(cx, item.hir_id()).is_none() {\n+                check_sig(cx, item.hir_id(), &sig.decl);\n             }\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'tcx>) {\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n-            check_sig(cx, item.hir_id, &sig.decl);\n+            check_sig(cx, item.hir_id(), &sig.decl);\n         }\n     }\n "}, {"sha": "1453ea6e8975da8856806e7f819f2748c8fc516c", "filename": "src/tools/clippy/clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -5,11 +5,12 @@\n use crate::utils::{is_automatically_derived, snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, BorrowKind, Expr, ExprKind, HirId, Item, Mutability, Pat, PatKind};\n+use rustc_hir::{BindingAnnotation, BorrowKind, Expr, ExprKind, Item, Mutability, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::def_id::LocalDefId;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for address of operations (`&`) that are going to\n@@ -35,7 +36,7 @@ declare_clippy_lint! {\n \n #[derive(Default)]\n pub struct NeedlessBorrow {\n-    derived_item: Option<HirId>,\n+    derived_item: Option<LocalDefId>,\n }\n \n impl_lint_pass!(NeedlessBorrow => [NEEDLESS_BORROW]);\n@@ -117,13 +118,13 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n     fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if is_automatically_derived(item.attrs) {\n             debug_assert!(self.derived_item.is_none());\n-            self.derived_item = Some(item.hir_id);\n+            self.derived_item = Some(item.def_id);\n         }\n     }\n \n     fn check_item_post(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let Some(id) = self.derived_item {\n-            if item.hir_id == id {\n+            if item.def_id == id {\n                 self.derived_item = None;\n             }\n         }"}, {"sha": "de2899c3462a4f6f8b71a0a727140c09f93e6232", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                     }\n                     if let hir::ImplItemKind::Fn(ref sig, _) = impl_item.kind {\n                         let name = impl_item.ident.name;\n-                        let id = impl_item.hir_id;\n+                        let id = impl_item.hir_id();\n                         if sig.header.constness == hir::Constness::Const {\n                             // can't be implemented by default\n                             return;"}, {"sha": "8aebce67917afa1559e16925ced20f8f16238bf7", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -271,7 +271,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Const(hir_ty, body_id) = &impl_item.kind {\n-            let item_hir_id = cx.tcx.hir().get_parent_node(impl_item.hir_id);\n+            let item_hir_id = cx.tcx.hir().get_parent_node(impl_item.hir_id());\n             let item = cx.tcx.hir().expect_item(item_hir_id);\n \n             match &item.kind {"}, {"sha": "3d6129aa78d4c47d71d832eb4b76d803fdc90c2d", "filename": "src/tools/clippy/clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n                         span_lint_hir(\n                             cx,\n                             PARTIALEQ_NE_IMPL,\n-                            impl_item.id.hir_id,\n+                            impl_item.id.hir_id(),\n                             impl_item.span,\n                             \"re-implementing `PartialEq::ne` is unnecessary\",\n                         );"}, {"sha": "b9ba32001b5137620f077b3996ef7bc00dab041c", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -206,7 +206,7 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n         }\n \n         if let hir::TraitItemKind::Fn(method_sig, _) = &item.kind {\n-            self.check_poly_fn(cx, item.hir_id, &*method_sig.decl, None);\n+            self.check_poly_fn(cx, item.hir_id(), &*method_sig.decl, None);\n         }\n     }\n "}, {"sha": "de2fb8decb7150c42c53320715850be09d6a1033", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -124,19 +124,19 @@ declare_lint_pass!(Ptr => [PTR_ARG, CMP_NULL, MUT_FROM_REF]);\n impl<'tcx> LateLintPass<'tcx> for Ptr {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Fn(ref sig, _, body_id) = item.kind {\n-            check_fn(cx, &sig.decl, item.hir_id, Some(body_id));\n+            check_fn(cx, &sig.decl, item.hir_id(), Some(body_id));\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Fn(ref sig, body_id) = item.kind {\n-            let parent_item = cx.tcx.hir().get_parent_item(item.hir_id);\n+            let parent_item = cx.tcx.hir().get_parent_item(item.hir_id());\n             if let Some(Node::Item(it)) = cx.tcx.hir().find(parent_item) {\n                 if let ItemKind::Impl(Impl { of_trait: Some(_), .. }) = it.kind {\n                     return; // ignore trait impls\n                 }\n             }\n-            check_fn(cx, &sig.decl, item.hir_id, Some(body_id));\n+            check_fn(cx, &sig.decl, item.hir_id(), Some(body_id));\n         }\n     }\n \n@@ -147,7 +147,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n             } else {\n                 None\n             };\n-            check_fn(cx, &sig.decl, item.hir_id, body_id);\n+            check_fn(cx, &sig.decl, item.hir_id(), body_id);\n         }\n     }\n "}, {"sha": "c876bae2303ad29f0252d0ec425d1b9ca17374c7", "filename": "src/tools/clippy/clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -42,11 +42,10 @@ impl_lint_pass!(RedundantPubCrate => [REDUNDANT_PUB_CRATE]);\n impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if let VisibilityKind::Crate { .. } = item.vis.node {\n-            if !cx.access_levels.is_exported(item.hir_id) {\n+            if !cx.access_levels.is_exported(item.hir_id()) {\n                 if let Some(false) = self.is_exported.last() {\n                     let span = item.span.with_hi(item.ident.span.hi());\n-                    let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-                    let descr = cx.tcx.def_kind(def_id).descr(def_id.to_def_id());\n+                    let descr = cx.tcx.def_kind(item.def_id).descr(item.def_id.to_def_id());\n                     span_lint_and_then(\n                         cx,\n                         REDUNDANT_PUB_CRATE,\n@@ -66,7 +65,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n         }\n \n         if let ItemKind::Mod { .. } = item.kind {\n-            self.is_exported.push(cx.access_levels.is_exported(item.hir_id));\n+            self.is_exported.push(cx.access_levels.is_exported(item.hir_id()));\n         }\n     }\n "}, {"sha": "05754503163bd275b57ec3989f38dc5d8688f84c", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -1106,7 +1106,9 @@ fn is_empty_block(expr: &Expr<'_>) -> bool {\n         expr.kind,\n         ExprKind::Block(\n             Block {\n-                stmts: &[], expr: None, ..\n+                stmts: &[],\n+                expr: None,\n+                ..\n             },\n             _,\n         )\n@@ -2565,7 +2567,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n             }\n         }\n \n-        if !cx.access_levels.is_exported(item.hir_id) {\n+        if !cx.access_levels.is_exported(item.hir_id()) {\n             return;\n         }\n "}, {"sha": "73c64b808405819239ca856976b32c61469e57b8", "filename": "src/tools/clippy/clippy_lints/src/unused_self.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -44,10 +44,9 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n         if impl_item.span.from_expansion() {\n             return;\n         }\n-        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id);\n+        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n         let parent_item = cx.tcx.hir().expect_item(parent);\n-        let def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n-        let assoc_item = cx.tcx.associated_item(def_id);\n+        let assoc_item = cx.tcx.associated_item(impl_item.def_id);\n         if_chain! {\n             if let ItemKind::Impl(Impl { of_trait: None, .. }) = parent_item.kind;\n             if assoc_item.fn_has_self_parameter;"}, {"sha": "8cb7429849da65bf207d9221c5f6805f5aecd17b", "filename": "src/tools/clippy/clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -57,8 +57,8 @@ impl<'tcx> LateLintPass<'tcx> for UnwrapInResult {\n             // first check if it's a method or function\n             if let hir::ImplItemKind::Fn(ref _signature, _) = impl_item.kind;\n             // checking if its return type is `result` or `option`\n-            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym::result_type)\n-                || is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym::option_type);\n+            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id()), sym::result_type)\n+                || is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id()), sym::option_type);\n             then {\n                 lint_impl_body(cx, impl_item.span, impl_item);\n             }\n@@ -114,10 +114,9 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tc\n         if let ImplItemKind::Fn(_, body_id) = impl_item.kind;\n         then {\n             let body = cx.tcx.hir().body(body_id);\n-            let impl_item_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n             let mut fpu = FindExpectUnwrap {\n                 lcx: cx,\n-                typeck_results: cx.tcx.typeck(impl_item_def_id),\n+                typeck_results: cx.tcx.typeck(impl_item.def_id),\n                 result: Vec::new(),\n             };\n             fpu.visit_expr(&body.value);"}, {"sha": "f2ff8c959c2e6405691664bd6c32662d81cfe74e", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -196,8 +196,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                         item_path,\n                         cx,\n                     };\n-                    let impl_def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-                    let impl_trait_ref = cx.tcx.impl_trait_ref(impl_def_id);\n+                    let impl_trait_ref = cx.tcx.impl_trait_ref(item.def_id);\n \n                     if let Some(impl_trait_ref) = impl_trait_ref {\n                         for impl_item_ref in impl_.items {"}, {"sha": "6e3d4fde107775847243d008c3b7e96bf2523302", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -130,7 +130,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n-        if !has_attr(cx.sess(), stmt.kind.attrs(|id| cx.tcx.hir().item(id.id))) {\n+        if !has_attr(cx.sess(), stmt.kind.attrs(|id| cx.tcx.hir().item(id))) {\n             return;\n         }\n         prelude();"}, {"sha": "9c1d98cd707453a3b7a82486ff4cbe0939dfe1d9", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -109,7 +109,7 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n-        if !has_attr(cx.sess(), stmt.kind.attrs(|id| cx.tcx.hir().item(id.id))) {\n+        if !has_attr(cx.sess(), stmt.kind.attrs(|id| cx.tcx.hir().item(id))) {\n             return;\n         }\n         match stmt.kind {\n@@ -370,7 +370,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n }\n \n fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-    let did = cx.tcx.hir().local_def_id(item.hir_id);\n+    let did = item.def_id;\n     println!(\"item `{}`\", item.ident.name);\n     match item.vis.node {\n         hir::VisibilityKind::Public => println!(\"public\"),\n@@ -383,8 +383,7 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n     }\n     match item.kind {\n         hir::ItemKind::ExternCrate(ref _renamed_from) => {\n-            let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-            if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(def_id) {\n+            if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(did) {\n                 let source = cx.tcx.used_crate_source(crate_id);\n                 if let Some(ref src) = source.dylib {\n                     println!(\"extern crate dylib source: {:?}\", src.0);"}, {"sha": "094b1a42346c23ff64444c560e087d1586fd16a3", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "patch": "@@ -113,7 +113,7 @@ impl LateLintPass<'_> for WildcardImports {\n         if_chain! {\n             if let ItemKind::Use(use_path, UseKind::Glob) = &item.kind;\n             if self.warn_on_all || !self.check_exceptions(item, use_path.segments);\n-            let used_imports = cx.tcx.names_imported_by_glob_use(item.hir_id.owner);\n+            let used_imports = cx.tcx.names_imported_by_glob_use(item.def_id);\n             if !used_imports.is_empty(); // Already handled by `unused_imports`\n             then {\n                 let mut applicability = Applicability::MachineApplicable;"}]}