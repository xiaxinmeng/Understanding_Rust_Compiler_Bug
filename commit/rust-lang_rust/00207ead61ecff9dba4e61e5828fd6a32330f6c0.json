{"sha": "00207ead61ecff9dba4e61e5828fd6a32330f6c0", "node_id": "C_kwDOAAsO6NoAKDAwMjA3ZWFkNjFlY2ZmOWRiYTRlNjFlNTgyOGZkNmEzMjMzMGY2YzA", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-22T05:00:53Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-26T22:14:09Z"}, "message": "Improve derived discriminant testing.\n\nCurrently the generated code for methods like `eq`, `ne`, and `partial_cmp`\nincludes stuff like this:\n```\nlet __self_vi = ::core::intrinsics::discriminant_value(&*self);\nlet __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\nif true && __self_vi == __arg_1_vi {\n    ...\n}\n```\nThis commit removes the unnecessary `true &&`, and makes the generating\ncode a little easier to read in the process. It also fixes some errors\nin comments.", "tree": {"sha": "ae58daa40094ff542088df8819bc8e43e03de329", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae58daa40094ff542088df8819bc8e43e03de329"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00207ead61ecff9dba4e61e5828fd6a32330f6c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00207ead61ecff9dba4e61e5828fd6a32330f6c0", "html_url": "https://github.com/rust-lang/rust/commit/00207ead61ecff9dba4e61e5828fd6a32330f6c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00207ead61ecff9dba4e61e5828fd6a32330f6c0/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea74997c414779d5628b2a6a8a964582b20607c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea74997c414779d5628b2a6a8a964582b20607c8", "html_url": "https://github.com/rust-lang/rust/commit/ea74997c414779d5628b2a6a8a964582b20607c8"}], "stats": {"total": 59, "additions": 27, "deletions": 32}, "files": [{"sha": "8760845138e38a199f742616bbf3441fc2624194", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/00207ead61ecff9dba4e61e5828fd6a32330f6c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00207ead61ecff9dba4e61e5828fd6a32330f6c0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=00207ead61ecff9dba4e61e5828fd6a32330f6c0", "patch": "@@ -1392,37 +1392,32 @@ impl<'a> MethodDef<'a> {\n             //\n             // i.e., for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n             // with three Self args, builds three statements:\n-            //\n             // ```\n-            // let __self0_vi = std::intrinsics::discriminant_value(&self);\n-            // let __self1_vi = std::intrinsics::discriminant_value(&arg1);\n-            // let __self2_vi = std::intrinsics::discriminant_value(&arg2);\n+            // let __self_vi = std::intrinsics::discriminant_value(&self);\n+            // let __arg_1_vi = std::intrinsics::discriminant_value(&arg1);\n+            // let __arg_2_vi = std::intrinsics::discriminant_value(&arg2);\n             // ```\n             let mut index_let_stmts: Vec<ast::Stmt> = Vec::with_capacity(vi_idents.len() + 1);\n \n-            // We also build an expression which checks whether all discriminants are equal\n-            // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n+            // We also build an expression which checks whether all discriminants are equal:\n+            // `__self_vi == __arg_1_vi && __self_vi == __arg_2_vi && ...`\n             let mut discriminant_test = cx.expr_bool(span, true);\n-\n-            let mut first_ident = None;\n-            for (&ident, self_arg) in iter::zip(&vi_idents, &self_args) {\n+            for (i, (&ident, self_arg)) in iter::zip(&vi_idents, &self_args).enumerate() {\n                 let self_addr = cx.expr_addr_of(span, self_arg.clone());\n                 let variant_value =\n                     deriving::call_intrinsic(cx, span, sym::discriminant_value, vec![self_addr]);\n                 let let_stmt = cx.stmt_let(span, false, ident, variant_value);\n                 index_let_stmts.push(let_stmt);\n \n-                match first_ident {\n-                    Some(first) => {\n-                        let first_expr = cx.expr_ident(span, first);\n-                        let id = cx.expr_ident(span, ident);\n-                        let test = cx.expr_binary(span, BinOpKind::Eq, first_expr, id);\n-                        discriminant_test =\n-                            cx.expr_binary(span, BinOpKind::And, discriminant_test, test)\n-                    }\n-                    None => {\n-                        first_ident = Some(ident);\n-                    }\n+                if i > 0 {\n+                    let id0 = cx.expr_ident(span, vi_idents[0]);\n+                    let id = cx.expr_ident(span, ident);\n+                    let test = cx.expr_binary(span, BinOpKind::Eq, id0, id);\n+                    discriminant_test = if i == 1 {\n+                        test\n+                    } else {\n+                        cx.expr_binary(span, BinOpKind::And, discriminant_test, test)\n+                    };\n                 }\n             }\n \n@@ -1453,7 +1448,7 @@ impl<'a> MethodDef<'a> {\n             //      }\n             //  }\n             //  else {\n-            //      <delegated expression referring to __self0_vi, et al.>\n+            //      <delegated expression referring to __self_vi, et al.>\n             //  }\n             let all_match = cx.expr_match(span, match_arg, match_arms);\n             let arm_expr = cx.expr_if(span, discriminant_test, all_match, Some(arm_expr));"}, {"sha": "faa5a3c3ddf1b875b184662f2d093435e518adad", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/00207ead61ecff9dba4e61e5828fd6a32330f6c0/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/00207ead61ecff9dba4e61e5828fd6a32330f6c0/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=00207ead61ecff9dba4e61e5828fd6a32330f6c0", "patch": "@@ -648,7 +648,7 @@ impl ::core::cmp::PartialEq for Fieldless {\n         {\n             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if true && __self_vi == __arg_1_vi {\n+            if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) { _ => true, }\n                 } else { false }\n         }\n@@ -672,7 +672,7 @@ impl ::core::cmp::PartialOrd for Fieldless {\n         {\n             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if true && __self_vi == __arg_1_vi {\n+            if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         _ =>\n                             ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n@@ -692,7 +692,7 @@ impl ::core::cmp::Ord for Fieldless {\n         {\n             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if true && __self_vi == __arg_1_vi {\n+            if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         _ => ::core::cmp::Ordering::Equal,\n                     }\n@@ -783,7 +783,7 @@ impl ::core::cmp::PartialEq for Mixed {\n         {\n             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if true && __self_vi == __arg_1_vi {\n+            if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n                             (*__self_0) == (*__arg_1_0),\n@@ -800,7 +800,7 @@ impl ::core::cmp::PartialEq for Mixed {\n         {\n             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if true && __self_vi == __arg_1_vi {\n+            if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n                             (*__self_0) != (*__arg_1_0),\n@@ -837,7 +837,7 @@ impl ::core::cmp::PartialOrd for Mixed {\n         {\n             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if true && __self_vi == __arg_1_vi {\n+            if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n                             match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n@@ -880,7 +880,7 @@ impl ::core::cmp::Ord for Mixed {\n         {\n             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if true && __self_vi == __arg_1_vi {\n+            if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n                             match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {\n@@ -973,7 +973,7 @@ impl ::core::cmp::PartialEq for Fielded {\n         {\n             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if true && __self_vi == __arg_1_vi {\n+            if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n                             (*__self_0) == (*__arg_1_0),\n@@ -991,7 +991,7 @@ impl ::core::cmp::PartialEq for Fielded {\n         {\n             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if true && __self_vi == __arg_1_vi {\n+            if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n                             (*__self_0) != (*__arg_1_0),\n@@ -1029,7 +1029,7 @@ impl ::core::cmp::PartialOrd for Fielded {\n         {\n             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if true && __self_vi == __arg_1_vi {\n+            if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n                             match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0),\n@@ -1072,7 +1072,7 @@ impl ::core::cmp::Ord for Fielded {\n         {\n             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-            if true && __self_vi == __arg_1_vi {\n+            if __self_vi == __arg_1_vi {\n                     match (&*self, &*other) {\n                         (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n                             match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {"}]}