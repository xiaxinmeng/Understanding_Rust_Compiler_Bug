{"sha": "f913a4fe901d6aeb84941fa06c17916d4e6d1dd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MTNhNGZlOTAxZDZhZWI4NDk0MWZhMDZjMTc5MTZkNGU2ZDFkZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-22T10:04:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-22T10:04:44Z"}, "message": "Auto merge of #86619 - rylev:incr-hashing-profiling, r=wesleywiser\n\nProfile incremental compilation hashing fingerprints\n\nAdds profiling instrumentation for the hashing of incremental compilation fingerprints per query.\n\nThis will eventually feed into the `measureme` and `rustc-perf` infrastructure for tracking if computing hashes changes over time.\n\nTODOs:\n* [x] Address the FIXME where we are including node interning in the hash timing.\n* [ ] Update measureme/summarize to handle this new data: https://github.com/rust-lang/measureme/pull/166\n* [ ] ~Update rustc-perf to handle the new data from measureme~ (will be done at a later time)\n\nr? `@ghost`\n\ncc `@michaelwoerister`", "tree": {"sha": "fa12a8e3b012f8ba6183240edd55fe63f0c46a1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa12a8e3b012f8ba6183240edd55fe63f0c46a1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f913a4fe901d6aeb84941fa06c17916d4e6d1dd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f913a4fe901d6aeb84941fa06c17916d4e6d1dd7", "html_url": "https://github.com/rust-lang/rust/commit/f913a4fe901d6aeb84941fa06c17916d4e6d1dd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f913a4fe901d6aeb84941fa06c17916d4e6d1dd7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5", "html_url": "https://github.com/rust-lang/rust/commit/7c89e389d00cfc7e86ae7e1b45880da4f5f5c9f5"}, {"sha": "b5bec171841ef35d9f29a58ec567c734348118d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5bec171841ef35d9f29a58ec567c734348118d0", "html_url": "https://github.com/rust-lang/rust/commit/b5bec171841ef35d9f29a58ec567c734348118d0"}], "stats": {"total": 90, "additions": 75, "deletions": 15}, "files": [{"sha": "ef101c56ab578716525fb042b72eb0b056988728", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f913a4fe901d6aeb84941fa06c17916d4e6d1dd7/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f913a4fe901d6aeb84941fa06c17916d4e6d1dd7/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=f913a4fe901d6aeb84941fa06c17916d4e6d1dd7", "patch": "@@ -94,31 +94,34 @@ use std::process;\n use std::sync::Arc;\n use std::time::{Duration, Instant};\n \n-use measureme::{EventId, EventIdBuilder, Profiler, SerializableString, StringId};\n+pub use measureme::EventId;\n+use measureme::{EventIdBuilder, Profiler, SerializableString, StringId};\n use parking_lot::RwLock;\n \n bitflags::bitflags! {\n     struct EventFilter: u32 {\n-        const GENERIC_ACTIVITIES = 1 << 0;\n-        const QUERY_PROVIDERS    = 1 << 1;\n-        const QUERY_CACHE_HITS   = 1 << 2;\n-        const QUERY_BLOCKED      = 1 << 3;\n-        const INCR_CACHE_LOADS   = 1 << 4;\n+        const GENERIC_ACTIVITIES  = 1 << 0;\n+        const QUERY_PROVIDERS     = 1 << 1;\n+        const QUERY_CACHE_HITS    = 1 << 2;\n+        const QUERY_BLOCKED       = 1 << 3;\n+        const INCR_CACHE_LOADS    = 1 << 4;\n \n-        const QUERY_KEYS         = 1 << 5;\n-        const FUNCTION_ARGS      = 1 << 6;\n-        const LLVM               = 1 << 7;\n+        const QUERY_KEYS          = 1 << 5;\n+        const FUNCTION_ARGS       = 1 << 6;\n+        const LLVM                = 1 << 7;\n+        const INCR_RESULT_HASHING = 1 << 8;\n \n         const DEFAULT = Self::GENERIC_ACTIVITIES.bits |\n                         Self::QUERY_PROVIDERS.bits |\n                         Self::QUERY_BLOCKED.bits |\n-                        Self::INCR_CACHE_LOADS.bits;\n+                        Self::INCR_CACHE_LOADS.bits |\n+                        Self::INCR_RESULT_HASHING.bits;\n \n         const ARGS = Self::QUERY_KEYS.bits | Self::FUNCTION_ARGS.bits;\n     }\n }\n \n-// keep this in sync with the `-Z self-profile-events` help message in librustc_session/options.rs\n+// keep this in sync with the `-Z self-profile-events` help message in rustc_session/options.rs\n const EVENT_FILTERS_BY_NAME: &[(&str, EventFilter)] = &[\n     (\"none\", EventFilter::empty()),\n     (\"all\", EventFilter::all()),\n@@ -132,6 +135,7 @@ const EVENT_FILTERS_BY_NAME: &[(&str, EventFilter)] = &[\n     (\"function-args\", EventFilter::FUNCTION_ARGS),\n     (\"args\", EventFilter::ARGS),\n     (\"llvm\", EventFilter::LLVM),\n+    (\"incr-result-hashing\", EventFilter::INCR_RESULT_HASHING),\n ];\n \n /// Something that uniquely identifies a query invocation.\n@@ -248,6 +252,15 @@ impl SelfProfilerRef {\n         })\n     }\n \n+    /// Start profiling with some event filter for a given event. Profiling continues until the\n+    /// TimingGuard returned from this call is dropped.\n+    #[inline(always)]\n+    pub fn generic_activity_with_event_id(&self, event_id: EventId) -> TimingGuard<'_> {\n+        self.exec(EventFilter::GENERIC_ACTIVITIES, |profiler| {\n+            TimingGuard::start(profiler, profiler.generic_activity_event_kind, event_id)\n+        })\n+    }\n+\n     /// Start profiling a generic activity. Profiling continues until the\n     /// TimingGuard returned from this call is dropped.\n     #[inline(always)]\n@@ -337,6 +350,19 @@ impl SelfProfilerRef {\n         })\n     }\n \n+    /// Start profiling how long it takes to hash query results for incremental compilation.\n+    /// Profiling continues until the TimingGuard returned from this call is dropped.\n+    #[inline(always)]\n+    pub fn incr_result_hashing(&self) -> TimingGuard<'_> {\n+        self.exec(EventFilter::INCR_RESULT_HASHING, |profiler| {\n+            TimingGuard::start(\n+                profiler,\n+                profiler.incremental_result_hashing_event_kind,\n+                EventId::INVALID,\n+            )\n+        })\n+    }\n+\n     #[inline(always)]\n     fn instant_query_event(\n         &self,\n@@ -364,6 +390,14 @@ impl SelfProfilerRef {\n         }\n     }\n \n+    /// Gets a `StringId` for the given string. This method makes sure that\n+    /// any strings going through it will only be allocated once in the\n+    /// profiling data.\n+    /// Returns `None` if the self-profiling is not enabled.\n+    pub fn get_or_alloc_cached_string(&self, s: &str) -> Option<StringId> {\n+        self.profiler.as_ref().map(|p| p.get_or_alloc_cached_string(s))\n+    }\n+\n     #[inline]\n     pub fn enabled(&self) -> bool {\n         self.profiler.is_some()\n@@ -388,6 +422,7 @@ pub struct SelfProfiler {\n     query_event_kind: StringId,\n     generic_activity_event_kind: StringId,\n     incremental_load_result_event_kind: StringId,\n+    incremental_result_hashing_event_kind: StringId,\n     query_blocked_event_kind: StringId,\n     query_cache_hit_event_kind: StringId,\n }\n@@ -408,6 +443,8 @@ impl SelfProfiler {\n         let query_event_kind = profiler.alloc_string(\"Query\");\n         let generic_activity_event_kind = profiler.alloc_string(\"GenericActivity\");\n         let incremental_load_result_event_kind = profiler.alloc_string(\"IncrementalLoadResult\");\n+        let incremental_result_hashing_event_kind =\n+            profiler.alloc_string(\"IncrementalResultHashing\");\n         let query_blocked_event_kind = profiler.alloc_string(\"QueryBlocked\");\n         let query_cache_hit_event_kind = profiler.alloc_string(\"QueryCacheHit\");\n \n@@ -451,6 +488,7 @@ impl SelfProfiler {\n             query_event_kind,\n             generic_activity_event_kind,\n             incremental_load_result_event_kind,\n+            incremental_result_hashing_event_kind,\n             query_blocked_event_kind,\n             query_cache_hit_event_kind,\n         })"}, {"sha": "c8a46e974f305e4f6f900746953e2859118c95b1", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f913a4fe901d6aeb84941fa06c17916d4e6d1dd7/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f913a4fe901d6aeb84941fa06c17916d4e6d1dd7/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=f913a4fe901d6aeb84941fa06c17916d4e6d1dd7", "patch": "@@ -1,7 +1,6 @@\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::profiling::QueryInvocationId;\n-use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::profiling::{EventId, QueryInvocationId, SelfProfilerRef};\n use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n@@ -36,6 +35,12 @@ pub struct DepGraph<K: DepKind> {\n     /// each task has a `DepNodeIndex` that uniquely identifies it. This unique\n     /// ID is used for self-profiling.\n     virtual_dep_node_index: Lrc<AtomicU32>,\n+\n+    /// The cached event id for profiling node interning. This saves us\n+    /// from having to look up the event id every time we intern a node\n+    /// which may incur too much overhead.\n+    /// This will be None if self-profiling is disabled.\n+    node_intern_event_id: Option<EventId>,\n }\n \n rustc_index::newtype_index! {\n@@ -130,6 +135,10 @@ impl<K: DepKind> DepGraph<K> {\n         );\n         debug_assert_eq!(_green_node_index, DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE);\n \n+        let node_intern_event_id = profiler\n+            .get_or_alloc_cached_string(\"incr_comp_intern_dep_graph_node\")\n+            .map(EventId::from_label);\n+\n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n@@ -141,11 +150,16 @@ impl<K: DepKind> DepGraph<K> {\n                 colors: DepNodeColorMap::new(prev_graph_node_count),\n             })),\n             virtual_dep_node_index: Lrc::new(AtomicU32::new(0)),\n+            node_intern_event_id,\n         }\n     }\n \n     pub fn new_disabled() -> DepGraph<K> {\n-        DepGraph { data: None, virtual_dep_node_index: Lrc::new(AtomicU32::new(0)) }\n+        DepGraph {\n+            data: None,\n+            virtual_dep_node_index: Lrc::new(AtomicU32::new(0)),\n+            node_intern_event_id: None,\n+        }\n     }\n \n     /// Returns `true` if we are actually building the full dep-graph, and `false` otherwise.\n@@ -244,10 +258,15 @@ impl<K: DepKind> DepGraph<K> {\n             let edges = task_deps.map_or_else(|| smallvec![], |lock| lock.into_inner().reads);\n \n             let mut hcx = dcx.create_stable_hashing_context();\n+            let hashing_timer = dcx.profiler().incr_result_hashing();\n             let current_fingerprint = hash_result(&mut hcx, &result);\n \n             let print_status = cfg!(debug_assertions) && dcx.sess().opts.debugging_opts.dep_tasks;\n \n+            // Get timer for profiling `DepNode` interning\n+            let node_intern_timer = self\n+                .node_intern_event_id\n+                .map(|eid| dcx.profiler().generic_activity_with_event_id(eid));\n             // Intern the new `DepNode`.\n             let (dep_node_index, prev_and_color) = data.current.intern_node(\n                 dcx.profiler(),\n@@ -257,6 +276,9 @@ impl<K: DepKind> DepGraph<K> {\n                 current_fingerprint,\n                 print_status,\n             );\n+            drop(node_intern_timer);\n+\n+            hashing_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n             if let Some((prev_index, color)) = prev_and_color {\n                 debug_assert!("}, {"sha": "172337aca3d4bfae35f8fc872fc7d9f4a24dfb1f", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f913a4fe901d6aeb84941fa06c17916d4e6d1dd7/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f913a4fe901d6aeb84941fa06c17916d4e6d1dd7/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=f913a4fe901d6aeb84941fa06c17916d4e6d1dd7", "patch": "@@ -1250,7 +1250,7 @@ options! {\n         \"specify the events recorded by the self profiler;\n         for example: `-Z self-profile-events=default,query-keys`\n         all options: none, all, default, generic-activity, query-provider, query-cache-hit\n-                     query-blocked, incr-cache-load, query-keys, function-args, args, llvm\"),\n+                     query-blocked, incr-cache-load, incr-result-hashing, query-keys, function-args, args, llvm\"),\n     share_generics: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"make the current crate share its generic instantiations\"),\n     show_span: Option<String> = (None, parse_opt_string, [TRACKED],"}]}