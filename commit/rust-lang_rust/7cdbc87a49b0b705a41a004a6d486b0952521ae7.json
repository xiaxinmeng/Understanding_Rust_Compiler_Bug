{"sha": "7cdbc87a49b0b705a41a004a6d486b0952521ae7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZGJjODdhNDliMGI3MDVhNDFhMDA0YTZkNDg2YjA5NTI1MjFhZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-14T19:54:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-14T19:54:23Z"}, "message": "Auto merge of #69999 - RalfJung:miri-unwind, r=oli-obk\n\nadjust Miri to needs of changed unwinding strategy\n\nAs expected, https://github.com/rust-lang/rust/pull/67502 broke unwinding in Miri. To fix it we have to adjust parts of the engine and the panic runtime, which this PR does. The Miri-side changes are in https://github.com/rust-lang/miri/pull/1227.\n\nCc @oli-obk @Aaron1011 @Mark-Simulacrum @Amanieu", "tree": {"sha": "25d94247c97cf08fa81d3f72b247a8d2c0d2d1c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25d94247c97cf08fa81d3f72b247a8d2c0d2d1c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cdbc87a49b0b705a41a004a6d486b0952521ae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cdbc87a49b0b705a41a004a6d486b0952521ae7", "html_url": "https://github.com/rust-lang/rust/commit/7cdbc87a49b0b705a41a004a6d486b0952521ae7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cdbc87a49b0b705a41a004a6d486b0952521ae7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "html_url": "https://github.com/rust-lang/rust/commit/131772c5e0ba40cd656dedb5e1990d36e3ea31cf"}, {"sha": "b450e1baf4c35ad4812fba9cb1946ea20d405ad8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b450e1baf4c35ad4812fba9cb1946ea20d405ad8", "html_url": "https://github.com/rust-lang/rust/commit/b450e1baf4c35ad4812fba9cb1946ea20d405ad8"}], "stats": {"total": 148, "additions": 98, "deletions": 50}, "files": [{"sha": "d722406b82b4ad3f839a8b26a819e5e9f3f2ae9a", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=7cdbc87a49b0b705a41a004a6d486b0952521ae7", "patch": "@@ -1892,10 +1892,12 @@ extern \"rust-intrinsic\" {\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// Internal hook used by Miri to implement unwinding.\n-    /// Compiles to a NOP during non-Miri codegen.\n+    /// ICEs when encountered during non-Miri codegen.\n     ///\n-    /// Perma-unstable: do not use\n-    pub fn miri_start_panic(data: *mut (dyn crate::any::Any + crate::marker::Send)) -> ();\n+    /// The `payload` ptr here will be exactly the one `do_catch` gets passed by `try`.\n+    ///\n+    /// Perma-unstable: do not use.\n+    pub fn miri_start_panic(payload: *mut u8) -> !;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "0a2a0e9e045c6bea287c2f1265f3620b54cc26fe", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=7cdbc87a49b0b705a41a004a6d486b0952521ae7", "patch": "@@ -30,6 +30,8 @@\n #![feature(raw)]\n #![panic_runtime]\n #![feature(panic_runtime)]\n+// `real_imp` is unused with Miri, so silence warnings.\n+#![cfg_attr(miri, allow(dead_code))]\n \n use alloc::boxed::Box;\n use core::any::Any;\n@@ -38,25 +40,38 @@ use core::panic::BoxMeUp;\n cfg_if::cfg_if! {\n     if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n-        mod imp;\n+        mod real_imp;\n     } else if #[cfg(target_arch = \"wasm32\")] {\n         #[path = \"dummy.rs\"]\n-        mod imp;\n+        mod real_imp;\n     } else if #[cfg(target_os = \"hermit\")] {\n         #[path = \"hermit.rs\"]\n-        mod imp;\n+        mod real_imp;\n     } else if #[cfg(all(target_env = \"msvc\", target_arch = \"aarch64\"))] {\n         #[path = \"dummy.rs\"]\n-        mod imp;\n+        mod real_imp;\n     } else if #[cfg(target_env = \"msvc\")] {\n         #[path = \"seh.rs\"]\n-        mod imp;\n+        mod real_imp;\n     } else {\n         // Rust runtime's startup objects depend on these symbols, so make them public.\n         #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n-        pub use imp::eh_frame_registry::*;\n+        pub use real_imp::eh_frame_registry::*;\n         #[path = \"gcc.rs\"]\n+        mod real_imp;\n+    }\n+}\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(miri)] {\n+        // Use the Miri runtime.\n+        // We still need to also load the normal runtime above, as rustc expects certain lang\n+        // items from there to be defined.\n+        #[path = \"miri.rs\"]\n         mod imp;\n+    } else {\n+        // Use the real runtime.\n+        use real_imp as imp;\n     }\n }\n \n@@ -81,12 +96,5 @@ pub unsafe extern \"C\" fn __rust_start_panic(payload: usize) -> u32 {\n     let payload = payload as *mut &mut dyn BoxMeUp;\n     let payload = (*payload).take_box();\n \n-    // Miri panic support: cfg'd out of normal builds just to be sure.\n-    // When going through normal codegen, `miri_start_panic` is a NOP, so the\n-    // Miri-enabled sysroot still supports normal unwinding. But when executed in\n-    // Miri, this line initiates unwinding.\n-    #[cfg(miri)]\n-    core::intrinsics::miri_start_panic(payload);\n-\n     imp::panic(Box::from_raw(payload))\n }"}, {"sha": "9d92b2b2f32078ae535ba9a142240806031d739c", "filename": "src/libpanic_unwind/miri.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibpanic_unwind%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibpanic_unwind%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fmiri.rs?ref=7cdbc87a49b0b705a41a004a6d486b0952521ae7", "patch": "@@ -0,0 +1,20 @@\n+//! Unwinding panics for Miri.\n+use alloc::boxed::Box;\n+use core::any::Any;\n+\n+// The type of the payload that the Miri engine propagates through unwinding for us.\n+// Must be pointer-sized.\n+type Payload = Box<Box<dyn Any + Send>>;\n+\n+pub unsafe fn panic(payload: Box<dyn Any + Send>) -> u32 {\n+    // The payload we pass to `miri_start_panic` will be exactly the argument we get\n+    // in `cleanup` below. So we just box it up once, to get something pointer-sized.\n+    let payload_box: Payload = Box::new(payload);\n+    core::intrinsics::miri_start_panic(Box::into_raw(payload_box) as *mut u8)\n+}\n+\n+pub unsafe fn cleanup(payload_box: *mut u8) -> Box<dyn Any + Send> {\n+    // Recover the underlying `Box`.\n+    let payload_box: Payload = Box::from_raw(payload_box as *mut _);\n+    *payload_box\n+}"}, {"sha": "1e630c96dd409aa8c0684579f9ba28c2a8738fc1", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=7cdbc87a49b0b705a41a004a6d486b0952521ae7", "patch": "@@ -272,11 +272,13 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn from_bool(b: bool) -> Self {\n+        // Guaranteed to be truncated and does not need sign extension.\n         Scalar::Raw { data: b as u128, size: 1 }\n     }\n \n     #[inline]\n     pub fn from_char(c: char) -> Self {\n+        // Guaranteed to be truncated and does not need sign extension.\n         Scalar::Raw { data: c as u128, size: 4 }\n     }\n \n@@ -299,21 +301,25 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn from_u8(i: u8) -> Self {\n+        // Guaranteed to be truncated and does not need sign extension.\n         Scalar::Raw { data: i as u128, size: 1 }\n     }\n \n     #[inline]\n     pub fn from_u16(i: u16) -> Self {\n+        // Guaranteed to be truncated and does not need sign extension.\n         Scalar::Raw { data: i as u128, size: 2 }\n     }\n \n     #[inline]\n     pub fn from_u32(i: u32) -> Self {\n+        // Guaranteed to be truncated and does not need sign extension.\n         Scalar::Raw { data: i as u128, size: 4 }\n     }\n \n     #[inline]\n     pub fn from_u64(i: u64) -> Self {\n+        // Guaranteed to be truncated and does not need sign extension.\n         Scalar::Raw { data: i as u128, size: 8 }\n     }\n \n@@ -341,6 +347,26 @@ impl<'tcx, Tag> Scalar<Tag> {\n             .unwrap_or_else(|| bug!(\"Signed value {:#x} does not fit in {} bits\", i, size.bits()))\n     }\n \n+    #[inline]\n+    pub fn from_i8(i: i8) -> Self {\n+        Self::from_int(i, Size::from_bits(8))\n+    }\n+\n+    #[inline]\n+    pub fn from_i16(i: i16) -> Self {\n+        Self::from_int(i, Size::from_bits(16))\n+    }\n+\n+    #[inline]\n+    pub fn from_i32(i: i32) -> Self {\n+        Self::from_int(i, Size::from_bits(32))\n+    }\n+\n+    #[inline]\n+    pub fn from_i64(i: i64) -> Self {\n+        Self::from_int(i, Size::from_bits(64))\n+    }\n+\n     #[inline]\n     pub fn from_machine_isize(i: i64, cx: &impl HasDataLayout) -> Self {\n         Self::from_int(i, cx.data_layout().pointer_size)"}, {"sha": "482c143a73ee2f0e403d8073cc68bfc2a48a8c88", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7cdbc87a49b0b705a41a004a6d486b0952521ae7", "patch": "@@ -21,7 +21,7 @@ use rustc_span::source_map::{self, Span, DUMMY_SP};\n \n use super::{\n     Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n-    ScalarMaybeUndef, StackPopInfo,\n+    ScalarMaybeUndef, StackPopJump,\n };\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -623,31 +623,24 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n-        let stack_pop_info = M::stack_pop(self, frame.extra, unwinding)?;\n-        if let (false, StackPopInfo::StopUnwinding) = (unwinding, stack_pop_info) {\n-            bug!(\"Attempted to stop unwinding while there is no unwinding!\");\n-        }\n \n         // Now where do we jump next?\n \n-        // Determine if we leave this function normally or via unwinding.\n-        let cur_unwinding =\n-            if let StackPopInfo::StopUnwinding = stack_pop_info { false } else { unwinding };\n-\n         // Usually we want to clean up (deallocate locals), but in a few rare cases we don't.\n         // In that case, we return early. We also avoid validation in that case,\n         // because this is CTFE and the final value will be thoroughly validated anyway.\n         let (cleanup, next_block) = match frame.return_to_block {\n             StackPopCleanup::Goto { ret, unwind } => {\n-                (true, Some(if cur_unwinding { unwind } else { ret }))\n+                (true, Some(if unwinding { unwind } else { ret }))\n             }\n             StackPopCleanup::None { cleanup, .. } => (cleanup, None),\n         };\n \n         if !cleanup {\n             assert!(self.stack.is_empty(), \"only the topmost frame should ever be leaked\");\n             assert!(next_block.is_none(), \"tried to skip cleanup when we have a next block!\");\n-            // Leak the locals, skip validation.\n+            assert!(!unwinding, \"tried to skip cleanup during unwinding\");\n+            // Leak the locals, skip validation, skip machine hook.\n             return Ok(());\n         }\n \n@@ -656,13 +649,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.deallocate_local(local.value)?;\n         }\n \n-        trace!(\n-            \"StackPopCleanup: {:?} StackPopInfo: {:?} cur_unwinding = {:?}\",\n-            frame.return_to_block,\n-            stack_pop_info,\n-            cur_unwinding\n-        );\n-        if cur_unwinding {\n+        if M::stack_pop(self, frame.extra, unwinding)? == StackPopJump::NoJump {\n+            // The hook already did everything.\n+            // We want to skip the `info!` below, hence early return.\n+            return Ok(());\n+        }\n+        // Normal return.\n+        if unwinding {\n             // Follow the unwind edge.\n             let unwind = next_block.expect(\"Encountered StackPopCleanup::None when unwinding!\");\n             self.unwind_to_block(unwind);\n@@ -697,7 +690,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 \"CONTINUING({}) {} (unwinding = {})\",\n                 self.cur_frame(),\n                 self.frame().instance,\n-                cur_unwinding\n+                unwinding\n             );\n         }\n "}, {"sha": "0e70e54ad85af12b6e7dbe496c17a807fc897a8d", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=7cdbc87a49b0b705a41a004a6d486b0952521ae7", "patch": "@@ -17,16 +17,16 @@ use super::{\n /// Data returned by Machine::stack_pop,\n /// to provide further control over the popping of the stack frame\n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n-pub enum StackPopInfo {\n+pub enum StackPopJump {\n     /// Indicates that no special handling should be\n     /// done - we'll either return normally or unwind\n     /// based on the terminator for the function\n     /// we're leaving.\n     Normal,\n \n-    /// Indicates that we should stop unwinding,\n-    /// as we've reached a catch frame\n-    StopUnwinding,\n+    /// Indicates that we should *not* jump to the return/unwind address, as the callback already\n+    /// took care of everything.\n+    NoJump,\n }\n \n /// Whether this kind of memory is allowed to leak\n@@ -276,9 +276,9 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _extra: Self::FrameExtra,\n         _unwinding: bool,\n-    ) -> InterpResult<'tcx, StackPopInfo> {\n+    ) -> InterpResult<'tcx, StackPopJump> {\n         // By default, we do not support unwinding from panics\n-        Ok(StackPopInfo::Normal)\n+        Ok(StackPopJump::Normal)\n     }\n \n     fn int_to_ptr("}, {"sha": "c3fd968276577241207408783545216fca5fe308", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=7cdbc87a49b0b705a41a004a6d486b0952521ae7", "patch": "@@ -24,7 +24,7 @@ pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n \n pub use self::memory::{AllocCheck, FnVal, Memory, MemoryKind};\n \n-pub use self::machine::{AllocMap, Machine, MayLeak, StackPopInfo};\n+pub use self::machine::{AllocMap, Machine, MayLeak, StackPopJump};\n \n pub use self::operand::{ImmTy, Immediate, OpTy, Operand, ScalarMaybeUndef};\n "}, {"sha": "7bc86650a7324d41168871498f2ad8200e3cd8eb", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cdbc87a49b0b705a41a004a6d486b0952521ae7/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=7cdbc87a49b0b705a41a004a6d486b0952521ae7", "patch": "@@ -251,21 +251,20 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     //\n     // We go through a transition where:\n     //\n-    // * First, we set the data to be the closure that we're going to call.\n+    // * First, we set the data field `f` to be the argumentless closure that we're going to call.\n     // * When we make the function call, the `do_call` function below, we take\n-    //   ownership of the function pointer. At this point the `Data` union is\n+    //   ownership of the function pointer. At this point the `data` union is\n     //   entirely uninitialized.\n     // * If the closure successfully returns, we write the return value into the\n-    //   data's return slot. Note that `ptr::write` is used as it's overwriting\n-    //   uninitialized data.\n+    //   data's return slot (field `r`).\n+    // * If the closure panics (`do_catch` below), we write the panic payload into field `p`.\n     // * Finally, when we come back out of the `try` intrinsic we're\n     //   in one of two states:\n     //\n     //      1. The closure didn't panic, in which case the return value was\n-    //         filled in. We move it out of `data` and return it.\n-    //      2. The closure panicked, in which case the return value wasn't\n-    //         filled in. In this case the entire `data` union is invalid, so\n-    //         there is no need to drop anything.\n+    //         filled in. We move it out of `data.r` and return it.\n+    //      2. The closure panicked, in which case the panic payload was\n+    //         filled in. We move it out of `data.p` and return it.\n     //\n     // Once we stack all that together we should have the \"most efficient'\n     // method of calling a catch panic whilst juggling ownership."}]}