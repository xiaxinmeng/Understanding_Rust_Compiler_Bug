{"sha": "cfa668f3bf8156730b419deec51fb980af23b8bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYTY2OGYzYmY4MTU2NzMwYjQxOWRlZWM1MWZiOTgwYWYyM2I4YmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-15T06:23:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-15T06:23:11Z"}, "message": "Auto merge of #37702 - redox-os:redox, r=brson\n\nRedox Support Preview\n\n# Important - This is only a preview of a working `sys::redox`.\n\nCompiling the Redox default distribution with this `libstd` results in a fully functioning distribution. As such, all further changes would be cosmetic or implementing features that have not been used by the default distribution (of which there are only a small number).\n\nI do not expect this to be merged, but would like to discuss how it may be improved and get feedback.\n\nThere are a few `unimplemented!()` - `cloexec` for example. I have documented them below. These would be resolved before desiring a merge.\n\nThere are also issues with how the Redox syscall library is called - currently I am using a re-export in `libc` but that probably would not be desired.", "tree": {"sha": "00f70114d72e3d944ac12d973ad6db58e91e3770", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00f70114d72e3d944ac12d973ad6db58e91e3770"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfa668f3bf8156730b419deec51fb980af23b8bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfa668f3bf8156730b419deec51fb980af23b8bb", "html_url": "https://github.com/rust-lang/rust/commit/cfa668f3bf8156730b419deec51fb980af23b8bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfa668f3bf8156730b419deec51fb980af23b8bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ad7232422f7e5bbfa0e52dabe36c12677df19e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ad7232422f7e5bbfa0e52dabe36c12677df19e2", "html_url": "https://github.com/rust-lang/rust/commit/7ad7232422f7e5bbfa0e52dabe36c12677df19e2"}, {"sha": "3e15dc108c66891da04aa8c3f77162746fab4277", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e15dc108c66891da04aa8c3f77162746fab4277", "html_url": "https://github.com/rust-lang/rust/commit/3e15dc108c66891da04aa8c3f77162746fab4277"}], "stats": {"total": 4260, "additions": 4252, "deletions": 8}, "files": [{"sha": "8f85bfe2c638eafeb2de9e46f4583a6201ceabec", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -28,7 +28,7 @@\n #![panic_runtime]\n #![feature(panic_runtime)]\n #![cfg_attr(unix, feature(libc))]\n-#![cfg_attr(windows, feature(core_intrinsics))]\n+#![cfg_attr(any(target_os = \"redox\", windows), feature(core_intrinsics))]\n \n // Rust's \"try\" function, but if we're aborting on panics we just call the\n // function as there's nothing else we need to do here.\n@@ -61,7 +61,7 @@ pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n         libc::abort();\n     }\n \n-    #[cfg(windows)]\n+    #[cfg(any(target_os = \"redox\", windows))]\n     unsafe fn abort() -> ! {\n         core::intrinsics::abort();\n     }"}, {"sha": "b75d9ec6520a4519062de54d60cd91d46eba5d45", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -69,6 +69,7 @@ mod imp;\n \n // i686-pc-windows-gnu and all others\n #[cfg(any(all(unix, not(target_os = \"emscripten\")),\n+          target_os = \"redox\",\n           all(windows, target_arch = \"x86\", target_env = \"gnu\")))]\n #[path = \"gcc.rs\"]\n mod imp;"}, {"sha": "6419a9ff683de75e0700d73e890afd72b72c38c0", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -81,11 +81,11 @@ impl Read for StdinRaw {\n }\n impl Write for StdoutRaw {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    fn flush(&mut self) -> io::Result<()> { self.0.flush() }\n }\n impl Write for StderrRaw {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    fn flush(&mut self) -> io::Result<()> { self.0.flush() }\n }\n \n enum Maybe<T> {"}, {"sha": "58f1604de1c5c6c1b94cfd2e38947a24f2c87adc", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -13,7 +13,7 @@\n #![stable(feature = \"os\", since = \"1.0.0\")]\n #![allow(missing_docs, bad_style)]\n \n-#[cfg(unix)]\n+#[cfg(any(target_os = \"redox\", unix))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use sys::ext as unix;\n #[cfg(windows)]"}, {"sha": "e4b0d980c921aa1381e7cec2ecda0cdc7e88fa12", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -32,6 +32,10 @@\n \n pub use self::imp::*;\n \n+#[cfg(target_os = \"redox\")]\n+#[path = \"redox/mod.rs\"]\n+mod imp;\n+\n #[cfg(unix)]\n #[path = \"unix/mod.rs\"]\n mod imp;"}, {"sha": "f6fea2f10761b0b423e3ac716d15a365a40077c0", "filename": "src/libstd/sys/redox/args.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fargs.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,109 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Global initialization and retreival of command line arguments.\n+//!\n+//! On some platforms these are stored during runtime startup,\n+//! and on some they are retrieved from the system on demand.\n+\n+#![allow(dead_code)] // runtime init functions not used during testing\n+\n+use ffi::OsString;\n+use marker::PhantomData;\n+use vec;\n+\n+/// One-time global initialization.\n+pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n+\n+/// One-time global cleanup.\n+pub unsafe fn cleanup() { imp::cleanup() }\n+\n+/// Returns the command line arguments\n+pub fn args() -> Args {\n+    imp::args()\n+}\n+\n+pub struct Args {\n+    iter: vec::IntoIter<OsString>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize { self.iter.len() }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n+}\n+\n+mod imp {\n+    use os::unix::prelude::*;\n+    use mem;\n+    use ffi::OsString;\n+    use marker::PhantomData;\n+    use slice;\n+    use str;\n+    use super::Args;\n+\n+    use sys_common::mutex::Mutex;\n+\n+    static mut GLOBAL_ARGS_PTR: usize = 0;\n+    static LOCK: Mutex = Mutex::new();\n+\n+    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+        let mut args: Vec<Vec<u8>> = Vec::new();\n+        for i in 0..argc {\n+            let len = *(argv.offset(i * 2)) as usize;\n+            let ptr = *(argv.offset(i * 2 + 1));\n+            args.push(slice::from_raw_parts(ptr, len).to_vec());\n+        }\n+\n+        LOCK.lock();\n+        let ptr = get_global_ptr();\n+        assert!((*ptr).is_none());\n+        (*ptr) = Some(box args);\n+        LOCK.unlock();\n+    }\n+\n+    pub unsafe fn cleanup() {\n+        LOCK.lock();\n+        *get_global_ptr() = None;\n+        LOCK.unlock();\n+    }\n+\n+    pub fn args() -> Args {\n+        let bytes = clone().unwrap_or(Vec::new());\n+        let v: Vec<OsString> = bytes.into_iter().map(|v| {\n+            OsStringExt::from_vec(v)\n+        }).collect();\n+        Args { iter: v.into_iter(), _dont_send_or_sync_me: PhantomData }\n+    }\n+\n+    fn clone() -> Option<Vec<Vec<u8>>> {\n+        unsafe {\n+            LOCK.lock();\n+            let ptr = get_global_ptr();\n+            let ret = (*ptr).as_ref().map(|s| (**s).clone());\n+            LOCK.unlock();\n+            return ret\n+        }\n+    }\n+\n+    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n+        unsafe { mem::transmute(&GLOBAL_ARGS_PTR) }\n+    }\n+\n+}"}, {"sha": "6f53841502ad23dc451283e4f16b0bda6b75feee", "filename": "src/libstd/sys/redox/backtrace.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc;\n+use io;\n+use sys_common::backtrace::output;\n+\n+#[inline(never)]\n+pub fn write(w: &mut io::Write) -> io::Result<()> {\n+    output(w, 0, 0 as *mut libc::c_void, None)\n+}"}, {"sha": "0ca0987b245a291de772a04a54533ca6a0e6bd50", "filename": "src/libstd/sys/redox/condvar.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use intrinsics::{atomic_cxchg, atomic_xadd, atomic_xchg};\n+use ptr;\n+use time::Duration;\n+\n+use sys::mutex::{mutex_lock, mutex_unlock, Mutex};\n+use sys::syscall::{futex, FUTEX_WAIT, FUTEX_WAKE, FUTEX_REQUEUE};\n+\n+pub struct Condvar {\n+    lock: UnsafeCell<*mut i32>,\n+    seq: UnsafeCell<i32>\n+}\n+\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        Condvar {\n+            lock: UnsafeCell::new(ptr::null_mut()),\n+            seq: UnsafeCell::new(0)\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&self) {\n+        *self.lock.get() = ptr::null_mut();\n+        *self.seq.get() = 0;\n+    }\n+\n+    #[inline]\n+    pub fn notify_one(&self) {\n+        unsafe {\n+            let seq = self.seq.get();\n+\n+            atomic_xadd(seq, 1);\n+\n+            let _ = futex(seq, FUTEX_WAKE, 1, 0, ptr::null_mut());\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn notify_all(&self) {\n+        unsafe {\n+            let lock = self.lock.get();\n+            let seq = self.seq.get();\n+\n+            if *lock == ptr::null_mut() {\n+                return;\n+            }\n+\n+            atomic_xadd(seq, 1);\n+\n+            let _ = futex(seq, FUTEX_REQUEUE, 1, ::usize::MAX, *lock);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn wait(&self, mutex: &Mutex) {\n+        unsafe {\n+            let lock = self.lock.get();\n+            let seq = self.seq.get();\n+\n+            if *lock != mutex.lock.get() {\n+                if *lock != ptr::null_mut() {\n+                    panic!(\"Condvar used with more than one Mutex\");\n+                }\n+\n+                atomic_cxchg(lock as *mut usize, 0, mutex.lock.get() as usize);\n+            }\n+\n+            mutex_unlock(*lock);\n+\n+            let _ = futex(seq, FUTEX_WAIT, *seq, 0, ptr::null_mut());\n+\n+            while atomic_xchg(*lock, 2) != 0 {\n+                let _ = futex(*lock, FUTEX_WAIT, 2, 0, ptr::null_mut());\n+            }\n+\n+            mutex_lock(*lock);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n+        ::sys_common::util::dumb_print(format_args!(\"condvar wait_timeout\\n\"));\n+        unimplemented!();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        *self.lock.get() = ptr::null_mut();\n+        *self.seq.get() = 0;\n+    }\n+}\n+\n+unsafe impl Send for Condvar {}\n+\n+unsafe impl Sync for Condvar {}"}, {"sha": "669b7520df846d90b237c35f4bb732d9a413a4a5", "filename": "src/libstd/sys/redox/env.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fenv.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod os {\n+    pub const FAMILY: &'static str = \"redox\";\n+    pub const OS: &'static str = \"redox\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}"}, {"sha": "d59b4fc0b70b8032a961d9123da86e7b5c2276ac", "filename": "src/libstd/sys/redox/ext/ffi.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fffi.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extension to the primitives in the `std::ffi` module\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use ffi::{OsStr, OsString};\n+use mem;\n+use sys::os_str::Buf;\n+use sys_common::{FromInner, IntoInner, AsInner};\n+\n+/// Unix-specific extensions to `OsString`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait OsStringExt {\n+    /// Creates an `OsString` from a byte vector.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_vec(vec: Vec<u8>) -> Self;\n+\n+    /// Yields the underlying byte vector of this `OsString`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn into_vec(self) -> Vec<u8>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl OsStringExt for OsString {\n+    fn from_vec(vec: Vec<u8>) -> OsString {\n+        FromInner::from_inner(Buf { inner: vec })\n+    }\n+    fn into_vec(self) -> Vec<u8> {\n+        self.into_inner().inner\n+    }\n+}\n+\n+/// Unix-specific extensions to `OsStr`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait OsStrExt {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_bytes(slice: &[u8]) -> &Self;\n+\n+    /// Gets the underlying byte view of the `OsStr` slice.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_bytes(&self) -> &[u8];\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl OsStrExt for OsStr {\n+    fn from_bytes(slice: &[u8]) -> &OsStr {\n+        unsafe { mem::transmute(slice) }\n+    }\n+    fn as_bytes(&self) -> &[u8] {\n+        &self.as_inner().inner\n+    }\n+}"}, {"sha": "b4e220971fd9cbe28005573a847cb6657fa10d91", "filename": "src/libstd/sys/redox/ext/fs.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,298 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to primitives in the `std::fs` module.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use fs::{self, Permissions, OpenOptions};\n+use io;\n+use path::Path;\n+use sys;\n+use sys_common::{FromInner, AsInner, AsInnerMut};\n+\n+/// Unix-specific extensions to `Permissions`\n+#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+pub trait PermissionsExt {\n+    /// Returns the underlying raw `mode_t` bits that are the standard Unix\n+    /// permissions for this file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// use std::fs::File;\n+    /// use std::os::unix::fs::PermissionsExt;\n+    ///\n+    /// let f = try!(File::create(\"foo.txt\"));\n+    /// let metadata = try!(f.metadata());\n+    /// let permissions = metadata.permissions();\n+    ///\n+    /// println!(\"permissions: {}\", permissions.mode());\n+    /// ```\n+    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+    fn mode(&self) -> u32;\n+\n+    /// Sets the underlying raw bits for this set of permissions.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// use std::fs::File;\n+    /// use std::os::unix::fs::PermissionsExt;\n+    ///\n+    /// let f = try!(File::create(\"foo.txt\"));\n+    /// let metadata = try!(f.metadata());\n+    /// let mut permissions = metadata.permissions();\n+    ///\n+    /// permissions.set_mode(0o644); // Read/write for owner and read for others.\n+    /// assert_eq!(permissions.mode(), 0o644);\n+    /// ```\n+    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+    fn set_mode(&mut self, mode: u32);\n+\n+    /// Creates a new instance of `Permissions` from the given set of Unix\n+    /// permission bits.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// use std::fs::Permissions;\n+    /// use std::os::unix::fs::PermissionsExt;\n+    ///\n+    /// // Read/write for owner and read for others.\n+    /// let permissions = Permissions::from_mode(0o644);\n+    /// assert_eq!(permissions.mode(), 0o644);\n+    /// ```\n+    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+    fn from_mode(mode: u32) -> Self;\n+}\n+\n+#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+impl PermissionsExt for Permissions {\n+    fn mode(&self) -> u32 {\n+        self.as_inner().mode()\n+    }\n+\n+    fn set_mode(&mut self, mode: u32) {\n+        *self = Permissions::from_inner(FromInner::from_inner(mode));\n+    }\n+\n+    fn from_mode(mode: u32) -> Permissions {\n+        Permissions::from_inner(FromInner::from_inner(mode))\n+    }\n+}\n+\n+/// Unix-specific extensions to `OpenOptions`\n+#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+pub trait OpenOptionsExt {\n+    /// Sets the mode bits that a new file will be created with.\n+    ///\n+    /// If a new file is created as part of a `File::open_opts` call then this\n+    /// specified `mode` will be used as the permission bits for the new file.\n+    /// If no `mode` is set, the default of `0o666` will be used.\n+    /// The operating system masks out bits with the systems `umask`, to produce\n+    /// the final permissions.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// extern crate libc;\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::unix::fs::OpenOptionsExt;\n+    ///\n+    /// let mut options = OpenOptions::new();\n+    /// options.mode(0o644); // Give read/write for owner and read for others.\n+    /// let file = options.open(\"foo.txt\");\n+    /// ```\n+    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+    fn mode(&mut self, mode: u32) -> &mut Self;\n+\n+    /// Pass custom flags to the `flags` agument of `open`.\n+    ///\n+    /// The bits that define the access mode are masked out with `O_ACCMODE`, to\n+    /// ensure they do not interfere with the access mode set by Rusts options.\n+    ///\n+    /// Custom flags can only set flags, not remove flags set by Rusts options.\n+    /// This options overwrites any previously set custom flags.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// extern crate libc;\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::unix::fs::OpenOptionsExt;\n+    ///\n+    /// let mut options = OpenOptions::new();\n+    /// options.write(true);\n+    /// if cfg!(unix) {\n+    ///     options.custom_flags(libc::O_NOFOLLOW);\n+    /// }\n+    /// let file = options.open(\"foo.txt\");\n+    /// ```\n+    #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n+    fn custom_flags(&mut self, flags: i32) -> &mut Self;\n+}\n+\n+#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+impl OpenOptionsExt for OpenOptions {\n+    fn mode(&mut self, mode: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().mode(mode); self\n+    }\n+\n+    fn custom_flags(&mut self, flags: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().custom_flags(flags); self\n+    }\n+}\n+\n+// Hm, why are there casts here to the returned type, shouldn't the types always\n+// be the same? Right you are! Turns out, however, on android at least the types\n+// in the raw `stat` structure are not the same as the types being returned. Who\n+// knew!\n+//\n+// As a result to make sure this compiles for all platforms we do the manual\n+// casts and rely on manual lowering to `stat` if the raw type is desired.\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+pub trait MetadataExt {\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn mode(&self) -> u32;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn uid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn gid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn size(&self) -> u64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn atime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn atime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn mtime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn mtime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn ctime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn ctime_nsec(&self) -> i64;\n+}\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+impl MetadataExt for fs::Metadata {\n+    fn mode(&self) -> u32 {\n+        self.as_inner().as_inner().st_mode as u32\n+    }\n+    fn uid(&self) -> u32 {\n+        self.as_inner().as_inner().st_uid as u32\n+    }\n+    fn gid(&self) -> u32 {\n+        self.as_inner().as_inner().st_gid as u32\n+    }\n+    fn size(&self) -> u64 {\n+        self.as_inner().as_inner().st_size as u64\n+    }\n+    fn atime(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime as i64\n+    }\n+    fn atime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime_nsec as i64\n+    }\n+    fn mtime(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime as i64\n+    }\n+    fn mtime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime_nsec as i64\n+    }\n+    fn ctime(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime as i64\n+    }\n+    fn ctime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime_nsec as i64\n+    }\n+}\n+\n+/// Add special unix types (block/char device, fifo and socket)\n+#[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+pub trait FileTypeExt {\n+    /// Returns whether this file type is a block device.\n+    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+    fn is_block_device(&self) -> bool;\n+    /// Returns whether this file type is a char device.\n+    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+    fn is_char_device(&self) -> bool;\n+    /// Returns whether this file type is a fifo.\n+    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+    fn is_fifo(&self) -> bool;\n+    /// Returns whether this file type is a socket.\n+    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+    fn is_socket(&self) -> bool;\n+}\n+\n+#[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+impl FileTypeExt for fs::FileType {\n+    fn is_block_device(&self) -> bool { false /*FIXME: Implement block device mode*/ }\n+    fn is_char_device(&self) -> bool { false /*FIXME: Implement char device mode*/ }\n+    fn is_fifo(&self) -> bool { false /*FIXME: Implement fifo mode*/ }\n+    fn is_socket(&self) -> bool { false /*FIXME: Implement socket mode*/ }\n+}\n+\n+/// Creates a new symbolic link on the filesystem.\n+///\n+/// The `dst` path will be a symbolic link pointing to the `src` path.\n+///\n+/// # Note\n+///\n+/// On Windows, you must specify whether a symbolic link points to a file\n+/// or directory.  Use `os::windows::fs::symlink_file` to create a\n+/// symbolic link to a file, or `os::windows::fs::symlink_dir` to create a\n+/// symbolic link to a directory.  Additionally, the process must have\n+/// `SeCreateSymbolicLinkPrivilege` in order to be able to create a\n+/// symbolic link.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::os::unix::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::symlink(\"a.txt\", \"b.txt\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n+#[stable(feature = \"symlink\", since = \"1.1.0\")]\n+pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n+{\n+    sys::fs::symlink(src.as_ref(), dst.as_ref())\n+}\n+\n+#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n+/// An extension trait for `fs::DirBuilder` for unix-specific options.\n+pub trait DirBuilderExt {\n+    /// Sets the mode to create new directories with. This option defaults to\n+    /// 0o777.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// use std::fs::DirBuilder;\n+    /// use std::os::unix::fs::DirBuilderExt;\n+    ///\n+    /// let mut builder = DirBuilder::new();\n+    /// builder.mode(0o755);\n+    /// ```\n+    #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n+    fn mode(&mut self, mode: u32) -> &mut Self;\n+}\n+\n+#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n+impl DirBuilderExt for fs::DirBuilder {\n+    fn mode(&mut self, mode: u32) -> &mut fs::DirBuilder {\n+        self.as_inner_mut().set_mode(mode);\n+        self\n+    }\n+}"}, {"sha": "135e31fae1e687eb9062d3dfb3c823f290d57132", "filename": "src/libstd/sys/redox/ext/io.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,146 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to general I/O primitives\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use fs;\n+use sys;\n+use sys_common::{AsInner, FromInner, IntoInner};\n+\n+/// Raw file descriptors.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type RawFd = usize;\n+\n+/// A trait to extract the raw unix file descriptor from an underlying\n+/// object.\n+///\n+/// This is only available on unix platforms and must be imported in order\n+/// to call the method. Windows platforms have a corresponding `AsRawHandle`\n+/// and `AsRawSocket` set of traits.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait AsRawFd {\n+    /// Extracts the raw file descriptor.\n+    ///\n+    /// This method does **not** pass ownership of the raw file descriptor\n+    /// to the caller. The descriptor is only guaranteed to be valid while\n+    /// the original object has not yet been destroyed.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_raw_fd(&self) -> RawFd;\n+}\n+\n+/// A trait to express the ability to construct an object from a raw file\n+/// descriptor.\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+pub trait FromRawFd {\n+    /// Constructs a new instances of `Self` from the given raw file\n+    /// descriptor.\n+    ///\n+    /// This function **consumes ownership** of the specified file\n+    /// descriptor. The returned object will take responsibility for closing\n+    /// it when the object goes out of scope.\n+    ///\n+    /// This function is also unsafe as the primitives currently returned\n+    /// have the contract that they are the sole owner of the file\n+    /// descriptor they are wrapping. Usage of this function could\n+    /// accidentally allow violating this contract which can cause memory\n+    /// unsafety in code that relies on it being true.\n+    #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n+}\n+\n+/// A trait to express the ability to consume an object and acquire ownership of\n+/// its raw file descriptor.\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+pub trait IntoRawFd {\n+    /// Consumes this object, returning the raw underlying file descriptor.\n+    ///\n+    /// This function **transfers ownership** of the underlying file descriptor\n+    /// to the caller. Callers are then the unique owners of the file descriptor\n+    /// and must close the descriptor once it's no longer needed.\n+    #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+    fn into_raw_fd(self) -> RawFd;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for fs::File {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for fs::File {\n+    unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n+        fs::File::from_inner(sys::fs::File::from_inner(fd))\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for fs::File {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}\n+\n+/*\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpStream {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpListener {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::UdpSocket {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n+    }\n+}\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n+    }\n+}\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::UdpSocket {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::UdpSocket {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+*/"}, {"sha": "513ef272e9790d4fe4f8b0f64599f61dacc37489", "filename": "src/libstd/sys/redox/ext/mod.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Experimental extensions to `std` for Unix platforms.\n+//!\n+//! For now, this module is limited to extracting file descriptors,\n+//! but its functionality will grow over time.\n+//!\n+//! # Example\n+//!\n+//! ```no_run\n+//! use std::fs::File;\n+//! use std::os::unix::prelude::*;\n+//!\n+//! fn main() {\n+//!     let f = File::create(\"foo.txt\").unwrap();\n+//!     let fd = f.as_raw_fd();\n+//!\n+//!     // use fd with native unix bindings\n+//! }\n+//! ```\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+pub mod ffi;\n+pub mod fs;\n+pub mod io;\n+pub mod process;\n+\n+/// A prelude for conveniently writing platform-specific code.\n+///\n+/// Includes all extension traits, and some important type definitions.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod prelude {\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::ffi::{OsStrExt, OsStringExt};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::fs::{FileTypeExt, PermissionsExt, OpenOptionsExt, MetadataExt};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::process::{CommandExt, ExitStatusExt};\n+}"}, {"sha": "1472242d3db5d64ddad8ed509ab5bbfb8e2ef0f0", "filename": "src/libstd/sys/redox/ext/process.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,183 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to primitives in the `std::process` module.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use io;\n+use os::unix::io::{FromRawFd, RawFd, AsRawFd, IntoRawFd};\n+use process;\n+use sys;\n+use sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n+\n+/// Unix-specific extensions to the `std::process::Command` builder\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait CommandExt {\n+    /// Sets the child process's user id. This translates to a\n+    /// `setuid` call in the child process. Failure in the `setuid`\n+    /// call will cause the spawn to fail.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn uid(&mut self, id: u32) -> &mut process::Command;\n+\n+    /// Similar to `uid`, but sets the group id of the child process. This has\n+    /// the same semantics as the `uid` field.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn gid(&mut self, id: u32) -> &mut process::Command;\n+\n+    /// Schedules a closure to be run just before the `exec` function is\n+    /// invoked.\n+    ///\n+    /// The closure is allowed to return an I/O error whose OS error code will\n+    /// be communicated back to the parent and returned as an error from when\n+    /// the spawn was requested.\n+    ///\n+    /// Multiple closures can be registered and they will be called in order of\n+    /// their registration. If a closure returns `Err` then no further closures\n+    /// will be called and the spawn operation will immediately return with a\n+    /// failure.\n+    ///\n+    /// # Notes\n+    ///\n+    /// This closure will be run in the context of the child process after a\n+    /// `fork`. This primarily means that any modificatons made to memory on\n+    /// behalf of this closure will **not** be visible to the parent process.\n+    /// This is often a very constrained environment where normal operations\n+    /// like `malloc` or acquiring a mutex are not guaranteed to work (due to\n+    /// other threads perhaps still running when the `fork` was run).\n+    ///\n+    /// When this closure is run, aspects such as the stdio file descriptors and\n+    /// working directory have successfully been changed, so output to these\n+    /// locations may not appear where intended.\n+    #[unstable(feature = \"process_exec\", issue = \"31398\")]\n+    fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n+\n+    /// Performs all the required setup by this `Command`, followed by calling\n+    /// the `execvp` syscall.\n+    ///\n+    /// On success this function will not return, and otherwise it will return\n+    /// an error indicating why the exec (or another part of the setup of the\n+    /// `Command`) failed.\n+    ///\n+    /// This function, unlike `spawn`, will **not** `fork` the process to create\n+    /// a new child. Like spawn, however, the default behavior for the stdio\n+    /// descriptors will be to inherited from the current process.\n+    ///\n+    /// # Notes\n+    ///\n+    /// The process may be in a \"broken state\" if this function returns in\n+    /// error. For example the working directory, environment variables, signal\n+    /// handling settings, various user/group information, or aspects of stdio\n+    /// file descriptors may have changed. If a \"transactional spawn\" is\n+    /// required to gracefully handle errors it is recommended to use the\n+    /// cross-platform `spawn` instead.\n+    #[stable(feature = \"process_exec2\", since = \"1.9.0\")]\n+    fn exec(&mut self) -> io::Error;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl CommandExt for process::Command {\n+    fn uid(&mut self, id: u32) -> &mut process::Command {\n+        self.as_inner_mut().uid(id);\n+        self\n+    }\n+\n+    fn gid(&mut self, id: u32) -> &mut process::Command {\n+        self.as_inner_mut().gid(id);\n+        self\n+    }\n+\n+    fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    {\n+        self.as_inner_mut().before_exec(Box::new(f));\n+        self\n+    }\n+\n+    fn exec(&mut self) -> io::Error {\n+        self.as_inner_mut().exec(sys::process::Stdio::Inherit)\n+    }\n+}\n+\n+/// Unix-specific extensions to `std::process::ExitStatus`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait ExitStatusExt {\n+    /// Creates a new `ExitStatus` from the raw underlying `i32` return value of\n+    /// a process.\n+    #[stable(feature = \"exit_status_from\", since = \"1.12.0\")]\n+    fn from_raw(raw: i32) -> Self;\n+\n+    /// If the process was terminated by a signal, returns that signal.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn signal(&self) -> Option<i32>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExitStatusExt for process::ExitStatus {\n+    fn from_raw(raw: i32) -> Self {\n+        process::ExitStatus::from_inner(From::from(raw))\n+    }\n+\n+    fn signal(&self) -> Option<i32> {\n+        self.as_inner().signal()\n+    }\n+}\n+\n+#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n+impl FromRawFd for process::Stdio {\n+    unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio {\n+        let fd = sys::fd::FileDesc::new(fd);\n+        let io = sys::process::Stdio::Fd(fd);\n+        process::Stdio::from_inner(io)\n+    }\n+}\n+\n+#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n+impl AsRawFd for process::ChildStdin {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+\n+#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n+impl AsRawFd for process::ChildStdout {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+\n+#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n+impl AsRawFd for process::ChildStderr {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for process::ChildStdin {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for process::ChildStdout {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for process::ChildStderr {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}"}, {"sha": "6eeae2d90ea0e8cf307022907ca9fd7e86891b04", "filename": "src/libstd/sys/redox/fast_thread_local.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg(target_thread_local)]\n+#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n+\n+use cell::{Cell, UnsafeCell};\n+use intrinsics;\n+use ptr;\n+\n+pub struct Key<T> {\n+    inner: UnsafeCell<Option<T>>,\n+\n+    // Metadata to keep track of the state of the destructor. Remember that\n+    // these variables are thread-local, not global.\n+    dtor_registered: Cell<bool>,\n+    dtor_running: Cell<bool>,\n+}\n+\n+unsafe impl<T> ::marker::Sync for Key<T> { }\n+\n+impl<T> Key<T> {\n+    pub const fn new() -> Key<T> {\n+        Key {\n+            inner: UnsafeCell::new(None),\n+            dtor_registered: Cell::new(false),\n+            dtor_running: Cell::new(false)\n+        }\n+    }\n+\n+    pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n+        unsafe {\n+            if intrinsics::needs_drop::<T>() && self.dtor_running.get() {\n+                return None\n+            }\n+            self.register_dtor();\n+        }\n+        Some(&self.inner)\n+    }\n+\n+    unsafe fn register_dtor(&self) {\n+        if !intrinsics::needs_drop::<T>() || self.dtor_registered.get() {\n+            return\n+        }\n+\n+        register_dtor(self as *const _ as *mut u8,\n+                      destroy_value::<T>);\n+        self.dtor_registered.set(true);\n+    }\n+}\n+\n+unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    // The fallback implementation uses a vanilla OS-based TLS key to track\n+    // the list of destructors that need to be run for this thread. The key\n+    // then has its own destructor which runs all the other destructors.\n+    //\n+    // The destructor for DTORS is a little special in that it has a `while`\n+    // loop to continuously drain the list of registered destructors. It\n+    // *should* be the case that this loop always terminates because we\n+    // provide the guarantee that a TLS key cannot be set after it is\n+    // flagged for destruction.\n+    use sys_common::thread_local as os;\n+\n+    static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n+    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n+    if DTORS.get().is_null() {\n+        let v: Box<List> = box Vec::new();\n+        DTORS.set(Box::into_raw(v) as *mut u8);\n+    }\n+    let list: &mut List = &mut *(DTORS.get() as *mut List);\n+    list.push((t, dtor));\n+\n+    unsafe extern fn run_dtors(mut ptr: *mut u8) {\n+        while !ptr.is_null() {\n+            let list: Box<List> = Box::from_raw(ptr as *mut List);\n+            for &(ptr, dtor) in list.iter() {\n+                dtor(ptr);\n+            }\n+            ptr = DTORS.get();\n+            DTORS.set(ptr::null_mut());\n+        }\n+    }\n+}\n+\n+pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n+    let ptr = ptr as *mut Key<T>;\n+    // Right before we run the user destructor be sure to flag the\n+    // destructor as running for this thread so calls to `get` will return\n+    // `None`.\n+    (*ptr).dtor_running.set(true);\n+\n+    // The OSX implementation of TLS apparently had an odd aspect to it\n+    // where the pointer we have may be overwritten while this destructor\n+    // is running. Specifically if a TLS destructor re-accesses TLS it may\n+    // trigger a re-initialization of all TLS variables, paving over at\n+    // least some destroyed ones with initial values.\n+    //\n+    // This means that if we drop a TLS value in place on OSX that we could\n+    // revert the value to its original state halfway through the\n+    // destructor, which would be bad!\n+    //\n+    // Hence, we use `ptr::read` on OSX (to move to a \"safe\" location)\n+    // instead of drop_in_place.\n+    if cfg!(target_os = \"macos\") {\n+        ptr::read((*ptr).inner.get());\n+    } else {\n+        ptr::drop_in_place((*ptr).inner.get());\n+    }\n+}"}, {"sha": "b6de68a9dc1a9edfb1846b43aa16a1636e2755be", "filename": "src/libstd/sys/redox/fd.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n+\n+use io::{self, Read};\n+use mem;\n+use sys::{cvt, syscall};\n+use sys_common::AsInner;\n+use sys_common::io::read_to_end_uninitialized;\n+\n+pub struct FileDesc {\n+    fd: usize,\n+}\n+\n+impl FileDesc {\n+    pub fn new(fd: usize) -> FileDesc {\n+        FileDesc { fd: fd }\n+    }\n+\n+    pub fn raw(&self) -> usize { self.fd }\n+\n+    /// Extracts the actual filedescriptor without closing it.\n+    pub fn into_raw(self) -> usize {\n+        let fd = self.fd;\n+        mem::forget(self);\n+        fd\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        cvt(syscall::read(self.fd, buf))\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let mut me = self;\n+        (&mut me).read_to_end(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        cvt(syscall::write(self.fd, buf))\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<FileDesc> {\n+        let new_fd = cvt(syscall::dup(self.fd, &[]))?;\n+        Ok(FileDesc::new(new_fd))\n+    }\n+\n+    pub fn nonblocking(&self) -> io::Result<bool> {\n+        let flags = cvt(syscall::fcntl(self.fd, syscall::F_GETFL, 0))?;\n+        Ok(flags & syscall::O_NONBLOCK == syscall::O_NONBLOCK)\n+    }\n+\n+    pub fn set_cloexec(&self) -> io::Result<()> {\n+        let mut flags = cvt(syscall::fcntl(self.fd, syscall::F_GETFL, 0))?;\n+        flags |= syscall::O_CLOEXEC;\n+        cvt(syscall::fcntl(self.fd, syscall::F_SETFL, flags)).and(Ok(()))\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        let mut flags = cvt(syscall::fcntl(self.fd, syscall::F_GETFL, 0))?;\n+        if nonblocking {\n+            flags |= syscall::O_NONBLOCK;\n+        } else {\n+            flags &= !syscall::O_NONBLOCK;\n+        }\n+        cvt(syscall::fcntl(self.fd, syscall::F_SETFL, flags)).and(Ok(()))\n+    }\n+}\n+\n+impl<'a> Read for &'a FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        (**self).read(buf)\n+    }\n+\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n+}\n+\n+impl AsInner<usize> for FileDesc {\n+    fn as_inner(&self) -> &usize { &self.fd }\n+}\n+\n+impl Drop for FileDesc {\n+    fn drop(&mut self) {\n+        // Note that errors are ignored when closing a file descriptor. The\n+        // reason for this is that if an error occurs we don't actually know if\n+        // the file descriptor was closed or not, and if we retried (for\n+        // something like EINTR), we might close another valid file descriptor\n+        // (opened after we closed ours.\n+        let _ = syscall::close(self.fd);\n+    }\n+}"}, {"sha": "e3bd77f40099821ff6ece363b7f7ea5001e3a13f", "filename": "src/libstd/sys/redox/fs.rs", "status": "added", "additions": 469, "deletions": 0, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,469 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use os::unix::prelude::*;\n+\n+use ffi::{OsString, OsStr};\n+use fmt;\n+use io::{self, Error, ErrorKind, SeekFrom};\n+use path::{Path, PathBuf};\n+use sync::Arc;\n+use sys::fd::FileDesc;\n+use sys::time::SystemTime;\n+use sys::{cvt, syscall};\n+use sys_common::{AsInner, FromInner};\n+\n+pub struct File(FileDesc);\n+\n+#[derive(Clone)]\n+pub struct FileAttr {\n+    stat: syscall::Stat,\n+}\n+\n+pub struct ReadDir {\n+    data: Vec<u8>,\n+    i: usize,\n+    root: Arc<PathBuf>,\n+}\n+\n+struct Dir(FileDesc);\n+\n+unsafe impl Send for Dir {}\n+unsafe impl Sync for Dir {}\n+\n+pub struct DirEntry {\n+    root: Arc<PathBuf>,\n+    name: Box<[u8]>\n+}\n+\n+#[derive(Clone)]\n+pub struct OpenOptions {\n+    // generic\n+    read: bool,\n+    write: bool,\n+    append: bool,\n+    truncate: bool,\n+    create: bool,\n+    create_new: bool,\n+    // system-specific\n+    custom_flags: i32,\n+    mode: u16,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct FilePermissions { mode: u16 }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct FileType { mode: u16 }\n+\n+pub struct DirBuilder { mode: u16 }\n+\n+impl FileAttr {\n+    pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n+    pub fn perm(&self) -> FilePermissions {\n+        FilePermissions { mode: (self.stat.st_mode as u16) & 0o777 }\n+    }\n+\n+    pub fn file_type(&self) -> FileType {\n+        FileType { mode: self.stat.st_mode as u16 }\n+    }\n+}\n+\n+impl FileAttr {\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(syscall::TimeSpec {\n+            tv_sec: self.stat.st_mtime as i64,\n+            tv_nsec: self.stat.st_mtime_nsec as i32,\n+        }))\n+    }\n+\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(syscall::TimeSpec {\n+            tv_sec: self.stat.st_atime as i64,\n+            tv_nsec: self.stat.st_atime_nsec as i32,\n+        }))\n+    }\n+\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(syscall::TimeSpec {\n+            tv_sec: self.stat.st_ctime as i64,\n+            tv_nsec: self.stat.st_ctime_nsec as i32,\n+        }))\n+    }\n+}\n+\n+impl AsInner<syscall::Stat> for FileAttr {\n+    fn as_inner(&self) -> &syscall::Stat { &self.stat }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool { self.mode & 0o222 == 0 }\n+    pub fn set_readonly(&mut self, readonly: bool) {\n+        if readonly {\n+            self.mode &= !0o222;\n+        } else {\n+            self.mode |= 0o222;\n+        }\n+    }\n+    pub fn mode(&self) -> u32 { self.mode as u32 }\n+}\n+\n+impl FileType {\n+    pub fn is_dir(&self) -> bool { self.is(syscall::MODE_DIR) }\n+    pub fn is_file(&self) -> bool { self.is(syscall::MODE_FILE) }\n+    pub fn is_symlink(&self) -> bool { false /*FIXME: Implement symlink mode*/ }\n+\n+    pub fn is(&self, mode: u16) -> bool {\n+        self.mode & (syscall::MODE_DIR | syscall::MODE_FILE) == mode\n+    }\n+}\n+\n+impl FromInner<u32> for FilePermissions {\n+    fn from_inner(mode: u32) -> FilePermissions {\n+        FilePermissions { mode: mode as u16 }\n+    }\n+}\n+\n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n+        // Thus the result will be e g 'ReadDir(\"/home\")'\n+        fmt::Debug::fmt(&*self.root, f)\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        loop {\n+            let start = self.i;\n+            let mut i = self.i;\n+            while i < self.data.len() {\n+                self.i += 1;\n+                if self.data[i] == b'\\n' {\n+                    break;\n+                }\n+                i += 1;\n+            }\n+            if start < self.i {\n+                let ret = DirEntry {\n+                    name: self.data[start .. i].to_owned().into_boxed_slice(),\n+                    root: self.root.clone()\n+                };\n+                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n+                    return Some(Ok(ret))\n+                }\n+            } else {\n+                return None;\n+            }\n+        }\n+    }\n+}\n+\n+impl DirEntry {\n+    pub fn path(&self) -> PathBuf {\n+        self.root.join(OsStr::from_bytes(self.name_bytes()))\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n+        OsStr::from_bytes(self.name_bytes()).to_os_string()\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        lstat(&self.path())\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        lstat(&self.path()).map(|m| m.file_type())\n+    }\n+\n+    fn name_bytes(&self) -> &[u8] {\n+        &*self.name\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions {\n+        OpenOptions {\n+            // generic\n+            read: false,\n+            write: false,\n+            append: false,\n+            truncate: false,\n+            create: false,\n+            create_new: false,\n+            // system-specific\n+            custom_flags: 0,\n+            mode: 0o666,\n+        }\n+    }\n+\n+    pub fn read(&mut self, read: bool) { self.read = read; }\n+    pub fn write(&mut self, write: bool) { self.write = write; }\n+    pub fn append(&mut self, append: bool) { self.append = append; }\n+    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n+    pub fn create(&mut self, create: bool) { self.create = create; }\n+    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n+\n+    pub fn custom_flags(&mut self, flags: i32) { self.custom_flags = flags; }\n+    pub fn mode(&mut self, mode: u32) { self.mode = mode as u16; }\n+\n+    fn get_access_mode(&self) -> io::Result<usize> {\n+        match (self.read, self.write, self.append) {\n+            (true,  false, false) => Ok(syscall::O_RDONLY),\n+            (false, true,  false) => Ok(syscall::O_WRONLY),\n+            (true,  true,  false) => Ok(syscall::O_RDWR),\n+            (false, _,     true)  => Ok(syscall::O_WRONLY | syscall::O_APPEND),\n+            (true,  _,     true)  => Ok(syscall::O_RDWR | syscall::O_APPEND),\n+            (false, false, false) => Err(Error::from_raw_os_error(syscall::EINVAL)),\n+        }\n+    }\n+\n+    fn get_creation_mode(&self) -> io::Result<usize> {\n+        match (self.write, self.append) {\n+            (true, false) => {}\n+            (false, false) =>\n+                if self.truncate || self.create || self.create_new {\n+                    return Err(Error::from_raw_os_error(syscall::EINVAL));\n+                },\n+            (_, true) =>\n+                if self.truncate && !self.create_new {\n+                    return Err(Error::from_raw_os_error(syscall::EINVAL));\n+                },\n+        }\n+\n+        Ok(match (self.create, self.truncate, self.create_new) {\n+                (false, false, false) => 0,\n+                (true,  false, false) => syscall::O_CREAT,\n+                (false, true,  false) => syscall::O_TRUNC,\n+                (true,  true,  false) => syscall::O_CREAT | syscall::O_TRUNC,\n+                (_,      _,    true)  => syscall::O_CREAT | syscall::O_EXCL,\n+           })\n+    }\n+}\n+\n+impl File {\n+    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+        let flags = syscall::O_CLOEXEC |\n+                    opts.get_access_mode()? as usize |\n+                    opts.get_creation_mode()? as usize |\n+                    (opts.custom_flags as usize & !syscall::O_ACCMODE);\n+        let fd = cvt(syscall::open(path.to_str().unwrap(), flags | opts.mode as usize))?;\n+        Ok(File(FileDesc::new(fd)))\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        let mut stat = syscall::Stat::default();\n+        cvt(syscall::fstat(self.0.raw(), &mut stat))?;\n+        Ok(FileAttr { stat: stat })\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        cvt(syscall::fsync(self.0.raw()))?;\n+        Ok(())\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> {\n+        self.fsync()\n+    }\n+\n+    pub fn truncate(&self, size: u64) -> io::Result<()> {\n+        cvt(syscall::ftruncate(self.0.raw(), size as usize))?;\n+        Ok(())\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.0.read_to_end(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> { Ok(()) }\n+\n+    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n+        let (whence, pos) = match pos {\n+            // Casting to `i64` is fine, too large values will end up as\n+            // negative which will cause an error in `lseek64`.\n+            SeekFrom::Start(off) => (syscall::SEEK_SET, off as i64),\n+            SeekFrom::End(off) => (syscall::SEEK_END, off),\n+            SeekFrom::Current(off) => (syscall::SEEK_CUR, off),\n+        };\n+        let n = cvt(syscall::lseek(self.0.raw(), pos as isize, whence))?;\n+        Ok(n as u64)\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<File> {\n+        self.0.duplicate().map(File)\n+    }\n+\n+    pub fn dup(&self, buf: &[u8]) -> io::Result<File> {\n+        let fd = cvt(syscall::dup(*self.fd().as_inner() as usize, buf))?;\n+        Ok(File(FileDesc::new(fd)))\n+    }\n+\n+    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n+        set_perm(&self.path()?, perm)\n+    }\n+\n+    pub fn path(&self) -> io::Result<PathBuf> {\n+        let mut buf: [u8; 4096] = [0; 4096];\n+        let count = cvt(syscall::fpath(*self.fd().as_inner() as usize, &mut buf))?;\n+        Ok(PathBuf::from(unsafe { String::from_utf8_unchecked(Vec::from(&buf[..count])) }))\n+    }\n+\n+    pub fn fd(&self) -> &FileDesc { &self.0 }\n+\n+    pub fn into_fd(self) -> FileDesc { self.0 }\n+}\n+\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder { mode: 0o777 }\n+    }\n+\n+    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n+        let flags = syscall::O_CREAT | syscall::O_DIRECTORY | syscall::O_EXCL;\n+        let fd = cvt(syscall::open(p.to_str().unwrap(), flags | (self.mode as usize & 0o777)))?;\n+        let _ = syscall::close(fd);\n+        Ok(())\n+    }\n+\n+    pub fn set_mode(&mut self, mode: u32) {\n+        self.mode = mode as u16;\n+    }\n+}\n+\n+impl FromInner<usize> for File {\n+    fn from_inner(fd: usize) -> File {\n+        File(FileDesc::new(fd))\n+    }\n+}\n+\n+impl fmt::Debug for File {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut b = f.debug_struct(\"File\");\n+        b.field(\"fd\", &self.0.raw());\n+        if let Ok(path) = self.path() {\n+            b.field(\"path\", &path);\n+        }\n+        /*\n+        if let Some((read, write)) = get_mode(fd) {\n+            b.field(\"read\", &read).field(\"write\", &write);\n+        }\n+        */\n+        b.finish()\n+    }\n+}\n+\n+pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n+    let root = Arc::new(p.to_path_buf());\n+\n+    let flags = syscall::O_CLOEXEC | syscall::O_RDONLY | syscall::O_DIRECTORY;\n+    let fd = cvt(syscall::open(p.to_str().unwrap(), flags))?;\n+    let file = FileDesc::new(fd);\n+    let mut data = Vec::new();\n+    file.read_to_end(&mut data)?;\n+\n+    Ok(ReadDir { data: data, i: 0, root: root })\n+}\n+\n+pub fn unlink(p: &Path) -> io::Result<()> {\n+    cvt(syscall::unlink(p.to_str().unwrap()))?;\n+    Ok(())\n+}\n+\n+pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n+    ::sys_common::util::dumb_print(format_args!(\"Rename\\n\"));\n+    unimplemented!();\n+}\n+\n+pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n+    cvt(syscall::chmod(p.to_str().unwrap(), perm.mode as usize))?;\n+    Ok(())\n+}\n+\n+pub fn rmdir(p: &Path) -> io::Result<()> {\n+    cvt(syscall::rmdir(p.to_str().unwrap()))?;\n+    Ok(())\n+}\n+\n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    let filetype = lstat(path)?.file_type();\n+    if filetype.is_symlink() {\n+        unlink(path)\n+    } else {\n+        remove_dir_all_recursive(path)\n+    }\n+}\n+\n+fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n+    for child in readdir(path)? {\n+        let child = child?;\n+        if child.file_type()?.is_dir() {\n+            remove_dir_all_recursive(&child.path())?;\n+        } else {\n+            unlink(&child.path())?;\n+        }\n+    }\n+    rmdir(path)\n+}\n+\n+pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n+    canonicalize(p)\n+}\n+\n+pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    ::sys_common::util::dumb_print(format_args!(\"Symlink\\n\"));\n+    unimplemented!();\n+}\n+\n+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    ::sys_common::util::dumb_print(format_args!(\"Link\\n\"));\n+    unimplemented!();\n+}\n+\n+pub fn stat(p: &Path) -> io::Result<FileAttr> {\n+    let fd = cvt(syscall::open(p.to_str().unwrap(), syscall::O_CLOEXEC | syscall::O_STAT))?;\n+    let file = File(FileDesc::new(fd));\n+    file.file_attr()\n+}\n+\n+pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n+    stat(p)\n+}\n+\n+pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n+    let fd = cvt(syscall::open(p.to_str().unwrap(), syscall::O_CLOEXEC | syscall::O_STAT))?;\n+    let file = File(FileDesc::new(fd));\n+    file.path()\n+}\n+\n+pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n+    use fs::{File, set_permissions};\n+    if !from.is_file() {\n+        return Err(Error::new(ErrorKind::InvalidInput,\n+                              \"the source path is not an existing regular file\"))\n+    }\n+\n+    let mut reader = File::open(from)?;\n+    let mut writer = File::create(to)?;\n+    let perm = reader.metadata()?.permissions();\n+\n+    let ret = io::copy(&mut reader, &mut writer)?;\n+    set_permissions(to, perm)?;\n+    Ok(ret)\n+}"}, {"sha": "4c314b7a472585b93faa63ae619a2aa28f727894", "filename": "src/libstd/sys/redox/memchr.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Original implementation taken from rust-memchr\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+pub use sys_common::memchr::fallback::{memchr, memrchr};"}, {"sha": "96efa27c0d34b120ef7316835fd3d59624583355", "filename": "src/libstd/sys/redox/mod.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code, missing_docs, bad_style)]\n+\n+pub extern crate syscall;\n+\n+use io::{self, ErrorKind};\n+\n+pub mod args;\n+pub mod backtrace;\n+pub mod condvar;\n+pub mod env;\n+pub mod ext;\n+pub mod fast_thread_local;\n+pub mod fd;\n+pub mod fs;\n+pub mod memchr;\n+pub mod mutex;\n+pub mod net;\n+pub mod os;\n+pub mod os_str;\n+pub mod path;\n+pub mod pipe;\n+pub mod process;\n+pub mod rand;\n+pub mod rwlock;\n+pub mod stack_overflow;\n+pub mod stdio;\n+pub mod thread;\n+pub mod thread_local;\n+pub mod time;\n+\n+#[cfg(not(test))]\n+pub fn init() {\n+    use alloc::oom;\n+\n+    oom::set_oom_handler(oom_handler);\n+\n+    // A nicer handler for out-of-memory situations than the default one. This\n+    // one prints a message to stderr before aborting. It is critical that this\n+    // code does not allocate any memory since we are in an OOM situation. Any\n+    // errors are ignored while printing since there's nothing we can do about\n+    // them and we are about to exit anyways.\n+    fn oom_handler() -> ! {\n+        use intrinsics;\n+        let msg = \"fatal runtime error: out of memory\\n\";\n+        unsafe {\n+            let _ = syscall::write(2, msg.as_bytes());\n+            intrinsics::abort();\n+        }\n+    }\n+}\n+\n+pub fn decode_error_kind(errno: i32) -> ErrorKind {\n+    match errno {\n+        syscall::ECONNREFUSED => ErrorKind::ConnectionRefused,\n+        syscall::ECONNRESET => ErrorKind::ConnectionReset,\n+        syscall::EPERM | syscall::EACCES => ErrorKind::PermissionDenied,\n+        syscall::EPIPE => ErrorKind::BrokenPipe,\n+        syscall::ENOTCONN => ErrorKind::NotConnected,\n+        syscall::ECONNABORTED => ErrorKind::ConnectionAborted,\n+        syscall::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n+        syscall::EADDRINUSE => ErrorKind::AddrInUse,\n+        syscall::ENOENT => ErrorKind::NotFound,\n+        syscall::EINTR => ErrorKind::Interrupted,\n+        syscall::EINVAL => ErrorKind::InvalidInput,\n+        syscall::ETIMEDOUT => ErrorKind::TimedOut,\n+        syscall::EEXIST => ErrorKind::AlreadyExists,\n+\n+        // These two constants can have the same value on some systems,\n+        // but different values on others, so we can't use a match\n+        // clause\n+        x if x == syscall::EAGAIN || x == syscall::EWOULDBLOCK =>\n+            ErrorKind::WouldBlock,\n+\n+        _ => ErrorKind::Other,\n+    }\n+}\n+\n+pub fn cvt(result: Result<usize, syscall::Error>) -> io::Result<usize> {\n+    result.map_err(|err| io::Error::from_raw_os_error(err.errno))\n+}\n+\n+/// On Redox, use an illegal instruction to abort\n+pub unsafe fn abort_internal() -> ! {\n+    ::core::intrinsics::abort();\n+}"}, {"sha": "a995f597fc46adc8e99dc2c6a700b92288bae416", "filename": "src/libstd/sys/redox/mutex.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmutex.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,179 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use intrinsics::{atomic_cxchg, atomic_xchg};\n+use ptr;\n+\n+use sys::syscall::{futex, getpid, FUTEX_WAIT, FUTEX_WAKE};\n+\n+pub unsafe fn mutex_try_lock(m: *mut i32) -> bool {\n+    atomic_cxchg(m, 0, 1).0 == 0\n+}\n+\n+pub unsafe fn mutex_lock(m: *mut i32) {\n+    let mut c = 0;\n+    //Set to larger value for longer spin test\n+    for _i in 0..100 {\n+        c = atomic_cxchg(m, 0, 1).0;\n+        if c == 0 {\n+            break;\n+        }\n+        //cpu_relax()\n+    }\n+    if c == 1 {\n+        c = atomic_xchg(m, 2);\n+    }\n+    while c != 0 {\n+        let _ = futex(m, FUTEX_WAIT, 2, 0, ptr::null_mut());\n+        c = atomic_xchg(m, 2);\n+    }\n+}\n+\n+pub unsafe fn mutex_unlock(m: *mut i32) {\n+    if *m == 2 {\n+        *m = 0;\n+    } else if atomic_xchg(m, 0) == 1 {\n+        return;\n+    }\n+    //Set to larger value for longer spin test\n+    for _i in 0..100 {\n+        if *m != 0 {\n+            if atomic_cxchg(m, 1, 2).0 != 0 {\n+                return;\n+            }\n+        }\n+        //cpu_relax()\n+    }\n+    let _ = futex(m, FUTEX_WAKE, 1, 0, ptr::null_mut());\n+}\n+\n+pub struct Mutex {\n+    pub lock: UnsafeCell<i32>,\n+}\n+\n+impl Mutex {\n+    /// Create a new mutex.\n+    pub const fn new() -> Self {\n+        Mutex {\n+            lock: UnsafeCell::new(0),\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&self) {\n+        *self.lock.get() = 0;\n+    }\n+\n+    /// Try to lock the mutex\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        mutex_try_lock(self.lock.get())\n+    }\n+\n+    /// Lock the mutex\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        mutex_lock(self.lock.get());\n+    }\n+\n+    /// Unlock the mutex\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        mutex_unlock(self.lock.get());\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        *self.lock.get() = 0;\n+    }\n+}\n+\n+unsafe impl Send for Mutex {}\n+\n+unsafe impl Sync for Mutex {}\n+\n+pub struct ReentrantMutex {\n+    pub lock: UnsafeCell<i32>,\n+    pub owner: UnsafeCell<usize>,\n+    pub own_count: UnsafeCell<usize>,\n+}\n+\n+impl ReentrantMutex {\n+    pub const fn uninitialized() -> Self {\n+        ReentrantMutex {\n+            lock: UnsafeCell::new(0),\n+            owner: UnsafeCell::new(0),\n+            own_count: UnsafeCell::new(0),\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {\n+        *self.lock.get() = 0;\n+        *self.owner.get() = 0;\n+        *self.own_count.get() = 0;\n+    }\n+\n+    /// Try to lock the mutex\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let pid = getpid().unwrap();\n+        if *self.own_count.get() > 0 && *self.owner.get() == pid {\n+            *self.own_count.get() += 1;\n+            true\n+        } else {\n+            if mutex_try_lock(self.lock.get()) {\n+                *self.owner.get() = pid;\n+                *self.own_count.get() = 1;\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Lock the mutex\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let pid = getpid().unwrap();\n+        if *self.own_count.get() > 0 && *self.owner.get() == pid {\n+            *self.own_count.get() += 1;\n+        } else {\n+            mutex_lock(self.lock.get());\n+            *self.owner.get() = pid;\n+            *self.own_count.get() = 1;\n+        }\n+    }\n+\n+    /// Unlock the mutex\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        let pid = getpid().unwrap();\n+        if *self.own_count.get() > 0 && *self.owner.get() == pid {\n+            *self.own_count.get() -= 1;\n+            if *self.own_count.get() == 0 {\n+                *self.owner.get() = 0;\n+                mutex_unlock(self.lock.get());\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        *self.lock.get() = 0;\n+        *self.owner.get() = 0;\n+        *self.own_count.get() = 0;\n+    }\n+}\n+\n+unsafe impl Send for ReentrantMutex {}\n+\n+unsafe impl Sync for ReentrantMutex {}"}, {"sha": "8e6aaeb0293ad6d468b229ce3d2cceec5b7eb1ec", "filename": "src/libstd/sys/redox/net/dns/answer.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fanswer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fanswer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fanswer.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use string::String;\n+use vec::Vec;\n+\n+#[derive(Clone, Debug)]\n+pub struct DnsAnswer {\n+    pub name: String,\n+    pub a_type: u16,\n+    pub a_class: u16,\n+    pub ttl_a: u16,\n+    pub ttl_b: u16,\n+    pub data: Vec<u8>\n+}"}, {"sha": "43c4fe7ac9d96ad23aa1eb14b87b66935a7e9219", "filename": "src/libstd/sys/redox/net/dns/mod.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,217 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::answer::DnsAnswer;\n+pub use self::query::DnsQuery;\n+\n+use slice;\n+use u16;\n+use string::String;\n+use vec::Vec;\n+\n+mod answer;\n+mod query;\n+\n+#[unstable(feature = \"n16\", issue=\"0\")]\n+#[allow(non_camel_case_types)]\n+#[derive(Copy, Clone, Debug, Default)]\n+#[repr(packed)]\n+pub struct n16 {\n+    inner: u16\n+}\n+\n+impl n16 {\n+    #[unstable(feature = \"n16\", issue=\"0\")]\n+    pub fn as_bytes(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts((&self.inner as *const u16) as *const u8, 2) }\n+    }\n+\n+    #[unstable(feature = \"n16\", issue=\"0\")]\n+    pub fn from_bytes(bytes: &[u8]) -> Self {\n+        n16 {\n+            inner: unsafe { slice::from_raw_parts(bytes.as_ptr() as *const u16, bytes.len()/2)[0] }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"n16\", issue=\"0\")]\n+impl From<u16> for n16 {\n+    fn from(value: u16) -> Self {\n+        n16 {\n+            inner: value.to_be()\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"n16\", issue=\"0\")]\n+impl From<n16> for u16 {\n+    fn from(value: n16) -> Self {\n+        u16::from_be(value.inner)\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Dns {\n+    pub transaction_id: u16,\n+    pub flags: u16,\n+    pub queries: Vec<DnsQuery>,\n+    pub answers: Vec<DnsAnswer>\n+}\n+\n+impl Dns {\n+    pub fn compile(&self) -> Vec<u8> {\n+        let mut data = Vec::new();\n+\n+        macro_rules! push_u8 {\n+            ($value:expr) => {\n+                data.push($value);\n+            };\n+        };\n+\n+        macro_rules! push_n16 {\n+            ($value:expr) => {\n+                data.extend_from_slice(n16::from($value).as_bytes());\n+            };\n+        };\n+\n+        push_n16!(self.transaction_id);\n+        push_n16!(self.flags);\n+        push_n16!(self.queries.len() as u16);\n+        push_n16!(self.answers.len() as u16);\n+        push_n16!(0);\n+        push_n16!(0);\n+\n+        for query in self.queries.iter() {\n+            for part in query.name.split('.') {\n+                push_u8!(part.len() as u8);\n+                data.extend_from_slice(part.as_bytes());\n+            }\n+            push_u8!(0);\n+            push_n16!(query.q_type);\n+            push_n16!(query.q_class);\n+        }\n+\n+        data\n+    }\n+\n+    pub fn parse(data: &[u8]) -> Result<Self, String> {\n+        let mut i = 0;\n+\n+        macro_rules! pop_u8 {\n+            () => {\n+                {\n+                    i += 1;\n+                    if i > data.len() {\n+                        return Err(format!(\"{}: {}: pop_u8\", file!(), line!()));\n+                    }\n+                    data[i - 1]\n+                }\n+            };\n+        };\n+\n+        macro_rules! pop_n16 {\n+            () => {\n+                {\n+                    i += 2;\n+                    if i > data.len() {\n+                        return Err(format!(\"{}: {}: pop_n16\", file!(), line!()));\n+                    }\n+                    u16::from(n16::from_bytes(&data[i - 2 .. i]))\n+                }\n+            };\n+        };\n+\n+        macro_rules! pop_data {\n+            () => {\n+                {\n+                    let mut data = Vec::new();\n+\n+                    let data_len = pop_n16!();\n+                    for _data_i in 0..data_len {\n+                        data.push(pop_u8!());\n+                    }\n+\n+                    data\n+                }\n+            };\n+        };\n+\n+        macro_rules! pop_name {\n+            () => {\n+                {\n+                    let mut name = String::new();\n+\n+                    loop {\n+                        let name_len = pop_u8!();\n+                        if name_len == 0 {\n+                            break;\n+                        }\n+                        if ! name.is_empty() {\n+                            name.push('.');\n+                        }\n+                        for _name_i in 0..name_len {\n+                            name.push(pop_u8!() as char);\n+                        }\n+                    }\n+\n+                    name\n+                }\n+            };\n+        };\n+\n+        let transaction_id = pop_n16!();\n+        let flags = pop_n16!();\n+        let queries_len = pop_n16!();\n+        let answers_len = pop_n16!();\n+        pop_n16!();\n+        pop_n16!();\n+\n+        let mut queries = Vec::new();\n+        for _query_i in 0..queries_len {\n+            queries.push(DnsQuery {\n+                name: pop_name!(),\n+                q_type: pop_n16!(),\n+                q_class: pop_n16!()\n+            });\n+        }\n+\n+        let mut answers = Vec::new();\n+        for _answer_i in 0..answers_len {\n+            let name_ind = 0b11000000;\n+            let name_test = pop_u8!();\n+            i -= 1;\n+\n+            answers.push(DnsAnswer {\n+                name: if name_test & name_ind == name_ind {\n+                    let name_off = pop_n16!() - ((name_ind as u16) << 8);\n+                    let old_i = i;\n+                    i = name_off as usize;\n+                    let name = pop_name!();\n+                    i = old_i;\n+                    name\n+                } else {\n+                    pop_name!()\n+                },\n+                a_type: pop_n16!(),\n+                a_class: pop_n16!(),\n+                ttl_a: pop_n16!(),\n+                ttl_b: pop_n16!(),\n+                data: pop_data!()\n+            });\n+        }\n+\n+        Ok(Dns {\n+            transaction_id: transaction_id,\n+            flags: flags,\n+            queries: queries,\n+            answers: answers,\n+        })\n+    }\n+}"}, {"sha": "b0dcdcb624abdf347b26a12ff1a2d89fd195eed6", "filename": "src/libstd/sys/redox/net/dns/query.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fquery.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use string::String;\n+\n+#[derive(Clone, Debug)]\n+pub struct DnsQuery {\n+    pub name: String,\n+    pub q_type: u16,\n+    pub q_class: u16\n+}"}, {"sha": "334c5e51c39b4d3b9267520ac7906665772a712e", "filename": "src/libstd/sys/redox/net/mod.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fs::File;\n+use io::{Error, Result, Read};\n+use iter::Iterator;\n+use net::{Ipv4Addr, SocketAddr, SocketAddrV4};\n+use str::FromStr;\n+use string::{String, ToString};\n+use sys::syscall::EINVAL;\n+use time;\n+use vec::{IntoIter, Vec};\n+\n+use self::dns::{Dns, DnsQuery};\n+\n+pub extern crate libc as netc;\n+pub use self::tcp::{TcpStream, TcpListener};\n+pub use self::udp::UdpSocket;\n+\n+mod dns;\n+mod tcp;\n+mod udp;\n+\n+pub struct LookupHost(IntoIter<SocketAddr>);\n+\n+impl Iterator for LookupHost {\n+    type Item = SocketAddr;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.0.next()\n+    }\n+}\n+\n+pub fn lookup_host(host: &str) -> Result<LookupHost> {\n+    let mut ip_string = String::new();\n+    File::open(\"/etc/net/ip\")?.read_to_string(&mut ip_string)?;\n+    let ip: Vec<u8> = ip_string.trim().split(\".\").map(|part| part.parse::<u8>()\n+                               .unwrap_or(0)).collect();\n+\n+    let mut dns_string = String::new();\n+    File::open(\"/etc/net/dns\")?.read_to_string(&mut dns_string)?;\n+    let dns: Vec<u8> = dns_string.trim().split(\".\").map(|part| part.parse::<u8>()\n+                                 .unwrap_or(0)).collect();\n+\n+    if ip.len() == 4 && dns.len() == 4 {\n+        let time = time::SystemTime::now().duration_since(time::UNIX_EPOCH).unwrap();\n+        let tid = (time.subsec_nanos() >> 16) as u16;\n+\n+        let packet = Dns {\n+            transaction_id: tid,\n+            flags: 0x0100,\n+            queries: vec![DnsQuery {\n+                name: host.to_string(),\n+                q_type: 0x0001,\n+                q_class: 0x0001,\n+            }],\n+            answers: vec![]\n+        };\n+\n+        let packet_data = packet.compile();\n+\n+        let my_ip = Ipv4Addr::new(ip[0], ip[1], ip[2], ip[3]);\n+        let dns_ip = Ipv4Addr::new(dns[0], dns[1], dns[2], dns[3]);\n+        let socket = UdpSocket::bind(&SocketAddr::V4(SocketAddrV4::new(my_ip, 0)))?;\n+        socket.connect(&SocketAddr::V4(SocketAddrV4::new(dns_ip, 53)))?;\n+        socket.send(&packet_data)?;\n+\n+        let mut buf = [0; 65536];\n+        let count = socket.recv(&mut buf)?;\n+\n+        match Dns::parse(&buf[.. count]) {\n+            Ok(response) => {\n+                let mut addrs = vec![];\n+                for answer in response.answers.iter() {\n+                    if answer.a_type == 0x0001 && answer.a_class == 0x0001\n+                       && answer.data.len() == 4\n+                    {\n+                        let answer_ip = Ipv4Addr::new(answer.data[0],\n+                                                      answer.data[1],\n+                                                      answer.data[2],\n+                                                      answer.data[3]);\n+                        addrs.push(SocketAddr::V4(SocketAddrV4::new(answer_ip, 0)));\n+                    }\n+                }\n+                Ok(LookupHost(addrs.into_iter()))\n+            },\n+            Err(_err) => Err(Error::from_raw_os_error(EINVAL))\n+        }\n+    } else {\n+        Err(Error::from_raw_os_error(EINVAL))\n+    }\n+}\n+\n+fn path_to_peer_addr(path_str: &str) -> SocketAddr {\n+    let mut parts = path_str.split('/').next().unwrap_or(\"\").split(':').skip(1);\n+    let host = Ipv4Addr::from_str(parts.next().unwrap_or(\"\")).unwrap_or(Ipv4Addr::new(0, 0, 0, 0));\n+    let port = parts.next().unwrap_or(\"\").parse::<u16>().unwrap_or(0);\n+    SocketAddr::V4(SocketAddrV4::new(host, port))\n+}\n+\n+fn path_to_local_addr(path_str: &str) -> SocketAddr {\n+    let mut parts = path_str.split('/').nth(1).unwrap_or(\"\").split(':');\n+    let host = Ipv4Addr::from_str(parts.next().unwrap_or(\"\")).unwrap_or(Ipv4Addr::new(0, 0, 0, 0));\n+    let port = parts.next().unwrap_or(\"\").parse::<u16>().unwrap_or(0);\n+    SocketAddr::V4(SocketAddrV4::new(host, port))\n+}"}, {"sha": "1bfec2e861a68295140c9b33f4b24292cae4ffe5", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,170 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io::{Error, ErrorKind, Result};\n+use net::{SocketAddr, Shutdown};\n+use path::Path;\n+use sys::fs::{File, OpenOptions};\n+use time::Duration;\n+use vec::Vec;\n+\n+use super::{path_to_peer_addr, path_to_local_addr};\n+\n+#[derive(Debug)]\n+pub struct TcpStream(File);\n+\n+impl TcpStream {\n+    pub fn connect(addr: &SocketAddr) -> Result<TcpStream> {\n+        let path = format!(\"tcp:{}\", addr);\n+        let mut options = OpenOptions::new();\n+        options.read(true);\n+        options.write(true);\n+        Ok(TcpStream(File::open(&Path::new(path.as_str()), &options)?))\n+    }\n+\n+    pub fn duplicate(&self) -> Result<TcpStream> {\n+        Ok(TcpStream(self.0.dup(&[])?))\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> Result<usize> {\n+        self.0.read_to_end(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn take_error(&self) -> Result<Option<Error>> {\n+        Ok(None)\n+    }\n+\n+    pub fn peer_addr(&self) -> Result<SocketAddr> {\n+        let path = self.0.path()?;\n+        Ok(path_to_peer_addr(path.to_str().unwrap_or(\"\")))\n+    }\n+\n+    pub fn socket_addr(&self) -> Result<SocketAddr> {\n+        let path = self.0.path()?;\n+        Ok(path_to_local_addr(path.to_str().unwrap_or(\"\")))\n+    }\n+\n+    pub fn shutdown(&self, _how: Shutdown) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::shutdown not implemented\"))\n+    }\n+\n+    pub fn nodelay(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::nodelay not implemented\"))\n+    }\n+\n+    pub fn nonblocking(&self) -> Result<bool> {\n+        self.0.fd().nonblocking()\n+    }\n+\n+    pub fn only_v6(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::only_v6 not implemented\"))\n+    }\n+\n+    pub fn ttl(&self) -> Result<u32> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::ttl not implemented\"))\n+    }\n+\n+    pub fn read_timeout(&self) -> Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::read_timeout not implemented\"))\n+    }\n+\n+    pub fn write_timeout(&self) -> Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::write_timeout not implemented\"))\n+    }\n+\n+    pub fn set_nodelay(&self, _nodelay: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::set_nodelay not implemented\"))\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> Result<()> {\n+        self.0.fd().set_nonblocking(nonblocking)\n+    }\n+\n+    pub fn set_only_v6(&self, _only_v6: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::set_only_v6 not implemented\"))\n+    }\n+\n+    pub fn set_ttl(&self, _ttl: u32) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::set_ttl not implemented\"))\n+    }\n+\n+    pub fn set_read_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::set_read_timeout not implemented\"))\n+    }\n+\n+    pub fn set_write_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpStream::set_write_timeout not implemented\"))\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct TcpListener(File);\n+\n+impl TcpListener {\n+    pub fn bind(addr: &SocketAddr) -> Result<TcpListener> {\n+        let path = format!(\"tcp:/{}\", addr);\n+        let mut options = OpenOptions::new();\n+        options.read(true);\n+        options.write(true);\n+        Ok(TcpListener(File::open(&Path::new(path.as_str()), &options)?))\n+    }\n+\n+    pub fn accept(&self) -> Result<(TcpStream, SocketAddr)> {\n+        let file = self.0.dup(b\"listen\")?;\n+        let path = file.path()?;\n+        let peer_addr = path_to_peer_addr(path.to_str().unwrap_or(\"\"));\n+        Ok((TcpStream(file), peer_addr))\n+    }\n+\n+    pub fn duplicate(&self) -> Result<TcpListener> {\n+        Ok(TcpListener(self.0.dup(&[])?))\n+    }\n+\n+    pub fn take_error(&self) -> Result<Option<Error>> {\n+        Ok(None)\n+    }\n+\n+    pub fn socket_addr(&self) -> Result<SocketAddr> {\n+        let path = self.0.path()?;\n+        Ok(path_to_local_addr(path.to_str().unwrap_or(\"\")))\n+    }\n+\n+    pub fn nonblocking(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"TcpListener::nonblocking not implemented\"))\n+    }\n+\n+    pub fn only_v6(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"TcpListener::only_v6 not implemented\"))\n+    }\n+\n+    pub fn ttl(&self) -> Result<u32> {\n+        Err(Error::new(ErrorKind::Other, \"TcpListener::ttl not implemented\"))\n+    }\n+\n+    pub fn set_nonblocking(&self, _nonblocking: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpListener::set_nonblocking not implemented\"))\n+    }\n+\n+    pub fn set_only_v6(&self, _only_v6: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpListener::set_only_v6 not implemented\"))\n+    }\n+\n+    pub fn set_ttl(&self, _ttl: u32) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"TcpListener::set_ttl not implemented\"))\n+    }\n+}"}, {"sha": "b81508e8f0de129a23945641d3951ac52c8a8f4f", "filename": "src/libstd/sys/redox/net/udp.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use io::{Error, ErrorKind, Result};\n+use net::{SocketAddr, Ipv4Addr, Ipv6Addr};\n+use path::Path;\n+use sys::fs::{File, OpenOptions};\n+use time::Duration;\n+\n+use super::{path_to_peer_addr, path_to_local_addr};\n+\n+#[derive(Debug)]\n+pub struct UdpSocket(File, UnsafeCell<Option<SocketAddr>>);\n+\n+impl UdpSocket {\n+    pub fn bind(addr: &SocketAddr) -> Result<UdpSocket> {\n+        let path = format!(\"udp:/{}\", addr);\n+        let mut options = OpenOptions::new();\n+        options.read(true);\n+        options.write(true);\n+        Ok(UdpSocket(File::open(&Path::new(path.as_str()), &options)?, UnsafeCell::new(None)))\n+    }\n+\n+    fn get_conn(&self) -> &mut Option<SocketAddr> {\n+        unsafe { &mut *(self.1.get()) }\n+    }\n+\n+    pub fn connect(&self, addr: &SocketAddr) -> Result<()> {\n+        unsafe { *self.1.get() = Some(*addr) };\n+        Ok(())\n+    }\n+\n+    pub fn duplicate(&self) -> Result<UdpSocket> {\n+        let new_bind = self.0.dup(&[])?;\n+        let new_conn = *self.get_conn();\n+        Ok(UdpSocket(new_bind, UnsafeCell::new(new_conn)))\n+    }\n+\n+    pub fn recv_from(&self, buf: &mut [u8]) -> Result<(usize, SocketAddr)> {\n+        let from = self.0.dup(b\"listen\")?;\n+        let path = from.path()?;\n+        let peer_addr = path_to_peer_addr(path.to_str().unwrap_or(\"\"));\n+        let count = from.read(buf)?;\n+        Ok((count, peer_addr))\n+    }\n+\n+    pub fn recv(&self, buf: &mut [u8]) -> Result<usize> {\n+        if let Some(addr) = *self.get_conn() {\n+            let from = self.0.dup(format!(\"{}\", addr).as_bytes())?;\n+            from.read(buf)\n+        } else {\n+            Err(Error::new(ErrorKind::Other, \"UdpSocket::recv not connected\"))\n+        }\n+    }\n+\n+    pub fn send_to(&self, buf: &[u8], addr: &SocketAddr) -> Result<usize> {\n+        let to = self.0.dup(format!(\"{}\", addr).as_bytes())?;\n+        to.write(buf)\n+    }\n+\n+    pub fn send(&self, buf: &[u8]) -> Result<usize> {\n+        if let Some(addr) = *self.get_conn() {\n+            self.send_to(buf, &addr)\n+        } else {\n+            Err(Error::new(ErrorKind::Other, \"UdpSocket::send not connected\"))\n+        }\n+    }\n+\n+    pub fn take_error(&self) -> Result<Option<Error>> {\n+        Ok(None)\n+    }\n+\n+    pub fn socket_addr(&self) -> Result<SocketAddr> {\n+        let path = self.0.path()?;\n+        Ok(path_to_local_addr(path.to_str().unwrap_or(\"\")))\n+    }\n+\n+    pub fn broadcast(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::broadcast not implemented\"))\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::multicast_loop_v4 not implemented\"))\n+    }\n+\n+    pub fn multicast_loop_v6(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::multicast_loop_v6 not implemented\"))\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> Result<u32> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::multicast_ttl_v4 not implemented\"))\n+    }\n+\n+    pub fn nonblocking(&self) -> Result<bool> {\n+        self.0.fd().nonblocking()\n+    }\n+\n+    pub fn only_v6(&self) -> Result<bool> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::only_v6 not implemented\"))\n+    }\n+\n+    pub fn ttl(&self) -> Result<u32> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::ttl not implemented\"))\n+    }\n+\n+    pub fn read_timeout(&self) -> Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::read_timeout not implemented\"))\n+    }\n+\n+    pub fn write_timeout(&self) -> Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::write_timeout not implemented\"))\n+    }\n+\n+    pub fn set_broadcast(&self, _broadcast: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_broadcast not implemented\"))\n+    }\n+\n+    pub fn set_multicast_loop_v4(&self, _multicast_loop_v4: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_multicast_loop_v4 not implemented\"))\n+    }\n+\n+    pub fn set_multicast_loop_v6(&self, _multicast_loop_v6: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_multicast_loop_v6 not implemented\"))\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, _multicast_ttl_v4: u32) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_multicast_ttl_v4 not implemented\"))\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> Result<()> {\n+        self.0.fd().set_nonblocking(nonblocking)\n+    }\n+\n+    pub fn set_only_v6(&self, _only_v6: bool) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_only_v6 not implemented\"))\n+    }\n+\n+    pub fn set_ttl(&self, _ttl: u32) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_ttl not implemented\"))\n+    }\n+\n+    pub fn set_read_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_read_timeout not implemented\"))\n+    }\n+\n+    pub fn set_write_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_write_timeout not implemented\"))\n+    }\n+\n+    pub fn join_multicast_v4(&self, _multiaddr: &Ipv4Addr, _interface: &Ipv4Addr) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::join_multicast_v4 not implemented\"))\n+    }\n+\n+    pub fn join_multicast_v6(&self, _multiaddr: &Ipv6Addr, _interface: u32) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::join_multicast_v6 not implemented\"))\n+    }\n+\n+    pub fn leave_multicast_v4(&self, _multiaddr: &Ipv4Addr, _interface: &Ipv4Addr) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::leave_multicast_v4 not implemented\"))\n+    }\n+\n+    pub fn leave_multicast_v6(&self, _multiaddr: &Ipv6Addr, _interface: u32) -> Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UdpSocket::leave_multicast_v6 not implemented\"))\n+    }\n+}"}, {"sha": "135e972bca4012af4c19030e47564e1fadc09471", "filename": "src/libstd/sys/redox/os.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,204 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of `std::os` functionality for unix systems\n+\n+#![allow(unused_imports)] // lots of cfg code here\n+\n+use os::unix::prelude::*;\n+\n+use error::Error as StdError;\n+use ffi::{OsString, OsStr};\n+use fmt;\n+use io::{self, Read, Write};\n+use iter;\n+use marker::PhantomData;\n+use mem;\n+use memchr;\n+use path::{self, PathBuf};\n+use ptr;\n+use slice;\n+use str;\n+use sys_common::mutex::Mutex;\n+use sys::{cvt, fd, syscall};\n+use vec;\n+\n+const TMPBUF_SZ: usize = 128;\n+static ENV_LOCK: Mutex = Mutex::new();\n+\n+/// Returns the platform-specific value of errno\n+pub fn errno() -> i32 {\n+    0\n+}\n+\n+/// Gets a detailed string description for the given error number.\n+pub fn error_string(errno: i32) -> String {\n+    if let Some(string) = syscall::STR_ERROR.get(errno as usize) {\n+        string.to_string()\n+    } else {\n+        \"unknown error\".to_string()\n+    }\n+}\n+\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    let mut buf = [0; 4096];\n+    let count = cvt(syscall::getcwd(&mut buf))?;\n+    Ok(PathBuf::from(OsString::from_vec(buf[.. count].to_vec())))\n+}\n+\n+pub fn chdir(p: &path::Path) -> io::Result<()> {\n+    cvt(syscall::chdir(p.to_str().unwrap())).and(Ok(()))\n+}\n+\n+pub struct SplitPaths<'a> {\n+    iter: iter::Map<slice::Split<'a, u8, fn(&u8) -> bool>,\n+                    fn(&'a [u8]) -> PathBuf>,\n+}\n+\n+pub fn split_paths(unparsed: &OsStr) -> SplitPaths {\n+    fn bytes_to_path(b: &[u8]) -> PathBuf {\n+        PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n+    }\n+    fn is_colon(b: &u8) -> bool { *b == b':' }\n+    let unparsed = unparsed.as_bytes();\n+    SplitPaths {\n+        iter: unparsed.split(is_colon as fn(&u8) -> bool)\n+                      .map(bytes_to_path as fn(&[u8]) -> PathBuf)\n+    }\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+{\n+    let mut joined = Vec::new();\n+    let sep = b':';\n+\n+    for (i, path) in paths.enumerate() {\n+        let path = path.as_ref().as_bytes();\n+        if i > 0 { joined.push(sep) }\n+        if path.contains(&sep) {\n+            return Err(JoinPathsError)\n+        }\n+        joined.extend_from_slice(path);\n+    }\n+    Ok(OsStringExt::from_vec(joined))\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"path segment contains separator `:`\".fmt(f)\n+    }\n+}\n+\n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str { \"failed to join paths\" }\n+}\n+\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    use fs::File;\n+\n+    let mut file = File::open(\"sys:exe\")?;\n+\n+    let mut path = String::new();\n+    file.read_to_string(&mut path)?;\n+\n+    if path.ends_with('\\n') {\n+        path.pop();\n+    }\n+\n+    Ok(PathBuf::from(path))\n+}\n+\n+pub struct Env {\n+    iter: vec::IntoIter<(OsString, OsString)>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Iterator for Env {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+/// Returns a vector of (variable, value) byte-vector pairs for all the\n+/// environment variables of the current process.\n+pub fn env() -> Env {\n+    let mut variables: Vec<(OsString, OsString)> = Vec::new();\n+    if let Ok(mut file) = ::fs::File::open(\"env:\") {\n+        let mut string = String::new();\n+        if file.read_to_string(&mut string).is_ok() {\n+            for line in string.lines() {\n+                let mut parts = line.splitn(2, '=');\n+                if let Some(name) = parts.next() {\n+                    let value = parts.next().unwrap_or(\"\");\n+                    variables.push((OsString::from(name.to_string()),\n+                                    OsString::from(value.to_string())));\n+                }\n+            }\n+        }\n+    }\n+    Env { iter: variables.into_iter(), _dont_send_or_sync_me: PhantomData }\n+}\n+\n+pub fn getenv(key: &OsStr) -> io::Result<Option<OsString>> {\n+    if ! key.is_empty() {\n+        if let Ok(mut file) = ::fs::File::open(&(\"env:\".to_owned() + key.to_str().unwrap())) {\n+            let mut string = String::new();\n+            file.read_to_string(&mut string)?;\n+            Ok(Some(OsString::from(string)))\n+        } else {\n+            Ok(None)\n+        }\n+    } else {\n+        Ok(None)\n+    }\n+}\n+\n+pub fn setenv(key: &OsStr, value: &OsStr) -> io::Result<()> {\n+    if ! key.is_empty() {\n+        let mut file = ::fs::File::open(&(\"env:\".to_owned() + key.to_str().unwrap()))?;\n+        file.write_all(value.as_bytes())?;\n+        file.set_len(value.len() as u64)?;\n+    }\n+    Ok(())\n+}\n+\n+pub fn unsetenv(key: &OsStr) -> io::Result<()> {\n+    ::fs::remove_file(&(\"env:\".to_owned() + key.to_str().unwrap()))?;\n+    Ok(())\n+}\n+\n+pub fn page_size() -> usize {\n+    4096\n+}\n+\n+pub fn temp_dir() -> PathBuf {\n+    ::env::var_os(\"TMPDIR\").map(PathBuf::from).unwrap_or_else(|| {\n+        PathBuf::from(\"/tmp\")\n+    })\n+}\n+\n+pub fn home_dir() -> Option<PathBuf> {\n+    return ::env::var_os(\"HOME\").map(PathBuf::from);\n+}\n+\n+pub fn exit(code: i32) -> ! {\n+    let _ = syscall::exit(code as usize);\n+    unreachable!();\n+}"}, {"sha": "8922bf04f56da3c195aa775eb8c48599ef8b1e9b", "filename": "src/libstd/sys/redox/os_str.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The underlying OsString/OsStr implementation on Unix systems: just\n+/// a `Vec<u8>`/`[u8]`.\n+\n+use borrow::Cow;\n+use fmt::{self, Debug};\n+use str;\n+use mem;\n+use sys_common::{AsInner, IntoInner};\n+\n+#[derive(Clone, Hash)]\n+pub struct Buf {\n+    pub inner: Vec<u8>\n+}\n+\n+pub struct Slice {\n+    pub inner: [u8]\n+}\n+\n+impl Debug for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.to_string_lossy().fmt(formatter)\n+    }\n+}\n+\n+impl Debug for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.as_slice().fmt(formatter)\n+    }\n+}\n+\n+impl IntoInner<Vec<u8>> for Buf {\n+    fn into_inner(self) -> Vec<u8> {\n+        self.inner\n+    }\n+}\n+\n+impl AsInner<[u8]> for Buf {\n+    fn as_inner(&self) -> &[u8] {\n+        &self.inner\n+    }\n+}\n+\n+\n+impl Buf {\n+    pub fn from_string(s: String) -> Buf {\n+        Buf { inner: s.into_bytes() }\n+    }\n+\n+    #[inline]\n+    pub fn with_capacity(capacity: usize) -> Buf {\n+        Buf {\n+            inner: Vec::with_capacity(capacity)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.inner.clear()\n+    }\n+\n+    #[inline]\n+    pub fn capacity(&self) -> usize {\n+        self.inner.capacity()\n+    }\n+\n+    #[inline]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.inner.reserve(additional)\n+    }\n+\n+    #[inline]\n+    pub fn reserve_exact(&mut self, additional: usize) {\n+        self.inner.reserve_exact(additional)\n+    }\n+\n+    pub fn as_slice(&self) -> &Slice {\n+        unsafe { mem::transmute(&*self.inner) }\n+    }\n+\n+    pub fn into_string(self) -> Result<String, Buf> {\n+        String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() } )\n+    }\n+\n+    pub fn push_slice(&mut self, s: &Slice) {\n+        self.inner.extend_from_slice(&s.inner)\n+    }\n+}\n+\n+impl Slice {\n+    fn from_u8_slice(s: &[u8]) -> &Slice {\n+        unsafe { mem::transmute(s) }\n+    }\n+\n+    pub fn from_str(s: &str) -> &Slice {\n+        Slice::from_u8_slice(s.as_bytes())\n+    }\n+\n+    pub fn to_str(&self) -> Option<&str> {\n+        str::from_utf8(&self.inner).ok()\n+    }\n+\n+    pub fn to_string_lossy(&self) -> Cow<str> {\n+        String::from_utf8_lossy(&self.inner)\n+    }\n+\n+    pub fn to_owned(&self) -> Buf {\n+        Buf { inner: self.inner.to_vec() }\n+    }\n+}"}, {"sha": "e6a267dd5d9130c1862a2992aed79077c9df3a75", "filename": "src/libstd/sys/redox/path.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fpath.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsStr;\n+use path::Prefix;\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+pub fn parse_prefix(path: &OsStr) -> Option<Prefix> {\n+    if let Some(path_str) = path.to_str() {\n+        if let Some(_i) = path_str.find(':') {\n+            // FIXME: Redox specific prefix\n+            // Some(Prefix::Verbatim(OsStr::new(&path_str[..i])))\n+            None\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+pub const MAIN_SEP_STR: &'static str = \"/\";\n+pub const MAIN_SEP: char = '/';"}, {"sha": "e7240fbe7bfb217950eebd2853c84e6498b60a51", "filename": "src/libstd/sys/redox/pipe.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,107 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::{cvt, syscall};\n+use sys::fd::FileDesc;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Anonymous pipes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct AnonPipe(FileDesc);\n+\n+pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n+    let mut fds = [0; 2];\n+    cvt(syscall::pipe2(&mut fds, syscall::O_CLOEXEC))?;\n+    Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))))\n+}\n+\n+impl AnonPipe {\n+    pub fn from_fd(fd: FileDesc) -> io::Result<AnonPipe> {\n+        fd.set_cloexec()?;\n+        Ok(AnonPipe(fd))\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.0.read_to_end(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn fd(&self) -> &FileDesc { &self.0 }\n+    pub fn into_fd(self) -> FileDesc { self.0 }\n+}\n+\n+pub fn read2(p1: AnonPipe,\n+             v1: &mut Vec<u8>,\n+             p2: AnonPipe,\n+             v2: &mut Vec<u8>) -> io::Result<()> {\n+    //FIXME: Use event based I/O multiplexing\n+    //unimplemented!()\n+\n+    p1.read_to_end(v1)?;\n+    p2.read_to_end(v2)?;\n+\n+    Ok(())\n+\n+    /*\n+    // Set both pipes into nonblocking mode as we're gonna be reading from both\n+    // in the `select` loop below, and we wouldn't want one to block the other!\n+    let p1 = p1.into_fd();\n+    let p2 = p2.into_fd();\n+    p1.set_nonblocking(true)?;\n+    p2.set_nonblocking(true)?;\n+\n+    loop {\n+        // wait for either pipe to become readable using `select`\n+        cvt_r(|| unsafe {\n+            let mut read: libc::fd_set = mem::zeroed();\n+            libc::FD_SET(p1.raw(), &mut read);\n+            libc::FD_SET(p2.raw(), &mut read);\n+            libc::select(max + 1, &mut read, ptr::null_mut(), ptr::null_mut(),\n+                         ptr::null_mut())\n+        })?;\n+\n+        // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n+        // EAGAIN. If we hit EOF, then this will happen because the underlying\n+        // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n+        // this case we flip the other fd back into blocking mode and read\n+        // whatever's leftover on that file descriptor.\n+        let read = |fd: &FileDesc, dst: &mut Vec<u8>| {\n+            match fd.read_to_end(dst) {\n+                Ok(_) => Ok(true),\n+                Err(e) => {\n+                    if e.raw_os_error() == Some(libc::EWOULDBLOCK) ||\n+                       e.raw_os_error() == Some(libc::EAGAIN) {\n+                        Ok(false)\n+                    } else {\n+                        Err(e)\n+                    }\n+                }\n+            }\n+        };\n+        if read(&p1, v1)? {\n+            p2.set_nonblocking(false)?;\n+            return p2.read_to_end(v2).map(|_| ());\n+        }\n+        if read(&p2, v2)? {\n+            p1.set_nonblocking(false)?;\n+            return p1.read_to_end(v1).map(|_| ());\n+        }\n+    }\n+    */\n+}"}, {"sha": "849f51013e6656099cf759e29bfd98279bc891e8", "filename": "src/libstd/sys/redox/process.rs", "status": "added", "additions": 504, "deletions": 0, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,504 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use collections::hash_map::HashMap;\n+use env;\n+use ffi::OsStr;\n+use fmt;\n+use io::{self, Error, ErrorKind};\n+use path::Path;\n+use sys::fd::FileDesc;\n+use sys::fs::{File, OpenOptions};\n+use sys::pipe::{self, AnonPipe};\n+use sys::{cvt, syscall};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Command {\n+    // Currently we try hard to ensure that the call to `.exec()` doesn't\n+    // actually allocate any memory. While many platforms try to ensure that\n+    // memory allocation works after a fork in a multithreaded process, it's\n+    // been observed to be buggy and somewhat unreliable, so we do our best to\n+    // just not do it at all!\n+    //\n+    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n+    // what's gonna get passed to `execvp`. The `argv` array starts with the\n+    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n+    // also null-terminated.\n+    //\n+    // Right now we don't support removing arguments, so there's no much fancy\n+    // support there, but we support adding and removing environment variables,\n+    // so a side table is used to track where in the `envp` array each key is\n+    // located. Whenever we add a key we update it in place if it's already\n+    // present, and whenever we remove a key we update the locations of all\n+    // other keys.\n+    program: String,\n+    args: Vec<String>,\n+    env: HashMap<String, String>,\n+\n+    cwd: Option<String>,\n+    uid: Option<u32>,\n+    gid: Option<u32>,\n+    saw_nul: bool,\n+    closures: Vec<Box<FnMut() -> io::Result<()> + Send + Sync>>,\n+    stdin: Option<Stdio>,\n+    stdout: Option<Stdio>,\n+    stderr: Option<Stdio>,\n+}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+// passed to do_exec() with configuration of what the child stdio should look\n+// like\n+struct ChildPipes {\n+    stdin: ChildStdio,\n+    stdout: ChildStdio,\n+    stderr: ChildStdio,\n+}\n+\n+enum ChildStdio {\n+    Inherit,\n+    Explicit(usize),\n+    Owned(FileDesc),\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+    Fd(FileDesc),\n+}\n+\n+impl Command {\n+    pub fn new(program: &OsStr) -> Command {\n+        Command {\n+            program: program.to_str().unwrap().to_owned(),\n+            args: Vec::new(),\n+            env: HashMap::new(),\n+            cwd: None,\n+            uid: None,\n+            gid: None,\n+            saw_nul: false,\n+            closures: Vec::new(),\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n+        }\n+    }\n+\n+    pub fn arg(&mut self, arg: &OsStr) {\n+        self.args.push(arg.to_str().unwrap().to_owned());\n+    }\n+\n+    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n+        self.env.insert(key.to_str().unwrap().to_owned(), val.to_str().unwrap().to_owned());\n+    }\n+\n+    pub fn env_remove(&mut self, key: &OsStr) {\n+        self.env.remove(key.to_str().unwrap());\n+    }\n+\n+    pub fn env_clear(&mut self) {\n+        self.env.clear();\n+    }\n+\n+    pub fn cwd(&mut self, dir: &OsStr) {\n+        self.cwd = Some(dir.to_str().unwrap().to_owned());\n+    }\n+    pub fn uid(&mut self, id: u32) {\n+        self.uid = Some(id);\n+    }\n+    pub fn gid(&mut self, id: u32) {\n+        self.gid = Some(id);\n+    }\n+\n+    pub fn before_exec(&mut self,\n+                       f: Box<FnMut() -> io::Result<()> + Send + Sync>) {\n+        self.closures.push(f);\n+    }\n+\n+    pub fn stdin(&mut self, stdin: Stdio) {\n+        self.stdin = Some(stdin);\n+    }\n+    pub fn stdout(&mut self, stdout: Stdio) {\n+        self.stdout = Some(stdout);\n+    }\n+    pub fn stderr(&mut self, stderr: Stdio) {\n+        self.stderr = Some(stderr);\n+    }\n+\n+    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n+                 -> io::Result<(Process, StdioPipes)> {\n+         const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n+\n+         if self.saw_nul {\n+             return Err(io::Error::new(ErrorKind::InvalidInput,\n+                                       \"nul byte found in provided data\"));\n+         }\n+\n+         let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n+         let (input, output) = pipe::anon_pipe()?;\n+\n+         let pid = unsafe {\n+             match cvt(syscall::clone(0))? {\n+                 0 => {\n+                     drop(input);\n+                     let err = self.do_exec(theirs);\n+                     let errno = err.raw_os_error().unwrap_or(syscall::EINVAL) as u32;\n+                     let bytes = [\n+                         (errno >> 24) as u8,\n+                         (errno >> 16) as u8,\n+                         (errno >>  8) as u8,\n+                         (errno >>  0) as u8,\n+                         CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                         CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n+                     ];\n+                     // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n+                     // we want to be sure we *don't* run at_exit destructors as\n+                     // we're being torn down regardless\n+                     assert!(output.write(&bytes).is_ok());\n+                     let _ = syscall::exit(1);\n+                     panic!(\"failed to exit\");\n+                 }\n+                 n => n,\n+             }\n+         };\n+\n+         let mut p = Process { pid: pid, status: None };\n+         drop(output);\n+         let mut bytes = [0; 8];\n+\n+         // loop to handle EINTR\n+         loop {\n+             match input.read(&mut bytes) {\n+                 Ok(0) => return Ok((p, ours)),\n+                 Ok(8) => {\n+                     assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n+                             \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n+                     let errno = combine(&bytes[0.. 4]);\n+                     assert!(p.wait().is_ok(),\n+                             \"wait() should either return Ok or panic\");\n+                     return Err(Error::from_raw_os_error(errno))\n+                 }\n+                 Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                 Err(e) => {\n+                     assert!(p.wait().is_ok(),\n+                             \"wait() should either return Ok or panic\");\n+                     panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n+                 },\n+                 Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n+                     assert!(p.wait().is_ok(),\n+                             \"wait() should either return Ok or panic\");\n+                     panic!(\"short read on the CLOEXEC pipe\")\n+                 }\n+             }\n+         }\n+\n+         fn combine(arr: &[u8]) -> i32 {\n+             let a = arr[0] as u32;\n+             let b = arr[1] as u32;\n+             let c = arr[2] as u32;\n+             let d = arr[3] as u32;\n+\n+             ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n+         }\n+    }\n+\n+    pub fn exec(&mut self, default: Stdio) -> io::Error {\n+        if self.saw_nul {\n+            return io::Error::new(ErrorKind::InvalidInput,\n+                                  \"nul byte found in provided data\")\n+        }\n+\n+        match self.setup_io(default, true) {\n+            Ok((_, theirs)) => unsafe { self.do_exec(theirs) },\n+            Err(e) => e,\n+        }\n+    }\n+\n+    // And at this point we've reached a special time in the life of the\n+    // child. The child must now be considered hamstrung and unable to\n+    // do anything other than syscalls really. Consider the following\n+    // scenario:\n+    //\n+    //      1. Thread A of process 1 grabs the malloc() mutex\n+    //      2. Thread B of process 1 forks(), creating thread C\n+    //      3. Thread C of process 2 then attempts to malloc()\n+    //      4. The memory of process 2 is the same as the memory of\n+    //         process 1, so the mutex is locked.\n+    //\n+    // This situation looks a lot like deadlock, right? It turns out\n+    // that this is what pthread_atfork() takes care of, which is\n+    // presumably implemented across platforms. The first thing that\n+    // threads to *before* forking is to do things like grab the malloc\n+    // mutex, and then after the fork they unlock it.\n+    //\n+    // Despite this information, libnative's spawn has been witnessed to\n+    // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n+    // all collected backtraces point at malloc/free traffic in the\n+    // child spawned process.\n+    //\n+    // For this reason, the block of code below should contain 0\n+    // invocations of either malloc of free (or their related friends).\n+    //\n+    // As an example of not having malloc/free traffic, we don't close\n+    // this file descriptor by dropping the FileDesc (which contains an\n+    // allocation). Instead we just close it manually. This will never\n+    // have the drop glue anyway because this code never returns (the\n+    // child will either exec() or invoke syscall::exit)\n+    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n+        macro_rules! t {\n+            ($e:expr) => (match $e {\n+                Ok(e) => e,\n+                Err(e) => return e,\n+            })\n+        }\n+\n+        if let Some(fd) = stdio.stderr.fd() {\n+            let _ = syscall::close(2);\n+            t!(cvt(syscall::dup(fd, &[])));\n+            let _ = syscall::close(fd);\n+        }\n+        if let Some(fd) = stdio.stdout.fd() {\n+            let _ = syscall::close(1);\n+            t!(cvt(syscall::dup(fd, &[])));\n+            let _ = syscall::close(fd);\n+        }\n+        if let Some(fd) = stdio.stdin.fd() {\n+            let _ = syscall::close(0);\n+            t!(cvt(syscall::dup(fd, &[])));\n+            let _ = syscall::close(fd);\n+        }\n+\n+        if let Some(g) = self.gid {\n+            t!(cvt(syscall::setregid(g as usize, g as usize)));\n+        }\n+        if let Some(u) = self.uid {\n+            t!(cvt(syscall::setreuid(u as usize, u as usize)));\n+        }\n+        if let Some(ref cwd) = self.cwd {\n+            t!(cvt(syscall::chdir(cwd)));\n+        }\n+\n+        for callback in self.closures.iter_mut() {\n+            t!(callback());\n+        }\n+\n+        let mut args: Vec<[usize; 2]> = Vec::new();\n+        args.push([self.program.as_ptr() as usize, self.program.len()]);\n+        for arg in self.args.iter() {\n+            args.push([arg.as_ptr() as usize, arg.len()]);\n+        }\n+\n+        for (key, val) in self.env.iter() {\n+            env::set_var(key, val);\n+        }\n+\n+        let program = if self.program.contains(':') || self.program.contains('/') {\n+            self.program.to_owned()\n+        } else {\n+            let mut path_env = ::env::var(\"PATH\").unwrap_or(\".\".to_string());\n+\n+            if ! path_env.ends_with('/') {\n+                path_env.push('/');\n+            }\n+\n+            path_env.push_str(&self.program);\n+\n+            path_env\n+        };\n+\n+        if let Err(err) = syscall::execve(&program, &args) {\n+            io::Error::from_raw_os_error(err.errno as i32)\n+        } else {\n+            panic!(\"return from exec without err\");\n+        }\n+    }\n+\n+\n+    fn setup_io(&self, default: Stdio, needs_stdin: bool)\n+                -> io::Result<(StdioPipes, ChildPipes)> {\n+        let null = Stdio::Null;\n+        let default_stdin = if needs_stdin {&default} else {&null};\n+        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n+        let stdout = self.stdout.as_ref().unwrap_or(&default);\n+        let stderr = self.stderr.as_ref().unwrap_or(&default);\n+        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n+        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n+        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n+        let ours = StdioPipes {\n+            stdin: our_stdin,\n+            stdout: our_stdout,\n+            stderr: our_stderr,\n+        };\n+        let theirs = ChildPipes {\n+            stdin: their_stdin,\n+            stdout: their_stdout,\n+            stderr: their_stderr,\n+        };\n+        Ok((ours, theirs))\n+    }\n+}\n+\n+impl Stdio {\n+    fn to_child_stdio(&self, readable: bool)\n+                      -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n+        match *self {\n+            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n+\n+            // Make sure that the source descriptors are not an stdio\n+            // descriptor, otherwise the order which we set the child's\n+            // descriptors may blow away a descriptor which we are hoping to\n+            // save. For example, suppose we want the child's stderr to be the\n+            // parent's stdout, and the child's stdout to be the parent's\n+            // stderr. No matter which we dup first, the second will get\n+            // overwritten prematurely.\n+            Stdio::Fd(ref fd) => {\n+                if fd.raw() <= 2 {\n+                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n+                } else {\n+                    Ok((ChildStdio::Explicit(fd.raw()), None))\n+                }\n+            }\n+\n+            Stdio::MakePipe => {\n+                let (reader, writer) = pipe::anon_pipe()?;\n+                let (ours, theirs) = if readable {\n+                    (writer, reader)\n+                } else {\n+                    (reader, writer)\n+                };\n+                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n+            }\n+\n+            Stdio::Null => {\n+                let mut opts = OpenOptions::new();\n+                opts.read(readable);\n+                opts.write(!readable);\n+                let fd = File::open(&Path::new(\"null:\"), &opts)?;\n+                Ok((ChildStdio::Owned(fd.into_fd()), None))\n+            }\n+        }\n+    }\n+}\n+\n+impl ChildStdio {\n+    fn fd(&self) -> Option<usize> {\n+        match *self {\n+            ChildStdio::Inherit => None,\n+            ChildStdio::Explicit(fd) => Some(fd),\n+            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}\", self.program)?;\n+        for arg in &self.args {\n+            write!(f, \" {:?}\", arg)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Unix exit statuses\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatus(i32);\n+\n+impl ExitStatus {\n+    fn exited(&self) -> bool {\n+        self.0 & 0x7F == 0\n+    }\n+\n+    pub fn success(&self) -> bool {\n+        self.code() == Some(0)\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        if self.exited() {\n+            Some((self.0 >> 8) & 0xFF)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn signal(&self) -> Option<i32> {\n+        if !self.exited() {\n+            Some(self.0 & 0x7F)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl From<i32> for ExitStatus {\n+    fn from(a: i32) -> ExitStatus {\n+        ExitStatus(a)\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if let Some(code) = self.code() {\n+            write!(f, \"exit code: {}\", code)\n+        } else {\n+            let signal = self.signal().unwrap();\n+            write!(f, \"signal: {}\", signal)\n+        }\n+    }\n+}\n+\n+/// The unique id of the process (this should never be negative).\n+pub struct Process {\n+    pid: usize,\n+    status: Option<ExitStatus>,\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        self.pid as u32\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        // If we've already waited on this process then the pid can be recycled\n+        // and used for another process, and we probably shouldn't be killing\n+        // random processes, so just return an error.\n+        if self.status.is_some() {\n+            Err(Error::new(ErrorKind::InvalidInput,\n+                           \"invalid argument: can't kill an exited process\"))\n+        } else {\n+            cvt(syscall::kill(self.pid, syscall::SIGKILL))?;\n+            Ok(())\n+        }\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        if let Some(status) = self.status {\n+            return Ok(status)\n+        }\n+        let mut status = 0;\n+        cvt(syscall::waitpid(self.pid, &mut status, 0))?;\n+        self.status = Some(ExitStatus(status as i32));\n+        Ok(ExitStatus(status as i32))\n+    }\n+}"}, {"sha": "d7e4d09a9d636bba8c77ee1ed0b6fb37b52f1efd", "filename": "src/libstd/sys/redox/rand.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Frand.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use libc;\n+use rand::Rng;\n+\n+pub struct OsRng;\n+\n+impl OsRng {\n+    /// Create a new `OsRng`.\n+    pub fn new() -> io::Result<OsRng> {\n+        Ok(OsRng)\n+    }\n+}\n+\n+impl Rng for OsRng {\n+    fn next_u32(&mut self) -> u32 {\n+        self.next_u64() as u32\n+    }\n+    fn next_u64(&mut self) -> u64 {\n+        unsafe { libc::random() }\n+    }\n+    fn fill_bytes(&mut self, buf: &mut [u8]) {\n+        for chunk in buf.chunks_mut(8) {\n+            let mut rand: u64 = self.next_u64();\n+            for b in chunk.iter_mut() {\n+                *b = rand as u8;\n+                rand = rand >> 8;\n+            }\n+        }\n+    }\n+}"}, {"sha": "d74b614ba47de188961a56e08f79e128f535fb0c", "filename": "src/libstd/sys/redox/rwlock.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Frwlock.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::mutex::Mutex;\n+\n+pub struct RWLock {\n+    mutex: Mutex\n+}\n+\n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {}\n+\n+impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock {\n+            mutex: Mutex::new()\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        self.mutex.lock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        self.mutex.try_lock()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        self.mutex.lock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        self.mutex.try_lock()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        self.mutex.unlock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        self.mutex.unlock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        self.mutex.destroy();\n+    }\n+}"}, {"sha": "760fe06c57faf5707d1944a8e1649e211a50e39f", "filename": "src/libstd/sys/redox/stack_overflow.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstack_overflow.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg_attr(test, allow(dead_code))]\n+\n+pub struct Handler;\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        Handler\n+    }\n+}\n+\n+pub unsafe fn init() {\n+\n+}\n+\n+pub unsafe fn cleanup() {\n+\n+}"}, {"sha": "607eef051d6eb444045148340217596a73fd235a", "filename": "src/libstd/sys/redox/stdio.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fstdio.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::{cvt, syscall};\n+use sys::fd::FileDesc;\n+\n+pub struct Stdin(());\n+pub struct Stdout(());\n+pub struct Stderr(());\n+\n+impl Stdin {\n+    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+\n+    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+        let fd = FileDesc::new(0);\n+        let ret = fd.read(data);\n+        fd.into_raw();\n+        ret\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let fd = FileDesc::new(0);\n+        let ret = fd.read_to_end(buf);\n+        fd.into_raw();\n+        ret\n+    }\n+}\n+\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        let fd = FileDesc::new(1);\n+        let ret = fd.write(data);\n+        fd.into_raw();\n+        ret\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        cvt(syscall::fsync(1)).and(Ok(()))\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        let fd = FileDesc::new(2);\n+        let ret = fd.write(data);\n+        fd.into_raw();\n+        ret\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        cvt(syscall::fsync(2)).and(Ok(()))\n+    }\n+}\n+\n+// FIXME: right now this raw stderr handle is used in a few places because\n+//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n+//        should go away\n+impl io::Write for Stderr {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Stderr::write(self, data)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Stderr::flush(self)\n+    }\n+}\n+\n+pub const EBADF_ERR: i32 = ::sys::syscall::EBADF;\n+pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;"}, {"sha": "b2c0e285f0663b2d856a06ef415ac87624696ecb", "filename": "src/libstd/sys/redox/thread.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc::boxed::FnBox;\n+use ffi::CStr;\n+use io;\n+use mem;\n+use sys_common::thread::start_thread;\n+use sys::{cvt, syscall};\n+use time::Duration;\n+\n+pub struct Thread {\n+    id: usize,\n+}\n+\n+// Some platforms may have pthread_t as a pointer in which case we still want\n+// a thread to be Send/Sync\n+unsafe impl Send for Thread {}\n+unsafe impl Sync for Thread {}\n+\n+impl Thread {\n+    pub unsafe fn new<'a>(_stack: usize, p: Box<FnBox() + 'a>) -> io::Result<Thread> {\n+        let p = box p;\n+\n+        let id = cvt(syscall::clone(syscall::CLONE_VM | syscall::CLONE_FS | syscall::CLONE_FILES))?;\n+        if id == 0 {\n+            start_thread(&*p as *const _ as *mut _);\n+            let _ = syscall::exit(0);\n+            panic!(\"thread failed to exit\");\n+        } else {\n+            mem::forget(p);\n+            Ok(Thread { id: id })\n+        }\n+    }\n+\n+    pub fn yield_now() {\n+        let ret = syscall::sched_yield().expect(\"failed to sched_yield\");\n+        debug_assert_eq!(ret, 0);\n+    }\n+\n+    pub fn set_name(_name: &CStr) {\n+\n+    }\n+\n+    pub fn sleep(dur: Duration) {\n+        let mut secs = dur.as_secs();\n+        let mut nsecs = dur.subsec_nanos() as i32;\n+\n+        // If we're awoken with a signal then the return value will be -1 and\n+        // nanosleep will fill in `ts` with the remaining time.\n+        while secs > 0 || nsecs > 0 {\n+            let req = syscall::TimeSpec {\n+                tv_sec: secs as i64,\n+                tv_nsec: nsecs,\n+            };\n+            secs -= req.tv_sec as u64;\n+            let mut rem = syscall::TimeSpec::default();\n+            if syscall::nanosleep(&req, &mut rem).is_err() {\n+                secs += rem.tv_sec as u64;\n+                nsecs = rem.tv_nsec;\n+            } else {\n+                nsecs = 0;\n+            }\n+        }\n+    }\n+\n+    pub fn join(self) {\n+        let mut status = 0;\n+        syscall::waitpid(self.id, &mut status, 0).unwrap();\n+    }\n+\n+    pub fn id(&self) -> usize { self.id }\n+\n+    pub fn into_id(self) -> usize {\n+        let id = self.id;\n+        mem::forget(self);\n+        id\n+    }\n+}\n+\n+pub mod guard {\n+    pub unsafe fn current() -> Option<usize> { None }\n+    pub unsafe fn init() -> Option<usize> { None }\n+}"}, {"sha": "abdd9ace795f42dea62490944ec7d32c60493fd5", "filename": "src/libstd/sys/redox/thread_local.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread_local.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)] // not used on all platforms\n+\n+use collections::BTreeMap;\n+use ptr;\n+use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+pub type Key = usize;\n+\n+type Dtor = unsafe extern fn(*mut u8);\n+\n+static NEXT_KEY: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+static mut KEYS: *mut BTreeMap<Key, Option<Dtor>> = ptr::null_mut();\n+\n+#[thread_local]\n+static mut LOCALS: *mut BTreeMap<Key, *mut u8> = ptr::null_mut();\n+\n+unsafe fn keys() -> &'static mut BTreeMap<Key, Option<Dtor>> {\n+    if KEYS == ptr::null_mut() {\n+        KEYS = Box::into_raw(Box::new(BTreeMap::new()));\n+    }\n+    &mut *KEYS\n+}\n+\n+unsafe fn locals() -> &'static mut BTreeMap<Key, *mut u8> {\n+    if LOCALS == ptr::null_mut() {\n+        LOCALS = Box::into_raw(Box::new(BTreeMap::new()));\n+    }\n+    &mut *LOCALS\n+}\n+\n+#[inline]\n+pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n+    let key = NEXT_KEY.fetch_add(1, Ordering::SeqCst);\n+    keys().insert(key, dtor);\n+    key\n+}\n+\n+#[inline]\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    if let Some(&entry) = locals().get(&key) {\n+        entry\n+    } else {\n+        ptr::null_mut()\n+    }\n+}\n+\n+#[inline]\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    locals().insert(key, value);\n+}\n+\n+#[inline]\n+pub unsafe fn destroy(key: Key) {\n+    keys().remove(&key);\n+}"}, {"sha": "dea406efe6ca963d9788c01114fd81c053de0c21", "filename": "src/libstd/sys/redox/time.rs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -0,0 +1,198 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cmp::Ordering;\n+use fmt;\n+use sys::{cvt, syscall};\n+use time::Duration;\n+\n+const NSEC_PER_SEC: u64 = 1_000_000_000;\n+\n+#[derive(Copy, Clone)]\n+struct Timespec {\n+    t: syscall::TimeSpec,\n+}\n+\n+impl Timespec {\n+    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n+        if self >= other {\n+            Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n+                Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n+                              (self.t.tv_nsec - other.t.tv_nsec) as u32)\n+            } else {\n+                Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n+                              self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n+                              other.t.tv_nsec as u32)\n+            })\n+        } else {\n+            match other.sub_timespec(self) {\n+                Ok(d) => Err(d),\n+                Err(d) => Ok(d),\n+            }\n+        }\n+    }\n+\n+    fn add_duration(&self, other: &Duration) -> Timespec {\n+        let secs = (self.t.tv_sec as i64).checked_add(other.as_secs() as i64);\n+        let mut secs = secs.expect(\"overflow when adding duration to time\");\n+\n+        // Nano calculations can't overflow because nanos are <1B which fit\n+        // in a u32.\n+        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n+        if nsec >= NSEC_PER_SEC as u32 {\n+            nsec -= NSEC_PER_SEC as u32;\n+            secs = secs.checked_add(1).expect(\"overflow when adding \\\n+                                               duration to time\");\n+        }\n+        Timespec {\n+            t: syscall::TimeSpec {\n+                tv_sec: secs as i64,\n+                tv_nsec: nsec as i32,\n+            },\n+        }\n+    }\n+\n+    fn sub_duration(&self, other: &Duration) -> Timespec {\n+        let secs = (self.t.tv_sec as i64).checked_sub(other.as_secs() as i64);\n+        let mut secs = secs.expect(\"overflow when subtracting duration \\\n+                                    from time\");\n+\n+        // Similar to above, nanos can't overflow.\n+        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n+        if nsec < 0 {\n+            nsec += NSEC_PER_SEC as i32;\n+            secs = secs.checked_sub(1).expect(\"overflow when subtracting \\\n+                                               duration from time\");\n+        }\n+        Timespec {\n+            t: syscall::TimeSpec {\n+                tv_sec: secs as i64,\n+                tv_nsec: nsec as i32,\n+            },\n+        }\n+    }\n+}\n+\n+impl PartialEq for Timespec {\n+    fn eq(&self, other: &Timespec) -> bool {\n+        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n+    }\n+}\n+\n+impl Eq for Timespec {}\n+\n+impl PartialOrd for Timespec {\n+    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Timespec {\n+    fn cmp(&self, other: &Timespec) -> Ordering {\n+        let me = (self.t.tv_sec, self.t.tv_nsec);\n+        let other = (other.t.tv_sec, other.t.tv_nsec);\n+        me.cmp(&other)\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct Instant {\n+    t: Timespec,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct SystemTime {\n+    t: Timespec,\n+}\n+\n+pub const UNIX_EPOCH: SystemTime = SystemTime {\n+    t: Timespec {\n+        t: syscall::TimeSpec {\n+            tv_sec: 0,\n+            tv_nsec: 0,\n+        },\n+    },\n+};\n+\n+impl Instant {\n+    pub fn now() -> Instant {\n+        Instant { t: now(syscall::CLOCK_MONOTONIC) }\n+    }\n+\n+    pub fn sub_instant(&self, other: &Instant) -> Duration {\n+        self.t.sub_timespec(&other.t).unwrap_or_else(|_| {\n+            panic!(\"other was less than the current instant\")\n+        })\n+    }\n+\n+    pub fn add_duration(&self, other: &Duration) -> Instant {\n+        Instant { t: self.t.add_duration(other) }\n+    }\n+\n+    pub fn sub_duration(&self, other: &Duration) -> Instant {\n+        Instant { t: self.t.sub_duration(other) }\n+    }\n+}\n+\n+impl fmt::Debug for Instant {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Instant\")\n+         .field(\"tv_sec\", &self.t.t.tv_sec)\n+         .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+         .finish()\n+    }\n+}\n+\n+impl SystemTime {\n+    pub fn now() -> SystemTime {\n+        SystemTime { t: now(syscall::CLOCK_REALTIME) }\n+    }\n+\n+    pub fn sub_time(&self, other: &SystemTime)\n+                    -> Result<Duration, Duration> {\n+        self.t.sub_timespec(&other.t)\n+    }\n+\n+    pub fn add_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime { t: self.t.add_duration(other) }\n+    }\n+\n+    pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime { t: self.t.sub_duration(other) }\n+    }\n+}\n+\n+impl From<syscall::TimeSpec> for SystemTime {\n+    fn from(t: syscall::TimeSpec) -> SystemTime {\n+        SystemTime { t: Timespec { t: t } }\n+    }\n+}\n+\n+impl fmt::Debug for SystemTime {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SystemTime\")\n+         .field(\"tv_sec\", &self.t.t.tv_sec)\n+         .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+         .finish()\n+    }\n+}\n+\n+pub type clock_t = usize;\n+\n+fn now(clock: clock_t) -> Timespec {\n+    let mut t = Timespec {\n+        t: syscall::TimeSpec {\n+            tv_sec: 0,\n+            tv_nsec: 0,\n+        }\n+    };\n+    cvt(syscall::clock_gettime(clock, &mut t.t)).unwrap();\n+    t\n+}"}, {"sha": "6d38b00b39eb5e1795038dbfde807b519949e2f2", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -43,6 +43,10 @@ impl Stdout {\n         fd.into_raw();\n         ret\n     }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n impl Stderr {\n@@ -54,6 +58,10 @@ impl Stderr {\n         fd.into_raw();\n         ret\n     }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n // FIXME: right now this raw stderr handle is used in a few places because\n@@ -63,7 +71,10 @@ impl io::Write for Stderr {\n     fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         Stderr::write(self, data)\n     }\n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Stderr::flush(self)\n+    }\n }\n \n pub const EBADF_ERR: i32 = ::libc::EBADF as i32;"}, {"sha": "a74e7699ba0fd6421911fce216ce83647d2657ba", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -156,6 +156,10 @@ impl Stdout {\n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n         write(&self.0, data)\n     }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n impl Stderr {\n@@ -166,6 +170,10 @@ impl Stderr {\n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n         write(&self.0, data)\n     }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n // FIXME: right now this raw stderr handle is used in a few places because\n@@ -175,7 +183,10 @@ impl io::Write for Stderr {\n     fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         Stderr::write(self, data)\n     }\n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Stderr::flush(self)\n+    }\n }\n \n impl NoClose {"}, {"sha": "5c07e36508c69128f34b6c6b2547ec7e219a9135", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa668f3bf8156730b419deec51fb980af23b8bb/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=cfa668f3bf8156730b419deec51fb980af23b8bb", "patch": "@@ -34,7 +34,6 @@ pub mod condvar;\n pub mod io;\n pub mod memchr;\n pub mod mutex;\n-pub mod net;\n pub mod poison;\n pub mod remutex;\n pub mod rwlock;\n@@ -44,6 +43,12 @@ pub mod thread_local;\n pub mod util;\n pub mod wtf8;\n \n+#[cfg(target_os = \"redox\")]\n+pub use sys::net;\n+\n+#[cfg(not(target_os = \"redox\"))]\n+pub mod net;\n+\n #[cfg(any(not(cargobuild), feature = \"backtrace\"))]\n #[cfg(any(all(unix, not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"emscripten\"))),\n           all(windows, target_env = \"gnu\")))]"}]}