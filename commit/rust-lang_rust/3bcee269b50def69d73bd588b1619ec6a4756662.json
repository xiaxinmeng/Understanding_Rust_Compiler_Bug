{"sha": "3bcee269b50def69d73bd588b1619ec6a4756662", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiY2VlMjY5YjUwZGVmNjlkNzNiZDU4OGIxNjE5ZWM2YTQ3NTY2NjI=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-20T03:27:15Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-28T01:18:51Z"}, "message": "Handle immediate tuples in `trans_arguments_untupled`\n\nUse either getelementptr or extractvalue depending on whether or not the\ntuple is immediate or not.", "tree": {"sha": "7e75c411bf7f7d89b5c56f5455fd6f6487c37171", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e75c411bf7f7d89b5c56f5455fd6f6487c37171"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bcee269b50def69d73bd588b1619ec6a4756662", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bcee269b50def69d73bd588b1619ec6a4756662", "html_url": "https://github.com/rust-lang/rust/commit/3bcee269b50def69d73bd588b1619ec6a4756662", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bcee269b50def69d73bd588b1619ec6a4756662/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e3b37a52e618f93f8b1357744d507b1b527a0fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e3b37a52e618f93f8b1357744d507b1b527a0fa", "html_url": "https://github.com/rust-lang/rust/commit/0e3b37a52e618f93f8b1357744d507b1b527a0fa"}], "stats": {"total": 72, "additions": 36, "deletions": 36}, "files": [{"sha": "d6a42bea22a6e3d0102d5e36db55077fceb1d883", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3bcee269b50def69d73bd588b1619ec6a4756662/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcee269b50def69d73bd588b1619ec6a4756662/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=3bcee269b50def69d73bd588b1619ec6a4756662", "patch": "@@ -436,47 +436,47 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 fn_ty: &FnType,\n                                 next_idx: &mut usize,\n                                 callee: &mut CalleeData) {\n-        // FIXME: consider having some optimization to avoid tupling/untupling\n-        // (and storing/loading in the case of immediates)\n-\n-        // avoid trans_operand for pointless copying\n-        let lv = match *operand {\n-            mir::Operand::Consume(ref lvalue) => self.trans_lvalue(bcx, lvalue),\n-            mir::Operand::Constant(ref constant) => {\n-                // FIXME: consider being less pessimized\n-                if constant.ty.is_nil() {\n-                    return;\n-                }\n-\n-                let ty = bcx.monomorphize(&constant.ty);\n-                let lv = LvalueRef::alloca(bcx, ty, \"__untuple_alloca\");\n-                let constant = self.trans_constant(bcx, constant);\n-                self.store_operand(bcx, lv.llval, constant);\n-                lv\n-           }\n-        };\n+        let tuple = self.trans_operand(bcx, operand);\n \n-        let lv_ty = lv.ty.to_ty(bcx.tcx());\n-        let result_types = match lv_ty.sty {\n+        let arg_types = match tuple.ty.sty {\n             ty::TyTuple(ref tys) => tys,\n-            _ => span_bug!(\n-                self.mir.span,\n-                \"bad final argument to \\\"rust-call\\\" fn {:?}\", lv_ty)\n+            _ => span_bug!(self.mir.span,\n+                           \"bad final argument to \\\"rust-call\\\" fn {:?}\", tuple.ty)\n         };\n \n-        let base_repr = adt::represent_type(bcx.ccx(), lv_ty);\n-        let base = adt::MaybeSizedValue::sized(lv.llval);\n-        for (n, &ty) in result_types.iter().enumerate() {\n-            let ptr = adt::trans_field_ptr_builder(bcx, &base_repr, base, Disr(0), n);\n-            let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n-                let (lldata, llextra) = load_fat_ptr(bcx, ptr);\n-                FatPtr(lldata, llextra)\n-            } else {\n-                // Don't bother loading the value, trans_argument will.\n-                Ref(ptr)\n-            };\n-            self.trans_argument(bcx, val, llargs, fn_ty, next_idx, callee);\n+        // Handle both by-ref and immediate tuples. This gives us the option of\n+        match tuple.val {\n+            Ref(llval) => {\n+                let base_repr = adt::represent_type(bcx.ccx(), tuple.ty);\n+                let base = adt::MaybeSizedValue::sized(llval);\n+                for (n, &ty) in arg_types.iter().enumerate() {\n+                    let ptr = adt::trans_field_ptr_builder(bcx, &base_repr, base, Disr(0), n);\n+                    let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n+                        let (lldata, llextra) = load_fat_ptr(bcx, ptr);\n+                        FatPtr(lldata, llextra)\n+                    } else {\n+                        // trans_argument will load this if it needs to\n+                        Ref(ptr)\n+                    };\n+                    self.trans_argument(bcx, val, llargs, fn_ty, next_idx, callee);\n+                }\n+\n+            }\n+            Immediate(llval) => {\n+                for (n, &ty) in arg_types.iter().enumerate() {\n+                    let mut elem = bcx.extract_value(llval, n);\n+                    // Truncate bools to i1, if needed\n+                    if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx()) {\n+                        elem = bcx.trunc(elem, Type::i1(bcx.ccx()));\n+                    }\n+                    // If the tuple is immediate, the elements are as well\n+                    let val = Immediate(elem);\n+                    self.trans_argument(bcx, val, llargs, fn_ty, next_idx, callee);\n+                }\n+            }\n+            FatPtr(_, _) => bug!(\"tuple is a fat pointer?!\")\n         }\n+\n     }\n \n     fn get_personality_slot(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>) -> ValueRef {"}]}