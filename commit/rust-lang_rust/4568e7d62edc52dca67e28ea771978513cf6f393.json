{"sha": "4568e7d62edc52dca67e28ea771978513cf6f393", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NjhlN2Q2MmVkYzUyZGNhNjdlMjhlYTc3MTk3ODUxM2NmNmYzOTM=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-04-21T07:12:04Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-04-21T07:12:04Z"}, "message": "Move nested quantification check to ast_validation", "tree": {"sha": "ffe8b5038f76e4dbfa26d783e0b7f74e4ba1ce07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffe8b5038f76e4dbfa26d783e0b7f74e4ba1ce07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4568e7d62edc52dca67e28ea771978513cf6f393", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4568e7d62edc52dca67e28ea771978513cf6f393", "html_url": "https://github.com/rust-lang/rust/commit/4568e7d62edc52dca67e28ea771978513cf6f393", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4568e7d62edc52dca67e28ea771978513cf6f393/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9891582897ae5f588022cec6a2f798d7a2883629", "url": "https://api.github.com/repos/rust-lang/rust/commits/9891582897ae5f588022cec6a2f798d7a2883629", "html_url": "https://github.com/rust-lang/rust/commit/9891582897ae5f588022cec6a2f798d7a2883629"}], "stats": {"total": 127, "additions": 52, "deletions": 75}, "files": [{"sha": "809660379f326a975e5bf4ea6b8d49a130764426", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4568e7d62edc52dca67e28ea771978513cf6f393/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4568e7d62edc52dca67e28ea771978513cf6f393/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=4568e7d62edc52dca67e28ea771978513cf6f393", "patch": "@@ -81,6 +81,13 @@ struct AstValidator<'a> {\n     is_assoc_ty_bound_banned: bool,\n \n     lint_buffer: &'a mut LintBuffer,\n+\n+    /// This is slightly complicated. Our representation for poly-trait-refs contains a single\n+    /// binder and thus we only allow a single level of quantification. However,\n+    /// the syntax of Rust permits quantification in two places in where clauses,\n+    /// e.g., `T: for <'a> Foo<'a>` and `for <'a, 'b> &'b T: Foo<'a>`. If both are\n+    /// defined, then error.\n+    trait_ref_hack: bool,\n }\n \n impl<'a> AstValidator<'a> {\n@@ -1213,8 +1220,25 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 deny_equality_constraints(self, predicate, generics);\n             }\n         }\n+        walk_list!(self, visit_generic_param, &generics.params);\n+        for predicate in &generics.where_clause.predicates {\n+            match predicate {\n+                WherePredicate::BoundPredicate(bound_pred) => {\n+                    // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n+                    self.check_late_bound_lifetime_defs(&bound_pred.bound_generic_params);\n \n-        visit::walk_generics(self, generics)\n+                    self.visit_ty(&bound_pred.bounded_ty);\n+\n+                    self.trait_ref_hack = !bound_pred.bound_generic_params.is_empty();\n+                    walk_list!(self, visit_param_bound, &bound_pred.bounds);\n+                    walk_list!(self, visit_generic_param, &bound_pred.bound_generic_params);\n+                    self.trait_ref_hack = false;\n+                }\n+                _ => {\n+                    self.visit_where_predicate(predicate);\n+                }\n+            }\n+        }\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n@@ -1263,17 +1287,21 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_pat(self, pat)\n     }\n \n-    fn visit_where_predicate(&mut self, p: &'a WherePredicate) {\n-        if let &WherePredicate::BoundPredicate(ref bound_predicate) = p {\n-            // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n-            self.check_late_bound_lifetime_defs(&bound_predicate.bound_generic_params);\n-        }\n-        visit::walk_where_predicate(self, p);\n-    }\n-\n     fn visit_poly_trait_ref(&mut self, t: &'a PolyTraitRef, m: &'a TraitBoundModifier) {\n         self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n+        if self.trait_ref_hack && !t.bound_generic_params.is_empty() {\n+            struct_span_err!(\n+                self.err_handler(),\n+                t.span,\n+                E0316,\n+                \"nested quantification of lifetimes\"\n+            )\n+            .emit();\n+        }\n+        let trait_ref_hack = self.trait_ref_hack;\n+        self.trait_ref_hack = false;\n         visit::walk_poly_trait_ref(self, t, m);\n+        self.trait_ref_hack = trait_ref_hack;\n     }\n \n     fn visit_variant_data(&mut self, s: &'a VariantData) {\n@@ -1492,6 +1520,7 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) ->\n         is_impl_trait_banned: false,\n         is_assoc_ty_bound_banned: false,\n         lint_buffer: lints,\n+        trait_ref_hack: false,\n     };\n     visit::walk_crate(&mut validator, krate);\n "}, {"sha": "3cccbb06bc4260c5d4c81b7d3da741d1d0756769", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 14, "deletions": 66, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4568e7d62edc52dca67e28ea771978513cf6f393/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4568e7d62edc52dca67e28ea771978513cf6f393/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=4568e7d62edc52dca67e28ea771978513cf6f393", "patch": "@@ -278,29 +278,6 @@ enum BinderScopeType {\n     /// you had `T: for<'a>  Foo<Bar: for<'b> Baz<'a, 'b>>`, then the `for<'a>`\n     /// scope uses `PolyTraitRef`.\n     PolyTraitRef,\n-    /// This is slightly complicated. Our representation for poly-trait-refs contains a single\n-    /// binder and thus we only allow a single level of quantification. However,\n-    /// the syntax of Rust permits quantification in two places in where clauses,\n-    /// e.g., `T: for <'a> Foo<'a>` and `for <'a, 'b> &'b T: Foo<'a>`. In order\n-    /// to get the De Bruijn indices correct when representing these constraints,\n-    /// we should only introduce one scope. However, we want to support both\n-    /// locations for the quantifier and during lifetime resolution we want\n-    /// precise information (so we can't desugar in an earlier phase). Moreso,\n-    /// an error here doesn't cause a bail from type checking, so we need to be\n-    /// extra careful that we don't lose any bound var information for *either*\n-    /// syntactic binder and that we track all lifetimes defined in both binders.\n-    ///\n-    /// This mechanism is similar to the concatenation done in nested poly trait\n-    /// refs, i.e. the inner syntactic binder extends upon the lifetimes on the\n-    /// outer syntactic binder. However, we require a separate variant here to\n-    /// distinguish `for<'a> T: for<'b> Foo<'a, 'b>` from\n-    /// `T: for<'a> Bar<Baz: for<'b> Foo<'a, 'b>>`. In this case, the innermost\n-    /// `: for<'b> Foo<'a, 'b>` both have a `for<'a>` scope above it. However,\n-    /// in the former case, we must emit an error because this is invalid syntax.\n-    /// Put another way: `PolyTraitRef` and `BoundedTy` behave identically except\n-    /// that `BoundedTy` is used to signal that an error should be emitted if\n-    /// another syntactic binder is found.\n-    BoundedTy,\n     /// Within a syntactic trait ref, there may be multiple poly trait refs that\n     /// are nested (under the `associcated_type_bounds` feature). The binders of\n     /// the innner poly trait refs are extended from the outer poly trait refs\n@@ -309,8 +286,7 @@ enum BinderScopeType {\n     /// would be `Concatenating`. This also used in trait refs in where clauses\n     /// where we have two binders `for<> T: for<> Foo` (I've intentionally left\n     /// out any lifetimes because they aren't needed to show the two scopes).\n-    /// See `BoundedTy` for a bit more details, but the inner `for<>` has a scope\n-    /// of `Concatenating`.\n+    /// The inner `for<>` has a scope of `Concatenating`.\n     Concatenating,\n     /// Any other binder scopes. These are \"normal\" in that they increase the binder\n     /// depth, are fully syntactic, don't concatenate, and don't have special syntactical\n@@ -1311,7 +1287,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             next_early_index,\n                             track_lifetime_uses: true,\n                             opaque_type_parent: false,\n-                            scope_type: BinderScopeType::BoundedTy,\n+                            scope_type: BinderScopeType::PolyTraitRef,\n                         };\n                         this.with(scope, |old_scope, this| {\n                             this.check_lifetime_params(old_scope, &bound_generic_params);\n@@ -1344,30 +1320,24 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         // FIXME(jackh726): This is pretty weird. `LangItemTrait` doesn't go\n         // through the regular poly trait ref code, so we don't get another\n         // chance to introduce a binder. For now, I'm keeping the existing logic\n-        // of \"if there isn't a `BoundedTy` scope above us, add one\", but I\n+        // of \"if there isn't a Binder scope above us, add one\", but I\n         // imagine there's a better way to go about this.\n         let mut scope = self.scope;\n         let trait_ref_hack = loop {\n             match scope {\n-                Scope::Body { .. } | Scope::Root => {\n+                Scope::TraitRefBoundary { .. } | Scope::Body { .. } | Scope::Root => {\n                     break false;\n                 }\n \n+                Scope::Binder { .. } => {\n+                    break true;\n+                }\n+\n                 Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::Supertrait { s, .. } => {\n                     scope = s;\n                 }\n-\n-                Scope::TraitRefBoundary { .. } => {\n-                    break false;\n-                }\n-\n-                Scope::Binder { scope_type, lifetimes, .. } => {\n-                    let trait_ref_hack =\n-                        matches!(scope_type, BinderScopeType::BoundedTy) && !lifetimes.is_empty();\n-                    break trait_ref_hack;\n-                }\n             }\n         };\n         match bound {\n@@ -1402,10 +1372,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         let next_early_index = self.next_early_index();\n         let mut scope = self.scope;\n         let mut supertrait_lifetimes = vec![];\n-        let (mut binders, trait_ref_hack, scope_type) = loop {\n+        let (mut binders, scope_type) = loop {\n             match scope {\n                 Scope::Body { .. } | Scope::Root => {\n-                    break (vec![], false, BinderScopeType::PolyTraitRef);\n+                    break (vec![], BinderScopeType::PolyTraitRef);\n                 }\n \n                 Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n@@ -1420,10 +1390,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 Scope::TraitRefBoundary { .. } => {\n                     // We should only see super trait lifetimes if there is a `Binder` above\n                     assert!(supertrait_lifetimes.is_empty());\n-                    break (vec![], false, BinderScopeType::PolyTraitRef);\n+                    break (vec![], BinderScopeType::PolyTraitRef);\n                 }\n \n-                Scope::Binder { hir_id, scope_type, lifetimes, .. } => {\n+                Scope::Binder { hir_id, scope_type, .. } => {\n                     if let BinderScopeType::Other = scope_type {\n                         bug!(\n                             \"Expected all syntacic poly trait refs to be surrounded by a `TraitRefBoundary`\"\n@@ -1434,30 +1404,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     let mut full_binders =\n                         self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n                     full_binders.extend(supertrait_lifetimes.into_iter());\n-                    let trait_ref_hack =\n-                        matches!(scope_type, BinderScopeType::BoundedTy) && !lifetimes.is_empty();\n-                    break (full_binders, trait_ref_hack, BinderScopeType::Concatenating);\n+                    break (full_binders, BinderScopeType::Concatenating);\n                 }\n             }\n         };\n \n-        // See note on `BinderScopeType::BoundedTy`. If `for<..>`\n-        // has been defined in both the outer and inner part of the\n-        // trait ref, emit an error.\n-        let has_lifetimes = trait_ref.bound_generic_params.iter().any(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => true,\n-            _ => false,\n-        });\n-        if trait_ref_hack && has_lifetimes {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                trait_ref.span,\n-                E0316,\n-                \"nested quantification of lifetimes\"\n-            )\n-            .emit();\n-        }\n-\n         let initial_bound_vars = binders.len() as u32;\n         let mut lifetimes: FxHashMap<hir::ParamName, Region> = FxHashMap::default();\n         let binders_iter = trait_ref\n@@ -1486,7 +1437,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         // Always introduce a scope here, even if this is in a where clause and\n         // we introduced the binders around the bounded Ty. In that case, we\n         // just reuse the concatenation functionality also present in nested trait\n-        // refs. See `BinderScopeType::BoundedTy` for more details on that case.\n+        // refs.\n         let scope = Scope::Binder {\n             hir_id: trait_ref.trait_ref.hir_ref_id,\n             lifetimes,\n@@ -2319,7 +2270,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     }\n                     match scope_type {\n                         BinderScopeType::Other => late_depth += 1,\n-                        BinderScopeType::BoundedTy => late_depth += 1,\n                         BinderScopeType::PolyTraitRef => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n                     }\n@@ -3051,7 +3001,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     }\n                     match scope_type {\n                         BinderScopeType::Other => late_depth += 1,\n-                        BinderScopeType::BoundedTy => late_depth += 1,\n                         BinderScopeType::PolyTraitRef => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n                     }\n@@ -3216,7 +3165,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Binder { s, scope_type, .. } => {\n                     match scope_type {\n                         BinderScopeType::Other => late_depth += 1,\n-                        BinderScopeType::BoundedTy => late_depth += 1,\n                         BinderScopeType::PolyTraitRef => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n                     }"}]}