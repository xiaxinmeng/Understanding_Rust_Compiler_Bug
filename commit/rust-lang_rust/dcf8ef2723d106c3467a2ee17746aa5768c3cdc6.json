{"sha": "dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZjhlZjI3MjNkMTA2YzM0NjdhMmVlMTc3NDZhYTU3NjhjM2NkYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-05T03:03:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-05T03:03:45Z"}, "message": "Auto merge of #31321 - jseyfried:cleanup, r=nrc\n\nThe first commit improves detection of unused imports -- it should have been part of #30325. Right now, the unused import in the changed test would not be reported.\n\nThe rest of the commits are miscellaneous, independent clean-ups in resolve that I didn't think warranted individual PRs.\n\nr? @nrc", "tree": {"sha": "c68fed0383cb57e0da5f0e3ed1683bddb71a94c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c68fed0383cb57e0da5f0e3ed1683bddb71a94c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "html_url": "https://github.com/rust-lang/rust/commit/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bcced73b77ba56834c3b5da0c4f82f80aa74db8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bcced73b77ba56834c3b5da0c4f82f80aa74db8", "html_url": "https://github.com/rust-lang/rust/commit/7bcced73b77ba56834c3b5da0c4f82f80aa74db8"}, {"sha": "9c166cb6713e1cbeed1db6efc4f7eb1dfa150294", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c166cb6713e1cbeed1db6efc4f7eb1dfa150294", "html_url": "https://github.com/rust-lang/rust/commit/9c166cb6713e1cbeed1db6efc4f7eb1dfa150294"}], "stats": {"total": 418, "additions": 128, "deletions": 290}, "files": [{"sha": "1361fac5b161ba5f9bce27e7f887701926fd0b45", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "patch": "@@ -20,7 +20,7 @@ use front::map as ast_map;\n use session::Session;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n use middle::cstore::InlinedItem;\n-use middle::ty::{self, Ty};\n+use middle::ty;\n \n use std::cell::RefCell;\n use std::collections::hash_map::Entry;"}, {"sha": "2688d549d4facf19c73de213d5fe2e6d067e2b15", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "patch": "@@ -26,7 +26,6 @@ use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n use syntax::{abi, ast};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n-use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n \n use rustc_front::hir;\n use rustc_front::intravisit::{self, Visitor};"}, {"sha": "6bc73194aa98b5cc220f509dcd44bd7143fc5fa3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "patch": "@@ -142,29 +142,17 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n-        // Check each statement.\n-        for statement in &block.stmts {\n-            match statement.node {\n-                StmtDecl(ref declaration, _) => {\n-                    match declaration.node {\n-                        DeclItem(_) => {\n-                            return true;\n-                        }\n-                        _ => {\n-                            // Keep searching.\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    // Keep searching.\n+        fn is_item(statement: &hir::Stmt) -> bool {\n+            if let StmtDecl(ref declaration, _) = statement.node {\n+                if let DeclItem(_) = declaration.node {\n+                    return true;\n                 }\n             }\n+            false\n         }\n \n-        // If we found no items, we don't need to create\n-        // an anonymous module.\n-\n-        return false;\n+        // If any statements are items, we need to create an anonymous module\n+        block.stmts.iter().any(is_item)\n     }\n \n     /// Constructs the reduced graph for one item.\n@@ -309,7 +297,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     let external_module = self.new_extern_crate_module(parent_link, def);\n                     self.define(parent, name, TypeNS, (external_module, sp));\n \n-                    self.build_reduced_graph_for_external_crate(&external_module);\n+                    self.build_reduced_graph_for_external_crate(external_module);\n                 }\n                 parent\n             }\n@@ -365,7 +353,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 for variant in &(*enum_definition).variants {\n                     let item_def_id = self.ast_map.local_def_id(item.id);\n                     self.build_reduced_graph_for_variant(variant, item_def_id,\n-                                                         &module, variant_modifiers);\n+                                                         module, variant_modifiers);\n                 }\n                 parent\n             }\n@@ -421,7 +409,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     };\n \n                     let modifiers = DefModifiers::PUBLIC; // NB: not DefModifiers::IMPORTABLE\n-                    self.define(&module_parent, item.name, ns, (def, item.span, modifiers));\n+                    self.define(module_parent, item.name, ns, (def, item.span, modifiers));\n \n                     self.trait_item_map.insert((item.name, def_id), item_def_id);\n                 }"}, {"sha": "64973bd791634f11f92773320bf05b39296b1660", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 79, "deletions": 178, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "patch": "@@ -662,10 +662,11 @@ enum ResolveResult<T> {\n }\n \n impl<T> ResolveResult<T> {\n-    fn success(&self) -> bool {\n-        match *self {\n-            Success(_) => true,\n-            _ => false,\n+    fn and_then<U, F: FnOnce(T) -> ResolveResult<U>>(self, f: F) -> ResolveResult<U> {\n+        match self {\n+            Failed(msg) => Failed(msg),\n+            Indeterminate => Indeterminate,\n+            Success(t) => f(t),\n         }\n     }\n }\n@@ -789,7 +790,7 @@ enum ParentLink<'a> {\n /// One node in the tree of modules.\n pub struct ModuleS<'a> {\n     parent_link: ParentLink<'a>,\n-    def: Cell<Option<Def>>,\n+    def: Option<Def>,\n     is_public: bool,\n     is_extern_crate: bool,\n \n@@ -839,7 +840,7 @@ impl<'a> ModuleS<'a> {\n     fn new(parent_link: ParentLink<'a>, def: Option<Def>, external: bool, is_public: bool) -> Self {\n         ModuleS {\n             parent_link: parent_link,\n-            def: Cell::new(def),\n+            def: def,\n             is_public: is_public,\n             is_extern_crate: false,\n             children: RefCell::new(HashMap::new()),\n@@ -877,18 +878,18 @@ impl<'a> ModuleS<'a> {\n     }\n \n     fn def_id(&self) -> Option<DefId> {\n-        self.def.get().as_ref().map(Def::def_id)\n+        self.def.as_ref().map(Def::def_id)\n     }\n \n     fn is_normal(&self) -> bool {\n-        match self.def.get() {\n+        match self.def {\n             Some(Def::Mod(_)) | Some(Def::ForeignMod(_)) => true,\n             _ => false,\n         }\n     }\n \n     fn is_trait(&self) -> bool {\n-        match self.def.get() {\n+        match self.def {\n             Some(Def::Trait(_)) => true,\n             _ => false,\n         }\n@@ -987,7 +988,7 @@ impl<'a> NameBinding<'a> {\n     fn def(&self) -> Option<Def> {\n         match self.def_or_module {\n             DefOrModule::Def(def) => Some(def),\n-            DefOrModule::Module(ref module) => module.def.get(),\n+            DefOrModule::Module(ref module) => module.def,\n         }\n     }\n \n@@ -1197,7 +1198,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     #[inline]\n-    fn record_import_use(&mut self, import_id: NodeId, name: Name) {\n+    fn record_import_use(&mut self, name: Name, ns: Namespace, resolution: &ImportResolution<'a>) {\n+        let import_id = resolution.id;\n+        self.used_imports.insert((import_id, ns));\n+        match resolution.target.as_ref().and_then(|target| target.target_module.def_id()) {\n+            Some(DefId { krate, .. }) => { self.used_crates.insert(krate); }\n+            _ => {}\n+        };\n+\n         if !self.make_glob_map {\n             return;\n         }\n@@ -1249,12 +1257,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index];\n-            match self.resolve_name_in_module(search_module, name, TypeNS, false) {\n+            match self.resolve_name_in_module(search_module, name, TypeNS, false, true) {\n                 Failed(None) => {\n                     let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n                     let mut span = span;\n-                    let msg = if \"???\" == &module_name[..] {\n+                    let msg = if \"???\" == &module_name {\n                         span.hi = span.lo + Pos::from_usize(segment_name.len());\n \n                         match search_parent_externals(name, &self.current_module) {\n@@ -1328,8 +1336,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Span)\n                            -> ResolveResult<(Module<'a>, LastPrivate)> {\n-        let module_path_len = module_path.len();\n-        assert!(module_path_len > 0);\n+        if module_path.len() == 0 {\n+            return Success((self.graph_root, LastMod(AllPublic))) // Use the crate root\n+        }\n \n         debug!(\"(resolving module path for import) processing `{}` rooted at `{}`\",\n                names_to_string(module_path),\n@@ -1380,16 +1389,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        match self.resolve_module_in_lexical_scope(module_, module_path[0]) {\n+                        match self.resolve_item_in_lexical_scope(module_,\n+                                                                 module_path[0],\n+                                                                 TypeNS,\n+                                                                 true) {\n                             Failed(err) => return Failed(err),\n                             Indeterminate => {\n                                 debug!(\"(resolving module path for import) indeterminate; bailing\");\n                                 return Indeterminate;\n                             }\n-                            Success(containing_module) => {\n-                                search_module = containing_module;\n-                                start_index = 1;\n-                                last_private = LastMod(AllPublic);\n+                            Success((target, _)) => match target.binding.module() {\n+                                Some(containing_module) => {\n+                                    search_module = containing_module;\n+                                    start_index = 1;\n+                                    last_private = LastMod(AllPublic);\n+                                }\n+                                None => return Failed(None),\n                             }\n                         }\n                     }\n@@ -1423,47 +1438,29 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                namespace,\n                module_to_string(&*module_));\n \n-        // The current module node is handled specially. First, check for\n-        // its immediate children.\n-        build_reduced_graph::populate_module_if_necessary(self, &module_);\n-\n-        if let Some(binding) = module_.get_child(name, namespace) {\n-            debug!(\"top name bindings succeeded\");\n-            return Success((Target::new(module_, binding, Shadowable::Never), false));\n-        }\n+        // Proceed up the scope chain looking for parent modules.\n+        let mut search_module = module_;\n+        loop {\n+            // Resolve the name in the parent module.\n+            match self.resolve_name_in_module(search_module, name, namespace, true, record_used) {\n+                Failed(Some((span, msg))) => {\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                }\n+                Failed(None) => (), // Continue up the search chain.\n+                Indeterminate => {\n+                    // We couldn't see through the higher scope because of an\n+                    // unresolved import higher up. Bail.\n \n-        // Now check for its import directives. We don't have to have resolved\n-        // all its imports in the usual way; this is because chains of\n-        // adjacent import statements are processed as though they mutated the\n-        // current scope.\n-        if let Some(import_resolution) =\n-            module_.import_resolutions.borrow().get(&(name, namespace)) {\n-            match import_resolution.target.clone() {\n-                None => {\n-                    // Not found; continue.\n-                    debug!(\"(resolving item in lexical scope) found import resolution, but not \\\n-                            in namespace {:?}\",\n-                           namespace);\n+                    debug!(\"(resolving item in lexical scope) indeterminate higher scope; bailing\");\n+                    return Indeterminate;\n                 }\n-                Some(target) => {\n-                    debug!(\"(resolving item in lexical scope) using import resolution\");\n-                    // track used imports and extern crates as well\n-                    let id = import_resolution.id;\n-                    if record_used {\n-                        self.used_imports.insert((id, namespace));\n-                        self.record_import_use(id, name);\n-                        if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n-                            self.used_crates.insert(kid);\n-                        }\n-                    }\n-                    return Success((target, false));\n+                Success((target, used_reexport)) => {\n+                    // We found the module.\n+                    debug!(\"(resolving item in lexical scope) found name in module, done\");\n+                    return Success((target, used_reexport));\n                 }\n             }\n-        }\n \n-        // Finally, proceed up the scope chain looking for parent modules.\n-        let mut search_module = module_;\n-        loop {\n             // Go to the next parent.\n             match search_module.parent_link {\n                 NoParentLink => {\n@@ -1485,55 +1482,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     search_module = parent_module_node;\n                 }\n             }\n-\n-            // Resolve the name in the parent module.\n-            match self.resolve_name_in_module(search_module, name, namespace, true) {\n-                Failed(Some((span, msg))) => {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n-                }\n-                Failed(None) => (), // Continue up the search chain.\n-                Indeterminate => {\n-                    // We couldn't see through the higher scope because of an\n-                    // unresolved import higher up. Bail.\n-\n-                    debug!(\"(resolving item in lexical scope) indeterminate higher scope; bailing\");\n-                    return Indeterminate;\n-                }\n-                Success((target, used_reexport)) => {\n-                    // We found the module.\n-                    debug!(\"(resolving item in lexical scope) found name in module, done\");\n-                    return Success((target, used_reexport));\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Resolves a module name in the current lexical scope.\n-    fn resolve_module_in_lexical_scope(&mut self,\n-                                       module_: Module<'a>,\n-                                       name: Name)\n-                                       -> ResolveResult<Module<'a>> {\n-        // If this module is an anonymous module, resolve the item in the\n-        // lexical scope. Otherwise, resolve the item from the crate root.\n-        let resolve_result = self.resolve_item_in_lexical_scope(module_, name, TypeNS, true);\n-        match resolve_result {\n-            Success((target, _)) => {\n-                if let Some(module_def) = target.binding.module() {\n-                    return Success(module_def)\n-                } else {\n-                    debug!(\"!!! (resolving module in lexical scope) module \\\n-                            wasn't actually a module!\");\n-                    return Failed(None);\n-                }\n-            }\n-            Indeterminate => {\n-                debug!(\"(resolving module in lexical scope) indeterminate; bailing\");\n-                return Indeterminate;\n-            }\n-            Failed(err) => {\n-                debug!(\"(resolving module in lexical scope) failed to resolve\");\n-                return Failed(err);\n-            }\n         }\n     }\n \n@@ -1612,14 +1560,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               module_: Module<'a>,\n                               name: Name,\n                               namespace: Namespace,\n-                              allow_private_imports: bool)\n+                              allow_private_imports: bool,\n+                              record_used: bool)\n                               -> ResolveResult<(Target<'a>, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n                name,\n                module_to_string(&*module_));\n \n         // First, check the direct children of the module.\n-        build_reduced_graph::populate_module_if_necessary(self, &module_);\n+        build_reduced_graph::populate_module_if_necessary(self, module_);\n \n         if let Some(binding) = module_.get_child(name, namespace) {\n             debug!(\"(resolving name in module) found node as child\");\n@@ -1633,22 +1582,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     debug!(\"(resolving name in module) import unresolved; bailing out\");\n                     return Indeterminate;\n                 }\n-                match import_resolution.target.clone() {\n-                    None => {\n-                        debug!(\"(resolving name in module) name found, but not in namespace {:?}\",\n-                               namespace);\n-                    }\n-                    Some(target) => {\n-                        debug!(\"(resolving name in module) resolved to import\");\n-                        // track used imports and extern crates as well\n-                        let id = import_resolution.id;\n-                        self.used_imports.insert((id, namespace));\n-                        self.record_import_use(id, name);\n-                        if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n-                            self.used_crates.insert(kid);\n-                        }\n-                        return Success((target, true));\n+                if let Some(target) = import_resolution.target.clone() {\n+                    debug!(\"(resolving name in module) resolved to import\");\n+                    if record_used {\n+                        self.record_import_use(name, namespace, &import_resolution);\n                     }\n+                    return Success((target, true));\n                 }\n             }\n             Some(..) | None => {} // Continue.\n@@ -1670,7 +1609,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Descend into children and anonymous children.\n-        build_reduced_graph::populate_module_if_necessary(self, &module_);\n+        build_reduced_graph::populate_module_if_necessary(self, module_);\n \n         module_.for_each_local_child(|_, _, child_node| {\n             match child_node.module() {\n@@ -2835,9 +2774,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n+        // Check the items.\n+        let module = self.current_module;\n         let name = identifier.unhygienic_name;\n-        self.resolve_item_by_name_in_lexical_scope(name, namespace, record_used)\n-            .map(LocalDef::from_def)\n+        match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n+            Success((target, _)) => target.binding.def().map(LocalDef::from_def),\n+            Failed(Some((span, msg))) => {\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                None\n+            }\n+            _ => None,\n+        }\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n@@ -2967,7 +2914,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        let def = match self.resolve_name_in_module(containing_module, name, namespace, false) {\n+        let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n+        let def = match result {\n             Success((Target { binding, .. }, _)) => {\n                 let (def, lp) = binding.def_and_lp();\n                 (def, last_private.or(lp))\n@@ -2999,7 +2947,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let containing_module;\n         let last_private;\n         match self.resolve_module_path_from_root(root_module,\n-                                                 &module_path[..],\n+                                                 &module_path,\n                                                  0,\n                                                  span,\n                                                  LastMod(AllPublic)) {\n@@ -3008,7 +2956,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          names_to_string(&module_path[..]));\n+                                          names_to_string(&module_path));\n                         (span, msg)\n                     }\n                 };\n@@ -3026,7 +2974,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        match self.resolve_name_in_module(containing_module, name, namespace, false) {\n+        match self.resolve_name_in_module(containing_module, name, namespace, false, true) {\n             Success((Target { binding, .. }, _)) => {\n                 let (def, lp) = binding.def_and_lp();\n                 Some((def, last_private.or(lp)))\n@@ -3068,6 +3016,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Success((target, _)) = self.resolve_name_in_module(module,\n                                                                           ident.unhygienic_name,\n                                                                           namespace,\n+                                                                          true,\n                                                                           true) {\n                     if let Some(def) = target.binding.def() {\n                         return Some(LocalDef::from_def(def));\n@@ -3079,49 +3028,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         None\n     }\n \n-    fn resolve_item_by_name_in_lexical_scope(&mut self,\n-                                             name: Name,\n-                                             namespace: Namespace,\n-                                             record_used: bool)\n-                                             -> Option<Def> {\n-        // Check the items.\n-        let module = self.current_module;\n-        match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n-            Success((target, _)) => {\n-                match target.binding.def() {\n-                    None => {\n-                        // This can happen if we were looking for a type and\n-                        // found a module instead. Modules don't have defs.\n-                        debug!(\"(resolving item path by identifier in lexical scope) failed to \\\n-                                resolve {} after success...\",\n-                               name);\n-                        None\n-                    }\n-                    Some(def) => {\n-                        debug!(\"(resolving item path in lexical scope) resolved `{}` to item\",\n-                               name);\n-                        // This lookup is \"all public\" because it only searched\n-                        // for one identifier in the current module (couldn't\n-                        // have passed through reexports or anything like that.\n-                        Some(def)\n-                    }\n-                }\n-            }\n-            Indeterminate => None,\n-            Failed(err) => {\n-                debug!(\"(resolving item path by identifier in lexical scope) failed to \\\n-                        resolve `{}`\",\n-                       name);\n-\n-                if let Some((span, msg)) = err {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&*msg))\n-                }\n-\n-                None\n-            }\n-        }\n-    }\n-\n     fn with_no_errors<T, F>(&mut self, f: F) -> T\n         where F: FnOnce(&mut Resolver) -> T\n     {\n@@ -3564,13 +3470,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n                 if self.trait_item_map.contains_key(&(name, did)) {\n                     add_trait_info(&mut found_traits, did, name);\n-                    let id = import.id;\n-                    self.used_imports.insert((id, TypeNS));\n                     let trait_name = self.get_trait_name(did);\n-                    self.record_import_use(id, trait_name);\n-                    if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n-                        self.used_crates.insert(kid);\n-                    }\n+                    self.record_import_use(trait_name, TypeNS, &import);\n                 }\n             }\n "}, {"sha": "3d2300e44c46893484a9f0ef897856089a26f4da", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 30, "deletions": 82, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "patch": "@@ -257,7 +257,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         errors.extend(self.resolve_imports_for_module(module_));\n         self.resolver.current_module = orig_module;\n \n-        build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n+        build_reduced_graph::populate_module_if_necessary(self.resolver, module_);\n         module_.for_each_local_child(|_, _, child_node| {\n             match child_node.module() {\n                 None => {\n@@ -332,92 +332,45 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                  module_: Module<'b>,\n                                  import_directive: &ImportDirective)\n                                  -> ResolveResult<()> {\n-        let mut resolution_result = ResolveResult::Failed(None);\n-        let module_path = &import_directive.module_path;\n-\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               names_to_string(&module_path[..]),\n+               names_to_string(&import_directive.module_path),\n                module_to_string(&*module_));\n \n-        // First, resolve the module path for the directive, if necessary.\n-        let container = if module_path.is_empty() {\n-            // Use the crate root.\n-            Some((self.resolver.graph_root, LastMod(AllPublic)))\n-        } else {\n-            match self.resolver.resolve_module_path(module_,\n-                                                    &module_path[..],\n-                                                    UseLexicalScopeFlag::DontUseLexicalScope,\n-                                                    import_directive.span) {\n-                ResolveResult::Failed(err) => {\n-                    resolution_result = ResolveResult::Failed(err);\n-                    None\n-                }\n-                ResolveResult::Indeterminate => {\n-                    resolution_result = ResolveResult::Indeterminate;\n-                    None\n-                }\n-                ResolveResult::Success(container) => Some(container),\n-            }\n-        };\n-\n-        match container {\n-            None => {}\n-            Some((containing_module, lp)) => {\n+        self.resolver\n+            .resolve_module_path(module_,\n+                                 &import_directive.module_path,\n+                                 UseLexicalScopeFlag::DontUseLexicalScope,\n+                                 import_directive.span)\n+            .and_then(|(containing_module, lp)| {\n                 // We found the module that the target is contained\n                 // within. Attempt to resolve the import within it.\n-\n-                match import_directive.subclass {\n-                    SingleImport(target, source) => {\n-                        resolution_result = self.resolve_single_import(&module_,\n-                                                                       containing_module,\n-                                                                       target,\n-                                                                       source,\n-                                                                       import_directive,\n-                                                                       lp);\n-                    }\n-                    GlobImport => {\n-                        resolution_result = self.resolve_glob_import(&module_,\n-                                                                     containing_module,\n-                                                                     import_directive,\n-                                                                     lp);\n-                    }\n+                if let SingleImport(target, source) = import_directive.subclass {\n+                    self.resolve_single_import(module_,\n+                                               containing_module,\n+                                               target,\n+                                               source,\n+                                               import_directive,\n+                                               lp)\n+                } else {\n+                    self.resolve_glob_import(module_, containing_module, import_directive, lp)\n                 }\n-            }\n-        }\n-\n-        // Decrement the count of unresolved imports.\n-        match resolution_result {\n-            ResolveResult::Success(()) => {\n+            })\n+            .and_then(|()| {\n+                // Decrement the count of unresolved imports.\n                 assert!(self.resolver.unresolved_imports >= 1);\n                 self.resolver.unresolved_imports -= 1;\n-            }\n-            _ => {\n-                // Nothing to do here; just return the error.\n-            }\n-        }\n-\n-        // Decrement the count of unresolved globs if necessary. But only if\n-        // the resolution result is a success -- other cases will\n-        // be handled by the main loop.\n \n-        if resolution_result.success() {\n-            match import_directive.subclass {\n-                GlobImport => {\n+                if let GlobImport = import_directive.subclass {\n                     module_.dec_glob_count();\n                     if import_directive.is_public {\n                         module_.dec_pub_glob_count();\n                     }\n                 }\n-                SingleImport(..) => {\n-                    // Ignore.\n+                if import_directive.is_public {\n+                    module_.dec_pub_count();\n                 }\n-            }\n-            if import_directive.is_public {\n-                module_.dec_pub_count();\n-            }\n-        }\n-\n-        return resolution_result;\n+                Success(())\n+            })\n     }\n \n     /// Resolves the name in the namespace of the module because it is being imported by\n@@ -460,12 +413,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n                 let target = resolution.target.clone();\n                 if let Some(Target { target_module, binding, shadowable: _ }) = target {\n-                    // track used imports and extern crates as well\n-                    self.resolver.used_imports.insert((resolution.id, ns));\n-                    self.resolver.record_import_use(resolution.id, name);\n-                    if let Some(DefId { krate, .. }) = target_module.def_id() {\n-                        self.resolver.used_crates.insert(krate);\n-                    }\n+                    self.resolver.record_import_use(name, ns, &resolution);\n                     (Success((target_module, binding)), true)\n                 } else {\n                     (Failed(None), false)\n@@ -517,9 +465,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         // We need to resolve both namespaces for this to succeed.\n         let (value_result, value_used_reexport) =\n-            self.resolve_name_in_module(&target_module, source, ValueNS, module_);\n+            self.resolve_name_in_module(target_module, source, ValueNS, module_);\n         let (type_result, type_used_reexport) =\n-            self.resolve_name_in_module(&target_module, source, TypeNS, module_);\n+            self.resolve_name_in_module(target_module, source, TypeNS, module_);\n \n         match (&value_result, &type_result) {\n             (&Success((_, ref name_binding)), _) if !value_used_reexport &&\n@@ -637,7 +585,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         if let (&Failed(_), &Failed(_)) = (&value_result, &type_result) {\n             let msg = format!(\"There is no `{}` in `{}`{}\",\n                               source,\n-                              module_to_string(&target_module), lev_suggestion);\n+                              module_to_string(target_module), lev_suggestion);\n             return Failed(Some((directive.span, msg)));\n         }\n \n@@ -763,7 +711,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n \n         // Add all children from the containing module.\n-        build_reduced_graph::populate_module_if_necessary(self.resolver, &target_module);\n+        build_reduced_graph::populate_module_if_necessary(self.resolver, target_module);\n \n         target_module.for_each_local_child(|name, ns, name_binding| {\n             self.merge_import_resolution(module_,"}, {"sha": "fe37006e5cf73931f0da76c34317a310e5003f6e", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "patch": "@@ -26,7 +26,7 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n use middle::def_id::DefId;\n use middle::infer;\n use middle::pat_util;\n-use middle::subst::{self, Substs};\n+use middle::subst;\n use rustc::front::map as hir_map;\n use rustc_front::hir;\n use trans::{type_of, adt, machine, monomorphize};"}, {"sha": "9f20131f9aad1be24e9d7f9ad6a7b1fbb790c2f6", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "patch": "@@ -15,7 +15,7 @@ use super::namespace::crate_root_namespace;\n use trans::common::CrateContext;\n use middle::def_id::DefId;\n use middle::infer;\n-use middle::subst::{self, Substs};\n+use middle::subst;\n use middle::ty::{self, Ty};\n \n use rustc_front::hir;"}, {"sha": "64dbe66a88f1d69eddca885507eeb66d55e3a982", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "patch": "@@ -50,7 +50,6 @@ use middle::ty::cast::{CastKind, CastTy};\n use syntax::codemap::Span;\n use rustc_front::hir;\n use syntax::ast;\n-use syntax::ast::UintTy::TyU8;\n \n \n /// Reifies a cast check to be checked once we have full type information for"}, {"sha": "064259c171d91bb638192068bc2fbfd4e2a757b0", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "patch": "@@ -17,7 +17,7 @@ use astconv::AstConv;\n use check::{self, FnCtxt};\n use front::map as hir_map;\n use middle::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TypeFoldable};\n-use middle::cstore::{self, CrateStore, DefLike};\n+use middle::cstore::{self, CrateStore};\n use middle::def::Def;\n use middle::def_id::DefId;\n use middle::lang_items::FnOnceTraitLangItem;"}, {"sha": "9a0d6bc16411a553e8ea745254c6c2a823110684", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "patch": "@@ -92,7 +92,7 @@ use middle::infer;\n use middle::infer::{TypeOrigin, type_variable};\n use middle::pat_util::{self, pat_id_map};\n use middle::privacy::{AllPublic, LastMod};\n-use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n+use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{GenericPredicates, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};"}, {"sha": "080c5e400ac9d58a7bf2ce0588db688bf388fb8e", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcf8ef2723d106c3467a2ee17746aa5768c3cdc6/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=dcf8ef2723d106c3467a2ee17746aa5768c3cdc6", "patch": "@@ -56,7 +56,10 @@ mod bar {\n         use foo::Point;\n         use foo::Square; //~ ERROR unused import\n         pub fn cc(_p: Point) -> super::Square {\n-            super::Square\n+            fn f() -> super::Square {\n+                super::Square\n+            }\n+            f()\n         }\n     }\n "}]}