{"sha": "3259b48568c4fe19b60a47011c9fe424b707533c", "node_id": "C_kwDOAAsO6NoAKDMyNTliNDg1NjhjNGZlMTliNjBhNDcwMTFjOWZlNDI0YjcwNzUzM2M", "commit": {"author": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2023-03-28T12:22:22Z"}, "committer": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2023-03-28T12:22:22Z"}, "message": "Migrate `format_args.rs` to `rustc_ast::FormatArgs`\n\nNo longer lints empty precisions `{:.}` as the spans aren't available", "tree": {"sha": "15911924bfa36b44d44276e779d1040ac6121a17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15911924bfa36b44d44276e779d1040ac6121a17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3259b48568c4fe19b60a47011c9fe424b707533c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3259b48568c4fe19b60a47011c9fe424b707533c", "html_url": "https://github.com/rust-lang/rust/commit/3259b48568c4fe19b60a47011c9fe424b707533c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3259b48568c4fe19b60a47011c9fe424b707533c/comments", "author": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70db22648bb1a79d2f6978adf6dc40240de59d89", "url": "https://api.github.com/repos/rust-lang/rust/commits/70db22648bb1a79d2f6978adf6dc40240de59d89", "html_url": "https://github.com/rust-lang/rust/commit/70db22648bb1a79d2f6978adf6dc40240de59d89"}], "stats": {"total": 503, "additions": 264, "deletions": 239}, "files": [{"sha": "5c6040f63f50f336dbc0f44ad521407bf4db26de", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3259b48568c4fe19b60a47011c9fe424b707533c/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3259b48568c4fe19b60a47011c9fe424b707533c/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=3259b48568c4fe19b60a47011c9fe424b707533c", "patch": "@@ -9,6 +9,7 @@ keywords = [\"clippy\", \"lint\", \"plugin\"]\n edition = \"2021\"\n \n [dependencies]\n+arrayvec = { version = \"0.7\", default-features = false }\n cargo_metadata = \"0.15.3\"\n clippy_utils = { path = \"../clippy_utils\" }\n declare_clippy_lint = { path = \"../declare_clippy_lint\" }"}, {"sha": "08e45ed7d0ec8e45a08f1bcc9cdff0630e82354a", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 124, "deletions": 86, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/3259b48568c4fe19b60a47011c9fe424b707533c/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3259b48568c4fe19b60a47011c9fe424b707533c/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=3259b48568c4fe19b60a47011c9fe424b707533c", "patch": "@@ -1,27 +1,31 @@\n+use arrayvec::ArrayVec;\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::is_diag_trait_item;\n-use clippy_utils::macros::FormatParamKind::{Implicit, Named, NamedInline, Numbered, Starred};\n use clippy_utils::macros::{\n-    is_assert_macro, is_format_macro, is_panic, root_macro_call, Count, FormatArg, FormatArgsExpn, FormatParam,\n-    FormatParamUsage,\n+    find_format_arg_expr, find_format_args, format_arg_removal_span, format_placeholder_format_span, is_assert_macro,\n+    is_format_macro, is_panic, root_macro_call, root_macro_call_first_node, FormatParamUsage,\n };\n use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{implements_trait, is_type_lang_item};\n use if_chain::if_chain;\n use itertools::Itertools;\n+use rustc_ast::{\n+    FormatArgPosition, FormatArgPositionKind, FormatArgsPiece, FormatArgumentKind, FormatCount, FormatOptions,\n+    FormatPlaceholder, FormatTrait,\n+};\n use rustc_errors::{\n     Applicability,\n     SuggestionStyle::{CompletelyHidden, ShowCode},\n };\n-use rustc_hir::{Expr, ExprKind, HirId, LangItem, QPath};\n+use rustc_hir::{Expr, ExprKind, LangItem};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_middle::ty::Ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::def_id::DefId;\n use rustc_span::edition::Edition::Edition2021;\n-use rustc_span::{sym, ExpnData, ExpnKind, Span, Symbol};\n+use rustc_span::{sym, Span, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -184,111 +188,120 @@ impl FormatArgs {\n \n impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let Some(format_args) = FormatArgsExpn::parse(cx, expr)\n-            && let expr_expn_data = expr.span.ctxt().outer_expn_data()\n-            && let outermost_expn_data = outermost_expn_data(expr_expn_data)\n-            && let Some(macro_def_id) = outermost_expn_data.macro_def_id\n-            && is_format_macro(cx, macro_def_id)\n-            && let ExpnKind::Macro(_, name) = outermost_expn_data.kind\n-        {\n-            for arg in &format_args.args {\n-                check_unused_format_specifier(cx, arg);\n-                if !arg.format.is_default() {\n-                    continue;\n-                }\n-                if is_aliased(&format_args, arg.param.value.hir_id) {\n-                    continue;\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        if !is_format_macro(cx, macro_call.def_id) {\n+            return;\n+        }\n+        let name = cx.tcx.item_name(macro_call.def_id);\n+\n+        find_format_args(cx, expr, macro_call.expn, |format_args| {\n+            for piece in &format_args.template {\n+                if let FormatArgsPiece::Placeholder(placeholder) = piece\n+                    && let Ok(index) = placeholder.argument.index\n+                    && let Some(arg) = format_args.arguments.all_args().get(index)\n+                {\n+                    let arg_expr = find_format_arg_expr(expr, arg);\n+\n+                    check_unused_format_specifier(cx, placeholder, arg_expr);\n+\n+                    if placeholder.format_trait != FormatTrait::Display\n+                        || placeholder.format_options != FormatOptions::default()\n+                        || is_aliased(format_args, index)\n+                    {\n+                        continue;\n+                    }\n+\n+                    if let Ok(arg_hir_expr) = arg_expr {\n+                        check_format_in_format_args(cx, macro_call.span, name, arg_hir_expr);\n+                        check_to_string_in_format_args(cx, name, arg_hir_expr);\n+                    }\n                 }\n-                check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg.param.value);\n-                check_to_string_in_format_args(cx, name, arg.param.value);\n             }\n+\n             if self.msrv.meets(msrvs::FORMAT_ARGS_CAPTURE) {\n-                check_uninlined_args(cx, &format_args, outermost_expn_data.call_site, macro_def_id, self.ignore_mixed);\n+                check_uninlined_args(cx, format_args, macro_call.span, macro_call.def_id, self.ignore_mixed);\n             }\n-        }\n+        });\n     }\n \n     extract_msrv_attr!(LateContext);\n }\n \n-fn check_unused_format_specifier(cx: &LateContext<'_>, arg: &FormatArg<'_>) {\n-    let param_ty = cx.typeck_results().expr_ty(arg.param.value).peel_refs();\n+fn check_unused_format_specifier(\n+    cx: &LateContext<'_>,\n+    placeholder: &FormatPlaceholder,\n+    arg_expr: Result<&Expr<'_>, &rustc_ast::Expr>,\n+) {\n+    let ty_or_ast_expr = arg_expr.map(|expr| cx.typeck_results().expr_ty(expr).peel_refs());\n \n-    if let Count::Implied(Some(mut span)) = arg.format.precision\n-        && !span.is_empty()\n-    {\n-        span_lint_and_then(\n-            cx,\n-            UNUSED_FORMAT_SPECS,\n-            span,\n-            \"empty precision specifier has no effect\",\n-            |diag| {\n-                if param_ty.is_floating_point() {\n-                    diag.note(\"a precision specifier is not required to format floats\");\n-                }\n+    let is_format_args = match ty_or_ast_expr {\n+        Ok(ty) => is_type_lang_item(cx, ty, LangItem::FormatArguments),\n+        Err(expr) => matches!(expr.peel_parens_and_refs().kind, rustc_ast::ExprKind::FormatArgs(_)),\n+    };\n \n-                if arg.format.is_default() {\n-                    // If there's no other specifiers remove the `:` too\n-                    span = arg.format_span();\n-                }\n+    let options = &placeholder.format_options;\n \n-                diag.span_suggestion_verbose(span, \"remove the `.`\", \"\", Applicability::MachineApplicable);\n-            },\n-        );\n-    }\n+    let arg_span = match arg_expr {\n+        Ok(expr) => expr.span,\n+        Err(expr) => expr.span,\n+    };\n \n-    if is_type_lang_item(cx, param_ty, LangItem::FormatArguments) && !arg.format.is_default_for_trait() {\n+    if let Some(placeholder_span) = placeholder.span\n+        && is_format_args\n+        && *options != FormatOptions::default()\n+    {\n         span_lint_and_then(\n             cx,\n             UNUSED_FORMAT_SPECS,\n-            arg.span,\n+            placeholder_span,\n             \"format specifiers have no effect on `format_args!()`\",\n             |diag| {\n-                let mut suggest_format = |spec, span| {\n+                let mut suggest_format = |spec| {\n                     let message = format!(\"for the {spec} to apply consider using `format!()`\");\n \n-                    if let Some(mac_call) = root_macro_call(arg.param.value.span)\n+                    if let Some(mac_call) = root_macro_call(arg_span)\n                         && cx.tcx.is_diagnostic_item(sym::format_args_macro, mac_call.def_id)\n-                        && arg.span.eq_ctxt(mac_call.span)\n                     {\n                         diag.span_suggestion(\n                             cx.sess().source_map().span_until_char(mac_call.span, '!'),\n                             message,\n                             \"format\",\n                             Applicability::MaybeIncorrect,\n                         );\n-                    } else if let Some(span) = span {\n-                        diag.span_help(span, message);\n+                    } else {\n+                        diag.help(message);\n                     }\n                 };\n \n-                if !arg.format.width.is_implied() {\n-                    suggest_format(\"width\", arg.format.width.span());\n+                if options.width.is_some() {\n+                    suggest_format(\"width\");\n                 }\n \n-                if !arg.format.precision.is_implied() {\n-                    suggest_format(\"precision\", arg.format.precision.span());\n+                if options.precision.is_some() {\n+                    suggest_format(\"precision\");\n                 }\n \n-                diag.span_suggestion_verbose(\n-                    arg.format_span(),\n-                    \"if the current behavior is intentional, remove the format specifiers\",\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                );\n+                if let Some(format_span) = format_placeholder_format_span(placeholder) {\n+                    diag.span_suggestion_verbose(\n+                        format_span,\n+                        \"if the current behavior is intentional, remove the format specifiers\",\n+                        \"\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n             },\n         );\n     }\n }\n \n fn check_uninlined_args(\n     cx: &LateContext<'_>,\n-    args: &FormatArgsExpn<'_>,\n+    args: &rustc_ast::FormatArgs,\n     call_site: Span,\n     def_id: DefId,\n     ignore_mixed: bool,\n ) {\n-    if args.format_string.span.from_expansion() {\n+    if args.span.from_expansion() {\n         return;\n     }\n     if call_site.edition() < Edition2021 && (is_panic(cx, def_id) || is_assert_macro(cx, def_id)) {\n@@ -303,7 +316,13 @@ fn check_uninlined_args(\n     // we cannot remove any other arguments in the format string,\n     // because the index numbers might be wrong after inlining.\n     // Example of an un-inlinable format:  print!(\"{}{1}\", foo, 2)\n-    if !args.params().all(|p| check_one_arg(args, &p, &mut fixes, ignore_mixed)) || fixes.is_empty() {\n+    for (pos, usage) in format_arg_positions(args) {\n+        if !check_one_arg(args, pos, usage, &mut fixes, ignore_mixed) {\n+            return;\n+        }\n+    }\n+\n+    if fixes.is_empty() {\n         return;\n     }\n \n@@ -332,38 +351,36 @@ fn check_uninlined_args(\n }\n \n fn check_one_arg(\n-    args: &FormatArgsExpn<'_>,\n-    param: &FormatParam<'_>,\n+    args: &rustc_ast::FormatArgs,\n+    pos: &FormatArgPosition,\n+    usage: FormatParamUsage,\n     fixes: &mut Vec<(Span, String)>,\n     ignore_mixed: bool,\n ) -> bool {\n-    if matches!(param.kind, Implicit | Starred | Named(_) | Numbered)\n-        && let ExprKind::Path(QPath::Resolved(None, path)) = param.value.kind\n-        && let [segment] = path.segments\n+    let index = pos.index.unwrap();\n+    let arg = &args.arguments.all_args()[index];\n+\n+    if !matches!(arg.kind, FormatArgumentKind::Captured(_))\n+        && let rustc_ast::ExprKind::Path(None, path) = &arg.expr.kind\n+        && let [segment] = path.segments.as_slice()\n         && segment.args.is_none()\n-        && let Some(arg_span) = args.value_with_prev_comma_span(param.value.hir_id)\n+        && let Some(arg_span) = format_arg_removal_span(args, index)\n+        && let Some(pos_span) = pos.span\n     {\n-        let replacement = match param.usage {\n+        let replacement = match usage {\n             FormatParamUsage::Argument => segment.ident.name.to_string(),\n             FormatParamUsage::Width => format!(\"{}$\", segment.ident.name),\n             FormatParamUsage::Precision => format!(\".{}$\", segment.ident.name),\n         };\n-        fixes.push((param.span, replacement));\n+        fixes.push((pos_span, replacement));\n         fixes.push((arg_span, String::new()));\n         true  // successful inlining, continue checking\n     } else {\n         // Do not continue inlining (return false) in case\n         // * if we can't inline a numbered argument, e.g. `print!(\"{0} ...\", foo.bar, ...)`\n         // * if allow_mixed_uninlined_format_args is false and this arg hasn't been inlined already\n-        param.kind != Numbered && (!ignore_mixed || matches!(param.kind, NamedInline(_)))\n-    }\n-}\n-\n-fn outermost_expn_data(expn_data: ExpnData) -> ExpnData {\n-    if expn_data.call_site.from_expansion() {\n-        outermost_expn_data(expn_data.call_site.ctxt().outer_expn_data())\n-    } else {\n-        expn_data\n+        pos.kind != FormatArgPositionKind::Number\n+            && (!ignore_mixed || matches!(arg.kind, FormatArgumentKind::Captured(_)))\n     }\n }\n \n@@ -438,10 +455,31 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n     }\n }\n \n-/// Returns true if `hir_id` is referred to by multiple format params\n-fn is_aliased(args: &FormatArgsExpn<'_>, hir_id: HirId) -> bool {\n-    args.params()\n-        .filter(|param| param.value.hir_id == hir_id)\n+fn format_arg_positions(\n+    format_args: &rustc_ast::FormatArgs,\n+) -> impl Iterator<Item = (&FormatArgPosition, FormatParamUsage)> {\n+    format_args.template.iter().flat_map(|piece| match piece {\n+        FormatArgsPiece::Placeholder(placeholder) => {\n+            let mut positions = ArrayVec::<_, 3>::new();\n+\n+            positions.push((&placeholder.argument, FormatParamUsage::Argument));\n+            if let Some(FormatCount::Argument(position)) = &placeholder.format_options.width {\n+                positions.push((position, FormatParamUsage::Width));\n+            }\n+            if let Some(FormatCount::Argument(position)) = &placeholder.format_options.precision {\n+                positions.push((position, FormatParamUsage::Precision));\n+            }\n+\n+            positions\n+        },\n+        FormatArgsPiece::Literal(_) => ArrayVec::new(),\n+    })\n+}\n+\n+/// Returns true if the format argument at `index` is referred to by multiple format params\n+fn is_aliased(format_args: &rustc_ast::FormatArgs, index: usize) -> bool {\n+    format_arg_positions(format_args)\n+        .filter(|(position, _)| position.index == Ok(index))\n         .at_most_one()\n         .is_err()\n }"}, {"sha": "09fcb82c37c88d95b78a87e20c7b3e7a7359c72a", "filename": "clippy_lints/src/utils/format_args_collector.rs", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/3259b48568c4fe19b60a47011c9fe424b707533c/clippy_lints%2Fsrc%2Futils%2Fformat_args_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3259b48568c4fe19b60a47011c9fe424b707533c/clippy_lints%2Fsrc%2Futils%2Fformat_args_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fformat_args_collector.rs?ref=3259b48568c4fe19b60a47011c9fe424b707533c", "patch": "@@ -1,7 +1,12 @@\n use clippy_utils::macros::collect_ast_format_args;\n-use rustc_ast::{Expr, ExprKind};\n+use clippy_utils::source::snippet_opt;\n+use itertools::Itertools;\n+use rustc_ast::{Expr, ExprKind, FormatArgs};\n+use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::hygiene;\n+use std::iter::once;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -15,9 +20,79 @@ declare_clippy_lint! {\n declare_lint_pass!(FormatArgsCollector => [FORMAT_ARGS_COLLECTOR]);\n \n impl EarlyLintPass for FormatArgsCollector {\n-    fn check_expr(&mut self, _: &EarlyContext<'_>, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if let ExprKind::FormatArgs(args) = &expr.kind {\n+            if has_span_from_proc_macro(cx, args) {\n+                return;\n+            }\n+\n             collect_ast_format_args(expr.span, args);\n         }\n     }\n }\n+\n+/// Detects if the format string or an argument has its span set by a proc macro to something inside\n+/// a macro callsite, e.g.\n+///\n+/// ```ignore\n+/// println!(some_proc_macro!(\"input {}\"), a);\n+/// ```\n+///\n+/// Where `some_proc_macro` expands to\n+///\n+/// ```ignore\n+/// println!(\"output {}\", a);\n+/// ```\n+///\n+/// But with the span of `\"output {}\"` set to the macro input\n+///\n+/// ```ignore\n+/// println!(some_proc_macro!(\"input {}\"), a);\n+/// //                        ^^^^^^^^^^\n+/// ```\n+fn has_span_from_proc_macro(cx: &EarlyContext<'_>, args: &FormatArgs) -> bool {\n+    let ctxt = args.span.ctxt();\n+\n+    // `format!(\"{} {} {c}\", \"one\", \"two\", c = \"three\")`\n+    //                       ^^^^^  ^^^^^      ^^^^^^^\n+    let argument_span = args\n+        .arguments\n+        .explicit_args()\n+        .iter()\n+        .map(|argument| hygiene::walk_chain(argument.expr.span, ctxt));\n+\n+    // `format!(\"{} {} {c}\", \"one\", \"two\", c = \"three\")`\n+    //                     ^^     ^^     ^^^^^^\n+    let between_spans = once(args.span)\n+        .chain(argument_span)\n+        .tuple_windows()\n+        .map(|(start, end)| start.between(end));\n+\n+    for between_span in between_spans {\n+        let mut seen_comma = false;\n+\n+        let Some(snippet) = snippet_opt(cx, between_span) else { return true };\n+        for token in tokenize(&snippet) {\n+            match token.kind {\n+                TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace => {},\n+                TokenKind::Comma if !seen_comma => seen_comma = true,\n+                // named arguments, `start_val, name = end_val`\n+                //                            ^^^^^^^^^ between_span\n+                TokenKind::Ident | TokenKind::Eq if seen_comma => {},\n+                // An unexpected token usually indicates that we crossed a macro boundary\n+                //\n+                // `println!(some_proc_macro!(\"input {}\"), a)`\n+                //                                      ^^^ between_span\n+                // `println!(\"{}\", val!(x))`\n+                //               ^^^^^^^ between_span\n+                _ => return true,\n+            }\n+        }\n+\n+        if !seen_comma {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "b03e0d4a1ca597b63a754a1b9d3d9d663de7e7ac", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3259b48568c4fe19b60a47011c9fe424b707533c/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3259b48568c4fe19b60a47011c9fe424b707533c/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=3259b48568c4fe19b60a47011c9fe424b707533c", "patch": "@@ -6,7 +6,7 @@ use crate::visitors::{for_each_expr, Descend};\n use arrayvec::ArrayVec;\n use itertools::{izip, Either, Itertools};\n use rustc_ast::ast::LitKind;\n-use rustc_ast::FormatArgs;\n+use rustc_ast::{FormatArgs, FormatArgument, FormatPlaceholder};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::{self as hir, Expr, ExprField, ExprKind, HirId, LangItem, Node, QPath, TyKind};\n@@ -391,30 +391,67 @@ pub fn collect_ast_format_args(span: Span, format_args: &FormatArgs) {\n     });\n }\n \n-/// Calls `callback` with an AST [`FormatArgs`] node if one is found\n+/// Calls `callback` with an AST [`FormatArgs`] node if a `format_args` expansion is found as a\n+/// descendant of `expn_id`\n pub fn find_format_args(cx: &LateContext<'_>, start: &Expr<'_>, expn_id: ExpnId, callback: impl FnOnce(&FormatArgs)) {\n     let format_args_expr = for_each_expr(start, |expr| {\n         let ctxt = expr.span.ctxt();\n-        if ctxt == start.span.ctxt() {\n-            ControlFlow::Continue(Descend::Yes)\n-        } else if ctxt.outer_expn().is_descendant_of(expn_id)\n-            && macro_backtrace(expr.span)\n+        if ctxt.outer_expn().is_descendant_of(expn_id) {\n+            if macro_backtrace(expr.span)\n                 .map(|macro_call| cx.tcx.item_name(macro_call.def_id))\n                 .any(|name| matches!(name, sym::const_format_args | sym::format_args | sym::format_args_nl))\n-        {\n-            ControlFlow::Break(expr)\n+            {\n+                ControlFlow::Break(expr)\n+            } else {\n+                ControlFlow::Continue(Descend::Yes)\n+            }\n         } else {\n             ControlFlow::Continue(Descend::No)\n         }\n     });\n \n-    if let Some(format_args_expr) = format_args_expr {\n+    if let Some(expr) = format_args_expr {\n         AST_FORMAT_ARGS.with(|ast_format_args| {\n-            ast_format_args.borrow().get(&format_args_expr.span).map(callback);\n+            ast_format_args.borrow().get(&expr.span).map(callback);\n         });\n     }\n }\n \n+/// Attempt to find the [`rustc_hir::Expr`] that corresponds to the [`FormatArgument`]'s value, if\n+/// it cannot be found it will return the [`rustc_ast::Expr`].\n+pub fn find_format_arg_expr<'hir, 'ast>(\n+    start: &'hir Expr<'hir>,\n+    target: &'ast FormatArgument,\n+) -> Result<&'hir rustc_hir::Expr<'hir>, &'ast rustc_ast::Expr> {\n+    for_each_expr(start, |expr| {\n+        if expr.span == target.expr.span {\n+            ControlFlow::Break(expr)\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    })\n+    .ok_or(&target.expr)\n+}\n+\n+/// Span of the `:` and format specifiers\n+///\n+/// ```ignore\n+/// format!(\"{:.}\"), format!(\"{foo:.}\")\n+///           ^^                  ^^\n+/// ```\n+pub fn format_placeholder_format_span(placeholder: &FormatPlaceholder) -> Option<Span> {\n+    let base = placeholder.span?.data();\n+\n+    // `base.hi` is `{...}|`, subtract 1 byte (the length of '}') so that it points before the closing\n+    // brace `{...|}`\n+    Some(Span::new(\n+        placeholder.argument.span?.hi(),\n+        base.hi - BytePos(1),\n+        base.ctxt,\n+        base.parent,\n+    ))\n+}\n+\n /// Returns the [`Span`] of the value at `index` extended to the previous comma, e.g. for the value\n /// `10`\n ///\n@@ -897,22 +934,6 @@ pub struct FormatArg<'tcx> {\n     pub span: Span,\n }\n \n-impl<'tcx> FormatArg<'tcx> {\n-    /// Span of the `:` and format specifiers\n-    ///\n-    /// ```ignore\n-    /// format!(\"{:.}\"), format!(\"{foo:.}\")\n-    ///           ^^                  ^^\n-    /// ```\n-    pub fn format_span(&self) -> Span {\n-        let base = self.span.data();\n-\n-        // `base.hi` is `{...}|`, subtract 1 byte (the length of '}') so that it points before the closing\n-        // brace `{...|}`\n-        Span::new(self.param.span.hi(), base.hi - BytePos(1), base.ctxt, base.parent)\n-    }\n-}\n-\n /// A parsed `format_args!` expansion.\n #[derive(Debug)]\n pub struct FormatArgsExpn<'tcx> {"}, {"sha": "1be0cda12fc11213b304bdfad651c7649c695667", "filename": "tests/ui-toml/allow_mixed_uninlined_format_args/uninlined_format_args.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3259b48568c4fe19b60a47011c9fe424b707533c/tests%2Fui-toml%2Fallow_mixed_uninlined_format_args%2Funinlined_format_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3259b48568c4fe19b60a47011c9fe424b707533c/tests%2Fui-toml%2Fallow_mixed_uninlined_format_args%2Funinlined_format_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fallow_mixed_uninlined_format_args%2Funinlined_format_args.stderr?ref=3259b48568c4fe19b60a47011c9fe424b707533c", "patch": "@@ -11,29 +11,29 @@ LL -     println!(\"val='{}'\", local_i32);\n LL +     println!(\"val='{local_i32}'\");\n    |\n \n-error: literal with an empty format string\n-  --> $DIR/uninlined_format_args.rs:10:35\n+error: variables can be used directly in the `format!` string\n+  --> $DIR/uninlined_format_args.rs:10:5\n    |\n LL |     println!(\"Hello {} is {:.*}\", \"x\", local_i32, local_f64);\n-   |                                   ^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `-D clippy::print-literal` implied by `-D warnings`\n-help: try this\n+help: change this to\n    |\n LL -     println!(\"Hello {} is {:.*}\", \"x\", local_i32, local_f64);\n-LL +     println!(\"Hello x is {:.*}\", local_i32, local_f64);\n+LL +     println!(\"Hello {} is {local_f64:.local_i32$}\", \"x\");\n    |\n \n-error: variables can be used directly in the `format!` string\n-  --> $DIR/uninlined_format_args.rs:10:5\n+error: literal with an empty format string\n+  --> $DIR/uninlined_format_args.rs:10:35\n    |\n LL |     println!(\"Hello {} is {:.*}\", \"x\", local_i32, local_f64);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^\n    |\n-help: change this to\n+   = note: `-D clippy::print-literal` implied by `-D warnings`\n+help: try this\n    |\n LL -     println!(\"Hello {} is {:.*}\", \"x\", local_i32, local_f64);\n-LL +     println!(\"Hello {} is {local_f64:.local_i32$}\", \"x\");\n+LL +     println!(\"Hello x is {:.*}\", local_i32, local_f64);\n    |\n \n error: variables can be used directly in the `format!` string"}, {"sha": "5ecb9a5bf9eb3658cf543068420203dfa7762a57", "filename": "tests/ui/uninlined_format_args.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3259b48568c4fe19b60a47011c9fe424b707533c/tests%2Fui%2Funinlined_format_args.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3259b48568c4fe19b60a47011c9fe424b707533c/tests%2Fui%2Funinlined_format_args.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args.fixed?ref=3259b48568c4fe19b60a47011c9fe424b707533c", "patch": "@@ -119,7 +119,7 @@ fn tester(fn_arg: i32) {\n     println!(\"Width = {local_i32}, value with width = {local_f64:local_i32$}\");\n     println!(\"{local_i32:width$.prec$}\");\n     println!(\"{width:width$.prec$}\");\n-    println!(\"{}\", format!(\"{local_i32}\"));\n+    println!(\"{}\", format!(\"{}\", local_i32));\n     my_println!(\"{}\", local_i32);\n     my_println_args!(\"{}\", local_i32);\n "}, {"sha": "dc4af6ef42ecd5a8201bf00218b4f69b524d8abe", "filename": "tests/ui/uninlined_format_args.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3259b48568c4fe19b60a47011c9fe424b707533c/tests%2Fui%2Funinlined_format_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3259b48568c4fe19b60a47011c9fe424b707533c/tests%2Fui%2Funinlined_format_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args.stderr?ref=3259b48568c4fe19b60a47011c9fe424b707533c", "patch": "@@ -774,18 +774,6 @@ LL -     println!(\"{:w$.p$}\", w = width, p = prec);\n LL +     println!(\"{width:width$.prec$}\");\n    |\n \n-error: variables can be used directly in the `format!` string\n-  --> $DIR/uninlined_format_args.rs:125:20\n-   |\n-LL |     println!(\"{}\", format!(\"{}\", local_i32));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: change this to\n-   |\n-LL -     println!(\"{}\", format!(\"{}\", local_i32));\n-LL +     println!(\"{}\", format!(\"{local_i32}\"));\n-   |\n-\n error: variables can be used directly in the `format!` string\n   --> $DIR/uninlined_format_args.rs:143:5\n    |\n@@ -856,5 +844,5 @@ LL -     println!(\"expand='{}'\", local_i32);\n LL +     println!(\"expand='{local_i32}'\");\n    |\n \n-error: aborting due to 72 previous errors\n+error: aborting due to 71 previous errors\n "}, {"sha": "2930722b42d9d4f39d33deb8119a3659b11df891", "filename": "tests/ui/unused_format_specs.fixed", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/70db22648bb1a79d2f6978adf6dc40240de59d89/tests%2Fui%2Funused_format_specs.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/70db22648bb1a79d2f6978adf6dc40240de59d89/tests%2Fui%2Funused_format_specs.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs.fixed?ref=70db22648bb1a79d2f6978adf6dc40240de59d89", "patch": "@@ -1,18 +0,0 @@\n-// run-rustfix\n-\n-#![warn(clippy::unused_format_specs)]\n-#![allow(unused)]\n-\n-fn main() {\n-    let f = 1.0f64;\n-    println!(\"{}\", 1.0);\n-    println!(\"{f} {f:?}\");\n-\n-    println!(\"{}\", 1);\n-}\n-\n-fn should_not_lint() {\n-    let f = 1.0f64;\n-    println!(\"{:.1}\", 1.0);\n-    println!(\"{f:.w$} {f:.*?}\", 3, w = 2);\n-}"}, {"sha": "ee192a000d4b55e6fd4d1a8c8ba72238cc626a4f", "filename": "tests/ui/unused_format_specs.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/70db22648bb1a79d2f6978adf6dc40240de59d89/tests%2Fui%2Funused_format_specs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70db22648bb1a79d2f6978adf6dc40240de59d89/tests%2Fui%2Funused_format_specs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs.rs?ref=70db22648bb1a79d2f6978adf6dc40240de59d89", "patch": "@@ -1,18 +0,0 @@\n-// run-rustfix\n-\n-#![warn(clippy::unused_format_specs)]\n-#![allow(unused)]\n-\n-fn main() {\n-    let f = 1.0f64;\n-    println!(\"{:.}\", 1.0);\n-    println!(\"{f:.} {f:.?}\");\n-\n-    println!(\"{:.}\", 1);\n-}\n-\n-fn should_not_lint() {\n-    let f = 1.0f64;\n-    println!(\"{:.1}\", 1.0);\n-    println!(\"{f:.w$} {f:.*?}\", 3, w = 2);\n-}"}, {"sha": "7231c17e74c19cd9de5c4c36d6c227594917f147", "filename": "tests/ui/unused_format_specs.stderr", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/70db22648bb1a79d2f6978adf6dc40240de59d89/tests%2Fui%2Funused_format_specs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70db22648bb1a79d2f6978adf6dc40240de59d89/tests%2Fui%2Funused_format_specs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs.stderr?ref=70db22648bb1a79d2f6978adf6dc40240de59d89", "patch": "@@ -1,54 +0,0 @@\n-error: empty precision specifier has no effect\n-  --> $DIR/unused_format_specs.rs:8:17\n-   |\n-LL |     println!(\"{:.}\", 1.0);\n-   |                 ^\n-   |\n-   = note: a precision specifier is not required to format floats\n-   = note: `-D clippy::unused-format-specs` implied by `-D warnings`\n-help: remove the `.`\n-   |\n-LL -     println!(\"{:.}\", 1.0);\n-LL +     println!(\"{}\", 1.0);\n-   |\n-\n-error: empty precision specifier has no effect\n-  --> $DIR/unused_format_specs.rs:9:18\n-   |\n-LL |     println!(\"{f:.} {f:.?}\");\n-   |                  ^\n-   |\n-   = note: a precision specifier is not required to format floats\n-help: remove the `.`\n-   |\n-LL -     println!(\"{f:.} {f:.?}\");\n-LL +     println!(\"{f} {f:.?}\");\n-   |\n-\n-error: empty precision specifier has no effect\n-  --> $DIR/unused_format_specs.rs:9:24\n-   |\n-LL |     println!(\"{f:.} {f:.?}\");\n-   |                        ^\n-   |\n-   = note: a precision specifier is not required to format floats\n-help: remove the `.`\n-   |\n-LL -     println!(\"{f:.} {f:.?}\");\n-LL +     println!(\"{f:.} {f:?}\");\n-   |\n-\n-error: empty precision specifier has no effect\n-  --> $DIR/unused_format_specs.rs:11:17\n-   |\n-LL |     println!(\"{:.}\", 1);\n-   |                 ^\n-   |\n-help: remove the `.`\n-   |\n-LL -     println!(\"{:.}\", 1);\n-LL +     println!(\"{}\", 1);\n-   |\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "cb7156b6baf0d8cec40121b324b0e6fa9626f258", "filename": "tests/ui/unused_format_specs_unfixable.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3259b48568c4fe19b60a47011c9fe424b707533c/tests%2Fui%2Funused_format_specs_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3259b48568c4fe19b60a47011c9fe424b707533c/tests%2Fui%2Funused_format_specs_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs_unfixable.stderr?ref=3259b48568c4fe19b60a47011c9fe424b707533c", "patch": "@@ -37,11 +37,7 @@ error: format specifiers have no effect on `format_args!()`\n LL |     println!(\"{:5}.\", format_args_from_macro!());\n    |               ^^^^\n    |\n-help: for the width to apply consider using `format!()`\n-  --> $DIR/unused_format_specs_unfixable.rs:16:17\n-   |\n-LL |     println!(\"{:5}.\", format_args_from_macro!());\n-   |                 ^\n+   = help: for the width to apply consider using `format!()`\n help: if the current behavior is intentional, remove the format specifiers\n    |\n LL -     println!(\"{:5}.\", format_args_from_macro!());\n@@ -54,11 +50,7 @@ error: format specifiers have no effect on `format_args!()`\n LL |     println!(\"{args:5}\");\n    |               ^^^^^^^^\n    |\n-help: for the width to apply consider using `format!()`\n-  --> $DIR/unused_format_specs_unfixable.rs:19:21\n-   |\n-LL |     println!(\"{args:5}\");\n-   |                     ^\n+   = help: for the width to apply consider using `format!()`\n help: if the current behavior is intentional, remove the format specifiers\n    |\n LL -     println!(\"{args:5}\");"}]}