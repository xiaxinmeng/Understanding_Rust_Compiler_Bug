{"sha": "6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhY2U4YTc2Y2I2OWJhN2Y4ZmQwYWQwNTVkZGY4NTY1OGRkY2JiZDI=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-05-05T21:35:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-05T21:35:24Z"}, "message": "Rollup merge of #41064 - Gankro:ptr-redux, r=alexcrichton\n\nrefactor NonZero, Shared, and Unique APIs\n\nMajor difference is that I removed Deref impls, as apparently LLVM has\ntrouble maintaining metadata with a `&ptr -> &ptr` API. This was cited\nas a blocker for ever stabilizing this API. It wasn't that ergonomic\nanyway.\n\n* Added `get` to NonZero to replace Deref impl\n* Added `ptr` getter to Shared/Unique to replace Deref impl\n* Added Unique's `get` and `get_mut` conveniences to Shared\n* Deprecated `as_mut_ptr` on Shared in favour of `ptr`\n\nNote that Shared used to primarily expose only `*const` but there isn't\na good justification for that, so I made it `*mut`.", "tree": {"sha": "cbc11dfc2fae55ee4d7a909ee6e5479b4739ab5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbc11dfc2fae55ee4d7a909ee6e5479b4739ab5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "html_url": "https://github.com/rust-lang/rust/commit/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "302dfd6c9d14ef9cd3140aed6ab9a65d6a0a1a51", "url": "https://api.github.com/repos/rust-lang/rust/commits/302dfd6c9d14ef9cd3140aed6ab9a65d6a0a1a51", "html_url": "https://github.com/rust-lang/rust/commit/302dfd6c9d14ef9cd3140aed6ab9a65d6a0a1a51"}, {"sha": "e8234e0e4756995dab0c095a2dfcee35908f4a3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8234e0e4756995dab0c095a2dfcee35908f4a3d", "html_url": "https://github.com/rust-lang/rust/commit/e8234e0e4756995dab0c095a2dfcee35908f4a3d"}], "stats": {"total": 475, "additions": 278, "deletions": 197}, "files": [{"sha": "6fa139b1630a9bb95dcd60cfc90aff9c19e54580", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -1 +1 @@\n-Subproject commit 616b98444ff4eb5260deee95ee3e090dfd98b947\n+Subproject commit 6fa139b1630a9bb95dcd60cfc90aff9c19e54580"}, {"sha": "6d85183faf75d9867b2f54d531b74e30973b9a07", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -277,8 +277,7 @@ impl<T> Arc<T> {\n         atomic::fence(Acquire);\n \n         unsafe {\n-            let ptr = *this.ptr;\n-            let elem = ptr::read(&(*ptr).data);\n+            let elem = ptr::read(&this.ptr.as_ref().data);\n \n             // Make a weak pointer to clean up the implicit strong-weak reference\n             let _weak = Weak { ptr: this.ptr };\n@@ -306,7 +305,7 @@ impl<T> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n-        let ptr = unsafe { &(**this.ptr).data as *const _ };\n+        let ptr: *const T = &*this;\n         mem::forget(this);\n         ptr\n     }\n@@ -345,7 +344,7 @@ impl<T> Arc<T> {\n         // `data` field from the pointer.\n         let ptr = (ptr as *const u8).offset(-offset_of!(ArcInner<T>, data));\n         Arc {\n-            ptr: Shared::new(ptr as *const _),\n+            ptr: Shared::new(ptr as *mut u8 as *mut _),\n         }\n     }\n }\n@@ -452,17 +451,17 @@ impl<T: ?Sized> Arc<T> {\n         // `ArcInner` structure itself is `Sync` because the inner data is\n         // `Sync` as well, so we're ok loaning out an immutable pointer to these\n         // contents.\n-        unsafe { &**self.ptr }\n+        unsafe { self.ptr.as_ref() }\n     }\n \n     // Non-inlined part of `drop`.\n     #[inline(never)]\n     unsafe fn drop_slow(&mut self) {\n-        let ptr = self.ptr.as_mut_ptr();\n+        let ptr = self.ptr.as_ptr();\n \n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n-        ptr::drop_in_place(&mut (*ptr).data);\n+        ptr::drop_in_place(&mut self.ptr.as_mut().data);\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n@@ -488,9 +487,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert!(!Arc::ptr_eq(&five, &other_five));\n     /// ```\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        let this_ptr: *const ArcInner<T> = *this.ptr;\n-        let other_ptr: *const ArcInner<T> = *other.ptr;\n-        this_ptr == other_ptr\n+        this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n@@ -621,7 +618,7 @@ impl<T: Clone> Arc<T> {\n                 // here (due to zeroing) because data is no longer accessed by\n                 // other threads (due to there being no more strong refs at this\n                 // point).\n-                let mut swap = Arc::new(ptr::read(&(**weak.ptr).data));\n+                let mut swap = Arc::new(ptr::read(&weak.ptr.as_ref().data));\n                 mem::swap(this, &mut swap);\n                 mem::forget(swap);\n             }\n@@ -634,8 +631,7 @@ impl<T: Clone> Arc<T> {\n         // As with `get_mut()`, the unsafety is ok because our reference was\n         // either unique to begin with, or became one upon cloning the contents.\n         unsafe {\n-            let inner = &mut *this.ptr.as_mut_ptr();\n-            &mut inner.data\n+            &mut this.ptr.as_mut().data\n         }\n     }\n }\n@@ -677,8 +673,7 @@ impl<T: ?Sized> Arc<T> {\n             // the Arc itself to be `mut`, so we're returning the only possible\n             // reference to the inner data.\n             unsafe {\n-                let inner = &mut *this.ptr.as_mut_ptr();\n-                Some(&mut inner.data)\n+                Some(&mut this.ptr.as_mut().data)\n             }\n         } else {\n             None\n@@ -878,7 +873,7 @@ impl<T: ?Sized> Weak<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // See comments above for why this is \"safe\"\n-        unsafe { &**self.ptr }\n+        unsafe { self.ptr.as_ref() }\n     }\n }\n \n@@ -962,7 +957,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n-        let ptr = *self.ptr;\n+        let ptr = self.ptr.as_ptr();\n \n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about\n@@ -1143,7 +1138,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.ptr, f)\n+        fmt::Pointer::fmt(&self.ptr, f)\n     }\n }\n "}, {"sha": "fc6929f896ecbaa70870751f9c59007cc1024983", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -156,7 +156,7 @@ fn make_place<T>() -> IntermediateBox<T> {\n     let align = mem::align_of::<T>();\n \n     let p = if size == 0 {\n-        heap::EMPTY as *mut u8\n+        mem::align_of::<T>() as *mut u8\n     } else {\n         let p = unsafe { heap::allocate(size, align) };\n         if p.is_null() {"}, {"sha": "5ff21c86483c80cbbef1ef02fe516cc425b5dab6", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -138,7 +138,9 @@ pub fn usable_size(size: usize, align: usize) -> usize {\n ///\n /// This preserves the non-null invariant for types like `Box<T>`. The address\n /// may overlap with non-zero-size memory allocations.\n-pub const EMPTY: *mut () = 0x1 as *mut ();\n+#[rustc_deprecated(since = \"1.19\", reason = \"Use Unique/Shared::empty() instead\")]\n+#[unstable(feature = \"heap_api\", issue = \"27700\")]\n+pub const EMPTY: *mut () = 1 as *mut ();\n \n /// The allocator for unique pointers.\n // This function must not unwind. If it does, MIR trans will fail.\n@@ -147,7 +149,7 @@ pub const EMPTY: *mut () = 0x1 as *mut ();\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     if size == 0 {\n-        EMPTY as *mut u8\n+        align as *mut u8\n     } else {\n         let ptr = allocate(size, align);\n         if ptr.is_null() {"}, {"sha": "7edf07944ec50c812aead220f6e66b4c69402b6a", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -22,13 +22,13 @@ use core::cmp;\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n /// In particular:\n ///\n-/// * Produces heap::EMPTY on zero-sized types\n-/// * Produces heap::EMPTY on zero-length allocations\n+/// * Produces Unique::empty() on zero-sized types\n+/// * Produces Unique::empty() on zero-length allocations\n /// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics)\n /// * Guards against 32-bit systems allocating more than isize::MAX bytes\n /// * Guards against overflowing your length\n /// * Aborts on OOM\n-/// * Avoids freeing heap::EMPTY\n+/// * Avoids freeing Unique::empty()\n /// * Contains a ptr::Unique and thus endows the user with all related benefits\n ///\n /// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n@@ -55,15 +55,13 @@ impl<T> RawVec<T> {\n     /// it makes a RawVec with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub fn new() -> Self {\n-        unsafe {\n-            // !0 is usize::MAX. This branch should be stripped at compile time.\n-            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+        // !0 is usize::MAX. This branch should be stripped at compile time.\n+        let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n \n-            // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n-            RawVec {\n-                ptr: Unique::new(heap::EMPTY as *mut T),\n-                cap: cap,\n-            }\n+        // Unique::empty() doubles as \"unallocated\" and \"zero-sized allocation\"\n+        RawVec {\n+            ptr: Unique::empty(),\n+            cap: cap,\n         }\n     }\n \n@@ -101,7 +99,7 @@ impl<T> RawVec<T> {\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n-                heap::EMPTY as *mut u8\n+                mem::align_of::<T>() as *mut u8\n             } else {\n                 let align = mem::align_of::<T>();\n                 let ptr = if zeroed {\n@@ -148,10 +146,10 @@ impl<T> RawVec<T> {\n \n impl<T> RawVec<T> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// heap::EMPTY if `cap = 0` or T is zero-sized. In the former case, you must\n+    /// Unique::empty() if `cap = 0` or T is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n-        *self.ptr\n+        self.ptr.as_ptr()\n     }\n \n     /// Gets the capacity of the allocation.\n@@ -563,7 +561,7 @@ unsafe impl<#[may_dangle] T> Drop for RawVec<T> {\n \n             let num_bytes = elem_size * self.cap;\n             unsafe {\n-                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n+                heap::deallocate(self.ptr() as *mut u8, num_bytes, align);\n             }\n         }\n     }"}, {"sha": "d6dbf77bfac770466ff3dfb8de43e83397d217fd", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -230,7 +230,7 @@ use core::cell::Cell;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::intrinsics::{abort, assume};\n+use core::intrinsics::abort;\n use core::marker;\n use core::marker::Unsize;\n use core::mem::{self, align_of_val, forget, size_of, size_of_val, uninitialized};\n@@ -358,7 +358,7 @@ impl<T> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n-        let ptr = unsafe { &mut (*this.ptr.as_mut_ptr()).value as *const _ };\n+        let ptr: *const T = &*this;\n         mem::forget(this);\n         ptr\n     }\n@@ -395,7 +395,11 @@ impl<T> Rc<T> {\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         // To find the corresponding pointer to the `RcBox` we need to subtract the offset of the\n         // `value` field from the pointer.\n-        Rc { ptr: Shared::new((ptr as *const u8).offset(-offset_of!(RcBox<T>, value)) as *const _) }\n+\n+        let ptr = (ptr as *const u8).offset(-offset_of!(RcBox<T>, value));\n+        Rc {\n+            ptr: Shared::new(ptr as *mut u8 as *mut _)\n+        }\n     }\n }\n \n@@ -451,7 +455,7 @@ impl<T> Rc<[T]> {\n             // Free the original allocation without freeing its (moved) contents.\n             box_free(Box::into_raw(value));\n \n-            Rc { ptr: Shared::new(ptr as *const _) }\n+            Rc { ptr: Shared::new(ptr as *mut _) }\n         }\n     }\n }\n@@ -553,8 +557,9 @@ impl<T: ?Sized> Rc<T> {\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if Rc::is_unique(this) {\n-            let inner = unsafe { &mut *this.ptr.as_mut_ptr() };\n-            Some(&mut inner.value)\n+            unsafe {\n+                Some(&mut this.ptr.as_mut().value)\n+            }\n         } else {\n             None\n         }\n@@ -578,9 +583,7 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(!Rc::ptr_eq(&five, &other_five));\n     /// ```\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        let this_ptr: *const RcBox<T> = *this.ptr;\n-        let other_ptr: *const RcBox<T> = *other.ptr;\n-        this_ptr == other_ptr\n+        this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n@@ -623,7 +626,7 @@ impl<T: Clone> Rc<T> {\n         } else if Rc::weak_count(this) != 0 {\n             // Can just steal the data, all that's left is Weaks\n             unsafe {\n-                let mut swap = Rc::new(ptr::read(&(**this.ptr).value));\n+                let mut swap = Rc::new(ptr::read(&this.ptr.as_ref().value));\n                 mem::swap(this, &mut swap);\n                 swap.dec_strong();\n                 // Remove implicit strong-weak ref (no need to craft a fake\n@@ -637,8 +640,9 @@ impl<T: Clone> Rc<T> {\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n         // reference to the inner value.\n-        let inner = unsafe { &mut *this.ptr.as_mut_ptr() };\n-        &mut inner.value\n+        unsafe {\n+            &mut this.ptr.as_mut().value\n+        }\n     }\n }\n \n@@ -683,12 +687,12 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = self.ptr.as_mut_ptr();\n+            let ptr = self.ptr.as_ptr();\n \n             self.dec_strong();\n             if self.strong() == 0 {\n                 // destroy the contained object\n-                ptr::drop_in_place(&mut (*ptr).value);\n+                ptr::drop_in_place(self.ptr.as_mut());\n \n                 // remove the implicit \"strong weak\" pointer now that we've\n                 // destroyed the contents.\n@@ -925,7 +929,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Rc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.ptr, f)\n+        fmt::Pointer::fmt(&self.ptr, f)\n     }\n }\n \n@@ -1067,7 +1071,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = *self.ptr;\n+            let ptr = self.ptr.as_ptr();\n \n             self.dec_weak();\n             // the weak count starts at 1, and will only go to zero if all\n@@ -1175,12 +1179,7 @@ impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n         unsafe {\n-            // Safe to assume this here, as if it weren't true, we'd be breaking\n-            // the contract anyway.\n-            // This allows the null check to be elided in the destructor if we\n-            // manipulated the reference count in the same function.\n-            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n-            &(**self.ptr)\n+            self.ptr.as_ref()\n         }\n     }\n }\n@@ -1189,12 +1188,7 @@ impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n         unsafe {\n-            // Safe to assume this here, as if it weren't true, we'd be breaking\n-            // the contract anyway.\n-            // This allows the null check to be elided in the destructor if we\n-            // manipulated the reference count in the same function.\n-            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n-            &(**self.ptr)\n+            self.ptr.as_ref()\n         }\n     }\n }"}, {"sha": "321fa2edd56c7717e9bb2aaa243392d175b5feb1", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -31,7 +31,6 @@\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![feature(heap_api)]\n #![feature(generic_param_attrs)]\n #![feature(staged_api)]\n #![cfg_attr(test, feature(test))]\n@@ -48,7 +47,6 @@ use std::mem;\n use std::ptr;\n use std::slice;\n \n-use alloc::heap;\n use alloc::raw_vec::RawVec;\n \n /// An arena that can hold objects of only one type.\n@@ -140,7 +138,7 @@ impl<T> TypedArena<T> {\n         unsafe {\n             if mem::size_of::<T>() == 0 {\n                 self.ptr.set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1) as *mut T);\n-                let ptr = heap::EMPTY as *mut T;\n+                let ptr = mem::align_of::<T>() as *mut T;\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);\n                 &mut *ptr"}, {"sha": "52cdd39d8f963c0666bcc26ba71765ad977c6917", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -152,12 +152,12 @@ impl<K, V> BoxedNode<K, V> {\n     }\n \n     unsafe fn from_ptr(ptr: NonZero<*const LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::new(*ptr as *mut LeafNode<K, V>) }\n+        BoxedNode { ptr: Unique::new(ptr.get() as *mut LeafNode<K, V>) }\n     }\n \n     fn as_ptr(&self) -> NonZero<*const LeafNode<K, V>> {\n         unsafe {\n-            NonZero::new(*self.ptr as *const LeafNode<K, V>)\n+            NonZero::new(self.ptr.as_ptr())\n         }\n     }\n }\n@@ -241,7 +241,7 @@ impl<K, V> Root<K, V> {\n     pub fn pop_level(&mut self) {\n         debug_assert!(self.height > 0);\n \n-        let top = *self.node.ptr as *mut u8;\n+        let top = self.node.ptr.as_ptr() as *mut u8;\n \n         self.node = unsafe {\n             BoxedNode::from_ptr(self.as_mut()\n@@ -308,15 +308,15 @@ unsafe impl<K: Send, V: Send, Type> Send\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     fn as_internal(&self) -> &InternalNode<K, V> {\n         unsafe {\n-            &*(*self.node as *const InternalNode<K, V>)\n+            &*(self.node.get() as *const InternalNode<K, V>)\n         }\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n         unsafe {\n-            &mut *(*self.node as *mut InternalNode<K, V>)\n+            &mut *(self.node.get() as *mut InternalNode<K, V>)\n         }\n     }\n }\n@@ -358,7 +358,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n \n     fn as_leaf(&self) -> &LeafNode<K, V> {\n         unsafe {\n-            &**self.node\n+            &*self.node.get()\n         }\n     }\n \n@@ -510,7 +510,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n     fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n         unsafe {\n-            &mut *(*self.node as *mut LeafNode<K, V>)\n+            &mut *(self.node.get() as *mut LeafNode<K, V>)\n         }\n     }\n \n@@ -1253,13 +1253,13 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 }\n \n                 heap::deallocate(\n-                    *right_node.node as *mut u8,\n+                    right_node.node.get() as *mut u8,\n                     mem::size_of::<InternalNode<K, V>>(),\n                     mem::align_of::<InternalNode<K, V>>()\n                 );\n             } else {\n                 heap::deallocate(\n-                    *right_node.node as *mut u8,\n+                    right_node.node.get() as *mut u8,\n                     mem::size_of::<LeafNode<K, V>>(),\n                     mem::align_of::<LeafNode<K, V>>()\n                 );"}, {"sha": "ae258083546f4fddcb52cbeb22920527de8f66a9", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -161,7 +161,7 @@ impl<T> LinkedList<T> {\n \n             match self.head {\n                 None => self.tail = node,\n-                Some(head) => (*head.as_mut_ptr()).prev = node,\n+                Some(mut head) => head.as_mut().prev = node,\n             }\n \n             self.head = node;\n@@ -173,12 +173,12 @@ impl<T> LinkedList<T> {\n     #[inline]\n     fn pop_front_node(&mut self) -> Option<Box<Node<T>>> {\n         self.head.map(|node| unsafe {\n-            let node = Box::from_raw(node.as_mut_ptr());\n+            let node = Box::from_raw(node.as_ptr());\n             self.head = node.next;\n \n             match self.head {\n                 None => self.tail = None,\n-                Some(head) => (*head.as_mut_ptr()).prev = None,\n+                Some(mut head) => head.as_mut().prev = None,\n             }\n \n             self.len -= 1;\n@@ -196,7 +196,7 @@ impl<T> LinkedList<T> {\n \n             match self.tail {\n                 None => self.head = node,\n-                Some(tail) => (*tail.as_mut_ptr()).next = node,\n+                Some(mut tail) => tail.as_mut().next = node,\n             }\n \n             self.tail = node;\n@@ -208,12 +208,12 @@ impl<T> LinkedList<T> {\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n         self.tail.map(|node| unsafe {\n-            let node = Box::from_raw(node.as_mut_ptr());\n+            let node = Box::from_raw(node.as_ptr());\n             self.tail = node.prev;\n \n             match self.tail {\n                 None => self.head = None,\n-                Some(tail) => (*tail.as_mut_ptr()).next = None,\n+                Some(mut tail) => tail.as_mut().next = None,\n             }\n \n             self.len -= 1;\n@@ -285,11 +285,11 @@ impl<T> LinkedList<T> {\n     pub fn append(&mut self, other: &mut Self) {\n         match self.tail {\n             None => mem::swap(self, other),\n-            Some(tail) => {\n-                if let Some(other_head) = other.head.take() {\n+            Some(mut tail) => {\n+                if let Some(mut other_head) = other.head.take() {\n                     unsafe {\n-                        (*tail.as_mut_ptr()).next = Some(other_head);\n-                        (*other_head.as_mut_ptr()).prev = Some(tail);\n+                        tail.as_mut().next = Some(other_head);\n+                        other_head.as_mut().prev = Some(tail);\n                     }\n \n                     self.tail = other.tail.take();\n@@ -477,7 +477,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n-        self.head.map(|node| unsafe { &(**node).element })\n+        unsafe {\n+            self.head.as_ref().map(|node| &node.as_ref().element)\n+        }\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n@@ -503,7 +505,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n-        self.head.map(|node| unsafe { &mut (*node.as_mut_ptr()).element })\n+        unsafe {\n+            self.head.as_mut().map(|node| &mut node.as_mut().element)\n+        }\n     }\n \n     /// Provides a reference to the back element, or `None` if the list is\n@@ -523,7 +527,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        self.tail.map(|node| unsafe { &(**node).element })\n+        unsafe {\n+            self.tail.as_ref().map(|node| &node.as_ref().element)\n+        }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n@@ -549,7 +555,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        self.tail.map(|node| unsafe { &mut (*node.as_mut_ptr()).element })\n+        unsafe {\n+            self.tail.as_mut().map(|node| &mut node.as_mut().element)\n+        }\n     }\n \n     /// Adds an element first in the list.\n@@ -694,9 +702,9 @@ impl<T> LinkedList<T> {\n         let second_part_head;\n \n         unsafe {\n-            second_part_head = (*split_node.unwrap().as_mut_ptr()).next.take();\n-            if let Some(head) = second_part_head {\n-                (*head.as_mut_ptr()).prev = None;\n+            second_part_head = split_node.unwrap().as_mut().next.take();\n+            if let Some(mut head) = second_part_head {\n+                head.as_mut().prev = None;\n             }\n         }\n \n@@ -788,7 +796,8 @@ impl<'a, T> Iterator for Iter<'a, T> {\n             None\n         } else {\n             self.head.map(|node| unsafe {\n-                let node = &**node;\n+                // Need an unbound lifetime to get 'a\n+                let node = &*node.as_ptr();\n                 self.len -= 1;\n                 self.head = node.next;\n                 &node.element\n@@ -810,7 +819,8 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n             None\n         } else {\n             self.tail.map(|node| unsafe {\n-                let node = &**node;\n+                // Need an unbound lifetime to get 'a\n+                let node = &*node.as_ptr();\n                 self.len -= 1;\n                 self.tail = node.prev;\n                 &node.element\n@@ -835,7 +845,8 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n             None\n         } else {\n             self.head.map(|node| unsafe {\n-                let node = &mut *node.as_mut_ptr();\n+                // Need an unbound lifetime to get 'a\n+                let node = &mut *node.as_ptr();\n                 self.len -= 1;\n                 self.head = node.next;\n                 &mut node.element\n@@ -857,7 +868,8 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n             None\n         } else {\n             self.tail.map(|node| unsafe {\n-                let node = &mut *node.as_mut_ptr();\n+                // Need an unbound lifetime to get 'a\n+                let node = &mut *node.as_ptr();\n                 self.len -= 1;\n                 self.tail = node.prev;\n                 &mut node.element\n@@ -903,8 +915,8 @@ impl<'a, T> IterMut<'a, T> {\n     pub fn insert_next(&mut self, element: T) {\n         match self.head {\n             None => self.list.push_back(element),\n-            Some(head) => unsafe {\n-                let prev = match (**head).prev {\n+            Some(mut head) => unsafe {\n+                let mut prev = match head.as_ref().prev {\n                     None => return self.list.push_front(element),\n                     Some(prev) => prev,\n                 };\n@@ -915,8 +927,8 @@ impl<'a, T> IterMut<'a, T> {\n                     element: element,\n                 })));\n \n-                (*prev.as_mut_ptr()).next = node;\n-                (*head.as_mut_ptr()).prev = node;\n+                prev.as_mut().next = node;\n+                head.as_mut().prev = node;\n \n                 self.list.len += 1;\n             },\n@@ -948,7 +960,9 @@ impl<'a, T> IterMut<'a, T> {\n         if self.len == 0 {\n             None\n         } else {\n-            self.head.map(|node| unsafe { &mut (*node.as_mut_ptr()).element })\n+            unsafe {\n+                self.head.as_mut().map(|node| &mut node.as_mut().element)\n+            }\n         }\n     }\n }\n@@ -1276,21 +1290,21 @@ mod tests {\n                     assert_eq!(0, list.len);\n                     return;\n                 }\n-                Some(node) => node_ptr = &**node,\n+                Some(node) => node_ptr = &*node.as_ptr(),\n             }\n             loop {\n                 match (last_ptr, node_ptr.prev) {\n                     (None, None) => {}\n                     (None, _) => panic!(\"prev link for head\"),\n                     (Some(p), Some(pptr)) => {\n-                        assert_eq!(p as *const Node<T>, *pptr as *const Node<T>);\n+                        assert_eq!(p as *const Node<T>, pptr.as_ptr() as *const Node<T>);\n                     }\n                     _ => panic!(\"prev link is none, not good\"),\n                 }\n                 match node_ptr.next {\n                     Some(next) => {\n                         last_ptr = Some(node_ptr);\n-                        node_ptr = &**next;\n+                        node_ptr = &*next.as_ptr();\n                         len += 1;\n                     }\n                     None => {"}, {"sha": "7ec5c29de6b4be49918d8bc5678f51a0ef665d29", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -67,7 +67,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n-use alloc::heap::EMPTY;\n use alloc::raw_vec::RawVec;\n use borrow::ToOwned;\n use borrow::Cow;\n@@ -1776,9 +1775,9 @@ impl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n         // A common case is passing a vector into a function which immediately\n         // re-collects into a vector. We can short circuit this if the IntoIter\n         // has not been advanced at all.\n-        if *iterator.buf == iterator.ptr as *mut T {\n+        if iterator.buf.as_ptr() as *const _ == iterator.ptr {\n             unsafe {\n-                let vec = Vec::from_raw_parts(*iterator.buf as *mut T,\n+                let vec = Vec::from_raw_parts(iterator.buf.as_ptr(),\n                                               iterator.len(),\n                                               iterator.cap);\n                 mem::forget(iterator);\n@@ -2192,7 +2191,8 @@ impl<T> Iterator for IntoIter<T> {\n                     self.ptr = arith_offset(self.ptr as *const i8, 1) as *mut T;\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n+                    // (self.ptr might be null because of wrapping)\n+                    Some(ptr::read(1 as *mut T))\n                 } else {\n                     let old = self.ptr;\n                     self.ptr = self.ptr.offset(1);\n@@ -2231,7 +2231,8 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n                     self.end = arith_offset(self.end as *const i8, -1) as *mut T;\n \n                     // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n+                    // (self.end might be null because of wrapping)\n+                    Some(ptr::read(1 as *mut T))\n                 } else {\n                     self.end = self.end.offset(-1);\n \n@@ -2269,7 +2270,7 @@ unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n         for _x in self.by_ref() {}\n \n         // RawVec handles deallocation\n-        let _ = unsafe { RawVec::from_raw_parts(self.buf.as_mut_ptr(), self.cap) };\n+        let _ = unsafe { RawVec::from_raw_parts(self.buf.as_ptr(), self.cap) };\n     }\n }\n \n@@ -2334,7 +2335,7 @@ impl<'a, T> Drop for Drain<'a, T> {\n \n         if self.tail_len > 0 {\n             unsafe {\n-                let source_vec = &mut *self.vec.as_mut_ptr();\n+                let source_vec = self.vec.as_mut();\n                 // memmove back untouched tail, update to new length\n                 let start = source_vec.len();\n                 let tail = self.tail_start;\n@@ -2456,8 +2457,7 @@ impl<'a, I: Iterator> Drop for Splice<'a, I> {\n \n         unsafe {\n             if self.drain.tail_len == 0 {\n-                let vec = &mut *self.drain.vec.as_mut_ptr();\n-                vec.extend(self.replace_with.by_ref());\n+                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n                 return\n             }\n \n@@ -2498,7 +2498,7 @@ impl<'a, T> Drain<'a, T> {\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n     /// Return whether we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n     unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n-        let vec = &mut *self.vec.as_mut_ptr();\n+        let vec = self.vec.as_mut();\n         let range_start = vec.len;\n         let range_end = self.tail_start;\n         let range_slice = slice::from_raw_parts_mut(\n@@ -2518,7 +2518,7 @@ impl<'a, T> Drain<'a, T> {\n \n     /// Make room for inserting more elements before the tail.\n     unsafe fn move_tail(&mut self, extra_capacity: usize) {\n-        let vec = &mut *self.vec.as_mut_ptr();\n+        let vec = self.vec.as_mut();\n         let used_capacity = self.tail_start + self.tail_len;\n         vec.buf.reserve(used_capacity, extra_capacity);\n "}, {"sha": "e826c9432b516133663c57c94a5624d7bd41fb0f", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -2160,7 +2160,7 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         for _ in self.by_ref() {}\n \n-        let source_deque = unsafe { &mut *self.deque.as_mut_ptr() };\n+        let source_deque = unsafe { self.deque.as_mut() };\n \n         // T = source_deque_tail; H = source_deque_head; t = drain_tail; h = drain_head\n         //"}, {"sha": "7886f90b66e85b64baa56590c174d0ba199fb8f0", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -132,7 +132,6 @@\n //! use std::cell::Cell;\n //! use std::ptr::Shared;\n //! use std::intrinsics::abort;\n-//! use std::intrinsics::assume;\n //!\n //! struct Rc<T: ?Sized> {\n //!     ptr: Shared<RcBox<T>>\n@@ -171,8 +170,7 @@\n //! impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n //!    fn inner(&self) -> &RcBox<T> {\n //!        unsafe {\n-//!            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n-//!            &(**self.ptr)\n+//!            self.ptr.as_ref()\n //!        }\n //!    }\n //! }"}, {"sha": "d93085e96dbb2833910a6df764430669bc8a40d1", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -13,7 +13,7 @@\n             reason = \"needs an RFC to flesh out the design\",\n             issue = \"27730\")]\n \n-use ops::{CoerceUnsized, Deref};\n+use ops::CoerceUnsized;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n pub unsafe trait Zeroable {}\n@@ -46,15 +46,10 @@ impl<T: Zeroable> NonZero<T> {\n     pub const unsafe fn new(inner: T) -> NonZero<T> {\n         NonZero(inner)\n     }\n-}\n-\n-impl<T: Zeroable> Deref for NonZero<T> {\n-    type Target = T;\n \n-    #[inline]\n-    fn deref(&self) -> &T {\n-        let NonZero(ref inner) = *self;\n-        inner\n+    /// Gets the inner value.\n+    pub fn get(self) -> T {\n+        self.0\n     }\n }\n "}, {"sha": "a60abefc076504027bdc99141b9add789bda7060", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 127, "deletions": 44, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -17,7 +17,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use intrinsics;\n-use ops::{CoerceUnsized, Deref};\n+use ops::CoerceUnsized;\n use fmt;\n use hash;\n use marker::{PhantomData, Unsize};\n@@ -957,13 +957,25 @@ impl<T: ?Sized> PartialOrd for *mut T {\n }\n \n /// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n-/// of this wrapper owns the referent. This in turn implies that the\n-/// `Unique<T>` is `Send`/`Sync` if `T` is `Send`/`Sync`, unlike a raw\n-/// `*mut T` (which conveys no particular ownership semantics).  It\n-/// also implies that the referent of the pointer should not be\n-/// modified without a unique path to the `Unique` reference. Useful\n-/// for building abstractions like `Vec<T>` or `Box<T>`, which\n-/// internally use raw pointers to manage the memory that they own.\n+/// of this wrapper owns the referent. Useful for building abstractions like\n+/// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n+///\n+/// Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n+/// It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n+/// the kind of strong aliasing guarantees an instance of `T` can expect:\n+/// the referent of the pointer should not be modified without a unique path to\n+/// its owning Unique.\n+///\n+/// If you're uncertain of whether it's correct to use `Unique` for your purposes,\n+/// consider using `Shared`, which has weaker semantics.\n+///\n+/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n+/// is never dereferenced. This is so that enums may use this forbidden value\n+/// as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n+/// However the pointer may still dangle if it isn't dereferenced.\n+///\n+/// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n+/// for any type which upholds Unique's aliasing requirements.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n            issue = \"27730\")]\n@@ -991,6 +1003,20 @@ unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n #[unstable(feature = \"unique\", issue = \"27730\")]\n unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n+#[unstable(feature = \"unique\", issue = \"27730\")]\n+impl<T: Sized> Unique<T> {\n+    /// Creates a new `Shared` that is dangling, but well-aligned.\n+    ///\n+    /// This is useful for initializing types which lazily allocate, like\n+    /// `Vec::new` does.\n+    pub fn empty() -> Self {\n+        unsafe {\n+            let ptr = mem::align_of::<T>() as *mut T;\n+            Unique::new(ptr)\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"unique\", issue = \"27730\")]\n impl<T: ?Sized> Unique<T> {\n     /// Creates a new `Unique`.\n@@ -1002,41 +1028,72 @@ impl<T: ?Sized> Unique<T> {\n         Unique { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n \n+    /// Acquires the underlying `*mut` pointer.\n+    pub fn as_ptr(self) -> *mut T {\n+        self.pointer.get() as *mut T\n+    }\n+\n     /// Dereferences the content.\n-    pub unsafe fn get(&self) -> &T {\n-        &**self.pointer\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&*my_ptr.ptr()`.\n+    pub unsafe fn as_ref(&self) -> &T {\n+        &*self.as_ptr()\n     }\n \n     /// Mutably dereferences the content.\n-    pub unsafe fn get_mut(&mut self) -> &mut T {\n-        &mut ***self\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.ptr()`.\n+    pub unsafe fn as_mut(&mut self) -> &mut T {\n+        &mut *self.as_ptr()\n     }\n }\n \n-#[unstable(feature = \"unique\", issue = \"27730\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n-\n-#[unstable(feature = \"unique\", issue= \"27730\")]\n-impl<T:?Sized> Deref for Unique<T> {\n-    type Target = *mut T;\n-\n-    #[inline]\n-    fn deref(&self) -> &*mut T {\n-        unsafe { mem::transmute(&*self.pointer) }\n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: ?Sized> Clone for Unique<T> {\n+    fn clone(&self) -> Self {\n+        *self\n     }\n }\n \n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: ?Sized> Copy for Unique<T> { }\n+\n+#[unstable(feature = \"unique\", issue = \"27730\")]\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+\n #[unstable(feature = \"unique\", issue = \"27730\")]\n-impl<T> fmt::Pointer for Unique<T> {\n+impl<T: ?Sized> fmt::Pointer for Unique<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.pointer, f)\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n     }\n }\n \n-/// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n+/// A wrapper around a raw `*mut T` that indicates that the possessor\n /// of this wrapper has shared ownership of the referent. Useful for\n-/// building abstractions like `Rc<T>` or `Arc<T>`, which internally\n-/// use raw pointers to manage the memory that they own.\n+/// building abstractions like `Rc<T>`, `Arc<T>`, or doubly-linked lists, which\n+/// internally use aliased raw pointers to manage the memory that they own.\n+///\n+/// This is similar to `Unique`, except that it doesn't make any aliasing\n+/// guarantees, and doesn't derive Send and Sync. Note that unlike `&T`,\n+/// Shared has no special mutability requirements. Shared may mutate data\n+/// aliased by other Shared pointers. More precise rules require Rust to\n+/// develop an actual aliasing model.\n+///\n+/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n+/// is never dereferenced. This is so that enums may use this forbidden value\n+/// as a discriminant -- `Option<Shared<T>>` has the same size as `Shared<T>`.\n+/// However the pointer may still dangle if it isn't dereferenced.\n+///\n+/// Unlike `*mut T`, `Shared<T>` is covariant over `T`. If this is incorrect\n+/// for your use case, you should include some PhantomData in your type to\n+/// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n+/// Usually this won't be necessary; covariance is correct for Rc, Arc, and LinkedList\n+/// because they provide a public API that follows the normal shared XOR mutable\n+/// rules of Rust.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"shared\", reason = \"needs an RFC to flesh out design\",\n            issue = \"27730\")]\n@@ -1060,23 +1117,59 @@ impl<T: ?Sized> !Send for Shared<T> { }\n #[unstable(feature = \"shared\", issue = \"27730\")]\n impl<T: ?Sized> !Sync for Shared<T> { }\n \n+#[unstable(feature = \"shared\", issue = \"27730\")]\n+impl<T: Sized> Shared<T> {\n+    /// Creates a new `Shared` that is dangling, but well-aligned.\n+    ///\n+    /// This is useful for initializing types which lazily allocate, like\n+    /// `Vec::new` does.\n+    pub fn empty() -> Self {\n+        unsafe {\n+            let ptr = mem::align_of::<T>() as *mut T;\n+            Shared::new(ptr)\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"shared\", issue = \"27730\")]\n impl<T: ?Sized> Shared<T> {\n     /// Creates a new `Shared`.\n     ///\n     /// # Safety\n     ///\n     /// `ptr` must be non-null.\n-    pub unsafe fn new(ptr: *const T) -> Self {\n+    pub unsafe fn new(ptr: *mut T) -> Self {\n         Shared { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n-}\n \n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> Shared<T> {\n+    /// Acquires the underlying `*mut` pointer.\n+    pub fn as_ptr(self) -> *mut T {\n+        self.pointer.get() as *mut T\n+    }\n+\n+    /// Dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&*my_ptr.ptr()`.\n+    pub unsafe fn as_ref(&self) -> &T {\n+        &*self.as_ptr()\n+    }\n+\n+    /// Mutably dereferences the content.\n+    ///\n+    /// The resulting lifetime is bound to self so this behaves \"as if\"\n+    /// it were actually an instance of T that is getting borrowed. If a longer\n+    /// (unbound) lifetime is needed, use `&mut *my_ptr.ptr_mut()`.\n+    pub unsafe fn as_mut(&mut self) -> &mut T {\n+        &mut *self.as_ptr()\n+    }\n+\n     /// Acquires the underlying pointer as a `*mut` pointer.\n+    #[rustc_deprecated(since = \"1.19\", reason = \"renamed to `as_ptr` for ergonomics/consistency\")]\n+    #[unstable(feature = \"shared\", issue = \"27730\")]\n     pub unsafe fn as_mut_ptr(&self) -> *mut T {\n-        **self as _\n+        self.as_ptr()\n     }\n }\n \n@@ -1094,18 +1187,8 @@ impl<T: ?Sized> Copy for Shared<T> { }\n impl<T: ?Sized, U: ?Sized> CoerceUnsized<Shared<U>> for Shared<T> where T: Unsize<U> { }\n \n #[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T: ?Sized> Deref for Shared<T> {\n-    type Target = *const T;\n-\n-    #[inline]\n-    fn deref(&self) -> &*const T {\n-        unsafe { mem::transmute(&*self.pointer) }\n-    }\n-}\n-\n-#[unstable(feature = \"shared\", issue = \"27730\")]\n-impl<T> fmt::Pointer for Shared<T> {\n+impl<T: ?Sized> fmt::Pointer for Shared<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.pointer, f)\n+        fmt::Pointer::fmt(&self.as_ptr(), f)\n     }\n }"}, {"sha": "588fffda35fca3dc20158d2b48dff128fcd21d2a", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -31,12 +31,12 @@ fn test_match_on_nonzero_option() {\n         NonZero::new(42)\n     });\n     match a {\n-        Some(val) => assert_eq!(*val, 42),\n+        Some(val) => assert_eq!(val.get(), 42),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }\n \n     match unsafe { Some(NonZero::new(43)) } {\n-        Some(val) => assert_eq!(*val, 43),\n+        Some(val) => assert_eq!(val.get(), 43),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }\n }"}, {"sha": "e28dc6a6881fde06acd2fc3a3b97269643b0b020", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -166,10 +166,10 @@ fn test_set_memory() {\n \n #[test]\n fn test_unsized_unique() {\n-    let xs: &mut [i32] = &mut [1, 2, 3];\n-    let ptr = unsafe { Unique::new(xs as *mut [i32]) };\n-    let ys = unsafe { &mut **ptr };\n-    let zs: &mut [i32] = &mut [1, 2, 3];\n+    let xs: &[i32] = &[1, 2, 3];\n+    let ptr = unsafe { Unique::new(xs as *const [i32] as *mut [i32]) };\n+    let ys = unsafe { ptr.as_ref() };\n+    let zs: &[i32] = &[1, 2, 3];\n     assert!(ys == zs);\n }\n "}, {"sha": "3619be82829cade3559577dd57a0f9fe71da2d52", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -62,14 +62,14 @@ pub struct Bytes {\n impl Deref for Bytes {\n     type Target = [u8];\n     fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(*self.ptr, self.len) }\n+        unsafe { slice::from_raw_parts(self.ptr.as_ptr(), self.len) }\n     }\n }\n \n impl Drop for Bytes {\n     fn drop(&mut self) {\n         unsafe {\n-            libc::free(*self.ptr as *mut _);\n+            libc::free(self.ptr.as_ptr() as *mut _);\n         }\n     }\n }"}, {"sha": "c9ffcee51c20ad1e346b54109a98949c174d8112", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> From<ty::Region<'tcx>> for Kind<'tcx> {\n impl<'tcx> Kind<'tcx> {\n     #[inline]\n     unsafe fn downcast<T>(self, tag: usize) -> Option<&'tcx T> {\n-        let ptr = *self.ptr;\n+        let ptr = self.ptr.get();\n         if ptr & TAG_MASK == tag {\n             Some(&*((ptr & !TAG_MASK) as *const _))\n         } else {\n@@ -102,7 +102,7 @@ impl<'tcx> fmt::Debug for Kind<'tcx> {\n         } else if let Some(r) = self.as_region() {\n             write!(f, \"{:?}\", r)\n         } else {\n-            write!(f, \"<unknwon @ {:p}>\", *self.ptr as *const ())\n+            write!(f, \"<unknwon @ {:p}>\", self.ptr.get() as *const ())\n         }\n     }\n }"}, {"sha": "ed5e539f245f10fb2280d4821e8bf39f38166796", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -43,7 +43,7 @@ mod indexes {\n                     unsafe { $Index(NonZero::new(idx + 1)) }\n                 }\n                 fn index(self) -> usize {\n-                    *self.0 - 1\n+                    self.0.get() - 1\n                 }\n             }\n "}, {"sha": "078bb801751d0b2bf4bd54d43a2c4f8944888ed1", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -255,7 +255,7 @@ impl<'a, A: Array> Drop for Drain<'a, A> {\n \n         if self.tail_len > 0 {\n             unsafe {\n-                let source_array_vec = &mut *self.array_vec.as_mut_ptr();\n+                let source_array_vec = self.array_vec.as_mut();\n                 // memmove back untouched tail, update to new length\n                 let start = source_array_vec.len();\n                 let tail = self.tail_start;"}, {"sha": "023c56ca59be8fcfd97e4b9fd31d9e4dcb07401e", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -23,6 +23,6 @@ impl NodeIndex {\n     }\n \n     pub fn get(self) -> usize {\n-        (*self.index - 1) as usize\n+        (self.index.get() - 1) as usize\n     }\n }"}, {"sha": "a15269cc87c5da08f9e0acd973f628ba83240bda", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=6ace8a76cb69ba7f8fd0ad055ddf85658ddcbbd2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::heap::{EMPTY, allocate, deallocate};\n+use alloc::heap::{allocate, deallocate};\n \n use cmp;\n use hash::{BuildHasher, Hash, Hasher};\n@@ -33,6 +33,7 @@ use self::BucketState::*;\n type HashUint = usize;\n \n const EMPTY_BUCKET: HashUint = 0;\n+const EMPTY: usize = 1;\n \n /// Special `Unique<HashUint>` that uses the lower bit of the pointer\n /// to expose a boolean tag.\n@@ -49,24 +50,25 @@ impl TaggedHashUintPtr {\n \n     #[inline]\n     fn set_tag(&mut self, value: bool) {\n-        let usize_ptr = &*self.0 as *const *mut HashUint as *mut usize;\n+        let mut usize_ptr = self.0.as_ptr() as usize;\n         unsafe {\n             if value {\n-                *usize_ptr |= 1;\n+                usize_ptr |= 1;\n             } else {\n-                *usize_ptr &= !1;\n+                usize_ptr &= !1;\n             }\n+            self.0 = Unique::new(usize_ptr as *mut HashUint)\n         }\n     }\n \n     #[inline]\n     fn tag(&self) -> bool {\n-        (*self.0 as usize) & 1 == 1\n+        (self.0.as_ptr() as usize) & 1 == 1\n     }\n \n     #[inline]\n     fn ptr(&self) -> *mut HashUint {\n-        (*self.0 as usize & !1) as *mut HashUint\n+        (self.0.as_ptr() as usize & !1) as *mut HashUint\n     }\n }\n \n@@ -1112,10 +1114,12 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n \n     #[inline]\n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-        self.iter.next().map(|raw| unsafe {\n-            (*self.table.as_mut_ptr()).size -= 1;\n-            let (k, v) = ptr::read(raw.pair());\n-            (SafeHash { hash: ptr::replace(&mut *raw.hash(), EMPTY_BUCKET) }, k, v)\n+        self.iter.next().map(|raw| {\n+            unsafe {\n+                self.table.as_mut().size -= 1;\n+                let (k, v) = ptr::read(raw.pair());\n+                (SafeHash { hash: ptr::replace(&mut *raw.hash(), EMPTY_BUCKET) }, k, v)\n+            }\n         })\n     }\n "}]}