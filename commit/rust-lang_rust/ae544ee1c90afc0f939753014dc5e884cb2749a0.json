{"sha": "ae544ee1c90afc0f939753014dc5e884cb2749a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNTQ0ZWUxYzkwYWZjMGY5Mzk3NTMwMTRkYzVlODg0Y2IyNzQ5YTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-29T11:34:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-29T11:34:17Z"}, "message": "Auto merge of #49163 - SimonSapin:range-bounds, r=alexcrichton\n\nRename RangeArgument to RangeBounds, move it and Bound to libcore\n\nAs proposed in the tracking issue: https://github.com/rust-lang/rust/issues/30877\n\nChanges to *stable* items:\n\n* `core::ops::Bound` / `std::ops::Bound` is new\n* `std::collections::Bound` is a deprecated reexport of it (does this actually cause a warning?)\n\nChanges to *unstable* items\n\n* `alloc::Bound` is gone\n* `alloc::range::RangeArgument` is moved to `core::ops::RangeBounds` / `std::ops::RangeBounds`\n* `alloc::range` is gone\n* `std::collections::range::RangeArgument` is deprecated reexport, to be removed later\n* `std::collections::range` is deprecated, to be removed later\n* `impl RangeBounds<T> for Range{,From,To,Inclusive,ToInclusive}<&T>` are added\n\nThe idea of replacing this trait with a type to be used with `Into<_>` is left for future consideration / work.\n\n(Fixes https://github.com/rust-lang-nursery/rust-clippy/issues/2552.)", "tree": {"sha": "d07caa9ff970a3127f3530bc78460b81fe727ca7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d07caa9ff970a3127f3530bc78460b81fe727ca7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae544ee1c90afc0f939753014dc5e884cb2749a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae544ee1c90afc0f939753014dc5e884cb2749a0", "html_url": "https://github.com/rust-lang/rust/commit/ae544ee1c90afc0f939753014dc5e884cb2749a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae544ee1c90afc0f939753014dc5e884cb2749a0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "409744bcb91f4efa35b8fcc9e7033523a86b90c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/409744bcb91f4efa35b8fcc9e7033523a86b90c2", "html_url": "https://github.com/rust-lang/rust/commit/409744bcb91f4efa35b8fcc9e7033523a86b90c2"}, {"sha": "6c9b3cccbcef8918829e173a2ea9c5d975cd2777", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9b3cccbcef8918829e173a2ea9c5d975cd2777", "html_url": "https://github.com/rust-lang/rust/commit/6c9b3cccbcef8918829e173a2ea9c5d975cd2777"}], "stats": {"total": 552, "additions": 307, "deletions": 245}, "files": [{"sha": "c604df7049e0c02e10f53809f5c610986200b1a9", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -13,12 +13,12 @@ use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, Peekable, FusedIterator};\n use core::marker::PhantomData;\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::Index;\n+use core::ops::RangeBounds;\n use core::{fmt, intrinsics, mem, ptr};\n \n use borrow::Borrow;\n-use Bound::{Excluded, Included, Unbounded};\n-use range::RangeArgument;\n \n use super::node::{self, Handle, NodeRef, marker};\n use super::search;\n@@ -804,7 +804,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n-    /// use std::collections::Bound::Included;\n+    /// use std::ops::Bound::Included;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(3, \"a\");\n@@ -817,7 +817,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n     pub fn range<T: ?Sized, R>(&self, range: R) -> Range<K, V>\n-        where T: Ord, K: Borrow<T>, R: RangeArgument<T>\n+        where T: Ord, K: Borrow<T>, R: RangeBounds<T>\n     {\n         let root1 = self.root.as_ref();\n         let root2 = self.root.as_ref();\n@@ -857,7 +857,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n     pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<K, V>\n-        where T: Ord, K: Borrow<T>, R: RangeArgument<T>\n+        where T: Ord, K: Borrow<T>, R: RangeBounds<T>\n     {\n         let root1 = self.root.as_mut();\n         let root2 = unsafe { ptr::read(&root1) };\n@@ -1812,7 +1812,7 @@ fn last_leaf_edge<BorrowType, K, V>\n     }\n }\n \n-fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeArgument<Q>>(\n+fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     range: R"}, {"sha": "2aad476d3153aead98448a4ddc9c6985df21c4e0", "filename": "src/liballoc/btree/set.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -16,12 +16,11 @@ use core::cmp::{min, max};\n use core::fmt::Debug;\n use core::fmt;\n use core::iter::{Peekable, FromIterator, FusedIterator};\n-use core::ops::{BitOr, BitAnd, BitXor, Sub};\n+use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeBounds};\n \n use borrow::Borrow;\n use btree_map::{BTreeMap, Keys};\n use super::Recover;\n-use range::RangeArgument;\n \n // FIXME(conventions): implement bounded iterators\n \n@@ -240,7 +239,7 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// ```\n     /// use std::collections::BTreeSet;\n-    /// use std::collections::Bound::Included;\n+    /// use std::ops::Bound::Included;\n     ///\n     /// let mut set = BTreeSet::new();\n     /// set.insert(3);\n@@ -253,7 +252,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n     pub fn range<K: ?Sized, R>(&self, range: R) -> Range<T>\n-        where K: Ord, T: Borrow<K>, R: RangeArgument<K>\n+        where K: Ord, T: Borrow<K>, R: RangeBounds<K>\n     {\n         Range { iter: self.map.range(range) }\n     }"}, {"sha": "e98b58994bfbb3bf5e63b23d83535e065b7e4011", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 52, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -88,6 +88,7 @@\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n+#![feature(collections_range)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(custom_attribute)]\n@@ -178,7 +179,6 @@ mod btree;\n pub mod borrow;\n pub mod fmt;\n pub mod linked_list;\n-pub mod range;\n pub mod slice;\n pub mod str;\n pub mod string;\n@@ -204,57 +204,6 @@ mod std {\n     pub use core::ops;      // RangeFull\n }\n \n-/// An endpoint of a range of keys.\n-///\n-/// # Examples\n-///\n-/// `Bound`s are range endpoints:\n-///\n-/// ```\n-/// #![feature(collections_range)]\n-///\n-/// use std::collections::range::RangeArgument;\n-/// use std::collections::Bound::*;\n-///\n-/// assert_eq!((..100).start(), Unbounded);\n-/// assert_eq!((1..12).start(), Included(&1));\n-/// assert_eq!((1..12).end(), Excluded(&12));\n-/// ```\n-///\n-/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n-/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n-///\n-/// ```\n-/// use std::collections::BTreeMap;\n-/// use std::collections::Bound::{Excluded, Included, Unbounded};\n-///\n-/// let mut map = BTreeMap::new();\n-/// map.insert(3, \"a\");\n-/// map.insert(5, \"b\");\n-/// map.insert(8, \"c\");\n-///\n-/// for (key, value) in map.range((Excluded(3), Included(8))) {\n-///     println!(\"{}: {}\", key, value);\n-/// }\n-///\n-/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n-/// ```\n-///\n-/// [`BTreeMap::range`]: btree_map/struct.BTreeMap.html#method.range\n-#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n-pub enum Bound<T> {\n-    /// An inclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Included(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n-    /// An exclusive bound.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Excluded(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n-    /// An infinite endpoint. Indicates that there is no bound in this direction.\n-    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n-    Unbounded,\n-}\n-\n /// An intermediate trait for specialization of `Extend`.\n #[doc(hidden)]\n trait SpecExtend<I: IntoIterator> {"}, {"sha": "b03abc8518087addd1b7d8976c3a0a1f45e06ca8", "filename": "src/liballoc/range.rs", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/409744bcb91f4efa35b8fcc9e7033523a86b90c2/src%2Fliballoc%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/409744bcb91f4efa35b8fcc9e7033523a86b90c2/src%2Fliballoc%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frange.rs?ref=409744bcb91f4efa35b8fcc9e7033523a86b90c2", "patch": "@@ -1,152 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![unstable(feature = \"collections_range\",\n-            reason = \"waiting for dust to settle on inclusive ranges\",\n-            issue = \"30877\")]\n-\n-//! Range syntax.\n-\n-use core::ops::{RangeFull, Range, RangeTo, RangeFrom, RangeInclusive, RangeToInclusive};\n-use Bound::{self, Excluded, Included, Unbounded};\n-\n-/// `RangeArgument` is implemented by Rust's built-in range types, produced\n-/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n-pub trait RangeArgument<T: ?Sized> {\n-    /// Start index bound.\n-    ///\n-    /// Returns the start value as a `Bound`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(alloc)]\n-    /// #![feature(collections_range)]\n-    ///\n-    /// extern crate alloc;\n-    ///\n-    /// # fn main() {\n-    /// use alloc::range::RangeArgument;\n-    /// use alloc::Bound::*;\n-    ///\n-    /// assert_eq!((..10).start(), Unbounded);\n-    /// assert_eq!((3..10).start(), Included(&3));\n-    /// # }\n-    /// ```\n-    fn start(&self) -> Bound<&T>;\n-\n-    /// End index bound.\n-    ///\n-    /// Returns the end value as a `Bound`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(alloc)]\n-    /// #![feature(collections_range)]\n-    ///\n-    /// extern crate alloc;\n-    ///\n-    /// # fn main() {\n-    /// use alloc::range::RangeArgument;\n-    /// use alloc::Bound::*;\n-    ///\n-    /// assert_eq!((3..).end(), Unbounded);\n-    /// assert_eq!((3..10).end(), Excluded(&10));\n-    /// # }\n-    /// ```\n-    fn end(&self) -> Bound<&T>;\n-}\n-\n-// FIXME add inclusive ranges to RangeArgument\n-\n-impl<T: ?Sized> RangeArgument<T> for RangeFull {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for RangeFrom<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for RangeTo<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Excluded(&self.end)\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for Range<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Excluded(&self.end)\n-    }\n-}\n-\n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<T> RangeArgument<T> for RangeInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Included(&self.start)\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Included(&self.end)\n-    }\n-}\n-\n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<T> RangeArgument<T> for RangeToInclusive<T> {\n-    fn start(&self) -> Bound<&T> {\n-        Unbounded\n-    }\n-    fn end(&self) -> Bound<&T> {\n-        Included(&self.end)\n-    }\n-}\n-\n-impl<T> RangeArgument<T> for (Bound<T>, Bound<T>) {\n-    fn start(&self) -> Bound<&T> {\n-        match *self {\n-            (Included(ref start), _) => Included(start),\n-            (Excluded(ref start), _) => Excluded(start),\n-            (Unbounded, _)           => Unbounded,\n-        }\n-    }\n-\n-    fn end(&self) -> Bound<&T> {\n-        match *self {\n-            (_, Included(ref end)) => Included(end),\n-            (_, Excluded(ref end)) => Excluded(end),\n-            (_, Unbounded)         => Unbounded,\n-        }\n-    }\n-}\n-\n-impl<'a, T: ?Sized + 'a> RangeArgument<T> for (Bound<&'a T>, Bound<&'a T>) {\n-    fn start(&self) -> Bound<&T> {\n-        self.0\n-    }\n-\n-    fn end(&self) -> Bound<&T> {\n-        self.1\n-    }\n-}"}, {"sha": "aa202e23628922072c144409ede7c24d395ba2de", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -59,15 +59,14 @@\n use core::fmt;\n use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n-use core::ops::{self, Add, AddAssign, Index, IndexMut};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{self, Add, AddAssign, Index, IndexMut, RangeBounds};\n use core::ptr;\n use core::str::pattern::Pattern;\n use std_unicode::lossy;\n use std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n \n use borrow::{Cow, ToOwned};\n-use range::RangeArgument;\n-use Bound::{Excluded, Included, Unbounded};\n use str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use vec::Vec;\n use boxed::Box;\n@@ -1484,7 +1483,7 @@ impl String {\n     /// ```\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain\n-        where R: RangeArgument<usize>\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //\n@@ -1548,7 +1547,7 @@ impl String {\n     /// ```\n     #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"44643\")]\n     pub fn splice<R>(&mut self, range: R, replace_with: &str)\n-        where R: RangeArgument<usize>\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //"}, {"sha": "6ebdb86cc4a9865a42bdde87419e87503ef249f0", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use std::collections::BTreeMap;\n-use std::collections::Bound::{self, Excluded, Included, Unbounded};\n use std::collections::btree_map::Entry::{Occupied, Vacant};\n+use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::rc::Rc;\n \n use std::iter::FromIterator;"}, {"sha": "df08e46fe25f1757e6a1d95af4d7890441281936", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -75,7 +75,8 @@ use core::marker::PhantomData;\n use core::mem;\n #[cfg(not(test))]\n use core::num::Float;\n-use core::ops::{InPlace, Index, IndexMut, Place, Placer};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{InPlace, Index, IndexMut, Place, Placer, RangeBounds};\n use core::ops;\n use core::ptr;\n use core::ptr::NonNull;\n@@ -85,9 +86,7 @@ use borrow::ToOwned;\n use borrow::Cow;\n use boxed::Box;\n use raw_vec::RawVec;\n-use super::range::RangeArgument;\n use super::allocator::CollectionAllocErr;\n-use Bound::{Excluded, Included, Unbounded};\n \n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n@@ -1176,7 +1175,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain<T>\n-        where R: RangeArgument<usize>\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //\n@@ -1950,7 +1949,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n     pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<I::IntoIter>\n-        where R: RangeArgument<usize>, I: IntoIterator<Item=T>\n+        where R: RangeBounds<usize>, I: IntoIterator<Item=T>\n     {\n         Splice {\n             drain: self.drain(range),"}, {"sha": "94d042a45aa3ebc809ec7aec2bf66e6afeb887f4", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -21,7 +21,8 @@ use core::cmp::Ordering;\n use core::fmt;\n use core::iter::{repeat, FromIterator, FusedIterator};\n use core::mem;\n-use core::ops::{Index, IndexMut, Place, Placer, InPlace};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n+use core::ops::{Index, IndexMut, Place, Placer, InPlace, RangeBounds};\n use core::ptr;\n use core::ptr::NonNull;\n use core::slice;\n@@ -32,8 +33,6 @@ use core::cmp;\n use raw_vec::RawVec;\n \n use super::allocator::CollectionAllocErr;\n-use super::range::RangeArgument;\n-use Bound::{Excluded, Included, Unbounded};\n use super::vec::Vec;\n \n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n@@ -969,7 +968,7 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain<R>(&mut self, range: R) -> Drain<T>\n-        where R: RangeArgument<usize>\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //"}, {"sha": "0b480b618fcb66469a3a254c709c133688a550bf", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -192,7 +192,7 @@ pub use self::index::{Index, IndexMut};\n pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-pub use self::range::{RangeInclusive, RangeToInclusive};\n+pub use self::range::{RangeInclusive, RangeToInclusive, RangeBounds, Bound};\n \n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n pub use self::try::Try;"}, {"sha": "3f6674071256696e45bf74c8229a05c85993dd71", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -442,3 +442,267 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n \n // RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n // because underflow would be possible with (..0).into()\n+\n+/// An endpoint of a range of keys.\n+///\n+/// # Examples\n+///\n+/// `Bound`s are range endpoints:\n+///\n+/// ```\n+/// #![feature(collections_range)]\n+///\n+/// use std::ops::Bound::*;\n+/// use std::ops::RangeBounds;\n+///\n+/// assert_eq!((..100).start(), Unbounded);\n+/// assert_eq!((1..12).start(), Included(&1));\n+/// assert_eq!((1..12).end(), Excluded(&12));\n+/// ```\n+///\n+/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n+/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n+///\n+/// ```\n+/// use std::collections::BTreeMap;\n+/// use std::ops::Bound::{Excluded, Included, Unbounded};\n+///\n+/// let mut map = BTreeMap::new();\n+/// map.insert(3, \"a\");\n+/// map.insert(5, \"b\");\n+/// map.insert(8, \"c\");\n+///\n+/// for (key, value) in map.range((Excluded(3), Included(8))) {\n+///     println!(\"{}: {}\", key, value);\n+/// }\n+///\n+/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n+/// ```\n+///\n+/// [`BTreeMap::range`]: ../../std/collections/btree_map/struct.BTreeMap.html#method.range\n+#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\n+pub enum Bound<T> {\n+    /// An inclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Included(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n+    /// An exclusive bound.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Excluded(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n+    /// An infinite endpoint. Indicates that there is no bound in this direction.\n+    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n+    Unbounded,\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+/// `RangeBounds` is implemented by Rust's built-in range types, produced\n+/// by range syntax like `..`, `a..`, `..b` or `c..d`.\n+pub trait RangeBounds<T: ?Sized> {\n+    /// Start index bound.\n+    ///\n+    /// Returns the start value as a `Bound`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collections_range)]\n+    ///\n+    /// # fn main() {\n+    /// use std::ops::Bound::*;\n+    /// use std::ops::RangeBounds;\n+    ///\n+    /// assert_eq!((..10).start(), Unbounded);\n+    /// assert_eq!((3..10).start(), Included(&3));\n+    /// # }\n+    /// ```\n+    fn start(&self) -> Bound<&T>;\n+\n+    /// End index bound.\n+    ///\n+    /// Returns the end value as a `Bound`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collections_range)]\n+    ///\n+    /// # fn main() {\n+    /// use std::ops::Bound::*;\n+    /// use std::ops::RangeBounds;\n+    ///\n+    /// assert_eq!((3..).end(), Unbounded);\n+    /// assert_eq!((3..10).end(), Excluded(&10));\n+    /// # }\n+    /// ```\n+    fn end(&self) -> Bound<&T>;\n+}\n+\n+use self::Bound::{Excluded, Included, Unbounded};\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T: ?Sized> RangeBounds<T> for RangeFull {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for RangeFrom<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for RangeTo<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for Range<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for RangeInclusive<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(&self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for RangeToInclusive<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(&self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n+    fn start(&self) -> Bound<&T> {\n+        match *self {\n+            (Included(ref start), _) => Included(start),\n+            (Excluded(ref start), _) => Excluded(start),\n+            (Unbounded, _)           => Unbounded,\n+        }\n+    }\n+\n+    fn end(&self) -> Bound<&T> {\n+        match *self {\n+            (_, Included(ref end)) => Included(end),\n+            (_, Excluded(ref end)) => Excluded(end),\n+            (_, Unbounded)         => Unbounded,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n+    fn start(&self) -> Bound<&T> {\n+        self.0\n+    }\n+\n+    fn end(&self) -> Bound<&T> {\n+        self.1\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for RangeFrom<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for RangeTo<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for Range<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Excluded(self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for RangeInclusive<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Included(self.start)\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"collections_range\",\n+           reason = \"might be replaced with `Into<_>` and a type containing two `Bound` values\",\n+           issue = \"30877\")]\n+impl<'a, T> RangeBounds<T> for RangeToInclusive<&'a T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(self.end)\n+    }\n+}"}, {"sha": "f50b8cadf15ab4f3b74d850ccfe1966a16d41bad", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -15,11 +15,10 @@\n //!\n //! The N above is determined by Array's implementor, by way of an associated constant.\n \n-use std::ops::{Deref, DerefMut};\n+use std::ops::{Deref, DerefMut, RangeBounds};\n use std::iter::{self, IntoIterator, FromIterator};\n use std::slice;\n use std::vec;\n-use std::collections::range::RangeArgument;\n \n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n \n@@ -74,7 +73,7 @@ impl<A: Array> AccumulateVec<A> {\n     }\n \n     pub fn drain<R>(&mut self, range: R) -> Drain<A>\n-        where R: RangeArgument<usize>\n+        where R: RangeBounds<usize>\n     {\n         match *self {\n             AccumulateVec::Array(ref mut v) => {"}, {"sha": "db1cfb5c767687cf92613bb333035f980cdb2592", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -18,9 +18,9 @@ use std::hash::{Hash, Hasher};\n use std::slice;\n use std::fmt;\n use std::mem;\n-use std::collections::range::RangeArgument;\n-use std::collections::Bound::{Excluded, Included, Unbounded};\n use std::mem::ManuallyDrop;\n+use std::ops::Bound::{Excluded, Included, Unbounded};\n+use std::ops::RangeBounds;\n \n pub unsafe trait Array {\n     type Element;\n@@ -106,7 +106,7 @@ impl<A: Array> ArrayVec<A> {\n     }\n \n     pub fn drain<R>(&mut self, range: R) -> Drain<A>\n-        where R: RangeArgument<usize>\n+        where R: RangeBounds<usize>\n     {\n         // Memory safety\n         //"}, {"sha": "1fb63afc72fa758ae882ae0905f17aa2c0b27711", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::collections::range::RangeArgument;\n use std::fmt::Debug;\n use std::iter::{self, FromIterator};\n use std::slice;\n use std::marker::PhantomData;\n-use std::ops::{Index, IndexMut, Range};\n+use std::ops::{Index, IndexMut, Range, RangeBounds};\n use std::fmt;\n use std::vec;\n use std::u32;\n@@ -448,13 +447,13 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn drain<'a, R: RangeArgument<usize>>(\n+    pub fn drain<'a, R: RangeBounds<usize>>(\n         &'a mut self, range: R) -> impl Iterator<Item=T> + 'a {\n         self.raw.drain(range)\n     }\n \n     #[inline]\n-    pub fn drain_enumerated<'a, R: RangeArgument<usize>>(\n+    pub fn drain_enumerated<'a, R: RangeBounds<usize>>(\n         &'a mut self, range: R) -> impl Iterator<Item=(I, T)> + 'a {\n         self.raw.drain(range).enumerate().map(IntoIdx { _marker: PhantomData })\n     }"}, {"sha": "c7ad27d8d2675684d323f0ae04471bb7e6e5ff11", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -420,7 +420,9 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::Bound;\n+#[rustc_deprecated(reason = \"moved to `std::ops::Bound`\", since = \"1.26.0\")]\n+#[doc(hidden)]\n+pub use ops::Bound;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc::{BinaryHeap, BTreeMap, BTreeSet};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -435,8 +437,13 @@ pub use self::hash_map::HashMap;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::hash_set::HashSet;\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::range;\n+#[unstable(feature = \"collections_range\", issue = \"30877\")]\n+#[rustc_deprecated(reason = \"renamed and moved to `std::ops::RangeBounds`\", since = \"1.26.0\")]\n+#[doc(hidden)]\n+/// Range syntax\n+pub mod range {\n+    pub use ops::RangeBounds as RangeArgument;\n+}\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n pub use alloc::allocator::CollectionAllocErr;"}, {"sha": "e096fb3bbaef723a60aea7d1d43b5656cbe14de4", "filename": "src/test/run-pass/sync-send-iterators-in-libcollections.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae544ee1c90afc0f939753014dc5e884cb2749a0/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -18,8 +18,8 @@ use std::collections::VecDeque;\n use std::collections::HashMap;\n use std::collections::HashSet;\n \n-use std::collections::Bound::Included;\n use std::mem;\n+use std::ops::Bound::Included;\n \n fn is_sync<T>(_: T) where T: Sync {}\n fn is_send<T>(_: T) where T: Send {}"}, {"sha": "b75618206cec71bd87ff7b07f0a8698ee854a2d1", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=ae544ee1c90afc0f939753014dc5e884cb2749a0", "patch": "@@ -1 +1 @@\n-Subproject commit eafd09010815da43302ac947afee45b0f5219e6b\n+Subproject commit b75618206cec71bd87ff7b07f0a8698ee854a2d1"}]}