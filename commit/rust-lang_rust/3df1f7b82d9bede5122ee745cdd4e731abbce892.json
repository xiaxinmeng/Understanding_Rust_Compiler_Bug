{"sha": "3df1f7b82d9bede5122ee745cdd4e731abbce892", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZjFmN2I4MmQ5YmVkZTUxMjJlZTc0NWNkZDRlNzMxYWJiY2U4OTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-25T18:05:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-25T18:05:22Z"}, "message": "Auto merge of #44085 - bjorn3:no_llvm_write_metadata, r=arielb1\n\nAllow writing metadata without llvm\n\n# Todo:\n\n* [x] Rebase\n* [x] Fix eventual errors\n* [x] <strike>Find some crate to write elf files</strike> (will do it later)\n\nCc #43842", "tree": {"sha": "8940e26551549d564690fef64cf207390252f45b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8940e26551549d564690fef64cf207390252f45b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3df1f7b82d9bede5122ee745cdd4e731abbce892", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3df1f7b82d9bede5122ee745cdd4e731abbce892", "html_url": "https://github.com/rust-lang/rust/commit/3df1f7b82d9bede5122ee745cdd4e731abbce892", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3df1f7b82d9bede5122ee745cdd4e731abbce892/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91dbf52af3de0436bcc032229540db1fe14b6df8", "url": "https://api.github.com/repos/rust-lang/rust/commits/91dbf52af3de0436bcc032229540db1fe14b6df8", "html_url": "https://github.com/rust-lang/rust/commit/91dbf52af3de0436bcc032229540db1fe14b6df8"}, {"sha": "843cd5bacc56dc7a9ec45d3aaebf717566f5bf36", "url": "https://api.github.com/repos/rust-lang/rust/commits/843cd5bacc56dc7a9ec45d3aaebf717566f5bf36", "html_url": "https://github.com/rust-lang/rust/commit/843cd5bacc56dc7a9ec45d3aaebf717566f5bf36"}], "stats": {"total": 790, "additions": 523, "deletions": 267}, "files": [{"sha": "309fbd95345a451fd9bcf6e04d65180ecf8229f4", "filename": ".gitignore", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -103,3 +103,6 @@ version.texi\n .cargo\n !src/vendor/**\n /src/target/\n+\n+no_llvm_build\n+"}, {"sha": "e9a20a7c79ca7d019a14922706d1a8558c250ff6", "filename": "src/Cargo.lock", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -1778,7 +1778,12 @@ dependencies = [\n name = \"rustc_trans_utils\"\n version = \"0.0.0\"\n dependencies = [\n+ \"ar 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "ffd959d86f5804e11a2c2be40b5ab00786e46a60", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -531,7 +531,10 @@ impl<'a> Builder<'a> {\n         // For other crates, however, we know that we've already got a standard\n         // library up and running, so we can use the normal compiler to compile\n         // build scripts in that situation.\n-        if mode == Mode::Libstd {\n+        //\n+        // If LLVM support is disabled we need to use the snapshot compiler to compile\n+        // build scripts, as the new compiler doesnt support executables.\n+        if mode == Mode::Libstd || !self.build.config.llvm_enabled {\n             cargo.env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n                  .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n         } else {"}, {"sha": "57989f75cbaec3b5a5a19436b5db52c6a5603785", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 54, "deletions": 73, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![cfg_attr(not(feature=\"llvm\"), allow(dead_code))]\n-\n use rustc::dep_graph::DepGraph;\n use rustc::hir::{self, map as hir_map};\n use rustc::hir::lowering::lower_crate;\n@@ -34,15 +32,16 @@ use rustc_incremental;\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n-use rustc_trans::back::write;\n use rustc_trans as trans;\n+use rustc_trans_utils::trans_crate::TransCrate;\n use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n use rustc_passes::{ast_validation, no_asm, loops, consts, static_recursion, hir_stats};\n use rustc_const_eval::{self, check_match};\n use super::Compilation;\n+use ::DefaultTransCrate;\n \n use serialize::json;\n \n@@ -76,7 +75,8 @@ pub fn compile_input(sess: &Session,\n                      output: &Option<PathBuf>,\n                      addl_plugins: Option<Vec<String>>,\n                      control: &CompileController) -> CompileResult {\n-    use rustc_trans::back::write::OngoingCrateTranslation;\n+    use rustc::session::config::CrateType;\n+\n     macro_rules! controller_entry_point {\n         ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n             let state = &mut $make_state;\n@@ -94,17 +94,16 @@ pub fn compile_input(sess: &Session,\n     }\n \n     if cfg!(not(feature=\"llvm\")) {\n-        use rustc::session::config::CrateType;\n-        if !sess.opts.debugging_opts.no_trans && sess.opts.output_types.should_trans() {\n-            sess.err(\"LLVM is not supported by this rustc. Please use -Z no-trans to compile\")\n-        }\n-\n-        if sess.opts.crate_types.iter().all(|&t|{\n-            t != CrateType::CrateTypeRlib && t != CrateType::CrateTypeExecutable\n-        }) && !sess.opts.crate_types.is_empty() {\n-            sess.err(\n-                \"LLVM is not supported by this rustc, so non rlib libraries are not supported\"\n-            );\n+        for cty in sess.opts.crate_types.iter() {\n+            match *cty {\n+                CrateType::CrateTypeRlib | CrateType::CrateTypeDylib |\n+                CrateType::CrateTypeExecutable => {},\n+                _ => {\n+                    sess.parse_sess.span_diagnostic.warn(\n+                        &format!(\"LLVM unsupported, so output type {} is not supported\", cty)\n+                    );\n+                },\n+            }\n         }\n \n         sess.abort_if_errors();\n@@ -117,7 +116,7 @@ pub fn compile_input(sess: &Session,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (outputs, trans, dep_graph): (OutputFilenames, OngoingCrateTranslation, DepGraph) = {\n+    let (outputs, trans, dep_graph) = {\n         let krate = match phase_1_parse_input(control, sess, input) {\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n@@ -246,7 +245,7 @@ pub fn compile_input(sess: &Session,\n                 tcx.print_debug_stats();\n             }\n \n-            let trans = phase_4_translate_to_llvm(tcx, rx);\n+            let trans = phase_4_translate_to_llvm::<DefaultTransCrate>(tcx, rx);\n \n             if log_enabled!(::log::LogLevel::Info) {\n                 println!(\"Post-trans\");\n@@ -264,44 +263,42 @@ pub fn compile_input(sess: &Session,\n         })??\n     };\n \n-    if cfg!(not(feature=\"llvm\")) {\n-        let (_, _) = (outputs, trans);\n-        sess.fatal(\"LLVM is not supported by this rustc\");\n+    if sess.opts.debugging_opts.print_type_sizes {\n+        sess.code_stats.borrow().print_type_sizes();\n     }\n \n-    #[cfg(feature=\"llvm\")]\n-    {\n-        if sess.opts.debugging_opts.print_type_sizes {\n-            sess.code_stats.borrow().print_type_sizes();\n-        }\n-\n-        let (phase5_result, trans) = phase_5_run_llvm_passes(sess, &dep_graph, trans);\n+    let (phase5_result, trans) =\n+        phase_5_run_llvm_passes::<DefaultTransCrate>(sess, &dep_graph, trans);\n \n-        controller_entry_point!(after_llvm,\n-                                sess,\n-                                CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n-                                phase5_result);\n-        phase5_result?;\n+    controller_entry_point!(after_llvm,\n+                            sess,\n+                            CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n+                            phase5_result);\n+    phase5_result?;\n \n-        phase_6_link_output(sess, &trans, &outputs);\n-\n-        // Now that we won't touch anything in the incremental compilation directory\n-        // any more, we can finalize it (which involves renaming it)\n-        rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n+    // Run the linker on any artifacts that resulted from the LLVM run.\n+    // This should produce either a finished executable or library.\n+    time(sess.time_passes(), \"linking\", || {\n+        DefaultTransCrate::link_binary(sess, &trans, &outputs)\n+    });\n \n-        if sess.opts.debugging_opts.perf_stats {\n-            sess.print_perf_stats();\n-        }\n+    // Now that we won't touch anything in the incremental compilation directory\n+    // any more, we can finalize it (which involves renaming it)\n+    #[cfg(feature=\"llvm\")]\n+    rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n \n-        controller_entry_point!(\n-            compilation_done,\n-            sess,\n-            CompileState::state_when_compilation_done(input, sess, outdir, output),\n-            Ok(())\n-        );\n+    if sess.opts.debugging_opts.perf_stats {\n+        sess.print_perf_stats();\n+    }\n \n+    controller_entry_point!(\n+        compilation_done,\n+        sess,\n+        CompileState::state_when_compilation_done(input, sess, outdir, output),\n         Ok(())\n-    }\n+    );\n+\n+    Ok(())\n }\n \n fn keep_hygiene_data(sess: &Session) -> bool {\n@@ -970,7 +967,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     mir::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n-    trans::provide_local(&mut local_providers);\n+    DefaultTransCrate::provide_local(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n     traits::provide(&mut local_providers);\n@@ -982,7 +979,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n-    trans::provide_extern(&mut extern_providers);\n+    DefaultTransCrate::provide_extern(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n     traits::provide_extern(&mut extern_providers);\n     // FIXME(eddyb) get rid of this once we replace const_eval with miri.\n@@ -1126,9 +1123,9 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n-pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn phase_4_translate_to_llvm<'a, 'tcx, Trans: TransCrate>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            rx: mpsc::Receiver<Box<Any + Send>>)\n-                                           -> write::OngoingCrateTranslation {\n+                                           -> <Trans as TransCrate>::OngoingCrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n \n     time(time_passes,\n@@ -1137,9 +1134,8 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let translation =\n         time(time_passes, \"translation\", move || {\n-            trans::trans_crate(tcx, rx)\n+            Trans::trans_crate(tcx, rx)\n         });\n-\n     if tcx.sess.profile_queries() {\n         profile::dump(\"profile_queries\".to_string())\n     }\n@@ -1149,15 +1145,14 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n-#[cfg(feature=\"llvm\")]\n-pub fn phase_5_run_llvm_passes(sess: &Session,\n+pub fn phase_5_run_llvm_passes<Trans: TransCrate>(sess: &Session,\n                                dep_graph: &DepGraph,\n-                               trans: write::OngoingCrateTranslation)\n-                               -> (CompileResult, trans::CrateTranslation) {\n-    let trans = trans.join(sess, dep_graph);\n+                               trans: <Trans as TransCrate>::OngoingCrateTranslation)\n+                               -> (CompileResult, <Trans as TransCrate>::TranslatedCrate) {\n+    let trans = Trans::join_trans(trans, sess, dep_graph);\n \n     if sess.opts.debugging_opts.incremental_info {\n-        write::dump_incremental_data(&trans);\n+        Trans::dump_incremental_data(&trans);\n     }\n \n     time(sess.time_passes(),\n@@ -1167,20 +1162,6 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n     (sess.compile_status(), trans)\n }\n \n-/// Run the linker on any artifacts that resulted from the LLVM run.\n-/// This should produce either a finished executable or library.\n-#[cfg(feature=\"llvm\")]\n-pub fn phase_6_link_output(sess: &Session,\n-                           trans: &trans::CrateTranslation,\n-                           outputs: &OutputFilenames) {\n-    time(sess.time_passes(), \"linking\", || {\n-        ::rustc_trans::back::link::link_binary(sess,\n-                                               trans,\n-                                               outputs,\n-                                               &trans.crate_name.as_str())\n-    });\n-}\n-\n fn escape_dep_filename(filename: &str) -> String {\n     // Apparently clang and gcc *only* escape spaces:\n     // http://llvm.org/klaus/clang/commit/9d50634cfc268ecc9a7250226dd5ca0e945240d4"}, {"sha": "6bdad0b212cf5d78a1fd92064b487c377910d844", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 8, "deletions": 76, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -75,6 +75,7 @@ use rustc::middle::cstore::CrateStore;\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n use rustc::util::common::{time, ErrorReported};\n+use rustc_trans_utils::trans_crate::TransCrate;\n \n use serialize::json::ToJson;\n \n@@ -151,101 +152,31 @@ pub fn run<F>(run_compiler: F) -> isize\n }\n \n #[cfg(not(feature=\"llvm\"))]\n-pub use no_llvm_metadata_loader::NoLLvmMetadataLoader as MetadataLoader;\n+pub use rustc_trans_utils::trans_crate::MetadataOnlyTransCrate as DefaultTransCrate;\n #[cfg(feature=\"llvm\")]\n-pub use rustc_trans::LlvmMetadataLoader as MetadataLoader;\n-\n-#[cfg(not(feature=\"llvm\"))]\n-mod no_llvm_metadata_loader {\n-    extern crate ar;\n-    extern crate owning_ref;\n-\n-    use rustc::middle::cstore::MetadataLoader as MetadataLoaderTrait;\n-    use rustc_back::target::Target;\n-    use std::io;\n-    use std::fs::File;\n-    use std::path::Path;\n-\n-    use self::ar::Archive;\n-    use self::owning_ref::{OwningRef, ErasedBoxRef};\n-\n-    pub struct NoLLvmMetadataLoader;\n-\n-    impl MetadataLoaderTrait for NoLLvmMetadataLoader {\n-        fn get_rlib_metadata(\n-            &self,\n-            _: &Target,\n-            filename: &Path\n-        ) -> Result<ErasedBoxRef<[u8]>, String> {\n-            let file = File::open(filename).map_err(|e| {\n-                format!(\"metadata file open err: {:?}\", e)\n-            })?;\n-            let mut archive = Archive::new(file);\n-\n-            while let Some(entry_result) = archive.next_entry() {\n-                let mut entry = entry_result.map_err(|e| {\n-                    format!(\"metadata section read err: {:?}\", e)\n-                })?;\n-                if entry.header().identifier() == \"rust.metadata.bin\" {\n-                    let mut buf = Vec::new();\n-                    io::copy(&mut entry, &mut buf).unwrap();\n-                    let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n-                    return Ok(buf.map_owner_box().erase_owner());\n-                }\n-            }\n-\n-            Err(\"Couldnt find metadata section\".to_string())\n-        }\n-\n-        fn get_dylib_metadata(&self,\n-                            _target: &Target,\n-                            _filename: &Path)\n-                            -> Result<ErasedBoxRef<[u8]>, String> {\n-            panic!(\"Dylib metadata loading not supported without LLVM\")\n-        }\n-    }\n-}\n+pub use rustc_trans::LlvmTransCrate as DefaultTransCrate;\n \n #[cfg(not(feature=\"llvm\"))]\n mod rustc_trans {\n     use syntax_pos::symbol::Symbol;\n     use rustc::session::Session;\n-    use rustc::session::config::{PrintRequest, OutputFilenames};\n-    use rustc::ty::{TyCtxt, CrateAnalysis};\n-    use rustc::ty::maps::Providers;\n-    use rustc_incremental::IncrementalHashesMap;\n-\n-    use self::back::write::OngoingCrateTranslation;\n+    use rustc::session::config::PrintRequest;\n+    pub use rustc_trans_utils::trans_crate::MetadataOnlyTransCrate as LlvmTransCrate;\n+    pub use rustc_trans_utils::trans_crate::TranslatedCrate as CrateTranslation;\n \n     pub fn init(_sess: &Session) {}\n     pub fn enable_llvm_debug() {}\n-    pub fn provide(_providers: &mut Providers) {}\n     pub fn print_version() {}\n     pub fn print_passes() {}\n     pub fn print(_req: PrintRequest, _sess: &Session) {}\n     pub fn target_features(_sess: &Session) -> Vec<Symbol> { vec![] }\n \n-    pub fn trans_crate<'a, 'tcx>(\n-        _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        _analysis: CrateAnalysis,\n-        _incr_hashes_map: IncrementalHashesMap,\n-        _output_filenames: &OutputFilenames\n-    ) -> OngoingCrateTranslation {\n-        OngoingCrateTranslation(())\n-    }\n-\n-    pub struct CrateTranslation(());\n-\n     pub mod back {\n         pub mod write {\n-            pub struct OngoingCrateTranslation(pub (in ::rustc_trans) ());\n-\n             pub const RELOC_MODEL_ARGS: [(&'static str, ()); 0] = [];\n             pub const CODE_GEN_MODEL_ARGS: [(&'static str, ()); 0] = [];\n         }\n     }\n-\n-    __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }\n }\n \n // Parse args and run the compiler. This is the primary entry point for rustc.\n@@ -293,7 +224,7 @@ pub fn run_compiler<'a>(args: &[String],\n         },\n     };\n \n-    let cstore = Rc::new(CStore::new(box ::MetadataLoader));\n+    let cstore = Rc::new(CStore::new(DefaultTransCrate::metadata_loader()));\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n@@ -1331,6 +1262,7 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     all_errors.extend_from_slice(&rustc_borrowck::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n+    #[cfg(feature=\"llvm\")]\n     all_errors.extend_from_slice(&rustc_trans::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_const_eval::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);"}, {"sha": "6de36820f0c19746508b8e849cec7888fa239251", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -30,6 +30,7 @@ use rustc::hir::map as hir_map;\n use rustc::mir::transform::Passes;\n use rustc::session::{self, config};\n use rustc::session::config::{OutputFilenames, OutputTypes};\n+use rustc_trans_utils::trans_crate::TransCrate;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n@@ -105,7 +106,7 @@ fn test_env<F>(source_string: &str,\n     options.unstable_features = UnstableFeatures::Allow;\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, emitter);\n \n-    let cstore = Rc::new(CStore::new(box ::MetadataLoader));\n+    let cstore = Rc::new(CStore::new(::DefaultTransCrate::metadata_loader()));\n     let sess = session::build_session_(options,\n                                        None,\n                                        diagnostic_handler,"}, {"sha": "1630e7759919ce2b957379f6bd687cbf74b01324", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 4, "deletions": 48, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate rustc_trans_utils;\n-\n use super::archive::{ArchiveBuilder, ArchiveConfig};\n use super::linker::Linker;\n use super::command::Command;\n@@ -20,14 +18,12 @@ use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType, Pri\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n-use rustc::ich::Fingerprint;\n-use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, NativeLibraryKind};\n+use rustc::middle::cstore::{NativeLibrary, LibSource, NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n use {CrateTranslation, CrateInfo};\n use rustc::util::common::time;\n use rustc::util::fs::fix_windows_verbatim_for_gcc;\n use rustc::hir::def_id::CrateNum;\n-use rustc::hir::svh::Svh;\n use rustc_back::tempdir::TempDir;\n use rustc_back::{PanicStrategy, RelroLevel};\n use context::get_reloc_model;\n@@ -88,16 +84,9 @@ pub const RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: usize =\n pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: usize =\n     RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n \n-pub use self::rustc_trans_utils::link::{find_crate_name, filename_for_input,\n-                                        default_output_for_target, invalid_output_for_target};\n-\n-pub fn build_link_meta(crate_hash: Fingerprint) -> LinkMeta {\n-    let r = LinkMeta {\n-        crate_hash: Svh::new(crate_hash.to_smaller_hash()),\n-    };\n-    info!(\"{:?}\", r);\n-    return r;\n-}\n+pub use rustc_trans_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n+                                  invalid_output_for_target, build_link_meta, out_filename,\n+                                  check_file_is_writeable};\n \n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n@@ -225,13 +214,6 @@ pub fn link_binary(sess: &Session,\n     out_filenames\n }\n \n-fn is_writeable(p: &Path) -> bool {\n-    match p.metadata() {\n-        Err(..) => true,\n-        Ok(m) => !m.permissions().readonly()\n-    }\n-}\n-\n fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilenames) -> PathBuf {\n     let out_filename = outputs.single_output_file.clone()\n         .unwrap_or(outputs\n@@ -295,32 +277,6 @@ pub fn ignored_for_lto(info: &CrateInfo, cnum: CrateNum) -> bool {\n     info.is_no_builtins.contains(&cnum) || info.compiler_builtins == Some(cnum)\n }\n \n-fn out_filename(sess: &Session,\n-                crate_type: config::CrateType,\n-                outputs: &OutputFilenames,\n-                crate_name: &str)\n-                -> PathBuf {\n-    let default_filename = filename_for_input(sess, crate_type, crate_name, outputs);\n-    let out_filename = outputs.outputs.get(&OutputType::Exe)\n-                              .and_then(|s| s.to_owned())\n-                              .or_else(|| outputs.single_output_file.clone())\n-                              .unwrap_or(default_filename);\n-\n-    check_file_is_writeable(&out_filename, sess);\n-\n-    out_filename\n-}\n-\n-// Make sure files are writeable.  Mac, FreeBSD, and Windows system linkers\n-// check this already -- however, the Linux linker will happily overwrite a\n-// read-only file.  We should be consistent.\n-fn check_file_is_writeable(file: &Path, sess: &Session) {\n-    if !is_writeable(file) {\n-        sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n-                            permissions\", file.display()));\n-    }\n-}\n-\n fn link_binary_output(sess: &Session,\n                       trans: &CrateTranslation,\n                       crate_type: config::CrateType,"}, {"sha": "2d01d2947d6eb2dfb607ed67f10ef62ccfc717d8", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -43,7 +43,6 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::dep_graph::{DepNode, DepKind};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n-use rustc::hir::map as hir_map;\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n@@ -95,6 +94,8 @@ use syntax::ast;\n \n use mir::lvalue::Alignment;\n \n+pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n+\n pub struct StatRecorder<'a, 'tcx: 'a> {\n     ccx: &'a CrateContext<'a, 'tcx>,\n     name: Option<String>,\n@@ -660,20 +661,6 @@ pub fn set_link_section(ccx: &CrateContext,\n     }\n }\n \n-// check for the #[rustc_error] annotation, which forces an\n-// error in trans. This is used to write compile-fail tests\n-// that actually test that compilation succeeds without\n-// reporting an error.\n-fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n-    if let Some((id, span)) = *tcx.sess.entry_fn.borrow() {\n-        let main_def_id = tcx.hir.local_def_id(id);\n-\n-        if tcx.has_attr(main_def_id, \"rustc_error\") {\n-            tcx.sess.span_fatal(span, \"compilation successful\");\n-        }\n-    }\n-}\n-\n /// Create the `main` function which will initialize the rust runtime and call\n /// users main function.\n fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n@@ -885,59 +872,10 @@ fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n     }\n }\n \n-/// The context provided lists a set of reachable ids as calculated by\n-/// middle::reachable, but this contains far more ids and symbols than we're\n-/// actually exposing from the object file. This function will filter the set in\n-/// the context to the set of ids which correspond to symbols that are exposed\n-/// from the object file being generated.\n-///\n-/// This list is later used by linkers to determine the set of symbols needed to\n-/// be exposed from a dynamic library and it's also encoded into the metadata.\n-pub fn find_exported_symbols(tcx: TyCtxt) -> NodeSet {\n-    tcx.reachable_set(LOCAL_CRATE).0.iter().cloned().filter(|&id| {\n-        // Next, we want to ignore some FFI functions that are not exposed from\n-        // this crate. Reachable FFI functions can be lumped into two\n-        // categories:\n-        //\n-        // 1. Those that are included statically via a static library\n-        // 2. Those included otherwise (e.g. dynamically or via a framework)\n-        //\n-        // Although our LLVM module is not literally emitting code for the\n-        // statically included symbols, it's an export of our library which\n-        // needs to be passed on to the linker and encoded in the metadata.\n-        //\n-        // As a result, if this id is an FFI item (foreign item) then we only\n-        // let it through if it's included statically.\n-        match tcx.hir.get(id) {\n-            hir_map::NodeForeignItem(..) => {\n-                let def_id = tcx.hir.local_def_id(id);\n-                tcx.is_statically_included_foreign_item(def_id)\n-            }\n-\n-            // Only consider nodes that actually have exported symbols.\n-            hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemStatic(..), .. }) |\n-            hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemFn(..), .. }) |\n-            hir_map::NodeImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Method(..), .. }) => {\n-                let def_id = tcx.hir.local_def_id(id);\n-                let generics = tcx.generics_of(def_id);\n-                let attributes = tcx.get_attrs(def_id);\n-                (generics.parent_types == 0 && generics.types.is_empty()) &&\n-                // Functions marked with #[inline] are only ever translated\n-                // with \"internal\" linkage and are never exported.\n-                !attr::requests_inline(&attributes)\n-            }\n-\n-            _ => false\n-        }\n-    }).collect()\n-}\n-\n pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              rx: mpsc::Receiver<Box<Any + Send>>)\n                              -> OngoingCrateTranslation {\n+\n     check_for_rustc_errors_attr(tcx);\n \n "}, {"sha": "8a2c478cea0615aab936703d3239029eee78bbc1", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -50,6 +50,7 @@ extern crate rustc_incremental;\n extern crate rustc_llvm as llvm;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_const_math;\n+extern crate rustc_trans_utils;\n extern crate rustc_demangle;\n extern crate jobserver;\n extern crate num_cpus;\n@@ -137,6 +138,63 @@ mod type_;\n mod type_of;\n mod value;\n \n+use std::sync::mpsc;\n+use std::any::Any;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::session::Session;\n+use rustc::session::config::OutputFilenames;\n+use rustc::middle::cstore::MetadataLoader;\n+use rustc::dep_graph::DepGraph;\n+\n+pub struct LlvmTransCrate(());\n+\n+impl LlvmTransCrate {\n+    pub fn new() -> Self {\n+        LlvmTransCrate(())\n+    }\n+}\n+\n+impl rustc_trans_utils::trans_crate::TransCrate for LlvmTransCrate {\n+    type MetadataLoader = metadata::LlvmMetadataLoader;\n+    type OngoingCrateTranslation = back::write::OngoingCrateTranslation;\n+    type TranslatedCrate = CrateTranslation;\n+\n+    fn metadata_loader() -> Box<MetadataLoader> {\n+        box metadata::LlvmMetadataLoader\n+    }\n+\n+    fn provide_local(providers: &mut ty::maps::Providers) {\n+        provide_local(providers);\n+    }\n+\n+    fn provide_extern(providers: &mut ty::maps::Providers) {\n+        provide_extern(providers);\n+    }\n+\n+    fn trans_crate<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        rx: mpsc::Receiver<Box<Any + Send>>\n+    ) -> Self::OngoingCrateTranslation {\n+        base::trans_crate(tcx, rx)\n+    }\n+\n+    fn join_trans(\n+        trans: Self::OngoingCrateTranslation,\n+        sess: &Session,\n+        dep_graph: &DepGraph\n+    ) -> Self::TranslatedCrate {\n+        trans.join(sess, dep_graph)\n+    }\n+\n+    fn link_binary(sess: &Session, trans: &Self::TranslatedCrate, outputs: &OutputFilenames) {\n+        back::link::link_binary(sess, trans, outputs, &trans.crate_name.as_str());\n+    }\n+\n+    fn dump_incremental_data(trans: &Self::TranslatedCrate) {\n+        back::write::dump_incremental_data(trans);\n+    }\n+}\n+\n pub struct ModuleTranslation {\n     /// The name of the module. When the crate may be saved between\n     /// compilations, incremental compilation requires that name be"}, {"sha": "bedbea0068874dd848b195ae9645e87cd51465ac", "filename": "src/librustc_trans_utils/Cargo.toml", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2FCargo.toml?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -10,6 +10,12 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n-rustc = { path = \"../librustc\" }\n+ar = \"0.3.0\"\n+flate2 = \"0.2\"\n+owning_ref = \"0.3.3\"\n+log = \"0.3\"\n+\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc = { path = \"../librustc\" }\n+rustc_back = { path = \"../librustc_back\" }"}, {"sha": "6873befd2bfcac5eb8b688d13d4d21944d8f4c10", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -29,8 +29,89 @@\n \n #![cfg_attr(stage0, feature(const_fn))]\n \n+extern crate ar;\n+extern crate flate2;\n+extern crate owning_ref;\n+#[macro_use]\n+extern crate log;\n+\n+#[macro_use]\n extern crate rustc;\n+extern crate rustc_back;\n extern crate syntax;\n extern crate syntax_pos;\n \n+use rustc::ty::TyCtxt;\n+use rustc::hir;\n+use rustc::hir::def_id::LOCAL_CRATE;\n+use rustc::hir::map as hir_map;\n+use rustc::util::nodemap::NodeSet;\n+\n+use syntax::attr;\n+\n pub mod link;\n+pub mod trans_crate;\n+\n+/// check for the #[rustc_error] annotation, which forces an\n+/// error in trans. This is used to write compile-fail tests\n+/// that actually test that compilation succeeds without\n+/// reporting an error.\n+pub fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n+    if let Some((id, span)) = *tcx.sess.entry_fn.borrow() {\n+        let main_def_id = tcx.hir.local_def_id(id);\n+\n+        if tcx.has_attr(main_def_id, \"rustc_error\") {\n+            tcx.sess.span_fatal(span, \"compilation successful\");\n+        }\n+    }\n+}\n+\n+/// The context provided lists a set of reachable ids as calculated by\n+/// middle::reachable, but this contains far more ids and symbols than we're\n+/// actually exposing from the object file. This function will filter the set in\n+/// the context to the set of ids which correspond to symbols that are exposed\n+/// from the object file being generated.\n+///\n+/// This list is later used by linkers to determine the set of symbols needed to\n+/// be exposed from a dynamic library and it's also encoded into the metadata.\n+pub fn find_exported_symbols(tcx: TyCtxt) -> NodeSet {\n+    tcx.reachable_set(LOCAL_CRATE).0.iter().cloned().filter(|&id| {\n+        // Next, we want to ignore some FFI functions that are not exposed from\n+        // this crate. Reachable FFI functions can be lumped into two\n+        // categories:\n+        //\n+        // 1. Those that are included statically via a static library\n+        // 2. Those included otherwise (e.g. dynamically or via a framework)\n+        //\n+        // Although our LLVM module is not literally emitting code for the\n+        // statically included symbols, it's an export of our library which\n+        // needs to be passed on to the linker and encoded in the metadata.\n+        //\n+        // As a result, if this id is an FFI item (foreign item) then we only\n+        // let it through if it's included statically.\n+        match tcx.hir.get(id) {\n+            hir_map::NodeForeignItem(..) => {\n+                let def_id = tcx.hir.local_def_id(id);\n+                tcx.is_statically_included_foreign_item(def_id)\n+            }\n+\n+            // Only consider nodes that actually have exported symbols.\n+            hir_map::NodeItem(&hir::Item {\n+                node: hir::ItemStatic(..), .. }) |\n+            hir_map::NodeItem(&hir::Item {\n+                node: hir::ItemFn(..), .. }) |\n+            hir_map::NodeImplItem(&hir::ImplItem {\n+                node: hir::ImplItemKind::Method(..), .. }) => {\n+                let def_id = tcx.hir.local_def_id(id);\n+                let generics = tcx.generics_of(def_id);\n+                let attributes = tcx.get_attrs(def_id);\n+                (generics.parent_types == 0 && generics.types.is_empty()) &&\n+                // Functions marked with #[inline] are only ever translated\n+                // with \"internal\" linkage and are never exported.\n+                !attr::requests_inline(&attributes)\n+            }\n+\n+            _ => false\n+        }\n+    }).collect()\n+}"}, {"sha": "47484488fb8e8792e92cb6e5015ed337b68f4d17", "filename": "src/librustc_trans_utils/link.rs", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flink.rs?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -8,13 +8,56 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::ich::Fingerprint;\n use rustc::session::config::{self, OutputFilenames, Input, OutputType};\n use rustc::session::Session;\n-use rustc::middle::cstore;\n-use std::path::PathBuf;\n+use rustc::middle::cstore::{self, LinkMeta};\n+use rustc::hir::svh::Svh;\n+use std::path::{Path, PathBuf};\n use syntax::ast;\n use syntax_pos::Span;\n \n+pub fn out_filename(sess: &Session,\n+                crate_type: config::CrateType,\n+                outputs: &OutputFilenames,\n+                crate_name: &str)\n+                -> PathBuf {\n+    let default_filename = filename_for_input(sess, crate_type, crate_name, outputs);\n+    let out_filename = outputs.outputs.get(&OutputType::Exe)\n+                              .and_then(|s| s.to_owned())\n+                              .or_else(|| outputs.single_output_file.clone())\n+                              .unwrap_or(default_filename);\n+\n+    check_file_is_writeable(&out_filename, sess);\n+\n+    out_filename\n+}\n+\n+// Make sure files are writeable.  Mac, FreeBSD, and Windows system linkers\n+// check this already -- however, the Linux linker will happily overwrite a\n+// read-only file.  We should be consistent.\n+pub fn check_file_is_writeable(file: &Path, sess: &Session) {\n+    if !is_writeable(file) {\n+        sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n+                            permissions\", file.display()));\n+    }\n+}\n+\n+fn is_writeable(p: &Path) -> bool {\n+    match p.metadata() {\n+        Err(..) => true,\n+        Ok(m) => !m.permissions().readonly()\n+    }\n+}\n+\n+pub fn build_link_meta(crate_hash: Fingerprint) -> LinkMeta {\n+    let r = LinkMeta {\n+        crate_hash: Svh::new(crate_hash.to_smaller_hash()),\n+    };\n+    info!(\"{:?}\", r);\n+    return r;\n+}\n+\n pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {"}, {"sha": "f51a463fcc23e86c30bb57335f4d5d9b78b58585", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3df1f7b82d9bede5122ee745cdd4e731abbce892/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=3df1f7b82d9bede5122ee745cdd4e731abbce892", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The Rust compiler.\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![deny(warnings)]\n+\n+#![feature(box_syntax)]\n+\n+use std::any::Any;\n+use std::io::prelude::*;\n+use std::io::{self, Cursor};\n+use std::fs::File;\n+use std::path::Path;\n+use std::sync::mpsc;\n+\n+use owning_ref::{ErasedBoxRef, OwningRef};\n+use ar::{Archive, Builder, Header};\n+use flate2::Compression;\n+use flate2::write::DeflateEncoder;\n+\n+use syntax::symbol::Symbol;\n+use rustc::hir::def_id::LOCAL_CRATE;\n+use rustc::session::Session;\n+use rustc::session::config::{CrateType, OutputFilenames};\n+use rustc::ty::TyCtxt;\n+use rustc::ty::maps::Providers;\n+use rustc::middle::cstore::EncodedMetadata;\n+use rustc::middle::cstore::MetadataLoader as MetadataLoaderTrait;\n+use rustc::dep_graph::{DepGraph, DepNode, DepKind};\n+use rustc_back::target::Target;\n+use link::{build_link_meta, out_filename};\n+\n+pub trait TransCrate {\n+    type MetadataLoader: MetadataLoaderTrait;\n+    type OngoingCrateTranslation;\n+    type TranslatedCrate;\n+\n+    fn metadata_loader() -> Box<MetadataLoaderTrait>;\n+    fn provide_local(_providers: &mut Providers);\n+    fn provide_extern(_providers: &mut Providers);\n+    fn trans_crate<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        rx: mpsc::Receiver<Box<Any + Send>>\n+    ) -> Self::OngoingCrateTranslation;\n+    fn join_trans(\n+        trans: Self::OngoingCrateTranslation,\n+        sess: &Session,\n+        dep_graph: &DepGraph\n+    ) -> Self::TranslatedCrate;\n+    fn link_binary(sess: &Session, trans: &Self::TranslatedCrate, outputs: &OutputFilenames);\n+    fn dump_incremental_data(trans: &Self::TranslatedCrate);\n+}\n+\n+pub struct DummyTransCrate;\n+\n+impl TransCrate for DummyTransCrate {\n+    type MetadataLoader = DummyMetadataLoader;\n+    type OngoingCrateTranslation = ();\n+    type TranslatedCrate = ();\n+\n+    fn metadata_loader() -> Box<MetadataLoaderTrait> {\n+        box DummyMetadataLoader(())\n+    }\n+\n+    fn provide_local(_providers: &mut Providers) {\n+        bug!(\"DummyTransCrate::provide_local\");\n+    }\n+\n+    fn provide_extern(_providers: &mut Providers) {\n+        bug!(\"DummyTransCrate::provide_extern\");\n+    }\n+\n+    fn trans_crate<'a, 'tcx>(\n+        _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        _rx: mpsc::Receiver<Box<Any + Send>>\n+    ) -> Self::OngoingCrateTranslation {\n+        bug!(\"DummyTransCrate::trans_crate\");\n+    }\n+\n+    fn join_trans(\n+        _trans: Self::OngoingCrateTranslation,\n+        _sess: &Session,\n+        _dep_graph: &DepGraph\n+    ) -> Self::TranslatedCrate {\n+        bug!(\"DummyTransCrate::join_trans\");\n+    }\n+\n+    fn link_binary(_sess: &Session, _trans: &Self::TranslatedCrate, _outputs: &OutputFilenames) {\n+        bug!(\"DummyTransCrate::link_binary\");\n+    }\n+\n+    fn dump_incremental_data(_trans: &Self::TranslatedCrate) {\n+        bug!(\"DummyTransCrate::dump_incremental_data\");\n+    }\n+}\n+\n+pub struct DummyMetadataLoader(());\n+\n+impl MetadataLoaderTrait for DummyMetadataLoader {\n+    fn get_rlib_metadata(\n+        &self,\n+        _target: &Target,\n+        _filename: &Path\n+    ) -> Result<ErasedBoxRef<[u8]>, String> {\n+        bug!(\"DummyMetadataLoader::get_rlib_metadata\");\n+    }\n+\n+    fn get_dylib_metadata(\n+        &self,\n+        _target: &Target,\n+        _filename: &Path\n+    ) -> Result<ErasedBoxRef<[u8]>, String> {\n+        bug!(\"DummyMetadataLoader::get_dylib_metadata\");\n+    }\n+}\n+\n+pub struct NoLlvmMetadataLoader;\n+\n+impl MetadataLoaderTrait for NoLlvmMetadataLoader {\n+    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<ErasedBoxRef<[u8]>, String> {\n+        let file = File::open(filename)\n+            .map_err(|e| format!(\"metadata file open err: {:?}\", e))?;\n+        let mut archive = Archive::new(file);\n+\n+        while let Some(entry_result) = archive.next_entry() {\n+            let mut entry = entry_result\n+                .map_err(|e| format!(\"metadata section read err: {:?}\", e))?;\n+            if entry.header().identifier() == \"rust.metadata.bin\" {\n+                let mut buf = Vec::new();\n+                io::copy(&mut entry, &mut buf).unwrap();\n+                let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n+                return Ok(buf.map_owner_box().erase_owner());\n+            }\n+        }\n+\n+        Err(\"Couldnt find metadata section\".to_string())\n+    }\n+\n+    fn get_dylib_metadata(\n+        &self,\n+        _target: &Target,\n+        _filename: &Path,\n+    ) -> Result<ErasedBoxRef<[u8]>, String> {\n+        // FIXME: Support reading dylibs from llvm enabled rustc\n+        self.get_rlib_metadata(_target, _filename)\n+    }\n+}\n+\n+pub struct MetadataOnlyTransCrate;\n+pub struct OngoingCrateTranslation {\n+    metadata: EncodedMetadata,\n+    metadata_version: Vec<u8>,\n+    crate_name: Symbol,\n+}\n+pub struct TranslatedCrate(OngoingCrateTranslation);\n+\n+impl MetadataOnlyTransCrate {\n+    #[allow(dead_code)]\n+    pub fn new() -> Self {\n+        MetadataOnlyTransCrate\n+    }\n+}\n+\n+impl TransCrate for MetadataOnlyTransCrate {\n+    type MetadataLoader = NoLlvmMetadataLoader;\n+    type OngoingCrateTranslation = OngoingCrateTranslation;\n+    type TranslatedCrate = TranslatedCrate;\n+\n+    fn metadata_loader() -> Box<MetadataLoaderTrait> {\n+        box NoLlvmMetadataLoader\n+    }\n+\n+    fn provide_local(_providers: &mut Providers) {}\n+    fn provide_extern(_providers: &mut Providers) {}\n+\n+    fn trans_crate<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        _rx: mpsc::Receiver<Box<Any + Send>>\n+    ) -> Self::OngoingCrateTranslation {\n+        ::check_for_rustc_errors_attr(tcx);\n+        let _ = tcx.link_args(LOCAL_CRATE);\n+        let _ = tcx.native_libraries(LOCAL_CRATE);\n+        tcx.sess.abort_if_errors();\n+\n+        let crate_hash = tcx.dep_graph\n+                        .fingerprint_of(&DepNode::new_no_params(DepKind::Krate));\n+        let link_meta = build_link_meta(crate_hash);\n+        let exported_symbols = ::find_exported_symbols(tcx);\n+        let (metadata, _hashes) = tcx.encode_metadata(&link_meta, &exported_symbols);\n+\n+        OngoingCrateTranslation {\n+            metadata: metadata,\n+            metadata_version: tcx.metadata_encoding_version().to_vec(),\n+            crate_name: tcx.crate_name(LOCAL_CRATE),\n+        }\n+    }\n+\n+    fn join_trans(\n+        trans: Self::OngoingCrateTranslation,\n+        _sess: &Session,\n+        _dep_graph: &DepGraph,\n+    ) -> Self::TranslatedCrate {\n+        TranslatedCrate(trans)\n+    }\n+\n+    fn link_binary(sess: &Session, trans: &Self::TranslatedCrate, outputs: &OutputFilenames) {\n+        for &crate_type in sess.opts.crate_types.iter() {\n+            if crate_type != CrateType::CrateTypeRlib && crate_type != CrateType::CrateTypeDylib {\n+                continue;\n+            }\n+            let output_name =\n+                out_filename(sess, crate_type, &outputs, &trans.0.crate_name.as_str());\n+            let mut compressed = trans.0.metadata_version.clone();\n+            let metadata = if crate_type == CrateType::CrateTypeDylib {\n+                DeflateEncoder::new(&mut compressed, Compression::Fast)\n+                    .write_all(&trans.0.metadata.raw_data)\n+                    .unwrap();\n+                &compressed\n+            } else {\n+                &trans.0.metadata.raw_data\n+            };\n+            let mut builder = Builder::new(File::create(&output_name).unwrap());\n+            let header = Header::new(\"rust.metadata.bin\".to_string(), metadata.len() as u64);\n+            builder.append(&header, Cursor::new(metadata)).unwrap();\n+        }\n+\n+        if !sess.opts.crate_types.contains(&CrateType::CrateTypeRlib)\n+            && !sess.opts.crate_types.contains(&CrateType::CrateTypeDylib) {\n+            sess.fatal(\"Executables are not supported by the metadata-only backend.\");\n+        }\n+    }\n+\n+    fn dump_incremental_data(_trans: &Self::TranslatedCrate) {}\n+}"}]}