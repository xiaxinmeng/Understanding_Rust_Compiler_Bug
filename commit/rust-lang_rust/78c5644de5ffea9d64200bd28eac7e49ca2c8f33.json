{"sha": "78c5644de5ffea9d64200bd28eac7e49ca2c8f33", "node_id": "C_kwDOAAsO6NoAKDc4YzU2NDRkZTVmZmVhOWQ2NDIwMGJkMjhlYWM3ZTQ5Y2EyYzhmMzM", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-12-20T23:50:31Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:30Z"}, "message": "drop_ranges: Add TrackedValue enum\n\nThis makes it clearer what values we are tracking and why.", "tree": {"sha": "c033956a2e8a4cc4d224d5b51e8c2bcca005dbf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c033956a2e8a4cc4d224d5b51e8c2bcca005dbf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78c5644de5ffea9d64200bd28eac7e49ca2c8f33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78c5644de5ffea9d64200bd28eac7e49ca2c8f33", "html_url": "https://github.com/rust-lang/rust/commit/78c5644de5ffea9d64200bd28eac7e49ca2c8f33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78c5644de5ffea9d64200bd28eac7e49ca2c8f33/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "887e843eeb35e9cc78884e9d5feacf914377f355", "url": "https://api.github.com/repos/rust-lang/rust/commits/887e843eeb35e9cc78884e9d5feacf914377f355", "html_url": "https://github.com/rust-lang/rust/commit/887e843eeb35e9cc78884e9d5feacf914377f355"}], "stats": {"total": 173, "additions": 106, "deletions": 67}, "files": [{"sha": "681cd7cf935f53646b7cf9d4d420ff7fd41fdf1b", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/78c5644de5ffea9d64200bd28eac7e49ca2c8f33/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78c5644de5ffea9d64200bd28eac7e49ca2c8f33/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=78c5644de5ffea9d64200bd28eac7e49ca2c8f33", "patch": "@@ -17,9 +17,12 @@ use self::record_consumed_borrow::find_consumed_and_borrowed;\n use crate::check::FnCtxt;\n use hir::def_id::DefId;\n use hir::{Body, HirId, HirIdMap, Node};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n+use rustc_middle::ty;\n use std::collections::BTreeMap;\n use std::fmt::Debug;\n \n@@ -47,21 +50,25 @@ pub fn compute_drop_ranges<'a, 'tcx>(\n \n     drop_ranges.propagate_to_fixpoint();\n \n-    DropRanges { hir_id_map: drop_ranges.hir_id_map, nodes: drop_ranges.nodes }\n+    DropRanges { tracked_value_map: drop_ranges.tracked_value_map, nodes: drop_ranges.nodes }\n }\n \n /// Applies `f` to consumable portion of a HIR node.\n ///\n /// The `node` parameter should be the result of calling `Map::find(place)`.\n-fn for_each_consumable(place: HirId, node: Option<Node<'_>>, mut f: impl FnMut(HirId)) {\n+fn for_each_consumable(\n+    place: TrackedValue,\n+    node: Option<Node<'_>>,\n+    mut f: impl FnMut(TrackedValue),\n+) {\n     f(place);\n     if let Some(Node::Expr(expr)) = node {\n         match expr.kind {\n             hir::ExprKind::Path(hir::QPath::Resolved(\n                 _,\n                 hir::Path { res: hir::def::Res::Local(hir_id), .. },\n             )) => {\n-                f(*hir_id);\n+                f(TrackedValue::Variable(*hir_id));\n             }\n             _ => (),\n         }\n@@ -75,22 +82,60 @@ rustc_index::newtype_index! {\n }\n \n rustc_index::newtype_index! {\n-    pub struct HirIdIndex {\n+    pub struct TrackedValueIndex {\n         DEBUG_FORMAT = \"hidx({})\",\n     }\n }\n \n+/// Identifies a value whose drop state we need to track.\n+#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\n+enum TrackedValue {\n+    /// Represents a named variable, such as a let binding, parameter, or upvar.\n+    ///\n+    /// The HirId points to the variable's definition site.\n+    Variable(HirId),\n+    /// A value produced as a result of an expression.\n+    ///\n+    /// The HirId points to the expression that returns this value.\n+    Temporary(HirId),\n+}\n+\n+impl TrackedValue {\n+    fn hir_id(&self) -> HirId {\n+        match self {\n+            TrackedValue::Variable(hir_id) | TrackedValue::Temporary(hir_id) => *hir_id,\n+        }\n+    }\n+}\n+\n+impl From<&PlaceWithHirId<'_>> for TrackedValue {\n+    fn from(place_with_id: &PlaceWithHirId<'_>) -> Self {\n+        match place_with_id.place.base {\n+            PlaceBase::Rvalue | PlaceBase::StaticItem => {\n+                TrackedValue::Temporary(place_with_id.hir_id)\n+            }\n+            PlaceBase::Local(hir_id)\n+            | PlaceBase::Upvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id }, .. }) => {\n+                TrackedValue::Variable(hir_id)\n+            }\n+        }\n+    }\n+}\n+\n pub struct DropRanges {\n-    hir_id_map: HirIdMap<HirIdIndex>,\n+    tracked_value_map: FxHashMap<TrackedValue, TrackedValueIndex>,\n     nodes: IndexVec<PostOrderId, NodeInfo>,\n }\n \n impl DropRanges {\n     pub fn is_dropped_at(&self, hir_id: HirId, location: usize) -> bool {\n-        self.hir_id_map\n-            .get(&hir_id)\n-            .copied()\n-            .map_or(false, |hir_id| self.expect_node(location.into()).drop_state.contains(hir_id))\n+        self.tracked_value_map\n+            .get(&TrackedValue::Temporary(hir_id))\n+            .or(self.tracked_value_map.get(&TrackedValue::Variable(hir_id)))\n+            .cloned()\n+            .map_or(false, |tracked_value_id| {\n+                self.expect_node(location.into()).drop_state.contains(tracked_value_id)\n+            })\n     }\n \n     /// Returns a reference to the NodeInfo for a node, panicking if it does not exist\n@@ -118,7 +163,7 @@ struct DropRangesBuilder {\n     /// (see NodeInfo::drop_state). The hir_id_map field stores the mapping\n     /// from HirIds to the HirIdIndex that is used to represent that value in\n     /// bitvector.\n-    hir_id_map: HirIdMap<HirIdIndex>,\n+    tracked_value_map: FxHashMap<TrackedValue, TrackedValueIndex>,\n \n     /// When building the control flow graph, we don't always know the\n     /// post-order index of the target node at the point we encounter it.\n@@ -138,7 +183,7 @@ struct DropRangesBuilder {\n impl Debug for DropRangesBuilder {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         f.debug_struct(\"DropRanges\")\n-            .field(\"hir_id_map\", &self.hir_id_map)\n+            .field(\"hir_id_map\", &self.tracked_value_map)\n             .field(\"post_order_maps\", &self.post_order_map)\n             .field(\"nodes\", &self.nodes.iter_enumerated().collect::<BTreeMap<_, _>>())\n             .finish()\n@@ -154,7 +199,7 @@ impl Debug for DropRangesBuilder {\n impl DropRangesBuilder {\n     /// Returns the number of values (hir_ids) that are tracked\n     fn num_values(&self) -> usize {\n-        self.hir_id_map.len()\n+        self.tracked_value_map.len()\n     }\n \n     fn node_mut(&mut self, id: PostOrderId) -> &mut NodeInfo {\n@@ -177,13 +222,13 @@ struct NodeInfo {\n     successors: Vec<PostOrderId>,\n \n     /// List of hir_ids that are dropped by this node.\n-    drops: Vec<HirIdIndex>,\n+    drops: Vec<TrackedValueIndex>,\n \n     /// List of hir_ids that are reinitialized by this node.\n-    reinits: Vec<HirIdIndex>,\n+    reinits: Vec<TrackedValueIndex>,\n \n     /// Set of values that are definitely dropped at this point.\n-    drop_state: BitSet<HirIdIndex>,\n+    drop_state: BitSet<TrackedValueIndex>,\n }\n \n impl NodeInfo {"}, {"sha": "dfe8ed54b21928f5a821b04522f65a5633416bdb", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/78c5644de5ffea9d64200bd28eac7e49ca2c8f33/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78c5644de5ffea9d64200bd28eac7e49ca2c8f33/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=78c5644de5ffea9d64200bd28eac7e49ca2c8f33", "patch": "@@ -1,11 +1,12 @@\n use super::{\n     for_each_consumable, record_consumed_borrow::ConsumedAndBorrowedPlaces, DropRangesBuilder,\n-    HirIdIndex, NodeInfo, PostOrderId,\n+    NodeInfo, PostOrderId, TrackedValue, TrackedValueIndex,\n };\n use hir::{\n     intravisit::{self, NestedVisitorMap, Visitor},\n-    Body, Expr, ExprKind, Guard, HirId, HirIdMap,\n+    Body, Expr, ExprKind, Guard, HirId,\n };\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_index::vec::IndexVec;\n use rustc_middle::{\n@@ -61,20 +62,20 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n     ) -> Self {\n         debug!(\"consumed_places: {:?}\", places.consumed);\n         let drop_ranges = DropRangesBuilder::new(\n-            places.consumed.iter().flat_map(|(_, places)| places.iter().copied()),\n+            places.consumed.iter().flat_map(|(_, places)| places.iter().cloned()),\n             hir,\n             num_exprs,\n         );\n         Self { hir, places, drop_ranges, expr_index: PostOrderId::from_u32(0), typeck_results, tcx }\n     }\n \n-    fn record_drop(&mut self, hir_id: HirId) {\n-        if self.places.borrowed.contains(&hir_id) {\n-            debug!(\"not marking {:?} as dropped because it is borrowed at some point\", hir_id);\n+    fn record_drop(&mut self, value: TrackedValue) {\n+        if self.places.borrowed.contains(&value) {\n+            debug!(\"not marking {:?} as dropped because it is borrowed at some point\", value);\n         } else {\n-            debug!(\"marking {:?} as dropped at {:?}\", hir_id, self.expr_index);\n+            debug!(\"marking {:?} as dropped at {:?}\", value, self.expr_index);\n             let count = self.expr_index;\n-            self.drop_ranges.drop_at(hir_id, count);\n+            self.drop_ranges.drop_at(value, count);\n         }\n     }\n \n@@ -88,7 +89,9 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n             .get(&expr.hir_id)\n             .map_or(vec![], |places| places.iter().cloned().collect());\n         for place in places {\n-            for_each_consumable(place, self.hir.find(place), |hir_id| self.record_drop(hir_id));\n+            for_each_consumable(place, self.hir.find(place.hir_id()), |value| {\n+                self.record_drop(value)\n+            });\n         }\n     }\n \n@@ -100,7 +103,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n         {\n             let location = self.expr_index;\n             debug!(\"reinitializing {:?} at {:?}\", hir_id, location);\n-            self.drop_ranges.reinit_at(*hir_id, location);\n+            self.drop_ranges.reinit_at(TrackedValue::Variable(*hir_id), location);\n         } else {\n             debug!(\"reinitializing {:?} is not supported\", expr);\n         }\n@@ -264,36 +267,40 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n }\n \n impl DropRangesBuilder {\n-    fn new(hir_ids: impl Iterator<Item = HirId>, hir: Map<'_>, num_exprs: usize) -> Self {\n-        let mut hir_id_map = HirIdMap::<HirIdIndex>::default();\n+    fn new(\n+        tracked_values: impl Iterator<Item = TrackedValue>,\n+        hir: Map<'_>,\n+        num_exprs: usize,\n+    ) -> Self {\n+        let mut tracked_value_map = FxHashMap::<_, TrackedValueIndex>::default();\n         let mut next = <_>::from(0u32);\n-        for hir_id in hir_ids {\n-            for_each_consumable(hir_id, hir.find(hir_id), |hir_id| {\n-                if !hir_id_map.contains_key(&hir_id) {\n-                    hir_id_map.insert(hir_id, next);\n-                    next = <_>::from(next.index() + 1);\n+        for value in tracked_values {\n+            for_each_consumable(value, hir.find(value.hir_id()), |value| {\n+                if !tracked_value_map.contains_key(&value) {\n+                    tracked_value_map.insert(value, next);\n+                    next = next + 1;\n                 }\n             });\n         }\n-        debug!(\"hir_id_map: {:?}\", hir_id_map);\n-        let num_values = hir_id_map.len();\n+        debug!(\"hir_id_map: {:?}\", tracked_value_map);\n+        let num_values = tracked_value_map.len();\n         Self {\n-            hir_id_map,\n+            tracked_value_map,\n             nodes: IndexVec::from_fn_n(|_| NodeInfo::new(num_values), num_exprs + 1),\n             deferred_edges: <_>::default(),\n             post_order_map: <_>::default(),\n         }\n     }\n \n-    fn hidx(&self, hir_id: HirId) -> HirIdIndex {\n-        *self.hir_id_map.get(&hir_id).unwrap()\n+    fn tracked_value_index(&self, tracked_value: TrackedValue) -> TrackedValueIndex {\n+        *self.tracked_value_map.get(&tracked_value).unwrap()\n     }\n \n     /// Adds an entry in the mapping from HirIds to PostOrderIds\n     ///\n     /// Needed so that `add_control_edge_hir_id` can work.\n-    fn add_node_mapping(&mut self, hir_id: HirId, post_order_id: PostOrderId) {\n-        self.post_order_map.insert(hir_id, post_order_id);\n+    fn add_node_mapping(&mut self, node_hir_id: HirId, post_order_id: PostOrderId) {\n+        self.post_order_map.insert(node_hir_id, post_order_id);\n     }\n \n     /// Like add_control_edge, but uses a hir_id as the target.\n@@ -304,13 +311,13 @@ impl DropRangesBuilder {\n         self.deferred_edges.push((from, to));\n     }\n \n-    fn drop_at(&mut self, value: HirId, location: PostOrderId) {\n-        let value = self.hidx(value);\n+    fn drop_at(&mut self, value: TrackedValue, location: PostOrderId) {\n+        let value = self.tracked_value_index(value);\n         self.node_mut(location.into()).drops.push(value);\n     }\n \n-    fn reinit_at(&mut self, value: HirId, location: PostOrderId) {\n-        let value = match self.hir_id_map.get(&value) {\n+    fn reinit_at(&mut self, value: TrackedValue, location: PostOrderId) {\n+        let value = match self.tracked_value_map.get(&value) {\n             Some(value) => *value,\n             // If there's no value, this is never consumed and therefore is never dropped. We can\n             // ignore this."}, {"sha": "2548b608092810a4444ec3f2a7ce86d1755338d3", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/78c5644de5ffea9d64200bd28eac7e49ca2c8f33/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78c5644de5ffea9d64200bd28eac7e49ca2c8f33/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=78c5644de5ffea9d64200bd28eac7e49ca2c8f33", "patch": "@@ -1,16 +1,14 @@\n+use super::TrackedValue;\n use crate::{\n     check::FnCtxt,\n     expr_use_visitor::{self, ExprUseVisitor},\n };\n-use hir::{def_id::DefId, Body, HirId, HirIdMap, HirIdSet};\n+use hir::{def_id::DefId, Body, HirId, HirIdMap};\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_hir as hir;\n-use rustc_middle::hir::{\n-    map::Map,\n-    place::{Place, PlaceBase},\n-};\n-use rustc_middle::ty;\n+use rustc_middle::hir::map::Map;\n \n-pub fn find_consumed_and_borrowed<'a, 'tcx>(\n+pub(super) fn find_consumed_and_borrowed<'a, 'tcx>(\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     def_id: DefId,\n     body: &'tcx Body<'tcx>,\n@@ -20,17 +18,17 @@ pub fn find_consumed_and_borrowed<'a, 'tcx>(\n     expr_use_visitor.places\n }\n \n-pub struct ConsumedAndBorrowedPlaces {\n+pub(super) struct ConsumedAndBorrowedPlaces {\n     /// Records the variables/expressions that are dropped by a given expression.\n     ///\n     /// The key is the hir-id of the expression, and the value is a set or hir-ids for variables\n     /// or values that are consumed by that expression.\n     ///\n     /// Note that this set excludes \"partial drops\" -- for example, a statement like `drop(x.y)` is\n     /// not considered a drop of `x`, although it would be a drop of `x.y`.\n-    pub consumed: HirIdMap<HirIdSet>,\n+    pub(super) consumed: HirIdMap<FxHashSet<TrackedValue>>,\n     /// A set of hir-ids of values or variables that are borrowed at some point within the body.\n-    pub borrowed: HirIdSet,\n+    pub(super) borrowed: FxHashSet<TrackedValue>,\n }\n \n /// Works with ExprUseVisitor to find interesting values for the drop range analysis.\n@@ -65,7 +63,7 @@ impl<'tcx> ExprUseDelegate<'tcx> {\n         .consume_body(body);\n     }\n \n-    fn mark_consumed(&mut self, consumer: HirId, target: HirId) {\n+    fn mark_consumed(&mut self, consumer: HirId, target: TrackedValue) {\n         if !self.places.consumed.contains_key(&consumer) {\n             self.places.consumed.insert(consumer, <_>::default());\n         }\n@@ -87,8 +85,7 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n             \"consume {:?}; diag_expr_id={:?}, using parent {:?}\",\n             place_with_id, diag_expr_id, parent\n         );\n-        self.mark_consumed(parent, place_with_id.hir_id);\n-        place_hir_id(&place_with_id.place).map(|place| self.mark_consumed(parent, place));\n+        self.mark_consumed(parent, place_with_id.into());\n     }\n \n     fn borrow(\n@@ -97,7 +94,7 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n         _diag_expr_id: HirId,\n         _bk: rustc_middle::ty::BorrowKind,\n     ) {\n-        place_hir_id(&place_with_id.place).map(|place| self.places.borrowed.insert(place));\n+        self.places.borrowed.insert(place_with_id.into());\n     }\n \n     fn mutate(\n@@ -115,13 +112,3 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n     ) {\n     }\n }\n-\n-/// Gives the hir_id associated with a place if one exists. This is the hir_id that we want to\n-/// track for a value in the drop range analysis.\n-fn place_hir_id(place: &Place<'_>) -> Option<HirId> {\n-    match place.base {\n-        PlaceBase::Rvalue | PlaceBase::StaticItem => None,\n-        PlaceBase::Local(hir_id)\n-        | PlaceBase::Upvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id }, .. }) => Some(hir_id),\n-    }\n-}"}]}