{"sha": "e1bda6aeda084e6e913b80959dbf6ce6260d1db2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxYmRhNmFlZGEwODRlNmU5MTNiODA5NTlkYmY2Y2U2MjYwZDFkYjI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-31T17:14:54Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-31T17:14:54Z"}, "message": "move completed requests to a separate file", "tree": {"sha": "d4bf2c513923892abf7ee709362bfdda5d677f14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4bf2c513923892abf7ee709362bfdda5d677f14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1bda6aeda084e6e913b80959dbf6ce6260d1db2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1bda6aeda084e6e913b80959dbf6ce6260d1db2", "html_url": "https://github.com/rust-lang/rust/commit/e1bda6aeda084e6e913b80959dbf6ce6260d1db2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1bda6aeda084e6e913b80959dbf6ce6260d1db2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "838915c9a29987f7c62abfdc6ae0664c21de4b7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/838915c9a29987f7c62abfdc6ae0664c21de4b7f", "html_url": "https://github.com/rust-lang/rust/commit/838915c9a29987f7c62abfdc6ae0664c21de4b7f"}], "stats": {"total": 194, "additions": 114, "deletions": 80}, "files": [{"sha": "e3cae94f44f5a05f3e2d45168e063923ffba0fbc", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 27, "deletions": 43, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e1bda6aeda084e6e913b80959dbf6ce6260d1db2/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1bda6aeda084e6e913b80959dbf6ce6260d1db2/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=e1bda6aeda084e6e913b80959dbf6ce6260d1db2", "patch": "@@ -1,5 +1,6 @@\n mod handlers;\n mod subscriptions;\n+pub(crate) mod pending_requests;\n \n use std::{fmt, path::PathBuf, sync::Arc, time::Instant, any::TypeId};\n \n@@ -12,16 +13,18 @@ use gen_lsp_server::{\n use lsp_types::NumberOrString;\n use ra_ide_api::{Canceled, FileId, LibraryData};\n use ra_vfs::VfsTask;\n-use rustc_hash::FxHashMap;\n use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n use ra_prof::profile;\n \n use crate::{\n-    main_loop::subscriptions::Subscriptions,\n+    main_loop::{\n+        subscriptions::Subscriptions,\n+        pending_requests::{PendingRequests, PendingRequest},\n+    },\n     project_model::workspace_loader,\n     req,\n-    server_world::{ServerWorld, ServerWorldState, CompletedRequest},\n+    server_world::{ServerWorld, ServerWorldState},\n     Result,\n     InitializationOptions,\n };\n@@ -42,37 +45,12 @@ impl LspError {\n     }\n }\n \n-#[derive(Debug)]\n-enum Task {\n-    Respond(RawResponse),\n-    Notify(RawNotification),\n-}\n-\n-struct PendingRequest {\n-    id: u64,\n-    received: Instant,\n-    method: String,\n-}\n-\n-impl From<PendingRequest> for CompletedRequest {\n-    fn from(pending: PendingRequest) -> CompletedRequest {\n-        CompletedRequest {\n-            id: pending.id,\n-            method: pending.method,\n-            duration: pending.received.elapsed(),\n-        }\n-    }\n-}\n-\n pub fn main_loop(\n     ws_roots: Vec<PathBuf>,\n     options: InitializationOptions,\n     msg_receiver: &Receiver<RawMessage>,\n     msg_sender: &Sender<RawMessage>,\n ) -> Result<()> {\n-    let pool = ThreadPool::new(THREADPOOL_SIZE);\n-    let (task_sender, task_receiver) = unbounded::<Task>();\n-\n     // FIXME: support dynamic workspace loading.\n     let workspaces = {\n         let ws_worker = workspace_loader();\n@@ -97,10 +75,12 @@ pub fn main_loop(\n \n     let mut state = ServerWorldState::new(ws_roots, workspaces);\n \n-    log::info!(\"server initialized, serving requests\");\n+    let pool = ThreadPool::new(THREADPOOL_SIZE);\n+    let (task_sender, task_receiver) = unbounded::<Task>();\n+    let mut pending_requests = PendingRequests::default();\n+    let mut subs = Subscriptions::default();\n \n-    let mut pending_requests = FxHashMap::default();\n-    let mut subs = Subscriptions::new();\n+    log::info!(\"server initialized, serving requests\");\n     let main_res = main_loop_inner(\n         options,\n         &pool,\n@@ -128,6 +108,12 @@ pub fn main_loop(\n     main_res\n }\n \n+#[derive(Debug)]\n+enum Task {\n+    Respond(RawResponse),\n+    Notify(RawNotification),\n+}\n+\n enum Event {\n     Msg(RawMessage),\n     Task(Task),\n@@ -178,7 +164,7 @@ fn main_loop_inner(\n     task_sender: Sender<Task>,\n     task_receiver: Receiver<Task>,\n     state: &mut ServerWorldState,\n-    pending_requests: &mut FxHashMap<u64, PendingRequest>,\n+    pending_requests: &mut PendingRequests,\n     subs: &mut Subscriptions,\n ) -> Result<()> {\n     // We try not to index more than MAX_IN_FLIGHT_LIBS libraries at the same\n@@ -202,15 +188,16 @@ fn main_loop_inner(\n             },\n             recv(libdata_receiver) -> data => Event::Lib(data.unwrap())\n         };\n-        // NOTE: don't count blocking select! call as a loop-turn time\n-        let _p = profile(\"main_loop_inner/loop-turn\");\n         let loop_start = Instant::now();\n \n+        // NOTE: don't count blocking select! call as a loop-turn time\n+        let _p = profile(\"main_loop_inner/loop-turn\");\n         log::info!(\"loop turn = {:?}\", event);\n         let queue_count = pool.queued_count();\n         if queue_count > 0 {\n             log::info!(\"queued count = {}\", queue_count);\n         }\n+\n         let mut state_changed = false;\n         match event {\n             Event::Task(task) => {\n@@ -311,13 +298,12 @@ fn main_loop_inner(\n fn on_task(\n     task: Task,\n     msg_sender: &Sender<RawMessage>,\n-    pending_requests: &mut FxHashMap<u64, PendingRequest>,\n+    pending_requests: &mut PendingRequests,\n     state: &mut ServerWorldState,\n ) {\n     match task {\n         Task::Respond(response) => {\n-            if let Some(pending) = pending_requests.remove(&response.id) {\n-                let completed = CompletedRequest::from(pending);\n+            if let Some(completed) = pending_requests.finish(response.id) {\n                 log::info!(\"handled req#{} in {:?}\", completed.id, completed.duration);\n                 state.complete_request(completed);\n                 msg_sender.send(response.into()).unwrap();\n@@ -331,7 +317,7 @@ fn on_task(\n \n fn on_request(\n     world: &mut ServerWorldState,\n-    pending_requests: &mut FxHashMap<u64, PendingRequest>,\n+    pending_requests: &mut PendingRequests,\n     pool: &ThreadPool,\n     sender: &Sender<Task>,\n     request_received: Instant,\n@@ -371,9 +357,7 @@ fn on_request(\n         .finish();\n     match req {\n         Ok(id) => {\n-            let prev = pending_requests\n-                .insert(id, PendingRequest { id, method, received: request_received });\n-            assert!(prev.is_none(), \"duplicate request: {}\", id);\n+            pending_requests.start(PendingRequest { id, method, received: request_received });\n             Ok(None)\n         }\n         Err(req) => Ok(Some(req)),\n@@ -383,7 +367,7 @@ fn on_request(\n fn on_notification(\n     msg_sender: &Sender<RawMessage>,\n     state: &mut ServerWorldState,\n-    pending_requests: &mut FxHashMap<u64, PendingRequest>,\n+    pending_requests: &mut PendingRequests,\n     subs: &mut Subscriptions,\n     not: RawNotification,\n ) -> Result<()> {\n@@ -395,7 +379,7 @@ fn on_notification(\n                     panic!(\"string id's not supported: {:?}\", id);\n                 }\n             };\n-            if pending_requests.remove(&id).is_some() {\n+            if pending_requests.cancel(id) {\n                 let response = RawResponse::err(\n                     id,\n                     ErrorCode::RequestCanceled as i32,"}, {"sha": "8cfb6a1925a2b28d8353b481bb7bf16d4fb1dc03", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1bda6aeda084e6e913b80959dbf6ce6260d1db2/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1bda6aeda084e6e913b80959dbf6ce6260d1db2/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=e1bda6aeda084e6e913b80959dbf6ce6260d1db2", "patch": "@@ -31,10 +31,10 @@ use crate::{\n pub fn handle_analyzer_status(world: ServerWorld, _: ()) -> Result<String> {\n     let mut buf = world.status();\n     writeln!(buf, \"\\n\\nrequests:\").unwrap();\n-    let requests = world.latest_completed_requests.read();\n-    for (idx, r) in requests.iter().enumerate() {\n-        let current = if idx == world.request_idx { \"*\" } else { \" \" };\n-        writeln!(buf, \"{:4}{}{:<36}{}ms\", r.id, current, r.method, r.duration.as_millis()).unwrap();\n+    let requests = world.latest_requests.read();\n+    for (is_last, r) in requests.iter() {\n+        let mark = if is_last { \"*\" } else { \" \" };\n+        writeln!(buf, \"{}{:4} {:<36}{}ms\", mark, r.id, r.method, r.duration.as_millis()).unwrap();\n     }\n     Ok(buf)\n }"}, {"sha": "741770e45655e7418e78403b082599d1b70fad7f", "filename": "crates/ra_lsp_server/src/main_loop/pending_requests.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e1bda6aeda084e6e913b80959dbf6ce6260d1db2/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fpending_requests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1bda6aeda084e6e913b80959dbf6ce6260d1db2/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fpending_requests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fpending_requests.rs?ref=e1bda6aeda084e6e913b80959dbf6ce6260d1db2", "patch": "@@ -0,0 +1,72 @@\n+use std::time::{Duration, Instant};\n+\n+use rustc_hash::FxHashMap;\n+\n+#[derive(Debug)]\n+pub struct CompletedRequest {\n+    pub id: u64,\n+    pub method: String,\n+    pub duration: Duration,\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct PendingRequest {\n+    pub(crate) id: u64,\n+    pub(crate) method: String,\n+    pub(crate) received: Instant,\n+}\n+\n+impl From<PendingRequest> for CompletedRequest {\n+    fn from(pending: PendingRequest) -> CompletedRequest {\n+        CompletedRequest {\n+            id: pending.id,\n+            method: pending.method,\n+            duration: pending.received.elapsed(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Default)]\n+pub(crate) struct PendingRequests {\n+    map: FxHashMap<u64, PendingRequest>,\n+}\n+\n+impl PendingRequests {\n+    pub(crate) fn start(&mut self, request: PendingRequest) {\n+        let id = request.id;\n+        let prev = self.map.insert(id, request);\n+        assert!(prev.is_none(), \"duplicate request with id {}\", id);\n+    }\n+    pub(crate) fn cancel(&mut self, id: u64) -> bool {\n+        self.map.remove(&id).is_some()\n+    }\n+    pub(crate) fn finish(&mut self, id: u64) -> Option<CompletedRequest> {\n+        self.map.remove(&id).map(CompletedRequest::from)\n+    }\n+}\n+\n+const N_COMPLETED_REQUESTS: usize = 10;\n+\n+#[derive(Debug, Default)]\n+pub struct LatestRequests {\n+    // hand-rolling VecDeque here to print things in a nicer way\n+    buf: [Option<CompletedRequest>; N_COMPLETED_REQUESTS],\n+    idx: usize,\n+}\n+\n+impl LatestRequests {\n+    pub(crate) fn record(&mut self, request: CompletedRequest) {\n+        // special case: don't track status request itself\n+        if request.method == \"rust-analyzer/analyzerStatus\" {\n+            return;\n+        }\n+        let idx = self.idx;\n+        self.buf[idx] = Some(request);\n+        self.idx = (idx + 1) % N_COMPLETED_REQUESTS;\n+    }\n+\n+    pub(crate) fn iter(&self) -> impl Iterator<Item = (bool, &CompletedRequest)> {\n+        let idx = self.idx;\n+        self.buf.iter().enumerate().filter_map(move |(i, req)| Some((i == idx, req.as_ref()?)))\n+    }\n+}"}, {"sha": "470bc12051e76970ce0290cc32b67124e89cc4b8", "filename": "crates/ra_lsp_server/src/main_loop/subscriptions.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1bda6aeda084e6e913b80959dbf6ce6260d1db2/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1bda6aeda084e6e913b80959dbf6ce6260d1db2/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs?ref=e1bda6aeda084e6e913b80959dbf6ce6260d1db2", "patch": "@@ -1,21 +1,19 @@\n use ra_ide_api::FileId;\n use rustc_hash::FxHashSet;\n \n-pub struct Subscriptions {\n+#[derive(Default)]\n+pub(crate) struct Subscriptions {\n     subs: FxHashSet<FileId>,\n }\n \n impl Subscriptions {\n-    pub fn new() -> Subscriptions {\n-        Subscriptions { subs: FxHashSet::default() }\n-    }\n-    pub fn add_sub(&mut self, file_id: FileId) {\n+    pub(crate) fn add_sub(&mut self, file_id: FileId) {\n         self.subs.insert(file_id);\n     }\n-    pub fn remove_sub(&mut self, file_id: FileId) {\n+    pub(crate) fn remove_sub(&mut self, file_id: FileId) {\n         self.subs.remove(&file_id);\n     }\n-    pub fn subscriptions(&self) -> Vec<FileId> {\n+    pub(crate) fn subscriptions(&self) -> Vec<FileId> {\n         self.subs.iter().cloned().collect()\n     }\n }"}, {"sha": "8c7951e13d82c3624bc3fcfe839e93f4e0aa07d4", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e1bda6aeda084e6e913b80959dbf6ce6260d1db2/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1bda6aeda084e6e913b80959dbf6ce6260d1db2/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=e1bda6aeda084e6e913b80959dbf6ce6260d1db2", "patch": "@@ -1,7 +1,6 @@\n use std::{\n     path::{Path, PathBuf},\n     sync::Arc,\n-    time::Duration,\n };\n \n use lsp_types::Url;\n@@ -16,6 +15,7 @@ use failure::{Error, format_err};\n use gen_lsp_server::ErrorCode;\n \n use crate::{\n+    main_loop::pending_requests::{CompletedRequest, LatestRequests},\n     project_model::ProjectWorkspace,\n     vfs_filter::IncludeRustFiles,\n     Result,\n@@ -29,26 +29,14 @@ pub struct ServerWorldState {\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis_host: AnalysisHost,\n     pub vfs: Arc<RwLock<Vfs>>,\n-    // hand-rolling VecDeque here to print things in a nicer way\n-    pub latest_completed_requests: Arc<RwLock<[CompletedRequest; N_COMPLETED_REQUESTS]>>,\n-    pub request_idx: usize,\n+    pub latest_requests: Arc<RwLock<LatestRequests>>,\n }\n \n-const N_COMPLETED_REQUESTS: usize = 10;\n-\n pub struct ServerWorld {\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis: Analysis,\n     pub vfs: Arc<RwLock<Vfs>>,\n-    pub latest_completed_requests: Arc<RwLock<[CompletedRequest; N_COMPLETED_REQUESTS]>>,\n-    pub request_idx: usize,\n-}\n-\n-#[derive(Debug, Default)]\n-pub struct CompletedRequest {\n-    pub id: u64,\n-    pub method: String,\n-    pub duration: Duration,\n+    pub latest_requests: Arc<RwLock<LatestRequests>>,\n }\n \n impl ServerWorldState {\n@@ -88,8 +76,7 @@ impl ServerWorldState {\n             workspaces: Arc::new(workspaces),\n             analysis_host,\n             vfs: Arc::new(RwLock::new(vfs)),\n-            latest_completed_requests: Default::default(),\n-            request_idx: 0,\n+            latest_requests: Default::default(),\n         }\n     }\n \n@@ -158,8 +145,7 @@ impl ServerWorldState {\n             workspaces: Arc::clone(&self.workspaces),\n             analysis: self.analysis_host.analysis(),\n             vfs: Arc::clone(&self.vfs),\n-            latest_completed_requests: Arc::clone(&self.latest_completed_requests),\n-            request_idx: self.request_idx.checked_sub(1).unwrap_or(N_COMPLETED_REQUESTS - 1),\n+            latest_requests: Arc::clone(&self.latest_requests),\n         }\n     }\n \n@@ -172,13 +158,7 @@ impl ServerWorldState {\n     }\n \n     pub fn complete_request(&mut self, request: CompletedRequest) {\n-        // special case: don't track status request itself\n-        if request.method == \"rust-analyzer/analyzerStatus\" {\n-            return;\n-        }\n-        let idx = self.request_idx;\n-        self.latest_completed_requests.write()[idx] = request;\n-        self.request_idx = (idx + 1) % N_COMPLETED_REQUESTS;\n+        self.latest_requests.write().record(request)\n     }\n }\n "}]}