{"sha": "aa2ae564d391a3da10bca2a79ab529a9925fbe58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMmFlNTY0ZDM5MWEzZGExMGJjYTJhNzlhYjUyOWE5OTI1ZmJlNTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-13T11:36:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-13T11:36:52Z"}, "message": "Auto merge of #65368 - Centril:rollup-lb7fe48, r=Centril\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #65039 (Document missing deny by default lints)\n - #65069 (Implement Clone::clone_from for VecDeque)\n - #65165 (Improve docs on some char boolean methods)\n - #65248 (Suggest `if let` on `let` refutable binding)\n - #65250 (resolve: fix error title regarding private constructors)\n - #65295 (Move diagnostics code out of the critical path)\n - #65320 (Report `CONST_ERR` lint in external macros)\n - #65327 (replace the hand-written binary search with the library one)\n - #65339 (do not reference LLVM for our concurrency memory model)\n - #65357 (syntax: simplify maybe_annotate_with_ascription)\n - #65358 (simplify maybe_stage_features)\n - #65359 (simplify integer_lit)\n - #65360 (mbe: reduce panictry! uses.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c2cd4ba7039146bc964171693b6978296f585a72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2cd4ba7039146bc964171693b6978296f585a72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa2ae564d391a3da10bca2a79ab529a9925fbe58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2ae564d391a3da10bca2a79ab529a9925fbe58", "html_url": "https://github.com/rust-lang/rust/commit/aa2ae564d391a3da10bca2a79ab529a9925fbe58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa2ae564d391a3da10bca2a79ab529a9925fbe58/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29b6e0f0a1d1a37f8dc729484a64e59bf0b9a0a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/29b6e0f0a1d1a37f8dc729484a64e59bf0b9a0a3", "html_url": "https://github.com/rust-lang/rust/commit/29b6e0f0a1d1a37f8dc729484a64e59bf0b9a0a3"}, {"sha": "b82859171cda6380546ad4802015dd803e4847a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b82859171cda6380546ad4802015dd803e4847a0", "html_url": "https://github.com/rust-lang/rust/commit/b82859171cda6380546ad4802015dd803e4847a0"}], "stats": {"total": 1140, "additions": 762, "deletions": 378}, "files": [{"sha": "5688e90ada129a8fa0fdc9942be4acff461767ae", "filename": "src/doc/rustc/src/lints/listing/deny-by-default.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -222,3 +222,28 @@ error: invalid `crate_type` value\n   | ^^^^^^^^^^^^^^^^^^^^\n   |\n ```\n+\n+## const-err\n+\n+This lint detects expressions that will always panic at runtime and would be an\n+error in a `const` context.\n+\n+```rust,ignore\n+let _ = [0; 4][4];\n+```\n+\n+This will produce:\n+\n+```text\n+error: index out of bounds: the len is 4 but the index is 4\n+ --> src/lib.rs:1:9\n+  |\n+1 | let _ = [0; 4][4];\n+  |         ^^^^^^^^^\n+  |\n+```\n+\n+## order-dependent-trait-objects\n+\n+This lint detects a trait coherency violation that would allow creating two\n+trait impls for the same dynamic trait object involving marker traits."}, {"sha": "0bf573f5e2539fc8d84ddbc2a1c295c1fdb36626", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 99, "deletions": 2, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -10,8 +10,8 @@\n use core::array::LengthAtMost32;\n use core::cmp::{self, Ordering};\n use core::fmt;\n-use core::iter::{repeat_with, FromIterator, FusedIterator};\n-use core::mem;\n+use core::iter::{once, repeat_with, FromIterator, FusedIterator};\n+use core::mem::{self, replace};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds, Try};\n use core::ptr::{self, NonNull};\n@@ -57,11 +57,88 @@ pub struct VecDeque<T> {\n     buf: RawVec<T>,\n }\n \n+/// PairSlices pairs up equal length slice parts of two deques\n+///\n+/// For example, given deques \"A\" and \"B\" with the following division into slices:\n+///\n+/// A: [0 1 2] [3 4 5]\n+/// B: [a b] [c d e]\n+///\n+/// It produces the following sequence of matching slices:\n+///\n+/// ([0 1], [a b])\n+/// ([2], [c])\n+/// ([3 4], [d e])\n+///\n+/// and the uneven remainder of either A or B is skipped.\n+struct PairSlices<'a, 'b, T> {\n+    a0: &'a mut [T],\n+    a1: &'a mut [T],\n+    b0: &'b [T],\n+    b1: &'b [T],\n+}\n+\n+impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n+    fn from(to: &'a mut VecDeque<T>, from: &'b VecDeque<T>) -> Self {\n+        let (a0, a1) = to.as_mut_slices();\n+        let (b0, b1) = from.as_slices();\n+        PairSlices { a0, a1, b0, b1 }\n+    }\n+\n+    fn has_remainder(&self) -> bool {\n+        !self.b0.is_empty()\n+    }\n+\n+    fn remainder(self) -> impl Iterator<Item=&'b [T]> {\n+        once(self.b0).chain(once(self.b1))\n+    }\n+}\n+\n+impl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T>\n+{\n+    type Item = (&'a mut [T], &'b [T]);\n+    fn next(&mut self) -> Option<Self::Item> {\n+        // Get next part length\n+        let part = cmp::min(self.a0.len(), self.b0.len());\n+        if part == 0 {\n+            return None;\n+        }\n+        let (p0, p1) = replace(&mut self.a0, &mut []).split_at_mut(part);\n+        let (q0, q1) = self.b0.split_at(part);\n+\n+        // Move a1 into a0, if it's empty (and b1, b0 the same way).\n+        self.a0 = p1;\n+        self.b0 = q1;\n+        if self.a0.is_empty() {\n+            self.a0 = replace(&mut self.a1, &mut []);\n+        }\n+        if self.b0.is_empty() {\n+            self.b0 = replace(&mut self.b1, &[]);\n+        }\n+        Some((p0, q0))\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for VecDeque<T> {\n     fn clone(&self) -> VecDeque<T> {\n         self.iter().cloned().collect()\n     }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        self.truncate(other.len());\n+\n+        let mut iter = PairSlices::from(self, other);\n+        while let Some((dst, src)) = iter.next() {\n+            dst.clone_from_slice(&src);\n+        }\n+\n+        if iter.has_remainder() {\n+            for remainder in iter.remainder() {\n+                self.extend(remainder.iter().cloned());\n+            }\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2209,6 +2286,16 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         final_res\n     }\n \n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        if n >= count(self.tail, self.head, self.ring.len()) {\n+            self.tail = self.head;\n+            None\n+        } else {\n+            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n+            self.next()\n+        }\n+    }\n+\n     #[inline]\n     fn last(mut self) -> Option<&'a T> {\n         self.next_back()\n@@ -2327,6 +2414,16 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         back.iter_mut().fold(accum, &mut f)\n     }\n \n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        if n >= count(self.tail, self.head, self.ring.len()) {\n+            self.tail = self.head;\n+            None\n+        } else {\n+            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n+            self.next()\n+        }\n+    }\n+\n     #[inline]\n     fn last(mut self) -> Option<&'a mut T> {\n         self.next_back()"}, {"sha": "d578ee0dac493fa922bd7d6d72f7c36f8d3184f8", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -361,6 +361,29 @@ fn test_vec_from_vecdeque() {\n     }\n }\n \n+#[test]\n+fn test_clone_from() {\n+    let m = vec![1; 8];\n+    let n = vec![2; 12];\n+    for pfv in 0..8 {\n+        for pfu in 0..8 {\n+            for longer in 0..2 {\n+                let (vr, ur) = if longer == 0 { (&m, &n) } else { (&n, &m) };\n+                let mut v = VecDeque::from(vr.clone());\n+                for _ in 0..pfv {\n+                    v.push_front(1);\n+                }\n+                let mut u = VecDeque::from(ur.clone());\n+                for _ in 0..pfu {\n+                    u.push_front(2);\n+                }\n+                v.clone_from(&u);\n+                assert_eq!(&v, &u);\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn issue_53529() {\n     use crate::boxed::Box;"}, {"sha": "971d89e004446e306a1ad424c43375e36f6d07b4", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 109, "deletions": 63, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -116,9 +116,9 @@ impl char {\n \n         // the code is split up here to improve execution speed for cases where\n         // the `radix` is constant and 10 or smaller\n-        let val = if radix <= 10  {\n+        let val = if radix <= 10 {\n             match self {\n-                '0' ..= '9' => self as u32 - '0' as u32,\n+                '0'..='9' => self as u32 - '0' as u32,\n                 _ => return None,\n             }\n         } else {\n@@ -130,8 +130,11 @@ impl char {\n             }\n         };\n \n-        if val < radix { Some(val) }\n-        else { None }\n+        if val < radix {\n+            Some(val)\n+        } else {\n+            None\n+        }\n     }\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a\n@@ -303,8 +306,8 @@ impl char {\n             '\\r' => EscapeDefaultState::Backslash('r'),\n             '\\n' => EscapeDefaultState::Backslash('n'),\n             '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n-            '\\x20' ..= '\\x7e' => EscapeDefaultState::Char(self),\n-            _ => EscapeDefaultState::Unicode(self.escape_unicode())\n+            '\\x20'..='\\x7e' => EscapeDefaultState::Char(self),\n+            _ => EscapeDefaultState::Unicode(self.escape_unicode()),\n         };\n         EscapeDefault { state: init_state }\n     }\n@@ -436,30 +439,31 @@ impl char {\n     pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n         let code = self as u32;\n         unsafe {\n-            let len =\n-            if code < MAX_ONE_B && !dst.is_empty() {\n+            let len = if code < MAX_ONE_B && !dst.is_empty() {\n                 *dst.get_unchecked_mut(0) = code as u8;\n                 1\n             } else if code < MAX_TWO_B && dst.len() >= 2 {\n                 *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n                 *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;\n                 2\n-            } else if code < MAX_THREE_B && dst.len() >= 3  {\n+            } else if code < MAX_THREE_B && dst.len() >= 3 {\n                 *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(1) = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n                 *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;\n                 3\n             } else if dst.len() >= 4 {\n                 *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n                 *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(2) = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n                 *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;\n                 4\n             } else {\n-                panic!(\"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n+                panic!(\n+                    \"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n                     from_u32_unchecked(code).len_utf8(),\n                     code,\n-                    dst.len())\n+                    dst.len(),\n+                )\n             };\n             from_utf8_unchecked_mut(dst.get_unchecked_mut(..len))\n         }\n@@ -515,15 +519,24 @@ impl char {\n                 *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n                 slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n             } else {\n-                panic!(\"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n+                panic!(\n+                    \"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n                     from_u32_unchecked(code).len_utf16(),\n                     code,\n-                    dst.len())\n+                    dst.len(),\n+                )\n             }\n         }\n     }\n \n-    /// Returns `true` if this `char` is an alphabetic code point, and false if not.\n+    /// Returns `true` if this `char` has the `Alphabetic` property.\n+    ///\n+    /// `Alphabetic` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n+    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n+    ///\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     ///\n     /// # Examples\n     ///\n@@ -547,10 +560,14 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is lowercase.\n+    /// Returns `true` if this `char` has the `Lowercase` property.\n     ///\n-    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core\n-    /// Property `Lowercase`.\n+    /// `Lowercase` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n+    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n+    ///\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     ///\n     /// # Examples\n     ///\n@@ -575,10 +592,14 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is uppercase.\n+    /// Returns `true` if this `char` has the `Uppercase` property.\n+    ///\n+    /// `Uppercase` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n+    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n     ///\n-    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core\n-    /// Property `Uppercase`.\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     ///\n     /// # Examples\n     ///\n@@ -603,10 +624,12 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is whitespace.\n+    /// Returns `true` if this `char` has the `White_Space` property.\n     ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived Core\n-    /// Property `White_Space`.\n+    /// `White_Space` is specified in the [Unicode Character Database][ucd] [`PropList.txt`].\n+    ///\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`PropList.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n     ///\n     /// # Examples\n     ///\n@@ -630,10 +653,10 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is alphanumeric.\n+    /// Returns `true` if this `char` satisfies either [`is_alphabetic()`] or [`is_numeric()`].\n     ///\n-    /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n-    /// `Nd`, `Nl`, `No` and the Derived Core Property `Alphabetic`.\n+    /// [`is_alphabetic()`]: #method.is_alphabetic\n+    /// [`is_numeric()`]: #method.is_numeric\n     ///\n     /// # Examples\n     ///\n@@ -655,10 +678,15 @@ impl char {\n         self.is_alphabetic() || self.is_numeric()\n     }\n \n-    /// Returns `true` if this `char` is a control code point.\n+    /// Returns `true` if this `char` has the general category for control codes.\n+    ///\n+    /// Control codes (code points with the general category of `Cc`) are described in Chapter 4\n+    /// (Character Properties) of the [Unicode Standard] and specified in the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`].\n     ///\n-    /// 'Control code point' is defined in terms of the Unicode General\n-    /// Category `Cc`.\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n     /// # Examples\n     ///\n@@ -675,19 +703,29 @@ impl char {\n         general_category::Cc(self)\n     }\n \n-    /// Returns `true` if this `char` is an extended grapheme character.\n+    /// Returns `true` if this `char` has the `Grapheme_Extend` property.\n     ///\n-    /// 'Extended grapheme character' is defined in terms of the Unicode Shaping and Rendering\n-    /// Category `Grapheme_Extend`.\n+    /// `Grapheme_Extend` is described in [Unicode Standard Annex #29 (Unicode Text\n+    /// Segmentation)][uax29] and specified in the [Unicode Character Database][ucd]\n+    /// [`DerivedCoreProperties.txt`].\n+    ///\n+    /// [uax29]: https://www.unicode.org/reports/tr29/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     #[inline]\n     pub(crate) fn is_grapheme_extended(self) -> bool {\n         derived_property::Grapheme_Extend(self)\n     }\n \n-    /// Returns `true` if this `char` is numeric.\n+    /// Returns `true` if this `char` has one of the general categories for numbers.\n+    ///\n+    /// The general categories for numbers (`Nd` for decimal digits, `Nl` for letter-like numeric\n+    /// characters, and `No` for other numeric characters) are specified in the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`].\n     ///\n-    /// 'Numeric'-ness is defined in terms of the Unicode General Categories\n-    /// `Nd`, `Nl`, `No`.\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n     /// # Examples\n     ///\n@@ -713,25 +751,29 @@ impl char {\n         }\n     }\n \n-    /// Returns an iterator that yields the lowercase equivalent of a `char`\n-    /// as one or more `char`s.\n+    /// Returns an iterator that yields the lowercase mapping of this `char` as one or more\n+    /// `char`s.\n     ///\n-    /// If a character does not have a lowercase equivalent, the same character\n-    /// will be returned back by the iterator.\n+    /// If this `char` does not have a lowercase mapping, the iterator yields the same `char`.\n     ///\n-    /// This performs complex unconditional mappings with no tailoring: it maps\n-    /// one Unicode character to its lowercase equivalent according to the\n-    /// [Unicode database] and the additional complex mappings\n-    /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n-    /// language) are not considered here.\n+    /// If this `char` has a one-to-one lowercase mapping given by the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`], the iterator yields that `char`.\n     ///\n-    /// For a full reference, see [here][reference].\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n-    /// [Unicode database]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    /// If this `char` requires special considerations (e.g. multiple `char`s) the iterator yields\n+    /// the `char`(s) given by [`SpecialCasing.txt`].\n     ///\n-    /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n+    /// [`SpecialCasing.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n     ///\n-    /// [reference]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n+    /// This operation performs an unconditional mapping without tailoring. That is, the conversion\n+    /// is independent of context and language.\n+    ///\n+    /// In the [Unicode Standard], Chapter 4 (Character Properties) discusses case mapping in\n+    /// general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.\n+    ///\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n     ///\n     /// # Examples\n     ///\n@@ -774,25 +816,29 @@ impl char {\n         ToLowercase(CaseMappingIter::new(conversions::to_lower(self)))\n     }\n \n-    /// Returns an iterator that yields the uppercase equivalent of a `char`\n-    /// as one or more `char`s.\n+    /// Returns an iterator that yields the uppercase mapping of this `char` as one or more\n+    /// `char`s.\n+    ///\n+    /// If this `char` does not have a uppercase mapping, the iterator yields the same `char`.\n+    ///\n+    /// If this `char` has a one-to-one uppercase mapping given by the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`], the iterator yields that `char`.\n     ///\n-    /// If a character does not have an uppercase equivalent, the same character\n-    /// will be returned back by the iterator.\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n-    /// This performs complex unconditional mappings with no tailoring: it maps\n-    /// one Unicode character to its uppercase equivalent according to the\n-    /// [Unicode database] and the additional complex mappings\n-    /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n-    /// language) are not considered here.\n+    /// If this `char` requires special considerations (e.g. multiple `char`s) the iterator yields\n+    /// the `char`(s) given by [`SpecialCasing.txt`].\n     ///\n-    /// For a full reference, see [here][reference].\n+    /// [`SpecialCasing.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n     ///\n-    /// [Unicode database]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    /// This operation performs an unconditional mapping without tailoring. That is, the conversion\n+    /// is independent of context and language.\n     ///\n-    /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n+    /// In the [Unicode Standard], Chapter 4 (Character Properties) discusses case mapping in\n+    /// general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.\n     ///\n-    /// [reference]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n     ///\n     /// # Examples\n     ///"}, {"sha": "f2822227ac2a69fa5d9b8e638e8b4ce6b5629e74", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -18,11 +18,11 @@\n //!\n //! Each method takes an [`Ordering`] which represents the strength of\n //! the memory barrier for that operation. These orderings are the\n-//! same as [LLVM atomic orderings][1]. For more information see the [nomicon][2].\n+//! same as the [C++20 atomic orderings][1]. For more information see the [nomicon][2].\n //!\n //! [`Ordering`]: enum.Ordering.html\n //!\n-//! [1]: https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n+//! [1]: https://en.cppreference.com/w/cpp/atomic/memory_order\n //! [2]: ../../../nomicon/atomics.html\n //!\n //! Atomic variables are safe to share between threads (they implement [`Sync`])\n@@ -217,8 +217,8 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// operations synchronize other memory while additionally preserving a total order of such\n /// operations across all threads.\n ///\n-/// Rust's memory orderings are [the same as\n-/// LLVM's](https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n+/// Rust's memory orderings are [the same as those of\n+/// C++20](https://en.cppreference.com/w/cpp/atomic/memory_order).\n ///\n /// For more information see the [nomicon].\n ///\n@@ -231,9 +231,9 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations.\n     ///\n-    /// Corresponds to LLVM's [`Monotonic`] ordering.\n+    /// Corresponds to [`memory_order_relaxed`] in C++20.\n     ///\n-    /// [`Monotonic`]: https://llvm.org/docs/Atomics.html#monotonic\n+    /// [`memory_order_relaxed`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Relaxed_ordering\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Relaxed,\n     /// When coupled with a store, all previous operations become ordered\n@@ -246,11 +246,12 @@ pub enum Ordering {\n     ///\n     /// This ordering is only applicable for operations that can perform a store.\n     ///\n-    /// Corresponds to LLVM's [`Release`] ordering.\n+    /// Corresponds to [`memory_order_release`] in C++20.\n     ///\n-    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n-    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n-    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n+    /// [`Release`]: #variant.Release\n+    /// [`Acquire`]: #variant.Acquire\n+    /// [`Relaxed`]: #variant.Relaxed\n+    /// [`memory_order_release`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n     /// When coupled with a load, if the loaded value was written by a store operation with\n@@ -263,40 +264,41 @@ pub enum Ordering {\n     ///\n     /// This ordering is only applicable for operations that can perform a load.\n     ///\n-    /// Corresponds to LLVM's [`Acquire`] ordering.\n+    /// Corresponds to [`memory_order_acquire`] in C++20.\n     ///\n-    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n-    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n-    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n+    /// [`Acquire`]: #variant.Acquire\n+    /// [`Release`]: #variant.Release\n+    /// [`Relaxed`]: #variant.Relaxed\n+    /// [`memory_order_acquire`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n     /// Has the effects of both [`Acquire`] and [`Release`] together:\n     /// For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n     ///\n     /// Notice that in the case of `compare_and_swap`, it is possible that the operation ends up\n     /// not performing any store and hence it has just [`Acquire`] ordering. However,\n-    /// [`AcqRel`][`AcquireRelease`] will never perform [`Relaxed`] accesses.\n+    /// `AcqRel` will never perform [`Relaxed`] accesses.\n     ///\n     /// This ordering is only applicable for operations that combine both loads and stores.\n     ///\n-    /// Corresponds to LLVM's [`AcquireRelease`] ordering.\n+    /// Corresponds to [`memory_order_acq_rel`] in C++20.\n     ///\n-    /// [`AcquireRelease`]: https://llvm.org/docs/Atomics.html#acquirerelease\n-    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n-    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n-    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n+    /// [`memory_order_acq_rel`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n+    /// [`Acquire`]: #variant.Acquire\n+    /// [`Release`]: #variant.Release\n+    /// [`Relaxed`]: #variant.Relaxed\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n     /// Like [`Acquire`]/[`Release`]/[`AcqRel`] (for load, store, and load-with-store\n     /// operations, respectively) with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n     ///\n-    /// Corresponds to LLVM's [`SequentiallyConsistent`] ordering.\n+    /// Corresponds to [`memory_order_seq_cst`] in C++20.\n     ///\n-    /// [`SequentiallyConsistent`]: https://llvm.org/docs/Atomics.html#sequentiallyconsistent\n-    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n-    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n-    /// [`AcqRel`]: https://llvm.org/docs/Atomics.html#acquirerelease\n+    /// [`memory_order_seq_cst`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Sequentially-consistent_ordering\n+    /// [`Acquire`]: #variant.Acquire\n+    /// [`Release`]: #variant.Release\n+    /// [`AcqRel`]: #variant.AcqRel\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     SeqCst,\n }"}, {"sha": "983e3a9922ec2dee00536d25ff1f98a5c0b37754", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -21,7 +21,8 @@ declare_lint! {\n declare_lint! {\n     pub CONST_ERR,\n     Deny,\n-    \"constant evaluation detected erroneous expression\"\n+    \"constant evaluation detected erroneous expression\",\n+    report_in_external_macro: true\n }\n \n declare_lint! {"}, {"sha": "9bed4fb66ea9dee219f92a8039f9eda3bd1ee191", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -62,12 +62,13 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n     fn visit_local(&mut self, loc: &'tcx hir::Local) {\n         intravisit::walk_local(self, loc);\n \n-        self.check_irrefutable(&loc.pat, match loc.source {\n-            hir::LocalSource::Normal => \"local binding\",\n-            hir::LocalSource::ForLoopDesugar => \"`for` loop binding\",\n-            hir::LocalSource::AsyncFn => \"async fn binding\",\n-            hir::LocalSource::AwaitDesugar => \"`await` future binding\",\n-        });\n+        let (msg, sp) = match loc.source {\n+            hir::LocalSource::Normal => (\"local binding\", Some(loc.span)),\n+            hir::LocalSource::ForLoopDesugar => (\"`for` loop binding\", None),\n+            hir::LocalSource::AsyncFn => (\"async fn binding\", None),\n+            hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n+        };\n+        self.check_irrefutable(&loc.pat, msg, sp);\n \n         // Check legality of move bindings and `@` patterns.\n         self.check_patterns(false, &loc.pat);\n@@ -77,7 +78,7 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n         intravisit::walk_body(self, body);\n \n         for param in &body.params {\n-            self.check_irrefutable(&param.pat, \"function argument\");\n+            self.check_irrefutable(&param.pat, \"function argument\", None);\n             self.check_patterns(false, &param.pat);\n         }\n     }\n@@ -242,7 +243,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         })\n     }\n \n-    fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n+    fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str, sp: Option<Span>) {\n         let module = self.tcx.hir().get_module_parent(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut patcx = PatCtxt::new(self.tcx,\n@@ -266,18 +267,35 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 \"refutable pattern in {}: {} not covered\",\n                 origin, joined_patterns\n             );\n-            match &pat.kind {\n+            let suggest_if_let = match &pat.kind {\n                 hir::PatKind::Path(hir::QPath::Resolved(None, path))\n                     if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n                 {\n                     const_not_var(&mut err, cx.tcx, pat, path);\n+                    false\n                 }\n                 _ => {\n                     err.span_label(\n                         pat.span,\n                         pattern_not_covered_label(&witnesses, &joined_patterns),\n                     );\n+                    true\n+                }\n+            };\n+\n+            if let (Some(span), true) = (sp, suggest_if_let) {\n+                err.note(\"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n+                          an `enum` with only one variant\");\n+                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                    err.span_suggestion(\n+                        span,\n+                        \"you might want to use `if let` to ignore the variant that isn't matched\",\n+                        format!(\"if {} {{ /* */ }}\", &snippet[..snippet.len() - 1]),\n+                        Applicability::HasPlaceholders,\n+                    );\n                 }\n+                err.note(\"for more information, visit \\\n+                          https://doc.rust-lang.org/book/ch18-02-refutability.html\");\n             }\n \n             adt_defined_here(cx, &mut err, pattern_ty, &witnesses);"}, {"sha": "e0ff1539009176688c8c16354c870fee109f9954", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -2378,26 +2378,38 @@ impl<'a> Resolver<'a> {\n         let mut reported_spans = FxHashSet::default();\n         for &PrivacyError(dedup_span, ident, binding) in &self.privacy_errors {\n             if reported_spans.insert(dedup_span) {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    ident.span,\n-                    E0603,\n-                    \"{} `{}` is private\",\n-                    binding.res().descr(),\n-                    ident.name,\n-                );\n-                if let NameBindingKind::Res(\n+                let session = &self.session;\n+                let mk_struct_span_error = |is_constructor| {\n+                    struct_span_err!(\n+                        session,\n+                        ident.span,\n+                        E0603,\n+                        \"{}{} `{}` is private\",\n+                        binding.res().descr(),\n+                        if is_constructor { \" constructor\"} else { \"\" },\n+                        ident.name,\n+                    )\n+                };\n+\n+                let mut err = if let NameBindingKind::Res(\n                     Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), ctor_def_id), _\n                 ) = binding.kind {\n                     let def_id = (&*self).parent(ctor_def_id).expect(\"no parent for a constructor\");\n                     if let Some(fields) = self.field_names.get(&def_id) {\n+                        let mut err = mk_struct_span_error(true);\n                         let first_field = fields.first().expect(\"empty field list in the map\");\n                         err.span_label(\n                             fields.iter().fold(first_field.span, |acc, field| acc.to(field.span)),\n-                            \"a tuple struct constructor is private if any of its fields is private\",\n+                            \"a constructor is private if any of the fields is private\",\n                         );\n+                        err\n+                    } else {\n+                        mk_struct_span_error(false)\n                     }\n-                }\n+                } else {\n+                    mk_struct_span_error(false)\n+                };\n+\n                 err.emit();\n             }\n         }"}, {"sha": "e57cc809c347989488f7ba5e150ec4b05782141c", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -213,27 +213,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             segment,\n         );\n \n-        let mut needs_mut = false;\n-        if let ty::Ref(region, t_type, mutability) = self_ty.kind {\n-            let trait_type = self.tcx.mk_ref(region, ty::TypeAndMut {\n-                ty: t_type,\n-                mutbl: mutability.invert(),\n-            });\n-            match self.lookup_probe(\n-                span,\n-                segment.ident,\n-                trait_type,\n-                call_expr,\n-                ProbeScope::TraitsInScope\n-            ) {\n-                Ok(ref new_pick) if *new_pick != pick => {\n-                    needs_mut = true;\n+        if result.illegal_sized_bound {\n+            let mut needs_mut = false;\n+            if let ty::Ref(region, t_type, mutability) = self_ty.kind {\n+                let trait_type = self.tcx.mk_ref(region, ty::TypeAndMut {\n+                    ty: t_type,\n+                    mutbl: mutability.invert(),\n+                });\n+                // We probe again to see if there might be a borrow mutability discrepancy.\n+                match self.lookup_probe(\n+                    span,\n+                    segment.ident,\n+                    trait_type,\n+                    call_expr,\n+                    ProbeScope::TraitsInScope\n+                ) {\n+                    Ok(ref new_pick) if *new_pick != pick => {\n+                        needs_mut = true;\n+                    }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n-        }\n \n-        if result.illegal_sized_bound {\n             // We probe again, taking all traits into account (not only those in scope).\n             let candidates = match self.lookup_probe(\n                 span,"}, {"sha": "0cb5eff1ef29a5adcab6f681de21053ad74e1c0e", "filename": "src/libsyntax/ext/mbe/macro_parser.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -76,7 +76,7 @@ use TokenTreeOrTokenTreeSlice::*;\n \n use crate::ast::{Ident, Name};\n use crate::ext::mbe::{self, TokenTree};\n-use crate::parse::{Directory, ParseSess};\n+use crate::parse::{Directory, ParseSess, PResult};\n use crate::parse::parser::{Parser, PathStyle};\n use crate::parse::token::{self, DocComment, Nonterminal, Token};\n use crate::print::pprust;\n@@ -893,48 +893,50 @@ fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Nonterminal {\n     }\n     // check at the beginning and the parser checks after each bump\n     p.process_potential_macro_variable();\n-    match name {\n-        sym::item => match panictry!(p.parse_item()) {\n+    match parse_nt_inner(p, sp, name) {\n+        Ok(nt) => nt,\n+        Err(mut err) => {\n+            err.emit();\n+            FatalError.raise();\n+        }\n+    }\n+}\n+\n+fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a, Nonterminal> {\n+    Ok(match name {\n+        sym::item => match p.parse_item()? {\n             Some(i) => token::NtItem(i),\n-            None => {\n-                p.fatal(\"expected an item keyword\").emit();\n-                FatalError.raise();\n-            }\n+            None => return Err(p.fatal(\"expected an item keyword\")),\n         },\n-        sym::block => token::NtBlock(panictry!(p.parse_block())),\n-        sym::stmt => match panictry!(p.parse_stmt()) {\n+        sym::block => token::NtBlock(p.parse_block()?),\n+        sym::stmt => match p.parse_stmt()? {\n             Some(s) => token::NtStmt(s),\n-            None => {\n-                p.fatal(\"expected a statement\").emit();\n-                FatalError.raise();\n-            }\n+            None => return Err(p.fatal(\"expected a statement\")),\n         },\n-        sym::pat => token::NtPat(panictry!(p.parse_pat(None))),\n-        sym::expr => token::NtExpr(panictry!(p.parse_expr())),\n-        sym::literal => token::NtLiteral(panictry!(p.parse_literal_maybe_minus())),\n-        sym::ty => token::NtTy(panictry!(p.parse_ty())),\n+        sym::pat => token::NtPat(p.parse_pat(None)?),\n+        sym::expr => token::NtExpr(p.parse_expr()?),\n+        sym::literal => token::NtLiteral(p.parse_literal_maybe_minus()?),\n+        sym::ty => token::NtTy(p.parse_ty()?),\n         // this could be handled like a token, since it is one\n         sym::ident => if let Some((name, is_raw)) = get_macro_name(&p.token) {\n             let span = p.token.span;\n             p.bump();\n             token::NtIdent(Ident::new(name, span), is_raw)\n         } else {\n             let token_str = pprust::token_to_string(&p.token);\n-            p.fatal(&format!(\"expected ident, found {}\", &token_str)).emit();\n-            FatalError.raise()\n+            return Err(p.fatal(&format!(\"expected ident, found {}\", &token_str)));\n         }\n-        sym::path => token::NtPath(panictry!(p.parse_path(PathStyle::Type))),\n-        sym::meta => token::NtMeta(panictry!(p.parse_attr_item())),\n-        sym::vis => token::NtVis(panictry!(p.parse_visibility(true))),\n+        sym::path => token::NtPath(p.parse_path(PathStyle::Type)?),\n+        sym::meta => token::NtMeta(p.parse_attr_item()?),\n+        sym::vis => token::NtVis(p.parse_visibility(true)?),\n         sym::lifetime => if p.check_lifetime() {\n             token::NtLifetime(p.expect_lifetime().ident)\n         } else {\n             let token_str = pprust::token_to_string(&p.token);\n-            p.fatal(&format!(\"expected a lifetime, found `{}`\", &token_str)).emit();\n-            FatalError.raise();\n+            return Err(p.fatal(&format!(\"expected a lifetime, found `{}`\", &token_str)));\n         }\n         // this is not supposed to happen, since it has been checked\n         // when compiling the macro.\n         _ => p.span_bug(sp, \"invalid fragment specifier\"),\n-    }\n+    })\n }"}, {"sha": "6008f8f3005b3c1047acbe15d886774bb4b9a759", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -855,25 +855,19 @@ impl UnstableFeatures {\n     pub fn is_nightly_build(&self) -> bool {\n         match *self {\n             UnstableFeatures::Allow | UnstableFeatures::Cheat => true,\n-            _ => false,\n+            UnstableFeatures::Disallow => false,\n         }\n     }\n }\n \n fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate, unstable: UnstableFeatures) {\n-    let allow_features = match unstable {\n-        UnstableFeatures::Allow => true,\n-        UnstableFeatures::Disallow => false,\n-        UnstableFeatures::Cheat => true\n-    };\n-    if !allow_features {\n-        for attr in &krate.attrs {\n-            if attr.check_name(sym::feature) {\n-                let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n-                span_err!(span_handler, attr.span, E0554,\n-                          \"`#![feature]` may not be used on the {} release channel\",\n-                          release_channel);\n-            }\n+    if !unstable.is_nightly_build() {\n+        for attr in krate.attrs.iter().filter(|attr| attr.check_name(sym::feature)) {\n+            span_err!(\n+                span_handler, attr.span, E0554,\n+                \"`#![feature]` may not be used on the {} release channel\",\n+                option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\")\n+            );\n         }\n     }\n }"}, {"sha": "09a47795a822a89a96ee8a0181ce7d68821e003d", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -17,6 +17,7 @@\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_span)]\n #![feature(try_trait)]\n+#![feature(slice_patterns)]\n #![feature(unicode_internals)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "42cbe28fc17d44f39953ead004299c3fdecfc330", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -2,7 +2,7 @@ use crate::ast::{\n     self, Param, BinOpKind, BindingMode, BlockCheckMode, Expr, ExprKind, Ident, Item, ItemKind,\n     Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind, VariantData,\n };\n-use crate::feature_gate::{feature_err, UnstableFeatures};\n+use crate::feature_gate::feature_err;\n use crate::parse::{SeqSep, PResult, Parser, ParseSess};\n use crate::parse::parser::{BlockMode, PathStyle, SemiColonMode, TokenType, TokenExpectType};\n use crate::parse::token::{self, TokenKind};\n@@ -387,14 +387,17 @@ impl<'a> Parser<'a> {\n             let next_pos = sm.lookup_char_pos(self.token.span.lo());\n             let op_pos = sm.lookup_char_pos(sp.hi());\n \n+            let allow_unstable = self.sess.unstable_features.is_nightly_build();\n+\n             if likely_path {\n                 err.span_suggestion(\n                     sp,\n                     \"maybe write a path separator here\",\n                     \"::\".to_string(),\n-                    match self.sess.unstable_features {\n-                        UnstableFeatures::Disallow => Applicability::MachineApplicable,\n-                        _ => Applicability::MaybeIncorrect,\n+                    if allow_unstable {\n+                        Applicability::MaybeIncorrect\n+                    } else {\n+                        Applicability::MachineApplicable\n                     },\n                 );\n             } else if op_pos.line != next_pos.line && maybe_expected_semicolon {\n@@ -404,14 +407,13 @@ impl<'a> Parser<'a> {\n                     \";\".to_string(),\n                     Applicability::MaybeIncorrect,\n                 );\n-            } else if let UnstableFeatures::Disallow = self.sess.unstable_features {\n-                err.span_label(sp, \"tried to parse a type due to this\");\n-            } else {\n+            } else if allow_unstable {\n                 err.span_label(sp, \"tried to parse a type due to this type ascription\");\n+            } else {\n+                err.span_label(sp, \"tried to parse a type due to this\");\n             }\n-            if let UnstableFeatures::Disallow = self.sess.unstable_features {\n+            if allow_unstable {\n                 // Give extra information about type ascription only if it's a nightly compiler.\n-            } else {\n                 err.note(\"`#![feature(type_ascription)]` lets you annotate an expression with a \\\n                           type: `<expr>: <type>`\");\n                 err.note(\"for more information, see \\"}, {"sha": "56a79bfe5d51cc24e525805cac1a5b953daa737c", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -426,15 +426,12 @@ fn integer_lit(symbol: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitErr\n     let symbol = strip_underscores(symbol);\n     let s = symbol.as_str();\n \n-    let mut base = 10;\n-    if s.len() > 1 && s.as_bytes()[0] == b'0' {\n-        match s.as_bytes()[1] {\n-            b'x' => base = 16,\n-            b'o' => base = 8,\n-            b'b' => base = 2,\n-            _ => {}\n-        }\n-    }\n+    let base = match s.as_bytes() {\n+        [b'0', b'x', ..] => 16,\n+        [b'0', b'o', ..] => 8,\n+        [b'0', b'b', ..] => 2,\n+        _ => 10,\n+    };\n \n     let ty = match suffix {\n         Some(suf) => match suf {"}, {"sha": "5e569f9dae378048407b828d186655acd78c47ff", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -878,25 +878,8 @@ impl SourceMap {\n \n     // Returns the index of the `SourceFile` (in `self.files`) that contains `pos`.\n     pub fn lookup_source_file_idx(&self, pos: BytePos) -> usize {\n-        let files = self.files.borrow();\n-        let files = &files.source_files;\n-        let count = files.len();\n-\n-        // Binary search for the `SourceFile`.\n-        let mut a = 0;\n-        let mut b = count;\n-        while b - a > 1 {\n-            let m = (a + b) / 2;\n-            if files[m].start_pos > pos {\n-                b = m;\n-            } else {\n-                a = m;\n-            }\n-        }\n-\n-        assert!(a < count, \"position {} does not resolve to a source location\", pos.to_usize());\n-\n-        return a;\n+        self.files.borrow().source_files.binary_search_by_key(&pos, |key| key.start_pos)\n+            .unwrap_or_else(|p| p - 1)\n     }\n \n     pub fn count_lines(&self) -> usize {"}, {"sha": "d260634c9963b0818657f8f1363a61174d675baa", "filename": "src/test/ui/consts/auxiliary/external_macro.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fexternal_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fexternal_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fexternal_macro.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -0,0 +1,14 @@\n+#![feature(allow_internal_unstable)]\n+\n+// Macro to help ensure CONST_ERR lint errors\n+// are not silenced in external macros.\n+// https://github.com/rust-lang/rust/issues/65300\n+\n+#[macro_export]\n+#[allow_internal_unstable(type_ascription)]\n+macro_rules! static_assert {\n+    ($test:expr) => {\n+        #[allow(dead_code)]\n+        const _: () = [()][!($test: bool) as usize];\n+    }\n+}"}, {"sha": "616d24f4a7bcfcd260aab7a8f4e7716b1c848823", "filename": "src/test/ui/consts/const-external-macro-const-err.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fconsts%2Fconst-external-macro-const-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fconsts%2Fconst-external-macro-const-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-external-macro-const-err.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -0,0 +1,13 @@\n+// edition:2018\n+// aux-build:external_macro.rs\n+\n+// Ensure that CONST_ERR lint errors\n+// are not silenced in external macros.\n+// https://github.com/rust-lang/rust/issues/65300\n+\n+extern crate external_macro;\n+use external_macro::static_assert;\n+\n+fn main() {\n+    static_assert!(2 + 2 == 5); //~ ERROR\n+}"}, {"sha": "237c4d792c9ea9677228a697e80eadbe0ea126da", "filename": "src/test/ui/consts/const-external-macro-const-err.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fconsts%2Fconst-external-macro-const-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fconsts%2Fconst-external-macro-const-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-external-macro-const-err.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -0,0 +1,11 @@\n+error: any use of this value will cause an error\n+  --> $DIR/const-external-macro-const-err.rs:12:5\n+   |\n+LL |     static_assert!(2 + 2 == 5);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ index out of bounds: the len is 1 but the index is 1\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "087cc3c86a68d9da9657af1e97c7c47b50dd4dad", "filename": "src/test/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -3,6 +3,13 @@ error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1\n    |\n LL |     A = { let 0 = 0; 0 },\n    |               ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     A = { if let 0 = 0 { /* */ } 0 },\n+   |           ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "80d9f794bc1d5ae35165abf4b5e935102e16ec3b", "filename": "src/test/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -3,6 +3,13 @@ error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1\n    |\n LL |     let x: [i32; { let 0 = 0; 0 }] = [];\n    |                        ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     let x: [i32; { if let 0 = 0 { /* */ } 0 }] = [];\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "e6b2f212bb43057873daa4c5e8b54467dee0f46d", "filename": "src/test/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -3,24 +3,52 @@ error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1\n    |\n LL | const X: i32 = { let 0 = 0; 0 };\n    |                      ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL | const X: i32 = { if let 0 = 0 { /* */ } 0 };\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:8:23\n    |\n LL | static Y: i32 = { let 0 = 0; 0 };\n    |                       ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL | static Y: i32 = { if let 0 = 0 { /* */ } 0 };\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:13:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n    |                          ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     const X: i32 = { if let 0 = 0 { /* */ } 0 };\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:19:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n    |                          ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     const X: i32 = { if let 0 = 0 { /* */ } 0 };\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "d865b59f0b9459a5c9ce3f164df3b8f5fcd9d671", "filename": "src/test/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -11,6 +11,13 @@ LL | | }\n ...\n LL |       let Helper::U(u) = Helper::T(t, []);\n    |           ^^^^^^^^^^^^ pattern `T(_, _)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Helper::U(u) = Helper::T(t, []) { /* */ }\n+   |\n \n error[E0381]: use of possibly-uninitialized variable: `u`\n   --> $DIR/empty-never-array.rs:12:5"}, {"sha": "577c6e886d52331e5c8b3975b22006d0c67fbe2e", "filename": "src/test/ui/error-codes/E0005.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -3,6 +3,13 @@ error[E0005]: refutable pattern in local binding: `None` not covered\n    |\n LL |     let Some(y) = x;\n    |         ^^^^^^^ pattern `None` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Some(y) = x { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d77fbc1e8239debff1410553b2f698755bc305b8", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.nll.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.nll.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -0,0 +1,16 @@\n+error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n+  --> $DIR/feature-gate-exhaustive-patterns.rs:7:9\n+   |\n+LL |     let Ok(_x) = foo();\n+   |         ^^^^^^ pattern `Err(_)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Ok(_x) = foo() { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0005`."}, {"sha": "d77fbc1e8239debff1410553b2f698755bc305b8", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -3,6 +3,13 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n    |\n LL |     let Ok(_x) = foo();\n    |         ^^^^^^ pattern `Err(_)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Ok(_x) = foo() { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d3c8e876b8a8816b778272b0d8f21e6a168eac3f", "filename": "src/test/ui/issues/issue-31561.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -12,6 +12,13 @@ LL | | }\n ...\n LL |       let Thing::Foo(y) = Thing::Foo(1);\n    |           ^^^^^^^^^^^^^ patterns `Bar` and `Baz` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Thing::Foo(y) = Thing::Foo(1) { /* */ }\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "e5f01174ac1bf7539ebbb0d6cab2a6f0acf806a0", "filename": "src/test/ui/match/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -41,6 +41,13 @@ LL | | }\n ...\n LL |       let E::A = e;\n    |           ^^^^ patterns `B` and `C` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let E::A = e { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0004]: non-exhaustive patterns: `&B` and `&C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:40:11\n@@ -85,6 +92,13 @@ LL | | }\n ...\n LL |       let E::A = e;\n    |           ^^^^ patterns `&B` and `&C` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let E::A = e { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0004]: non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:48:11\n@@ -129,6 +143,13 @@ LL | | }\n ...\n LL |       let E::A = e;\n    |           ^^^^ patterns `&&mut &B` and `&&mut &C` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let E::A = e { /* */ }\n+   |\n \n error[E0004]: non-exhaustive patterns: `None` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:65:11\n@@ -163,6 +184,13 @@ LL | | }\n ...\n LL |       let Opt::Some(ref _x) = e;\n    |           ^^^^^^^^^^^^^^^^^ pattern `None` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Opt::Some(ref _x) = e { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 8 previous errors\n "}, {"sha": "3dc26b1955cd7fbea53ce1efe05319920bfea83f", "filename": "src/test/ui/privacy/privacy5.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -48,80 +48,80 @@ mod a {\n }\n \n fn this_crate() {\n-    let a = a::A(()); //~ ERROR tuple struct `A` is private\n-    let b = a::B(2); //~ ERROR tuple struct `B` is private\n-    let c = a::C(2, 3); //~ ERROR tuple struct `C` is private\n+    let a = a::A(()); //~ ERROR tuple struct constructor `A` is private\n+    let b = a::B(2); //~ ERROR tuple struct constructor `B` is private\n+    let c = a::C(2, 3); //~ ERROR tuple struct constructor `C` is private\n     let d = a::D(4);\n \n-    let a::A(()) = a; //~ ERROR tuple struct `A` is private\n-    let a::A(_) = a; //~ ERROR tuple struct `A` is private\n-    match a { a::A(()) => {} } //~ ERROR tuple struct `A` is private\n-    match a { a::A(_) => {} } //~ ERROR tuple struct `A` is private\n-\n-    let a::B(_) = b; //~ ERROR tuple struct `B` is private\n-    let a::B(_b) = b; //~ ERROR tuple struct `B` is private\n-    match b { a::B(_) => {} } //~ ERROR tuple struct `B` is private\n-    match b { a::B(_b) => {} } //~ ERROR tuple struct `B` is private\n-    match b { a::B(1) => {} a::B(_) => {} } //~ ERROR tuple struct `B` is private\n-                                            //~^ ERROR tuple struct `B` is private\n-\n-    let a::C(_, _) = c; //~ ERROR tuple struct `C` is private\n-    let a::C(_a, _) = c; //~ ERROR tuple struct `C` is private\n-    let a::C(_, _b) = c; //~ ERROR tuple struct `C` is private\n-    let a::C(_a, _b) = c; //~ ERROR tuple struct `C` is private\n-    match c { a::C(_, _) => {} } //~ ERROR tuple struct `C` is private\n-    match c { a::C(_a, _) => {} } //~ ERROR tuple struct `C` is private\n-    match c { a::C(_, _b) => {} } //~ ERROR tuple struct `C` is private\n-    match c { a::C(_a, _b) => {} } //~ ERROR tuple struct `C` is private\n+    let a::A(()) = a; //~ ERROR tuple struct constructor `A` is private\n+    let a::A(_) = a; //~ ERROR tuple struct constructor `A` is private\n+    match a { a::A(()) => {} } //~ ERROR tuple struct constructor `A` is private\n+    match a { a::A(_) => {} } //~ ERROR tuple struct constructor `A` is private\n+\n+    let a::B(_) = b; //~ ERROR tuple struct constructor `B` is private\n+    let a::B(_b) = b; //~ ERROR tuple struct constructor `B` is private\n+    match b { a::B(_) => {} } //~ ERROR tuple struct constructor `B` is private\n+    match b { a::B(_b) => {} } //~ ERROR tuple struct constructor `B` is private\n+    match b { a::B(1) => {} a::B(_) => {} } //~ ERROR tuple struct constructor `B` is private\n+                                            //~^ ERROR tuple struct constructor `B` is private\n+\n+    let a::C(_, _) = c; //~ ERROR tuple struct constructor `C` is private\n+    let a::C(_a, _) = c; //~ ERROR tuple struct constructor `C` is private\n+    let a::C(_, _b) = c; //~ ERROR tuple struct constructor `C` is private\n+    let a::C(_a, _b) = c; //~ ERROR tuple struct constructor `C` is private\n+    match c { a::C(_, _) => {} } //~ ERROR tuple struct constructor `C` is private\n+    match c { a::C(_a, _) => {} } //~ ERROR tuple struct constructor `C` is private\n+    match c { a::C(_, _b) => {} } //~ ERROR tuple struct constructor `C` is private\n+    match c { a::C(_a, _b) => {} } //~ ERROR tuple struct constructor `C` is private\n \n     let a::D(_) = d;\n     let a::D(_d) = d;\n     match d { a::D(_) => {} }\n     match d { a::D(_d) => {} }\n     match d { a::D(1) => {} a::D(_) => {} }\n \n-    let a2 = a::A; //~ ERROR tuple struct `A` is private\n-    let b2 = a::B; //~ ERROR tuple struct `B` is private\n-    let c2 = a::C; //~ ERROR tuple struct `C` is private\n+    let a2 = a::A; //~ ERROR tuple struct constructor `A` is private\n+    let b2 = a::B; //~ ERROR tuple struct constructor `B` is private\n+    let c2 = a::C; //~ ERROR tuple struct constructor `C` is private\n     let d2 = a::D;\n }\n \n fn xcrate() {\n-    let a = other::A(()); //~ ERROR tuple struct `A` is private\n-    let b = other::B(2); //~ ERROR tuple struct `B` is private\n-    let c = other::C(2, 3); //~ ERROR tuple struct `C` is private\n+    let a = other::A(()); //~ ERROR tuple struct constructor `A` is private\n+    let b = other::B(2); //~ ERROR tuple struct constructor `B` is private\n+    let c = other::C(2, 3); //~ ERROR tuple struct constructor `C` is private\n     let d = other::D(4);\n \n-    let other::A(()) = a; //~ ERROR tuple struct `A` is private\n-    let other::A(_) = a; //~ ERROR tuple struct `A` is private\n-    match a { other::A(()) => {} } //~ ERROR tuple struct `A` is private\n-    match a { other::A(_) => {} } //~ ERROR tuple struct `A` is private\n-\n-    let other::B(_) = b; //~ ERROR tuple struct `B` is private\n-    let other::B(_b) = b; //~ ERROR tuple struct `B` is private\n-    match b { other::B(_) => {} } //~ ERROR tuple struct `B` is private\n-    match b { other::B(_b) => {} } //~ ERROR tuple struct `B` is private\n-    match b { other::B(1) => {} other::B(_) => {} } //~ ERROR tuple struct `B` is private\n-                                                    //~^ ERROR tuple struct `B` is private\n-\n-    let other::C(_, _) = c; //~ ERROR tuple struct `C` is private\n-    let other::C(_a, _) = c; //~ ERROR tuple struct `C` is private\n-    let other::C(_, _b) = c; //~ ERROR tuple struct `C` is private\n-    let other::C(_a, _b) = c; //~ ERROR tuple struct `C` is private\n-    match c { other::C(_, _) => {} } //~ ERROR tuple struct `C` is private\n-    match c { other::C(_a, _) => {} } //~ ERROR tuple struct `C` is private\n-    match c { other::C(_, _b) => {} } //~ ERROR tuple struct `C` is private\n-    match c { other::C(_a, _b) => {} } //~ ERROR tuple struct `C` is private\n+    let other::A(()) = a; //~ ERROR tuple struct constructor `A` is private\n+    let other::A(_) = a; //~ ERROR tuple struct constructor `A` is private\n+    match a { other::A(()) => {} } //~ ERROR tuple struct constructor `A` is private\n+    match a { other::A(_) => {} } //~ ERROR tuple struct constructor `A` is private\n+\n+    let other::B(_) = b; //~ ERROR tuple struct constructor `B` is private\n+    let other::B(_b) = b; //~ ERROR tuple struct constructor `B` is private\n+    match b { other::B(_) => {} } //~ ERROR tuple struct constructor `B` is private\n+    match b { other::B(_b) => {} } //~ ERROR tuple struct constructor `B` is private\n+    match b { other::B(1) => {}//~ ERROR tuple struct constructor `B` is private\n+        other::B(_) => {} }    //~ ERROR tuple struct constructor `B` is private\n+\n+    let other::C(_, _) = c; //~ ERROR tuple struct constructor `C` is private\n+    let other::C(_a, _) = c; //~ ERROR tuple struct constructor `C` is private\n+    let other::C(_, _b) = c; //~ ERROR tuple struct constructor `C` is private\n+    let other::C(_a, _b) = c; //~ ERROR tuple struct constructor `C` is private\n+    match c { other::C(_, _) => {} } //~ ERROR tuple struct constructor `C` is private\n+    match c { other::C(_a, _) => {} } //~ ERROR tuple struct constructor `C` is private\n+    match c { other::C(_, _b) => {} } //~ ERROR tuple struct constructor `C` is private\n+    match c { other::C(_a, _b) => {} } //~ ERROR tuple struct constructor `C` is private\n \n     let other::D(_) = d;\n     let other::D(_d) = d;\n     match d { other::D(_) => {} }\n     match d { other::D(_d) => {} }\n     match d { other::D(1) => {} other::D(_) => {} }\n \n-    let a2 = other::A; //~ ERROR tuple struct `A` is private\n-    let b2 = other::B; //~ ERROR tuple struct `B` is private\n-    let c2 = other::C; //~ ERROR tuple struct `C` is private\n+    let a2 = other::A; //~ ERROR tuple struct constructor `A` is private\n+    let b2 = other::B; //~ ERROR tuple struct constructor `B` is private\n+    let c2 = other::C; //~ ERROR tuple struct constructor `C` is private\n     let d2 = other::D;\n }\n "}, {"sha": "2ee83149b695f12c8234d9c47b66fdf90fbff4be", "filename": "src/test/ui/privacy/privacy5.stderr", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -1,220 +1,220 @@\n-error[E0603]: tuple struct `A` is private\n+error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:51:16\n    |\n LL |     pub struct A(());\n-   |                  -- a tuple struct constructor is private if any of its fields is private\n+   |                  -- a constructor is private if any of the fields is private\n ...\n LL |     let a = a::A(());\n    |                ^\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:52:16\n    |\n LL |     pub struct B(isize);\n-   |                  ----- a tuple struct constructor is private if any of its fields is private\n+   |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     let b = a::B(2);\n    |                ^\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:53:16\n    |\n LL |     pub struct C(pub isize, isize);\n-   |                  ---------------- a tuple struct constructor is private if any of its fields is private\n+   |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     let c = a::C(2, 3);\n    |                ^\n \n-error[E0603]: tuple struct `A` is private\n+error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:56:12\n    |\n LL |     pub struct A(());\n-   |                  -- a tuple struct constructor is private if any of its fields is private\n+   |                  -- a constructor is private if any of the fields is private\n ...\n LL |     let a::A(()) = a;\n    |            ^\n \n-error[E0603]: tuple struct `A` is private\n+error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:57:12\n    |\n LL |     pub struct A(());\n-   |                  -- a tuple struct constructor is private if any of its fields is private\n+   |                  -- a constructor is private if any of the fields is private\n ...\n LL |     let a::A(_) = a;\n    |            ^\n \n-error[E0603]: tuple struct `A` is private\n+error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:58:18\n    |\n LL |     pub struct A(());\n-   |                  -- a tuple struct constructor is private if any of its fields is private\n+   |                  -- a constructor is private if any of the fields is private\n ...\n LL |     match a { a::A(()) => {} }\n    |                  ^\n \n-error[E0603]: tuple struct `A` is private\n+error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:59:18\n    |\n LL |     pub struct A(());\n-   |                  -- a tuple struct constructor is private if any of its fields is private\n+   |                  -- a constructor is private if any of the fields is private\n ...\n LL |     match a { a::A(_) => {} }\n    |                  ^\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:61:12\n    |\n LL |     pub struct B(isize);\n-   |                  ----- a tuple struct constructor is private if any of its fields is private\n+   |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     let a::B(_) = b;\n    |            ^\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:62:12\n    |\n LL |     pub struct B(isize);\n-   |                  ----- a tuple struct constructor is private if any of its fields is private\n+   |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     let a::B(_b) = b;\n    |            ^\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:63:18\n    |\n LL |     pub struct B(isize);\n-   |                  ----- a tuple struct constructor is private if any of its fields is private\n+   |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     match b { a::B(_) => {} }\n    |                  ^\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:64:18\n    |\n LL |     pub struct B(isize);\n-   |                  ----- a tuple struct constructor is private if any of its fields is private\n+   |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     match b { a::B(_b) => {} }\n    |                  ^\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:65:18\n    |\n LL |     pub struct B(isize);\n-   |                  ----- a tuple struct constructor is private if any of its fields is private\n+   |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     match b { a::B(1) => {} a::B(_) => {} }\n    |                  ^\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:65:32\n    |\n LL |     pub struct B(isize);\n-   |                  ----- a tuple struct constructor is private if any of its fields is private\n+   |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     match b { a::B(1) => {} a::B(_) => {} }\n    |                                ^\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:68:12\n    |\n LL |     pub struct C(pub isize, isize);\n-   |                  ---------------- a tuple struct constructor is private if any of its fields is private\n+   |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     let a::C(_, _) = c;\n    |            ^\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:69:12\n    |\n LL |     pub struct C(pub isize, isize);\n-   |                  ---------------- a tuple struct constructor is private if any of its fields is private\n+   |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     let a::C(_a, _) = c;\n    |            ^\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:70:12\n    |\n LL |     pub struct C(pub isize, isize);\n-   |                  ---------------- a tuple struct constructor is private if any of its fields is private\n+   |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     let a::C(_, _b) = c;\n    |            ^\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:71:12\n    |\n LL |     pub struct C(pub isize, isize);\n-   |                  ---------------- a tuple struct constructor is private if any of its fields is private\n+   |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     let a::C(_a, _b) = c;\n    |            ^\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:72:18\n    |\n LL |     pub struct C(pub isize, isize);\n-   |                  ---------------- a tuple struct constructor is private if any of its fields is private\n+   |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     match c { a::C(_, _) => {} }\n    |                  ^\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:73:18\n    |\n LL |     pub struct C(pub isize, isize);\n-   |                  ---------------- a tuple struct constructor is private if any of its fields is private\n+   |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     match c { a::C(_a, _) => {} }\n    |                  ^\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:74:18\n    |\n LL |     pub struct C(pub isize, isize);\n-   |                  ---------------- a tuple struct constructor is private if any of its fields is private\n+   |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     match c { a::C(_, _b) => {} }\n    |                  ^\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:75:18\n    |\n LL |     pub struct C(pub isize, isize);\n-   |                  ---------------- a tuple struct constructor is private if any of its fields is private\n+   |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     match c { a::C(_a, _b) => {} }\n    |                  ^\n \n-error[E0603]: tuple struct `A` is private\n+error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:83:17\n    |\n LL |     pub struct A(());\n-   |                  -- a tuple struct constructor is private if any of its fields is private\n+   |                  -- a constructor is private if any of the fields is private\n ...\n LL |     let a2 = a::A;\n    |                 ^\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:84:17\n    |\n LL |     pub struct B(isize);\n-   |                  ----- a tuple struct constructor is private if any of its fields is private\n+   |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     let b2 = a::B;\n    |                 ^\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:85:17\n    |\n LL |     pub struct C(pub isize, isize);\n-   |                  ---------------- a tuple struct constructor is private if any of its fields is private\n+   |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     let c2 = a::C;\n    |                 ^\n \n-error[E0603]: tuple struct `A` is private\n+error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:90:20\n    |\n LL |     let a = other::A(());\n@@ -223,9 +223,9 @@ LL |     let a = other::A(());\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:1:14\n    |\n LL | pub struct A(());\n-   |              -- a tuple struct constructor is private if any of its fields is private\n+   |              -- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:91:20\n    |\n LL |     let b = other::B(2);\n@@ -234,9 +234,9 @@ LL |     let b = other::B(2);\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n-   |              ----- a tuple struct constructor is private if any of its fields is private\n+   |              ----- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:92:20\n    |\n LL |     let c = other::C(2, 3);\n@@ -245,9 +245,9 @@ LL |     let c = other::C(2, 3);\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n-   |              ---------------- a tuple struct constructor is private if any of its fields is private\n+   |              ---------------- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `A` is private\n+error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:95:16\n    |\n LL |     let other::A(()) = a;\n@@ -256,9 +256,9 @@ LL |     let other::A(()) = a;\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:1:14\n    |\n LL | pub struct A(());\n-   |              -- a tuple struct constructor is private if any of its fields is private\n+   |              -- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `A` is private\n+error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:96:16\n    |\n LL |     let other::A(_) = a;\n@@ -267,9 +267,9 @@ LL |     let other::A(_) = a;\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:1:14\n    |\n LL | pub struct A(());\n-   |              -- a tuple struct constructor is private if any of its fields is private\n+   |              -- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `A` is private\n+error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:97:22\n    |\n LL |     match a { other::A(()) => {} }\n@@ -278,9 +278,9 @@ LL |     match a { other::A(()) => {} }\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:1:14\n    |\n LL | pub struct A(());\n-   |              -- a tuple struct constructor is private if any of its fields is private\n+   |              -- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `A` is private\n+error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:98:22\n    |\n LL |     match a { other::A(_) => {} }\n@@ -289,9 +289,9 @@ LL |     match a { other::A(_) => {} }\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:1:14\n    |\n LL | pub struct A(());\n-   |              -- a tuple struct constructor is private if any of its fields is private\n+   |              -- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:100:16\n    |\n LL |     let other::B(_) = b;\n@@ -300,9 +300,9 @@ LL |     let other::B(_) = b;\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n-   |              ----- a tuple struct constructor is private if any of its fields is private\n+   |              ----- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:101:16\n    |\n LL |     let other::B(_b) = b;\n@@ -311,9 +311,9 @@ LL |     let other::B(_b) = b;\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n-   |              ----- a tuple struct constructor is private if any of its fields is private\n+   |              ----- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:102:22\n    |\n LL |     match b { other::B(_) => {} }\n@@ -322,9 +322,9 @@ LL |     match b { other::B(_) => {} }\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n-   |              ----- a tuple struct constructor is private if any of its fields is private\n+   |              ----- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:103:22\n    |\n LL |     match b { other::B(_b) => {} }\n@@ -333,31 +333,31 @@ LL |     match b { other::B(_b) => {} }\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n-   |              ----- a tuple struct constructor is private if any of its fields is private\n+   |              ----- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:104:22\n    |\n-LL |     match b { other::B(1) => {} other::B(_) => {} }\n+LL |     match b { other::B(1) => {}\n    |                      ^\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n-   |              ----- a tuple struct constructor is private if any of its fields is private\n+   |              ----- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:104:40\n+error[E0603]: tuple struct constructor `B` is private\n+  --> $DIR/privacy5.rs:105:16\n    |\n-LL |     match b { other::B(1) => {} other::B(_) => {} }\n-   |                                        ^\n+LL |         other::B(_) => {} }\n+   |                ^\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n-   |              ----- a tuple struct constructor is private if any of its fields is private\n+   |              ----- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:107:16\n    |\n LL |     let other::C(_, _) = c;\n@@ -366,9 +366,9 @@ LL |     let other::C(_, _) = c;\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n-   |              ---------------- a tuple struct constructor is private if any of its fields is private\n+   |              ---------------- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:108:16\n    |\n LL |     let other::C(_a, _) = c;\n@@ -377,9 +377,9 @@ LL |     let other::C(_a, _) = c;\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n-   |              ---------------- a tuple struct constructor is private if any of its fields is private\n+   |              ---------------- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:109:16\n    |\n LL |     let other::C(_, _b) = c;\n@@ -388,9 +388,9 @@ LL |     let other::C(_, _b) = c;\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n-   |              ---------------- a tuple struct constructor is private if any of its fields is private\n+   |              ---------------- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:110:16\n    |\n LL |     let other::C(_a, _b) = c;\n@@ -399,9 +399,9 @@ LL |     let other::C(_a, _b) = c;\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n-   |              ---------------- a tuple struct constructor is private if any of its fields is private\n+   |              ---------------- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:111:22\n    |\n LL |     match c { other::C(_, _) => {} }\n@@ -410,9 +410,9 @@ LL |     match c { other::C(_, _) => {} }\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n-   |              ---------------- a tuple struct constructor is private if any of its fields is private\n+   |              ---------------- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:112:22\n    |\n LL |     match c { other::C(_a, _) => {} }\n@@ -421,9 +421,9 @@ LL |     match c { other::C(_a, _) => {} }\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n-   |              ---------------- a tuple struct constructor is private if any of its fields is private\n+   |              ---------------- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:113:22\n    |\n LL |     match c { other::C(_, _b) => {} }\n@@ -432,9 +432,9 @@ LL |     match c { other::C(_, _b) => {} }\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n-   |              ---------------- a tuple struct constructor is private if any of its fields is private\n+   |              ---------------- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:114:22\n    |\n LL |     match c { other::C(_a, _b) => {} }\n@@ -443,9 +443,9 @@ LL |     match c { other::C(_a, _b) => {} }\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n-   |              ---------------- a tuple struct constructor is private if any of its fields is private\n+   |              ---------------- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `A` is private\n+error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:122:21\n    |\n LL |     let a2 = other::A;\n@@ -454,9 +454,9 @@ LL |     let a2 = other::A;\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:1:14\n    |\n LL | pub struct A(());\n-   |              -- a tuple struct constructor is private if any of its fields is private\n+   |              -- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `B` is private\n+error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:123:21\n    |\n LL |     let b2 = other::B;\n@@ -465,9 +465,9 @@ LL |     let b2 = other::B;\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n-   |              ----- a tuple struct constructor is private if any of its fields is private\n+   |              ----- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `C` is private\n+error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:124:21\n    |\n LL |     let c2 = other::C;\n@@ -476,7 +476,7 @@ LL |     let c2 = other::C;\n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n-   |              ---------------- a tuple struct constructor is private if any of its fields is private\n+   |              ---------------- a constructor is private if any of the fields is private\n \n error: aborting due to 48 previous errors\n "}, {"sha": "f9ae75b18317deeccae691d293ebebf51ebfcb4d", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -3,6 +3,13 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n    |\n LL |     let Ok(x) = res;\n    |         ^^^^^ pattern `Err(_)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Ok(x) = res { /* */ }\n+   |\n \n error[E0381]: use of possibly-uninitialized variable: `x`\n   --> $DIR/recursive-types-are-not-uninhabited.rs:8:5"}, {"sha": "0cf5d9cd5f12a6e6a223a61aae2ff7fa475d002b", "filename": "src/test/ui/refutable-pattern-errors.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -9,6 +9,13 @@ error[E0005]: refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` an\n    |\n LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n    |         ^^^^^^^^^^^^^^^^^^^^^ patterns `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let (1, (Some(1), 2..=3)) = (1, (None, 2)) { /* */ }\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0eecc7f8cc5db8d669d179b26b28601f58fe914a", "filename": "src/test/ui/resolve/privacy-struct-ctor.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -16,7 +16,7 @@ mod m {\n \n     fn f() {\n         n::Z;\n-        //~^ ERROR tuple struct `Z` is private\n+        //~^ ERROR tuple struct constructor `Z` is private\n         Z;\n         //~^ ERROR expected value, found struct `Z`\n     }\n@@ -27,21 +27,21 @@ use m::S2; // OK, only the type is imported\n \n fn main() {\n     m::S;\n-    //~^ ERROR tuple struct `S` is private\n+    //~^ ERROR tuple struct constructor `S` is private\n     let _: S = m::S(2);\n-    //~^ ERROR tuple struct `S` is private\n+    //~^ ERROR tuple struct constructor `S` is private\n     S;\n     //~^ ERROR expected value, found struct `S`\n     m::n::Z;\n-    //~^ ERROR tuple struct `Z` is private\n+    //~^ ERROR tuple struct constructor `Z` is private\n \n     S2;\n     //~^ ERROR expected value, found struct `S2`\n \n     xcrate::m::S;\n-    //~^ ERROR tuple struct `S` is private\n+    //~^ ERROR tuple struct constructor `S` is private\n     xcrate::S;\n     //~^ ERROR expected value, found struct `xcrate::S`\n     xcrate::m::n::Z;\n-    //~^ ERROR tuple struct `Z` is private\n+    //~^ ERROR tuple struct constructor `Z` is private\n }"}, {"sha": "7d884d3a66910ca38e7fae8ec2f661d812a65c6b", "filename": "src/test/ui/resolve/privacy-struct-ctor.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -34,43 +34,43 @@ help: possible better candidate is found in another module, you can import it in\n LL | use m::S;\n    |\n \n-error[E0603]: tuple struct `Z` is private\n+error[E0603]: tuple struct constructor `Z` is private\n   --> $DIR/privacy-struct-ctor.rs:18:12\n    |\n LL |         pub(in m) struct Z(pub(in m::n) u8);\n-   |                            --------------- a tuple struct constructor is private if any of its fields is private\n+   |                            --------------- a constructor is private if any of the fields is private\n ...\n LL |         n::Z;\n    |            ^\n \n-error[E0603]: tuple struct `S` is private\n+error[E0603]: tuple struct constructor `S` is private\n   --> $DIR/privacy-struct-ctor.rs:29:8\n    |\n LL |     pub struct S(u8);\n-   |                  -- a tuple struct constructor is private if any of its fields is private\n+   |                  -- a constructor is private if any of the fields is private\n ...\n LL |     m::S;\n    |        ^\n \n-error[E0603]: tuple struct `S` is private\n+error[E0603]: tuple struct constructor `S` is private\n   --> $DIR/privacy-struct-ctor.rs:31:19\n    |\n LL |     pub struct S(u8);\n-   |                  -- a tuple struct constructor is private if any of its fields is private\n+   |                  -- a constructor is private if any of the fields is private\n ...\n LL |     let _: S = m::S(2);\n    |                   ^\n \n-error[E0603]: tuple struct `Z` is private\n+error[E0603]: tuple struct constructor `Z` is private\n   --> $DIR/privacy-struct-ctor.rs:35:11\n    |\n LL |         pub(in m) struct Z(pub(in m::n) u8);\n-   |                            --------------- a tuple struct constructor is private if any of its fields is private\n+   |                            --------------- a constructor is private if any of the fields is private\n ...\n LL |     m::n::Z;\n    |           ^\n \n-error[E0603]: tuple struct `S` is private\n+error[E0603]: tuple struct constructor `S` is private\n   --> $DIR/privacy-struct-ctor.rs:41:16\n    |\n LL |     xcrate::m::S;\n@@ -79,9 +79,9 @@ LL |     xcrate::m::S;\n   ::: $DIR/auxiliary/privacy-struct-ctor.rs:2:18\n    |\n LL |     pub struct S(u8);\n-   |                  -- a tuple struct constructor is private if any of its fields is private\n+   |                  -- a constructor is private if any of the fields is private\n \n-error[E0603]: tuple struct `Z` is private\n+error[E0603]: tuple struct constructor `Z` is private\n   --> $DIR/privacy-struct-ctor.rs:45:19\n    |\n LL |     xcrate::m::n::Z;\n@@ -90,7 +90,7 @@ LL |     xcrate::m::n::Z;\n   ::: $DIR/auxiliary/privacy-struct-ctor.rs:5:28\n    |\n LL |         pub(in m) struct Z(pub(in m::n) u8);\n-   |                            --------------- a tuple struct constructor is private if any of its fields is private\n+   |                            --------------- a constructor is private if any of the fields is private\n \n error: aborting due to 10 previous errors\n "}, {"sha": "cf383a260e044be784f32d9ae48d9707eeb18d09", "filename": "src/test/ui/rfc-2008-non-exhaustive/struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.rs?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -21,7 +21,7 @@ fn main() {\n     //~^ ERROR expected function, found struct `TupleStruct` [E0423]\n \n     let ts_explicit = structs::TupleStruct(640, 480);\n-    //~^ ERROR tuple struct `TupleStruct` is private [E0603]\n+    //~^ ERROR tuple struct constructor `TupleStruct` is private [E0603]\n \n     let TupleStruct { 0: first_field, 1: second_field } = ts;\n     //~^ ERROR `..` required with struct marked as non-exhaustive"}, {"sha": "d3686a1b869619357613b5c101839b88cb8f0e13", "filename": "src/test/ui/rfc-2008-non-exhaustive/struct.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -10,7 +10,7 @@ error[E0423]: expected value, found struct `UnitStruct`\n LL |     let us = UnitStruct;\n    |              ^^^^^^^^^^ constructor is not visible here due to private fields\n \n-error[E0603]: tuple struct `TupleStruct` is private\n+error[E0603]: tuple struct constructor `TupleStruct` is private\n   --> $DIR/struct.rs:23:32\n    |\n LL |     let ts_explicit = structs::TupleStruct(640, 480);\n@@ -19,7 +19,7 @@ LL |     let ts_explicit = structs::TupleStruct(640, 480);\n   ::: $DIR/auxiliary/structs.rs:13:24\n    |\n LL | pub struct TupleStruct(pub u16, pub u16);\n-   |                        ---------------- a tuple struct constructor is private if any of its fields is private\n+   |                        ---------------- a constructor is private if any of the fields is private\n \n error[E0603]: unit struct `UnitStruct` is private\n   --> $DIR/struct.rs:32:32"}, {"sha": "26e1be34ea75dfb651fa8c4e38c791bb842a617f", "filename": "src/test/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -12,6 +12,13 @@ LL | | }\n ...\n LL |       let Foo::D(_y) = x;\n    |           ^^^^^^^^^^ pattern `A(_)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Foo::D(_y) = x { /* */ }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "a49344e45cec652775d6737f3b8c178d9477e0fa", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ae564d391a3da10bca2a79ab529a9925fbe58/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=aa2ae564d391a3da10bca2a79ab529a9925fbe58", "patch": "@@ -51,6 +51,13 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n    |\n LL |     let Ok(x) = x;\n    |         ^^^^^ pattern `Err(_)` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |     if let Ok(x) = x { /* */ }\n+   |\n \n error: aborting due to 7 previous errors\n "}]}