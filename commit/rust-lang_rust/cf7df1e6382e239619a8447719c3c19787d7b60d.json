{"sha": "cf7df1e6382e239619a8447719c3c19787d7b60d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmN2RmMWU2MzgyZTIzOTYxOWE4NDQ3NzE5YzNjMTk3ODdkN2I2MGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-19T07:21:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-19T07:21:42Z"}, "message": "auto merge of #18483 : eddyb/rust/safe-ty, r=nikomatsakis\n\nAfter more than a month of sitting on this patch, rebasing and tracking down some nasty bugs (there's might be still one out there, but it only manifested in `middle::trans::reflect` which is now gone), I'd like to merge it as it is.\r\n\r\nThis changeset makes middle::ty safe, linking the lifetime of a type to the type context it was created in.\r\nIt's a prerequisite for introducing function-local type contexts to localize types with inference variables, in order to (potentially) free hundreds of MBs from rustc's memory usage peak.", "tree": {"sha": "a2d0dad24dec23d2f80c805968ef79ab072ad936", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2d0dad24dec23d2f80c805968ef79ab072ad936"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf7df1e6382e239619a8447719c3c19787d7b60d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf7df1e6382e239619a8447719c3c19787d7b60d", "html_url": "https://github.com/rust-lang/rust/commit/cf7df1e6382e239619a8447719c3c19787d7b60d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf7df1e6382e239619a8447719c3c19787d7b60d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e09d98603e608c9e47d4c89f7b4dca87a4b56da3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e09d98603e608c9e47d4c89f7b4dca87a4b56da3", "html_url": "https://github.com/rust-lang/rust/commit/e09d98603e608c9e47d4c89f7b4dca87a4b56da3"}, {"sha": "bf0766ada1a43c58f844f951ae2319185f3e2ceb", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf0766ada1a43c58f844f951ae2319185f3e2ceb", "html_url": "https://github.com/rust-lang/rust/commit/bf0766ada1a43c58f844f951ae2319185f3e2ceb"}], "stats": {"total": 10089, "additions": 5115, "deletions": 4974}, "files": [{"sha": "fce8627e226738b7b08e4e174a30b6e33f3b6d3d", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -28,9 +28,10 @@ use self::MethodContext::*;\n \n use metadata::csearch;\n use middle::def::*;\n+use middle::ty::{mod, Ty};\n use middle::typeck::astconv::ast_ty_to_ty;\n-use middle::typeck::infer;\n-use middle::{typeck, ty, def, pat_util, stability};\n+use middle::typeck::{mod, infer};\n+use middle::{def, pat_util, stability};\n use middle::const_eval::{eval_const_expr_partial, const_int, const_uint};\n use util::ppaux::{ty_to_string};\n use util::nodemap::{FnvHashMap, NodeSet};\n@@ -99,7 +100,7 @@ impl LintPass for UnusedCasts {\n         match e.node {\n             ast::ExprCast(ref expr, ref ty) => {\n                 let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &**ty);\n-                if ty::get(ty::expr_ty(cx.tcx, &**expr)).sty == ty::get(t_t).sty {\n+                if ty::expr_ty(cx.tcx, &**expr) == t_t {\n                     cx.span_lint(UNUSED_TYPECASTS, ty.span, \"unnecessary type cast\");\n                 }\n             }\n@@ -155,7 +156,7 @@ impl LintPass for TypeLimits {\n                     },\n                     _ => {\n                         let t = ty::expr_ty(cx.tcx, &**expr);\n-                        match ty::get(t).sty {\n+                        match t.sty {\n                             ty::ty_uint(_) => {\n                                 cx.span_lint(UNSIGNED_NEGATION, e.span,\n                                              \"negation of unsigned int variable may \\\n@@ -180,7 +181,7 @@ impl LintPass for TypeLimits {\n                 }\n \n                 if is_shift_binop(binop) {\n-                    let opt_ty_bits = match ty::get(ty::expr_ty(cx.tcx, &**l)).sty {\n+                    let opt_ty_bits = match ty::expr_ty(cx.tcx, &**l).sty {\n                         ty::ty_int(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::ty_uint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None\n@@ -205,7 +206,7 @@ impl LintPass for TypeLimits {\n                 }\n             },\n             ast::ExprLit(ref lit) => {\n-                match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n+                match ty::expr_ty(cx.tcx, e).sty {\n                     ty::ty_int(t) => {\n                         match lit.node {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n@@ -343,7 +344,7 @@ impl LintPass for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match ty::get(ty::expr_ty(tcx, expr)).sty {\n+            match ty::expr_ty(tcx, expr).sty {\n                 ty::ty_int(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n@@ -473,10 +474,11 @@ declare_lint!(BOX_POINTERS, Allow,\n pub struct BoxPointers;\n \n impl BoxPointers {\n-    fn check_heap_type(&self, cx: &Context, span: Span, ty: ty::t) {\n+    fn check_heap_type<'a, 'tcx>(&self, cx: &Context<'a, 'tcx>,\n+                                 span: Span, ty: Ty<'tcx>) {\n         let mut n_uniq = 0i;\n         ty::fold_ty(cx.tcx, ty, |t| {\n-            match ty::get(t).sty {\n+            match t.sty {\n                 ty::ty_uniq(_) |\n                 ty::ty_closure(box ty::ClosureTy {\n                     store: ty::UniqTraitStore,\n@@ -576,7 +578,7 @@ impl LintPass for RawPointerDeriving {\n         }\n         let did = match item.node {\n             ast::ItemImpl(..) => {\n-                match ty::get(ty::node_id_to_type(cx.tcx, item.id)).sty {\n+                match ty::node_id_to_type(cx.tcx, item.id).sty {\n                     ty::ty_enum(did, _) => did,\n                     ty::ty_struct(did, _) => did,\n                     _ => return,\n@@ -738,7 +740,7 @@ impl LintPass for UnusedResults {\n \n         let t = ty::expr_ty(cx.tcx, expr);\n         let mut warned = false;\n-        match ty::get(t).sty {\n+        match t.sty {\n             ty::ty_tup(ref tys) if tys.is_empty() => return,\n             ty::ty_bool => return,\n             ty::ty_struct(did, _) |"}, {"sha": "83f14d3a0db54868a2da890a1b9f6a15fab1ed8c", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -27,7 +27,7 @@ use self::TargetLint::*;\n \n use middle::privacy::ExportedItems;\n use middle::subst;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::astconv::AstConv;\n use middle::typeck::infer;\n use session::{early_error, Session};\n@@ -546,30 +546,30 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n impl<'a, 'tcx> AstConv<'tcx> for Context<'a, 'tcx>{\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         ty::lookup_item_type(self.tcx, id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         ty::lookup_trait_def(self.tcx, id)\n     }\n \n-    fn ty_infer(&self, _span: Span) -> ty::t {\n+    fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n         infer::new_infer_ctxt(self.tcx).next_ty_var()\n     }\n \n-    fn associated_types_of_trait_are_valid(&self, _: ty::t, _: ast::DefId)\n+    fn associated_types_of_trait_are_valid(&self, _: Ty<'tcx>, _: ast::DefId)\n                                            -> bool {\n         // FIXME(pcwalton): This is wrong.\n         true\n     }\n \n     fn associated_type_binding(&self,\n                                _: Span,\n-                               _: Option<ty::t>,\n+                               _: Option<Ty<'tcx>>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty<'tcx> {\n         // FIXME(pcwalton): This is wrong.\n         let trait_def = self.get_trait_def(trait_id);\n         let index = ty::associated_type_parameter_index(self.tcx,"}, {"sha": "20e3f27f2ae18d2418af1a7622478c784cb42ce4", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -123,8 +123,8 @@ pub fn get_enum_variant_defs(cstore: &cstore::CStore, enum_id: ast::DefId)\n     decoder::get_enum_variant_defs(&*cstore.intr, &*cdata, enum_id.node)\n }\n \n-pub fn get_enum_variants(tcx: &ty::ctxt, def: ast::DefId)\n-                      -> Vec<Rc<ty::VariantInfo>> {\n+pub fn get_enum_variants<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+                               -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_enum_variants(cstore.intr.clone(), &*cdata, def.node, tcx)\n@@ -137,8 +137,8 @@ pub fn get_impl_items(cstore: &cstore::CStore, impl_def_id: ast::DefId)\n     decoder::get_impl_items(&*cdata, impl_def_id.node)\n }\n \n-pub fn get_impl_or_trait_item(tcx: &ty::ctxt, def: ast::DefId)\n-                              -> ty::ImplOrTraitItem {\n+pub fn get_impl_or_trait_item<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+                                    -> ty::ImplOrTraitItem<'tcx> {\n     let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n     decoder::get_impl_or_trait_item(tcx.sess.cstore.intr.clone(),\n                                     &*cdata,\n@@ -166,15 +166,17 @@ pub fn get_item_variances(cstore: &cstore::CStore,\n     decoder::get_item_variances(&*cdata, def.node)\n }\n \n-pub fn get_provided_trait_methods(tcx: &ty::ctxt,\n-                                  def: ast::DefId)\n-                               -> Vec<Rc<ty::Method>> {\n+pub fn get_provided_trait_methods<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                        def: ast::DefId)\n+                                        -> Vec<Rc<ty::Method<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits(tcx: &ty::ctxt, def: ast::DefId) -> Vec<Rc<ty::TraitRef>> {\n+pub fn get_supertraits<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                             def: ast::DefId)\n+                             -> Vec<Rc<ty::TraitRef<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_supertraits(&*cdata, def.node, tcx)\n@@ -213,22 +215,22 @@ pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: ast::DefId) -> HashM\n     decoder::get_struct_field_attrs(&*cdata)\n }\n \n-pub fn get_type(tcx: &ty::ctxt,\n-                def: ast::DefId)\n-             -> ty::Polytype {\n+pub fn get_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                      def: ast::DefId)\n+                      -> ty::Polytype<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type(&*cdata, def.node, tcx)\n }\n \n-pub fn get_trait_def(tcx: &ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n+pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::TraitDef<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_def(&*cdata, def.node, tcx)\n }\n \n-pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n-                      def: ast::DefId) -> ty::Polytype {\n+pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n+                            def: ast::DefId) -> ty::Polytype<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n     let all_items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n@@ -255,17 +257,18 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n \n // Given a def_id for an impl, return the trait it implements,\n // if there is one.\n-pub fn get_impl_trait(tcx: &ty::ctxt,\n-                      def: ast::DefId) -> Option<Rc<ty::TraitRef>> {\n+pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                            def: ast::DefId)\n+                            -> Option<Rc<ty::TraitRef<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_trait(&*cdata, def.node, tcx)\n }\n \n // Given a def_id for an impl, return information about its vtables\n-pub fn get_impl_vtables(tcx: &ty::ctxt,\n-                        def: ast::DefId)\n-                        -> typeck::vtable_res {\n+pub fn get_impl_vtables<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              def: ast::DefId)\n+                              -> typeck::vtable_res<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_vtables(&*cdata, def.node, tcx)"}, {"sha": "209e78682b418b3c5f77207c58c975770ae5a361", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 47, "deletions": 41, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -29,7 +29,7 @@ use middle::lang_items;\n use middle::resolve::{TraitItemKind, TypeTraitItemKind};\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n \n@@ -224,39 +224,44 @@ fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n     })\n }\n \n-fn doc_type(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n+fn doc_type<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n }\n \n-fn doc_method_fty(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n+fn doc_method_fty<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>,\n+                        cdata: Cmd) -> ty::BareFnTy<'tcx> {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n     parse_bare_fn_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                           |_, did| translate_def_id(cdata, did))\n }\n \n-pub fn item_type(_item_id: ast::DefId, item: rbml::Doc,\n-                 tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n+pub fn item_type<'tcx>(_item_id: ast::DefId, item: rbml::Doc,\n+                       tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     doc_type(item, tcx, cdata)\n }\n \n-fn doc_trait_ref(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n+fn doc_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n+                       -> ty::TraitRef<'tcx> {\n     parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n-fn item_trait_ref(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n+fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n+                        -> ty::TraitRef<'tcx> {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn doc_bounds(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::ParamBounds {\n+fn doc_bounds<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n+                    -> ty::ParamBounds<'tcx> {\n     parse_bounds_data(doc.data, cdata.cnum, doc.start, tcx,\n                       |_, did| translate_def_id(cdata, did))\n }\n \n-fn trait_def_bounds(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::ParamBounds {\n+fn trait_def_bounds<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n+                          -> ty::ParamBounds<'tcx> {\n     let d = reader::get_doc(doc, tag_trait_def_bounds);\n     doc_bounds(d, tcx, cdata)\n }\n@@ -353,9 +358,9 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     }\n }\n \n-pub fn get_trait_def(cdata: Cmd,\n-                     item_id: ast::NodeId,\n-                     tcx: &ty::ctxt) -> ty::TraitDef\n+pub fn get_trait_def<'tcx>(cdata: Cmd,\n+                           item_id: ast::NodeId,\n+                           tcx: &ty::ctxt<'tcx>) -> ty::TraitDef<'tcx>\n {\n     let item_doc = lookup_item(item_id, cdata.data());\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n@@ -368,8 +373,8 @@ pub fn get_trait_def(cdata: Cmd,\n     }\n }\n \n-pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n-    -> ty::Polytype {\n+pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n+    -> ty::Polytype<'tcx> {\n \n     let item = lookup_item(id, cdata.data());\n \n@@ -403,20 +408,21 @@ pub fn get_repr_attrs(cdata: Cmd, id: ast::NodeId) -> Vec<attr::ReprAttr> {\n     }\n }\n \n-pub fn get_impl_trait(cdata: Cmd,\n-                      id: ast::NodeId,\n-                      tcx: &ty::ctxt) -> Option<Rc<ty::TraitRef>>\n+pub fn get_impl_trait<'tcx>(cdata: Cmd,\n+                            id: ast::NodeId,\n+                            tcx: &ty::ctxt<'tcx>)\n+                            -> Option<Rc<ty::TraitRef<'tcx>>>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n         Rc::new(doc_trait_ref(tp, tcx, cdata))\n     })\n }\n \n-pub fn get_impl_vtables(cdata: Cmd,\n-                        id: ast::NodeId,\n-                        tcx: &ty::ctxt)\n-                        -> typeck::vtable_res\n+pub fn get_impl_vtables<'tcx>(cdata: Cmd,\n+                              id: ast::NodeId,\n+                              tcx: &ty::ctxt<'tcx>)\n+                              -> typeck::vtable_res<'tcx>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     let vtables_doc = reader::get_doc(item_doc, tag_item_impl_vtables);\n@@ -682,8 +688,8 @@ pub fn get_enum_variant_defs(intr: &IdentInterner,\n     }).collect()\n }\n \n-pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n-                     tcx: &ty::ctxt) -> Vec<Rc<ty::VariantInfo>> {\n+pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n+                               tcx: &ty::ctxt<'tcx>) -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n     let data = cdata.data();\n     let items = reader::get_doc(rbml::Doc::new(data), tag_items);\n     let item = find_item(id, items);\n@@ -693,7 +699,7 @@ pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n         let ctor_ty = item_type(ast::DefId { krate: cdata.cnum, node: id},\n                                 item, tcx, cdata);\n         let name = item_name(&*intr, item);\n-        let (ctor_ty, arg_tys) = match ty::get(ctor_ty).sty {\n+        let (ctor_ty, arg_tys) = match ctor_ty.sty {\n             ty::ty_bare_fn(ref f) =>\n                 (Some(ctor_ty), f.sig.inputs.clone()),\n             _ => // Nullary or struct enum variant.\n@@ -786,11 +792,11 @@ pub fn get_trait_item_name_and_kind(intr: Rc<IdentInterner>,\n     }\n }\n \n-pub fn get_impl_or_trait_item(intr: Rc<IdentInterner>,\n-                              cdata: Cmd,\n-                              id: ast::NodeId,\n-                              tcx: &ty::ctxt)\n-                              -> ty::ImplOrTraitItem {\n+pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n+                                    cdata: Cmd,\n+                                    id: ast::NodeId,\n+                                    tcx: &ty::ctxt<'tcx>)\n+                                    -> ty::ImplOrTraitItem<'tcx> {\n     let method_doc = lookup_item(id, cdata.data());\n \n     let def_id = item_def_id(method_doc, cdata);\n@@ -860,11 +866,11 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n     Decodable::decode(&mut decoder).unwrap()\n }\n \n-pub fn get_provided_trait_methods(intr: Rc<IdentInterner>,\n-                                  cdata: Cmd,\n-                                  id: ast::NodeId,\n-                                  tcx: &ty::ctxt)\n-                                  -> Vec<Rc<ty::Method>> {\n+pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n+                                        cdata: Cmd,\n+                                        id: ast::NodeId,\n+                                        tcx: &ty::ctxt<'tcx>)\n+                                        -> Vec<Rc<ty::Method<'tcx>>> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n     let mut result = Vec::new();\n@@ -892,8 +898,8 @@ pub fn get_provided_trait_methods(intr: Rc<IdentInterner>,\n }\n \n /// Returns the supertraits of the given trait.\n-pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n-                    -> Vec<Rc<ty::TraitRef>> {\n+pub fn get_supertraits<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n+                             -> Vec<Rc<ty::TraitRef<'tcx>>> {\n     let mut results = Vec::new();\n     let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n@@ -1388,11 +1394,11 @@ pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n     }\n }\n \n-fn doc_generics(base_doc: rbml::Doc,\n-                tcx: &ty::ctxt,\n-                cdata: Cmd,\n-                tag: uint)\n-                -> ty::Generics\n+fn doc_generics<'tcx>(base_doc: rbml::Doc,\n+                      tcx: &ty::ctxt<'tcx>,\n+                      cdata: Cmd,\n+                      tag: uint)\n+                      -> ty::Generics<'tcx>\n {\n     let doc = reader::get_doc(base_doc, tag);\n "}, {"sha": "7e4d2621f1837ab4dee232b4640e4a882ac20640", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 119, "deletions": 118, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -22,7 +22,7 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n use middle::ty::{lookup_item_type};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::stability;\n use middle;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n@@ -32,8 +32,7 @@ use std::cell::RefCell;\n use std::hash::Hash;\n use std::hash;\n use syntax::abi;\n-use syntax::ast::*;\n-use syntax::ast;\n+use syntax::ast::{mod, DefId, NodeId};\n use syntax::ast_map::{PathElem, PathElems};\n use syntax::ast_map;\n use syntax::ast_util::*;\n@@ -53,8 +52,8 @@ use rbml::io::SeekableMemWriter;\n /// A borrowed version of `ast::InlinedItem`.\n pub enum InlinedItemRef<'a> {\n     IIItemRef(&'a ast::Item),\n-    IITraitItemRef(ast::DefId, &'a ast::TraitItem),\n-    IIImplItemRef(ast::DefId, &'a ast::ImplItem),\n+    IITraitItemRef(DefId, &'a ast::TraitItem),\n+    IIImplItemRef(DefId, &'a ast::ImplItem),\n     IIForeignRef(&'a ast::ForeignItem)\n }\n \n@@ -83,15 +82,15 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n     pub encode_inlined_item: RefCell<EncodeInlinedItem<'a>>,\n-    pub type_abbrevs: tyencode::abbrev_map,\n+    pub type_abbrevs: tyencode::abbrev_map<'tcx>,\n     pub reachable: &'a NodeSet,\n }\n \n-fn encode_name(rbml_w: &mut Encoder, name: Name) {\n+fn encode_name(rbml_w: &mut Encoder, name: ast::Name) {\n     rbml_w.wr_tagged_str(tag_paths_data_name, token::get_name(name).get());\n }\n \n-fn encode_impl_type_basename(rbml_w: &mut Encoder, name: Ident) {\n+fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Ident) {\n     rbml_w.wr_tagged_str(tag_item_impl_type_basename, token::get_ident(name).get());\n }\n \n@@ -105,10 +104,10 @@ struct entry<T> {\n     pos: u64\n }\n \n-fn encode_trait_ref(rbml_w: &mut Encoder,\n-                    ecx: &EncodeContext,\n-                    trait_ref: &ty::TraitRef,\n-                    tag: uint) {\n+fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n+                              ecx: &EncodeContext<'a, 'tcx>,\n+                              trait_ref: &ty::TraitRef<'tcx>,\n+                              tag: uint) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n@@ -134,16 +133,16 @@ pub fn def_to_string(did: DefId) -> String {\n \n fn encode_item_variances(rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n-                         id: ast::NodeId) {\n+                         id: NodeId) {\n     let v = ty::item_variances(ecx.tcx, ast_util::local_def(id));\n     rbml_w.start_tag(tag_item_variances);\n     v.encode(rbml_w);\n     rbml_w.end_tag();\n }\n \n-fn encode_bounds_and_type(rbml_w: &mut Encoder,\n-                          ecx: &EncodeContext,\n-                          pty: &ty::Polytype) {\n+fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n+                                    ecx: &EncodeContext<'a, 'tcx>,\n+                                    pty: &ty::Polytype<'tcx>) {\n     encode_generics(rbml_w, ecx, &pty.generics, tag_item_generics);\n     encode_type(ecx, rbml_w, pty.ty);\n }\n@@ -159,9 +158,9 @@ fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.end_tag();\n }\n \n-pub fn write_closure_type(ecx: &EncodeContext,\n-                          rbml_w: &mut Encoder,\n-                          closure_type: &ty::ClosureTy) {\n+pub fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                    rbml_w: &mut Encoder,\n+                                    closure_type: &ty::ClosureTy<'tcx>) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n@@ -171,9 +170,9 @@ pub fn write_closure_type(ecx: &EncodeContext,\n     tyencode::enc_closure_ty(rbml_w.writer, ty_str_ctxt, closure_type);\n }\n \n-pub fn write_type(ecx: &EncodeContext,\n-                  rbml_w: &mut Encoder,\n-                  typ: ty::t) {\n+pub fn write_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                            rbml_w: &mut Encoder,\n+                            typ: Ty<'tcx>) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n@@ -183,9 +182,9 @@ pub fn write_type(ecx: &EncodeContext,\n     tyencode::enc_ty(rbml_w.writer, ty_str_ctxt, typ);\n }\n \n-pub fn write_trait_ref(ecx: &EncodeContext,\n-                       rbml_w: &mut Encoder,\n-                       trait_ref: &ty::TraitRef) {\n+pub fn write_trait_ref<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                 rbml_w: &mut Encoder,\n+                                trait_ref: &ty::TraitRef<'tcx>) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n@@ -207,10 +206,10 @@ pub fn write_region(ecx: &EncodeContext,\n     tyencode::enc_region(rbml_w.writer, ty_str_ctxt, r);\n }\n \n-fn encode_bounds(rbml_w: &mut Encoder,\n-                 ecx: &EncodeContext,\n-                 bounds: &ty::ParamBounds,\n-                 tag: uint) {\n+fn encode_bounds<'a, 'tcx>(rbml_w: &mut Encoder,\n+                           ecx: &EncodeContext<'a, 'tcx>,\n+                           bounds: &ty::ParamBounds<'tcx>,\n+                           tag: uint) {\n     rbml_w.start_tag(tag);\n \n     let ty_str_ctxt = &tyencode::ctxt { diag: ecx.diag,\n@@ -222,9 +221,9 @@ fn encode_bounds(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_type(ecx: &EncodeContext,\n-               rbml_w: &mut Encoder,\n-               typ: ty::t) {\n+fn encode_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                         rbml_w: &mut Encoder,\n+                         typ: Ty<'tcx>) {\n     rbml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, rbml_w, typ);\n     rbml_w.end_tag();\n@@ -238,9 +237,9 @@ fn encode_region(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn encode_method_fty(ecx: &EncodeContext,\n-                     rbml_w: &mut Encoder,\n-                     typ: &ty::BareFnTy) {\n+fn encode_method_fty<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                               rbml_w: &mut Encoder,\n+                               typ: &ty::BareFnTy<'tcx>) {\n     rbml_w.start_tag(tag_item_method_fty);\n \n     let ty_str_ctxt = &tyencode::ctxt {\n@@ -310,14 +309,14 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n fn encode_enum_variant_info(ecx: &EncodeContext,\n                             rbml_w: &mut Encoder,\n                             id: NodeId,\n-                            variants: &[P<Variant>],\n+                            variants: &[P<ast::Variant>],\n                             index: &mut Vec<entry<i64>>) {\n     debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n-                               ast::DefId { krate: LOCAL_CRATE, node: id });\n+                               DefId { krate: ast::LOCAL_CRATE, node: id });\n     for variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n         index.push(entry {\n@@ -382,7 +381,7 @@ fn encode_path<PI: Iterator<PathElem> + Clone>(rbml_w: &mut Encoder,\n fn encode_reexported_static_method(rbml_w: &mut Encoder,\n                                    exp: &middle::resolve::Export2,\n                                    method_def_id: DefId,\n-                                   method_name: Name) {\n+                                   method_name: ast::Name) {\n     debug!(\"(encode reexported static method) {}::{}\",\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n@@ -504,18 +503,18 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// * For enums, iterates through the node IDs of the variants.\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id(item: &Item, callback: |NodeId| -> bool) -> bool {\n+fn each_auxiliary_node_id(item: &ast::Item, callback: |NodeId| -> bool) -> bool {\n     let mut continue_ = true;\n     match item.node {\n-        ItemEnum(ref enum_def, _) => {\n+        ast::ItemEnum(ref enum_def, _) => {\n             for variant in enum_def.variants.iter() {\n                 continue_ = callback(variant.node.id);\n                 if !continue_ {\n                     break\n                 }\n             }\n         }\n-        ItemStruct(ref struct_def, _) => {\n+        ast::ItemStruct(ref struct_def, _) => {\n             // If this is a newtype struct, return the constructor.\n             match struct_def.ctor_id {\n                 Some(ctor_id) if struct_def.fields.len() > 0 &&\n@@ -566,12 +565,12 @@ fn encode_reexports(ecx: &EncodeContext,\n \n fn encode_info_for_mod(ecx: &EncodeContext,\n                        rbml_w: &mut Encoder,\n-                       md: &Mod,\n-                       attrs: &[Attribute],\n+                       md: &ast::Mod,\n+                       attrs: &[ast::Attribute],\n                        id: NodeId,\n                        path: PathElems,\n-                       name: Ident,\n-                       vis: Visibility) {\n+                       name: ast::Ident,\n+                       vis: ast::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id(rbml_w, local_def(id));\n     encode_family(rbml_w, 'm');\n@@ -593,7 +592,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         });\n \n         match item.node {\n-            ItemImpl(..) => {\n+            ast::ItemImpl(..) => {\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl {} \\\n                         ({}/{})\",\n@@ -615,7 +614,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     encode_stability(rbml_w, stab);\n \n     // Encode the reexports of this module, if this module is public.\n-    if vis == Public {\n+    if vis == ast::Public {\n         debug!(\"(encoding info for module) encoding reexports for {}\", id);\n         encode_reexports(ecx, rbml_w, id, path);\n     }\n@@ -625,18 +624,18 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n }\n \n fn encode_struct_field_family(rbml_w: &mut Encoder,\n-                              visibility: Visibility) {\n+                              visibility: ast::Visibility) {\n     encode_family(rbml_w, match visibility {\n-        Public => 'g',\n-        Inherited => 'N'\n+        ast::Public => 'g',\n+        ast::Inherited => 'N'\n     });\n }\n \n-fn encode_visibility(rbml_w: &mut Encoder, visibility: Visibility) {\n+fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n     rbml_w.start_tag(tag_items_data_item_visibility);\n     let ch = match visibility {\n-        Public => 'y',\n-        Inherited => 'i',\n+        ast::Public => 'y',\n+        ast::Inherited => 'i',\n     };\n     rbml_w.wr_str(ch.to_string().as_slice());\n     rbml_w.end_tag();\n@@ -681,8 +680,8 @@ fn encode_explicit_self(rbml_w: &mut Encoder,\n     fn encode_mutability(rbml_w: &mut Encoder,\n                          m: ast::Mutability) {\n         match m {\n-            MutImmutable => { rbml_w.writer.write(&[ 'i' as u8 ]); }\n-            MutMutable => { rbml_w.writer.write(&[ 'm' as u8 ]); }\n+            ast::MutImmutable => { rbml_w.writer.write(&[ 'i' as u8 ]); }\n+            ast::MutMutable => { rbml_w.writer.write(&[ 'm' as u8 ]); }\n         }\n     }\n }\n@@ -782,10 +781,10 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn encode_generics(rbml_w: &mut Encoder,\n-                   ecx: &EncodeContext,\n-                   generics: &ty::Generics,\n-                   tag: uint)\n+fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n+                             ecx: &EncodeContext<'a, 'tcx>,\n+                             generics: &ty::Generics<'tcx>,\n+                             tag: uint)\n {\n     rbml_w.start_tag(tag);\n \n@@ -829,9 +828,9 @@ fn encode_generics(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_method_ty_fields(ecx: &EncodeContext,\n-                           rbml_w: &mut Encoder,\n-                           method_ty: &ty::Method) {\n+fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                     rbml_w: &mut Encoder,\n+                                     method_ty: &ty::Method<'tcx>) {\n     encode_def_id(rbml_w, method_ty.def_id);\n     encode_name(rbml_w, method_ty.name);\n     encode_generics(rbml_w, ecx, &method_ty.generics,\n@@ -848,13 +847,13 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n     encode_provided_source(rbml_w, method_ty.provided_source);\n }\n \n-fn encode_info_for_method(ecx: &EncodeContext,\n-                          rbml_w: &mut Encoder,\n-                          m: &ty::Method,\n-                          impl_path: PathElems,\n-                          is_default_impl: bool,\n-                          parent_id: NodeId,\n-                          ast_item_opt: Option<&ImplItem>) {\n+fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                    rbml_w: &mut Encoder,\n+                                    m: &ty::Method<'tcx>,\n+                                    impl_path: PathElems,\n+                                    is_default_impl: bool,\n+                                    parent_id: NodeId,\n+                                    ast_item_opt: Option<&ast::ImplItem>) {\n \n     debug!(\"encode_info_for_method: {} {}\", m.def_id,\n            token::get_name(m.name));\n@@ -948,7 +947,7 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n \n fn encode_repr_attrs(rbml_w: &mut Encoder,\n                      ecx: &EncodeContext,\n-                     attrs: &[Attribute]) {\n+                     attrs: &[ast::Attribute]) {\n     let mut repr_attrs = Vec::new();\n     for attr in attrs.iter() {\n         repr_attrs.extend(attr::find_repr_attrs(ecx.tcx.sess.diagnostic(),\n@@ -971,7 +970,7 @@ const FN_FAMILY: char = 'f';\n const STATIC_METHOD_FAMILY: char = 'F';\n const METHOD_FAMILY: char = 'h';\n \n-fn should_inline(attrs: &[Attribute]) -> bool {\n+fn should_inline(attrs: &[ast::Attribute]) -> bool {\n     use syntax::attr::*;\n     match find_inline_attr(attrs) {\n         InlineNone | InlineNever  => false,\n@@ -1021,13 +1020,13 @@ fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<attr::Stability>) {\n \n fn encode_info_for_item(ecx: &EncodeContext,\n                         rbml_w: &mut Encoder,\n-                        item: &Item,\n+                        item: &ast::Item,\n                         index: &mut Vec<entry<i64>>,\n                         path: PathElems,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n-    fn add_to_index(item: &Item, rbml_w: &Encoder,\n+    fn add_to_index(item: &ast::Item, rbml_w: &Encoder,\n                     index: &mut Vec<entry<i64>>) {\n         index.push(entry {\n             val: item.id as i64,\n@@ -1042,7 +1041,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     let stab = stability::lookup(tcx, ast_util::local_def(item.id));\n \n     match item.node {\n-      ItemStatic(_, m, _) => {\n+      ast::ItemStatic(_, m, _) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1060,7 +1059,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, item.attrs.as_slice());\n         rbml_w.end_tag();\n       }\n-      ItemConst(_, _) => {\n+      ast::ItemConst(_, _) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1073,7 +1072,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n-      ItemFn(ref decl, _, _, ref generics, _) => {\n+      ast::ItemFn(ref decl, _, _, ref generics, _) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1094,7 +1093,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_method_argument_names(rbml_w, &**decl);\n         rbml_w.end_tag();\n       }\n-      ItemMod(ref m) => {\n+      ast::ItemMod(ref m) => {\n         add_to_index(item, rbml_w, index);\n         encode_info_for_mod(ecx,\n                             rbml_w,\n@@ -1105,7 +1104,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             item.ident,\n                             item.vis);\n       }\n-      ItemForeignMod(ref fm) => {\n+      ast::ItemForeignMod(ref fm) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1123,7 +1122,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n-      ItemTy(..) => {\n+      ast::ItemTy(..) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1135,7 +1134,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n-      ItemEnum(ref enum_definition, _) => {\n+      ast::ItemEnum(ref enum_definition, _) => {\n         add_to_index(item, rbml_w, index);\n \n         rbml_w.start_tag(tag_items_data_item);\n@@ -1165,7 +1164,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  (*enum_definition).variants.as_slice(),\n                                  index);\n       }\n-      ItemStruct(ref struct_def, _) => {\n+      ast::ItemStruct(ref struct_def, _) => {\n         let fields = ty::lookup_struct_fields(tcx, def_id);\n \n         /* First, encode the fields\n@@ -1217,7 +1216,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             None => {}\n         }\n       }\n-      ItemImpl(_, ref opt_trait, ref ty, ref ast_items) => {\n+      ast::ItemImpl(_, ref opt_trait, ref ty, ref ast_items) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n@@ -1321,7 +1320,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n         }\n       }\n-      ItemTrait(_, _, _, ref ms) => {\n+      ast::ItemTrait(_, _, _, ref ms) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1433,22 +1432,22 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 }\n             };\n             match trait_item {\n-                &RequiredMethod(ref m) => {\n+                &ast::RequiredMethod(ref m) => {\n                     encode_attributes(rbml_w, m.attrs.as_slice());\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n                     encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n-                &ProvidedMethod(ref m) => {\n+                &ast::ProvidedMethod(ref m) => {\n                     encode_attributes(rbml_w, m.attrs.as_slice());\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n                     encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n                 }\n \n-                &TypeTraitItem(ref associated_type) => {\n+                &ast::TypeTraitItem(ref associated_type) => {\n                     encode_attributes(rbml_w,\n                                       associated_type.attrs.as_slice());\n                     encode_item_sort(rbml_w, 't');\n@@ -1461,15 +1460,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode inherent implementations for this trait.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n       }\n-      ItemMac(..) => {\n+      ast::ItemMac(..) => {\n         // macros are encoded separately\n       }\n     }\n }\n \n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 rbml_w: &mut Encoder,\n-                                nitem: &ForeignItem,\n+                                nitem: &ast::ForeignItem,\n                                 index: &mut Vec<entry<i64>>,\n                                 path: PathElems,\n                                 abi: abi::Abi) {\n@@ -1482,7 +1481,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     encode_def_id(rbml_w, local_def(nitem.id));\n     encode_visibility(rbml_w, nitem.vis);\n     match nitem.node {\n-      ForeignItemFn(..) => {\n+      ast::ForeignItemFn(..) => {\n         encode_family(rbml_w, FN_FAMILY);\n         encode_bounds_and_type(rbml_w, ecx,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n@@ -1492,7 +1491,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         }\n         encode_symbol(ecx, rbml_w, nitem.id);\n       }\n-      ForeignItemStatic(_, mutbl) => {\n+      ast::ForeignItemStatic(_, mutbl) => {\n         if mutbl {\n             encode_family(rbml_w, 'b');\n         } else {\n@@ -1508,9 +1507,9 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn my_visit_expr(_e: &Expr) { }\n+fn my_visit_expr(_e: &ast::Expr) { }\n \n-fn my_visit_item(i: &Item,\n+fn my_visit_item(i: &ast::Item,\n                  rbml_w: &mut Encoder,\n                  ecx: &EncodeContext,\n                  index: &mut Vec<entry<i64>>) {\n@@ -1519,7 +1518,7 @@ fn my_visit_item(i: &Item,\n     });\n }\n \n-fn my_visit_foreign_item(ni: &ForeignItem,\n+fn my_visit_foreign_item(ni: &ast::ForeignItem,\n                          rbml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          index: &mut Vec<entry<i64>>) {\n@@ -1542,18 +1541,18 @@ struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n }\n \n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n-    fn visit_expr(&mut self, ex: &Expr) {\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n         visit::walk_expr(self, ex);\n         my_visit_expr(ex);\n     }\n-    fn visit_item(&mut self, i: &Item) {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         visit::walk_item(self, i);\n         my_visit_item(i,\n                       self.rbml_w_for_visit_item,\n                       self.ecx,\n                       self.index);\n     }\n-    fn visit_foreign_item(&mut self, ni: &ForeignItem) {\n+    fn visit_foreign_item(&mut self, ni: &ast::ForeignItem) {\n         visit::walk_foreign_item(self, ni);\n         my_visit_foreign_item(ni,\n                               self.rbml_w_for_visit_item,\n@@ -1564,22 +1563,22 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n \n fn encode_info_for_items(ecx: &EncodeContext,\n                          rbml_w: &mut Encoder,\n-                         krate: &Crate)\n+                         krate: &ast::Crate)\n                          -> Vec<entry<i64>> {\n     let mut index = Vec::new();\n     rbml_w.start_tag(tag_items_data);\n     index.push(entry {\n-        val: CRATE_NODE_ID as i64,\n+        val: ast::CRATE_NODE_ID as i64,\n         pos: rbml_w.writer.tell().unwrap(),\n     });\n     encode_info_for_mod(ecx,\n                         rbml_w,\n                         &krate.module,\n                         &[],\n-                        CRATE_NODE_ID,\n+                        ast::CRATE_NODE_ID,\n                         ast_map::Values([].iter()).chain(None),\n                         syntax::parse::token::special_idents::invalid,\n-                        Public);\n+                        ast::Public);\n \n     visit::walk_crate(&mut EncodeVisitor {\n         index: &mut index,\n@@ -1637,18 +1636,18 @@ fn write_i64(writer: &mut SeekableMemWriter, &n: &i64) {\n     wr.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(rbml_w: &mut Encoder, mi: &MetaItem) {\n+fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n     match mi.node {\n-      MetaWord(ref name) => {\n+      ast::MetaWord(ref name) => {\n         rbml_w.start_tag(tag_meta_item_word);\n         rbml_w.start_tag(tag_meta_item_name);\n         rbml_w.writer.write(name.get().as_bytes());\n         rbml_w.end_tag();\n         rbml_w.end_tag();\n       }\n-      MetaNameValue(ref name, ref value) => {\n+      ast::MetaNameValue(ref name, ref value) => {\n         match value.node {\n-          LitStr(ref value, _) => {\n+          ast::LitStr(ref value, _) => {\n             rbml_w.start_tag(tag_meta_item_name_value);\n             rbml_w.start_tag(tag_meta_item_name);\n             rbml_w.writer.write(name.get().as_bytes());\n@@ -1661,7 +1660,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &MetaItem) {\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n-      MetaList(ref name, ref items) => {\n+      ast::MetaList(ref name, ref items) => {\n         rbml_w.start_tag(tag_meta_item_list);\n         rbml_w.start_tag(tag_meta_item_name);\n         rbml_w.writer.write(name.get().as_bytes());\n@@ -1674,7 +1673,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &MetaItem) {\n     }\n }\n \n-fn encode_attributes(rbml_w: &mut Encoder, attrs: &[Attribute]) {\n+fn encode_attributes(rbml_w: &mut Encoder, attrs: &[ast::Attribute]) {\n     rbml_w.start_tag(tag_attributes);\n     for attr in attrs.iter() {\n         rbml_w.start_tag(tag_attribute);\n@@ -1728,7 +1727,7 @@ fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n \n     for (i, def_id) in ecx.tcx.lang_items.items() {\n         for id in def_id.iter() {\n-            if id.krate == LOCAL_CRATE {\n+            if id.krate == ast::LOCAL_CRATE {\n                 rbml_w.start_tag(tag_lang_items_item);\n \n                 rbml_w.start_tag(tag_lang_items_item_id);\n@@ -1804,7 +1803,7 @@ fn encode_macro_def(ecx: &EncodeContext,\n \n /// Serialize the text of the exported macros\n fn encode_macro_defs(ecx: &EncodeContext,\n-                     krate: &Crate,\n+                     krate: &ast::Crate,\n                      rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_exported_macros);\n     for item in krate.exported_macros.iter() {\n@@ -1821,7 +1820,7 @@ fn encode_unboxed_closures<'a>(\n                                                     .unboxed_closures\n                                                     .borrow()\n                                                     .iter() {\n-        if unboxed_closure_id.krate != LOCAL_CRATE {\n+        if unboxed_closure_id.krate != ast::LOCAL_CRATE {\n             continue\n         }\n \n@@ -1836,7 +1835,7 @@ fn encode_unboxed_closures<'a>(\n     rbml_w.end_tag();\n }\n \n-fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &Crate) {\n+fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &ast::Crate) {\n     struct StructFieldVisitor<'a, 'b:'a> {\n         rbml_w: &'a mut Encoder<'b>,\n     }\n@@ -1865,17 +1864,17 @@ struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n }\n \n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n-    fn visit_item(&mut self, item: &Item) {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         match item.node {\n-            ItemImpl(_, Some(ref trait_ref), _, _) => {\n+            ast::ItemImpl(_, Some(ref trait_ref), _, _) => {\n                 let def_map = &self.ecx.tcx.def_map;\n                 let trait_def = def_map.borrow()[trait_ref.ref_id].clone();\n                 let def_id = trait_def.def_id();\n \n                 // Load eagerly if this is an implementation of the Drop trait\n                 // or if the trait is not defined in this crate.\n                 if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n-                        def_id.krate != LOCAL_CRATE {\n+                        def_id.krate != ast::LOCAL_CRATE {\n                     self.rbml_w.start_tag(tag_impls_impl);\n                     encode_def_id(self.rbml_w, local_def(item.id));\n                     self.rbml_w.end_tag();\n@@ -1898,7 +1897,7 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n ///\n /// * Implementations of traits not defined in this crate.\n fn encode_impls<'a>(ecx: &'a EncodeContext,\n-                    krate: &Crate,\n+                    krate: &ast::Crate,\n                     rbml_w: &'a mut Encoder) {\n     rbml_w.start_tag(tag_impls);\n \n@@ -1914,7 +1913,7 @@ fn encode_impls<'a>(ecx: &'a EncodeContext,\n }\n \n fn encode_misc_info(ecx: &EncodeContext,\n-                    krate: &Crate,\n+                    krate: &ast::Crate,\n                     rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n@@ -2011,13 +2010,15 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n #[allow(non_upper_case_globals)]\n pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 1 ];\n \n-pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> Vec<u8> {\n+pub fn encode_metadata(parms: EncodeParams, krate: &ast::Crate) -> Vec<u8> {\n     let mut wr = SeekableMemWriter::new();\n     encode_metadata_inner(&mut wr, parms, krate);\n     wr.unwrap().into_iter().collect()\n }\n \n-fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate: &Crate) {\n+fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n+                         parms: EncodeParams,\n+                         krate: &ast::Crate) {\n     struct Stats {\n         attr_bytes: u64,\n         dep_bytes: u64,\n@@ -2166,7 +2167,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate:\n }\n \n // Get the encoded string for a type\n-pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> String {\n+pub fn encoded_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> String {\n     let mut wr = SeekableMemWriter::new();\n     tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),"}, {"sha": "34b57c5b437ed3e26bdbcb60d905683cd39464f9", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -20,17 +20,16 @@ pub use self::DefIdSource::*;\n \n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n \n use std::rc::Rc;\n use std::str;\n use std::string::String;\n use syntax::abi;\n use syntax::ast;\n-use syntax::ast::*;\n use syntax::parse::token;\n \n-// Compact string representation for ty::t values. API ty_str &\n+// Compact string representation for Ty values. API ty_str &\n // parse_from_str. Extra parameters are for converting to/from def_ids in the\n // data buffer. Whatever format you choose should not contain pipe characters.\n \n@@ -140,18 +139,18 @@ fn data_log_string(data: &[u8], pos: uint) -> String {\n     buf\n }\n \n-pub fn parse_ty_closure_data(data: &[u8],\n-                             crate_num: ast::CrateNum,\n-                             pos: uint,\n-                             tcx: &ty::ctxt,\n-                             conv: conv_did)\n-                             -> ty::ClosureTy {\n+pub fn parse_ty_closure_data<'tcx>(data: &[u8],\n+                                   crate_num: ast::CrateNum,\n+                                   pos: uint,\n+                                   tcx: &ty::ctxt<'tcx>,\n+                                   conv: conv_did)\n+                                   -> ty::ClosureTy<'tcx> {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_closure_ty(&mut st, conv)\n }\n \n-pub fn parse_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n-                     conv: conv_did) -> ty::t {\n+pub fn parse_ty_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+                           tcx: &ty::ctxt<'tcx>, conv: conv_did) -> Ty<'tcx> {\n     debug!(\"parse_ty_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_ty(&mut st, conv)\n@@ -164,30 +163,32 @@ pub fn parse_region_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx:\n     parse_region(&mut st, conv)\n }\n \n-pub fn parse_bare_fn_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n-                             conv: conv_did) -> ty::BareFnTy {\n+pub fn parse_bare_fn_ty_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+                                   tcx: &ty::ctxt<'tcx>, conv: conv_did)\n+                                   -> ty::BareFnTy<'tcx> {\n     debug!(\"parse_bare_fn_ty_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_bare_fn_ty(&mut st, conv)\n }\n \n-pub fn parse_trait_ref_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n-                            conv: conv_did) -> ty::TraitRef {\n+pub fn parse_trait_ref_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+                                  tcx: &ty::ctxt<'tcx>, conv: conv_did)\n+                                  -> ty::TraitRef<'tcx> {\n     debug!(\"parse_trait_ref_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_trait_ref(&mut st, conv)\n }\n \n-pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n-                         conv: conv_did) -> subst::Substs {\n+pub fn parse_substs_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+                               tcx: &ty::ctxt<'tcx>, conv: conv_did) -> subst::Substs<'tcx> {\n     debug!(\"parse_substs_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_substs(&mut st, conv)\n }\n \n-pub fn parse_bounds_data(data: &[u8], crate_num: ast::CrateNum,\n-                         pos: uint, tcx: &ty::ctxt, conv: conv_did)\n-                         -> ty::ParamBounds {\n+pub fn parse_bounds_data<'tcx>(data: &[u8], crate_num: ast::CrateNum,\n+                               pos: uint, tcx: &ty::ctxt<'tcx>, conv: conv_did)\n+                               -> ty::ParamBounds<'tcx> {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_bounds(&mut st, conv)\n }\n@@ -230,9 +231,9 @@ fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n     }\n }\n \n-fn parse_vec_per_param_space<T>(st: &mut PState,\n-                                f: |&mut PState| -> T)\n-                                -> VecPerParamSpace<T>\n+fn parse_vec_per_param_space<'a, 'tcx, T>(st: &mut PState<'a, 'tcx>,\n+                                          f: |&mut PState<'a, 'tcx>| -> T)\n+                                          -> VecPerParamSpace<T>\n {\n     let mut r = VecPerParamSpace::empty();\n     for &space in subst::ParamSpace::all().iter() {\n@@ -245,7 +246,8 @@ fn parse_vec_per_param_space<T>(st: &mut PState,\n     r\n }\n \n-fn parse_substs(st: &mut PState, conv: conv_did) -> subst::Substs {\n+fn parse_substs<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n+                          conv: conv_did) -> subst::Substs<'tcx> {\n     let regions =\n         parse_region_substs(st, |x,y| conv(x,y));\n \n@@ -335,7 +337,8 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n     }\n }\n \n-fn parse_opt<T>(st: &mut PState, f: |&mut PState| -> T) -> Option<T> {\n+fn parse_opt<'a, 'tcx, T>(st: &mut PState<'a, 'tcx>, f: |&mut PState<'a, 'tcx>| -> T)\n+                          -> Option<T> {\n     match next(st) {\n       'n' => None,\n       's' => Some(f(st)),\n@@ -354,13 +357,14 @@ fn parse_str(st: &mut PState, term: char) -> String {\n     result\n }\n \n-fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {\n+fn parse_trait_ref<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n+                             -> ty::TraitRef<'tcx> {\n     let def = parse_def(st, NominalType, |x,y| conv(x,y));\n     let substs = parse_substs(st, |x,y| conv(x,y));\n     ty::TraitRef {def_id: def, substs: substs}\n }\n \n-fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n+fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n     match next(st) {\n       'b' => return ty::mk_bool(),\n       'i' => return ty::mk_int(),\n@@ -487,7 +491,7 @@ fn parse_mutability(st: &mut PState) -> ast::Mutability {\n     }\n }\n \n-fn parse_mt(st: &mut PState, conv: conv_did) -> ty::mt {\n+fn parse_mt<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::mt<'tcx> {\n     let m = parse_mutability(st);\n     ty::mt { ty: parse_ty(st, |x,y| conv(x,y)), mutbl: m }\n }\n@@ -525,10 +529,10 @@ fn parse_hex(st: &mut PState) -> uint {\n     };\n }\n \n-fn parse_fn_style(c: char) -> FnStyle {\n+fn parse_fn_style(c: char) -> ast::FnStyle {\n     match c {\n-        'u' => UnsafeFn,\n-        'n' => NormalFn,\n+        'u' => ast::UnsafeFn,\n+        'n' => ast::NormalFn,\n         _ => panic!(\"parse_fn_style: bad fn_style {}\", c)\n     }\n }\n@@ -549,7 +553,8 @@ fn parse_onceness(c: char) -> ast::Onceness {\n     }\n }\n \n-fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n+fn parse_closure_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n+                              conv: conv_did) -> ty::ClosureTy<'tcx> {\n     let fn_style = parse_fn_style(next(st));\n     let onceness = parse_onceness(next(st));\n     let store = parse_trait_store(st, |x,y| conv(x,y));\n@@ -566,7 +571,8 @@ fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n     }\n }\n \n-fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n+fn parse_bare_fn_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n+                              conv: conv_did) -> ty::BareFnTy<'tcx> {\n     let fn_style = parse_fn_style(next(st));\n     let abi = parse_abi_set(st);\n     let sig = parse_sig(st, |x,y| conv(x,y));\n@@ -577,7 +583,7 @@ fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n     }\n }\n \n-fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n+fn parse_sig<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::FnSig<'tcx> {\n     assert_eq!(next(st), '[');\n     let mut inputs = Vec::new();\n     while peek(st) != ']' {\n@@ -627,15 +633,16 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     ast::DefId { krate: crate_num, node: def_num }\n }\n \n-pub fn parse_type_param_def_data(data: &[u8], start: uint,\n-                                 crate_num: ast::CrateNum, tcx: &ty::ctxt,\n-                                 conv: conv_did) -> ty::TypeParameterDef\n+pub fn parse_type_param_def_data<'tcx>(data: &[u8], start: uint,\n+                                       crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n+                                       conv: conv_did) -> ty::TypeParameterDef<'tcx>\n {\n     let mut st = parse_state_from_data(data, crate_num, start, tcx);\n     parse_type_param_def(&mut st, conv)\n }\n \n-fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef {\n+fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n+                                  -> ty::TypeParameterDef<'tcx> {\n     let name = parse_name(st, ':');\n     let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n     let space = parse_param_space(st);\n@@ -693,7 +700,8 @@ fn parse_builtin_bounds(st: &mut PState, _conv: conv_did) -> ty::BuiltinBounds {\n     }\n }\n \n-fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n+fn parse_bounds<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n+                          -> ty::ParamBounds<'tcx> {\n     let builtin_bounds = parse_builtin_bounds(st, |x,y| conv(x,y));\n \n     let mut param_bounds = ty::ParamBounds {"}, {"sha": "ea778d07e1c9d2b75b07258640ec1a0ddc7c8572", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -18,12 +18,11 @@ use std::cell::RefCell;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::ParamTy;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::nodemap::FnvHashMap;\n \n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::ast::*;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token;\n \n@@ -34,28 +33,28 @@ macro_rules! mywrite( ($($arg:tt)*) => ({ write!($($arg)*); }) )\n pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n     // Def -> str Callback:\n-    pub ds: fn(DefId) -> String,\n+    pub ds: fn(ast::DefId) -> String,\n     // The type context.\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub abbrevs: &'a abbrev_map\n+    pub abbrevs: &'a abbrev_map<'tcx>\n }\n \n-// Compact string representation for ty.t values. API ty_str & parse_from_str.\n+// Compact string representation for Ty values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n pub struct ty_abbrev {\n     s: String\n }\n \n-pub type abbrev_map = RefCell<FnvHashMap<ty::t, ty_abbrev>>;\n+pub type abbrev_map<'tcx> = RefCell<FnvHashMap<Ty<'tcx>, ty_abbrev>>;\n \n-pub fn enc_ty(w: &mut SeekableMemWriter, cx: &ctxt, t: ty::t) {\n+pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n     match cx.abbrevs.borrow_mut().get(&t) {\n         Some(a) => { w.write(a.s.as_bytes()); return; }\n         None => {}\n     }\n     let pos = w.tell().unwrap();\n-    enc_sty(w, cx, &ty::get(t).sty);\n+    enc_sty(w, cx, &t.sty);\n     let end = w.tell().unwrap();\n     let len = end - pos;\n     fn estimate_sz(u: u64) -> u64 {\n@@ -75,12 +74,13 @@ pub fn enc_ty(w: &mut SeekableMemWriter, cx: &ctxt, t: ty::t) {\n \n fn enc_mutability(w: &mut SeekableMemWriter, mt: ast::Mutability) {\n     match mt {\n-        MutImmutable => (),\n-        MutMutable => mywrite!(w, \"m\"),\n+        ast::MutImmutable => (),\n+        ast::MutMutable => mywrite!(w, \"m\"),\n     }\n }\n \n-fn enc_mt(w: &mut SeekableMemWriter, cx: &ctxt, mt: ty::mt) {\n+fn enc_mt<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                    mt: ty::mt<'tcx>) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }\n@@ -95,10 +95,10 @@ fn enc_opt<T>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: |&mut SeekableMemW\n     }\n }\n \n-fn enc_vec_per_param_space<T>(w: &mut SeekableMemWriter,\n-                              cx: &ctxt,\n-                              v: &VecPerParamSpace<T>,\n-                              op: |&mut SeekableMemWriter, &ctxt, &T|) {\n+fn enc_vec_per_param_space<'a, 'tcx, T>(w: &mut SeekableMemWriter,\n+                                        cx: &ctxt<'a, 'tcx>,\n+                                        v: &VecPerParamSpace<T>,\n+                                        op: |&mut SeekableMemWriter, &ctxt<'a, 'tcx>, &T|) {\n     for &space in subst::ParamSpace::all().iter() {\n         mywrite!(w, \"[\");\n         for t in v.get_slice(space).iter() {\n@@ -108,7 +108,8 @@ fn enc_vec_per_param_space<T>(w: &mut SeekableMemWriter,\n     }\n }\n \n-pub fn enc_substs(w: &mut SeekableMemWriter, cx: &ctxt, substs: &subst::Substs) {\n+pub fn enc_substs<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                            substs: &subst::Substs<'tcx>) {\n     enc_region_substs(w, cx, &substs.regions);\n     enc_vec_per_param_space(w, cx, &substs.types,\n                             |w, cx, &ty| enc_ty(w, cx, ty));\n@@ -181,7 +182,8 @@ fn enc_bound_region(w: &mut SeekableMemWriter, cx: &ctxt, br: ty::BoundRegion) {\n     }\n }\n \n-pub fn enc_trait_ref(w: &mut SeekableMemWriter, cx: &ctxt, s: &ty::TraitRef) {\n+pub fn enc_trait_ref<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                               s: &ty::TraitRef<'tcx>) {\n     mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, &s.substs);\n }\n@@ -197,32 +199,33 @@ pub fn enc_trait_store(w: &mut SeekableMemWriter, cx: &ctxt, s: ty::TraitStore)\n     }\n }\n \n-fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n+fn enc_sty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                     st: &ty::sty<'tcx>) {\n     match *st {\n         ty::ty_bool => mywrite!(w, \"b\"),\n         ty::ty_char => mywrite!(w, \"c\"),\n         ty::ty_int(t) => {\n             match t {\n-                TyI => mywrite!(w, \"i\"),\n-                TyI8 => mywrite!(w, \"MB\"),\n-                TyI16 => mywrite!(w, \"MW\"),\n-                TyI32 => mywrite!(w, \"ML\"),\n-                TyI64 => mywrite!(w, \"MD\")\n+                ast::TyI => mywrite!(w, \"i\"),\n+                ast::TyI8 => mywrite!(w, \"MB\"),\n+                ast::TyI16 => mywrite!(w, \"MW\"),\n+                ast::TyI32 => mywrite!(w, \"ML\"),\n+                ast::TyI64 => mywrite!(w, \"MD\")\n             }\n         }\n         ty::ty_uint(t) => {\n             match t {\n-                TyU => mywrite!(w, \"u\"),\n-                TyU8 => mywrite!(w, \"Mb\"),\n-                TyU16 => mywrite!(w, \"Mw\"),\n-                TyU32 => mywrite!(w, \"Ml\"),\n-                TyU64 => mywrite!(w, \"Md\")\n+                ast::TyU => mywrite!(w, \"u\"),\n+                ast::TyU8 => mywrite!(w, \"Mb\"),\n+                ast::TyU16 => mywrite!(w, \"Mw\"),\n+                ast::TyU32 => mywrite!(w, \"Ml\"),\n+                ast::TyU64 => mywrite!(w, \"Md\")\n             }\n         }\n         ty::ty_float(t) => {\n             match t {\n-                TyF32 => mywrite!(w, \"Mf\"),\n-                TyF64 => mywrite!(w, \"MF\"),\n+                ast::TyF32 => mywrite!(w, \"Mf\"),\n+                ast::TyF64 => mywrite!(w, \"MF\"),\n             }\n         }\n         ty::ty_enum(def, ref substs) => {\n@@ -295,10 +298,10 @@ fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n     }\n }\n \n-fn enc_fn_style(w: &mut SeekableMemWriter, p: FnStyle) {\n+fn enc_fn_style(w: &mut SeekableMemWriter, p: ast::FnStyle) {\n     match p {\n-        NormalFn => mywrite!(w, \"n\"),\n-        UnsafeFn => mywrite!(w, \"u\"),\n+        ast::NormalFn => mywrite!(w, \"n\"),\n+        ast::UnsafeFn => mywrite!(w, \"u\"),\n     }\n }\n \n@@ -308,20 +311,22 @@ fn enc_abi(w: &mut SeekableMemWriter, abi: Abi) {\n     mywrite!(w, \"]\")\n }\n \n-fn enc_onceness(w: &mut SeekableMemWriter, o: Onceness) {\n+fn enc_onceness(w: &mut SeekableMemWriter, o: ast::Onceness) {\n     match o {\n-        Once => mywrite!(w, \"o\"),\n-        Many => mywrite!(w, \"m\")\n+        ast::Once => mywrite!(w, \"o\"),\n+        ast::Many => mywrite!(w, \"m\")\n     }\n }\n \n-pub fn enc_bare_fn_ty(w: &mut SeekableMemWriter, cx: &ctxt, ft: &ty::BareFnTy) {\n+pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                                ft: &ty::BareFnTy<'tcx>) {\n     enc_fn_style(w, ft.fn_style);\n     enc_abi(w, ft.abi);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-pub fn enc_closure_ty(w: &mut SeekableMemWriter, cx: &ctxt, ft: &ty::ClosureTy) {\n+pub fn enc_closure_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                                ft: &ty::ClosureTy<'tcx>) {\n     enc_fn_style(w, ft.fn_style);\n     enc_onceness(w, ft.onceness);\n     enc_trait_store(w, cx, ft.store);\n@@ -330,7 +335,8 @@ pub fn enc_closure_ty(w: &mut SeekableMemWriter, cx: &ctxt, ft: &ty::ClosureTy)\n     enc_abi(w, ft.abi);\n }\n \n-fn enc_fn_sig(w: &mut SeekableMemWriter, cx: &ctxt, fsig: &ty::FnSig) {\n+fn enc_fn_sig<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                        fsig: &ty::FnSig<'tcx>) {\n     mywrite!(w, \"[\");\n     for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n@@ -369,7 +375,8 @@ pub fn enc_existential_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::Exi\n     enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n }\n \n-pub fn enc_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n+pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                            bs: &ty::ParamBounds<'tcx>) {\n     enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n \n     for &r in bs.region_bounds.iter() {\n@@ -385,7 +392,8 @@ pub fn enc_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_type_param_def(w: &mut SeekableMemWriter, cx: &ctxt, v: &ty::TypeParameterDef) {\n+pub fn enc_type_param_def<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                                    v: &ty::TypeParameterDef<'tcx>) {\n     mywrite!(w, \"{}:{}|{}|{}|\",\n              token::get_name(v.name), (cx.ds)(v.def_id),\n              v.space.to_uint(), v.index);"}, {"sha": "3cebb7236b64001e2d80c80e5b65f426c99db9df", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 144, "deletions": 123, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -26,8 +26,8 @@ use metadata::tyencode;\n use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n-use middle::{ty, typeck};\n+use middle::typeck::{mod, MethodCall, MethodCallee, MethodOrigin};\n+use middle::ty::{mod, Ty};\n use util::ppaux::ty_to_string;\n \n use syntax::{ast, ast_map, ast_util, codemap, fold};\n@@ -577,15 +577,15 @@ impl tr for ty::UpvarBorrow {\n // ______________________________________________________________________\n // Encoding and decoding of MethodCallee\n \n-trait read_method_callee_helper {\n-    fn read_method_callee(&mut self, dcx: &DecodeContext)\n-        -> (typeck::ExprAdjustment, MethodCallee);\n+trait read_method_callee_helper<'tcx> {\n+    fn read_method_callee<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+        -> (typeck::ExprAdjustment, MethodCallee<'tcx>);\n }\n \n-fn encode_method_callee(ecx: &e::EncodeContext,\n-                        rbml_w: &mut Encoder,\n-                        adjustment: typeck::ExprAdjustment,\n-                        method: &MethodCallee) {\n+fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n+                                  rbml_w: &mut Encoder,\n+                                  adjustment: typeck::ExprAdjustment,\n+                                  method: &MethodCallee<'tcx>) {\n     use serialize::Encoder;\n \n     rbml_w.emit_struct(\"MethodCallee\", 4, |rbml_w| {\n@@ -604,9 +604,9 @@ fn encode_method_callee(ecx: &e::EncodeContext,\n     }).unwrap();\n }\n \n-impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n-    fn read_method_callee(&mut self, dcx: &DecodeContext)\n-        -> (typeck::ExprAdjustment, MethodCallee) {\n+impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n+    fn read_method_callee<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+        -> (typeck::ExprAdjustment, MethodCallee<'tcx>) {\n \n         self.read_struct(\"MethodCallee\", 4, |this| {\n             let adjustment = this.read_struct_field(\"adjustment\", 0, |this| {\n@@ -627,8 +627,8 @@ impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n     }\n }\n \n-impl tr for MethodOrigin {\n-    fn tr(&self, dcx: &DecodeContext) -> MethodOrigin {\n+impl<'tcx> tr for MethodOrigin<'tcx> {\n+    fn tr(&self, dcx: &DecodeContext) -> MethodOrigin<'tcx> {\n         match *self {\n             typeck::MethodStatic(did) => typeck::MethodStatic(did.tr(dcx)),\n             typeck::MethodStaticUnboxedClosure(did) => {\n@@ -683,26 +683,26 @@ pub fn encode_unboxed_closure_kind(ebml_w: &mut Encoder,\n     }).unwrap()\n }\n \n-pub trait vtable_decoder_helpers {\n+pub trait vtable_decoder_helpers<'tcx> {\n     fn read_vec_per_param_space<T>(&mut self,\n                                    f: |&mut Self| -> T)\n                                    -> VecPerParamSpace<T>;\n     fn read_vtable_res_with_key(&mut self,\n-                                tcx: &ty::ctxt,\n+                                tcx: &ty::ctxt<'tcx>,\n                                 cdata: &cstore::crate_metadata)\n-                                -> (typeck::ExprAdjustment, typeck::vtable_res);\n+                                -> (typeck::ExprAdjustment, typeck::vtable_res<'tcx>);\n     fn read_vtable_res(&mut self,\n-                       tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n-                      -> typeck::vtable_res;\n+                       tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n+                      -> typeck::vtable_res<'tcx>;\n     fn read_vtable_param_res(&mut self,\n-                       tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n-                      -> typeck::vtable_param_res;\n+                       tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n+                      -> typeck::vtable_param_res<'tcx>;\n     fn read_vtable_origin(&mut self,\n-                          tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n-                          -> typeck::vtable_origin;\n+                          tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n+                          -> typeck::vtable_origin<'tcx>;\n }\n \n-impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n+impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_vec_per_param_space<T>(&mut self,\n                                    f: |&mut reader::Decoder<'a>| -> T)\n                                    -> VecPerParamSpace<T>\n@@ -715,9 +715,9 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_vtable_res_with_key(&mut self,\n-                                tcx: &ty::ctxt,\n+                                tcx: &ty::ctxt<'tcx>,\n                                 cdata: &cstore::crate_metadata)\n-                                -> (typeck::ExprAdjustment, typeck::vtable_res) {\n+                                -> (typeck::ExprAdjustment, typeck::vtable_res<'tcx>) {\n         self.read_struct(\"VtableWithKey\", 2, |this| {\n             let adjustment = this.read_struct_field(\"adjustment\", 0, |this| {\n                 Decodable::decode(this)\n@@ -729,24 +729,24 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_vtable_res(&mut self,\n-                       tcx: &ty::ctxt,\n+                       tcx: &ty::ctxt<'tcx>,\n                        cdata: &cstore::crate_metadata)\n-                       -> typeck::vtable_res\n+                       -> typeck::vtable_res<'tcx>\n     {\n         self.read_vec_per_param_space(\n             |this| this.read_vtable_param_res(tcx, cdata))\n     }\n \n     fn read_vtable_param_res(&mut self,\n-                             tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n-                      -> typeck::vtable_param_res {\n+                             tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n+                      -> typeck::vtable_param_res<'tcx> {\n         self.read_to_vec(|this| Ok(this.read_vtable_origin(tcx, cdata)))\n              .unwrap().into_iter().collect()\n     }\n \n     fn read_vtable_origin(&mut self,\n-                          tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n-        -> typeck::vtable_origin {\n+                          tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n+        -> typeck::vtable_origin<'tcx> {\n         self.read_enum(\"vtable_origin\", |this| {\n             this.read_enum_variant(&[\"vtable_static\",\n                                      \"vtable_param\",\n@@ -824,43 +824,46 @@ impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n     }\n }\n \n-trait rbml_writer_helpers {\n-    fn emit_closure_type(&mut self,\n-                         ecx: &e::EncodeContext,\n-                         closure_type: &ty::ClosureTy);\n-    fn emit_method_origin(&mut self,\n-                          ecx: &e::EncodeContext,\n-                          method_origin: &typeck::MethodOrigin);\n-    fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t);\n-    fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]);\n-    fn emit_type_param_def(&mut self,\n-                           ecx: &e::EncodeContext,\n-                           type_param_def: &ty::TypeParameterDef);\n-    fn emit_trait_ref(&mut self, ecx: &e::EncodeContext, ty: &ty::TraitRef);\n-    fn emit_polytype(&mut self,\n-                     ecx: &e::EncodeContext,\n-                     pty: ty::Polytype);\n-    fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &subst::Substs);\n+trait rbml_writer_helpers<'tcx> {\n+    fn emit_closure_type<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                             closure_type: &ty::ClosureTy<'tcx>);\n+    fn emit_method_origin<'a>(&mut self,\n+                              ecx: &e::EncodeContext<'a, 'tcx>,\n+                              method_origin: &typeck::MethodOrigin<'tcx>);\n+    fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n+    fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n+    fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                               type_param_def: &ty::TypeParameterDef<'tcx>);\n+    fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                          ty: &ty::TraitRef<'tcx>);\n+    fn emit_polytype<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                         pty: ty::Polytype<'tcx>);\n+    fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                       substs: &subst::Substs<'tcx>);\n     fn emit_existential_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::ExistentialBounds);\n     fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds);\n-    fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment);\n-    fn emit_autoref(&mut self, ecx: &e::EncodeContext, autoref: &ty::AutoRef);\n-    fn emit_auto_deref_ref(&mut self, ecx: &e::EncodeContext, auto_deref_ref: &ty::AutoDerefRef);\n-    fn emit_unsize_kind(&mut self, ecx: &e::EncodeContext, uk: &ty::UnsizeKind);\n-}\n-\n-impl<'a> rbml_writer_helpers for Encoder<'a> {\n-    fn emit_closure_type(&mut self,\n-                         ecx: &e::EncodeContext,\n-                         closure_type: &ty::ClosureTy) {\n+    fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                                adj: &ty::AutoAdjustment<'tcx>);\n+    fn emit_autoref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                        autoref: &ty::AutoRef<'tcx>);\n+    fn emit_auto_deref_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                               auto_deref_ref: &ty::AutoDerefRef<'tcx>);\n+    fn emit_unsize_kind<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                            uk: &ty::UnsizeKind<'tcx>);\n+}\n+\n+impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n+    fn emit_closure_type<'a>(&mut self,\n+                             ecx: &e::EncodeContext<'a, 'tcx>,\n+                             closure_type: &ty::ClosureTy<'tcx>) {\n         self.emit_opaque(|this| {\n             Ok(e::write_closure_type(ecx, this, closure_type))\n         });\n     }\n \n-    fn emit_method_origin(&mut self,\n-                          ecx: &e::EncodeContext,\n-                          method_origin: &typeck::MethodOrigin)\n+    fn emit_method_origin<'a>(&mut self,\n+                              ecx: &e::EncodeContext<'a, 'tcx>,\n+                              method_origin: &typeck::MethodOrigin<'tcx>)\n     {\n         use serialize::Encoder;\n \n@@ -915,33 +918,31 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n-    fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n+    fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>) {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n \n-    fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]) {\n+    fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]) {\n         self.emit_from_vec(tys, |this, ty| Ok(this.emit_ty(ecx, *ty)));\n     }\n \n-    fn emit_trait_ref(&mut self,\n-                      ecx: &e::EncodeContext,\n-                      trait_ref: &ty::TraitRef) {\n+    fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                          trait_ref: &ty::TraitRef<'tcx>) {\n         self.emit_opaque(|this| Ok(e::write_trait_ref(ecx, this, trait_ref)));\n     }\n \n-    fn emit_type_param_def(&mut self,\n-                           ecx: &e::EncodeContext,\n-                           type_param_def: &ty::TypeParameterDef) {\n+    fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                               type_param_def: &ty::TypeParameterDef<'tcx>) {\n         self.emit_opaque(|this| {\n             Ok(tyencode::enc_type_param_def(this.writer,\n                                          &ecx.ty_str_ctxt(),\n                                          type_param_def))\n         });\n     }\n \n-    fn emit_polytype(&mut self,\n-                 ecx: &e::EncodeContext,\n-                 pty: ty::Polytype) {\n+    fn emit_polytype<'a>(&mut self,\n+                         ecx: &e::EncodeContext<'a, 'tcx>,\n+                         pty: ty::Polytype<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_struct(\"Polytype\", 2, |this| {\n@@ -977,13 +978,15 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n                                                                 bounds)));\n     }\n \n-    fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &subst::Substs) {\n+    fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                       substs: &subst::Substs<'tcx>) {\n         self.emit_opaque(|this| Ok(tyencode::enc_substs(this.writer,\n                                                            &ecx.ty_str_ctxt(),\n                                                            substs)));\n     }\n \n-    fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment) {\n+    fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                                adj: &ty::AutoAdjustment<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"AutoAdjustment\", |this| {\n@@ -1004,7 +1007,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n-    fn emit_autoref(&mut self, ecx: &e::EncodeContext, autoref: &ty::AutoRef) {\n+    fn emit_autoref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                        autoref: &ty::AutoRef<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"AutoRef\", |this| {\n@@ -1053,7 +1057,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n-    fn emit_auto_deref_ref(&mut self, ecx: &e::EncodeContext, auto_deref_ref: &ty::AutoDerefRef) {\n+    fn emit_auto_deref_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                               auto_deref_ref: &ty::AutoDerefRef<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_struct(\"AutoDerefRef\", 2, |this| {\n@@ -1069,7 +1074,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n-    fn emit_unsize_kind(&mut self, ecx: &e::EncodeContext, uk: &ty::UnsizeKind) {\n+    fn emit_unsize_kind<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                            uk: &ty::UnsizeKind<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"UnsizeKind\", |this| {\n@@ -1325,23 +1331,31 @@ impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n     }\n }\n \n-trait rbml_decoder_decoder_helpers {\n-    fn read_method_origin(&mut self, dcx: &DecodeContext) -> typeck::MethodOrigin;\n-    fn read_ty(&mut self, dcx: &DecodeContext) -> ty::t;\n-    fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<ty::t>;\n-    fn read_trait_ref(&mut self, dcx: &DecodeContext) -> Rc<ty::TraitRef>;\n-    fn read_type_param_def(&mut self, dcx: &DecodeContext)\n-                           -> ty::TypeParameterDef;\n-    fn read_polytype(&mut self, dcx: &DecodeContext)\n-                     -> ty::Polytype;\n-    fn read_existential_bounds(&mut self, dcx: &DecodeContext) -> ty::ExistentialBounds;\n-    fn read_substs(&mut self, dcx: &DecodeContext) -> subst::Substs;\n-    fn read_auto_adjustment(&mut self, dcx: &DecodeContext) -> ty::AutoAdjustment;\n-    fn read_unboxed_closure(&mut self, dcx: &DecodeContext)\n-                            -> ty::UnboxedClosure;\n-    fn read_auto_deref_ref(&mut self, dcx: &DecodeContext) -> ty::AutoDerefRef;\n-    fn read_autoref(&mut self, dcx: &DecodeContext) -> ty::AutoRef;\n-    fn read_unsize_kind(&mut self, dcx: &DecodeContext) -> ty::UnsizeKind;\n+trait rbml_decoder_decoder_helpers<'tcx> {\n+    fn read_method_origin<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                  -> typeck::MethodOrigin<'tcx>;\n+    fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n+    fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n+    fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                              -> Rc<ty::TraitRef<'tcx>>;\n+    fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                   -> ty::TypeParameterDef<'tcx>;\n+    fn read_polytype<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                             -> ty::Polytype<'tcx>;\n+    fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                       -> ty::ExistentialBounds;\n+    fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                           -> subst::Substs<'tcx>;\n+    fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                    -> ty::AutoAdjustment<'tcx>;\n+    fn read_unboxed_closure<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                    -> ty::UnboxedClosure<'tcx>;\n+    fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                   -> ty::AutoDerefRef<'tcx>;\n+    fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                            -> ty::AutoRef<'tcx>;\n+    fn read_unsize_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                -> ty::UnsizeKind<'tcx>;\n     fn convert_def_id(&mut self,\n                       dcx: &DecodeContext,\n                       source: DefIdSource,\n@@ -1351,18 +1365,18 @@ trait rbml_decoder_decoder_helpers {\n     // Versions of the type reading functions that don't need the full\n     // DecodeContext.\n     fn read_ty_nodcx(&mut self,\n-                     tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t;\n+                     tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata) -> Ty<'tcx>;\n     fn read_tys_nodcx(&mut self,\n-                      tcx: &ty::ctxt,\n-                      cdata: &cstore::crate_metadata) -> Vec<ty::t>;\n-    fn read_substs_nodcx(&mut self, tcx: &ty::ctxt,\n+                      tcx: &ty::ctxt<'tcx>,\n+                      cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>>;\n+    fn read_substs_nodcx(&mut self, tcx: &ty::ctxt<'tcx>,\n                          cdata: &cstore::crate_metadata)\n-                         -> subst::Substs;\n+                         -> subst::Substs<'tcx>;\n }\n \n-impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n+impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_ty_nodcx(&mut self,\n-                     tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t {\n+                     tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata) -> Ty<'tcx> {\n         self.read_opaque(|_, doc| {\n             Ok(tydecode::parse_ty_data(\n                 doc.data,\n@@ -1374,18 +1388,18 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_tys_nodcx(&mut self,\n-                      tcx: &ty::ctxt,\n-                      cdata: &cstore::crate_metadata) -> Vec<ty::t> {\n+                      tcx: &ty::ctxt<'tcx>,\n+                      cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n             .unwrap()\n             .into_iter()\n             .collect()\n     }\n \n     fn read_substs_nodcx(&mut self,\n-                         tcx: &ty::ctxt,\n+                         tcx: &ty::ctxt<'tcx>,\n                          cdata: &cstore::crate_metadata)\n-                         -> subst::Substs\n+                         -> subst::Substs<'tcx>\n     {\n         self.read_opaque(|_, doc| {\n             Ok(tydecode::parse_substs_data(\n@@ -1397,8 +1411,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_method_origin(&mut self, dcx: &DecodeContext)\n-                          -> typeck::MethodOrigin\n+    fn read_method_origin<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                  -> typeck::MethodOrigin<'tcx>\n     {\n         self.read_enum(\"MethodOrigin\", |this| {\n             let variants = &[\"MethodStatic\", \"MethodStaticUnboxedClosure\",\n@@ -1468,7 +1482,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n \n-    fn read_ty(&mut self, dcx: &DecodeContext) -> ty::t {\n+    fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx> {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n@@ -1496,11 +1510,13 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }\n     }\n \n-    fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<ty::t> {\n+    fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                        -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().into_iter().collect()\n     }\n \n-    fn read_trait_ref(&mut self, dcx: &DecodeContext) -> Rc<ty::TraitRef> {\n+    fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                              -> Rc<ty::TraitRef<'tcx>> {\n         Rc::new(self.read_opaque(|this, doc| {\n             let ty = tydecode::parse_trait_ref_data(\n                 doc.data,\n@@ -1512,8 +1528,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap())\n     }\n \n-    fn read_type_param_def(&mut self, dcx: &DecodeContext)\n-                           -> ty::TypeParameterDef {\n+    fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                   -> ty::TypeParameterDef<'tcx> {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_type_param_def_data(\n                 doc.data,\n@@ -1524,8 +1540,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_polytype(&mut self, dcx: &DecodeContext)\n-                                   -> ty::Polytype {\n+    fn read_polytype<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                             -> ty::Polytype<'tcx> {\n         self.read_struct(\"Polytype\", 2, |this| {\n             Ok(ty::Polytype {\n                 generics: this.read_struct_field(\"generics\", 0, |this| {\n@@ -1552,7 +1568,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_existential_bounds(&mut self, dcx: &DecodeContext) -> ty::ExistentialBounds\n+    fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                       -> ty::ExistentialBounds\n     {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_existential_bounds_data(doc.data,\n@@ -1563,7 +1580,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_substs(&mut self, dcx: &DecodeContext) -> subst::Substs {\n+    fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                           -> subst::Substs<'tcx> {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_substs_data(doc.data,\n                                         dcx.cdata.cnum,\n@@ -1573,7 +1591,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_auto_adjustment(&mut self, dcx: &DecodeContext) -> ty::AutoAdjustment {\n+    fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                    -> ty::AutoAdjustment<'tcx> {\n         self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AutoAddEnv\", \"AutoDerefRef\"];\n             this.read_enum_variant(&variants, |this, i| {\n@@ -1597,7 +1616,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_auto_deref_ref(&mut self, dcx: &DecodeContext) -> ty::AutoDerefRef {\n+    fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                   -> ty::AutoDerefRef<'tcx> {\n         self.read_struct(\"AutoDerefRef\", 2, |this| {\n             Ok(ty::AutoDerefRef {\n                 autoderefs: this.read_struct_field(\"autoderefs\", 0, |this| {\n@@ -1616,7 +1636,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_autoref(&mut self, dcx: &DecodeContext) -> ty::AutoRef {\n+    fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> ty::AutoRef<'tcx> {\n         self.read_enum(\"AutoRef\", |this| {\n             let variants = [\"AutoPtr\",\n                             \"AutoUnsize\",\n@@ -1674,7 +1694,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unsize_kind(&mut self, dcx: &DecodeContext) -> ty::UnsizeKind {\n+    fn read_unsize_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                -> ty::UnsizeKind<'tcx> {\n         self.read_enum(\"UnsizeKind\", |this| {\n             let variants = &[\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\"];\n             this.read_enum_variant(variants, |this, i| {\n@@ -1716,8 +1737,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unboxed_closure(&mut self, dcx: &DecodeContext)\n-                            -> ty::UnboxedClosure {\n+    fn read_unboxed_closure<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                    -> ty::UnboxedClosure<'tcx> {\n         let closure_type = self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_ty_closure_data(\n                 doc.data,"}, {"sha": "d91d666511dd5fe40fe82cd49d44cbf17b881f7a", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -86,11 +86,11 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     all_loans: &'a [Loan],\n }\n \n-impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                consume_span: Span,\n-               cmt: mc::cmt,\n+               cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={}, mode={})\",\n                consume_id, cmt.repr(self.tcx()), mode);\n@@ -100,7 +100,7 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {\n \n     fn consume_pat(&mut self,\n                    consume_pat: &ast::Pat,\n-                   cmt: mc::cmt,\n+                   cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(consume_pat={}, cmt={}, mode={})\",\n                consume_pat.repr(self.tcx()),\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n-              cmt: mc::cmt,\n+              cmt: mc::cmt<'tcx>,\n               loan_region: ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n@@ -140,7 +140,7 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {\n     fn mutate(&mut self,\n               assignment_id: ast::NodeId,\n               assignment_span: Span,\n-              assignee_cmt: mc::cmt,\n+              assignee_cmt: mc::cmt<'tcx>,\n               mode: euv::MutateMode)\n     {\n         debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n@@ -737,7 +737,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn check_assignment(&self,\n                         assignment_id: ast::NodeId,\n                         assignment_span: Span,\n-                        assignee_cmt: mc::cmt,\n+                        assignee_cmt: mc::cmt<'tcx>,\n                         mode: euv::MutateMode) {\n         debug!(\"check_assignment(assignee_cmt={})\", assignee_cmt.repr(self.tcx()));\n \n@@ -820,8 +820,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         }\n         return;\n \n-        fn mark_variable_as_used_mut(this: &CheckLoanCtxt,\n-                                     mut cmt: mc::cmt) {\n+        fn mark_variable_as_used_mut<'a, 'tcx>(this: &CheckLoanCtxt<'a, 'tcx>,\n+                                               mut cmt: mc::cmt<'tcx>) {\n             //! If the mutability of the `cmt` being written is inherited\n             //! from a local variable, liveness will\n             //! not have been able to detect that this variable's mutability\n@@ -868,9 +868,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn check_for_aliasable_mutable_writes(this: &CheckLoanCtxt,\n-                                              span: Span,\n-                                              cmt: mc::cmt) -> bool {\n+        fn check_for_aliasable_mutable_writes<'a, 'tcx>(this: &CheckLoanCtxt<'a, 'tcx>,\n+                                                        span: Span,\n+                                                        cmt: mc::cmt<'tcx>) -> bool {\n             //! Safety checks related to writes to aliasable, mutable locations\n \n             let guarantor = cmt.guarantor();\n@@ -889,10 +889,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             return true; // no errors reported\n         }\n \n-        fn check_for_aliasability_violation(this: &CheckLoanCtxt,\n-                                            span: Span,\n-                                            cmt: mc::cmt)\n-                                            -> bool {\n+        fn check_for_aliasability_violation<'a, 'tcx>(this: &CheckLoanCtxt<'a, 'tcx>,\n+                                                      span: Span,\n+                                                      cmt: mc::cmt<'tcx>)\n+                                                      -> bool {\n             match cmt.freely_aliasable(this.tcx()) {\n                 None => {\n                     return true;"}, {"sha": "4caea5ae423bd096d3f87a4829dd369ce129ac13", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -25,10 +25,10 @@ use util::ppaux::Repr;\n \n use std::rc::Rc;\n \n-struct GatherMoveInfo {\n+struct GatherMoveInfo<'tcx> {\n     id: ast::NodeId,\n     kind: MoveKind,\n-    cmt: mc::cmt,\n+    cmt: mc::cmt<'tcx>,\n     span_path_opt: Option<MoveSpanAndPath>\n }\n \n@@ -41,12 +41,12 @@ pub fn gather_decl(bccx: &BorrowckCtxt,\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }\n \n-pub fn gather_move_from_expr(bccx: &BorrowckCtxt,\n-                             move_data: &MoveData,\n-                             move_error_collector: &MoveErrorCollector,\n-                             move_expr_id: ast::NodeId,\n-                             cmt: mc::cmt,\n-                             move_reason: euv::MoveReason) {\n+pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                       move_data: &MoveData,\n+                                       move_error_collector: &MoveErrorCollector<'tcx>,\n+                                       move_expr_id: ast::NodeId,\n+                                       cmt: mc::cmt<'tcx>,\n+                                       move_reason: euv::MoveReason) {\n     let kind = match move_reason {\n         euv::DirectRefMove | euv::PatBindingMove => MoveExpr,\n         euv::CaptureMove => Captured\n@@ -60,11 +60,11 @@ pub fn gather_move_from_expr(bccx: &BorrowckCtxt,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n-                            move_data: &MoveData,\n-                            move_error_collector: &MoveErrorCollector,\n-                            move_pat: &ast::Pat,\n-                            cmt: mc::cmt) {\n+pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                      move_data: &MoveData,\n+                                      move_error_collector: &MoveErrorCollector<'tcx>,\n+                                      move_pat: &ast::Pat,\n+                                      cmt: mc::cmt<'tcx>) {\n     let pat_span_path_opt = match move_pat.node {\n         ast::PatIdent(_, ref path1, _) => {\n             Some(MoveSpanAndPath{span: move_pat.span,\n@@ -81,10 +81,10 @@ pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-fn gather_move(bccx: &BorrowckCtxt,\n-               move_data: &MoveData,\n-               move_error_collector: &MoveErrorCollector,\n-               move_info: GatherMoveInfo) {\n+fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                         move_data: &MoveData,\n+                         move_error_collector: &MoveErrorCollector<'tcx>,\n+                         move_info: GatherMoveInfo<'tcx>) {\n     debug!(\"gather_move(move_id={}, cmt={})\",\n            move_info.id, move_info.cmt.repr(bccx.tcx));\n \n@@ -127,8 +127,9 @@ pub fn gather_assignment(bccx: &BorrowckCtxt,\n                              mode);\n }\n \n-fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n-                                     cmt: &mc::cmt) -> Option<mc::cmt> {\n+fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                               cmt: &mc::cmt<'tcx>)\n+                                               -> Option<mc::cmt<'tcx>> {\n     match cmt.cat {\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::Implicit(..)) |\n@@ -145,7 +146,7 @@ fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n \n         mc::cat_downcast(ref b) |\n         mc::cat_interior(ref b, _) => {\n-            match ty::get(b.ty).sty {\n+            match b.ty.sty {\n                 ty::ty_struct(did, _) | ty::ty_enum(did, _) => {\n                     if ty::has_dtor(bccx.tcx, did) {\n                         Some(cmt.clone())"}, {"sha": "99795fb3009021720934c7caef47718835430df5", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -23,14 +23,14 @@ use syntax::codemap::Span;\n \n type R = Result<(),()>;\n \n-pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n-                          item_scope_id: ast::NodeId,\n-                          span: Span,\n-                          cause: euv::LoanCause,\n-                          cmt: mc::cmt,\n-                          loan_region: ty::Region,\n-                          _: ty::BorrowKind)\n-                          -> Result<(),()> {\n+pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                    item_scope_id: ast::NodeId,\n+                                    span: Span,\n+                                    cause: euv::LoanCause,\n+                                    cmt: mc::cmt<'tcx>,\n+                                    loan_region: ty::Region,\n+                                    _: ty::BorrowKind)\n+                                    -> Result<(),()> {\n     debug!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n            cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n@@ -54,12 +54,12 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n     span: Span,\n     cause: euv::LoanCause,\n     loan_region: ty::Region,\n-    cmt_original: mc::cmt\n+    cmt_original: mc::cmt<'tcx>\n }\n \n impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n \n-    fn check(&self, cmt: &mc::cmt, discr_scope: Option<ast::NodeId>) -> R {\n+    fn check(&self, cmt: &mc::cmt<'tcx>, discr_scope: Option<ast::NodeId>) -> R {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n         debug!(\"guarantee_lifetime.check(cmt={}, loan_region={})\",\n                cmt.repr(self.bccx.tcx),"}, {"sha": "6bb511b2077c9659334036b271060ffa9c8a2bd6", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -60,16 +60,16 @@ pub fn gather_loans_in_fn(bccx: &BorrowckCtxt,\n struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     move_data: move_data::MoveData,\n-    move_error_collector: move_error::MoveErrorCollector,\n+    move_error_collector: move_error::MoveErrorCollector<'tcx>,\n     all_loans: Vec<Loan>,\n     item_ub: ast::NodeId,\n }\n \n-impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                _consume_span: Span,\n-               cmt: mc::cmt,\n+               cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={}, mode={})\",\n                consume_id, cmt.repr(self.tcx()), mode);\n@@ -86,7 +86,7 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n \n     fn consume_pat(&mut self,\n                    consume_pat: &ast::Pat,\n-                   cmt: mc::cmt,\n+                   cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(consume_pat={}, cmt={}, mode={})\",\n                consume_pat.repr(self.tcx()),\n@@ -106,7 +106,7 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n-              cmt: mc::cmt,\n+              cmt: mc::cmt<'tcx>,\n               loan_region: ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n     fn mutate(&mut self,\n               assignment_id: ast::NodeId,\n               assignment_span: Span,\n-              assignee_cmt: mc::cmt,\n+              assignee_cmt: mc::cmt<'tcx>,\n               mode: euv::MutateMode)\n     {\n         debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n@@ -153,12 +153,12 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n }\n \n /// Implements the A-* rules in doc.rs.\n-fn check_aliasability(bccx: &BorrowckCtxt,\n-                      borrow_span: Span,\n-                      loan_cause: euv::LoanCause,\n-                      cmt: mc::cmt,\n-                      req_kind: ty::BorrowKind)\n-                      -> Result<(),()> {\n+fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                borrow_span: Span,\n+                                loan_cause: euv::LoanCause,\n+                                cmt: mc::cmt<'tcx>,\n+                                req_kind: ty::BorrowKind)\n+                                -> Result<(),()> {\n \n     match (cmt.freely_aliasable(bccx.tcx), req_kind) {\n         (None, _) => {\n@@ -206,7 +206,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     fn guarantee_valid(&mut self,\n                        borrow_id: ast::NodeId,\n                        borrow_span: Span,\n-                       cmt: mc::cmt,\n+                       cmt: mc::cmt<'tcx>,\n                        req_kind: ty::BorrowKind,\n                        loan_region: ty::Region,\n                        cause: euv::LoanCause) {\n@@ -349,12 +349,12 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             //    }\n         // }\n \n-        fn check_mutability(bccx: &BorrowckCtxt,\n-                            borrow_span: Span,\n-                            cause: euv::LoanCause,\n-                            cmt: mc::cmt,\n-                            req_kind: ty::BorrowKind)\n-                            -> Result<(),()> {\n+        fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                      borrow_span: Span,\n+                                      cause: euv::LoanCause,\n+                                      cmt: mc::cmt<'tcx>,\n+                                      req_kind: ty::BorrowKind)\n+                                      -> Result<(),()> {\n             //! Implements the M-* rules in doc.rs.\n \n             match req_kind {"}, {"sha": "c7ffcc3ac1d1506078f4e30c7904fdc7127036a3", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -18,35 +18,35 @@ use syntax::codemap;\n use syntax::print::pprust;\n use util::ppaux::UserString;\n \n-pub struct MoveErrorCollector {\n-    errors: RefCell<Vec<MoveError>>\n+pub struct MoveErrorCollector<'tcx> {\n+    errors: RefCell<Vec<MoveError<'tcx>>>\n }\n \n-impl MoveErrorCollector {\n-    pub fn new() -> MoveErrorCollector {\n+impl<'tcx> MoveErrorCollector<'tcx> {\n+    pub fn new() -> MoveErrorCollector<'tcx> {\n         MoveErrorCollector {\n             errors: RefCell::new(Vec::new())\n         }\n     }\n \n-    pub fn add_error(&self, error: MoveError) {\n+    pub fn add_error(&self, error: MoveError<'tcx>) {\n         self.errors.borrow_mut().push(error);\n     }\n \n-    pub fn report_potential_errors(&self, bccx: &BorrowckCtxt) {\n+    pub fn report_potential_errors<'a>(&self, bccx: &BorrowckCtxt<'a, 'tcx>) {\n         report_move_errors(bccx, self.errors.borrow().deref())\n     }\n }\n \n-pub struct MoveError {\n-    move_from: mc::cmt,\n+pub struct MoveError<'tcx> {\n+    move_from: mc::cmt<'tcx>,\n     move_to: Option<MoveSpanAndPath>\n }\n \n-impl MoveError {\n-    pub fn with_move_info(move_from: mc::cmt,\n+impl<'tcx> MoveError<'tcx> {\n+    pub fn with_move_info(move_from: mc::cmt<'tcx>,\n                           move_to: Option<MoveSpanAndPath>)\n-                          -> MoveError {\n+                          -> MoveError<'tcx> {\n         MoveError {\n             move_from: move_from,\n             move_to: move_to,\n@@ -60,12 +60,13 @@ pub struct MoveSpanAndPath {\n     pub ident: ast::Ident\n }\n \n-pub struct GroupedMoveErrors {\n-    move_from: mc::cmt,\n+pub struct GroupedMoveErrors<'tcx> {\n+    move_from: mc::cmt<'tcx>,\n     move_to_places: Vec<MoveSpanAndPath>\n }\n \n-fn report_move_errors(bccx: &BorrowckCtxt, errors: &Vec<MoveError>) {\n+fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                errors: &Vec<MoveError<'tcx>>) {\n     let grouped_errors = group_errors_with_same_origin(errors);\n     for error in grouped_errors.iter() {\n         report_cannot_move_out_of(bccx, error.move_from.clone());\n@@ -78,16 +79,16 @@ fn report_move_errors(bccx: &BorrowckCtxt, errors: &Vec<MoveError>) {\n     }\n }\n \n-fn group_errors_with_same_origin(errors: &Vec<MoveError>)\n-                                 -> Vec<GroupedMoveErrors> {\n+fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n+                                       -> Vec<GroupedMoveErrors<'tcx>> {\n     let mut grouped_errors = Vec::new();\n     for error in errors.iter() {\n         append_to_grouped_errors(&mut grouped_errors, error)\n     }\n     return grouped_errors;\n \n-    fn append_to_grouped_errors(grouped_errors: &mut Vec<GroupedMoveErrors>,\n-                                error: &MoveError) {\n+    fn append_to_grouped_errors<'tcx>(grouped_errors: &mut Vec<GroupedMoveErrors<'tcx>>,\n+                                      error: &MoveError<'tcx>) {\n         let move_from_id = error.move_from.id;\n         debug!(\"append_to_grouped_errors(move_from_id={})\", move_from_id);\n         let move_to = if error.move_to.is_some() {\n@@ -110,7 +111,8 @@ fn group_errors_with_same_origin(errors: &Vec<MoveError>)\n     }\n }\n \n-fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n+fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                       move_from: mc::cmt<'tcx>) {\n     match move_from.cat {\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::Implicit(..)) |\n@@ -124,7 +126,7 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n \n         mc::cat_downcast(ref b) |\n         mc::cat_interior(ref b, _) => {\n-            match ty::get(b.ty).sty {\n+            match b.ty.sty {\n                 ty::ty_struct(did, _)\n                 | ty::ty_enum(did, _) if ty::has_dtor(bccx.tcx, did) => {\n                     bccx.span_err("}, {"sha": "9b9a5e61393f888fe43448b9f284b67ea6c08f5b", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -29,11 +29,12 @@ pub enum RestrictionResult {\n     SafeIf(Rc<LoanPath>, Vec<Rc<LoanPath>>)\n }\n \n-pub fn compute_restrictions(bccx: &BorrowckCtxt,\n-                            span: Span,\n-                            cause: euv::LoanCause,\n-                            cmt: mc::cmt,\n-                            loan_region: ty::Region) -> RestrictionResult {\n+pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                      span: Span,\n+                                      cause: euv::LoanCause,\n+                                      cmt: mc::cmt<'tcx>,\n+                                      loan_region: ty::Region)\n+                                      -> RestrictionResult {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n         span: span,\n@@ -56,7 +57,7 @@ struct RestrictionsContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn restrict(&self,\n-                cmt: mc::cmt) -> RestrictionResult {\n+                cmt: mc::cmt<'tcx>) -> RestrictionResult {\n         debug!(\"restrict(cmt={})\", cmt.repr(self.bccx.tcx));\n \n         match cmt.cat.clone() {"}, {"sha": "fbb0a87cf3f873a02cfc657975fb325642a549dc", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -24,7 +24,7 @@ use middle::dataflow::BitwiseOperator;\n use middle::dataflow::DataFlowOperator;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use std::rc::Rc;\n@@ -247,7 +247,7 @@ struct BorrowStats {\n     guaranteed_paths: uint\n }\n \n-pub type BckResult<T> = Result<T, BckError>;\n+pub type BckResult<'tcx, T> = Result<T, BckError<'tcx>>;\n \n ///////////////////////////////////////////////////////////////////////////\n // Loans and loan paths\n@@ -405,10 +405,10 @@ pub enum bckerr_code {\n // Combination of an error code and the categorization of the expression\n // that caused it\n #[deriving(PartialEq)]\n-pub struct BckError {\n+pub struct BckError<'tcx> {\n     span: Span,\n     cause: euv::LoanCause,\n-    cmt: mc::cmt,\n+    cmt: mc::cmt<'tcx>,\n     code: bckerr_code\n }\n \n@@ -436,7 +436,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         mc::MemCategorizationContext::new(self.tcx)\n     }\n \n-    pub fn cat_expr(&self, expr: &ast::Expr) -> mc::cmt {\n+    pub fn cat_expr(&self, expr: &ast::Expr) -> mc::cmt<'tcx> {\n         match self.mc().cat_expr(expr) {\n             Ok(c) => c,\n             Err(()) => {\n@@ -445,7 +445,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn report(&self, err: BckError) {\n+    pub fn report(&self, err: BckError<'tcx>) {\n         self.span_err(\n             err.span,\n             self.bckerr_to_string(&err).as_slice());\n@@ -586,9 +586,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn move_suggestion(tcx: &ty::ctxt, ty: ty::t, default_msgs: (&'static str, &'static str))\n-                          -> (&'static str, &'static str) {\n-            match ty::get(ty).sty {\n+        fn move_suggestion<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>,\n+                                 default_msgs: (&'static str, &'static str))\n+                                 -> (&'static str, &'static str) {\n+            match ty.sty {\n                 ty::ty_closure(box ty::ClosureTy {\n                         store: ty::RegionTraitStore(..),\n                         ..\n@@ -631,7 +632,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_help(s, m);\n     }\n \n-    pub fn bckerr_to_string(&self, err: &BckError) -> String {\n+    pub fn bckerr_to_string(&self, err: &BckError<'tcx>) -> String {\n         match err.code {\n             err_mutbl => {\n                 let descr = match err.cmt.note {\n@@ -766,7 +767,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn note_and_explain_bckerr(&self, err: BckError) {\n+    pub fn note_and_explain_bckerr(&self, err: BckError<'tcx>) {\n         let code = err.code;\n         match code {\n             err_mutbl(..) => {\n@@ -893,7 +894,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         result\n     }\n \n-    pub fn cmt_to_string(&self, cmt: &mc::cmt_) -> String {\n+    pub fn cmt_to_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n         self.mc().cmt_to_string(cmt)\n     }\n }\n@@ -924,7 +925,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n     }\n }\n \n-impl Repr for Loan {\n+impl<'tcx> Repr<'tcx> for Loan {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"Loan_{}({}, {}, {}-{}, {})\",\n                  self.index,\n@@ -936,7 +937,7 @@ impl Repr for Loan {\n     }\n }\n \n-impl Repr for LoanPath {\n+impl<'tcx> Repr<'tcx> for LoanPath {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match self {\n             &LpVar(id) => {"}, {"sha": "8cb63fcd82741ad1a9d84141145ac8943c7a3508", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -14,7 +14,7 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux;\n \n-use syntax::ast::*;\n+use syntax::ast;\n use syntax::ast_util;\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -40,13 +40,13 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &Item) {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         check_item(self, i);\n     }\n-    fn visit_pat(&mut self, p: &Pat) {\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n         check_pat(self, p);\n     }\n-    fn visit_expr(&mut self, ex: &Expr) {\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n         if check_expr(self, ex) {\n             visit::walk_expr(self, ex);\n         }\n@@ -59,13 +59,13 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n+fn check_item(v: &mut CheckCrateVisitor, it: &ast::Item) {\n     match it.node {\n-        ItemStatic(_, _, ref ex) |\n-        ItemConst(_, ref ex) => {\n+        ast::ItemStatic(_, _, ref ex) |\n+        ast::ItemConst(_, ref ex) => {\n             v.inside_const(|v| v.visit_expr(&**ex));\n         }\n-        ItemEnum(ref enum_definition, _) => {\n+        ast::ItemEnum(ref enum_definition, _) => {\n             for var in (*enum_definition).variants.iter() {\n                 for ex in var.node.disr_expr.iter() {\n                     v.inside_const(|v| v.visit_expr(&**ex));\n@@ -76,12 +76,12 @@ fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n     }\n }\n \n-fn check_pat(v: &mut CheckCrateVisitor, p: &Pat) {\n-    fn is_str(e: &Expr) -> bool {\n+fn check_pat(v: &mut CheckCrateVisitor, p: &ast::Pat) {\n+    fn is_str(e: &ast::Expr) -> bool {\n         match e.node {\n-            ExprBox(_, ref expr) => {\n+            ast::ExprBox(_, ref expr) => {\n                 match expr.node {\n-                    ExprLit(ref lit) => ast_util::lit_is_str(&**lit),\n+                    ast::ExprLit(ref lit) => ast_util::lit_is_str(&**lit),\n                     _ => false,\n                 }\n             }\n@@ -90,36 +90,36 @@ fn check_pat(v: &mut CheckCrateVisitor, p: &Pat) {\n     }\n     match p.node {\n         // Let through plain ~-string literals here\n-        PatLit(ref a) => if !is_str(&**a) { v.inside_const(|v| v.visit_expr(&**a)); },\n-        PatRange(ref a, ref b) => {\n+        ast::PatLit(ref a) => if !is_str(&**a) { v.inside_const(|v| v.visit_expr(&**a)); },\n+        ast::PatRange(ref a, ref b) => {\n             if !is_str(&**a) { v.inside_const(|v| v.visit_expr(&**a)); }\n             if !is_str(&**b) { v.inside_const(|v| v.visit_expr(&**b)); }\n         }\n         _ => v.outside_const(|v| visit::walk_pat(v, p))\n     }\n }\n \n-fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n+fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) -> bool {\n     if !v.in_const { return true }\n \n     match e.node {\n-        ExprUnary(UnDeref, _) => {}\n-        ExprUnary(UnUniq, _) => {\n+        ast::ExprUnary(ast::UnDeref, _) => {}\n+        ast::ExprUnary(ast::UnUniq, _) => {\n             span_err!(v.tcx.sess, e.span, E0010,\n                       \"cannot do allocations in constant expressions\");\n             return false;\n         }\n-        ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {}\n-        ExprBinary(..) | ExprUnary(..) => {\n+        ast::ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {}\n+        ast::ExprBinary(..) | ast::ExprUnary(..) => {\n             let method_call = typeck::MethodCall::expr(e.id);\n             if v.tcx.method_map.borrow().contains_key(&method_call) {\n                 span_err!(v.tcx.sess, e.span, E0011,\n                           \"user-defined operators are not allowed in constant \\\n                            expressions\");\n             }\n         }\n-        ExprLit(_) => (),\n-        ExprCast(ref from, _) => {\n+        ast::ExprLit(_) => (),\n+        ast::ExprCast(ref from, _) => {\n             let toty = ty::expr_ty(v.tcx, e);\n             let fromty = ty::expr_ty(v.tcx, &**from);\n             if !ty::type_is_numeric(toty) && !ty::type_is_unsafe_ptr(toty) {\n@@ -133,7 +133,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n                            expression\");\n             }\n         }\n-        ExprPath(ref pth) => {\n+        ast::ExprPath(ref pth) => {\n             // NB: In the future you might wish to relax this slightly\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on\n@@ -161,7 +161,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n                 }\n             }\n         }\n-        ExprCall(ref callee, _) => {\n+        ast::ExprCall(ref callee, _) => {\n             match v.tcx.def_map.borrow().get(&callee.id) {\n                 Some(&DefStruct(..)) |\n                 Some(&DefVariant(..)) => {}    // OK.\n@@ -173,25 +173,25 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n                 }\n             }\n         }\n-        ExprBlock(ref block) => {\n+        ast::ExprBlock(ref block) => {\n             // Check all statements in the block\n             for stmt in block.stmts.iter() {\n                 let block_span_err = |span|\n                     span_err!(v.tcx.sess, span, E0016,\n                               \"blocks in constants are limited to items and \\\n                                tail expressions\");\n                 match stmt.node {\n-                    StmtDecl(ref span, _) => {\n+                    ast::StmtDecl(ref span, _) => {\n                         match span.node {\n-                            DeclLocal(_) => block_span_err(span.span),\n+                            ast::DeclLocal(_) => block_span_err(span.span),\n \n                             // Item statements are allowed\n-                            DeclItem(_) => {}\n+                            ast::DeclItem(_) => {}\n                         }\n                     }\n-                    StmtExpr(ref expr, _) => block_span_err(expr.span),\n-                    StmtSemi(ref semi, _) => block_span_err(semi.span),\n-                    StmtMac(..) => {\n+                    ast::StmtExpr(ref expr, _) => block_span_err(expr.span),\n+                    ast::StmtSemi(ref semi, _) => block_span_err(semi.span),\n+                    ast::StmtMac(..) => {\n                         v.tcx.sess.span_bug(e.span, \"unexpanded statement \\\n                                                      macro in const?!\")\n                     }\n@@ -202,20 +202,20 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n                 None => {}\n             }\n         }\n-        ExprVec(_) |\n-        ExprAddrOf(MutImmutable, _) |\n-        ExprParen(..) |\n-        ExprField(..) |\n-        ExprTupField(..) |\n-        ExprIndex(..) |\n-        ExprTup(..) |\n-        ExprRepeat(..) |\n-        ExprStruct(..) => {}\n-\n-        ExprAddrOf(_, ref inner) => {\n+        ast::ExprVec(_) |\n+        ast::ExprAddrOf(ast::MutImmutable, _) |\n+        ast::ExprParen(..) |\n+        ast::ExprField(..) |\n+        ast::ExprTupField(..) |\n+        ast::ExprIndex(..) |\n+        ast::ExprTup(..) |\n+        ast::ExprRepeat(..) |\n+        ast::ExprStruct(..) => {}\n+\n+        ast::ExprAddrOf(_, ref inner) => {\n             match inner.node {\n                 // Mutable slices are allowed.\n-                ExprVec(_) => {}\n+                ast::ExprVec(_) => {}\n                 _ => span_err!(v.tcx.sess, e.span, E0017,\n                                \"references in constants may only refer \\\n                                 to immutable values\")"}, {"sha": "edc4e4ac7758b9b0060a4fb8b321e4f94b46b7b6", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 88, "deletions": 86, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -21,13 +21,13 @@ use middle::expr_use_visitor::{WriteAndRead};\n use middle::mem_categorization::cmt;\n use middle::pat_util::*;\n use middle::ty::*;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use std::fmt;\n use std::iter::AdditiveIterator;\n use std::iter::range_inclusive;\n use std::num::Float;\n use std::slice;\n-use syntax::ast::*;\n+use syntax::ast::{mod, DUMMY_NODE_ID, NodeId, Pat};\n use syntax::ast_util::walk_pat;\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n use syntax::fold::{Folder, noop_fold_pat};\n@@ -39,7 +39,7 @@ use util::ppaux::ty_to_string;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n-    node: PatWild(PatWildSingle),\n+    node: ast::PatWild(ast::PatWildSingle),\n     span: DUMMY_SP\n };\n \n@@ -108,7 +108,7 @@ pub enum Constructor {\n     /// e.g. struct patterns and fixed-length arrays.\n     Single,\n     /// Enum variants.\n-    Variant(DefId),\n+    Variant(ast::DefId),\n     /// Literal values.\n     ConstantValue(const_val),\n     /// Ranges of literal values (2..5).\n@@ -132,14 +132,14 @@ enum WitnessPreference {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &Expr) {\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n         check_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &Local) {\n+    fn visit_local(&mut self, l: &ast::Local) {\n         check_local(self, l);\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, n: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v ast::FnDecl,\n+                b: &'v ast::Block, s: Span, n: NodeId) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n }\n@@ -149,10 +149,10 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n+fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n     visit::walk_expr(cx, ex);\n     match ex.node {\n-        ExprMatch(ref scrut, ref arms, source) => {\n+        ast::ExprMatch(ref scrut, ref arms, source) => {\n             // First, check legality of move bindings.\n             for arm in arms.iter() {\n                 check_legality_of_move_bindings(cx,\n@@ -177,7 +177,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                 (arm.pats.iter().map(|pat| {\n                     static_inliner.fold_pat((*pat).clone())\n                 }).collect(), arm.guard.as_ref().map(|e| &**e))\n-            }).collect::<Vec<(Vec<P<Pat>>, Option<&Expr>)>>();\n+            }).collect::<Vec<(Vec<P<Pat>>, Option<&ast::Expr>)>>();\n \n             if static_inliner.failed {\n                 return;\n@@ -214,7 +214,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                 .collect();\n             check_exhaustive(cx, ex.span, &matrix);\n         },\n-        ExprForLoop(ref pat, _, _, _) => {\n+        ast::ExprForLoop(ref pat, _, _, _) => {\n             let mut static_inliner = StaticInliner::new(cx.tcx);\n             is_refutable(cx, &*static_inliner.fold_pat((*pat).clone()), |uncovered_pat| {\n                 cx.tcx.sess.span_err(\n@@ -232,7 +232,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n     }\n }\n \n-fn is_expr_const_nan(tcx: &ty::ctxt, expr: &Expr) -> bool {\n+fn is_expr_const_nan(tcx: &ty::ctxt, expr: &ast::Expr) -> bool {\n     match eval_const_expr(tcx, expr) {\n         const_float(f) => f.is_nan(),\n         _ => false\n@@ -244,7 +244,7 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pats: &[P<Pat>]) {\n     for pat in pats.iter() {\n         walk_pat(&**pat, |p| {\n             match p.node {\n-                PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n+                ast::PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n                     span_warn!(cx.tcx.sess, p.span, E0003,\n                         \"unmatchable NaN in pattern, \\\n                             use the is_nan method in a guard instead\");\n@@ -257,7 +257,9 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pats: &[P<Pat>]) {\n }\n \n // Check for unreachable patterns\n-fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source: MatchSource) {\n+fn check_arms(cx: &MatchCheckCtxt,\n+              arms: &[(Vec<P<Pat>>, Option<&ast::Expr>)],\n+              source: ast::MatchSource) {\n     let mut seen = Matrix(vec![]);\n     let mut printed_if_let_err = false;\n     for &(ref pats, guard) in arms.iter() {\n@@ -267,7 +269,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source\n             match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n-                        MatchIfLetDesugar => {\n+                        ast::MatchIfLetDesugar => {\n                             if printed_if_let_err {\n                                 // we already printed an irrefutable if-let pattern error.\n                                 // We don't want two, that's just confusing.\n@@ -281,15 +283,15 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source\n                             }\n                         },\n \n-                        MatchWhileLetDesugar => {\n+                        ast::MatchWhileLetDesugar => {\n                             // find the first arm pattern so we can use its span\n                             let &(ref first_arm_pats, _) = &arms[0];\n                             let first_pat = &first_arm_pats[0];\n                             let span = first_pat.span;\n                             span_err!(cx.tcx.sess, span, E0165, \"irrefutable while-let pattern\");\n                         },\n \n-                        MatchNormal => {\n+                        ast::MatchNormal => {\n                             span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\")\n                         },\n                     }\n@@ -308,7 +310,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source\n \n fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n     match p.node {\n-        PatIdent(_, _, Some(ref s)) => raw_pat(&**s),\n+        ast::PatIdent(_, _, Some(ref s)) => raw_pat(&**s),\n         _ => p\n     }\n }\n@@ -333,14 +335,14 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     }\n }\n \n-fn const_val_to_expr(value: &const_val) -> P<Expr> {\n+fn const_val_to_expr(value: &const_val) -> P<ast::Expr> {\n     let node = match value {\n-        &const_bool(b) => LitBool(b),\n+        &const_bool(b) => ast::LitBool(b),\n         _ => unreachable!()\n     };\n-    P(Expr {\n+    P(ast::Expr {\n         id: 0,\n-        node: ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n+        node: ast::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n         span: DUMMY_SP\n     })\n }\n@@ -362,7 +364,7 @@ impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         match pat.node {\n-            PatIdent(..) | PatEnum(..) => {\n+            ast::PatIdent(..) | ast::PatEnum(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).cloned();\n                 match def {\n                     Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n@@ -401,11 +403,11 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n /// left_ty: struct X { a: (bool, &'static str), b: uint}\n /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n-                     pats: Vec<&Pat>, left_ty: ty::t) -> P<Pat> {\n+                     pats: Vec<&Pat>, left_ty: Ty) -> P<Pat> {\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n-    let pat = match ty::get(left_ty).sty {\n-        ty::ty_tup(_) => PatTup(pats.collect()),\n+    let pat = match left_ty.sty {\n+        ty::ty_tup(_) => ast::PatTup(pats.collect()),\n \n         ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n@@ -417,71 +419,71 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n             };\n             if is_structure {\n                 let fields = ty::lookup_struct_fields(cx.tcx, vid);\n-                let field_pats: Vec<Spanned<FieldPat>> = fields.into_iter()\n+                let field_pats: Vec<_> = fields.into_iter()\n                     .zip(pats)\n-                    .filter(|&(_, ref pat)| pat.node != PatWild(PatWildSingle))\n+                    .filter(|&(_, ref pat)| pat.node != ast::PatWild(ast::PatWildSingle))\n                     .map(|(field, pat)| Spanned {\n                         span: DUMMY_SP,\n-                        node: FieldPat {\n-                            ident: Ident::new(field.name),\n+                        node: ast::FieldPat {\n+                            ident: ast::Ident::new(field.name),\n                             pat: pat,\n                             is_shorthand: false,\n                         }\n                     }).collect();\n                 let has_more_fields = field_pats.len() < pats_len;\n-                PatStruct(def_to_path(cx.tcx, vid), field_pats, has_more_fields)\n+                ast::PatStruct(def_to_path(cx.tcx, vid), field_pats, has_more_fields)\n             } else {\n-                PatEnum(def_to_path(cx.tcx, vid), Some(pats.collect()))\n+                ast::PatEnum(def_to_path(cx.tcx, vid), Some(pats.collect()))\n             }\n         }\n \n         ty::ty_rptr(_, ty::mt { ty, .. }) => {\n-            match ty::get(ty).sty {\n+            match ty.sty {\n                ty::ty_vec(_, Some(n)) => match ctor {\n                     &Single => {\n                         assert_eq!(pats_len, n);\n-                        PatVec(pats.collect(), None, vec!())\n+                        ast::PatVec(pats.collect(), None, vec!())\n                     },\n                     _ => unreachable!()\n                 },\n                 ty::ty_vec(_, None) => match ctor {\n                     &Slice(n) => {\n                         assert_eq!(pats_len, n);\n-                        PatVec(pats.collect(), None, vec!())\n+                        ast::PatVec(pats.collect(), None, vec!())\n                     },\n                     _ => unreachable!()\n                 },\n-                ty::ty_str => PatWild(PatWildSingle),\n+                ty::ty_str => ast::PatWild(ast::PatWildSingle),\n \n                 _ => {\n                     assert_eq!(pats_len, 1);\n-                    PatRegion(pats.nth(0).unwrap())\n+                    ast::PatRegion(pats.nth(0).unwrap())\n                 }\n             }\n         }\n \n         ty::ty_vec(_, Some(len)) => {\n             assert_eq!(pats_len, len);\n-            PatVec(pats.collect(), None, vec![])\n+            ast::PatVec(pats.collect(), None, vec![])\n         }\n \n         _ => {\n             match *ctor {\n-                ConstantValue(ref v) => PatLit(const_val_to_expr(v)),\n-                _ => PatWild(PatWildSingle),\n+                ConstantValue(ref v) => ast::PatLit(const_val_to_expr(v)),\n+                _ => ast::PatWild(ast::PatWildSingle),\n             }\n         }\n     };\n \n-    P(Pat {\n+    P(ast::Pat {\n         id: 0,\n         node: pat,\n         span: DUMMY_SP\n     })\n }\n \n fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n-                       left_ty: ty::t, max_slice_length: uint) -> Option<Constructor> {\n+                       left_ty: Ty, max_slice_length: uint) -> Option<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n         .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length).into_iter())\n         .collect();\n@@ -494,13 +496,13 @@ fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n /// values of type `left_ty`. For vectors, this would normally be an infinite set\n /// but is instead bounded by the maximum fixed length of slice patterns in\n /// the column of patterns being analyzed.\n-fn all_constructors(cx: &MatchCheckCtxt, left_ty: ty::t,\n+fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n                     max_slice_length: uint) -> Vec<Constructor> {\n-    match ty::get(left_ty).sty {\n+    match left_ty.sty {\n         ty::ty_bool =>\n             [true, false].iter().map(|b| ConstantValue(const_bool(*b))).collect(),\n \n-        ty::ty_rptr(_, ty::mt { ty, .. }) => match ty::get(ty).sty {\n+        ty::ty_rptr(_, ty::mt { ty, .. }) => match ty.sty {\n             ty::ty_vec(_, None) =>\n                 range_inclusive(0, max_slice_length).map(|length| Slice(length)).collect(),\n             _ => vec!(Single)\n@@ -558,7 +560,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n     };\n \n     let max_slice_length = rows.iter().filter_map(|row| match row[0].node {\n-        PatVec(ref before, _, ref after) => Some(before.len() + after.len()),\n+        ast::PatVec(ref before, _, ref after) => Some(before.len() + after.len()),\n         _ => None\n     }).max().map_or(0, |v| v + 1);\n \n@@ -614,7 +616,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n }\n \n fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n-                         v: &[&Pat], ctor: Constructor, lty: ty::t,\n+                         v: &[&Pat], ctor: Constructor, lty: Ty,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n@@ -636,10 +638,10 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n /// On the other hand, a wild pattern and an identifier pattern cannot be\n /// specialized in any way.\n fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n-                    left_ty: ty::t, max_slice_length: uint) -> Vec<Constructor> {\n+                    left_ty: Ty, max_slice_length: uint) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-        PatIdent(..) =>\n+        ast::PatIdent(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n@@ -648,28 +650,28 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!()\n             },\n-        PatEnum(..) =>\n+        ast::PatEnum(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n-        PatStruct(..) =>\n+        ast::PatStruct(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n-        PatLit(ref expr) =>\n+        ast::PatLit(ref expr) =>\n             vec!(ConstantValue(eval_const_expr(cx.tcx, &**expr))),\n-        PatRange(ref lo, ref hi) =>\n+        ast::PatRange(ref lo, ref hi) =>\n             vec!(ConstantRange(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi))),\n-        PatVec(ref before, ref slice, ref after) =>\n-            match ty::get(left_ty).sty {\n+        ast::PatVec(ref before, ref slice, ref after) =>\n+            match left_ty.sty {\n                 ty::ty_vec(_, Some(_)) => vec!(Single),\n                 _                      => if slice.is_some() {\n                     range_inclusive(before.len() + after.len(), max_slice_length)\n@@ -679,11 +681,11 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     vec!(Slice(before.len() + after.len()))\n                 }\n             },\n-        PatBox(_) | PatTup(_) | PatRegion(..) =>\n+        ast::PatBox(_) | ast::PatTup(_) | ast::PatRegion(..) =>\n             vec!(Single),\n-        PatWild(_) =>\n+        ast::PatWild(_) =>\n             vec!(),\n-        PatMac(_) =>\n+        ast::PatMac(_) =>\n             cx.tcx.sess.bug(\"unexpanded macro\")\n     }\n }\n@@ -693,11 +695,11 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n ///\n /// For instance, a tuple pattern (_, 42u, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: ty::t) -> uint {\n-    match ty::get(ty).sty {\n+pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> uint {\n+    match ty.sty {\n         ty::ty_tup(ref fs) => fs.len(),\n         ty::ty_uniq(_) => 1u,\n-        ty::ty_rptr(_, ty::mt { ty, .. }) => match ty::get(ty).sty {\n+        ty::ty_rptr(_, ty::mt { ty, .. }) => match ty.sty {\n             ty::ty_vec(_, None) => match *ctor {\n                 Slice(length) => length,\n                 ConstantValue(_) => 0u,\n@@ -747,12 +749,11 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n     let &Pat {\n         id: pat_id, ref node, span: pat_span\n     } = raw_pat(r[col]);\n-    let head: Option<Vec<&Pat>> = match node {\n-\n-        &PatWild(_) =>\n+    let head: Option<Vec<&Pat>> = match *node {\n+        ast::PatWild(_) =>\n             Some(Vec::from_elem(arity, DUMMY_WILD_PAT)),\n \n-        &PatIdent(_, _, _) => {\n+        ast::PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().get(&pat_id).cloned();\n             match opt_def {\n                 Some(DefConst(..)) =>\n@@ -767,7 +768,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        &PatEnum(_, ref args) => {\n+        ast::PatEnum(_, ref args) => {\n             let def = cx.tcx.def_map.borrow()[pat_id].clone();\n             match def {\n                 DefConst(..) =>\n@@ -784,7 +785,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        &PatStruct(_, ref pattern_fields, _) => {\n+        ast::PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow()[pat_id].clone();\n             let class_id = match def {\n@@ -820,13 +821,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             })\n         }\n \n-        &PatTup(ref args) =>\n+        ast::PatTup(ref args) =>\n             Some(args.iter().map(|p| &**p).collect()),\n \n-        &PatBox(ref inner) | &PatRegion(ref inner) =>\n+        ast::PatBox(ref inner) | ast::PatRegion(ref inner) =>\n             Some(vec![&**inner]),\n \n-        &PatLit(ref expr) => {\n+        ast::PatLit(ref expr) => {\n             let expr_value = eval_const_expr(cx.tcx, &**expr);\n             match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n                 Some(true) => Some(vec![]),\n@@ -838,7 +839,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        &PatRange(ref from, ref to) => {\n+        ast::PatRange(ref from, ref to) => {\n             let from_value = eval_const_expr(cx.tcx, &**from);\n             let to_value = eval_const_expr(cx.tcx, &**to);\n             match range_covered_by_constructor(constructor, &from_value, &to_value) {\n@@ -851,7 +852,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        &PatVec(ref before, ref slice, ref after) => {\n+        ast::PatVec(ref before, ref slice, ref after) => {\n             match *constructor {\n                 // Fixed-length vectors.\n                 Single => {\n@@ -883,7 +884,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        &PatMac(_) => {\n+        ast::PatMac(_) => {\n             cx.tcx.sess.span_err(pat_span, \"unexpanded macro\");\n             None\n         }\n@@ -895,12 +896,12 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n     })\n }\n \n-fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n+fn check_local(cx: &mut MatchCheckCtxt, loc: &ast::Local) {\n     visit::walk_local(cx, loc);\n \n     let name = match loc.source {\n-        LocalLet => \"local\",\n-        LocalFor => \"`for` loop\"\n+        ast::LocalLet => \"local\",\n+        ast::LocalFor => \"`for` loop\"\n     };\n \n     let mut static_inliner = StaticInliner::new(cx.tcx);\n@@ -918,8 +919,8 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n \n fn check_fn(cx: &mut MatchCheckCtxt,\n             kind: FnKind,\n-            decl: &FnDecl,\n-            body: &Block,\n+            decl: &ast::FnDecl,\n+            body: &ast::Block,\n             sp: Span,\n             _: NodeId) {\n     visit::walk_fn(cx, kind, decl, body, sp);\n@@ -957,10 +958,10 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     for pat in pats.iter() {\n         pat_bindings(def_map, &**pat, |bm, _, span, _path| {\n             match bm {\n-                BindByRef(_) => {\n+                ast::BindByRef(_) => {\n                     by_ref_span = Some(span);\n                 }\n-                BindByValue(_) => {\n+                ast::BindByValue(_) => {\n                 }\n             }\n         })\n@@ -985,13 +986,13 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         walk_pat(&**pat, |p| {\n             if pat_is_binding(def_map, &*p) {\n                 match p.node {\n-                    PatIdent(BindByValue(_), _, ref sub) => {\n+                    ast::PatIdent(ast::BindByValue(_), _, ref sub) => {\n                         let pat_ty = ty::node_id_to_type(tcx, p.id);\n                         if ty::type_moves_by_default(tcx, pat_ty) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }\n-                    PatIdent(BindByRef(_), _, _) => {\n+                    ast::PatIdent(ast::BindByRef(_), _, _) => {\n                     }\n                     _ => {\n                         cx.tcx.sess.span_bug(\n@@ -1010,7 +1011,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n /// Ensures that a pattern guard doesn't borrow by mutable reference or\n /// assign.\n-fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>, guard: &Expr) {\n+fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n+                                         guard: &ast::Expr) {\n     let mut checker = MutationChecker {\n         cx: cx,\n     };\n@@ -1022,7 +1024,7 @@ struct MutationChecker<'a, 'tcx: 'a> {\n     cx: &'a MatchCheckCtxt<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx> Delegate for MutationChecker<'a, 'tcx> {\n+impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n     fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}\n     fn borrow(&mut self,\n@@ -1078,7 +1080,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n         }\n \n         match pat.node {\n-            PatIdent(_, _, Some(_)) => {\n+            ast::PatIdent(_, _, Some(_)) => {\n                 let bindings_were_allowed = self.bindings_allowed;\n                 self.bindings_allowed = false;\n                 visit::walk_pat(self, pat);"}, {"sha": "dbba9288cbbc4cb0d9874655cdd272453a78be2b", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -45,11 +45,11 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> euv::Delegate for RvalueContext<'a, 'tcx> {\n+impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContext<'a, 'tcx> {\n     fn consume(&mut self,\n                _: ast::NodeId,\n                span: Span,\n-               cmt: mc::cmt,\n+               cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n         debug!(\"consume; cmt: {}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n         if !ty::type_is_sized(self.tcx, cmt.ty) {"}, {"sha": "afba72cea99a20de4b8ae118fe2a323dc244ed59", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -53,7 +53,7 @@ struct CheckStaticVisitor<'a, 'tcx: 'a> {\n     checker: &'a mut GlobalChecker,\n }\n \n-struct GlobalVisitor<'a, 'b, 't: 'b>(euv::ExprUseVisitor<'a, 'b, ty::ctxt<'t>>);\n+struct GlobalVisitor<'a, 'b, 'tcx: 'b>(euv::ExprUseVisitor<'a, 'b, 'tcx, ty::ctxt<'tcx>>);\n struct GlobalChecker {\n     static_consumptions: NodeSet,\n     const_borrows: NodeSet,\n@@ -162,7 +162,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n \n         let node_ty = ty::node_id_to_type(self.tcx, e.id);\n \n-        match ty::get(node_ty).sty {\n+        match node_ty.sty {\n             ty::ty_struct(did, _) |\n             ty::ty_enum(did, _) if ty::has_dtor(self.tcx, did) => {\n                 self.tcx.sess.span_err(e.span,\n@@ -256,7 +256,7 @@ impl<'a, 'b, 't, 'v> Visitor<'v> for GlobalVisitor<'a, 'b, 't> {\n     }\n }\n \n-impl euv::Delegate for GlobalChecker {\n+impl<'tcx> euv::Delegate<'tcx> for GlobalChecker {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                _consume_span: Span,"}, {"sha": "c7c67e8a67b6142b017c9c3995bfecdb50213295", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 104, "deletions": 104, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -18,17 +18,17 @@ use metadata::csearch;\n use middle::astencode;\n use middle::def;\n use middle::pat_util::def_to_path;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::astconv;\n use middle::typeck::check;\n use util::nodemap::{DefIdMap};\n \n-use syntax::ast::*;\n+use syntax::ast::{mod, Expr};\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n-use syntax::{ast, ast_map, ast_util, codemap};\n+use syntax::{ast_map, ast_util, codemap};\n \n use std::rc::Rc;\n use std::collections::hash_map::Vacant;\n@@ -118,7 +118,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n         match tcx.map.find(enum_def.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n-                ItemEnum(ast::EnumDef { ref variants }, _) => {\n+                ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n                     variant_expr(variants.as_slice(), variant_def.node)\n                 }\n                 _ => None\n@@ -136,7 +136,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n         let expr_id = match csearch::maybe_get_item_ast(tcx, enum_def,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n             csearch::found(&ast::IIItem(ref item)) => match item.node {\n-                ItemEnum(ast::EnumDef { ref variants }, _) => {\n+                ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n                     // come from different crates, so they will likely never match.\n@@ -158,7 +158,7 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n         match tcx.map.find(def_id.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n-                ItemConst(_, ref const_expr) => {\n+                ast::ItemConst(_, ref const_expr) => {\n                     Some(&**const_expr)\n                 }\n                 _ => None\n@@ -176,7 +176,7 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n             csearch::found(&ast::IIItem(ref item)) => match item.node {\n-                ItemConst(_, ref const_expr) => Some(const_expr.id),\n+                ast::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n             _ => None\n@@ -280,9 +280,9 @@ impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ConstEvalVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, t: &Ty) {\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n-            TyFixedLengthVec(_, ref expr) => {\n+            ast::TyFixedLengthVec(_, ref expr) => {\n                 check::check_const_in_type(self.tcx, &**expr, ty::mk_uint());\n             }\n             _ => {}\n@@ -317,12 +317,12 @@ pub enum const_val {\n     const_bool(bool)\n }\n \n-pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n+pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n     let pat = match expr.node {\n-        ExprTup(ref exprs) =>\n-            PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect()),\n+        ast::ExprTup(ref exprs) =>\n+            ast::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect()),\n \n-        ExprCall(ref callee, ref args) => {\n+        ast::ExprCall(ref callee, ref args) => {\n             let def = tcx.def_map.borrow()[callee.id].clone();\n             match tcx.def_map.borrow_mut().entry(expr.id) {\n               Vacant(entry) => { entry.set(def); }\n@@ -334,33 +334,33 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n                 _ => unreachable!()\n             };\n             let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect();\n-            PatEnum(path, Some(pats))\n+            ast::PatEnum(path, Some(pats))\n         }\n \n-        ExprStruct(ref path, ref fields, None) => {\n+        ast::ExprStruct(ref path, ref fields, None) => {\n             let field_pats = fields.iter().map(|field| codemap::Spanned {\n                 span: codemap::DUMMY_SP,\n-                node: FieldPat {\n+                node: ast::FieldPat {\n                     ident: field.ident.node,\n                     pat: const_expr_to_pat(tcx, &*field.expr),\n                     is_shorthand: false,\n                 },\n             }).collect();\n-            PatStruct(path.clone(), field_pats, false)\n+            ast::PatStruct(path.clone(), field_pats, false)\n         }\n \n-        ExprVec(ref exprs) => {\n+        ast::ExprVec(ref exprs) => {\n             let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect();\n-            PatVec(pats, None, vec![])\n+            ast::PatVec(pats, None, vec![])\n         }\n \n-        ExprPath(ref path) => {\n+        ast::ExprPath(ref path) => {\n             let opt_def = tcx.def_map.borrow().get(&expr.id).cloned();\n             match opt_def {\n                 Some(def::DefStruct(..)) =>\n-                    PatStruct(path.clone(), vec![], false),\n+                    ast::PatStruct(path.clone(), vec![], false),\n                 Some(def::DefVariant(..)) =>\n-                    PatEnum(path.clone(), None),\n+                    ast::PatEnum(path.clone(), None),\n                 _ => {\n                     match lookup_const(tcx, expr) {\n                         Some(actual) => return const_expr_to_pat(tcx, actual),\n@@ -370,9 +370,9 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n             }\n         }\n \n-        _ => PatLit(P(expr.clone()))\n+        _ => ast::PatLit(P(expr.clone()))\n     };\n-    P(Pat { id: expr.id, node: pat, span: expr.span })\n+    P(ast::Pat { id: expr.id, node: pat, span: expr.span })\n }\n \n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n@@ -385,7 +385,7 @@ pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, String> {\n     fn fromb(b: bool) -> Result<const_val, String> { Ok(const_int(b as i64)) }\n     match e.node {\n-      ExprUnary(UnNeg, ref inner) => {\n+      ast::ExprUnary(ast::UnNeg, ref inner) => {\n         match eval_const_expr_partial(tcx, &**inner) {\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n@@ -395,118 +395,118 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n           ref err => ((*err).clone())\n         }\n       }\n-      ExprUnary(UnNot, ref inner) => {\n+      ast::ExprUnary(ast::UnNot, ref inner) => {\n         match eval_const_expr_partial(tcx, &**inner) {\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n           _ => Err(\"not on float or string\".to_string())\n         }\n       }\n-      ExprBinary(op, ref a, ref b) => {\n+      ast::ExprBinary(op, ref a, ref b) => {\n         match (eval_const_expr_partial(tcx, &**a),\n                eval_const_expr_partial(tcx, &**b)) {\n           (Ok(const_float(a)), Ok(const_float(b))) => {\n             match op {\n-              BiAdd => Ok(const_float(a + b)),\n-              BiSub => Ok(const_float(a - b)),\n-              BiMul => Ok(const_float(a * b)),\n-              BiDiv => Ok(const_float(a / b)),\n-              BiRem => Ok(const_float(a % b)),\n-              BiEq => fromb(a == b),\n-              BiLt => fromb(a < b),\n-              BiLe => fromb(a <= b),\n-              BiNe => fromb(a != b),\n-              BiGe => fromb(a >= b),\n-              BiGt => fromb(a > b),\n+              ast::BiAdd => Ok(const_float(a + b)),\n+              ast::BiSub => Ok(const_float(a - b)),\n+              ast::BiMul => Ok(const_float(a * b)),\n+              ast::BiDiv => Ok(const_float(a / b)),\n+              ast::BiRem => Ok(const_float(a % b)),\n+              ast::BiEq => fromb(a == b),\n+              ast::BiLt => fromb(a < b),\n+              ast::BiLe => fromb(a <= b),\n+              ast::BiNe => fromb(a != b),\n+              ast::BiGe => fromb(a >= b),\n+              ast::BiGt => fromb(a > b),\n               _ => Err(\"can't do this op on floats\".to_string())\n             }\n           }\n           (Ok(const_int(a)), Ok(const_int(b))) => {\n             match op {\n-              BiAdd => Ok(const_int(a + b)),\n-              BiSub => Ok(const_int(a - b)),\n-              BiMul => Ok(const_int(a * b)),\n-              BiDiv if b == 0 => {\n+              ast::BiAdd => Ok(const_int(a + b)),\n+              ast::BiSub => Ok(const_int(a - b)),\n+              ast::BiMul => Ok(const_int(a * b)),\n+              ast::BiDiv if b == 0 => {\n                   Err(\"attempted to divide by zero\".to_string())\n               }\n-              BiDiv => Ok(const_int(a / b)),\n-              BiRem if b == 0 => {\n+              ast::BiDiv => Ok(const_int(a / b)),\n+              ast::BiRem if b == 0 => {\n                   Err(\"attempted remainder with a divisor of \\\n                        zero\".to_string())\n               }\n-              BiRem => Ok(const_int(a % b)),\n-              BiAnd | BiBitAnd => Ok(const_int(a & b)),\n-              BiOr | BiBitOr => Ok(const_int(a | b)),\n-              BiBitXor => Ok(const_int(a ^ b)),\n-              BiShl => Ok(const_int(a << b as uint)),\n-              BiShr => Ok(const_int(a >> b as uint)),\n-              BiEq => fromb(a == b),\n-              BiLt => fromb(a < b),\n-              BiLe => fromb(a <= b),\n-              BiNe => fromb(a != b),\n-              BiGe => fromb(a >= b),\n-              BiGt => fromb(a > b)\n+              ast::BiRem => Ok(const_int(a % b)),\n+              ast::BiAnd | ast::BiBitAnd => Ok(const_int(a & b)),\n+              ast::BiOr | ast::BiBitOr => Ok(const_int(a | b)),\n+              ast::BiBitXor => Ok(const_int(a ^ b)),\n+              ast::BiShl => Ok(const_int(a << b as uint)),\n+              ast::BiShr => Ok(const_int(a >> b as uint)),\n+              ast::BiEq => fromb(a == b),\n+              ast::BiLt => fromb(a < b),\n+              ast::BiLe => fromb(a <= b),\n+              ast::BiNe => fromb(a != b),\n+              ast::BiGe => fromb(a >= b),\n+              ast::BiGt => fromb(a > b)\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_uint(b))) => {\n             match op {\n-              BiAdd => Ok(const_uint(a + b)),\n-              BiSub => Ok(const_uint(a - b)),\n-              BiMul => Ok(const_uint(a * b)),\n-              BiDiv if b == 0 => {\n+              ast::BiAdd => Ok(const_uint(a + b)),\n+              ast::BiSub => Ok(const_uint(a - b)),\n+              ast::BiMul => Ok(const_uint(a * b)),\n+              ast::BiDiv if b == 0 => {\n                   Err(\"attempted to divide by zero\".to_string())\n               }\n-              BiDiv => Ok(const_uint(a / b)),\n-              BiRem if b == 0 => {\n+              ast::BiDiv => Ok(const_uint(a / b)),\n+              ast::BiRem if b == 0 => {\n                   Err(\"attempted remainder with a divisor of \\\n                        zero\".to_string())\n               }\n-              BiRem => Ok(const_uint(a % b)),\n-              BiAnd | BiBitAnd => Ok(const_uint(a & b)),\n-              BiOr | BiBitOr => Ok(const_uint(a | b)),\n-              BiBitXor => Ok(const_uint(a ^ b)),\n-              BiShl => Ok(const_uint(a << b as uint)),\n-              BiShr => Ok(const_uint(a >> b as uint)),\n-              BiEq => fromb(a == b),\n-              BiLt => fromb(a < b),\n-              BiLe => fromb(a <= b),\n-              BiNe => fromb(a != b),\n-              BiGe => fromb(a >= b),\n-              BiGt => fromb(a > b),\n+              ast::BiRem => Ok(const_uint(a % b)),\n+              ast::BiAnd | ast::BiBitAnd => Ok(const_uint(a & b)),\n+              ast::BiOr | ast::BiBitOr => Ok(const_uint(a | b)),\n+              ast::BiBitXor => Ok(const_uint(a ^ b)),\n+              ast::BiShl => Ok(const_uint(a << b as uint)),\n+              ast::BiShr => Ok(const_uint(a >> b as uint)),\n+              ast::BiEq => fromb(a == b),\n+              ast::BiLt => fromb(a < b),\n+              ast::BiLe => fromb(a <= b),\n+              ast::BiNe => fromb(a != b),\n+              ast::BiGe => fromb(a >= b),\n+              ast::BiGt => fromb(a > b),\n             }\n           }\n           // shifts can have any integral type as their rhs\n           (Ok(const_int(a)), Ok(const_uint(b))) => {\n             match op {\n-              BiShl => Ok(const_int(a << b as uint)),\n-              BiShr => Ok(const_int(a >> b as uint)),\n+              ast::BiShl => Ok(const_int(a << b as uint)),\n+              ast::BiShr => Ok(const_int(a >> b as uint)),\n               _ => Err(\"can't do this op on an int and uint\".to_string())\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_int(b))) => {\n             match op {\n-              BiShl => Ok(const_uint(a << b as uint)),\n-              BiShr => Ok(const_uint(a >> b as uint)),\n+              ast::BiShl => Ok(const_uint(a << b as uint)),\n+              ast::BiShr => Ok(const_uint(a >> b as uint)),\n               _ => Err(\"can't do this op on a uint and int\".to_string())\n             }\n           }\n           (Ok(const_bool(a)), Ok(const_bool(b))) => {\n             Ok(const_bool(match op {\n-              BiAnd => a && b,\n-              BiOr => a || b,\n-              BiBitXor => a ^ b,\n-              BiBitAnd => a & b,\n-              BiBitOr => a | b,\n-              BiEq => a == b,\n-              BiNe => a != b,\n+              ast::BiAnd => a && b,\n+              ast::BiOr => a || b,\n+              ast::BiBitXor => a ^ b,\n+              ast::BiBitAnd => a & b,\n+              ast::BiBitOr => a | b,\n+              ast::BiEq => a == b,\n+              ast::BiNe => a != b,\n               _ => return Err(\"can't do this op on bools\".to_string())\n              }))\n           }\n           _ => Err(\"bad operands for binary\".to_string())\n         }\n       }\n-      ExprCast(ref base, ref target_ty) => {\n+      ast::ExprCast(ref base, ref target_ty) => {\n         // This tends to get called w/o the type actually having been\n         // populated in the ctxt, which was causing things to blow up\n         // (#5900). Fall back to doing a limited lookup to get past it.\n@@ -524,7 +524,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n                     $const_type:ident,\n                     $target_ty:ty\n                 )),*\n-            }) => (match ty::get(ety).sty {\n+            }) => (match ety.sty {\n                 $($ty_pat => {\n                     match $val {\n                         const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),\n@@ -556,15 +556,15 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n                 ty::ty_float(ast::TyF64) => (f64, const_float, f64)\n             }))\n       }\n-      ExprPath(_) => {\n+      ast::ExprPath(_) => {\n           match lookup_const(tcx, e) {\n               Some(actual_e) => eval_const_expr_partial(tcx, &*actual_e),\n               None => Err(\"non-constant path in constant expr\".to_string())\n           }\n       }\n-      ExprLit(ref lit) => Ok(lit_to_const(&**lit)),\n-      ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e),\n-      ExprBlock(ref block) => {\n+      ast::ExprLit(ref lit) => Ok(lit_to_const(&**lit)),\n+      ast::ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e),\n+      ast::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => eval_const_expr_partial(tcx, &**expr),\n             None => Ok(const_int(0i64))\n@@ -574,24 +574,24 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n     }\n }\n \n-pub fn lit_to_const(lit: &Lit) -> const_val {\n+pub fn lit_to_const(lit: &ast::Lit) -> const_val {\n     match lit.node {\n-        LitStr(ref s, _) => const_str((*s).clone()),\n-        LitBinary(ref data) => {\n+        ast::LitStr(ref s, _) => const_str((*s).clone()),\n+        ast::LitBinary(ref data) => {\n             const_binary(Rc::new(data.iter().map(|x| *x).collect()))\n         }\n-        LitByte(n) => const_uint(n as u64),\n-        LitChar(n) => const_uint(n as u64),\n-        LitInt(n, ast::SignedIntLit(_, ast::Plus)) |\n-        LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => const_int(n as i64),\n-        LitInt(n, ast::SignedIntLit(_, ast::Minus)) |\n-        LitInt(n, ast::UnsuffixedIntLit(ast::Minus)) => const_int(-(n as i64)),\n-        LitInt(n, ast::UnsignedIntLit(_)) => const_uint(n),\n-        LitFloat(ref n, _) |\n-        LitFloatUnsuffixed(ref n) => {\n+        ast::LitByte(n) => const_uint(n as u64),\n+        ast::LitChar(n) => const_uint(n as u64),\n+        ast::LitInt(n, ast::SignedIntLit(_, ast::Plus)) |\n+        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => const_int(n as i64),\n+        ast::LitInt(n, ast::SignedIntLit(_, ast::Minus)) |\n+        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Minus)) => const_int(-(n as i64)),\n+        ast::LitInt(n, ast::UnsignedIntLit(_)) => const_uint(n),\n+        ast::LitFloat(ref n, _) |\n+        ast::LitFloatUnsuffixed(ref n) => {\n             const_float(from_str::<f64>(n.get()).unwrap() as f64)\n         }\n-        LitBool(b) => const_bool(b)\n+        ast::LitBool(b) => const_bool(b)\n     }\n }\n "}, {"sha": "62a5d23e3332cb839c69cc3b2daefe3022ca91ce", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_access(&mut self, lhs: &ast::Expr, name: &ast::Ident) {\n-        match ty::get(ty::expr_ty_adjusted(self.tcx, lhs)).sty {\n+        match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n             ty::ty_struct(id, _) => {\n                 let fields = ty::lookup_struct_fields(self.tcx, id);\n                 let field_id = fields.iter()\n@@ -152,7 +152,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: uint) {\n-        match ty::get(ty::expr_ty_adjusted(self.tcx, lhs)).sty {\n+        match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n             ty::ty_struct(id, _) => {\n                 let fields = ty::lookup_struct_fields(self.tcx, id);\n                 let field_id = fields[idx].id;"}, {"sha": "71885a769f580e452cc3a69fee7a86a25e98c42e", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -13,7 +13,7 @@\n use self::UnsafeContext::*;\n \n use middle::def;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::MethodCall;\n use util::ppaux;\n \n@@ -30,8 +30,8 @@ enum UnsafeContext {\n     UnsafeBlock(ast::NodeId),\n }\n \n-fn type_is_unsafe_function(ty: ty::t) -> bool {\n-    match ty::get(ty).sty {\n+fn type_is_unsafe_function(ty: Ty) -> bool {\n+    match ty.sty {\n         ty::ty_bare_fn(ref f) => f.fn_style == ast::UnsafeFn,\n         ty::ty_closure(ref f) => f.fn_style == ast::UnsafeFn,\n         _ => false,\n@@ -70,8 +70,8 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n         };\n         debug!(\"effect: checking index with base type {}\",\n                 ppaux::ty_to_string(self.tcx, base_type));\n-        match ty::get(base_type).sty {\n-            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+        match base_type.sty {\n+            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty.sty {\n                 ty::ty_str => {\n                     span_err!(self.tcx.sess, e.span, E0134,\n                               \"modification of string types is not allowed\");\n@@ -166,7 +166,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: unary case, base type is {}\",\n                         ppaux::ty_to_string(self.tcx, base_type));\n-                match ty::get(base_type).sty {\n+                match base_type.sty {\n                     ty::ty_ptr(_) => {\n                         self.require_unsafe(expr.span,\n                                             \"dereference of unsafe pointer\")"}, {"sha": "f4c22c571639001b2dd89b338202d6d9e49bef59", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -24,7 +24,7 @@ use middle::mem_categorization as mc;\n use middle::def;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::{MethodCall, MethodObject, MethodTraitObject};\n use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure};\n@@ -40,28 +40,28 @@ use syntax::codemap::Span;\n \n /// This trait defines the callbacks you can expect to receive when\n /// employing the ExprUseVisitor.\n-pub trait Delegate {\n+pub trait Delegate<'tcx> {\n     // The value found at `cmt` is either copied or moved, depending\n     // on mode.\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                consume_span: Span,\n-               cmt: mc::cmt,\n+               cmt: mc::cmt<'tcx>,\n                mode: ConsumeMode);\n \n     // The value found at `cmt` is either copied or moved via the\n     // pattern binding `consume_pat`, depending on mode.\n     fn consume_pat(&mut self,\n                    consume_pat: &ast::Pat,\n-                   cmt: mc::cmt,\n+                   cmt: mc::cmt<'tcx>,\n                    mode: ConsumeMode);\n \n     // The value found at `borrow` is being borrowed at the point\n     // `borrow_id` for the region `loan_region` with kind `bk`.\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n-              cmt: mc::cmt,\n+              cmt: mc::cmt<'tcx>,\n               loan_region: ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: LoanCause);\n@@ -75,7 +75,7 @@ pub trait Delegate {\n     fn mutate(&mut self,\n               assignment_id: ast::NodeId,\n               assignment_span: Span,\n-              assignee_cmt: mc::cmt,\n+              assignee_cmt: mc::cmt<'tcx>,\n               mode: MutateMode);\n }\n \n@@ -201,10 +201,10 @@ impl OverloadedCallType {\n // supplies types from the tree. After type checking is complete, you\n // can just use the tcx as the typer.\n \n-pub struct ExprUseVisitor<'d,'t,TYPER:'t> {\n+pub struct ExprUseVisitor<'d,'t,'tcx,TYPER:'t> {\n     typer: &'t TYPER,\n     mc: mc::MemCategorizationContext<'t,TYPER>,\n-    delegate: &'d mut Delegate+'d,\n+    delegate: &'d mut Delegate<'tcx>+'d,\n }\n \n // If the TYPER results in an error, it's because the type check\n@@ -223,10 +223,10 @@ macro_rules! return_if_err(\n     )\n )\n \n-impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n-    pub fn new(delegate: &'d mut Delegate,\n+impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n+    pub fn new(delegate: &'d mut Delegate<'tcx>,\n                typer: &'t TYPER)\n-               -> ExprUseVisitor<'d,'t,TYPER> {\n+               -> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         ExprUseVisitor { typer: typer,\n                          mc: mc::MemCategorizationContext::new(typer),\n                          delegate: delegate }\n@@ -262,7 +262,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     fn delegate_consume(&mut self,\n                         consume_id: ast::NodeId,\n                         consume_span: Span,\n-                        cmt: mc::cmt) {\n+                        cmt: mc::cmt<'tcx>) {\n         let mode = copy_or_move(self.tcx(), cmt.ty, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n@@ -519,7 +519,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         let callee_ty = ty::expr_ty_adjusted(self.tcx(), callee);\n         debug!(\"walk_callee: callee={} callee_ty={}\",\n                callee.repr(self.tcx()), callee_ty.repr(self.tcx()));\n-        match ty::get(callee_ty).sty {\n+        match callee_ty.sty {\n             ty::ty_bare_fn(..) => {\n                 self.consume_expr(callee);\n             }\n@@ -656,7 +656,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n-        let with_fields = match ty::get(with_cmt.ty).sty {\n+        let with_fields = match with_cmt.ty.sty {\n             ty::ty_struct(did, ref substs) => {\n                 ty::struct_fields(self.tcx(), did, substs)\n             }\n@@ -745,7 +745,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 Some(method_ty) => {\n                     let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n                     let self_ty = ty::ty_fn_args(method_ty)[0];\n-                    let (m, r) = match ty::get(self_ty).sty {\n+                    let (m, r) = match self_ty.sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n                                 format!(\"bad overloaded deref type {}\",\n@@ -823,7 +823,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         return true;\n     }\n \n-    fn walk_arm(&mut self, discr_cmt: mc::cmt, arm: &ast::Arm) {\n+    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) {\n         for pat in arm.pats.iter() {\n             self.walk_pat(discr_cmt.clone(), &**pat);\n         }\n@@ -835,7 +835,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         self.consume_expr(&*arm.body);\n     }\n \n-    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: &ast::Pat) {\n+    fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &ast::Pat) {\n         debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n         let mc = &self.mc;\n@@ -990,7 +990,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                         closure_id: ast::NodeId,\n                         closure_span: Span,\n                         upvar_def: def::Def)\n-                        -> mc::McResult<mc::cmt> {\n+                        -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_id = upvar_def.def_id().node;\n@@ -999,7 +999,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     }\n }\n \n-fn copy_or_move(tcx: &ty::ctxt, ty: ty::t, move_reason: MoveReason) -> ConsumeMode {\n+fn copy_or_move<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>,\n+                      move_reason: MoveReason) -> ConsumeMode {\n     if ty::type_moves_by_default(tcx, ty) { Move(move_reason) } else { Copy }\n }\n "}, {"sha": "7514a63c7fa58f5bfd1186da8c6fde92e521eed0", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use syntax::ast;\n \n use self::SimplifiedType::*;\n@@ -34,7 +34,7 @@ pub enum SimplifiedType {\n }\n \n pub fn simplify_type(tcx: &ty::ctxt,\n-                     ty: ty::t,\n+                     ty: Ty,\n                      can_simplify_params: bool)\n                      -> Option<SimplifiedType>\n {\n@@ -53,7 +53,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n      * are to be considered bound.\n      */\n \n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_bool => Some(BoolSimplifiedType),\n         ty::ty_char => Some(CharSimplifiedType),\n         ty::ty_int(int_type) => Some(IntSimplifiedType(int_type)),"}, {"sha": "68d0ac932164a4272b55cd302cb3a43e378e207c", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -12,7 +12,7 @@ use metadata::csearch;\n use middle::def::DefFn;\n use middle::subst::Subst;\n use middle::ty::{TransmuteRestriction, ctxt, ty_bare_fn};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n \n use syntax::abi::RustIntrinsic;\n use syntax::ast::DefId;\n@@ -23,11 +23,11 @@ use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-fn type_size_is_affected_by_type_parameters(tcx: &ty::ctxt, typ: ty::t)\n-                                            -> bool {\n+fn type_size_is_affected_by_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>, typ: Ty<'tcx>)\n+                                                  -> bool {\n     let mut result = false;\n     ty::maybe_walk_ty(typ, |typ| {\n-        match ty::get(typ).sty {\n+        match typ.sty {\n             ty::ty_uniq(_) | ty::ty_ptr(_) | ty::ty_rptr(..) |\n             ty::ty_bare_fn(..) | ty::ty_closure(..) => {\n                 false\n@@ -73,7 +73,7 @@ struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match ty::get(ty::lookup_item_type(self.tcx, def_id).ty).sty {\n+        let intrinsic = match ty::lookup_item_type(self.tcx, def_id).ty.sty {\n             ty::ty_bare_fn(ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_transmute(&self, span: Span, from: ty::t, to: ty::t, id: ast::NodeId) {\n+    fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>, id: ast::NodeId) {\n         if type_size_is_affected_by_type_parameters(self.tcx, from) {\n             span_err!(self.tcx.sess, span, E0139,\n                       \"cannot transmute from a type that contains type parameters\");\n@@ -123,7 +123,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                 match ty::resolve_expr(self.tcx, expr) {\n                     DefFn(did, _) if self.def_id_is_transmute(did) => {\n                         let typ = ty::node_id_to_type(self.tcx, expr.id);\n-                        match ty::get(typ).sty {\n+                        match typ.sty {\n                             ty_bare_fn(ref bare_fn_ty)\n                                     if bare_fn_ty.abi == RustIntrinsic => {\n                                 if let ty::FnConverging(to) = bare_fn_ty.sig.output {"}, {"sha": "82edfdf146eaefa70de2e0fb45ad1dc1d831fd44", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 113, "deletions": 110, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -123,8 +123,7 @@ use std::fmt;\n use std::io;\n use std::rc::Rc;\n use std::uint;\n-use syntax::ast;\n-use syntax::ast::*;\n+use syntax::ast::{mod, NodeId, Expr};\n use syntax::codemap::{BytePos, original_sp, Span};\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n@@ -140,7 +139,7 @@ enum LoopKind<'a> {\n     /// A `while` loop, with the given expression as condition.\n     WhileLoop(&'a Expr),\n     /// A `for` loop, with the given pattern to bind.\n-    ForLoop(&'a Pat),\n+    ForLoop(&'a ast::Pat),\n }\n \n #[deriving(PartialEq)]\n@@ -187,12 +186,13 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, cx: &ty::ctxt) -> String {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v ast::FnDecl,\n+                b: &'v ast::Block, s: Span, id: NodeId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n     fn visit_local(&mut self, l: &ast::Local) { visit_local(self, l); }\n     fn visit_expr(&mut self, ex: &Expr) { visit_expr(self, ex); }\n-    fn visit_arm(&mut self, a: &Arm) { visit_arm(self, a); }\n+    fn visit_arm(&mut self, a: &ast::Arm) { visit_arm(self, a); }\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n@@ -250,12 +250,12 @@ struct CaptureInfo {\n #[deriving(Show)]\n struct LocalInfo {\n     id: NodeId,\n-    ident: Ident\n+    ident: ast::Ident\n }\n \n #[deriving(Show)]\n enum VarKind {\n-    Arg(NodeId, Ident),\n+    Arg(NodeId, ast::Ident),\n     Local(LocalInfo),\n     ImplicitRet,\n     CleanExit\n@@ -354,7 +354,8 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, n: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v ast::FnDecl,\n+                b: &'v ast::Block, s: Span, n: NodeId) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n     fn visit_local(&mut self, l: &ast::Local) {\n@@ -363,15 +364,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         check_expr(self, ex);\n     }\n-    fn visit_arm(&mut self, a: &Arm) {\n+    fn visit_arm(&mut self, a: &ast::Arm) {\n         check_arm(self, a);\n     }\n }\n \n fn visit_fn(ir: &mut IrMaps,\n             fk: FnKind,\n-            decl: &FnDecl,\n-            body: &Block,\n+            decl: &ast::FnDecl,\n+            body: &ast::Block,\n             sp: Span,\n             id: ast::NodeId) {\n     debug!(\"visit_fn\");\n@@ -429,7 +430,7 @@ fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n     visit::walk_local(ir, local);\n }\n \n-fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n+fn visit_arm(ir: &mut IrMaps, arm: &ast::Arm) {\n     for pat in arm.pats.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {}\",\n@@ -448,7 +449,7 @@ fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      ExprPath(_) => {\n+      ast::ExprPath(_) => {\n         let def = ir.tcx.def_map.borrow()[expr.id].clone();\n         debug!(\"expr {}: path that leads to {}\", expr.id, def);\n         match def {\n@@ -457,7 +458,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         }\n         visit::walk_expr(ir, expr);\n       }\n-      ExprFnBlock(..) | ExprProc(..) | ExprUnboxedFn(..) => {\n+      ast::ExprFnBlock(..) | ast::ExprProc(..) | ast::ExprUnboxedFn(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -485,17 +486,17 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       }\n \n       // live nodes required for interesting control flow:\n-      ExprIf(..) | ExprMatch(..) | ExprWhile(..) | ExprLoop(..) => {\n+      ast::ExprIf(..) | ast::ExprMatch(..) | ast::ExprWhile(..) | ast::ExprLoop(..) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n-      ExprIfLet(..) => {\n+      ast::ExprIfLet(..) => {\n           ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n       }\n-      ExprWhileLet(..) => {\n+      ast::ExprWhileLet(..) => {\n           ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n-      ExprForLoop(ref pat, _, _, _) => {\n+      ast::ExprForLoop(ref pat, _, _, _) => {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from for loop with bm {}\",\n                    p_id, bm);\n@@ -509,20 +510,21 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n-      ExprBinary(op, _, _) if ast_util::lazy_binop(op) => {\n+      ast::ExprBinary(op, _, _) if ast_util::lazy_binop(op) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n \n       // otherwise, live nodes are not required:\n-      ExprIndex(..) | ExprField(..) | ExprTupField(..) | ExprVec(..) |\n-      ExprCall(..) | ExprMethodCall(..) | ExprTup(..) | ExprSlice(..) |\n-      ExprBinary(..) | ExprAddrOf(..) |\n-      ExprCast(..) | ExprUnary(..) | ExprBreak(_) |\n-      ExprAgain(_) | ExprLit(_) | ExprRet(..) | ExprBlock(..) |\n-      ExprAssign(..) | ExprAssignOp(..) | ExprMac(..) |\n-      ExprStruct(..) | ExprRepeat(..) | ExprParen(..) |\n-      ExprInlineAsm(..) | ExprBox(..) => {\n+      ast::ExprIndex(..) | ast::ExprField(..) | ast::ExprTupField(..) |\n+      ast::ExprVec(..) | ast::ExprCall(..) | ast::ExprMethodCall(..) |\n+      ast::ExprTup(..) | ast::ExprBinary(..) | ast::ExprAddrOf(..) |\n+      ast::ExprCast(..) | ast::ExprUnary(..) | ast::ExprBreak(_) |\n+      ast::ExprAgain(_) | ast::ExprLit(_) | ast::ExprRet(..) |\n+      ast::ExprBlock(..) | ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n+      ast::ExprMac(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n+      ast::ExprParen(..) | ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n+      ast::ExprSlice(..) => {\n           visit::walk_expr(ir, expr);\n       }\n     }\n@@ -611,7 +613,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn pat_bindings(&mut self,\n-                    pat: &Pat,\n+                    pat: &ast::Pat,\n                     f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n         pat_util::pat_bindings(&self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n@@ -621,7 +623,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn arm_pats_bindings(&mut self,\n-                         pat: Option<&Pat>,\n+                         pat: Option<&ast::Pat>,\n                          f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n         match pat {\n             Some(pat) => {\n@@ -631,12 +633,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn define_bindings_in_pat(&mut self, pat: &Pat, succ: LiveNode)\n+    fn define_bindings_in_pat(&mut self, pat: &ast::Pat, succ: LiveNode)\n                               -> LiveNode {\n         self.define_bindings_in_arm_pats(Some(pat), succ)\n     }\n \n-    fn define_bindings_in_arm_pats(&mut self, pat: Option<&Pat>, succ: LiveNode)\n+    fn define_bindings_in_arm_pats(&mut self, pat: Option<&ast::Pat>, succ: LiveNode)\n                                    -> LiveNode {\n         let mut succ = succ;\n         self.arm_pats_bindings(pat, |this, ln, var, _sp, _id| {\n@@ -711,7 +713,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn find_loop_scope(&self,\n-                       opt_label: Option<Ident>,\n+                       opt_label: Option<ast::Ident>,\n                        id: NodeId,\n                        sp: Span)\n                        -> NodeId {\n@@ -846,7 +848,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     // _______________________________________________________________________\n \n-    fn compute(&mut self, decl: &FnDecl, body: &Block) -> LiveNode {\n+    fn compute(&mut self, decl: &ast::FnDecl, body: &ast::Block) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n@@ -871,7 +873,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(&mut self, _: &FnDecl, blk: &Block)\n+    fn propagate_through_fn_block(&mut self, _: &ast::FnDecl, blk: &ast::Block)\n                                   -> LiveNode {\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n@@ -885,38 +887,38 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.propagate_through_block(blk, s.fallthrough_ln)\n     }\n \n-    fn propagate_through_block(&mut self, blk: &Block, succ: LiveNode)\n+    fn propagate_through_block(&mut self, blk: &ast::Block, succ: LiveNode)\n                                -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n             self.propagate_through_stmt(&**stmt, succ)\n         })\n     }\n \n-    fn propagate_through_stmt(&mut self, stmt: &Stmt, succ: LiveNode)\n+    fn propagate_through_stmt(&mut self, stmt: &ast::Stmt, succ: LiveNode)\n                               -> LiveNode {\n         match stmt.node {\n-            StmtDecl(ref decl, _) => {\n+            ast::StmtDecl(ref decl, _) => {\n                 self.propagate_through_decl(&**decl, succ)\n             }\n \n-            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => {\n+            ast::StmtExpr(ref expr, _) | ast::StmtSemi(ref expr, _) => {\n                 self.propagate_through_expr(&**expr, succ)\n             }\n \n-            StmtMac(..) => {\n+            ast::StmtMac(..) => {\n                 self.ir.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n             }\n         }\n     }\n \n-    fn propagate_through_decl(&mut self, decl: &Decl, succ: LiveNode)\n+    fn propagate_through_decl(&mut self, decl: &ast::Decl, succ: LiveNode)\n                               -> LiveNode {\n         match decl.node {\n-            DeclLocal(ref local) => {\n+            ast::DeclLocal(ref local) => {\n                 self.propagate_through_local(&**local, succ)\n             }\n-            DeclItem(_) => succ,\n+            ast::DeclItem(_) => succ,\n         }\n     }\n \n@@ -961,21 +963,21 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n-          ExprPath(_) => {\n+          ast::ExprPath(_) => {\n               self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n-          ExprField(ref e, _, _) => {\n+          ast::ExprField(ref e, _, _) => {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ExprTupField(ref e, _, _) => {\n+          ast::ExprTupField(ref e, _, _) => {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ExprFnBlock(_, _, ref blk) |\n-          ExprProc(_, ref blk) |\n-          ExprUnboxedFn(_, _, _, ref blk) => {\n+          ast::ExprFnBlock(_, _, ref blk) |\n+          ast::ExprProc(_, ref blk) |\n+          ast::ExprUnboxedFn(_, _, _, ref blk) => {\n               debug!(\"{} is an ExprFnBlock, ExprProc, or ExprUnboxedFn\",\n                      expr_to_string(expr));\n \n@@ -1003,7 +1005,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               })\n           }\n \n-          ExprIf(ref cond, ref then, ref els) => {\n+          ast::ExprIf(ref cond, ref then, ref els) => {\n             //\n             //     (cond)\n             //       |\n@@ -1025,30 +1027,30 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**cond, ln)\n           }\n \n-          ExprIfLet(..) => {\n+          ast::ExprIfLet(..) => {\n               self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n           }\n \n-          ExprWhile(ref cond, ref blk, _) => {\n+          ast::ExprWhile(ref cond, ref blk, _) => {\n             self.propagate_through_loop(expr, WhileLoop(&**cond), &**blk, succ)\n           }\n \n-          ExprWhileLet(..) => {\n+          ast::ExprWhileLet(..) => {\n               self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n           }\n \n-          ExprForLoop(ref pat, ref head, ref blk, _) => {\n+          ast::ExprForLoop(ref pat, ref head, ref blk, _) => {\n             let ln = self.propagate_through_loop(expr, ForLoop(&**pat), &**blk, succ);\n             self.propagate_through_expr(&**head, ln)\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          ExprLoop(ref blk, _) => {\n+          ast::ExprLoop(ref blk, _) => {\n             self.propagate_through_loop(expr, LoopLoop, &**blk, succ)\n           }\n \n-          ExprMatch(ref e, ref arms, _) => {\n+          ast::ExprMatch(ref e, ref arms, _) => {\n             //\n             //      (e)\n             //       |\n@@ -1083,13 +1085,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**e, ln)\n           }\n \n-          ExprRet(ref o_e) => {\n+          ast::ExprRet(ref o_e) => {\n             // ignore succ and subst exit_ln:\n             let exit_ln = self.s.exit_ln;\n             self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n           }\n \n-          ExprBreak(opt_label) => {\n+          ast::ExprBreak(opt_label) => {\n               // Find which label this break jumps to\n               let sc = self.find_loop_scope(opt_label, expr.id, expr.span);\n \n@@ -1103,7 +1105,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          ExprAgain(opt_label) => {\n+          ast::ExprAgain(opt_label) => {\n               // Find which label this expr continues to\n               let sc = self.find_loop_scope(opt_label, expr.id, expr.span);\n \n@@ -1117,15 +1119,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          ExprAssign(ref l, ref r) => {\n+          ast::ExprAssign(ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n             let succ = self.write_lvalue(&**l, succ, ACC_WRITE);\n             let succ = self.propagate_through_lvalue_components(&**l, succ);\n             self.propagate_through_expr(&**r, succ)\n           }\n \n-          ExprAssignOp(_, ref l, ref r) => {\n+          ast::ExprAssignOp(_, ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n             let succ = self.write_lvalue(&**l, succ, ACC_WRITE|ACC_READ);\n@@ -1135,23 +1137,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           // Uninteresting cases: just propagate in rev exec order\n \n-          ExprVec(ref exprs) => {\n+          ast::ExprVec(ref exprs) => {\n             self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n \n-          ExprRepeat(ref element, ref count) => {\n+          ast::ExprRepeat(ref element, ref count) => {\n             let succ = self.propagate_through_expr(&**count, succ);\n             self.propagate_through_expr(&**element, succ)\n           }\n \n-          ExprStruct(_, ref fields, ref with_expr) => {\n+          ast::ExprStruct(_, ref fields, ref with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n                 self.propagate_through_expr(&*field.expr, succ)\n             })\n           }\n \n-          ExprCall(ref f, ref args) => {\n+          ast::ExprCall(ref f, ref args) => {\n             let diverges = !self.ir.tcx.is_method_call(expr.id) && {\n                 let t_ret = ty::ty_fn_ret(ty::expr_ty(self.ir.tcx, &**f));\n                 t_ret == ty::FnDiverging\n@@ -1165,7 +1167,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**f, succ)\n           }\n \n-          ExprMethodCall(_, _, ref args) => {\n+          ast::ExprMethodCall(_, _, ref args) => {\n             let method_call = typeck::MethodCall::expr(expr.id);\n             let method_ty = self.ir.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n             let diverges = ty::ty_fn_ret(method_ty) == ty::FnDiverging;\n@@ -1177,11 +1179,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(args.as_slice(), succ)\n           }\n \n-          ExprTup(ref exprs) => {\n+          ast::ExprTup(ref exprs) => {\n             self.propagate_through_exprs(exprs.as_slice(), succ)\n           }\n \n-          ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n+          ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n             let r_succ = self.propagate_through_expr(&**r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);\n@@ -1191,27 +1193,27 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**l, ln)\n           }\n \n-          ExprIndex(ref l, ref r) |\n-          ExprBinary(_, ref l, ref r) |\n-          ExprBox(ref l, ref r) => {\n+          ast::ExprIndex(ref l, ref r) |\n+          ast::ExprBinary(_, ref l, ref r) |\n+          ast::ExprBox(ref l, ref r) => {\n             let r_succ = self.propagate_through_expr(&**r, succ);\n             self.propagate_through_expr(&**l, r_succ)\n           }\n \n-          ExprSlice(ref e1, ref e2, ref e3, _) => {\n+          ast::ExprSlice(ref e1, ref e2, ref e3, _) => {\n             let succ = e3.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n             let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n             self.propagate_through_expr(&**e1, succ)\n           }\n \n-          ExprAddrOf(_, ref e) |\n-          ExprCast(ref e, _) |\n-          ExprUnary(_, ref e) |\n-          ExprParen(ref e) => {\n+          ast::ExprAddrOf(_, ref e) |\n+          ast::ExprCast(ref e, _) |\n+          ast::ExprUnary(_, ref e) |\n+          ast::ExprParen(ref e) => {\n             self.propagate_through_expr(&**e, succ)\n           }\n \n-          ExprInlineAsm(ref ia) => {\n+          ast::ExprInlineAsm(ref ia) => {\n \n             let succ = ia.outputs.iter().rev().fold(succ, |succ, &(_, ref expr, _)| {\n                 // see comment on lvalues\n@@ -1225,15 +1227,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             })\n           }\n \n-          ExprLit(..) => {\n+          ast::ExprLit(..) => {\n             succ\n           }\n \n-          ExprBlock(ref blk) => {\n+          ast::ExprBlock(ref blk) => {\n             self.propagate_through_block(&**blk, succ)\n           }\n \n-          ExprMac(..) => {\n+          ast::ExprMac(..) => {\n             self.ir.tcx.sess.span_bug(expr.span, \"unexpanded macro\");\n           }\n         }\n@@ -1293,9 +1295,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-            ExprPath(_) => succ,\n-            ExprField(ref e, _, _) => self.propagate_through_expr(&**e, succ),\n-            ExprTupField(ref e, _, _) => self.propagate_through_expr(&**e, succ),\n+            ast::ExprPath(_) => succ,\n+            ast::ExprField(ref e, _, _) => self.propagate_through_expr(&**e, succ),\n+            ast::ExprTupField(ref e, _, _) => self.propagate_through_expr(&**e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -1304,7 +1306,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n                     -> LiveNode {\n         match expr.node {\n-          ExprPath(_) => self.access_path(expr, succ, acc),\n+          ast::ExprPath(_) => self.access_path(expr, succ, acc),\n \n           // We do not track other lvalues, so just propagate through\n           // to their subcomponents.  Also, it may happen that\n@@ -1333,7 +1335,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn propagate_through_loop(&mut self,\n                               expr: &Expr,\n                               kind: LoopKind,\n-                              body: &Block,\n+                              body: &ast::Block,\n                               succ: LiveNode)\n                               -> LiveNode {\n \n@@ -1437,7 +1439,7 @@ fn check_local(this: &mut Liveness, local: &ast::Local) {\n     visit::walk_local(this, local);\n }\n \n-fn check_arm(this: &mut Liveness, arm: &Arm) {\n+fn check_arm(this: &mut Liveness, arm: &ast::Arm) {\n     // only consider the first pattern; any later patterns must have\n     // the same bindings, and we also consider the first pattern to be\n     // the \"authoritative\" set of ids\n@@ -1449,20 +1451,20 @@ fn check_arm(this: &mut Liveness, arm: &Arm) {\n \n fn check_expr(this: &mut Liveness, expr: &Expr) {\n     match expr.node {\n-      ExprAssign(ref l, ref r) => {\n+      ast::ExprAssign(ref l, ref r) => {\n         this.check_lvalue(&**l);\n         this.visit_expr(&**r);\n \n         visit::walk_expr(this, expr);\n       }\n \n-      ExprAssignOp(_, ref l, _) => {\n+      ast::ExprAssignOp(_, ref l, _) => {\n         this.check_lvalue(&**l);\n \n         visit::walk_expr(this, expr);\n       }\n \n-      ExprInlineAsm(ref ia) => {\n+      ast::ExprInlineAsm(ref ia) => {\n         for &(_, ref input) in ia.inputs.iter() {\n           this.visit_expr(&**input);\n         }\n@@ -1476,7 +1478,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n         visit::walk_expr(this, expr);\n       }\n \n-      ExprForLoop(ref pat, _, _, _) => {\n+      ast::ExprForLoop(ref pat, _, _, _) => {\n         this.pat_bindings(&**pat, |this, ln, var, sp, id| {\n             this.warn_about_unused(sp, id, ln, var);\n         });\n@@ -1485,38 +1487,40 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       }\n \n       // no correctness conditions related to liveness\n-      ExprCall(..) | ExprMethodCall(..) | ExprIf(..) | ExprMatch(..) |\n-      ExprWhile(..) | ExprLoop(..) | ExprIndex(..) | ExprField(..) |\n-      ExprTupField(..) | ExprVec(..) | ExprTup(..) | ExprBinary(..) |\n-      ExprCast(..) | ExprUnary(..) | ExprRet(..) | ExprBreak(..) |\n-      ExprAgain(..) | ExprLit(_) | ExprBlock(..) | ExprSlice(..) |\n-      ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |\n-      ExprParen(..) | ExprFnBlock(..) | ExprProc(..) | ExprUnboxedFn(..) |\n-      ExprPath(..) | ExprBox(..) => {\n+      ast::ExprCall(..) | ast::ExprMethodCall(..) | ast::ExprIf(..) |\n+      ast::ExprMatch(..) | ast::ExprWhile(..) | ast::ExprLoop(..) |\n+      ast::ExprIndex(..) | ast::ExprField(..) | ast::ExprTupField(..) |\n+      ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprBinary(..) |\n+      ast::ExprCast(..) | ast::ExprUnary(..) | ast::ExprRet(..) |\n+      ast::ExprBreak(..) | ast::ExprAgain(..) | ast::ExprLit(_) |\n+      ast::ExprBlock(..) | ast::ExprMac(..) | ast::ExprAddrOf(..) |\n+      ast::ExprStruct(..) | ast::ExprRepeat(..) | ast::ExprParen(..) |\n+      ast::ExprFnBlock(..) | ast::ExprProc(..) | ast::ExprUnboxedFn(..) |\n+      ast::ExprPath(..) | ast::ExprBox(..) | ast::ExprSlice(..) => {\n         visit::walk_expr(this, expr);\n       }\n-      ExprIfLet(..) => {\n+      ast::ExprIfLet(..) => {\n         this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n       }\n-      ExprWhileLet(..) => {\n+      ast::ExprWhileLet(..) => {\n         this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n     }\n }\n \n fn check_fn(_v: &Liveness,\n             _fk: FnKind,\n-            _decl: &FnDecl,\n-            _body: &Block,\n+            _decl: &ast::FnDecl,\n+            _body: &ast::Block,\n             _sp: Span,\n             _id: NodeId) {\n     // do not check contents of nested fns\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn fn_ret(&self, id: NodeId) -> ty::FnOutput {\n+    fn fn_ret(&self, id: NodeId) -> ty::FnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n-        match ty::get(fn_ty).sty {\n+        match fn_ty.sty {\n             ty::ty_unboxed_closure(closure_def_id, _, _) =>\n                 self.ir.tcx.unboxed_closures()\n                     .borrow()\n@@ -1534,7 +1538,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  sp: Span,\n                  _fk: FnKind,\n                  entry_ln: LiveNode,\n-                 body: &Block) {\n+                 body: &ast::Block) {\n         match self.fn_ret(id) {\n             ty::FnConverging(t_ret)\n                 if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n@@ -1545,9 +1549,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     let ends_with_stmt = match body.expr {\n                         None if body.stmts.len() > 0 =>\n                             match body.stmts.last().unwrap().node {\n-                                StmtSemi(ref e, _) => {\n-                                    let t_stmt = ty::expr_ty(self.ir.tcx, &**e);\n-                                    ty::get(t_stmt).sty == ty::get(t_ret).sty\n+                                ast::StmtSemi(ref e, _) => {\n+                                    ty::expr_ty(self.ir.tcx, &**e) == t_ret\n                                 },\n                                 _ => false\n                             },\n@@ -1581,7 +1584,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n-          ExprPath(_) => {\n+          ast::ExprPath(_) => {\n             match self.ir.tcx.def_map.borrow()[expr.id].clone() {\n               DefLocal(nid) => {\n                 // Assignment to an immutable variable or argument: only legal\n@@ -1613,7 +1616,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn warn_about_unused_args(&self, decl: &FnDecl, entry_ln: LiveNode) {\n+    fn warn_about_unused_args(&self, decl: &ast::FnDecl, entry_ln: LiveNode) {\n         for arg in decl.inputs.iter() {\n             pat_util::pat_bindings(&self.ir.tcx.def_map,\n                                    &*arg.pat,\n@@ -1628,7 +1631,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn warn_about_unused_or_dead_vars_in_pat(&mut self, pat: &Pat) {\n+    fn warn_about_unused_or_dead_vars_in_pat(&mut self, pat: &ast::Pat) {\n         self.pat_bindings(pat, |this, ln, var, sp, id| {\n             if !this.warn_about_unused(sp, id, ln, var) {\n                 this.warn_about_dead_assign(sp, id, ln, var);"}, {"sha": "93c2e8f0d9933e9bc557a56eefec09737cf65d35", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 82, "deletions": 81, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -74,7 +74,7 @@ pub use self::deref_kind::*;\n pub use self::categorization::*;\n \n use middle::def;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck;\n use util::nodemap::{DefIdMap, NodeMap};\n use util::ppaux::{ty_to_string, Repr};\n@@ -90,14 +90,14 @@ use std::cell::RefCell;\n use std::rc::Rc;\n \n #[deriving(Clone, PartialEq, Show)]\n-pub enum categorization {\n-    cat_rvalue(ty::Region),            // temporary val, argument is its scope\n+pub enum categorization<'tcx> {\n+    cat_rvalue(ty::Region),                    // temporary val, argument is its scope\n     cat_static_item,\n-    cat_upvar(Upvar),                  // upvar referenced by closure env\n-    cat_local(ast::NodeId),            // local variable\n-    cat_deref(cmt, uint, PointerKind), // deref of a ptr\n-    cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n-    cat_downcast(cmt),                 // selects a particular enum variant (*1)\n+    cat_upvar(Upvar),                          // upvar referenced by closure env\n+    cat_local(ast::NodeId),                    // local variable\n+    cat_deref(cmt<'tcx>, uint, PointerKind),   // deref of a ptr\n+    cat_interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n+    cat_downcast(cmt<'tcx>),                   // selects a particular enum variant (*1)\n \n     // (*1) downcast is only required if the enum has more than one variant\n }\n@@ -175,16 +175,16 @@ pub enum Note {\n // (`@T`). So use `cmt.ty` to find the type of the value in a consistent\n // fashion. For more details, see the method `cat_pattern`\n #[deriving(Clone, PartialEq, Show)]\n-pub struct cmt_ {\n-    pub id: ast::NodeId,          // id of expr/pat producing this value\n+pub struct cmt_<'tcx> {\n+    pub id: ast::NodeId,           // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n-    pub cat: categorization,       // categorization of expr\n+    pub cat: categorization<'tcx>, // categorization of expr\n     pub mutbl: MutabilityCategory, // mutability of expr as lvalue\n-    pub ty: ty::t,                 // type of the expr (*see WARNING above*)\n+    pub ty: Ty<'tcx>,              // type of the expr (*see WARNING above*)\n     pub note: Note,                // Note about the provenance of this cmt\n }\n \n-pub type cmt = Rc<cmt_>;\n+pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n@@ -196,8 +196,8 @@ pub enum deref_kind {\n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n-pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n-    match ty::get(t).sty {\n+pub fn opt_deref_kind(t: Ty) -> Option<deref_kind> {\n+    match t.sty {\n         ty::ty_uniq(_) |\n         ty::ty_closure(box ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n             Some(deref_ptr(OwnedPtr))\n@@ -232,7 +232,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     }\n }\n \n-pub fn deref_kind(tcx: &ty::ctxt, t: ty::t) -> deref_kind {\n+pub fn deref_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> deref_kind {\n     debug!(\"deref_kind {}\", ty_to_string(tcx, t));\n     match opt_deref_kind(t) {\n       Some(k) => k,\n@@ -285,16 +285,16 @@ pub type McResult<T> = Result<T, ()>;\n  */\n pub trait Typer<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t>;\n-    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t>;\n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>>;\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<Ty<'tcx>>;\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>;\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause;\n     fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure>>;\n+                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>>;\n }\n \n impl MutabilityCategory {\n@@ -393,26 +393,26 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         self.typer.tcx()\n     }\n \n-    fn expr_ty(&self, expr: &ast::Expr) -> McResult<ty::t> {\n+    fn expr_ty(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n         self.typer.node_ty(expr.id)\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<ty::t> {\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n         let unadjusted_ty = if_ok!(self.expr_ty(expr));\n         Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n                          self.typer.adjustments().borrow().get(&expr.id),\n                          |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n         self.typer.node_ty(id)\n     }\n \n-    fn pat_ty(&self, pat: &ast::Pat) -> McResult<ty::t> {\n+    fn pat_ty(&self, pat: &ast::Pat) -> McResult<Ty<'tcx>> {\n         self.typer.node_ty(pat.id)\n     }\n \n-    pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt> {\n+    pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n         match self.typer.adjustments().borrow().get(&expr.id) {\n             None => {\n                 // No adjustments.\n@@ -455,7 +455,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_expr_autoderefd(&self,\n                                expr: &ast::Expr,\n                                autoderefs: uint)\n-                               -> McResult<cmt> {\n+                               -> McResult<cmt<'tcx>> {\n         let mut cmt = if_ok!(self.cat_expr_unadjusted(expr));\n         debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n                autoderefs,\n@@ -466,7 +466,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         return Ok(cmt);\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt> {\n+    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n         debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr(self.tcx()));\n \n         let expr_ty = if_ok!(self.expr_ty(expr));\n@@ -546,9 +546,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_def(&self,\n                    id: ast::NodeId,\n                    span: Span,\n-                   expr_ty: ty::t,\n+                   expr_ty: Ty<'tcx>,\n                    def: def::Def)\n-                   -> McResult<cmt> {\n+                   -> McResult<cmt<'tcx>> {\n         debug!(\"cat_def: id={} expr={} def={}\",\n                id, expr_ty.repr(self.tcx()), def);\n \n@@ -585,7 +585,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n           def::DefUpvar(var_id, fn_node_id, _) => {\n               let ty = if_ok!(self.node_ty(fn_node_id));\n-              match ty::get(ty).sty {\n+              match ty.sty {\n                   ty::ty_closure(ref closure_ty) => {\n                       // Translate old closure type info into unboxed\n                       // closure kind/capture mode\n@@ -644,7 +644,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                  kind: ty::UnboxedClosureKind,\n                  mode: ast::CaptureClause,\n                  is_unboxed: bool)\n-                 -> McResult<cmt> {\n+                 -> McResult<cmt<'tcx>> {\n         // An upvar can have up to 3 components.  The base is a\n         // `cat_upvar`.  Next, we add a deref through the implicit\n         // environment pointer with an anonymous free region 'env and\n@@ -804,11 +804,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_rvalue_node(&self,\n                            id: ast::NodeId,\n                            span: Span,\n-                           expr_ty: ty::t)\n-                           -> cmt {\n+                           expr_ty: Ty<'tcx>)\n+                           -> cmt<'tcx> {\n         match self.typer.temporary_scope(id) {\n             Some(scope) => {\n-                match ty::get(expr_ty).sty {\n+                match expr_ty.sty {\n                     ty::ty_vec(_, Some(0)) => self.cat_rvalue(id, span, ty::ReStatic, expr_ty),\n                     _ => self.cat_rvalue(id, span, ty::ReScope(scope), expr_ty)\n                 }\n@@ -823,7 +823,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region,\n-                      expr_ty: ty::t) -> cmt {\n+                      expr_ty: Ty<'tcx>) -> cmt<'tcx> {\n         Rc::new(cmt_ {\n             id:cmt_id,\n             span:span,\n@@ -836,10 +836,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_field<N:ast_node>(&self,\n                                  node: &N,\n-                                 base_cmt: cmt,\n+                                 base_cmt: cmt<'tcx>,\n                                  f_name: ast::Name,\n-                                 f_ty: ty::t)\n-                                 -> cmt {\n+                                 f_ty: Ty<'tcx>)\n+                                 -> cmt<'tcx> {\n         Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n@@ -852,10 +852,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_tup_field<N:ast_node>(&self,\n                                      node: &N,\n-                                     base_cmt: cmt,\n+                                     base_cmt: cmt<'tcx>,\n                                      f_idx: uint,\n-                                     f_ty: ty::t)\n-                                     -> cmt {\n+                                     f_ty: Ty<'tcx>)\n+                                     -> cmt<'tcx> {\n         Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n@@ -868,10 +868,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n-                             base_cmt: cmt,\n+                             base_cmt: cmt<'tcx>,\n                              deref_cnt: uint,\n                              implicit: bool)\n-                             -> cmt {\n+                             -> cmt<'tcx> {\n         let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n             Some(adj) if ty::adjust_is_object(adj) => typeck::AutoObject,\n             _ if deref_cnt != 0 => typeck::AutoDeref(deref_cnt),\n@@ -907,11 +907,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     fn cat_deref_common<N:ast_node>(&self,\n                                     node: &N,\n-                                    base_cmt: cmt,\n+                                    base_cmt: cmt<'tcx>,\n                                     deref_cnt: uint,\n-                                    deref_ty: ty::t,\n+                                    deref_ty: Ty<'tcx>,\n                                     implicit: bool)\n-                                    -> cmt {\n+                                    -> cmt<'tcx> {\n         let (m, cat) = match deref_kind(self.tcx(), base_cmt.ty) {\n             deref_ptr(ptr) => {\n                 let ptr = if implicit {\n@@ -944,8 +944,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_index<N:ast_node>(&self,\n                                  elt: &N,\n-                                 mut base_cmt: cmt)\n-                                 -> cmt {\n+                                 mut base_cmt: cmt<'tcx>)\n+                                 -> cmt<'tcx> {\n         //! Creates a cmt for an indexing operation (`[]`).\n         //!\n         //! One subtle aspect of indexing that may not be\n@@ -988,11 +988,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let m = base_cmt.mutbl.inherit();\n         return interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty);\n \n-        fn interior<N: ast_node>(elt: &N,\n-                                 of_cmt: cmt,\n-                                 vec_ty: ty::t,\n-                                 mutbl: MutabilityCategory,\n-                                 element_ty: ty::t) -> cmt\n+        fn interior<'tcx, N: ast_node>(elt: &N,\n+                                       of_cmt: cmt<'tcx>,\n+                                       vec_ty: Ty<'tcx>,\n+                                       mutbl: MutabilityCategory,\n+                                       element_ty: Ty<'tcx>) -> cmt<'tcx>\n         {\n             Rc::new(cmt_ {\n                 id:elt.id(),\n@@ -1009,8 +1009,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     // underlying vec.\n     fn deref_vec<N:ast_node>(&self,\n                              elt: &N,\n-                             base_cmt: cmt)\n-                             -> cmt {\n+                             base_cmt: cmt<'tcx>)\n+                             -> cmt<'tcx> {\n         match deref_kind(self.tcx(), base_cmt.ty) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n@@ -1038,9 +1038,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     pub fn cat_slice_pattern(&self,\n-                             vec_cmt: cmt,\n+                             vec_cmt: cmt<'tcx>,\n                              slice_pat: &ast::Pat)\n-                             -> McResult<(cmt, ast::Mutability, ty::Region)> {\n+                             -> McResult<(cmt<'tcx>, ast::Mutability, ty::Region)> {\n         /*!\n          * Given a pattern P like: `[_, ..Q, _]`, where `vec_cmt` is\n          * the cmt for `P`, `slice_pat` is the pattern `Q`, returns:\n@@ -1060,7 +1060,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         fn vec_slice_info(tcx: &ty::ctxt,\n                           pat: &ast::Pat,\n-                          slice_ty: ty::t)\n+                          slice_ty: Ty)\n                           -> (ast::Mutability, ty::Region) {\n             /*!\n              * In a pattern like [a, b, ..c], normally `c` has slice type,\n@@ -1069,8 +1069,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n              * to recurse through rptrs.\n              */\n \n-            match ty::get(slice_ty).sty {\n-                ty::ty_rptr(r, ref mt) => match ty::get(mt.ty).sty {\n+            match slice_ty.sty {\n+                ty::ty_rptr(r, ref mt) => match mt.ty.sty {\n                     ty::ty_vec(_, None) => (mt.mutbl, r),\n                     _ => vec_slice_info(tcx, pat, mt.ty),\n                 },\n@@ -1085,10 +1085,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_imm_interior<N:ast_node>(&self,\n                                         node: &N,\n-                                        base_cmt: cmt,\n-                                        interior_ty: ty::t,\n+                                        base_cmt: cmt<'tcx>,\n+                                        interior_ty: Ty<'tcx>,\n                                         interior: InteriorKind)\n-                                        -> cmt {\n+                                        -> cmt<'tcx> {\n         Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n@@ -1101,9 +1101,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_downcast<N:ast_node>(&self,\n                                     node: &N,\n-                                    base_cmt: cmt,\n-                                    downcast_ty: ty::t)\n-                                    -> cmt {\n+                                    base_cmt: cmt<'tcx>,\n+                                    downcast_ty: Ty<'tcx>)\n+                                    -> cmt<'tcx> {\n         Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n@@ -1115,10 +1115,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     pub fn cat_pattern(&self,\n-                       cmt: cmt,\n+                       cmt: cmt<'tcx>,\n                        pat: &ast::Pat,\n                        op: |&MemCategorizationContext<TYPER>,\n-                            cmt,\n+                            cmt<'tcx>,\n                             &ast::Pat|)\n                        -> McResult<()> {\n         // Here, `cmt` is the categorization for the value being\n@@ -1291,7 +1291,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         Ok(())\n     }\n \n-    pub fn cmt_to_string(&self, cmt: &cmt_) -> String {\n+    pub fn cmt_to_string(&self, cmt: &cmt_<'tcx>) -> String {\n         fn upvar_to_string(upvar: &Upvar, is_copy: bool) -> String {\n             if upvar.is_unboxed {\n                 let kind = match upvar.kind {\n@@ -1376,8 +1376,8 @@ pub enum AliasableReason {\n     AliasableStaticMut(InteriorSafety),\n }\n \n-impl cmt_ {\n-    pub fn guarantor(&self) -> cmt {\n+impl<'tcx> cmt_<'tcx> {\n+    pub fn guarantor(&self) -> cmt<'tcx> {\n         //! Returns `self` after stripping away any owned pointer derefs or\n         //! interior content. The return value is basically the `cmt` which\n         //! determines how long the value in `self` remains live.\n@@ -1400,7 +1400,8 @@ impl cmt_ {\n         }\n     }\n \n-    pub fn freely_aliasable(&self, ctxt: &ty::ctxt) -> Option<AliasableReason> {\n+    pub fn freely_aliasable(&self, ctxt: &ty::ctxt<'tcx>)\n+                            -> Option<AliasableReason> {\n         /*!\n          * Returns `Some(_)` if this lvalue represents a freely aliasable\n          * pointer type.\n@@ -1455,7 +1456,7 @@ impl cmt_ {\n \n     // Digs down through one or two layers of deref and grabs the cmt\n     // for the upvar if a note indicates there is one.\n-    pub fn upvar(&self) -> Option<cmt> {\n+    pub fn upvar(&self) -> Option<cmt<'tcx>> {\n         match self.note {\n             NoteClosureEnv(..) | NoteUpvarRef(..) => {\n                 Some(match self.cat {\n@@ -1474,8 +1475,8 @@ impl cmt_ {\n     }\n }\n \n-impl Repr for cmt_ {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for cmt_<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"{{{} id:{} m:{} ty:{}}}\",\n                 self.cat.repr(tcx),\n                 self.id,\n@@ -1484,8 +1485,8 @@ impl Repr for cmt_ {\n     }\n }\n \n-impl Repr for categorization {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for categorization<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             cat_static_item |\n             cat_rvalue(..) |\n@@ -1519,7 +1520,7 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     }\n }\n \n-impl Repr for InteriorKind {\n+impl<'tcx> Repr<'tcx> for InteriorKind {\n     fn repr(&self, _tcx: &ty::ctxt) -> String {\n         match *self {\n             InteriorField(NamedField(fld)) => {\n@@ -1531,10 +1532,10 @@ impl Repr for InteriorKind {\n     }\n }\n \n-fn element_kind(t: ty::t) -> ElementKind {\n-    match ty::get(t).sty {\n+fn element_kind(t: Ty) -> ElementKind {\n+    match t.sty {\n         ty::ty_rptr(_, ty::mt{ty, ..}) |\n-        ty::ty_uniq(ty) => match ty::get(ty).sty {\n+        ty::ty_uniq(ty) => match ty.sty {\n             ty::ty_vec(_, None) => VecElement,\n             _ => OtherElement\n         },"}, {"sha": "a51956797cad063be9f3592af784f62a505df790", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -13,39 +13,43 @@ use middle::resolve;\n use middle::ty;\n use util::nodemap::FnvHashMap;\n \n-use syntax::ast::*;\n+use syntax::ast;\n use syntax::ast_util::{walk_pat};\n use syntax::codemap::{Span, DUMMY_SP};\n \n-pub type PatIdMap = FnvHashMap<Ident, NodeId>;\n+pub type PatIdMap = FnvHashMap<ast::Ident, ast::NodeId>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n-pub fn pat_id_map(dm: &resolve::DefMap, pat: &Pat) -> PatIdMap {\n+pub fn pat_id_map(dm: &resolve::DefMap, pat: &ast::Pat) -> PatIdMap {\n     let mut map = FnvHashMap::new();\n     pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n         map.insert(path1.node, p_id);\n     });\n     map\n }\n \n-pub fn pat_is_refutable(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_refutable(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        PatLit(_) | PatRange(_, _) => true,\n-        PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n+        ast::PatLit(_) | ast::PatRange(_, _) => true,\n+        ast::PatEnum(_, _) |\n+        ast::PatIdent(_, _, None) |\n+        ast::PatStruct(..) => {\n             match dm.borrow().get(&pat.id) {\n                 Some(&DefVariant(..)) => true,\n                 _ => false\n             }\n         }\n-        PatVec(_, _, _) => true,\n+        ast::PatVec(_, _, _) => true,\n         _ => false\n     }\n }\n \n-pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n+        ast::PatEnum(_, _) |\n+        ast::PatIdent(_, _, None) |\n+        ast::PatStruct(..) => {\n             match dm.borrow().get(&pat.id) {\n                 Some(&DefVariant(..)) | Some(&DefStruct(..)) => true,\n                 _ => false\n@@ -55,9 +59,9 @@ pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_const(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_const(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        PatIdent(_, _, None) | PatEnum(..) => {\n+        ast::PatIdent(_, _, None) | ast::PatEnum(..) => {\n             match dm.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) => true,\n                 _ => false\n@@ -67,32 +71,32 @@ pub fn pat_is_const(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_binding(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        PatIdent(..) => {\n+        ast::PatIdent(..) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n             !pat_is_const(dm, pat)\n         }\n         _ => false\n     }\n }\n \n-pub fn pat_is_binding_or_wild(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_binding_or_wild(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        PatIdent(..) => pat_is_binding(dm, pat),\n-        PatWild(_) => true,\n+        ast::PatIdent(..) => pat_is_binding(dm, pat),\n+        ast::PatWild(_) => true,\n         _ => false\n     }\n }\n \n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n pub fn pat_bindings(dm: &resolve::DefMap,\n-                    pat: &Pat,\n-                    it: |BindingMode, NodeId, Span, &SpannedIdent|) {\n+                    pat: &ast::Pat,\n+                    it: |ast::BindingMode, ast::NodeId, Span, &ast::SpannedIdent|) {\n     walk_pat(pat, |p| {\n         match p.node {\n-          PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n+          ast::PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);\n           }\n           _ => {}\n@@ -103,7 +107,7 @@ pub fn pat_bindings(dm: &resolve::DefMap,\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_contains_bindings(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n     let mut contains_bindings = false;\n     walk_pat(pat, |p| {\n         if pat_is_binding(dm, p) {\n@@ -116,9 +120,9 @@ pub fn pat_contains_bindings(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     contains_bindings\n }\n \n-pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Ident> {\n+pub fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Ident> {\n     match pat.node {\n-        PatIdent(BindByValue(_), ref path1, None) => {\n+        ast::PatIdent(ast::BindByValue(_), ref path1, None) => {\n             Some(&path1.node)\n         }\n         _ => {\n@@ -127,12 +131,12 @@ pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Ident> {\n     }\n }\n \n-pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n-    ty::with_path(tcx, id, |mut path| Path {\n+pub fn def_to_path(tcx: &ty::ctxt, id: ast::DefId) -> ast::Path {\n+    ty::with_path(tcx, id, |mut path| ast::Path {\n         global: false,\n-        segments: path.last().map(|elem| PathSegment {\n-            identifier: Ident::new(elem.name()),\n-            parameters: PathParameters::none(),\n+        segments: path.last().map(|elem| ast::PathSegment {\n+            identifier: ast::Ident::new(elem.name()),\n+            parameters: ast::PathParameters::none(),\n         }).into_iter().collect(),\n         span: DUMMY_SP,\n     })"}, {"sha": "c2835ba5647e8a91ab1c79b20c1c6d2164045899", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -19,7 +19,7 @@ use std::mem::replace;\n use metadata::csearch;\n use middle::def;\n use middle::resolve;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::{MethodCall, MethodMap, MethodOrigin, MethodParam, MethodTypeParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n use util::nodemap::{NodeMap, NodeSet};\n@@ -32,7 +32,7 @@ use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-type Context<'a> = (&'a MethodMap, &'a resolve::ExportMap2);\n+type Context<'a, 'tcx> = (&'a MethodMap<'tcx>, &'a resolve::ExportMap2);\n \n /// A set of AST nodes exported by the crate.\n pub type ExportedItems = NodeSet;\n@@ -667,7 +667,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         }\n \n         let struct_type = ty::lookup_item_type(self.tcx, id).ty;\n-        let struct_desc = match ty::get(struct_type).sty {\n+        let struct_desc = match struct_type.sty {\n             ty::ty_struct(_, _) =>\n                 format!(\"struct `{}`\", ty::item_path_str(self.tcx, id)),\n             // struct variant fields have inherited visibility\n@@ -837,15 +837,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprField(ref base, ident, _) => {\n-                match ty::get(ty::expr_ty_adjusted(self.tcx, &**base)).sty {\n+                match ty::expr_ty_adjusted(self.tcx, &**base).sty {\n                     ty::ty_struct(id, _) => {\n                         self.check_field(expr.span, id, NamedField(ident.node));\n                     }\n                     _ => {}\n                 }\n             }\n             ast::ExprTupField(ref base, idx, _) => {\n-                match ty::get(ty::expr_ty_adjusted(self.tcx, &**base)).sty {\n+                match ty::expr_ty_adjusted(self.tcx, &**base).sty {\n                     ty::ty_struct(id, _) => {\n                         self.check_field(expr.span, id, UnnamedField(idx.node));\n                     }\n@@ -867,7 +867,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ast::ExprStruct(_, ref fields, _) => {\n-                match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n+                match ty::expr_ty(self.tcx, expr).sty {\n                     ty::ty_struct(id, _) => {\n                         for field in (*fields).iter() {\n                             self.check_field(expr.span, id,\n@@ -976,7 +976,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n         match pattern.node {\n             ast::PatStruct(_, ref fields, _) => {\n-                match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n+                match ty::pat_ty(self.tcx, pattern).sty {\n                     ty::ty_struct(id, _) => {\n                         for field in fields.iter() {\n                             self.check_field(pattern.span, id,\n@@ -1007,7 +1007,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             // Patterns which bind no fields are allowable (the path is check\n             // elsewhere).\n             ast::PatEnum(_, Some(ref fields)) => {\n-                match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n+                match ty::pat_ty(self.tcx, pattern).sty {\n                     ty::ty_struct(id, _) => {\n                         for (i, field) in fields.iter().enumerate() {\n                             match field.node {"}, {"sha": "0c0861eda3e7a997128152d8655cdbedc41f8328", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -23,7 +23,7 @@ Most of the documentation on regions can be found in\n \n use session::Session;\n use middle::ty::{FreeRegion};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n use util::common::can_reach;\n "}, {"sha": "bac417c8218a4383ab0f0bce396c3119bb6d5af9", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -13,7 +13,7 @@\n pub use self::ParamSpace::*;\n pub use self::RegionSubsts::*;\n \n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n@@ -31,8 +31,8 @@ use syntax::codemap::{Span, DUMMY_SP};\n  * `ParamSpace`).\n  */\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n-pub struct Substs {\n-    pub types: VecPerParamSpace<ty::t>,\n+pub struct Substs<'tcx> {\n+    pub types: VecPerParamSpace<Ty<'tcx>>,\n     pub regions: RegionSubsts,\n }\n \n@@ -46,45 +46,45 @@ pub enum RegionSubsts {\n     NonerasedRegions(VecPerParamSpace<ty::Region>)\n }\n \n-impl Substs {\n-    pub fn new(t: VecPerParamSpace<ty::t>,\n+impl<'tcx> Substs<'tcx> {\n+    pub fn new(t: VecPerParamSpace<Ty<'tcx>>,\n                r: VecPerParamSpace<ty::Region>)\n-               -> Substs\n+               -> Substs<'tcx>\n     {\n         Substs { types: t, regions: NonerasedRegions(r) }\n     }\n \n-    pub fn new_type(t: Vec<ty::t>,\n+    pub fn new_type(t: Vec<Ty<'tcx>>,\n                     r: Vec<ty::Region>)\n-                    -> Substs\n+                    -> Substs<'tcx>\n     {\n         Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new(), Vec::new()),\n                     VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n \n-    pub fn new_trait(t: Vec<ty::t>,\n+    pub fn new_trait(t: Vec<Ty<'tcx>>,\n                      r: Vec<ty::Region>,\n-                     a: Vec<ty::t>,\n-                     s: ty::t)\n-                    -> Substs\n+                     a: Vec<Ty<'tcx>>,\n+                     s: Ty<'tcx>)\n+                    -> Substs<'tcx>\n     {\n         Substs::new(VecPerParamSpace::new(t, vec!(s), a, Vec::new()),\n                     VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n \n-    pub fn erased(t: VecPerParamSpace<ty::t>) -> Substs\n+    pub fn erased(t: VecPerParamSpace<Ty<'tcx>>) -> Substs<'tcx>\n     {\n         Substs { types: t, regions: ErasedRegions }\n     }\n \n-    pub fn empty() -> Substs {\n+    pub fn empty() -> Substs<'tcx> {\n         Substs {\n             types: VecPerParamSpace::empty(),\n             regions: NonerasedRegions(VecPerParamSpace::empty()),\n         }\n     }\n \n-    pub fn trans_empty() -> Substs {\n+    pub fn trans_empty() -> Substs<'tcx> {\n         Substs {\n             types: VecPerParamSpace::empty(),\n             regions: ErasedRegions\n@@ -111,18 +111,18 @@ impl Substs {\n         }\n     }\n \n-    pub fn self_ty(&self) -> Option<ty::t> {\n+pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n         self.types.get_self().map(|&t| t)\n     }\n \n-    pub fn with_self_ty(&self, self_ty: ty::t) -> Substs {\n+    pub fn with_self_ty(&self, self_ty: Ty<'tcx>) -> Substs<'tcx> {\n         assert!(self.self_ty().is_none());\n         let mut s = (*self).clone();\n         s.types.push(SelfSpace, self_ty);\n         s\n     }\n \n-    pub fn erase_regions(self) -> Substs {\n+    pub fn erase_regions(self) -> Substs<'tcx> {\n         let Substs { types, regions: _ } = self;\n         Substs { types: types, regions: ErasedRegions }\n     }\n@@ -154,9 +154,9 @@ impl Substs {\n     }\n \n     pub fn with_method(self,\n-                       m_types: Vec<ty::t>,\n+                       m_types: Vec<Ty<'tcx>>,\n                        m_regions: Vec<ty::Region>)\n-                       -> Substs\n+                       -> Substs<'tcx>\n     {\n         let Substs { types, regions } = self;\n         let types = types.with_vec(FnSpace, m_types);\n@@ -536,21 +536,21 @@ impl<'a,T> Iterator<(ParamSpace, uint, &'a T)> for EnumeratedItems<'a,T> {\n // `foo`. Or use `foo.subst_spanned(tcx, substs, Some(span))` when\n // there is more information available (for better errors).\n \n-pub trait Subst {\n-    fn subst(&self, tcx: &ty::ctxt, substs: &Substs) -> Self {\n+pub trait Subst<'tcx> {\n+    fn subst(&self, tcx: &ty::ctxt<'tcx>, substs: &Substs<'tcx>) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &Substs,\n+    fn subst_spanned(&self, tcx: &ty::ctxt<'tcx>,\n+                     substs: &Substs<'tcx>,\n                      span: Option<Span>)\n                      -> Self;\n }\n \n-impl<T:TypeFoldable> Subst for T {\n+impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n     fn subst_spanned(&self,\n-                     tcx: &ty::ctxt,\n-                     substs: &Substs,\n+                     tcx: &ty::ctxt<'tcx>,\n+                     substs: &Substs<'tcx>,\n                      span: Option<Span>)\n                      -> T\n     {\n@@ -569,13 +569,13 @@ impl<T:TypeFoldable> Subst for T {\n \n struct SubstFolder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    substs: &'a Substs,\n+    substs: &'a Substs<'tcx>,\n \n     // The location for which the substitution is performed, if available.\n     span: Option<Span>,\n \n     // The root type that is being substituted, if available.\n-    root_ty: Option<ty::t>,\n+    root_ty: Option<Ty<'tcx>>,\n \n     // Depth of type stack\n     ty_stack_depth: uint,\n@@ -629,7 +629,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if !ty::type_needs_subst(t) {\n             return t;\n         }\n@@ -641,7 +641,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         }\n         self.ty_stack_depth += 1;\n \n-        let t1 = match ty::get(t).sty {\n+        let t1 = match t.sty {\n             ty::ty_param(p) => {\n                 self.ty_for_param(p, t)\n             }\n@@ -661,7 +661,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n }\n \n impl<'a,'tcx> SubstFolder<'a,'tcx> {\n-    fn ty_for_param(&self, p: ty::ParamTy, source_ty: ty::t) -> ty::t {\n+    fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n         let opt_ty = self.substs.types.opt_get(p.space, p.idx);\n         let ty = match opt_ty {\n@@ -684,7 +684,7 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n         self.shift_regions_through_binders(ty)\n     }\n \n-    fn shift_regions_through_binders(&self, ty: ty::t) -> ty::t {\n+    fn shift_regions_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         /*!\n          * It is sometimes necessary to adjust the debruijn indices\n          * during substitution. This occurs when we are substituting a"}, {"sha": "c84a2a0d11e6b3b01a3c20a67899e21cb945ee39", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -16,7 +16,7 @@ use super::util;\n \n use middle::subst;\n use middle::subst::Subst;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::{mod, InferCtxt};\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n@@ -76,13 +76,10 @@ pub fn impl_is_local(tcx: &ty::ctxt,\n     trait_ref.input_types().iter().any(|&t| ty_is_local(tcx, t))\n }\n \n-pub fn ty_is_local(tcx: &ty::ctxt,\n-                   ty: ty::t)\n-                   -> bool\n-{\n+pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     debug!(\"ty_is_local({})\", ty.repr(tcx));\n \n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_bool |\n         ty::ty_char |\n         ty::ty_int(..) |"}, {"sha": "5b8edacb28d67e775484c55fcc2aeda262011132", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -31,39 +31,39 @@ use super::select::SelectionContext;\n  * method `select_all_or_error` can be used to report any remaining\n  * ambiguous cases as errors.\n  */\n-pub struct FulfillmentContext {\n+pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n-    trait_obligations: Vec<Obligation>,\n+    trait_obligations: Vec<Obligation<'tcx>>,\n \n     // Remembers the count of trait obligations that we have already\n     // attempted to select. This is used to avoid repeating work\n     // when `select_new_obligations` is called.\n     attempted_mark: uint,\n }\n \n-impl FulfillmentContext {\n-    pub fn new() -> FulfillmentContext {\n+impl<'tcx> FulfillmentContext<'tcx> {\n+    pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             trait_obligations: Vec::new(),\n             attempted_mark: 0,\n         }\n     }\n \n     pub fn register_obligation(&mut self,\n-                               tcx: &ty::ctxt,\n-                               obligation: Obligation)\n+                               tcx: &ty::ctxt<'tcx>,\n+                               obligation: Obligation<'tcx>)\n     {\n         debug!(\"register_obligation({})\", obligation.repr(tcx));\n         assert!(!obligation.trait_ref.has_escaping_regions());\n         self.trait_obligations.push(obligation);\n     }\n \n-    pub fn select_all_or_error<'a,'tcx>(&mut self,\n-                                        infcx: &InferCtxt<'a,'tcx>,\n-                                        param_env: &ty::ParameterEnvironment,\n-                                        typer: &Typer<'tcx>)\n-                                        -> Result<(),Vec<FulfillmentError>>\n+    pub fn select_all_or_error<'a>(&mut self,\n+                                   infcx: &InferCtxt<'a,'tcx>,\n+                                   param_env: &ty::ParameterEnvironment<'tcx>,\n+                                   typer: &Typer<'tcx>)\n+                                   -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         try!(self.select_where_possible(infcx, param_env, typer));\n \n@@ -81,11 +81,11 @@ impl FulfillmentContext {\n         }\n     }\n \n-    pub fn select_new_obligations<'a,'tcx>(&mut self,\n-                                           infcx: &InferCtxt<'a,'tcx>,\n-                                           param_env: &ty::ParameterEnvironment,\n-                                           typer: &Typer<'tcx>)\n-                                           -> Result<(),Vec<FulfillmentError>>\n+    pub fn select_new_obligations<'a>(&mut self,\n+                                      infcx: &InferCtxt<'a,'tcx>,\n+                                      param_env: &ty::ParameterEnvironment<'tcx>,\n+                                      typer: &Typer<'tcx>)\n+                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         /*!\n          * Attempts to select obligations that were registered since\n@@ -99,20 +99,20 @@ impl FulfillmentContext {\n         self.select(&mut selcx, true)\n     }\n \n-    pub fn select_where_possible<'a,'tcx>(&mut self,\n-                                          infcx: &InferCtxt<'a,'tcx>,\n-                                          param_env: &ty::ParameterEnvironment,\n-                                          typer: &Typer<'tcx>)\n-                                          -> Result<(),Vec<FulfillmentError>>\n+    pub fn select_where_possible<'a>(&mut self,\n+                                     infcx: &InferCtxt<'a,'tcx>,\n+                                     param_env: &ty::ParameterEnvironment<'tcx>,\n+                                     typer: &Typer<'tcx>)\n+                                     -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx, param_env, typer);\n         self.select(&mut selcx, false)\n     }\n \n-    fn select(&mut self,\n-              selcx: &mut SelectionContext,\n-              only_new_obligations: bool)\n-              -> Result<(),Vec<FulfillmentError>>\n+    fn select<'a>(&mut self,\n+                  selcx: &mut SelectionContext<'a, 'tcx>,\n+                  only_new_obligations: bool)\n+                  -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         /*!\n          * Attempts to select obligations using `selcx`. If"}, {"sha": "c5eacf35da92fd6e09bed8d9b46d2836fe8f25d4", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 61, "deletions": 57, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -19,7 +19,7 @@ pub use self::ObligationCauseCode::*;\n \n use middle::mem_categorization::Typer;\n use middle::subst;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::InferCtxt;\n use std::rc::Rc;\n use std::slice::Items;\n@@ -50,23 +50,23 @@ mod util;\n  * scope. The eventual result is usually a `Selection` (defined below).\n  */\n #[deriving(Clone)]\n-pub struct Obligation {\n-    pub cause: ObligationCause,\n+pub struct Obligation<'tcx> {\n+    pub cause: ObligationCause<'tcx>,\n     pub recursion_depth: uint,\n-    pub trait_ref: Rc<ty::TraitRef>,\n+    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n }\n \n /**\n  * Why did we incur this obligation? Used for error reporting.\n  */\n #[deriving(Clone)]\n-pub struct ObligationCause {\n+pub struct ObligationCause<'tcx> {\n     pub span: Span,\n-    pub code: ObligationCauseCode\n+    pub code: ObligationCauseCode<'tcx>\n }\n \n #[deriving(Clone)]\n-pub enum ObligationCauseCode {\n+pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n \n@@ -75,7 +75,7 @@ pub enum ObligationCauseCode {\n     ItemObligation(ast::DefId),\n \n     /// Obligation incurred due to an object cast.\n-    ObjectCastObligation(/* Object type */ ty::t),\n+    ObjectCastObligation(/* Object type */ Ty<'tcx>),\n \n     /// To implement drop, type must be sendable.\n     DropTrait,\n@@ -99,25 +99,25 @@ pub enum ObligationCauseCode {\n #[deriving(Clone,Show)]\n pub struct ErrorReported;\n \n-pub type Obligations = subst::VecPerParamSpace<Obligation>;\n+pub type Obligations<'tcx> = subst::VecPerParamSpace<Obligation<'tcx>>;\n \n-pub type Selection = Vtable<Obligation>;\n+pub type Selection<'tcx> = Vtable<'tcx, Obligation<'tcx>>;\n \n #[deriving(Clone,Show)]\n-pub enum SelectionError {\n+pub enum SelectionError<'tcx> {\n     Unimplemented,\n     Overflow,\n-    OutputTypeParameterMismatch(Rc<ty::TraitRef>, ty::type_err)\n+    OutputTypeParameterMismatch(Rc<ty::TraitRef<'tcx>>, ty::type_err<'tcx>)\n }\n \n-pub struct FulfillmentError {\n-    pub obligation: Obligation,\n-    pub code: FulfillmentErrorCode\n+pub struct FulfillmentError<'tcx> {\n+    pub obligation: Obligation<'tcx>,\n+    pub code: FulfillmentErrorCode<'tcx>\n }\n \n #[deriving(Clone)]\n-pub enum FulfillmentErrorCode {\n-    CodeSelectionError(SelectionError),\n+pub enum FulfillmentErrorCode<'tcx> {\n+    CodeSelectionError(SelectionError<'tcx>),\n     CodeAmbiguity,\n }\n \n@@ -130,7 +130,7 @@ pub enum FulfillmentErrorCode {\n  *   to inconclusive type inference.\n  * - `Err(e)`: error `e` occurred\n  */\n-pub type SelectionResult<T> = Result<Option<T>, SelectionError>;\n+pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n \n /**\n  * Given the successful resolution of an obligation, the `Vtable`\n@@ -173,19 +173,19 @@ pub type SelectionResult<T> = Result<Option<T>, SelectionError>;\n  * See explanation on `VtableImplData`.\n  */\n #[deriving(Show,Clone)]\n-pub enum Vtable<N> {\n+pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n-    VtableImpl(VtableImplData<N>),\n+    VtableImpl(VtableImplData<'tcx, N>),\n \n     /// Vtable automatically generated for an unboxed closure. The def\n     /// ID is the ID of the closure expression. This is a `VtableImpl`\n     /// in spirit, but the impl is generated by the compiler and does\n     /// not appear in the source.\n-    VtableUnboxedClosure(ast::DefId, subst::Substs),\n+    VtableUnboxedClosure(ast::DefId, subst::Substs<'tcx>),\n \n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter.\n-    VtableParam(VtableParamData),\n+    VtableParam(VtableParamData<'tcx>),\n \n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n@@ -204,9 +204,9 @@ pub enum Vtable<N> {\n  * impl, and nested obligations are satisfied later.\n  */\n #[deriving(Clone)]\n-pub struct VtableImplData<N> {\n+pub struct VtableImplData<'tcx, N> {\n     pub impl_def_id: ast::DefId,\n-    pub substs: subst::Substs,\n+    pub substs: subst::Substs<'tcx>,\n     pub nested: subst::VecPerParamSpace<N>\n }\n \n@@ -221,18 +221,19 @@ pub struct VtableBuiltinData<N> {\n  * on an instance of `T`, the vtable would be of type `VtableParam`.\n  */\n #[deriving(PartialEq,Eq,Clone)]\n-pub struct VtableParamData {\n+pub struct VtableParamData<'tcx> {\n     // In the above example, this would `Eq`\n-    pub bound: Rc<ty::TraitRef>,\n+    pub bound: Rc<ty::TraitRef<'tcx>>,\n }\n \n pub fn select_inherent_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                     param_env: &ty::ParameterEnvironment,\n+                                     param_env: &ty::ParameterEnvironment<'tcx>,\n                                      typer: &Typer<'tcx>,\n-                                     cause: ObligationCause,\n+                                     cause: ObligationCause<'tcx>,\n                                      impl_def_id: ast::DefId,\n-                                     self_ty: ty::t)\n-                                     -> SelectionResult<VtableImplData<Obligation>>\n+                                     self_ty: Ty<'tcx>)\n+                                     -> SelectionResult<'tcx,\n+                                            VtableImplData<'tcx, Obligation<'tcx>>>\n {\n     /*!\n      * Matches the self type of the inherent impl `impl_def_id`\n@@ -281,11 +282,11 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n     coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)\n }\n \n-pub fn obligations_for_generics(tcx: &ty::ctxt,\n-                                cause: ObligationCause,\n-                                generic_bounds: &ty::GenericBounds,\n-                                type_substs: &subst::VecPerParamSpace<ty::t>)\n-                                -> subst::VecPerParamSpace<Obligation>\n+pub fn obligations_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      cause: ObligationCause<'tcx>,\n+                                      generic_bounds: &ty::GenericBounds<'tcx>,\n+                                      type_substs: &subst::VecPerParamSpace<Ty<'tcx>>)\n+                                      -> subst::VecPerParamSpace<Obligation<'tcx>>\n {\n     /*!\n      * Given generic bounds from an impl like:\n@@ -305,46 +306,48 @@ pub fn obligations_for_generics(tcx: &ty::ctxt,\n     util::obligations_for_generics(tcx, cause, 0, generic_bounds, type_substs)\n }\n \n-pub fn obligation_for_builtin_bound(tcx: &ty::ctxt,\n-                                    cause: ObligationCause,\n-                                    source_ty: ty::t,\n-                                    builtin_bound: ty::BuiltinBound)\n-                                    -> Result<Obligation, ErrorReported>\n+pub fn obligation_for_builtin_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                          cause: ObligationCause<'tcx>,\n+                                          source_ty: Ty<'tcx>,\n+                                          builtin_bound: ty::BuiltinBound)\n+                                          -> Result<Obligation<'tcx>, ErrorReported>\n {\n     util::obligation_for_builtin_bound(tcx, cause, builtin_bound, 0, source_ty)\n }\n \n-impl Obligation {\n-    pub fn new(cause: ObligationCause, trait_ref: Rc<ty::TraitRef>) -> Obligation {\n+impl<'tcx> Obligation<'tcx> {\n+    pub fn new(cause: ObligationCause<'tcx>, trait_ref: Rc<ty::TraitRef<'tcx>>)\n+               -> Obligation<'tcx> {\n         Obligation { cause: cause,\n                      recursion_depth: 0,\n                      trait_ref: trait_ref }\n     }\n \n-    pub fn misc(span: Span, trait_ref: Rc<ty::TraitRef>) -> Obligation {\n+    pub fn misc(span: Span, trait_ref: Rc<ty::TraitRef<'tcx>>) -> Obligation<'tcx> {\n         Obligation::new(ObligationCause::misc(span), trait_ref)\n     }\n \n-    pub fn self_ty(&self) -> ty::t {\n+    pub fn self_ty(&self) -> Ty<'tcx> {\n         self.trait_ref.self_ty()\n     }\n }\n \n-impl ObligationCause {\n-    pub fn new(span: Span, code: ObligationCauseCode) -> ObligationCause {\n+impl<'tcx> ObligationCause<'tcx> {\n+    pub fn new(span: Span, code: ObligationCauseCode<'tcx>)\n+               -> ObligationCause<'tcx> {\n         ObligationCause { span: span, code: code }\n     }\n \n-    pub fn misc(span: Span) -> ObligationCause {\n+    pub fn misc(span: Span) -> ObligationCause<'tcx> {\n         ObligationCause { span: span, code: MiscObligation }\n     }\n \n-    pub fn dummy() -> ObligationCause {\n+    pub fn dummy() -> ObligationCause<'tcx> {\n         ObligationCause { span: DUMMY_SP, code: MiscObligation }\n     }\n }\n \n-impl<N> Vtable<N> {\n+impl<'tcx, N> Vtable<'tcx, N> {\n     pub fn iter_nested(&self) -> Items<N> {\n         match *self {\n             VtableImpl(ref i) => i.iter_nested(),\n@@ -354,7 +357,7 @@ impl<N> Vtable<N> {\n         }\n     }\n \n-    pub fn map_nested<M>(&self, op: |&N| -> M) -> Vtable<M> {\n+    pub fn map_nested<M>(&self, op: |&N| -> M) -> Vtable<'tcx, M> {\n         match *self {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n             VtableUnboxedClosure(d, ref s) => VtableUnboxedClosure(d, s.clone()),\n@@ -363,7 +366,7 @@ impl<N> Vtable<N> {\n         }\n     }\n \n-    pub fn map_move_nested<M>(self, op: |N| -> M) -> Vtable<M> {\n+    pub fn map_move_nested<M>(self, op: |N| -> M) -> Vtable<'tcx, M> {\n         match self {\n             VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n             VtableUnboxedClosure(d, s) => VtableUnboxedClosure(d, s),\n@@ -373,14 +376,14 @@ impl<N> Vtable<N> {\n     }\n }\n \n-impl<N> VtableImplData<N> {\n+impl<'tcx, N> VtableImplData<'tcx, N> {\n     pub fn iter_nested(&self) -> Items<N> {\n         self.nested.iter()\n     }\n \n     pub fn map_nested<M>(&self,\n                          op: |&N| -> M)\n-                         -> VtableImplData<M>\n+                         -> VtableImplData<'tcx, M>\n     {\n         VtableImplData {\n             impl_def_id: self.impl_def_id,\n@@ -389,7 +392,8 @@ impl<N> VtableImplData<N> {\n         }\n     }\n \n-    pub fn map_move_nested<M>(self, op: |N| -> M) -> VtableImplData<M> {\n+    pub fn map_move_nested<M>(self, op: |N| -> M)\n+                              -> VtableImplData<'tcx, M> {\n         let VtableImplData { impl_def_id, substs, nested } = self;\n         VtableImplData {\n             impl_def_id: impl_def_id,\n@@ -420,9 +424,9 @@ impl<N> VtableBuiltinData<N> {\n     }\n }\n \n-impl FulfillmentError {\n-    fn new(obligation: Obligation, code: FulfillmentErrorCode)\n-           -> FulfillmentError\n+impl<'tcx> FulfillmentError<'tcx> {\n+    fn new(obligation: Obligation<'tcx>, code: FulfillmentErrorCode<'tcx>)\n+           -> FulfillmentError<'tcx>\n     {\n         FulfillmentError { obligation: obligation, code: code }\n     }"}, {"sha": "b884cb535d7a5de9488ac78b33eb4ca2be92fc6e", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 165, "deletions": 160, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -30,7 +30,7 @@ use super::{util};\n use middle::fast_reject;\n use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer;\n use middle::typeck::infer::{InferCtxt, TypeSkolemizer};\n use middle::ty_fold::TypeFoldable;\n@@ -42,7 +42,7 @@ use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    param_env: &'cx ty::ParameterEnvironment,\n+    param_env: &'cx ty::ParameterEnvironment<'tcx>,\n     typer: &'cx Typer<'tcx>+'cx,\n \n     /// Skolemizer used specifically for skolemizing entries on the\n@@ -70,18 +70,19 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n }\n \n // A stack that walks back up the stack frame.\n-struct ObligationStack<'prev> {\n-    obligation: &'prev Obligation,\n+struct ObligationStack<'prev, 'tcx: 'prev> {\n+    obligation: &'prev Obligation<'tcx>,\n \n     /// Trait ref from `obligation` but skolemized with the\n     /// selection-context's skolemizer. Used to check for recursion.\n-    skol_trait_ref: Rc<ty::TraitRef>,\n+    skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n-    previous: Option<&'prev ObligationStack<'prev>>\n+    previous: Option<&'prev ObligationStack<'prev, 'tcx>>\n }\n \n-pub struct SelectionCache {\n-    hashmap: RefCell<HashMap<Rc<ty::TraitRef>, SelectionResult<Candidate>>>,\n+pub struct SelectionCache<'tcx> {\n+    hashmap: RefCell<HashMap<Rc<ty::TraitRef<'tcx>>,\n+                             SelectionResult<'tcx, Candidate<'tcx>>>>,\n }\n \n pub enum MethodMatchResult {\n@@ -128,21 +129,21 @@ pub enum MethodMatchedData {\n  * parameters) that would have to be inferred from the impl.\n  */\n #[deriving(PartialEq,Eq,Show,Clone)]\n-enum Candidate {\n+enum Candidate<'tcx> {\n     BuiltinCandidate(ty::BuiltinBound),\n-    ParamCandidate(VtableParamData),\n+    ParamCandidate(VtableParamData<'tcx>),\n     ImplCandidate(ast::DefId),\n-    UnboxedClosureCandidate(/* closure */ ast::DefId, Substs),\n+    UnboxedClosureCandidate(/* closure */ ast::DefId, Substs<'tcx>),\n     ErrorCandidate,\n }\n \n-struct CandidateSet {\n-    vec: Vec<Candidate>,\n+struct CandidateSet<'tcx> {\n+    vec: Vec<Candidate<'tcx>>,\n     ambiguous: bool\n }\n \n-enum BuiltinBoundConditions {\n-    If(Vec<ty::t>),\n+enum BuiltinBoundConditions<'tcx> {\n+    If(Vec<Ty<'tcx>>),\n     ParameterBuiltin,\n     AmbiguousBuiltin\n }\n@@ -156,7 +157,7 @@ enum EvaluationResult {\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-               param_env: &'cx ty::ParameterEnvironment,\n+               param_env: &'cx ty::ParameterEnvironment<'tcx>,\n                typer: &'cx Typer<'tcx>)\n                -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n@@ -169,7 +170,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-                      param_env: &'cx ty::ParameterEnvironment,\n+                      param_env: &'cx ty::ParameterEnvironment<'tcx>,\n                       typer: &'cx Typer<'tcx>)\n                       -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n@@ -200,7 +201,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     //    is `Vec<Foo>:Iterable<Bar>`, but the impl specifies\n     //    `impl<T> Iterable<T> for Vec<T>`, than an error would result.\n \n-    pub fn select(&mut self, obligation: &Obligation) -> SelectionResult<Selection> {\n+    pub fn select(&mut self, obligation: &Obligation<'tcx>)\n+                  -> SelectionResult<'tcx, Selection<'tcx>> {\n         /*!\n          * Evaluates whether the obligation can be satisfied. Returns\n          * an indication of whether the obligation can be satisfied\n@@ -220,9 +222,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     pub fn select_inherent_impl(&mut self,\n                                 impl_def_id: ast::DefId,\n-                                obligation_cause: ObligationCause,\n-                                obligation_self_ty: ty::t)\n-                                -> SelectionResult<VtableImplData<Obligation>>\n+                                obligation_cause: ObligationCause<'tcx>,\n+                                obligation_self_ty: Ty<'tcx>)\n+                                -> SelectionResult<'tcx, VtableImplData<'tcx, Obligation<'tcx>>>\n     {\n         debug!(\"select_inherent_impl(impl_def_id={}, obligation_self_ty={})\",\n                impl_def_id.repr(self.tcx()),\n@@ -252,7 +254,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // we can be sure it does not.\n \n     pub fn evaluate_obligation(&mut self,\n-                               obligation: &Obligation)\n+                               obligation: &Obligation<'tcx>)\n                                -> bool\n     {\n         /*!\n@@ -268,11 +270,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.evaluate_stack(&stack).may_apply()\n     }\n \n-    fn evaluate_builtin_bound_recursively(&mut self,\n-                                          bound: ty::BuiltinBound,\n-                                          previous_stack: &ObligationStack,\n-                                          ty: ty::t)\n-                                          -> EvaluationResult\n+    fn evaluate_builtin_bound_recursively<'o>(&mut self,\n+                                              bound: ty::BuiltinBound,\n+                                              previous_stack: &ObligationStack<'o, 'tcx>,\n+                                              ty: Ty<'tcx>)\n+                                              -> EvaluationResult\n     {\n         let obligation =\n             util::obligation_for_builtin_bound(\n@@ -292,10 +294,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    fn evaluate_obligation_recursively(&mut self,\n-                                       previous_stack: Option<&ObligationStack>,\n-                                       obligation: &Obligation)\n-                                       -> EvaluationResult\n+    fn evaluate_obligation_recursively<'o>(&mut self,\n+                                           previous_stack: Option<&ObligationStack<'o, 'tcx>>,\n+                                           obligation: &Obligation<'tcx>)\n+                                           -> EvaluationResult\n     {\n         debug!(\"evaluate_obligation_recursively({})\",\n                obligation.repr(self.tcx()));\n@@ -308,9 +310,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         result\n     }\n \n-    fn evaluate_stack(&mut self,\n-                      stack: &ObligationStack)\n-                      -> EvaluationResult\n+    fn evaluate_stack<'o>(&mut self,\n+                          stack: &ObligationStack<'o, 'tcx>)\n+                          -> EvaluationResult\n     {\n         // In intercrate mode, whenever any of the types are unbound,\n         // there can always be an impl. Even if there are no impls in\n@@ -387,7 +389,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     pub fn evaluate_impl(&mut self,\n                          impl_def_id: ast::DefId,\n-                         obligation: &Obligation)\n+                         obligation: &Obligation<'tcx>)\n                          -> bool\n     {\n         /*!\n@@ -434,9 +436,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // the algorithm.\n \n     pub fn evaluate_method_obligation(&mut self,\n-                                      rcvr_ty: ty::t,\n-                                      xform_self_ty: ty::t,\n-                                      obligation: &Obligation)\n+                                      rcvr_ty: Ty<'tcx>,\n+                                      xform_self_ty: Ty<'tcx>,\n+                                      obligation: &Obligation<'tcx>)\n                                       -> MethodMatchResult\n     {\n         /*!\n@@ -562,9 +564,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     pub fn confirm_method_match(&mut self,\n-                                rcvr_ty: ty::t,\n-                                xform_self_ty: ty::t,\n-                                obligation: &Obligation,\n+                                rcvr_ty: Ty<'tcx>,\n+                                xform_self_ty: Ty<'tcx>,\n+                                obligation: &Obligation<'tcx>,\n                                 data: MethodMatchedData)\n     {\n         /*!\n@@ -596,9 +598,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn match_method_precise(&mut self,\n-                            rcvr_ty: ty::t,\n-                            xform_self_ty: ty::t,\n-                            obligation: &Obligation)\n+                            rcvr_ty: Ty<'tcx>,\n+                            xform_self_ty: Ty<'tcx>,\n+                            obligation: &Obligation<'tcx>)\n                             -> Result<(),()>\n     {\n         /*!\n@@ -622,9 +624,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn assemble_method_candidates_from_impls(&mut self,\n-                                             rcvr_ty: ty::t,\n-                                             xform_self_ty: ty::t,\n-                                             obligation: &Obligation)\n+                                             rcvr_ty: Ty<'tcx>,\n+                                             xform_self_ty: Ty<'tcx>,\n+                                             obligation: &Obligation<'tcx>)\n                                              -> Vec<ast::DefId>\n     {\n         /*!\n@@ -650,10 +652,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_method_coerce(&mut self,\n                            impl_def_id: ast::DefId,\n-                           rcvr_ty: ty::t,\n-                           xform_self_ty: ty::t,\n-                           obligation: &Obligation)\n-                           -> Result<Substs, ()>\n+                           rcvr_ty: Ty<'tcx>,\n+                           xform_self_ty: Ty<'tcx>,\n+                           obligation: &Obligation<'tcx>)\n+                           -> Result<Substs<'tcx>, ()>\n     {\n         /*!\n          * Applies the *coercive match* procedure described in\n@@ -683,9 +685,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn winnow_method_impl(&mut self,\n                           impl_def_id: ast::DefId,\n-                          rcvr_ty: ty::t,\n-                          xform_self_ty: ty::t,\n-                          obligation: &Obligation)\n+                          rcvr_ty: Ty<'tcx>,\n+                          xform_self_ty: Ty<'tcx>,\n+                          obligation: &Obligation<'tcx>)\n                           -> bool\n     {\n         /*!\n@@ -724,9 +726,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // caller obligations, and so forth and assembling a list of\n     // candidates. See `doc.rs` and the `Candidate` type for more details.\n \n-    fn candidate_from_obligation(&mut self,\n-                                 stack: &ObligationStack)\n-                                 -> SelectionResult<Candidate>\n+    fn candidate_from_obligation<'o>(&mut self,\n+                                     stack: &ObligationStack<'o, 'tcx>)\n+                                     -> SelectionResult<'tcx, Candidate<'tcx>>\n     {\n         // Watch out for overflow. This intentionally bypasses (and does\n         // not update) the cache.\n@@ -767,9 +769,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidate\n     }\n \n-    fn candidate_from_obligation_no_cache(&mut self,\n-                                          stack: &ObligationStack)\n-                                          -> SelectionResult<Candidate>\n+    fn candidate_from_obligation_no_cache<'o>(&mut self,\n+                                              stack: &ObligationStack<'o, 'tcx>)\n+                                              -> SelectionResult<'tcx, Candidate<'tcx>>\n     {\n         if ty::type_is_error(stack.obligation.self_ty()) {\n             return Ok(Some(ErrorCandidate));\n@@ -863,8 +865,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn pick_candidate_cache(&self,\n-                            cache_skol_trait_ref: &Rc<ty::TraitRef>)\n-                            -> &SelectionCache\n+                            cache_skol_trait_ref: &Rc<ty::TraitRef<'tcx>>)\n+                            -> &SelectionCache<'tcx>\n     {\n         // High-level idea: we have to decide whether to consult the\n         // cache that is specific to this scope, or to consult the\n@@ -910,26 +912,26 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn check_candidate_cache(&mut self,\n-                             cache_skol_trait_ref: Rc<ty::TraitRef>)\n-                             -> Option<SelectionResult<Candidate>>\n+                             cache_skol_trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                             -> Option<SelectionResult<'tcx, Candidate<'tcx>>>\n     {\n         let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n         let hashmap = cache.hashmap.borrow();\n         hashmap.get(&cache_skol_trait_ref).map(|c| (*c).clone())\n     }\n \n     fn insert_candidate_cache(&mut self,\n-                              cache_skol_trait_ref: Rc<ty::TraitRef>,\n-                              candidate: SelectionResult<Candidate>)\n+                              cache_skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                              candidate: SelectionResult<'tcx, Candidate<'tcx>>)\n     {\n         let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n         let mut hashmap = cache.hashmap.borrow_mut();\n         hashmap.insert(cache_skol_trait_ref, candidate);\n     }\n \n-    fn assemble_candidates(&mut self,\n-                           stack: &ObligationStack)\n-                           -> Result<CandidateSet, SelectionError>\n+    fn assemble_candidates<'o>(&mut self,\n+                               stack: &ObligationStack<'o, 'tcx>)\n+                               -> Result<CandidateSet<'tcx>, SelectionError<'tcx>>\n     {\n         // Check for overflow.\n \n@@ -961,9 +963,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn assemble_candidates_from_caller_bounds(&mut self,\n-                                              obligation: &Obligation,\n-                                              candidates: &mut CandidateSet)\n-                                              -> Result<(),SelectionError>\n+                                              obligation: &Obligation<'tcx>,\n+                                              candidates: &mut CandidateSet<'tcx>)\n+                                              -> Result<(),SelectionError<'tcx>>\n     {\n         /*!\n          * Given an obligation like `<SomeTrait for T>`, search the obligations\n@@ -1001,9 +1003,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn assemble_unboxed_candidates(&mut self,\n-                                   obligation: &Obligation,\n-                                   candidates: &mut CandidateSet)\n-                                   -> Result<(),SelectionError>\n+                                   obligation: &Obligation<'tcx>,\n+                                   candidates: &mut CandidateSet<'tcx>)\n+                                   -> Result<(),SelectionError<'tcx>>\n     {\n         /*!\n          * Check for the artificial impl that the compiler will create\n@@ -1028,7 +1030,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-        let (closure_def_id, substs) = match ty::get(self_ty).sty {\n+        let (closure_def_id, substs) = match self_ty.sty {\n             ty::ty_unboxed_closure(id, _, ref substs) => (id, substs.clone()),\n             ty::ty_infer(ty::TyVar(_)) => {\n                 candidates.ambiguous = true;\n@@ -1059,9 +1061,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn assemble_candidates_from_impls(&mut self,\n-                                      obligation: &Obligation,\n-                                      candidates: &mut CandidateSet)\n-                                      -> Result<(), SelectionError>\n+                                      obligation: &Obligation<'tcx>,\n+                                      candidates: &mut CandidateSet<'tcx>)\n+                                      -> Result<(), SelectionError<'tcx>>\n     {\n         /*!\n          * Search for impls that might apply to `obligation`.\n@@ -1090,10 +1092,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // attempt to evaluate recursive bounds to see if they are\n     // satisfied.\n \n-    fn winnow_candidate(&mut self,\n-                        stack: &ObligationStack,\n-                        candidate: &Candidate)\n-                        -> EvaluationResult\n+    fn winnow_candidate<'o>(&mut self,\n+                            stack: &ObligationStack<'o, 'tcx>,\n+                            candidate: &Candidate<'tcx>)\n+                            -> EvaluationResult\n     {\n         /*!\n          * Further evaluate `candidate` to decide whether all type parameters match\n@@ -1111,10 +1113,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         })\n     }\n \n-    fn winnow_selection(&mut self,\n-                        stack: Option<&ObligationStack>,\n-                        selection: Selection)\n-                        -> EvaluationResult\n+    fn winnow_selection<'o>(&mut self,\n+                            stack: Option<&ObligationStack<'o, 'tcx>>,\n+                            selection: Selection<'tcx>)\n+                            -> EvaluationResult\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in selection.iter_nested() {\n@@ -1127,11 +1129,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         result\n     }\n \n-    fn candidate_should_be_dropped_in_favor_of(&mut self,\n-                                               stack: &ObligationStack,\n-                                               candidate_i: &Candidate,\n-                                               candidate_j: &Candidate)\n-                                               -> bool\n+    fn candidate_should_be_dropped_in_favor_of<'o>(&mut self,\n+                                                   stack: &ObligationStack<'o, 'tcx>,\n+                                                   candidate_i: &Candidate<'tcx>,\n+                                                   candidate_j: &Candidate<'tcx>)\n+                                                   -> bool\n     {\n         /*!\n          * Returns true if `candidate_i` should be dropped in favor of `candidate_j`.\n@@ -1194,11 +1196,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // those will hopefully change to library-defined traits in the\n     // future.\n \n-    fn assemble_builtin_bound_candidates(&mut self,\n-                                         bound: ty::BuiltinBound,\n-                                         stack: &ObligationStack,\n-                                         candidates: &mut CandidateSet)\n-                                         -> Result<(),SelectionError>\n+    fn assemble_builtin_bound_candidates<'o>(&mut self,\n+                                             bound: ty::BuiltinBound,\n+                                             stack: &ObligationStack<'o, 'tcx>,\n+                                             candidates: &mut CandidateSet<'tcx>)\n+                                             -> Result<(),SelectionError<'tcx>>\n     {\n         // FIXME -- To be more like a normal impl, we should just\n         // ignore the nested cases here, and instead generate nested\n@@ -1227,11 +1229,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn builtin_bound(&mut self,\n                      bound: ty::BuiltinBound,\n-                     self_ty: ty::t)\n-                     -> Result<BuiltinBoundConditions,SelectionError>\n+                     self_ty: Ty<'tcx>)\n+                     -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n     {\n         let self_ty = self.infcx.shallow_resolve(self_ty);\n-        return match ty::get(self_ty).sty {\n+        return match self_ty.sty {\n             ty::ty_infer(ty::IntVar(_)) |\n             ty::ty_infer(ty::FloatVar(_)) |\n             ty::ty_uint(_) |\n@@ -1443,7 +1445,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n \n                     Some(freevars) => {\n-                        let tys: Vec<ty::t> =\n+                        let tys: Vec<Ty> =\n                             freevars\n                             .iter()\n                             .map(|freevar| {\n@@ -1458,7 +1460,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::ty_struct(def_id, ref substs) => {\n-                let types: Vec<ty::t> =\n+                let types: Vec<Ty> =\n                     ty::struct_fields(self.tcx(), def_id, substs)\n                     .iter()\n                     .map(|f| f.mt.ty)\n@@ -1467,7 +1469,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::ty_enum(def_id, ref substs) => {\n-                let types: Vec<ty::t> =\n+                let types: Vec<Ty> =\n                     ty::substd_enum_variants(self.tcx(), def_id, substs)\n                     .iter()\n                     .flat_map(|variant| variant.args.iter())\n@@ -1505,11 +1507,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        fn nominal(this: &mut SelectionContext,\n-                   bound: ty::BuiltinBound,\n-                   def_id: ast::DefId,\n-                   types: Vec<ty::t>)\n-                   -> Result<BuiltinBoundConditions,SelectionError>\n+        fn nominal<'cx, 'tcx>(this: &mut SelectionContext<'cx, 'tcx>,\n+                              bound: ty::BuiltinBound,\n+                              def_id: ast::DefId,\n+                              types: Vec<Ty<'tcx>>)\n+                              -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n         {\n             // First check for markers and other nonsense.\n             let tcx = this.tcx();\n@@ -1564,9 +1566,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // type error.  See `doc.rs` for more details.\n \n     fn confirm_candidate(&mut self,\n-                         obligation: &Obligation,\n-                         candidate: Candidate)\n-                         -> Result<Selection,SelectionError>\n+                         obligation: &Obligation<'tcx>,\n+                         candidate: Candidate<'tcx>)\n+                         -> Result<Selection<'tcx>,SelectionError<'tcx>>\n     {\n         debug!(\"confirm_candidate({}, {})\",\n                obligation.repr(self.tcx()),\n@@ -1598,9 +1600,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_param_candidate(&mut self,\n-                               obligation: &Obligation,\n-                               param: VtableParamData)\n-                               -> Result<VtableParamData,SelectionError>\n+                               obligation: &Obligation<'tcx>,\n+                               param: VtableParamData<'tcx>)\n+                               -> Result<VtableParamData<'tcx>,\n+                                         SelectionError<'tcx>>\n     {\n         debug!(\"confirm_param_candidate({},{})\",\n                obligation.repr(self.tcx()),\n@@ -1613,9 +1616,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_builtin_candidate(&mut self,\n-                                 obligation: &Obligation,\n+                                 obligation: &Obligation<'tcx>,\n                                  bound: ty::BuiltinBound)\n-                                 -> Result<VtableBuiltinData<Obligation>,SelectionError>\n+                                 -> Result<VtableBuiltinData<Obligation<'tcx>>,\n+                                           SelectionError<'tcx>>\n     {\n         debug!(\"confirm_builtin_candidate({})\",\n                obligation.repr(self.tcx()));\n@@ -1633,10 +1637,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn vtable_builtin_data(&mut self,\n-                           obligation: &Obligation,\n+                           obligation: &Obligation<'tcx>,\n                            bound: ty::BuiltinBound,\n-                           nested: Vec<ty::t>)\n-                           -> VtableBuiltinData<Obligation>\n+                           nested: Vec<Ty<'tcx>>)\n+                           -> VtableBuiltinData<Obligation<'tcx>>\n     {\n         let obligations = nested.iter().map(|&t| {\n             util::obligation_for_builtin_bound(\n@@ -1656,9 +1660,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_impl_candidate(&mut self,\n-                              obligation: &Obligation,\n+                              obligation: &Obligation<'tcx>,\n                               impl_def_id: ast::DefId)\n-                              -> Result<VtableImplData<Obligation>,SelectionError>\n+                              -> Result<VtableImplData<'tcx, Obligation<'tcx>>,\n+                                        SelectionError<'tcx>>\n     {\n         debug!(\"confirm_impl_candidate({},{})\",\n                obligation.repr(self.tcx()),\n@@ -1672,10 +1677,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn vtable_impl(&mut self,\n                    impl_def_id: ast::DefId,\n-                   substs: Substs,\n-                   cause: ObligationCause,\n+                   substs: Substs<'tcx>,\n+                   cause: ObligationCause<'tcx>,\n                    recursion_depth: uint)\n-                   -> VtableImplData<Obligation>\n+                   -> VtableImplData<'tcx, Obligation<'tcx>>\n     {\n         let impl_obligations =\n             self.impl_obligations(cause,\n@@ -1688,10 +1693,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_unboxed_closure_candidate(&mut self,\n-                                         obligation: &Obligation,\n+                                         obligation: &Obligation<'tcx>,\n                                          closure_def_id: ast::DefId,\n-                                         substs: &Substs)\n-                                         -> Result<(),SelectionError>\n+                                         substs: &Substs<'tcx>)\n+                                         -> Result<(),SelectionError<'tcx>>\n     {\n         debug!(\"confirm_unboxed_closure_candidate({},{},{})\",\n                obligation.repr(self.tcx()),\n@@ -1739,8 +1744,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn rematch_impl(&mut self,\n                     impl_def_id: ast::DefId,\n-                    obligation: &Obligation)\n-                    -> Substs\n+                    obligation: &Obligation<'tcx>)\n+                    -> Substs<'tcx>\n     {\n         match self.match_impl(impl_def_id, obligation) {\n             Ok(substs) => {\n@@ -1758,8 +1763,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_impl(&mut self,\n                   impl_def_id: ast::DefId,\n-                  obligation: &Obligation)\n-                  -> Result<Substs, ()>\n+                  obligation: &Obligation<'tcx>)\n+                  -> Result<Substs<'tcx>, ()>\n     {\n         let impl_trait_ref = ty::impl_trait_ref(self.tcx(),\n                                                 impl_def_id).unwrap();\n@@ -1808,8 +1813,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn match_trait_refs(&mut self,\n-                        obligation: &Obligation,\n-                        trait_ref: Rc<ty::TraitRef>)\n+                        obligation: &Obligation<'tcx>,\n+                        trait_ref: Rc<ty::TraitRef<'tcx>>)\n                         -> Result<(),()>\n     {\n         debug!(\"match_trait_refs: obligation={} trait_ref={}\",\n@@ -1829,8 +1834,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn match_inherent_impl(&mut self,\n                            impl_def_id: ast::DefId,\n                            obligation_cause: ObligationCause,\n-                           obligation_self_ty: ty::t)\n-                           -> Result<Substs,()>\n+                           obligation_self_ty: Ty<'tcx>)\n+                           -> Result<Substs<'tcx>,()>\n     {\n         /*!\n          * Determines whether the self type declared against\n@@ -1878,10 +1883,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         cause: ObligationCause,\n \n                         // The self type provided by the impl/caller-obligation:\n-                        provided_self_ty: ty::t,\n+                        provided_self_ty: Ty<'tcx>,\n \n                         // The self type the obligation is for:\n-                        required_self_ty: ty::t)\n+                        required_self_ty: Ty<'tcx>)\n                         -> Result<(),()>\n     {\n         // FIXME(#5781) -- equating the types is stronger than\n@@ -1908,10 +1913,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn confirm_impl_vtable(&mut self,\n                            impl_def_id: ast::DefId,\n-                           obligation_cause: ObligationCause,\n-                           obligation_trait_ref: Rc<ty::TraitRef>,\n-                           substs: &Substs)\n-                           -> Result<(), SelectionError>\n+                           obligation_cause: ObligationCause<'tcx>,\n+                           obligation_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                           substs: &Substs<'tcx>)\n+                           -> Result<(), SelectionError<'tcx>>\n     {\n         /*!\n          * Relates the output type parameters from an impl to the\n@@ -1938,9 +1943,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn confirm(&mut self,\n                obligation_cause: ObligationCause,\n-               obligation_trait_ref: Rc<ty::TraitRef>,\n-               expected_trait_ref: Rc<ty::TraitRef>)\n-               -> Result<(), SelectionError>\n+               obligation_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+               expected_trait_ref: Rc<ty::TraitRef<'tcx>>)\n+               -> Result<(), SelectionError<'tcx>>\n     {\n         /*!\n          * After we have determined which impl applies, and with what\n@@ -1984,9 +1989,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // Miscellany\n \n     fn push_stack<'o,'s:'o>(&mut self,\n-                            previous_stack: Option<&'s ObligationStack<'s>>,\n-                            obligation: &'o Obligation)\n-                            -> ObligationStack<'o>\n+                            previous_stack: Option<&'s ObligationStack<'s, 'tcx>>,\n+                            obligation: &'o Obligation<'tcx>)\n+                            -> ObligationStack<'o, 'tcx>\n     {\n         let skol_trait_ref = obligation.trait_ref.fold_with(&mut self.skolemizer);\n \n@@ -2011,11 +2016,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn impl_obligations(&self,\n-                        cause: ObligationCause,\n+                        cause: ObligationCause<'tcx>,\n                         recursion_depth: uint,\n                         impl_def_id: ast::DefId,\n-                        impl_substs: &Substs)\n-                        -> VecPerParamSpace<Obligation>\n+                        impl_substs: &Substs<'tcx>)\n+                        -> VecPerParamSpace<Obligation<'tcx>>\n     {\n         let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n         let bounds = impl_generics.to_bounds(self.tcx(), impl_substs);\n@@ -2024,8 +2029,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n }\n \n-impl Repr for Candidate {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for Candidate<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({})\", b),\n@@ -2038,22 +2043,22 @@ impl Repr for Candidate {\n     }\n }\n \n-impl SelectionCache {\n-    pub fn new() -> SelectionCache {\n+impl<'tcx> SelectionCache<'tcx> {\n+    pub fn new() -> SelectionCache<'tcx> {\n         SelectionCache {\n             hashmap: RefCell::new(HashMap::new())\n         }\n     }\n }\n \n-impl<'o> ObligationStack<'o> {\n-    fn iter(&self) -> Option<&ObligationStack> {\n+impl<'o, 'tcx> ObligationStack<'o, 'tcx> {\n+    fn iter(&self) -> Option<&ObligationStack<'o, 'tcx>> {\n         Some(self)\n     }\n }\n \n-impl<'o> Iterator<&'o ObligationStack<'o>> for Option<&'o ObligationStack<'o>> {\n-    fn next(&mut self) -> Option<&'o ObligationStack<'o>> {\n+impl<'o, 'tcx> Iterator<&'o ObligationStack<'o, 'tcx>> for Option<&'o ObligationStack<'o, 'tcx>> {\n+    fn next(&mut self) -> Option<&'o ObligationStack<'o, 'tcx>> {\n         match *self {\n             Some(o) => {\n                 *self = o.previous;\n@@ -2066,8 +2071,8 @@ impl<'o> Iterator<&'o ObligationStack<'o>> for Option<&'o ObligationStack<'o>> {\n     }\n }\n \n-impl<'o> Repr for ObligationStack<'o> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'o, 'tcx> Repr<'tcx> for ObligationStack<'o, 'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"ObligationStack({})\",\n                 self.obligation.repr(tcx))\n     }"}, {"sha": "dfd436bdc4d306458f0b49869612690b66b6232f", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -12,7 +12,7 @@\n use middle::subst;\n use middle::subst::{ParamSpace, Substs, VecPerParamSpace};\n use middle::typeck::infer::InferCtxt;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use std::collections::HashSet;\n use std::fmt;\n use std::rc::Rc;\n@@ -28,17 +28,17 @@ use super::{ErrorReported, Obligation, ObligationCause, VtableImpl,\n \n pub struct Supertraits<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n-    stack: Vec<SupertraitEntry>,\n-    visited: HashSet<Rc<ty::TraitRef>>,\n+    stack: Vec<SupertraitEntry<'tcx>>,\n+    visited: HashSet<Rc<ty::TraitRef<'tcx>>>,\n }\n \n-struct SupertraitEntry {\n+struct SupertraitEntry<'tcx> {\n     position: uint,\n-    supertraits: Vec<Rc<ty::TraitRef>>,\n+    supertraits: Vec<Rc<ty::TraitRef<'tcx>>>,\n }\n \n pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                              trait_ref: Rc<ty::TraitRef>)\n+                              trait_ref: Rc<ty::TraitRef<'tcx>>)\n                               -> Supertraits<'cx, 'tcx>\n {\n     /*!\n@@ -61,7 +61,7 @@ pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n }\n \n pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                                    bounds: &[Rc<ty::TraitRef>])\n+                                    bounds: &[Rc<ty::TraitRef<'tcx>>])\n                                     -> Supertraits<'cx, 'tcx>\n {\n     let bounds = Vec::from_fn(bounds.len(), |i| bounds[i].clone());\n@@ -76,7 +76,7 @@ pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n }\n \n impl<'cx, 'tcx> Supertraits<'cx, 'tcx> {\n-    fn push(&mut self, trait_ref: &ty::TraitRef) {\n+    fn push(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n         let ty::ParamBounds { builtin_bounds, mut trait_bounds, .. } =\n             ty::bounds_for_trait_ref(self.tcx, trait_ref);\n         for builtin_bound in builtin_bounds.iter() {\n@@ -106,8 +106,8 @@ impl<'cx, 'tcx> Supertraits<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef>> for Supertraits<'cx, 'tcx> {\n-    fn next(&mut self) -> Option<Rc<ty::TraitRef>> {\n+impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n+    fn next(&mut self) -> Option<Rc<ty::TraitRef<'tcx>>> {\n         loop {\n             // Extract next item from top-most stack frame, if any.\n             let next_trait = match self.stack.last_mut() {\n@@ -148,34 +148,34 @@ impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef>> for Supertraits<'cx, 'tcx> {\n // declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-pub fn fresh_substs_for_impl(infcx: &InferCtxt,\n-                             span: Span,\n-                             impl_def_id: ast::DefId)\n-                             -> Substs\n+pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                       span: Span,\n+                                       impl_def_id: ast::DefId)\n+                                       -> Substs<'tcx>\n {\n     let tcx = infcx.tcx;\n     let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n-impl<N> fmt::Show for VtableImplData<N> {\n+impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableImpl({})\", self.impl_def_id)\n     }\n }\n \n-impl fmt::Show for VtableParamData {\n+impl<'tcx> fmt::Show for VtableParamData<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableParam(...)\")\n     }\n }\n \n-pub fn obligations_for_generics(tcx: &ty::ctxt,\n-                                cause: ObligationCause,\n-                                recursion_depth: uint,\n-                                generic_bounds: &ty::GenericBounds,\n-                                type_substs: &VecPerParamSpace<ty::t>)\n-                                -> VecPerParamSpace<Obligation>\n+pub fn obligations_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      cause: ObligationCause<'tcx>,\n+                                      recursion_depth: uint,\n+                                      generic_bounds: &ty::GenericBounds<'tcx>,\n+                                      type_substs: &VecPerParamSpace<Ty<'tcx>>)\n+                                      -> VecPerParamSpace<Obligation<'tcx>>\n {\n     /*! See `super::obligations_for_generics` */\n \n@@ -200,15 +200,15 @@ pub fn obligations_for_generics(tcx: &ty::ctxt,\n     return obligations;\n }\n \n-fn push_obligations_for_param_bounds(\n-    tcx: &ty::ctxt,\n-    cause: ObligationCause,\n+fn push_obligations_for_param_bounds<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    cause: ObligationCause<'tcx>,\n     recursion_depth: uint,\n     space: subst::ParamSpace,\n     index: uint,\n-    param_bounds: &ty::ParamBounds,\n-    param_type_substs: &VecPerParamSpace<ty::t>,\n-    obligations: &mut VecPerParamSpace<Obligation>)\n+    param_bounds: &ty::ParamBounds<'tcx>,\n+    param_type_substs: &VecPerParamSpace<Ty<'tcx>>,\n+    obligations: &mut VecPerParamSpace<Obligation<'tcx>>)\n {\n     let param_ty = *param_type_substs.get(space, index);\n     for builtin_bound in param_bounds.builtin_bounds.iter() {\n@@ -232,11 +232,11 @@ fn push_obligations_for_param_bounds(\n     }\n }\n \n-pub fn trait_ref_for_builtin_bound(\n-    tcx: &ty::ctxt,\n+pub fn trait_ref_for_builtin_bound<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n-    param_ty: ty::t)\n-    -> Option<Rc<ty::TraitRef>>\n+    param_ty: Ty<'tcx>)\n+    -> Option<Rc<ty::TraitRef<'tcx>>>\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n@@ -252,13 +252,13 @@ pub fn trait_ref_for_builtin_bound(\n     }\n }\n \n-pub fn obligation_for_builtin_bound(\n-    tcx: &ty::ctxt,\n-    cause: ObligationCause,\n+pub fn obligation_for_builtin_bound<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    cause: ObligationCause<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     recursion_depth: uint,\n-    param_ty: ty::t)\n-    -> Result<Obligation, ErrorReported>\n+    param_ty: Ty<'tcx>)\n+    -> Result<Obligation<'tcx>, ErrorReported>\n {\n     let trait_ref = trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty);\n     match trait_ref {\n@@ -271,10 +271,10 @@ pub fn obligation_for_builtin_bound(\n     }\n }\n \n-pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n-                                               caller_bound: Rc<ty::TraitRef>,\n-                                               test: |ast::DefId| -> bool)\n-                                               -> Option<VtableParamData>\n+pub fn search_trait_and_supertraits_from_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                     caller_bound: Rc<ty::TraitRef<'tcx>>,\n+                                                     test: |ast::DefId| -> bool)\n+                                                     -> Option<VtableParamData<'tcx>>\n {\n     /*!\n      * Starting from a caller obligation `caller_bound` (which has\n@@ -295,16 +295,16 @@ pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n     return None;\n }\n \n-impl Repr for super::Obligation {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for super::Obligation<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Obligation(trait_ref={},depth={})\",\n                 self.trait_ref.repr(tcx),\n                 self.recursion_depth)\n     }\n }\n \n-impl<N:Repr> Repr for super::Vtable<N> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             super::VtableImpl(ref v) =>\n                 v.repr(tcx),\n@@ -323,31 +323,31 @@ impl<N:Repr> Repr for super::Vtable<N> {\n     }\n }\n \n-impl<N:Repr> Repr for super::VtableImplData<N> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableImplData<'tcx, N> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"VtableImpl(impl_def_id={}, substs={}, nested={})\",\n                 self.impl_def_id.repr(tcx),\n                 self.substs.repr(tcx),\n                 self.nested.repr(tcx))\n     }\n }\n \n-impl<N:Repr> Repr for super::VtableBuiltinData<N> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableBuiltinData<N> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"VtableBuiltin(nested={})\",\n                 self.nested.repr(tcx))\n     }\n }\n \n-impl Repr for super::VtableParamData {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for super::VtableParamData<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"VtableParam(bound={})\",\n                 self.bound.repr(tcx))\n     }\n }\n \n-impl Repr for super::SelectionError {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             super::Overflow =>\n                 format!(\"Overflow\"),\n@@ -363,24 +363,24 @@ impl Repr for super::SelectionError {\n     }\n }\n \n-impl Repr for super::FulfillmentError {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for super::FulfillmentError<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"FulfillmentError({},{})\",\n                 self.obligation.repr(tcx),\n                 self.code.repr(tcx))\n     }\n }\n \n-impl Repr for super::FulfillmentErrorCode {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for super::FulfillmentErrorCode<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             super::CodeSelectionError(ref o) => o.repr(tcx),\n             super::CodeAmbiguity => format!(\"Ambiguity\")\n         }\n     }\n }\n \n-impl fmt::Show for super::FulfillmentErrorCode {\n+impl<'tcx> fmt::Show for super::FulfillmentErrorCode<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             super::CodeSelectionError(ref e) => write!(f, \"{}\", e),\n@@ -389,8 +389,8 @@ impl fmt::Show for super::FulfillmentErrorCode {\n     }\n }\n \n-impl Repr for ty::type_err {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::type_err<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         ty::type_err_to_str(tcx, self)\n     }\n }"}, {"sha": "bf4260c46314b449d3ba383aa4036d9b872bd828", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 635, "deletions": 677, "changes": 1312, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "913919fe774f341f0a7320347904dc2d72565d8d", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 138, "deletions": 134, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -38,7 +38,7 @@\n \n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::traits;\n use middle::typeck;\n use std::rc::Rc;\n@@ -50,8 +50,8 @@ use util::ppaux::Repr;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n-pub trait TypeFoldable {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n+pub trait TypeFoldable<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n /// The TypeFolder trait defines the actual *folding*. There is a\n@@ -73,50 +73,50 @@ pub trait TypeFolder<'tcx> {\n     /// track the Debruijn index nesting level.\n     fn exit_region_binder(&mut self) { }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         super_fold_ty(self, t)\n     }\n \n-    fn fold_mt(&mut self, t: &ty::mt) -> ty::mt {\n+    fn fold_mt(&mut self, t: &ty::mt<'tcx>) -> ty::mt<'tcx> {\n         super_fold_mt(self, t)\n     }\n \n-    fn fold_trait_ref(&mut self, t: &ty::TraitRef) -> ty::TraitRef {\n+    fn fold_trait_ref(&mut self, t: &ty::TraitRef<'tcx>) -> ty::TraitRef<'tcx> {\n         super_fold_trait_ref(self, t)\n     }\n \n-    fn fold_sty(&mut self, sty: &ty::sty) -> ty::sty {\n+    fn fold_sty(&mut self, sty: &ty::sty<'tcx>) -> ty::sty<'tcx> {\n         super_fold_sty(self, sty)\n     }\n \n     fn fold_substs(&mut self,\n-                   substs: &subst::Substs)\n-                   -> subst::Substs {\n+                   substs: &subst::Substs<'tcx>)\n+                   -> subst::Substs<'tcx> {\n         super_fold_substs(self, substs)\n     }\n \n     fn fold_fn_sig(&mut self,\n-                sig: &ty::FnSig)\n-                -> ty::FnSig {\n+                sig: &ty::FnSig<'tcx>)\n+                -> ty::FnSig<'tcx> {\n         super_fold_fn_sig(self, sig)\n     }\n \n     fn fold_output(&mut self,\n-                      output: &ty::FnOutput)\n-                      -> ty::FnOutput {\n+                      output: &ty::FnOutput<'tcx>)\n+                      -> ty::FnOutput<'tcx> {\n         super_fold_output(self, output)\n     }\n \n     fn fold_bare_fn_ty(&mut self,\n-                       fty: &ty::BareFnTy)\n-                       -> ty::BareFnTy\n+                       fty: &ty::BareFnTy<'tcx>)\n+                       -> ty::BareFnTy<'tcx>\n     {\n         super_fold_bare_fn_ty(self, fty)\n     }\n \n     fn fold_closure_ty(&mut self,\n-                       fty: &ty::ClosureTy)\n-                       -> ty::ClosureTy {\n+                       fty: &ty::ClosureTy<'tcx>)\n+                       -> ty::ClosureTy<'tcx> {\n         super_fold_closure_ty(self, fty)\n     }\n \n@@ -133,15 +133,16 @@ pub trait TypeFolder<'tcx> {\n         super_fold_existential_bounds(self, s)\n     }\n \n-    fn fold_autoref(&mut self, ar: &ty::AutoRef) -> ty::AutoRef {\n+    fn fold_autoref(&mut self, ar: &ty::AutoRef<'tcx>) -> ty::AutoRef<'tcx> {\n         super_fold_autoref(self, ar)\n     }\n \n-    fn fold_item_substs(&mut self, i: ty::ItemSubsts) -> ty::ItemSubsts {\n+    fn fold_item_substs(&mut self, i: ty::ItemSubsts<'tcx>) -> ty::ItemSubsts<'tcx> {\n         super_fold_item_substs(self, i)\n     }\n \n-    fn fold_obligation(&mut self, o: &traits::Obligation) -> traits::Obligation {\n+    fn fold_obligation(&mut self, o: &traits::Obligation<'tcx>)\n+                       -> traits::Obligation<'tcx> {\n         super_fold_obligation(self, o)\n     }\n }\n@@ -157,53 +158,53 @@ pub trait TypeFolder<'tcx> {\n // can easily refactor the folding into the TypeFolder trait as\n // needed.\n \n-impl TypeFoldable for () {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, _: &mut F) -> () {\n+impl<'tcx> TypeFoldable<'tcx> for () {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> () {\n         ()\n     }\n }\n \n-impl<T:TypeFoldable,U:TypeFoldable> TypeFoldable for (T, U) {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n+impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n }\n \n-impl<T:TypeFoldable> TypeFoldable for Option<T> {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n         self.as_ref().map(|t| t.fold_with(folder))\n     }\n }\n \n-impl<T:TypeFoldable> TypeFoldable for Rc<T> {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n         Rc::new((**self).fold_with(folder))\n     }\n }\n \n-impl<T:TypeFoldable> TypeFoldable for Vec<T> {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n }\n \n-impl<T:TypeFoldable> TypeFoldable for ty::Binder<T> {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n+impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         folder.enter_region_binder();\n         let result = ty::bind(self.value.fold_with(folder));\n         folder.exit_region_binder();\n         result\n     }\n }\n \n-impl<T:TypeFoldable> TypeFoldable for OwnedSlice<T> {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for OwnedSlice<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n }\n \n-impl<T:TypeFoldable> TypeFoldable for VecPerParamSpace<T> {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n \n         // Things in the Fn space take place under an additional level\n         // of region binding relative to the other spaces. This is\n@@ -225,88 +226,88 @@ impl<T:TypeFoldable> TypeFoldable for VecPerParamSpace<T> {\n     }\n }\n \n-impl TypeFoldable for ty::TraitStore {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitStore {\n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitStore {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitStore {\n         folder.fold_trait_store(*self)\n     }\n }\n \n-impl TypeFoldable for ty::t {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::t {\n+impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Ty<'tcx> {\n         folder.fold_ty(*self)\n     }\n }\n \n-impl TypeFoldable for ty::BareFnTy {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::BareFnTy {\n+impl<'tcx> TypeFoldable<'tcx> for ty::BareFnTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::BareFnTy<'tcx> {\n         folder.fold_bare_fn_ty(self)\n     }\n }\n \n-impl TypeFoldable for ty::ClosureTy {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureTy {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureTy<'tcx> {\n         folder.fold_closure_ty(self)\n     }\n }\n \n-impl TypeFoldable for ty::mt {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::mt {\n+impl<'tcx> TypeFoldable<'tcx> for ty::mt<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::mt<'tcx> {\n         folder.fold_mt(self)\n     }\n }\n \n-impl TypeFoldable for ty::FnOutput {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnOutput {\n+impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnOutput<'tcx> {\n         folder.fold_output(self)\n     }\n }\n \n-impl TypeFoldable for ty::FnSig {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig {\n+impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig<'tcx> {\n         folder.fold_fn_sig(self)\n     }\n }\n \n-impl TypeFoldable for ty::sty {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::sty {\n+impl<'tcx> TypeFoldable<'tcx> for ty::sty<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::sty<'tcx> {\n         folder.fold_sty(self)\n     }\n }\n \n-impl TypeFoldable for ty::TraitRef {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef {\n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n         folder.fold_trait_ref(self)\n     }\n }\n \n-impl TypeFoldable for ty::Region {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n+impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n         folder.fold_region(*self)\n     }\n }\n \n-impl TypeFoldable for subst::Substs {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> subst::Substs {\n+impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> subst::Substs<'tcx> {\n         folder.fold_substs(self)\n     }\n }\n \n-impl TypeFoldable for ty::ItemSubsts {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ItemSubsts {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ItemSubsts<'tcx> {\n         ty::ItemSubsts {\n             substs: self.substs.fold_with(folder),\n         }\n     }\n }\n \n-impl TypeFoldable for ty::AutoRef {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::AutoRef {\n+impl<'tcx> TypeFoldable<'tcx> for ty::AutoRef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::AutoRef<'tcx> {\n         folder.fold_autoref(self)\n     }\n }\n \n-impl TypeFoldable for typeck::MethodOrigin {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> typeck::MethodOrigin {\n+impl<'tcx> TypeFoldable<'tcx> for typeck::MethodOrigin<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> typeck::MethodOrigin<'tcx> {\n         match *self {\n             typeck::MethodStatic(def_id) => {\n                 typeck::MethodStatic(def_id)\n@@ -332,8 +333,8 @@ impl TypeFoldable for typeck::MethodOrigin {\n     }\n }\n \n-impl TypeFoldable for typeck::vtable_origin {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> typeck::vtable_origin {\n+impl<'tcx> TypeFoldable<'tcx> for typeck::vtable_origin<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> typeck::vtable_origin<'tcx> {\n         match *self {\n             typeck::vtable_static(def_id, ref substs, ref origins) => {\n                 let r_substs = substs.fold_with(folder);\n@@ -353,20 +354,20 @@ impl TypeFoldable for typeck::vtable_origin {\n     }\n }\n \n-impl TypeFoldable for ty::BuiltinBounds {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n+impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n         *self\n     }\n }\n \n-impl TypeFoldable for ty::ExistentialBounds {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds {\n         folder.fold_existential_bounds(*self)\n     }\n }\n \n-impl TypeFoldable for ty::ParamBounds {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ParamBounds {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ParamBounds<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ParamBounds<'tcx> {\n         ty::ParamBounds {\n             region_bounds: self.region_bounds.fold_with(folder),\n             builtin_bounds: self.builtin_bounds.fold_with(folder),\n@@ -375,8 +376,8 @@ impl TypeFoldable for ty::ParamBounds {\n     }\n }\n \n-impl TypeFoldable for ty::TypeParameterDef {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeParameterDef {\n+impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeParameterDef<'tcx> {\n         ty::TypeParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n@@ -389,8 +390,8 @@ impl TypeFoldable for ty::TypeParameterDef {\n     }\n }\n \n-impl TypeFoldable for ty::RegionParameterDef {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::RegionParameterDef {\n+impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::RegionParameterDef {\n         ty::RegionParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n@@ -401,26 +402,26 @@ impl TypeFoldable for ty::RegionParameterDef {\n     }\n }\n \n-impl TypeFoldable for ty::Generics {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Generics {\n+impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Generics<'tcx> {\n         ty::Generics {\n             types: self.types.fold_with(folder),\n             regions: self.regions.fold_with(folder),\n         }\n     }\n }\n \n-impl TypeFoldable for ty::GenericBounds {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericBounds {\n+impl<'tcx> TypeFoldable<'tcx> for ty::GenericBounds<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericBounds<'tcx> {\n         ty::GenericBounds {\n             types: self.types.fold_with(folder),\n             regions: self.regions.fold_with(folder),\n         }\n     }\n }\n \n-impl TypeFoldable for ty::UnsizeKind {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::UnsizeKind {\n+impl<'tcx> TypeFoldable<'tcx> for ty::UnsizeKind<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::UnsizeKind<'tcx> {\n         match *self {\n             ty::UnsizeLength(len) => ty::UnsizeLength(len),\n             ty::UnsizeStruct(box ref k, n) => ty::UnsizeStruct(box k.fold_with(folder), n),\n@@ -436,14 +437,14 @@ impl TypeFoldable for ty::UnsizeKind {\n     }\n }\n \n-impl TypeFoldable for traits::Obligation {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation {\n+impl<'tcx> TypeFoldable<'tcx> for traits::Obligation<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx> {\n         folder.fold_obligation(self)\n     }\n }\n \n-impl<N:TypeFoldable> TypeFoldable for traits::VtableImplData<N> {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImplData<N> {\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImplData<'tcx, N> {\n         traits::VtableImplData {\n             impl_def_id: self.impl_def_id,\n             substs: self.substs.fold_with(folder),\n@@ -452,16 +453,16 @@ impl<N:TypeFoldable> TypeFoldable for traits::VtableImplData<N> {\n     }\n }\n \n-impl<N:TypeFoldable> TypeFoldable for traits::VtableBuiltinData<N> {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableBuiltinData<N> {\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableBuiltinData<N> {\n         traits::VtableBuiltinData {\n             nested: self.nested.fold_with(folder),\n         }\n     }\n }\n \n-impl<N:TypeFoldable> TypeFoldable for traits::Vtable<N> {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<N> {\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<'tcx, N> {\n         match *self {\n             traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n             traits::VtableUnboxedClosure(d, ref s) => {\n@@ -473,8 +474,8 @@ impl<N:TypeFoldable> TypeFoldable for traits::Vtable<N> {\n     }\n }\n \n-impl TypeFoldable for traits::VtableParamData {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableParamData {\n+impl<'tcx> TypeFoldable<'tcx> for traits::VtableParamData<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableParamData<'tcx> {\n         traits::VtableParamData {\n             bound: self.bound.fold_with(folder),\n         }\n@@ -487,15 +488,15 @@ impl TypeFoldable for traits::VtableParamData {\n // They should invoke `foo.fold_with()` to do recursive folding.\n \n pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                t: ty::t)\n-                                                -> ty::t {\n-    let sty = ty::get(t).sty.fold_with(this);\n+                                                t: Ty<'tcx>)\n+                                                -> Ty<'tcx> {\n+    let sty = t.sty.fold_with(this);\n     ty::mk_t(this.tcx(), sty)\n }\n \n pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                    substs: &subst::Substs)\n-                                                    -> subst::Substs {\n+                                                    substs: &subst::Substs<'tcx>)\n+                                                    -> subst::Substs<'tcx> {\n     let regions = match substs.regions {\n         subst::ErasedRegions => {\n             subst::ErasedRegions\n@@ -510,8 +511,8 @@ pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_fn_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                    sig: &ty::FnSig)\n-                                                    -> ty::FnSig\n+                                                    sig: &ty::FnSig<'tcx>)\n+                                                    -> ty::FnSig<'tcx>\n {\n     this.enter_region_binder();\n     let result = super_fold_fn_sig_contents(this, sig);\n@@ -520,35 +521,35 @@ pub fn super_fold_fn_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_fn_sig_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                             sig: &ty::FnSig)\n-                                                             -> ty::FnSig\n+                                                             sig: &ty::FnSig<'tcx>)\n+                                                             -> ty::FnSig<'tcx>\n {\n     ty::FnSig { inputs: sig.inputs.fold_with(this),\n                 output: sig.output.fold_with(this),\n                 variadic: sig.variadic }\n }\n \n pub fn super_fold_output<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                    output: &ty::FnOutput)\n-                                                    -> ty::FnOutput {\n+                                                    output: &ty::FnOutput<'tcx>)\n+                                                    -> ty::FnOutput<'tcx> {\n     match *output {\n         ty::FnConverging(ref ty) => ty::FnConverging(ty.fold_with(this)),\n         ty::FnDiverging => ty::FnDiverging\n     }\n }\n \n pub fn super_fold_bare_fn_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                        fty: &ty::BareFnTy)\n-                                                        -> ty::BareFnTy\n+                                                        fty: &ty::BareFnTy<'tcx>)\n+                                                        -> ty::BareFnTy<'tcx>\n {\n     ty::BareFnTy { sig: fty.sig.fold_with(this),\n                    abi: fty.abi,\n                    fn_style: fty.fn_style }\n }\n \n pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                        fty: &ty::ClosureTy)\n-                                                        -> ty::ClosureTy\n+                                                        fty: &ty::ClosureTy<'tcx>)\n+                                                        -> ty::ClosureTy<'tcx>\n {\n     ty::ClosureTy {\n         store: fty.store.fold_with(this),\n@@ -561,8 +562,8 @@ pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                       t: &ty::TraitRef)\n-                                                       -> ty::TraitRef\n+                                                       t: &ty::TraitRef<'tcx>)\n+                                                       -> ty::TraitRef<'tcx>\n {\n     this.enter_region_binder();\n     let result = super_fold_trait_ref_contents(this, t);\n@@ -571,8 +572,8 @@ pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_trait_ref_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                                t: &ty::TraitRef)\n-                                                                -> ty::TraitRef\n+                                                                t: &ty::TraitRef<'tcx>)\n+                                                                -> ty::TraitRef<'tcx>\n {\n     ty::TraitRef {\n         def_id: t.def_id,\n@@ -581,13 +582,15 @@ pub fn super_fold_trait_ref_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_mt<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                mt: &ty::mt) -> ty::mt {\n+                                                mt: &ty::mt<'tcx>)\n+                                                -> ty::mt<'tcx> {\n     ty::mt {ty: mt.ty.fold_with(this),\n             mutbl: mt.mutbl}\n }\n \n pub fn super_fold_sty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                 sty: &ty::sty) -> ty::sty {\n+                                                 sty: &ty::sty<'tcx>)\n+                                                 -> ty::sty<'tcx> {\n     match *sty {\n         ty::ty_uniq(typ) => {\n             ty::ty_uniq(typ.fold_with(this))\n@@ -658,8 +661,8 @@ pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_autoref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                     autoref: &ty::AutoRef)\n-                                                     -> ty::AutoRef\n+                                                     autoref: &ty::AutoRef<'tcx>)\n+                                                     -> ty::AutoRef<'tcx>\n {\n     match *autoref {\n         ty::AutoPtr(r, m, None) => ty::AutoPtr(this.fold_region(r), m, None),\n@@ -676,17 +679,17 @@ pub fn super_fold_autoref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_item_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                         substs: ty::ItemSubsts)\n-                                                         -> ty::ItemSubsts\n+                                                         substs: ty::ItemSubsts<'tcx>)\n+                                                         -> ty::ItemSubsts<'tcx>\n {\n     ty::ItemSubsts {\n         substs: substs.substs.fold_with(this),\n     }\n }\n \n pub fn super_fold_obligation<'tcx, T:TypeFolder<'tcx>>(this: &mut T,\n-                                                       obligation: &traits::Obligation)\n-                                                       -> traits::Obligation\n+                                                       obligation: &traits::Obligation<'tcx>)\n+                                                       -> traits::Obligation<'tcx>\n {\n     traits::Obligation {\n         cause: obligation.cause,\n@@ -701,32 +704,32 @@ pub fn super_fold_obligation<'tcx, T:TypeFolder<'tcx>>(this: &mut T,\n /**\n  * Designates a \"binder\" for late-bound regions.\n  */\n-pub trait HigherRankedFoldable : Repr {\n+pub trait HigherRankedFoldable<'tcx>: Repr<'tcx> {\n     /// Folds the contents of `self`, ignoring the region binder created\n     /// by `self`.\n-    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n+    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n-impl HigherRankedFoldable for ty::FnSig {\n-    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig {\n+impl<'tcx> HigherRankedFoldable<'tcx> for ty::FnSig<'tcx> {\n+    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig<'tcx> {\n         super_fold_fn_sig_contents(folder, self)\n     }\n }\n \n-impl HigherRankedFoldable for ty::TraitRef {\n-    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef {\n+impl<'tcx> HigherRankedFoldable<'tcx> for ty::TraitRef<'tcx> {\n+    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n         super_fold_trait_ref_contents(folder, self)\n     }\n }\n \n-impl<T:TypeFoldable+Repr> HigherRankedFoldable for ty::Binder<T> {\n-    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n+impl<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>> HigherRankedFoldable<'tcx> for ty::Binder<T> {\n+    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         ty::bind(self.value.fold_with(folder))\n     }\n }\n \n-impl<T:HigherRankedFoldable> HigherRankedFoldable for Rc<T> {\n-    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n+impl<'tcx, T:HigherRankedFoldable<'tcx>> HigherRankedFoldable<'tcx> for Rc<T> {\n+    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n         Rc::new((**self).fold_contents(folder))\n     }\n }\n@@ -736,13 +739,13 @@ impl<T:HigherRankedFoldable> HigherRankedFoldable for Rc<T> {\n \n pub struct BottomUpFolder<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub fldop: |ty::t|: 'a -> ty::t,\n+    pub fldop: |Ty<'tcx>|: 'a -> Ty<'tcx>,\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n-    fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let t1 = super_fold_ty(self, ty);\n         (self.fldop)(t1)\n     }\n@@ -754,7 +757,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n /// Folds over the substructure of a type, visiting its component\n /// types and all regions that occur *free* within it.\n ///\n-/// That is, `ty::t` can contain function or method types that bind\n+/// That is, `Ty` can contain function or method types that bind\n /// regions at the call site (`ReLateBound`), and occurrences of\n /// regions (aka \"lifetimes\") that are bound within a type are not\n /// visited by this folder; only regions that occur free will be\n@@ -816,7 +819,7 @@ pub struct RegionEraser<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n }\n \n-pub fn erase_regions<T:TypeFoldable>(tcx: &ty::ctxt, t: T) -> T {\n+pub fn erase_regions<'tcx, T: TypeFoldable<'tcx>>(tcx: &ty::ctxt<'tcx>, t: T) -> T {\n     let mut eraser = RegionEraser { tcx: tcx };\n     t.fold_with(&mut eraser)\n }\n@@ -852,7 +855,8 @@ pub fn shift_region(region: ty::Region, amount: uint) -> ty::Region {\n     }\n }\n \n-pub fn shift_regions<T:TypeFoldable+Repr>(tcx: &ty::ctxt, amount: uint, value: &T) -> T {\n+pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>>(tcx: &ty::ctxt<'tcx>,\n+                                                            amount: uint, value: &T) -> T {\n     debug!(\"shift_regions(value={}, amount={})\",\n            value.repr(tcx), amount);\n "}, {"sha": "ea652bc7e6599cc393b06e7135277d0a89d48562", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -53,7 +53,7 @@ use middle::def;\n use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::lookup_def_tcx;\n use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope,\n                              ShiftedRscope, BindingRscope};\n@@ -71,26 +71,26 @@ use syntax::print::pprust;\n \n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype;\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef>;\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx>;\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>>;\n \n     /// What type should we use when a type is omitted?\n-    fn ty_infer(&self, span: Span) -> ty::t;\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n \n     /// Returns true if associated types from the given trait and type are\n     /// allowed to be used here and false otherwise.\n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: ty::t,\n+                                           ty: Ty<'tcx>,\n                                            trait_id: ast::DefId)\n                                            -> bool;\n \n     /// Returns the binding of the given associated type for some type.\n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<ty::t>,\n+                               ty: Option<Ty<'tcx>>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t;\n+                               -> Ty<'tcx>;\n }\n \n pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n@@ -205,11 +205,11 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     decl_def_id: ast::DefId,\n-    decl_generics: &ty::Generics,\n-    self_ty: Option<ty::t>,\n-    associated_ty: Option<ty::t>,\n+    decl_generics: &ty::Generics<'tcx>,\n+    self_ty: Option<Ty<'tcx>>,\n+    associated_ty: Option<Ty<'tcx>>,\n     path: &ast::Path)\n-    -> Substs\n+    -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     /*!\n@@ -251,12 +251,12 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n     rscope: &RS,\n     span: Span,\n     decl_def_id: ast::DefId,\n-    decl_generics: &ty::Generics,\n-    self_ty: Option<ty::t>,\n-    types: Vec<ty::t>,\n+    decl_generics: &ty::Generics<'tcx>,\n+    self_ty: Option<Ty<'tcx>>,\n+    types: Vec<Ty<'tcx>>,\n     regions: Vec<ty::Region>,\n-    associated_ty: Option<ty::t>)\n-    -> Substs\n+    associated_ty: Option<Ty<'tcx>>)\n+    -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let tcx = this.tcx();\n@@ -377,7 +377,7 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n                                                     rscope: &RS,\n                                                     data: &ast::AngleBracketedParameterData)\n-                                                    -> (Vec<ty::Region>, Vec<ty::t>)\n+                                                    -> (Vec<ty::Region>, Vec<Ty<'tcx>>)\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let regions: Vec<_> =\n@@ -395,7 +395,7 @@ fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n \n fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n                                              data: &ast::ParenthesizedParameterData)\n-                                             -> Vec<ty::t>\n+                                             -> Vec<Ty<'tcx>>\n     where AC: AstConv<'tcx>\n {\n     let binding_rscope = BindingRscope::new();\n@@ -417,9 +417,9 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     ast_trait_ref: &ast::PolyTraitRef,\n-    self_ty: Option<ty::t>,\n-    associated_type: Option<ty::t>)\n-    -> Rc<ty::TraitRef>\n+    self_ty: Option<Ty<'tcx>>,\n+    associated_type: Option<Ty<'tcx>>)\n+    -> Rc<ty::TraitRef<'tcx>>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, associated_type)\n@@ -428,9 +428,9 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          rscope: &RS,\n                                          ast_trait_ref: &ast::TraitRef,\n-                                         self_ty: Option<ty::t>,\n-                                         associated_type: Option<ty::t>)\n-                                         -> Rc<ty::TraitRef>\n+                                         self_ty: Option<Ty<'tcx>>,\n+                                         associated_type: Option<Ty<'tcx>>)\n+                                         -> Rc<ty::TraitRef<'tcx>>\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope\n {\n@@ -462,10 +462,10 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     trait_def_id: ast::DefId,\n-    self_ty: Option<ty::t>,\n-    associated_type: Option<ty::t>,\n+    self_ty: Option<Ty<'tcx>>,\n+    associated_type: Option<Ty<'tcx>>,\n     path: &ast::Path)\n-    -> ty::TraitRef\n+    -> ty::TraitRef<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let trait_def = this.get_trait_def(trait_def_id);\n@@ -504,7 +504,7 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     rscope: &RS,\n     did: ast::DefId,\n     path: &ast::Path)\n-    -> TypeAndSubsts\n+    -> TypeAndSubsts<'tcx>\n {\n     let tcx = this.tcx();\n     let ty::Polytype {\n@@ -533,7 +533,7 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n     rscope: &RS,\n     did: ast::DefId,\n     path: &ast::Path)\n-    -> TypeAndSubsts\n+    -> TypeAndSubsts<'tcx>\n     where AC : AstConv<'tcx>, RS : RegionScope\n {\n     let tcx = this.tcx();\n@@ -589,7 +589,8 @@ fn check_path_args(tcx: &ty::ctxt,\n     }\n }\n \n-pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n+pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n+                               -> Option<Ty<'tcx>> {\n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n             let a_def = match tcx.def_map.borrow().get(&id) {\n@@ -641,7 +642,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         this: &AC,\n         rscope: &RS,\n         ast_ty: &ast::Ty)\n-        -> Option<ty::t> {\n+        -> Option<Ty<'tcx>> {\n     match ast_ty_to_prim_ty(this.tcx(), ast_ty) {\n         Some(typ) => return Some(typ),\n         None => {}\n@@ -666,7 +667,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 def::DefTy(did, _) |\n                 def::DefStruct(did) if Some(did) == this.tcx().lang_items.owned_box() => {\n                     let ty = ast_path_to_ty(this, rscope, did, path).ty;\n-                    match ty::get(ty).sty {\n+                    match ty.sty {\n                         ty::ty_struct(struct_def_id, ref substs) => {\n                             assert_eq!(struct_def_id, did);\n                             assert_eq!(substs.types.len(TypeSpace), 1);\n@@ -697,8 +698,8 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         a_seq_mutbl: ast::Mutability,\n         a_seq_ty: &ast::Ty,\n         region: ty::Region,\n-        constr: |ty::t| -> ty::t)\n-        -> ty::t\n+        constr: |Ty<'tcx>| -> Ty<'tcx>)\n+        -> Ty<'tcx>\n {\n     let tcx = this.tcx();\n \n@@ -755,7 +756,7 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                    for_ast_type: &ast::Ty,\n                                    trait_type_id: ast::DefId,\n                                    span: Span)\n-                                   -> ty::t\n+                                   -> Ty<'tcx>\n                                    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     debug!(\"associated_ty_to_ty(trait_path={}, for_ast_type={}, trait_type_id={})\",\n@@ -811,7 +812,7 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type.\n pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t\n+        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> Ty<'tcx>\n {\n     debug!(\"ast_ty_to_ty(ast_ty={})\",\n            ast_ty.repr(this.tcx()));\n@@ -1060,28 +1061,28 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n pub fn ty_of_arg<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(this: &AC, rscope: &RS,\n                                                            a: &ast::Arg,\n-                                                           expected_ty: Option<ty::t>)\n-                                                           -> ty::t {\n+                                                           expected_ty: Option<Ty<'tcx>>)\n+                                                           -> Ty<'tcx> {\n     match a.ty.node {\n         ast::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::TyInfer => this.ty_infer(a.ty.span),\n         _ => ast_ty_to_ty(this, rscope, &*a.ty),\n     }\n }\n \n-struct SelfInfo<'a> {\n-    untransformed_self_ty: ty::t,\n+struct SelfInfo<'a, 'tcx> {\n+    untransformed_self_ty: Ty<'tcx>,\n     explicit_self: &'a ast::ExplicitSelf,\n }\n \n pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n                     this: &AC,\n                     fn_style: ast::FnStyle,\n-                    untransformed_self_ty: ty::t,\n+                    untransformed_self_ty: Ty<'tcx>,\n                     explicit_self: &ast::ExplicitSelf,\n                     decl: &ast::FnDecl,\n                     abi: abi::Abi)\n-                    -> (ty::BareFnTy, ty::ExplicitSelfCategory) {\n+                    -> (ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n     let self_info = Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n         explicit_self: explicit_self,\n@@ -1096,18 +1097,18 @@ pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n }\n \n pub fn ty_of_bare_fn<'tcx, AC: AstConv<'tcx>>(this: &AC, fn_style: ast::FnStyle, abi: abi::Abi,\n-                                              decl: &ast::FnDecl) -> ty::BareFnTy {\n+                                              decl: &ast::FnDecl) -> ty::BareFnTy<'tcx> {\n     let (bare_fn_ty, _) = ty_of_method_or_bare_fn(this, fn_style, abi, None, decl);\n     bare_fn_ty\n }\n \n-fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n+fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n                            this: &AC,\n                            fn_style: ast::FnStyle,\n                            abi: abi::Abi,\n-                           opt_self_info: Option<SelfInfo>,\n+                           opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n                            decl: &ast::FnDecl)\n-                           -> (ty::BareFnTy,\n+                           -> (ty::BareFnTy<'tcx>,\n                                Option<ty::ExplicitSelfCategory>) {\n     debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -1163,7 +1164,7 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n     let input_pats: Vec<String> = input_params.iter()\n                                               .map(|a| pprust::pat_to_string(&*a.pat))\n                                               .collect();\n-    let self_and_input_tys: Vec<ty::t> =\n+    let self_and_input_tys: Vec<Ty> =\n         self_ty.into_iter().chain(input_tys).collect();\n \n     let mut lifetimes_for_params: Vec<(String, Vec<ty::Region>)> = Vec::new();\n@@ -1229,11 +1230,11 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n     }, explicit_self_category_result)\n }\n \n-fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n+fn determine_explicit_self_category<'a, 'tcx, AC: AstConv<'tcx>,\n                                     RS:RegionScope>(\n                                     this: &AC,\n                                     rscope: &RS,\n-                                    self_info: &SelfInfo)\n+                                    self_info: &SelfInfo<'a, 'tcx>)\n                                     -> ty::ExplicitSelfCategory\n {\n     return match self_info.explicit_self.node {\n@@ -1293,7 +1294,7 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n             if impl_modifiers >= method_modifiers {\n                 ty::ByValueExplicitSelfCategory\n             } else {\n-                match ty::get(explicit_type).sty {\n+                match explicit_type.sty {\n                     ty::ty_rptr(r, mt) => ty::ByReferenceExplicitSelfCategory(r, mt.mutbl),\n                     ty::ty_uniq(_) => ty::ByBoxExplicitSelfCategory,\n                     _ => ty::ByValueExplicitSelfCategory,\n@@ -1302,8 +1303,8 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n         }\n     };\n \n-    fn count_modifiers(ty: ty::t) -> uint {\n-        match ty::get(ty).sty {\n+    fn count_modifiers(ty: Ty) -> uint {\n+        match ty.sty {\n             ty::ty_rptr(_, mt) => count_modifiers(mt.ty) + 1,\n             ty::ty_uniq(t) => count_modifiers(t) + 1,\n             _ => 0,\n@@ -1319,8 +1320,8 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n     store: ty::TraitStore,\n     decl: &ast::FnDecl,\n     abi: abi::Abi,\n-    expected_sig: Option<ty::FnSig>)\n-    -> ty::ClosureTy\n+    expected_sig: Option<ty::FnSig<'tcx>>)\n+    -> ty::ClosureTy<'tcx>\n {\n     debug!(\"ty_of_closure(expected_sig={})\",\n            expected_sig.repr(this.tcx()));\n@@ -1373,7 +1374,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    main_trait_refs: &[Rc<ty::TraitRef>],\n+    main_trait_refs: &[Rc<ty::TraitRef<'tcx>>],\n     ast_bounds: &[ast::TyParamBound])\n     -> ty::ExistentialBounds\n {\n@@ -1402,7 +1403,7 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n     rscope: &RS,\n     span: Span,\n     ast_bounds: &[ast::TyParamBound])\n-    -> ty::t\n+    -> Ty<'tcx>\n     where AC: AstConv<'tcx>, RS:RegionScope\n {\n     let ast_bounds: Vec<&ast::TyParamBound> = ast_bounds.iter().collect();\n@@ -1436,7 +1437,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    main_trait_refs: &[Rc<ty::TraitRef>],\n+    main_trait_refs: &[Rc<ty::TraitRef<'tcx>>],\n     partitioned_bounds: PartitionedBounds)\n     -> ty::ExistentialBounds\n     where AC: AstConv<'tcx>, RS:RegionScope\n@@ -1483,12 +1484,12 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n     }\n }\n \n-pub fn compute_opt_region_bound(tcx: &ty::ctxt,\n-                                span: Span,\n-                                builtin_bounds: ty::BuiltinBounds,\n-                                region_bounds: &[&ast::Lifetime],\n-                                trait_bounds: &[Rc<ty::TraitRef>])\n-                                -> Option<ty::Region>\n+pub fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      span: Span,\n+                                      builtin_bounds: ty::BuiltinBounds,\n+                                      region_bounds: &[&ast::Lifetime],\n+                                      trait_bounds: &[Rc<ty::TraitRef<'tcx>>])\n+                                      -> Option<ty::Region>\n {\n     /*!\n      * Given the bounds on a type parameter / existential type,\n@@ -1552,7 +1553,7 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     span: Span,\n     builtin_bounds: ty::BuiltinBounds,\n     region_bounds: &[&ast::Lifetime],\n-    trait_bounds: &[Rc<ty::TraitRef>])\n+    trait_bounds: &[Rc<ty::TraitRef<'tcx>>])\n     -> ty::Region\n {\n     /*!"}, {"sha": "92b30cd7af8f76e97d1288ab41602dda11fdee14", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -11,7 +11,7 @@\n use middle::def;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n use middle::subst::{Subst, Substs};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::check::{check_expr, check_expr_has_type, demand, FnCtxt};\n use middle::typeck::check::{instantiate_path, structurally_resolved_type, valid_range_bounds};\n use middle::typeck::infer::{mod, resolve};\n@@ -27,7 +27,8 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n \n-pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n+pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n+                           pat: &ast::Pat, expected: Ty<'tcx>) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n@@ -164,7 +165,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         ast::PatVec(ref before, ref slice, ref after) => {\n             let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n             let inner_ty = fcx.infcx().next_ty_var();\n-            let pat_ty = match ty::get(expected_ty).sty {\n+            let pat_ty = match expected_ty.sty {\n                 ty::ty_vec(_, Some(size)) => ty::mk_vec(tcx, inner_ty, Some({\n                     let min_len = before.len() + after.len();\n                     match *slice {\n@@ -207,15 +208,16 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n     }\n }\n \n-pub fn check_dereferencable(pcx: &pat_ctxt, span: Span, expected: ty::t,\n-                            inner: &ast::Pat) -> bool {\n+pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n+                                      span: Span, expected: Ty<'tcx>,\n+                                      inner: &ast::Pat) -> bool {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n     match infer::resolve_type(\n         fcx.infcx(), Some(span),\n         expected, resolve::try_resolve_tvar_shallow) {\n         Ok(t) if pat_is_binding(&tcx.def_map, inner) => {\n-            ty::deref(t, true).map_or(true, |mt| match ty::get(mt.ty).sty {\n+            ty::deref(t, true).map_or(true, |mt| match mt.ty.sty {\n                 ty::ty_trait(_) => {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n@@ -290,9 +292,9 @@ pub struct pat_ctxt<'a, 'tcx: 'a> {\n     pub map: PatIdMap,\n }\n \n-pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n-                        path: &ast::Path, fields: &[Spanned<ast::FieldPat>],\n-                        etc: bool, expected: ty::t) {\n+pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n+                                  path: &ast::Path, fields: &[Spanned<ast::FieldPat>],\n+                                  etc: bool, expected: Ty<'tcx>) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n@@ -311,7 +313,7 @@ pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n         },\n         _ => {\n             let def_type = ty::lookup_item_type(tcx, def.def_id());\n-            match ty::get(def_type.ty).sty {\n+            match def_type.ty.sty {\n                 ty::ty_struct(struct_def_id, _) =>\n                     (struct_def_id, struct_def_id),\n                 ty::ty_enum(enum_def_id, _)\n@@ -349,9 +351,9 @@ pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n                             variant_def_id, etc);\n }\n \n-pub fn check_pat_enum(pcx: &pat_ctxt, pat: &ast::Pat,\n-                      path: &ast::Path, subpats: &Option<Vec<P<ast::Pat>>>,\n-                      expected: ty::t) {\n+pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n+                                path: &ast::Path, subpats: &Option<Vec<P<ast::Pat>>>,\n+                                expected: Ty<'tcx>) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n@@ -376,7 +378,7 @@ pub fn check_pat_enum(pcx: &pat_ctxt, pat: &ast::Pat,\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n     let real_path_ty = fcx.node_ty(pat.id);\n-    let (arg_tys, kind_name) = match ty::get(real_path_ty).sty {\n+    let (arg_tys, kind_name) = match real_path_ty.sty {\n         ty::ty_enum(enum_def_id, ref expected_substs) => {\n             let variant = ty::enum_variant_with_id(tcx, enum_def_id, def.def_id());\n             (variant.args.iter().map(|t| t.subst(tcx, expected_substs)).collect::<Vec<_>>(),\n@@ -434,12 +436,12 @@ pub fn check_pat_enum(pcx: &pat_ctxt, pat: &ast::Pat,\n /// `struct_fields` describes the type of each field of the struct.\n /// `struct_id` is the ID of the struct.\n /// `etc` is true if the pattern said '...' and false otherwise.\n-pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n-                               span: Span,\n-                               fields: &[Spanned<ast::FieldPat>],\n-                               struct_fields: &[ty::field],\n-                               struct_id: ast::DefId,\n-                               etc: bool) {\n+pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n+                                         span: Span,\n+                                         fields: &[Spanned<ast::FieldPat>],\n+                                         struct_fields: &[ty::field<'tcx>],\n+                                         struct_id: ast::DefId,\n+                                         etc: bool) {\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Index the struct fields' types."}, {"sha": "1e45d059b849ba018c79427659bae56d06639d0f", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::check::FnCtxt;\n use middle::typeck::infer;\n use middle::typeck::infer::resolve_type;\n@@ -23,22 +23,24 @@ use util::ppaux::Repr;\n \n // Requires that the two types unify, and prints an error message if they\n // don't.\n-pub fn suptype(fcx: &FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     suptype_with_fn(fcx, sp, false, expected, actual,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn subtype(fcx: &FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn subtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     suptype_with_fn(fcx, sp, true, actual, expected,\n         |sp, a, e, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn suptype_with_fn(fcx: &FnCtxt,\n-                       sp: Span,\n-                       b_is_expected: bool,\n-                       ty_a: ty::t,\n-                       ty_b: ty::t,\n-                       handle_err: |Span, ty::t, ty::t, &ty::type_err|) {\n+pub fn suptype_with_fn<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                 sp: Span,\n+                                 b_is_expected: bool,\n+                                 ty_a: Ty<'tcx>,\n+                                 ty_b: Ty<'tcx>,\n+                                 handle_err: |Span, Ty<'tcx>, Ty<'tcx>, &ty::type_err<'tcx>|) {\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),\n                           ty_b, ty_a) {\n@@ -49,7 +51,8 @@ pub fn suptype_with_fn(fcx: &FnCtxt,\n     }\n }\n \n-pub fn eqtype(fcx: &FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                        expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => {\n@@ -59,7 +62,8 @@ pub fn eqtype(fcx: &FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n }\n \n // Checks that the type `actual` can be coerced to `expected`.\n-pub fn coerce(fcx: &FnCtxt, sp: Span, expected: ty::t, expr: &ast::Expr) {\n+pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                        expected: Ty<'tcx>, expr: &ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     debug!(\"demand::coerce(expected = {}, expr_ty = {})\",\n            expected.repr(fcx.ccx.tcx),"}, {"sha": "af8ef09d2a072865fae7816f499d68de6a32dde6", "filename": "src/librustc/middle/typeck/check/method/confirm.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -13,7 +13,7 @@ use super::probe;\n use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::check;\n use middle::typeck::check::{FnCtxt, NoPreference, PreferMutLvalue};\n use middle::typeck::{MethodCall, MethodCallee, MethodObject, MethodOrigin,\n@@ -33,34 +33,33 @@ struct ConfirmContext<'a, 'tcx:'a> {\n     self_expr: &'a ast::Expr,\n }\n \n-struct InstantiatedMethodSig {\n+struct InstantiatedMethodSig<'tcx> {\n     /// Function signature of the method being invoked. The 0th\n     /// argument is the receiver.\n-    method_sig: ty::FnSig,\n+    method_sig: ty::FnSig<'tcx>,\n \n     /// Substitutions for all types/early-bound-regions declared on\n     /// the method.\n-    all_substs: subst::Substs,\n+    all_substs: subst::Substs<'tcx>,\n \n     /// Substitution to use when adding obligations from the method\n     /// bounds. Normally equal to `all_substs` except for object\n     /// receivers. See FIXME in instantiate_method_sig() for\n     /// explanation.\n-    method_bounds_substs: subst::Substs,\n+    method_bounds_substs: subst::Substs<'tcx>,\n \n     /// Generic bounds on the method's parameters which must be added\n     /// as pending obligations.\n-    method_bounds: ty::GenericBounds,\n+    method_bounds: ty::GenericBounds<'tcx>,\n }\n \n-\n-pub fn confirm(fcx: &FnCtxt,\n-               span: Span,\n-               self_expr: &ast::Expr,\n-               unadjusted_self_ty: ty::t,\n-               pick: probe::Pick,\n-               supplied_method_types: Vec<ty::t>)\n-               -> MethodCallee\n+pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                         span: Span,\n+                         self_expr: &ast::Expr,\n+                         unadjusted_self_ty: Ty<'tcx>,\n+                         pick: probe::Pick<'tcx>,\n+                         supplied_method_types: Vec<Ty<'tcx>>)\n+                         -> MethodCallee<'tcx>\n {\n     debug!(\"confirm(unadjusted_self_ty={}, pick={}, supplied_method_types={})\",\n            unadjusted_self_ty.repr(fcx.tcx()),\n@@ -81,10 +80,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn confirm(&mut self,\n-               unadjusted_self_ty: ty::t,\n-               pick: probe::Pick,\n-               supplied_method_types: Vec<ty::t>)\n-               -> MethodCallee\n+               unadjusted_self_ty: Ty<'tcx>,\n+               pick: probe::Pick<'tcx>,\n+               supplied_method_types: Vec<Ty<'tcx>>)\n+               -> MethodCallee<'tcx>\n     {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick.adjustment);\n@@ -136,9 +135,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     // ADJUSTMENTS\n \n     fn adjust_self_ty(&mut self,\n-                      unadjusted_self_ty: ty::t,\n+                      unadjusted_self_ty: Ty<'tcx>,\n                       adjustment: &probe::PickAdjustment)\n-                      -> ty::t\n+                      -> Ty<'tcx>\n     {\n         // Construct the actual adjustment and write it into the table\n         let auto_deref_ref = self.create_ty_adjustment(adjustment);\n@@ -164,7 +163,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n     fn create_ty_adjustment(&mut self,\n                             adjustment: &probe::PickAdjustment)\n-                            -> ty::AutoDerefRef\n+                            -> ty::AutoDerefRef<'tcx>\n     {\n         match *adjustment {\n             probe::AutoDeref(num) => {\n@@ -191,9 +190,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     //\n \n     fn fresh_receiver_substs(&mut self,\n-                             self_ty: ty::t,\n-                             pick: &probe::Pick)\n-                             -> (subst::Substs, MethodOrigin)\n+                             self_ty: Ty<'tcx>,\n+                             pick: &probe::Pick<'tcx>)\n+                             -> (subst::Substs<'tcx>, MethodOrigin<'tcx>)\n     {\n         /*!\n          * Returns a set of substitutions for the method *receiver*\n@@ -292,8 +291,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn extract_trait_ref<R>(&mut self,\n-                            self_ty: ty::t,\n-                            closure: |&mut ConfirmContext<'a,'tcx>, ty::t, &ty::TyTrait| -> R)\n+                            self_ty: Ty<'tcx>,\n+                            closure: |&mut ConfirmContext<'a,'tcx>,\n+                                      Ty<'tcx>, &ty::TyTrait<'tcx>| -> R)\n                             -> R\n     {\n         // If we specified that this is an object method, then the\n@@ -305,7 +305,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             check::autoderef(\n                 self.fcx, self.span, self_ty, None, NoPreference,\n                 |ty, _| {\n-                    match ty::get(ty).sty {\n+                    match ty.sty {\n                         ty::ty_trait(ref data) => Some(closure(self, ty, &**data)),\n                         _ => None,\n                     }\n@@ -323,9 +323,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn instantiate_method_substs(&mut self,\n-                                 pick: &probe::Pick,\n-                                 supplied_method_types: Vec<ty::t>)\n-                                 -> (Vec<ty::t>, Vec<ty::Region>)\n+                                 pick: &probe::Pick<'tcx>,\n+                                 supplied_method_types: Vec<Ty<'tcx>>)\n+                                 -> (Vec<Ty<'tcx>>, Vec<ty::Region>)\n     {\n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n@@ -361,8 +361,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn unify_receivers(&mut self,\n-                       self_ty: ty::t,\n-                       method_self_ty: ty::t)\n+                       self_ty: Ty<'tcx>,\n+                       method_self_ty: Ty<'tcx>)\n     {\n         match self.fcx.mk_subty(false, infer::Misc(self.span), self_ty, method_self_ty) {\n             Ok(_) => {}\n@@ -381,9 +381,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     //\n \n     fn instantiate_method_sig(&mut self,\n-                              pick: &probe::Pick,\n-                              all_substs: subst::Substs)\n-                              -> InstantiatedMethodSig\n+                              pick: &probe::Pick<'tcx>,\n+                              all_substs: subst::Substs<'tcx>)\n+                              -> InstantiatedMethodSig<'tcx>\n     {\n         // If this method comes from an impl (as opposed to a trait),\n         // it may have late-bound regions from the impl that appear in\n@@ -457,9 +457,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn add_obligations(&mut self,\n-                       pick: &probe::Pick,\n-                       method_bounds_substs: &subst::Substs,\n-                       method_bounds: &ty::GenericBounds) {\n+                       pick: &probe::Pick<'tcx>,\n+                       method_bounds_substs: &subst::Substs<'tcx>,\n+                       method_bounds: &ty::GenericBounds<'tcx>) {\n         debug!(\"add_obligations: pick={} method_bounds_substs={} method_bounds={}\",\n                pick.repr(self.tcx()),\n                method_bounds_substs.repr(self.tcx()),\n@@ -482,13 +482,13 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n          * `DerefMut` and `IndexMut` respectively.\n          */\n \n-        let sig = match ty::get(method_callee.ty).sty {\n+        let sig = match method_callee.ty.sty {\n             ty::ty_bare_fn(ref f) => f.sig.clone(),\n             ty::ty_closure(ref f) => f.sig.clone(),\n             _ => return,\n         };\n \n-        match ty::get(sig.inputs[0]).sty {\n+        match sig.inputs[0].sty {\n             ty::ty_rptr(_, ty::mt {\n                 ty: _,\n                 mutbl: ast::MutMutable,\n@@ -647,9 +647,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn upcast(&mut self,\n-              source_trait_ref: Rc<ty::TraitRef>,\n+              source_trait_ref: Rc<ty::TraitRef<'tcx>>,\n               target_trait_def_id: ast::DefId)\n-              -> Rc<ty::TraitRef>\n+              -> Rc<ty::TraitRef<'tcx>>\n     {\n         for super_trait_ref in traits::supertraits(self.tcx(), source_trait_ref.clone()) {\n             if super_trait_ref.def_id == target_trait_def_id {\n@@ -665,16 +665,16 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &T) -> T\n-        where T : HigherRankedFoldable\n+        where T : HigherRankedFoldable<'tcx>\n     {\n         self.infcx().replace_late_bound_regions_with_fresh_var(\n             self.span, infer::FnCall, value).0\n     }\n }\n \n-fn wrap_autoref(mut deref: ty::AutoDerefRef,\n-                base_fn: |Option<Box<ty::AutoRef>>| -> ty::AutoRef)\n-                -> ty::AutoDerefRef {\n+fn wrap_autoref<'tcx>(mut deref: ty::AutoDerefRef<'tcx>,\n+                      base_fn: |Option<Box<ty::AutoRef<'tcx>>>| -> ty::AutoRef<'tcx>)\n+                      -> ty::AutoDerefRef<'tcx> {\n     let autoref = mem::replace(&mut deref.autoref, None);\n     let autoref = autoref.map(|r| box r);\n     deref.autoref = Some(base_fn(autoref));"}, {"sha": "411948ed6b4acffd44da09d70c5d84dd9d39fac7", "filename": "src/librustc/middle/typeck/check/method/mod.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -56,12 +56,12 @@ pub enum CandidateSource {\n \n type MethodIndex = uint; // just for doc purposes\n \n-pub fn exists(fcx: &FnCtxt,\n-              span: Span,\n-              method_name: ast::Name,\n-              self_ty: ty::t,\n-              call_expr_id: ast::NodeId)\n-              -> bool\n+pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                        span: Span,\n+                        method_name: ast::Name,\n+                        self_ty: Ty<'tcx>,\n+                        call_expr_id: ast::NodeId)\n+                        -> bool\n {\n     /*!\n      * Determines whether the type `self_ty` supports a method name `method_name` or not.\n@@ -74,14 +74,14 @@ pub fn exists(fcx: &FnCtxt,\n     }\n }\n \n-pub fn lookup(fcx: &FnCtxt,\n-              span: Span,\n-              method_name: ast::Name,\n-              self_ty: ty::t,\n-              supplied_method_types: Vec<ty::t>,\n-              call_expr_id: ast::NodeId,\n-              self_expr: &ast::Expr)\n-              -> Result<MethodCallee, MethodError>\n+pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                        span: Span,\n+                        method_name: ast::Name,\n+                        self_ty: Ty<'tcx>,\n+                        supplied_method_types: Vec<Ty<'tcx>>,\n+                        call_expr_id: ast::NodeId,\n+                        self_expr: &ast::Expr)\n+                        -> Result<MethodCallee<'tcx>, MethodError>\n {\n     /*!\n      * Performs method lookup. If lookup is successful, it will return the callee\n@@ -115,9 +115,9 @@ pub fn lookup_in_trait<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                  self_expr: Option<&'a ast::Expr>,\n                                  m_name: ast::Name,\n                                  trait_def_id: DefId,\n-                                 self_ty: ty::t,\n-                                 opt_input_types: Option<Vec<ty::t>>)\n-                                 -> Option<MethodCallee>\n+                                 self_ty: Ty<'tcx>,\n+                                 opt_input_types: Option<Vec<Ty<'tcx>>>)\n+                                 -> Option<MethodCallee<'tcx>>\n {\n     lookup_in_trait_adjusted(fcx, span, self_expr, m_name, trait_def_id,\n                              ty::AutoDerefRef { autoderefs: 0, autoref: None },\n@@ -129,10 +129,10 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                           self_expr: Option<&'a ast::Expr>,\n                                           m_name: ast::Name,\n                                           trait_def_id: DefId,\n-                                          autoderefref: ty::AutoDerefRef,\n-                                          self_ty: ty::t,\n-                                          opt_input_types: Option<Vec<ty::t>>)\n-                                          -> Option<MethodCallee>\n+                                          autoderefref: ty::AutoDerefRef<'tcx>,\n+                                          self_ty: Ty<'tcx>,\n+                                          opt_input_types: Option<Vec<Ty<'tcx>>>)\n+                                          -> Option<MethodCallee<'tcx>>\n {\n     /*!\n      * `lookup_in_trait_adjusted` is used for overloaded operators. It\n@@ -262,7 +262,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                 ty::ByReferenceExplicitSelfCategory(..) => {\n                     // Trait method is fn(&self) or fn(&mut self), need an\n                     // autoref. Pull the region etc out of the type of first argument.\n-                    match ty::get(transformed_self_ty).sty {\n+                    match transformed_self_ty.sty {\n                         ty::ty_rptr(region, ty::mt { mutbl, ty: _ }) => {\n                             let ty::AutoDerefRef { autoderefs, autoref } = autoderefref;\n                             let autoref = autoref.map(|r| box r);\n@@ -308,11 +308,11 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     Some(callee)\n }\n \n-pub fn report_error(fcx: &FnCtxt,\n-                    span: Span,\n-                    rcvr_ty: ty::t,\n-                    method_name: ast::Name,\n-                    error: MethodError)\n+pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                              span: Span,\n+                              rcvr_ty: Ty<'tcx>,\n+                              method_name: ast::Name,\n+                              error: MethodError)\n {\n     match error {\n         NoMatch(static_sources) => {\n@@ -321,7 +321,7 @@ pub fn report_error(fcx: &FnCtxt,\n \n             // True if the type is a struct and contains a field with\n             // the same name as the not-found method\n-            let is_field = match ty::get(rcvr_ty).sty {\n+            let is_field = match rcvr_ty.sty {\n                 ty_struct(did, _) =>\n                     ty::lookup_struct_fields(cx, did)\n                         .iter()\n@@ -408,10 +408,10 @@ pub fn report_error(fcx: &FnCtxt,\n     }\n }\n \n-fn trait_method(tcx: &ty::ctxt,\n-                trait_def_id: ast::DefId,\n-                method_name: ast::Name)\n-                -> Option<(uint, Rc<ty::Method>)>\n+fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                      trait_def_id: ast::DefId,\n+                      method_name: ast::Name)\n+                      -> Option<(uint, Rc<ty::Method<'tcx>>)>\n {\n     /*!\n      * Find method with name `method_name` defined in `trait_def_id` and return it,\n@@ -426,10 +426,10 @@ fn trait_method(tcx: &ty::ctxt,\n         .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n }\n \n-fn impl_method(tcx: &ty::ctxt,\n-               impl_def_id: ast::DefId,\n-               method_name: ast::Name)\n-               -> Option<Rc<ty::Method>>\n+fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                     impl_def_id: ast::DefId,\n+                     method_name: ast::Name)\n+                     -> Option<Rc<ty::Method<'tcx>>>\n {\n     let impl_items = tcx.impl_items.borrow();\n     let impl_items = impl_items.get(&impl_def_id).unwrap();"}, {"sha": "a98b4cf011d97e38f1a9b4eb414a813c2349e455", "filename": "src/librustc/middle/typeck/check/method/probe.rs", "status": "modified", "additions": 105, "deletions": 90, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -16,7 +16,7 @@ use middle::fast_reject;\n use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold::HigherRankedFoldable;\n use middle::typeck::check;\n use middle::typeck::check::{FnCtxt, NoPreference};\n@@ -37,49 +37,50 @@ struct ProbeContext<'a, 'tcx:'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n     method_name: ast::Name,\n-    steps: Rc<Vec<CandidateStep>>,\n+    steps: Rc<Vec<CandidateStep<'tcx>>>,\n     opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>,\n-    inherent_candidates: Vec<Candidate>,\n-    extension_candidates: Vec<Candidate>,\n+    inherent_candidates: Vec<Candidate<'tcx>>,\n+    extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: HashSet<ast::DefId>,\n     static_candidates: Vec<CandidateSource>,\n }\n \n-struct CandidateStep {\n-    self_ty: ty::t,\n+struct CandidateStep<'tcx> {\n+    self_ty: Ty<'tcx>,\n     adjustment: PickAdjustment,\n }\n \n-struct Candidate {\n-    xform_self_ty: ty::t,\n-    method_ty: Rc<ty::Method>,\n-    kind: CandidateKind,\n+struct Candidate<'tcx> {\n+    xform_self_ty: Ty<'tcx>,\n+    method_ty: Rc<ty::Method<'tcx>>,\n+    kind: CandidateKind<'tcx>,\n }\n \n-enum CandidateKind {\n-    InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs),\n-    ObjectCandidate(MethodObject),\n-    ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef>, subst::Substs, MethodIndex),\n+enum CandidateKind<'tcx> {\n+    InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n+    ObjectCandidate(MethodObject<'tcx>),\n+    ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n+                           subst::Substs<'tcx>, MethodIndex),\n     UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClauseCandidate(Rc<ty::TraitRef>, MethodIndex),\n+    WhereClauseCandidate(Rc<ty::TraitRef<'tcx>>, MethodIndex),\n }\n \n-pub struct Pick {\n-    pub method_ty: Rc<ty::Method>,\n+pub struct Pick<'tcx> {\n+    pub method_ty: Rc<ty::Method<'tcx>>,\n     pub adjustment: PickAdjustment,\n-    pub kind: PickKind,\n+    pub kind: PickKind<'tcx>,\n }\n \n #[deriving(Clone,Show)]\n-pub enum PickKind {\n+pub enum PickKind<'tcx> {\n     InherentImplPick(/* Impl */ ast::DefId),\n     ObjectPick(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n     ExtensionImplPick(/* Impl */ ast::DefId, MethodIndex),\n     TraitPick(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClausePick(/* Trait */ Rc<ty::TraitRef>, MethodIndex),\n+    WhereClausePick(/* Trait */ Rc<ty::TraitRef<'tcx>>, MethodIndex),\n }\n \n-pub type PickResult = Result<Pick, MethodError>;\n+pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError>;\n \n // This is a kind of \"abstracted\" version of ty::AutoAdjustment.  The\n // difference is that it doesn't embed any regions or other\n@@ -105,12 +106,12 @@ pub enum PickAdjustment {\n     AutoRef(ast::Mutability, Box<PickAdjustment>),\n }\n \n-pub fn probe(fcx: &FnCtxt,\n-             span: Span,\n-             method_name: ast::Name,\n-             self_ty: ty::t,\n-             call_expr_id: ast::NodeId)\n-             -> PickResult\n+pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                       span: Span,\n+                       method_name: ast::Name,\n+                       self_ty: Ty<'tcx>,\n+                       call_expr_id: ast::NodeId)\n+                       -> PickResult<'tcx>\n {\n     debug!(\"probe(self_ty={}, method_name={}, call_expr_id={})\",\n            self_ty.repr(fcx.tcx()),\n@@ -157,7 +158,10 @@ pub fn probe(fcx: &FnCtxt,\n     })\n }\n \n-fn create_steps(fcx: &FnCtxt, span: Span, self_ty: ty::t) -> Vec<CandidateStep> {\n+fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                          span: Span,\n+                          self_ty: Ty<'tcx>)\n+                          -> Vec<CandidateStep<'tcx>> {\n     let mut steps = Vec::new();\n \n     let (fully_dereferenced_ty, dereferences, _) =\n@@ -169,7 +173,7 @@ fn create_steps(fcx: &FnCtxt, span: Span, self_ty: ty::t) -> Vec<CandidateStep>\n                 None::<()> // keep iterating until we can't anymore\n             });\n \n-    match ty::get(fully_dereferenced_ty).sty {\n+    match fully_dereferenced_ty.sty {\n         ty::ty_vec(elem_ty, Some(len)) => {\n             steps.push(CandidateStep {\n                 self_ty: ty::mk_vec(fcx.tcx(), elem_ty, None),\n@@ -182,9 +186,9 @@ fn create_steps(fcx: &FnCtxt, span: Span, self_ty: ty::t) -> Vec<CandidateStep>\n \n     return steps;\n \n-    fn consider_reborrow(t: ty::t, d: uint) -> PickAdjustment {\n+    fn consider_reborrow(ty: Ty, d: uint) -> PickAdjustment {\n         // Insert a `&*` or `&mut *` if this is a reference type:\n-        match ty::get(t).sty {\n+        match ty.sty {\n             ty::ty_rptr(_, ref mt) => AutoRef(mt.mutbl, box AutoDeref(d+1)),\n             _ => AutoDeref(d),\n         }\n@@ -195,7 +199,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a,'tcx>,\n            span: Span,\n            method_name: ast::Name,\n-           steps: Vec<CandidateStep>,\n+           steps: Vec<CandidateStep<'tcx>>,\n            opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>)\n            -> ProbeContext<'a,'tcx>\n     {\n@@ -230,11 +234,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n-    fn assemble_probe(&mut self, self_ty: ty::t) {\n+    fn assemble_probe(&mut self, self_ty: Ty<'tcx>) {\n         debug!(\"assemble_probe: self_ty={}\",\n                self_ty.repr(self.tcx()));\n \n-        match ty::get(self_ty).sty {\n+        match self_ty.sty {\n             ty::ty_trait(box ty::TyTrait { ref principal, bounds, .. }) => {\n                 self.assemble_inherent_candidates_from_object(self_ty, &*principal, bounds);\n                 self.assemble_inherent_impl_candidates_for_type(principal.def_id);\n@@ -293,8 +297,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_object(&mut self,\n-                                                self_ty: ty::t,\n-                                                principal: &ty::TraitRef,\n+                                                self_ty: Ty<'tcx>,\n+                                                principal: &ty::TraitRef<'tcx>,\n                                                 _bounds: ty::ExistentialBounds) {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={})\",\n                self_ty.repr(self.tcx()));\n@@ -353,8 +357,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_param(&mut self,\n-                                           _rcvr_ty: ty::t,\n-                                           param_ty: ty::ParamTy) {\n+                                               _rcvr_ty: Ty<'tcx>,\n+                                               param_ty: ty::ParamTy) {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n         let ty::ParamTy { space, idx: index, .. } = param_ty;\n@@ -397,11 +401,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     // create the candidates.\n     fn elaborate_bounds(\n         &mut self,\n-        bounds: &[Rc<ty::TraitRef>],\n-        mk_cand: |this: &mut ProbeContext,\n-                  tr: Rc<ty::TraitRef>,\n-                  m: Rc<ty::Method>,\n-                  method_num: uint|)\n+        bounds: &[Rc<ty::TraitRef<'tcx>>],\n+        mk_cand: for<'a> |this: &mut ProbeContext<'a, 'tcx>,\n+                          tr: Rc<ty::TraitRef<'tcx>>,\n+                          m: Rc<ty::Method<'tcx>>,\n+                          method_num: uint|)\n     {\n         let tcx = self.tcx();\n         let mut cache = HashSet::new();\n@@ -475,7 +479,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      trait_def_id: ast::DefId,\n-                                                     method: Rc<ty::Method>,\n+                                                     method: Rc<ty::Method<'tcx>>,\n                                                      method_index: uint)\n     {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n@@ -539,7 +543,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_unboxed_closure_candidates(&mut self,\n                                            trait_def_id: ast::DefId,\n-                                           method_ty: Rc<ty::Method>,\n+                                           method_ty: Rc<ty::Method<'tcx>>,\n                                            method_index: uint)\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n@@ -558,7 +562,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // If so, add \"synthetic impls\".\n         let steps = self.steps.clone();\n         for step in steps.iter() {\n-            let (closure_def_id, _, _) = match ty::get(step.self_ty).sty {\n+            let (closure_def_id, _, _) = match step.self_ty.sty {\n                 ty::ty_unboxed_closure(a, b, ref c) => (a, b, c),\n                 _ => continue,\n             };\n@@ -600,7 +604,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // THE ACTUAL SEARCH\n \n-    fn pick(mut self) -> PickResult {\n+    fn pick(mut self) -> PickResult<'tcx> {\n         let steps = self.steps.clone();\n \n         for step in steps.iter() {\n@@ -615,7 +619,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         Err(NoMatch(self.static_candidates))\n     }\n \n-    fn pick_step(&mut self, step: &CandidateStep) -> Option<PickResult> {\n+    fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n         debug!(\"pick_step: step={}\", step.repr(self.tcx()));\n \n         if ty::type_is_error(step.self_ty) {\n@@ -634,22 +638,22 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         // FIXME -- Super hack. For DST types, we will convert to\n         // &&[T] or &&str, as part of a kind of legacy lookup scheme.\n-        match ty::get(step.self_ty).sty {\n+        match step.self_ty.sty {\n             ty::ty_str | ty::ty_vec(_, None) => self.pick_autorefrefd_method(step),\n             _ => None\n         }\n     }\n \n     fn pick_adjusted_method(&mut self,\n-                            step: &CandidateStep)\n-                            -> Option<PickResult>\n+                            step: &CandidateStep<'tcx>)\n+                            -> Option<PickResult<'tcx>>\n     {\n         self.pick_method(step.self_ty).map(|r| self.adjust(r, step.adjustment.clone()))\n     }\n \n     fn pick_autorefd_method(&mut self,\n-                            step: &CandidateStep)\n-                            -> Option<PickResult>\n+                            step: &CandidateStep<'tcx>)\n+                            -> Option<PickResult<'tcx>>\n     {\n         let tcx = self.tcx();\n         self.search_mutabilities(\n@@ -658,8 +662,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn pick_autorefrefd_method(&mut self,\n-                               step: &CandidateStep)\n-                               -> Option<PickResult>\n+                               step: &CandidateStep<'tcx>)\n+                               -> Option<PickResult<'tcx>>\n     {\n         let tcx = self.tcx();\n         self.search_mutabilities(\n@@ -671,8 +675,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn search_mutabilities(&mut self,\n                            mk_adjustment: |ast::Mutability| -> PickAdjustment,\n-                           mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n-                           -> Option<PickResult>\n+                           mk_autoref_ty: |ast::Mutability, ty::Region| -> Ty<'tcx>)\n+                           -> Option<PickResult<'tcx>>\n     {\n         // In general, during probing we erase regions. See\n         // `impl_self_ty()` for an explanation.\n@@ -690,7 +694,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             .nth(0)\n     }\n \n-    fn adjust(&mut self, result: PickResult, adjustment: PickAdjustment) -> PickResult {\n+    fn adjust(&mut self,\n+              result: PickResult<'tcx>,\n+              adjustment: PickAdjustment)\n+              -> PickResult<'tcx> {\n         match result {\n             Err(e) => Err(e),\n             Ok(mut pick) => {\n@@ -700,7 +707,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n-    fn pick_method(&mut self, self_ty: ty::t) -> Option<PickResult> {\n+    fn pick_method(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n         debug!(\"pick_method(self_ty={})\", self.infcx().ty_to_string(self_ty));\n \n         debug!(\"searching inherent candidates\");\n@@ -715,7 +722,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.consider_candidates(self_ty, self.extension_candidates[])\n     }\n \n-    fn consider_candidates(&self, self_ty: ty::t, probes: &[Candidate]) -> Option<PickResult> {\n+    fn consider_candidates(&self,\n+                           self_ty: Ty<'tcx>,\n+                           probes: &[Candidate<'tcx>])\n+                           -> Option<PickResult<'tcx>> {\n         let mut applicable_candidates: Vec<_> =\n             probes.iter()\n                   .filter(|&probe| self.consider_probe(self_ty, probe))\n@@ -741,7 +751,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         })\n     }\n \n-    fn consider_probe(&self, self_ty: ty::t, probe: &Candidate) -> bool {\n+    fn consider_probe(&self, self_ty: Ty<'tcx>, probe: &Candidate<'tcx>) -> bool {\n         debug!(\"consider_probe: self_ty={} probe={}\",\n                self_ty.repr(self.tcx()),\n                probe.repr(self.tcx()));\n@@ -797,7 +807,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         })\n     }\n \n-    fn collapse_candidates_to_trait_pick(&self, probes: &[&Candidate]) -> Option<Pick> {\n+    fn collapse_candidates_to_trait_pick(&self,\n+                                         probes: &[&Candidate<'tcx>])\n+                                         -> Option<Pick<'tcx>> {\n         /*!\n          * Sometimes we get in a situation where we have multiple\n          * probes that are all impls of the same trait, but we don't\n@@ -844,7 +856,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n \n-    fn make_sub_ty(&self, sub: ty::t, sup: ty::t) -> infer::ures {\n+    fn make_sub_ty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>) -> infer::ures<'tcx> {\n         self.infcx().sub_types(false, infer::Misc(DUMMY_SP), sub, sup)\n     }\n \n@@ -874,7 +886,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.static_candidates.push(source);\n     }\n \n-    fn xform_self_ty(&self, method: &Rc<ty::Method>, substs: &subst::Substs) -> ty::t {\n+    fn xform_self_ty(&self,\n+                     method: &Rc<ty::Method<'tcx>>,\n+                     substs: &subst::Substs<'tcx>)\n+                     -> Ty<'tcx> {\n         debug!(\"xform_self_ty(self_ty={}, substs={})\",\n                method.fty.sig.inputs[0].repr(self.tcx()),\n                substs.repr(self.tcx()));\n@@ -922,7 +937,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn impl_substs(&self,\n                    impl_def_id: ast::DefId)\n-                   -> subst::Substs\n+                   -> subst::Substs<'tcx>\n     {\n         let impl_pty = ty::lookup_item_type(self.tcx(), impl_def_id);\n \n@@ -938,7 +953,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn erase_late_bound_regions<T>(&self, value: &T) -> T\n-        where T : HigherRankedFoldable\n+        where T : HigherRankedFoldable<'tcx>\n     {\n         /*!\n          * Replace late-bound-regions bound by `value` with `'static`\n@@ -971,10 +986,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n }\n \n-fn impl_method(tcx: &ty::ctxt,\n-               impl_def_id: ast::DefId,\n-               method_name: ast::Name)\n-               -> Option<Rc<ty::Method>>\n+fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                     impl_def_id: ast::DefId,\n+                     method_name: ast::Name)\n+                     -> Option<Rc<ty::Method<'tcx>>>\n {\n     let impl_items = tcx.impl_items.borrow();\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n@@ -985,10 +1000,10 @@ fn impl_method(tcx: &ty::ctxt,\n         .and_then(|item| item.as_opt_method())\n }\n \n-fn trait_method(tcx: &ty::ctxt,\n-                trait_def_id: ast::DefId,\n-                method_name: ast::Name)\n-                -> Option<(uint, Rc<ty::Method>)>\n+fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                      trait_def_id: ast::DefId,\n+                      method_name: ast::Name)\n+                      -> Option<(uint, Rc<ty::Method<'tcx>>)>\n {\n     /*!\n      * Find method with name `method_name` defined in `trait_def_id` and return it,\n@@ -1005,10 +1020,10 @@ fn trait_method(tcx: &ty::ctxt,\n \n // Determine the index of a method in the list of all methods belonging\n // to a trait and its supertraits.\n-fn get_method_index(tcx: &ty::ctxt,\n-                    trait_ref: &ty::TraitRef,\n-                    subtrait: Rc<ty::TraitRef>,\n-                    n_method: uint) -> uint {\n+fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                          trait_ref: &ty::TraitRef<'tcx>,\n+                          subtrait: Rc<ty::TraitRef<'tcx>>,\n+                          n_method: uint) -> uint {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by\n     // iterating down the supertraits of the object's trait until\n@@ -1032,8 +1047,8 @@ fn get_method_index(tcx: &ty::ctxt,\n     method_count + n_method\n }\n \n-impl Candidate {\n-    fn to_unadjusted_pick(&self) -> Pick {\n+impl<'tcx> Candidate<'tcx> {\n+    fn to_unadjusted_pick(&self) -> Pick<'tcx> {\n         Pick {\n             method_ty: self.method_ty.clone(),\n             adjustment: AutoDeref(0),\n@@ -1091,16 +1106,16 @@ impl Candidate {\n     }\n }\n \n-impl Repr for Candidate {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for Candidate<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Candidate(xform_self_ty={}, kind={})\",\n                 self.xform_self_ty.repr(tcx),\n                 self.kind.repr(tcx))\n     }\n }\n \n-impl Repr for CandidateKind {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             InherentImplCandidate(ref a, ref b) =>\n                 format!(\"InherentImplCandidate({},{})\", a.repr(tcx), b.repr(tcx)),\n@@ -1117,28 +1132,28 @@ impl Repr for CandidateKind {\n     }\n }\n \n-impl Repr for CandidateStep {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for CandidateStep<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"CandidateStep({},{})\",\n                 self.self_ty.repr(tcx),\n                 self.adjustment)\n     }\n }\n \n-impl Repr for PickAdjustment {\n+impl<'tcx> Repr<'tcx> for PickAdjustment {\n     fn repr(&self, _tcx: &ty::ctxt) -> String {\n         format!(\"{}\", self)\n     }\n }\n \n-impl Repr for PickKind {\n+impl<'tcx> Repr<'tcx> for PickKind<'tcx> {\n     fn repr(&self, _tcx: &ty::ctxt) -> String {\n         format!(\"{}\", self)\n     }\n }\n \n-impl Repr for Pick {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for Pick<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Pick(method_ty={}, adjustment={}, kind={})\",\n                 self.method_ty.repr(tcx),\n                 self.adjustment,"}, {"sha": "543eb44697c06ce5fdaaa5c79293326b1330685c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 379, "deletions": 367, "changes": 746, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -96,7 +96,7 @@ use middle::traits;\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{Polytype};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::{replace_late_bound_regions, liberate_late_bound_regions};\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n@@ -160,22 +160,22 @@ pub mod wf;\n /// share the inherited fields.\n pub struct Inherited<'a, 'tcx: 'a> {\n     infcx: infer::InferCtxt<'a, 'tcx>,\n-    locals: RefCell<NodeMap<ty::t>>,\n-    param_env: ty::ParameterEnvironment,\n+    locals: RefCell<NodeMap<Ty<'tcx>>>,\n+    param_env: ty::ParameterEnvironment<'tcx>,\n \n     // Temporary tables:\n-    node_types: RefCell<NodeMap<ty::t>>,\n-    item_substs: RefCell<NodeMap<ty::ItemSubsts>>,\n-    adjustments: RefCell<NodeMap<ty::AutoAdjustment>>,\n-    method_map: MethodMap,\n+    node_types: RefCell<NodeMap<Ty<'tcx>>>,\n+    item_substs: RefCell<NodeMap<ty::ItemSubsts<'tcx>>>,\n+    adjustments: RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>,\n+    method_map: MethodMap<'tcx>,\n     upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n-    unboxed_closures: RefCell<DefIdMap<ty::UnboxedClosure>>,\n-    object_cast_map: ObjectCastMap,\n+    unboxed_closures: RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>>,\n+    object_cast_map: ObjectCastMap<'tcx>,\n \n     // A mapping from each fn's id to its signature, with all bound\n     // regions replaced with free ones. Unlike the other tables, this\n     // one is never copied into the tcx: it is only used by regionck.\n-    fn_sig_map: RefCell<NodeMap<Vec<ty::t>>>,\n+    fn_sig_map: RefCell<NodeMap<Vec<Ty<'tcx>>>>,\n \n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n@@ -201,29 +201,29 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // regionck to be sure that it has found *all* the region\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n-    region_obligations: RefCell<NodeMap<Vec<RegionObligation>>>,\n+    region_obligations: RefCell<NodeMap<Vec<RegionObligation<'tcx>>>>,\n \n     // Tracks trait obligations incurred during this function body.\n-    fulfillment_cx: RefCell<traits::FulfillmentContext>,\n+    fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n }\n \n-struct RegionObligation {\n+struct RegionObligation<'tcx> {\n     sub_region: ty::Region,\n-    sup_type: ty::t,\n-    origin: infer::SubregionOrigin,\n+    sup_type: Ty<'tcx>,\n+    origin: infer::SubregionOrigin<'tcx>,\n }\n \n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n-enum Expectation {\n+enum Expectation<'tcx> {\n     /// We know nothing about what type this expression should have.\n     NoExpectation,\n \n     /// This expression should have the type given (or some subtype)\n-    ExpectHasType(ty::t),\n+    ExpectHasType(Ty<'tcx>),\n \n-    /// This expression will be cast to the `ty::t`\n-    ExpectCastableToType(ty::t),\n+    /// This expression will be cast to the `Ty`\n+    ExpectCastableToType(Ty<'tcx>),\n }\n \n #[deriving(Clone)]\n@@ -282,7 +282,7 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n     // expects the types within the function to be consistent.\n     err_count_on_creation: uint,\n \n-    ret_ty: ty::FnOutput,\n+    ret_ty: ty::FnOutput<'tcx>,\n \n     ps: RefCell<FnStyleState>,\n \n@@ -295,14 +295,14 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n         Ok(self.node_ty(id))\n     }\n     fn node_method_ty(&self, method_call: typeck::MethodCall)\n-                      -> Option<ty::t> {\n+                      -> Option<Ty<'tcx>> {\n         self.inh.method_map.borrow().get(&method_call).map(|m| m.ty)\n     }\n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.inh.adjustments\n     }\n     fn is_method_call(&self, id: ast::NodeId) -> bool {\n@@ -318,14 +318,15 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n                     -> ast::CaptureClause {\n         self.ccx.tcx.capture_mode(closure_expr_id)\n     }\n-    fn unboxed_closures<'a>(&'a self) -> &'a RefCell<DefIdMap<ty::UnboxedClosure>> {\n+    fn unboxed_closures<'a>(&'a self)\n+                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n         &self.inh.unboxed_closures\n     }\n }\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n-           param_env: ty::ParameterEnvironment)\n+           param_env: ty::ParameterEnvironment<'tcx>)\n            -> Inherited<'a, 'tcx> {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n@@ -348,7 +349,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n // Used by check_const and check_enum_variants\n pub fn blank_fn_ctxt<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                                inh: &'a Inherited<'a, 'tcx>,\n-                               rty: ty::FnOutput,\n+                               rty: ty::FnOutput<'tcx>,\n                                body_id: ast::NodeId)\n                                -> FnCtxt<'a, 'tcx> {\n     FnCtxt {\n@@ -394,17 +395,17 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n     ccx.tcx.sess.abort_if_errors();\n }\n \n-fn check_bare_fn(ccx: &CrateCtxt,\n-                 decl: &ast::FnDecl,\n-                 body: &ast::Block,\n-                 id: ast::NodeId,\n-                 fty: ty::t,\n-                 param_env: ty::ParameterEnvironment) {\n+fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                           decl: &ast::FnDecl,\n+                           body: &ast::Block,\n+                           id: ast::NodeId,\n+                           fty: Ty<'tcx>,\n+                           param_env: ty::ParameterEnvironment<'tcx>) {\n     // Compute the fty from point of view of inside fn\n     // (replace any type-scheme with a type)\n     let fty = fty.subst(ccx.tcx, &param_env.free_substs);\n \n-    match ty::get(fty).sty {\n+    match fty.sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n             let fcx = check_fn(ccx, fn_ty.fn_style, id, &fn_ty.sig,\n@@ -425,7 +426,7 @@ struct GatherLocalsVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n-    fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<ty::t>) -> ty::t {\n+    fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<Ty<'tcx>>) -> Ty<'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n@@ -507,7 +508,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                       fn_style: ast::FnStyle,\n                       fn_style_id: ast::NodeId,\n-                      fn_sig: &ty::FnSig,\n+                      fn_sig: &ty::FnSig<'tcx>,\n                       decl: &ast::FnDecl,\n                       fn_id: ast::NodeId,\n                       body: &ast::Block,\n@@ -551,7 +552,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     };\n \n     // Remember return type so that regionck can access it later.\n-    let mut fn_sig_tys: Vec<ty::t> =\n+    let mut fn_sig_tys: Vec<Ty> =\n         arg_tys.iter()\n         .map(|&ty| ty)\n         .collect();\n@@ -719,9 +720,9 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     }\n }\n \n-fn check_method_body(ccx: &CrateCtxt,\n-                     item_generics: &ty::Generics,\n-                     method: &ast::Method) {\n+fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                               item_generics: &ty::Generics<'tcx>,\n+                               method: &ast::Method) {\n     /*!\n      * Type checks a method body.\n      *\n@@ -752,11 +753,11 @@ fn check_method_body(ccx: &CrateCtxt,\n                   param_env);\n }\n \n-fn check_impl_items_against_trait(ccx: &CrateCtxt,\n-                                  impl_span: Span,\n-                                  ast_trait_ref: &ast::TraitRef,\n-                                  impl_trait_ref: &ty::TraitRef,\n-                                  impl_items: &[ast::ImplItem]) {\n+fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                            impl_span: Span,\n+                                            ast_trait_ref: &ast::TraitRef,\n+                                            impl_trait_ref: &ty::TraitRef<'tcx>,\n+                                            impl_items: &[ast::ImplItem]) {\n     // Locate trait methods\n     let tcx = ccx.tcx;\n     let trait_items = ty::trait_items(tcx, impl_trait_ref.def_id);\n@@ -927,12 +928,12 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n  * - trait_m: the method in the trait\n  * - trait_to_impl_substs: the substitutions used on the type of the trait\n  */\n-fn compare_impl_method(tcx: &ty::ctxt,\n-                       impl_m: &ty::Method,\n-                       impl_m_span: Span,\n-                       impl_m_body_id: ast::NodeId,\n-                       trait_m: &ty::Method,\n-                       impl_trait_ref: &ty::TraitRef) {\n+fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                             impl_m: &ty::Method<'tcx>,\n+                             impl_m_span: Span,\n+                             impl_m_body_id: ast::NodeId,\n+                             trait_m: &ty::Method<'tcx>,\n+                             impl_trait_ref: &ty::TraitRef<'tcx>) {\n     debug!(\"compare_impl_method(impl_trait_ref={})\",\n            impl_trait_ref.repr(tcx));\n \n@@ -1236,15 +1237,15 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     // parameters.\n     infcx.resolve_regions_and_report_errors();\n \n-    fn check_region_bounds_on_impl_method(tcx: &ty::ctxt,\n-                                          span: Span,\n-                                          impl_m: &ty::Method,\n-                                          impl_m_body_id: ast::NodeId,\n-                                          trait_generics: &ty::Generics,\n-                                          impl_generics: &ty::Generics,\n-                                          trait_to_skol_substs: &Substs,\n-                                          impl_to_skol_substs: &Substs)\n-                                          -> bool\n+    fn check_region_bounds_on_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                span: Span,\n+                                                impl_m: &ty::Method<'tcx>,\n+                                                impl_m_body_id: ast::NodeId,\n+                                                trait_generics: &ty::Generics<'tcx>,\n+                                                impl_generics: &ty::Generics<'tcx>,\n+                                                trait_to_skol_substs: &Substs<'tcx>,\n+                                                impl_to_skol_substs: &Substs<'tcx>)\n+                                                -> bool\n     {\n         /*!\n \n@@ -1435,7 +1436,7 @@ fn check_cast(fcx: &FnCtxt,\n         fcx.type_error_message(span, |actual| {\n             format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n         }, t_e, None);\n-        match ty::get(t_e).sty {\n+        match t_e.sty {\n             ty::ty_rptr(_, ty::mt { mutbl: mt, .. }) => {\n                 let mtstr = match mt {\n                     ast::MutMutable => \"mut \",\n@@ -1504,19 +1505,19 @@ fn check_cast(fcx: &FnCtxt,\n         // casts from C-like enums are allowed\n     } else if t_1_is_char {\n         let t_e = fcx.infcx().shallow_resolve(t_e);\n-        if ty::get(t_e).sty != ty::ty_uint(ast::TyU8) {\n+        if t_e.sty != ty::ty_uint(ast::TyU8) {\n             fcx.type_error_message(span, |actual| {\n                 format!(\"only `u8` can be cast as \\\n                          `char`, not `{}`\", actual)\n             }, t_e, None);\n         }\n-    } else if ty::get(t_1).sty == ty::ty_bool {\n+    } else if t_1.sty == ty::ty_bool {\n         span_err!(fcx.tcx().sess, span, E0054,\n             \"cannot cast as `bool`, compare with zero instead\");\n     } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n-        fn types_compatible(fcx: &FnCtxt, sp: Span,\n-                            t1: ty::t, t2: ty::t) -> bool {\n-            match ty::get(t1).sty {\n+        fn types_compatible<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                                      t1: Ty<'tcx>, t2: Ty<'tcx>) -> bool {\n+            match t1.sty {\n                 ty::ty_vec(_, Some(_)) => {}\n                 _ => return false\n             }\n@@ -1544,7 +1545,7 @@ fn check_cast(fcx: &FnCtxt,\n \n         /* this cast is only allowed from &[T, ..n] to *T or\n         &T to *T. */\n-        match (&ty::get(t_e).sty, &ty::get(t_1).sty) {\n+        match (&t_e.sty, &t_1.sty) {\n             (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n              &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n             if types_compatible(fcx, e.span, mt1, mt2) => {\n@@ -1580,29 +1581,29 @@ fn check_cast(fcx: &FnCtxt,\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         ty::lookup_item_type(self.tcx(), id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         ty::lookup_trait_def(self.tcx(), id)\n     }\n \n-    fn ty_infer(&self, _span: Span) -> ty::t {\n+    fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n         self.infcx().next_ty_var()\n     }\n \n-    fn associated_types_of_trait_are_valid(&self, _: ty::t, _: ast::DefId)\n+    fn associated_types_of_trait_are_valid(&self, _: Ty, _: ast::DefId)\n                                            -> bool {\n         false\n     }\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               _: Option<ty::t>,\n+                               _: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                _: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty<'tcx> {\n         self.tcx().sess.span_err(span, \"unsupported associated type binding\");\n         ty::mk_err()\n     }\n@@ -1642,7 +1643,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         format!(\"{}\", self as *const FnCtxt)\n     }\n \n-    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> ty::t {\n+    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> Ty<'tcx> {\n         match self.inh.locals.borrow().get(&nid) {\n             Some(&t) => t,\n             None => {\n@@ -1663,21 +1664,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn write_ty(&self, node_id: ast::NodeId, ty: ty::t) {\n+    pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({}, {}) in fcx {}\",\n                node_id, ppaux::ty_to_string(self.tcx(), ty), self.tag());\n         self.inh.node_types.borrow_mut().insert(node_id, ty);\n     }\n \n     pub fn write_object_cast(&self,\n                              key: ast::NodeId,\n-                             trait_ref: Rc<ty::TraitRef>) {\n+                             trait_ref: Rc<ty::TraitRef<'tcx>>) {\n         debug!(\"write_object_cast key={} trait_ref={}\",\n                key, trait_ref.repr(self.tcx()));\n         self.inh.object_cast_map.borrow_mut().insert(key, trait_ref);\n     }\n \n-    pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts) {\n+    pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n         if !substs.substs.is_noop() {\n             debug!(\"write_substs({}, {}) in fcx {}\",\n                    node_id,\n@@ -1705,7 +1706,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n                             span: Span,\n-                            adj: ty::AutoAdjustment) {\n+                            adj: ty::AutoAdjustment<'tcx>) {\n         debug!(\"write_adjustment(node_id={}, adj={})\", node_id, adj);\n \n         if adj.is_identity() {\n@@ -1724,7 +1725,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn register_adjustment_obligations(&self,\n                                        span: Span,\n-                                       adj: &ty::AutoAdjustment) {\n+                                       adj: &ty::AutoAdjustment<'tcx>) {\n         match *adj {\n             ty::AdjustAddEnv(..) => { }\n             ty::AdjustDerefRef(ref d_r) => {\n@@ -1740,7 +1741,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn register_autoref_obligations(&self,\n                                     span: Span,\n-                                    autoref: &ty::AutoRef) {\n+                                    autoref: &ty::AutoRef<'tcx>) {\n         match *autoref {\n             ty::AutoUnsize(ref unsize) => {\n                 self.register_unsize_obligations(span, unsize);\n@@ -1760,7 +1761,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn register_unsize_obligations(&self,\n                                    span: Span,\n-                                   unsize: &ty::UnsizeKind) {\n+                                   unsize: &ty::UnsizeKind<'tcx>) {\n         debug!(\"register_unsize_obligations: unsize={}\", unsize);\n \n         match *unsize {\n@@ -1788,7 +1789,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn instantiate_type(&self,\n                             span: Span,\n                             def_id: ast::DefId)\n-                            -> TypeAndSubsts\n+                            -> TypeAndSubsts<'tcx>\n     {\n         /*!\n          * Returns the type of `def_id` with all generics replaced by\n@@ -1833,9 +1834,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn require_type_meets(&self,\n-                              ty: ty::t,\n+                              ty: Ty<'tcx>,\n                               span: Span,\n-                              code: traits::ObligationCauseCode,\n+                              code: traits::ObligationCauseCode<'tcx>,\n                               bound: ty::BuiltinBound)\n     {\n         let obligation = traits::obligation_for_builtin_bound(\n@@ -1850,22 +1851,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn require_type_is_sized(&self,\n-                                 ty: ty::t,\n+                                 ty: Ty<'tcx>,\n                                  span: Span,\n-                                 code: traits::ObligationCauseCode)\n+                                 code: traits::ObligationCauseCode<'tcx>)\n     {\n         self.require_type_meets(ty, span, code, ty::BoundSized);\n     }\n \n     pub fn require_expr_have_sized_type(&self,\n                                         expr: &ast::Expr,\n-                                        code: traits::ObligationCauseCode)\n+                                        code: traits::ObligationCauseCode<'tcx>)\n     {\n         self.require_type_is_sized(self.expr_ty(expr), expr.span, code);\n     }\n \n     pub fn register_obligation(&self,\n-                               obligation: traits::Obligation)\n+                               obligation: traits::Obligation<'tcx>)\n     {\n         debug!(\"register_obligation({})\",\n                obligation.repr(self.tcx()));\n@@ -1875,7 +1876,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .register_obligation(self.tcx(), obligation);\n     }\n \n-    pub fn to_ty(&self, ast_t: &ast::Ty) -> ty::t {\n+    pub fn to_ty(&self, ast_t: &ast::Ty) -> Ty<'tcx> {\n         let t = ast_ty_to_ty(self, self.infcx(), ast_t);\n \n         let mut bounds_checker = wf::BoundsChecker::new(self,\n@@ -1891,7 +1892,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat.repr(self.tcx())\n     }\n \n-    pub fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n+    pub fn expr_ty(&self, ex: &ast::Expr) -> Ty<'tcx> {\n         match self.inh.node_types.borrow().get(&ex.id) {\n             Some(&t) => t,\n             None => {\n@@ -1901,7 +1902,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> ty::t {\n+    pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n         /*!\n          * Fetch type of `expr` after applying adjustments that\n          * have been recorded in the fcx.\n@@ -1914,8 +1915,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn adjust_expr_ty(&self,\n                           expr: &ast::Expr,\n-                          adjustment: Option<&ty::AutoAdjustment>)\n-                          -> ty::t\n+                          adjustment: Option<&ty::AutoAdjustment<'tcx>>)\n+                          -> Ty<'tcx>\n     {\n         /*!\n          * Apply `adjustment` to the type of `expr`\n@@ -1933,7 +1934,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                        .map(|method| method.ty))\n     }\n \n-    pub fn node_ty(&self, id: ast::NodeId) -> ty::t {\n+    pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n         match self.inh.node_types.borrow().get(&id) {\n             Some(&t) => t,\n             None => {\n@@ -1945,13 +1946,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn item_substs<'a>(&'a self) -> Ref<'a, NodeMap<ty::ItemSubsts>> {\n+    pub fn item_substs<'a>(&'a self) -> Ref<'a, NodeMap<ty::ItemSubsts<'tcx>>> {\n         self.inh.item_substs.borrow()\n     }\n \n     pub fn opt_node_ty_substs(&self,\n                               id: ast::NodeId,\n-                              f: |&ty::ItemSubsts|) {\n+                              f: |&ty::ItemSubsts<'tcx>|) {\n         match self.inh.item_substs.borrow().get(&id) {\n             Some(s) => { f(s) }\n             None => { }\n@@ -1961,27 +1962,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn mk_subty(&self,\n                     a_is_expected: bool,\n                     origin: infer::TypeOrigin,\n-                    sub: ty::t,\n-                    sup: ty::t)\n-                    -> Result<(), ty::type_err> {\n+                    sub: Ty<'tcx>,\n+                    sup: Ty<'tcx>)\n+                    -> Result<(), ty::type_err<'tcx>> {\n         infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n-    pub fn can_mk_subty(&self, sub: ty::t, sup: ty::t)\n-                        -> Result<(), ty::type_err> {\n+    pub fn can_mk_subty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>)\n+                        -> Result<(), ty::type_err<'tcx>> {\n         infer::can_mk_subty(self.infcx(), sub, sup)\n     }\n \n-    pub fn can_mk_eqty(&self, sub: ty::t, sup: ty::t)\n-                       -> Result<(), ty::type_err> {\n+    pub fn can_mk_eqty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>)\n+                       -> Result<(), ty::type_err<'tcx>> {\n         infer::can_mk_eqty(self.infcx(), sub, sup)\n     }\n \n     pub fn mk_assignty(&self,\n                        expr: &ast::Expr,\n-                       sub: ty::t,\n-                       sup: ty::t)\n-                       -> Result<(), ty::type_err> {\n+                       sub: Ty<'tcx>,\n+                       sup: Ty<'tcx>)\n+                       -> Result<(), ty::type_err<'tcx>> {\n         match infer::mk_coercety(self.infcx(),\n                                  false,\n                                  infer::ExprAssignable(expr.span),\n@@ -1999,14 +2000,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn mk_eqty(&self,\n                    a_is_expected: bool,\n                    origin: infer::TypeOrigin,\n-                   sub: ty::t,\n-                   sup: ty::t)\n-                   -> Result<(), ty::type_err> {\n+                   sub: Ty<'tcx>,\n+                   sup: Ty<'tcx>)\n+                   -> Result<(), ty::type_err<'tcx>> {\n         infer::mk_eqty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n     pub fn mk_subr(&self,\n-                   origin: infer::SubregionOrigin,\n+                   origin: infer::SubregionOrigin<'tcx>,\n                    sub: ty::Region,\n                    sup: ty::Region) {\n         infer::mk_subr(self.infcx(), origin, sub, sup)\n@@ -2015,22 +2016,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn type_error_message(&self,\n                               sp: Span,\n                               mk_msg: |String| -> String,\n-                              actual_ty: ty::t,\n-                              err: Option<&ty::type_err>) {\n+                              actual_ty: Ty<'tcx>,\n+                              err: Option<&ty::type_err<'tcx>>) {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n     }\n \n     pub fn report_mismatched_types(&self,\n                                    sp: Span,\n-                                   e: ty::t,\n-                                   a: ty::t,\n-                                   err: &ty::type_err) {\n+                                   e: Ty<'tcx>,\n+                                   a: Ty<'tcx>,\n+                                   err: &ty::type_err<'tcx>) {\n         self.infcx().report_mismatched_types(sp, e, a, err)\n     }\n \n     pub fn register_region_obligation(&self,\n-                                      origin: infer::SubregionOrigin,\n-                                      ty: ty::t,\n+                                      origin: infer::SubregionOrigin<'tcx>,\n+                                      ty: Ty<'tcx>,\n                                       r: ty::Region)\n     {\n         /*!\n@@ -2050,9 +2051,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn add_obligations_for_parameters(&self,\n-                                          cause: traits::ObligationCause,\n-                                          substs: &Substs,\n-                                          generic_bounds: &ty::GenericBounds)\n+                                          cause: traits::ObligationCause<'tcx>,\n+                                          substs: &Substs<'tcx>,\n+                                          generic_bounds: &ty::GenericBounds<'tcx>)\n     {\n         /*!\n          * Given a fully substituted set of bounds (`generic_bounds`),\n@@ -2085,9 +2086,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn add_trait_obligations_for_generics(&self,\n-                                          cause: traits::ObligationCause,\n-                                          substs: &Substs,\n-                                          generic_bounds: &ty::GenericBounds) {\n+                                          cause: traits::ObligationCause<'tcx>,\n+                                          substs: &Substs<'tcx>,\n+                                          generic_bounds: &ty::GenericBounds<'tcx>) {\n         assert!(!generic_bounds.has_escaping_regions());\n         assert!(!substs.has_regions_escaping_depth(0));\n \n@@ -2100,9 +2101,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn add_region_obligations_for_generics(&self,\n-                                           cause: traits::ObligationCause,\n-                                           substs: &Substs,\n-                                           generic_bounds: &ty::GenericBounds)\n+                                           cause: traits::ObligationCause<'tcx>,\n+                                           substs: &Substs<'tcx>,\n+                                           generic_bounds: &ty::GenericBounds<'tcx>)\n     {\n         assert!(!generic_bounds.has_escaping_regions());\n         assert_eq!(generic_bounds.types.iter().len(), substs.types.iter().len());\n@@ -2128,8 +2129,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn add_region_obligations_for_type_parameter(&self,\n                                                  span: Span,\n-                                                 param_bound: &ty::ParamBounds,\n-                                                 ty: ty::t)\n+                                                 param_bound: &ty::ParamBounds<'tcx>,\n+                                                 ty: Ty<'tcx>)\n     {\n         // For each declared region bound `T:r`, `T` must outlive `r`.\n         let region_bounds =\n@@ -2164,11 +2165,12 @@ pub enum LvaluePreference {\n     NoPreference\n }\n \n-pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n-                    expr_id: Option<ast::NodeId>,\n-                    mut lvalue_pref: LvaluePreference,\n-                    should_stop: |ty::t, uint| -> Option<T>)\n-                    -> (ty::t, uint, Option<T>) {\n+pub fn autoderef<'a, 'tcx, T>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                              base_ty: Ty<'tcx>,\n+                              expr_id: Option<ast::NodeId>,\n+                              mut lvalue_pref: LvaluePreference,\n+                              should_stop: |Ty<'tcx>, uint| -> Option<T>)\n+                              -> (Ty<'tcx>, uint, Option<T>) {\n     /*!\n      * Executes an autoderef loop for the type `t`. At each step, invokes\n      * `should_stop` to decide whether to terminate the loop. Returns\n@@ -2219,12 +2221,12 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n }\n \n /// Attempts to resolve a call expression as an overloaded call.\n-fn try_overloaded_call<'a>(fcx: &FnCtxt,\n-                           call_expression: &ast::Expr,\n-                           callee: &ast::Expr,\n-                           callee_type: ty::t,\n-                           args: &[&'a P<ast::Expr>])\n-                           -> bool {\n+fn try_overloaded_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                 call_expression: &ast::Expr,\n+                                 callee: &ast::Expr,\n+                                 callee_type: Ty<'tcx>,\n+                                 args: &[&P<ast::Expr>])\n+                                 -> bool {\n     // Bail out if the callee is a bare function or a closure. We check those\n     // manually.\n     match *structure_of(fcx, callee.span, callee_type) {\n@@ -2278,13 +2280,13 @@ fn try_overloaded_call<'a>(fcx: &FnCtxt,\n     false\n }\n \n-fn try_overloaded_deref(fcx: &FnCtxt,\n-                        span: Span,\n-                        method_call: Option<MethodCall>,\n-                        base_expr: Option<&ast::Expr>,\n-                        base_ty: ty::t,\n-                        lvalue_pref: LvaluePreference)\n-                        -> Option<ty::mt>\n+fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  span: Span,\n+                                  method_call: Option<MethodCall>,\n+                                  base_expr: Option<&ast::Expr>,\n+                                  base_ty: Ty<'tcx>,\n+                                  lvalue_pref: LvaluePreference)\n+                                  -> Option<ty::mt<'tcx>>\n {\n     // Try DerefMut first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n@@ -2309,10 +2311,10 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n     make_overloaded_lvalue_return_type(fcx, method_call, method)\n }\n \n-fn make_overloaded_lvalue_return_type(fcx: &FnCtxt,\n-                                      method_call: Option<MethodCall>,\n-                                      method: Option<MethodCallee>)\n-                                      -> Option<ty::mt>\n+fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                method_call: Option<MethodCall>,\n+                                                method: Option<MethodCallee<'tcx>>)\n+                                                -> Option<ty::mt<'tcx>>\n {\n     /*!\n      * For the overloaded lvalue expressions (`*x`, `x[3]`), the trait\n@@ -2345,12 +2347,12 @@ fn make_overloaded_lvalue_return_type(fcx: &FnCtxt,\n     }\n }\n \n-fn autoderef_for_index<T>(fcx: &FnCtxt,\n-                          base_expr: &ast::Expr,\n-                          base_ty: ty::t,\n-                          lvalue_pref: LvaluePreference,\n-                          step: |ty::t, ty::AutoDerefRef| -> Option<T>)\n-                          -> Option<T>\n+fn autoderef_for_index<'a, 'tcx, T>(fcx: &FnCtxt<'a, 'tcx>,\n+                                    base_expr: &ast::Expr,\n+                                    base_ty: Ty<'tcx>,\n+                                    lvalue_pref: LvaluePreference,\n+                                    step: |Ty<'tcx>, ty::AutoDerefRef<'tcx>| -> Option<T>)\n+                                    -> Option<T>\n {\n     // FIXME(#18741) -- this is almost but not quite the same as the\n     // autoderef that normal method probing does. They could likely be\n@@ -2368,7 +2370,7 @@ fn autoderef_for_index<T>(fcx: &FnCtxt,\n \n     // After we have fully autoderef'd, if the resulting type is [T, ..n], then\n     // do a final unsized coercion to yield [T].\n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_vec(element_ty, Some(n)) => {\n             let adjusted_ty = ty::mk_vec(fcx.tcx(), element_ty, None);\n             let autoderefref = ty::AutoDerefRef {\n@@ -2383,15 +2385,15 @@ fn autoderef_for_index<T>(fcx: &FnCtxt,\n     }\n }\n \n-fn try_overloaded_slice(fcx: &FnCtxt,\n-                        method_call: MethodCall,\n-                        expr: &ast::Expr,\n-                        base_expr: &ast::Expr,\n-                        base_ty: ty::t,\n-                        start_expr: &Option<P<ast::Expr>>,\n-                        end_expr: &Option<P<ast::Expr>>,\n-                        mutbl: ast::Mutability)\n-                        -> Option<ty::t> // return type is result of slice\n+fn try_overloaded_slice<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  method_call: MethodCall,\n+                                  expr: &ast::Expr,\n+                                  base_expr: &ast::Expr,\n+                                  base_ty: Ty<'tcx>,\n+                                  start_expr: &Option<P<ast::Expr>>,\n+                                  end_expr: &Option<P<ast::Expr>>,\n+                                  mutbl: ast::Mutability)\n+                                  -> Option<Ty<'tcx>> // return type is result of slice\n {\n     /*!\n      * Autoderefs `base_expr`, looking for a `Slice` impl. If it\n@@ -2439,16 +2441,17 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n     })\n }\n \n-fn try_overloaded_slice_step(fcx: &FnCtxt,\n-                             method_call: MethodCall,\n-                             expr: &ast::Expr,\n-                             base_expr: &ast::Expr,\n-                             base_ty: ty::t, // autoderef'd type\n-                             autoderefref: ty::AutoDerefRef,\n-                             mutbl: ast::Mutability,\n-                             start_expr: &Option<P<ast::Expr>>,\n-                             end_expr: &Option<P<ast::Expr>>)\n-                             -> Option<ty::t> // result type is type of method being called\n+fn try_overloaded_slice_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                       method_call: MethodCall,\n+                                       expr: &ast::Expr,\n+                                       base_expr: &ast::Expr,\n+                                       base_ty: Ty<'tcx>, // autoderef'd type\n+                                       autoderefref: ty::AutoDerefRef<'tcx>,\n+                                       mutbl: ast::Mutability,\n+                                       start_expr: &Option<P<ast::Expr>>,\n+                                       end_expr: &Option<P<ast::Expr>>)\n+                                       // result type is type of method being called\n+                                       -> Option<Ty<'tcx>>\n {\n     /*!\n      * Checks for a `Slice` (or `SliceMut`) impl at the relevant level\n@@ -2512,14 +2515,14 @@ fn try_overloaded_slice_step(fcx: &FnCtxt,\n     })\n }\n \n-fn try_index_step(fcx: &FnCtxt,\n-                  method_call: MethodCall,\n-                  expr: &ast::Expr,\n-                  base_expr: &ast::Expr,\n-                  adjusted_ty: ty::t,\n-                  adjustment: ty::AutoDerefRef,\n-                  lvalue_pref: LvaluePreference)\n-                  -> Option<(/*index type*/ ty::t, /*element type*/ ty::t)>\n+fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                            method_call: MethodCall,\n+                            expr: &ast::Expr,\n+                            base_expr: &ast::Expr,\n+                            adjusted_ty: Ty<'tcx>,\n+                            adjustment: ty::AutoDerefRef<'tcx>,\n+                            lvalue_pref: LvaluePreference)\n+                            -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n {\n     /*!\n      * To type-check `base_expr[index_expr]`, we progressively autoderef (and otherwise adjust)\n@@ -2591,10 +2594,10 @@ fn try_index_step(fcx: &FnCtxt,\n ///\n /// The return type of this function represents the concrete element type\n /// `A` in the type `Iterator<A>` that the method returns.\n-fn lookup_method_for_for_loop(fcx: &FnCtxt,\n-                              iterator_expr: &ast::Expr,\n-                              loop_id: ast::NodeId)\n-                              -> ty::t {\n+fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                        iterator_expr: &ast::Expr,\n+                                        loop_id: ast::NodeId)\n+                                        -> Ty<'tcx> {\n     let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n         Ok(trait_did) => trait_did,\n         Err(ref err_string) => {\n@@ -2650,7 +2653,7 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n                     structurally_resolved_type(fcx, iterator_expr.span, return_type),\n                 ty::FnDiverging => ty::mk_err()\n             };\n-            match ty::get(return_type).sty {\n+            match return_type.sty {\n                 ty::ty_enum(_, ref substs)\n                         if !substs.types.is_empty_in(subst::TypeSpace) => {\n                     *substs.types.get(subst::TypeSpace, 0)\n@@ -2672,14 +2675,14 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n     }\n }\n \n-fn check_method_argument_types<'a>(fcx: &FnCtxt,\n-                                   sp: Span,\n-                                   method_fn_ty: ty::t,\n-                                   callee_expr: &ast::Expr,\n-                                   args_no_rcvr: &[&'a P<ast::Expr>],\n-                                   deref_args: DerefArgs,\n-                                   tuple_arguments: TupleArgumentsFlag)\n-                                   -> ty::FnOutput {\n+fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                         sp: Span,\n+                                         method_fn_ty: Ty<'tcx>,\n+                                         callee_expr: &ast::Expr,\n+                                         args_no_rcvr: &[&P<ast::Expr>],\n+                                         deref_args: DerefArgs,\n+                                         tuple_arguments: TupleArgumentsFlag)\n+                                         -> ty::FnOutput<'tcx> {\n     if ty::type_is_error(method_fn_ty) {\n        let err_inputs = err_args(args_no_rcvr.len());\n         check_argument_types(fcx,\n@@ -2692,7 +2695,7 @@ fn check_method_argument_types<'a>(fcx: &FnCtxt,\n                              tuple_arguments);\n         ty::FnConverging(ty::mk_err())\n     } else {\n-        match ty::get(method_fn_ty).sty {\n+        match method_fn_ty.sty {\n             ty::ty_bare_fn(ref fty) => {\n                 // HACK(eddyb) ignore self in the definition (see above).\n                 check_argument_types(fcx,\n@@ -2713,14 +2716,14 @@ fn check_method_argument_types<'a>(fcx: &FnCtxt,\n     }\n }\n \n-fn check_argument_types<'a>(fcx: &FnCtxt,\n-                            sp: Span,\n-                            fn_inputs: &[ty::t],\n-                            _callee_expr: &ast::Expr,\n-                            args: &[&'a P<ast::Expr>],\n-                            deref_args: DerefArgs,\n-                            variadic: bool,\n-                            tuple_arguments: TupleArgumentsFlag) {\n+fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  sp: Span,\n+                                  fn_inputs: &[Ty<'tcx>],\n+                                  _callee_expr: &ast::Expr,\n+                                  args: &[&P<ast::Expr>],\n+                                  deref_args: DerefArgs,\n+                                  variadic: bool,\n+                                  tuple_arguments: TupleArgumentsFlag) {\n     /*!\n      *\n      * Generic function that factors out common logic from\n@@ -2740,7 +2743,7 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n     let expected_arg_count = fn_inputs.len();\n     let formal_tys = if tuple_arguments == TupleArguments {\n         let tuple_type = structurally_resolved_type(fcx, sp, fn_inputs[0]);\n-        match ty::get(tuple_type).sty {\n+        match tuple_type.sty {\n             ty::ty_tup(ref arg_types) => {\n                 if arg_types.len() != args.len() {\n                     span_err!(tcx.sess, sp, E0057,\n@@ -2831,7 +2834,7 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n \n                 match deref_args {\n                     DoDerefArgs => {\n-                        match ty::get(formal_ty).sty {\n+                        match formal_ty.sty {\n                             ty::ty_rptr(_, mt) => formal_ty = mt.ty,\n                             ty::ty_err => (),\n                             _ => {\n@@ -2863,7 +2866,7 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n             // in C but we just error out instead and require explicit casts.\n             let arg_ty = structurally_resolved_type(fcx, arg.span,\n                                                     fcx.expr_ty(&***arg));\n-            match ty::get(arg_ty).sty {\n+            match arg_ty.sty {\n                 ty::ty_float(ast::TyF32) => {\n                     fcx.type_error_message(arg.span,\n                                            |t| {\n@@ -2891,22 +2894,25 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n     }\n }\n \n-fn err_args(len: uint) -> Vec<ty::t> {\n+// FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n+fn err_args<'tcx>(len: uint) -> Vec<Ty<'tcx>> {\n     Vec::from_fn(len, |_| ty::mk_err())\n }\n \n-fn write_call(fcx: &FnCtxt, call_expr: &ast::Expr, output: ty::FnOutput) {\n+fn write_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                        call_expr: &ast::Expr,\n+                        output: ty::FnOutput<'tcx>) {\n     fcx.write_ty(call_expr.id, match output {\n         ty::FnConverging(output_ty) => output_ty,\n         ty::FnDiverging => fcx.infcx().next_diverging_ty_var()\n     });\n }\n \n // AST fragment checking\n-fn check_lit(fcx: &FnCtxt,\n-             lit: &ast::Lit,\n-             expected: Expectation)\n-             -> ty::t\n+fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                       lit: &ast::Lit,\n+                       expected: Expectation<'tcx>)\n+                       -> Ty<'tcx>\n {\n     let tcx = fcx.ccx.tcx;\n \n@@ -2958,40 +2964,41 @@ pub fn valid_range_bounds(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn check_expr_has_type(fcx: &FnCtxt,\n-                           expr: &ast::Expr,\n-                           expected: ty::t) {\n+pub fn check_expr_has_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                     expr: &ast::Expr,\n+                                     expected: Ty<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr)));\n }\n \n-fn check_expr_coercable_to_type(fcx: &FnCtxt,\n-                                expr: &ast::Expr,\n-                                expected: ty::t) {\n+fn check_expr_coercable_to_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                          expr: &ast::Expr,\n+                                          expected: Ty<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || demand::coerce(fcx, expr.span, expected, expr));\n }\n \n-fn check_expr_with_hint(fcx: &FnCtxt, expr: &ast::Expr, expected: ty::t) {\n+fn check_expr_with_hint<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, expr: &ast::Expr,\n+                                  expected: Ty<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || ())\n }\n \n-fn check_expr_with_expectation(fcx: &FnCtxt,\n-                               expr: &ast::Expr,\n-                               expected: Expectation) {\n+fn check_expr_with_expectation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                         expr: &ast::Expr,\n+                                         expected: Expectation<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, expected, NoPreference,\n         || ())\n }\n \n-fn check_expr_with_expectation_and_lvalue_pref(fcx: &FnCtxt,\n-                                            expr: &ast::Expr,\n-                                            expected: Expectation,\n-                                            lvalue_pref: LvaluePreference)\n+fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                         expr: &ast::Expr,\n+                                                         expected: Expectation<'tcx>,\n+                                                         lvalue_pref: LvaluePreference)\n {\n     check_expr_with_unifier(fcx, expr, expected, lvalue_pref, || ())\n }\n@@ -3009,10 +3016,10 @@ fn check_expr_with_lvalue_pref(fcx: &FnCtxt, expr: &ast::Expr,\n // declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-pub fn impl_self_ty(fcx: &FnCtxt,\n-                    span: Span, // (potential) receiver for this impl\n-                    did: ast::DefId)\n-                    -> TypeAndSubsts {\n+pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                              span: Span, // (potential) receiver for this impl\n+                              did: ast::DefId)\n+                              -> TypeAndSubsts<'tcx> {\n     let tcx = fcx.tcx();\n \n     let ity = ty::lookup_item_type(tcx, did);\n@@ -3031,21 +3038,23 @@ pub fn impl_self_ty(fcx: &FnCtxt,\n \n // Only for fields! Returns <none> for methods>\n // Indifferent to privacy flags\n-pub fn lookup_field_ty(tcx: &ty::ctxt,\n-                       class_id: ast::DefId,\n-                       items: &[ty::field_ty],\n-                       fieldname: ast::Name,\n-                       substs: &subst::Substs) -> Option<ty::t> {\n+pub fn lookup_field_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                             class_id: ast::DefId,\n+                             items: &[ty::field_ty],\n+                             fieldname: ast::Name,\n+                             substs: &subst::Substs<'tcx>)\n+                             -> Option<Ty<'tcx>> {\n \n     let o_field = items.iter().find(|f| f.name == fieldname);\n     o_field.map(|f| ty::lookup_field_type(tcx, class_id, f.id, substs))\n }\n \n-pub fn lookup_tup_field_ty(tcx: &ty::ctxt,\n-                           class_id: ast::DefId,\n-                           items: &[ty::field_ty],\n-                           idx: uint,\n-                           substs: &subst::Substs) -> Option<ty::t> {\n+pub fn lookup_tup_field_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 class_id: ast::DefId,\n+                                 items: &[ty::field_ty],\n+                                 idx: uint,\n+                                 substs: &subst::Substs<'tcx>)\n+                                 -> Option<Ty<'tcx>> {\n \n     let o_field = if idx < items.len() { Some(&items[idx]) } else { None };\n     o_field.map(|f| ty::lookup_field_type(tcx, class_id, f.id, substs))\n@@ -3090,20 +3099,20 @@ enum TupleArgumentsFlag {\n /// Note that inspecting a type's structure *directly* may expose the fact\n /// that there are actually multiple representations for `ty_err`, so avoid\n /// that when err needs to be handled differently.\n-fn check_expr_with_unifier(fcx: &FnCtxt,\n-                           expr: &ast::Expr,\n-                           expected: Expectation,\n-                           lvalue_pref: LvaluePreference,\n-                           unifier: ||)\n+fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                     expr: &ast::Expr,\n+                                     expected: Expectation<'tcx>,\n+                                     lvalue_pref: LvaluePreference,\n+                                     unifier: ||)\n {\n     debug!(\">> typechecking: expr={} expected={}\",\n            expr.repr(fcx.tcx()), expected.repr(fcx.tcx()));\n \n     // A generic function for doing all of the checking for call expressions\n-    fn check_call<'a>(fcx: &FnCtxt,\n-                      call_expr: &ast::Expr,\n-                      f: &ast::Expr,\n-                      args: &[&'a P<ast::Expr>]) {\n+    fn check_call(fcx: &FnCtxt,\n+                  call_expr: &ast::Expr,\n+                  f: &ast::Expr,\n+                  args: &[&P<ast::Expr>]) {\n         // Store the type of `f` as the type of the callee\n         let fn_ty = fcx.expr_ty(f);\n \n@@ -3201,13 +3210,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     // A generic function for checking the then and else in an if\n     // or if-check\n-    fn check_then_else(fcx: &FnCtxt,\n-                       cond_expr: &ast::Expr,\n-                       then_blk: &ast::Block,\n-                       opt_else_expr: Option<&ast::Expr>,\n-                       id: ast::NodeId,\n-                       sp: Span,\n-                       expected: Expectation) {\n+    fn check_then_else<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                 cond_expr: &ast::Expr,\n+                                 then_blk: &ast::Block,\n+                                 opt_else_expr: Option<&ast::Expr>,\n+                                 id: ast::NodeId,\n+                                 sp: Span,\n+                                 expected: Expectation<'tcx>) {\n         check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n \n         // Disregard \"castable to\" expectations because they\n@@ -3271,12 +3280,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                   op_ex: &ast::Expr,\n-                                  lhs_ty: ty::t,\n+                                  lhs_ty: Ty<'tcx>,\n                                   opname: ast::Name,\n                                   trait_did: Option<ast::DefId>,\n                                   lhs: &'a ast::Expr,\n                                   rhs: Option<&P<ast::Expr>>,\n-                                  unbound_method: ||) -> ty::t {\n+                                  unbound_method: ||) -> Ty<'tcx> {\n         let method = match trait_did {\n             Some(trait_did) => {\n                 // We do eager coercions to make using operators\n@@ -3289,7 +3298,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 //   could also solve this with variance or different\n                 //   traits that don't force left and right to have same\n                 //   type.\n-                let (adj_ty, adjustment) = match ty::get(lhs_ty).sty {\n+                let (adj_ty, adjustment) = match lhs_ty.sty {\n                     ty::ty_rptr(r_in, mt) => {\n                         let r_adj = fcx.infcx().next_region_var(infer::Autoref(lhs.span));\n                         fcx.mk_subr(infer::Reborrow(lhs.span), r_adj, r_in);\n@@ -3454,12 +3463,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n     }\n \n-    fn check_user_binop(fcx: &FnCtxt,\n-                        ex: &ast::Expr,\n-                        lhs_expr: &ast::Expr,\n-                        lhs_resolved_t: ty::t,\n-                        op: ast::BinOp,\n-                        rhs: &P<ast::Expr>) -> ty::t {\n+    fn check_user_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  ex: &ast::Expr,\n+                                  lhs_expr: &ast::Expr,\n+                                  lhs_resolved_t: Ty<'tcx>,\n+                                  op: ast::BinOp,\n+                                  rhs: &P<ast::Expr>) -> Ty<'tcx> {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n         let (name, trait_did) = match op {\n@@ -3494,13 +3503,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         })\n     }\n \n-    fn check_user_unop(fcx: &FnCtxt,\n-                       op_str: &str,\n-                       mname: &str,\n-                       trait_did: Option<ast::DefId>,\n-                       ex: &ast::Expr,\n-                       rhs_expr: &ast::Expr,\n-                       rhs_t: ty::t) -> ty::t {\n+    fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                 op_str: &str,\n+                                 mname: &str,\n+                                 trait_did: Option<ast::DefId>,\n+                                 ex: &ast::Expr,\n+                                 rhs_expr: &ast::Expr,\n+                                 rhs_t: Ty<'tcx>) -> Ty<'tcx> {\n        lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n                         trait_did, rhs_expr, None, || {\n             fcx.type_error_message(ex.span, |actual| {\n@@ -3579,12 +3588,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n            .insert(local_def(expr.id), unboxed_closure);\n     }\n \n-    fn check_expr_fn(fcx: &FnCtxt,\n-                     expr: &ast::Expr,\n-                     store: ty::TraitStore,\n-                     decl: &ast::FnDecl,\n-                     body: &ast::Block,\n-                     expected: Expectation) {\n+    fn check_expr_fn<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                               expr: &ast::Expr,\n+                               store: ty::TraitStore,\n+                               decl: &ast::FnDecl,\n+                               body: &ast::Block,\n+                               expected: Expectation<'tcx>) {\n         let tcx = fcx.ccx.tcx;\n \n         debug!(\"check_expr_fn(expr={}, expected={})\",\n@@ -3691,7 +3700,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) =\n             autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n-                match ty::get(base_t).sty {\n+                match base_t.sty {\n                     ty::ty_struct(base_id, ref substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n@@ -3752,7 +3761,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) =\n             autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n-                match ty::get(base_t).sty {\n+                match base_t.sty {\n                     ty::ty_struct(base_id, ref substs) => {\n                         tuple_like = ty::is_tuple_struct(tcx, base_id);\n                         if tuple_like {\n@@ -3799,15 +3808,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         fcx.write_error(expr.id);\n     }\n \n-    fn check_struct_or_variant_fields(fcx: &FnCtxt,\n-                                      struct_ty: ty::t,\n-                                      span: Span,\n-                                      class_id: ast::DefId,\n-                                      node_id: ast::NodeId,\n-                                      substitutions: subst::Substs,\n-                                      field_types: &[ty::field_ty],\n-                                      ast_fields: &[ast::Field],\n-                                      check_completeness: bool)  {\n+    fn check_struct_or_variant_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                struct_ty: Ty<'tcx>,\n+                                                span: Span,\n+                                                class_id: ast::DefId,\n+                                                node_id: ast::NodeId,\n+                                                substitutions: subst::Substs<'tcx>,\n+                                                field_types: &[ty::field_ty],\n+                                                ast_fields: &[ast::Field],\n+                                                check_completeness: bool)  {\n         let tcx = fcx.ccx.tcx;\n \n         let mut class_field_map = FnvHashMap::new();\n@@ -3975,7 +3984,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n     }\n \n-    type ExprCheckerWithTy = fn(&FnCtxt, &ast::Expr, ty::t);\n+    type ExprCheckerWithTy = fn(&FnCtxt, &ast::Expr, Ty);\n \n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n@@ -4083,7 +4092,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                            Some(&**oprnd), oprnd_t, lvalue_pref) {\n                             Some(mt) => mt.ty,\n                             None => {\n-                                let is_newtype = match ty::get(oprnd_t).sty {\n+                                let is_newtype = match oprnd_t.sty {\n                                     ty::ty_struct(did, ref substs) => {\n                                         let fields = ty::struct_fields(fcx.tcx(), did, substs);\n                                         fields.len() == 1\n@@ -4112,7 +4121,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n-                         ty::get(oprnd_t).sty == ty::ty_bool) {\n+                         oprnd_t.sty == ty::ty_bool) {\n                         oprnd_t = check_user_unop(fcx, \"!\", \"not\",\n                                                   tcx.lang_items.not_trait(),\n                                                   expr, &**oprnd, oprnd_t);\n@@ -4378,7 +4387,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprVec(ref args) => {\n         let uty = match expected {\n             ExpectHasType(uty) => {\n-                match ty::get(uty).sty {\n+                match uty.sty {\n                         ty::ty_vec(ty, _) => Some(ty),\n                         _ => None\n                 }\n@@ -4394,7 +4403,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 uty\n             }\n             None => {\n-                let t: ty::t = fcx.infcx().next_ty_var();\n+                let t: Ty = fcx.infcx().next_ty_var();\n                 for e in args.iter() {\n                     check_expr_has_type(fcx, &**e, t);\n                 }\n@@ -4410,7 +4419,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         let uty = match expected {\n             ExpectHasType(uty) => {\n-                match ty::get(uty).sty {\n+                match uty.sty {\n                         ty::ty_vec(ty, _) => Some(ty),\n                         _ => None\n                 }\n@@ -4424,7 +4433,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 (uty, uty)\n             }\n             None => {\n-                let t: ty::t = fcx.infcx().next_ty_var();\n+                let t: Ty = fcx.infcx().next_ty_var();\n                 check_expr_has_type(fcx, &**element, t);\n                 (fcx.expr_ty(&**element), t)\n             }\n@@ -4501,7 +4510,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             Some(def) => {\n                 // Verify that this was actually a struct.\n                 let typ = ty::lookup_item_type(fcx.ccx.tcx, def.def_id());\n-                match ty::get(typ.ty).sty {\n+                match typ.ty.sty {\n                     ty::ty_struct(struct_did, _) => {\n                         check_struct_constructor(fcx,\n                                                  id,\n@@ -4692,8 +4701,8 @@ fn constrain_path_type_parameters(fcx: &FnCtxt,\n     });\n }\n \n-impl Expectation {\n-    fn only_has_type(self) -> Expectation {\n+impl<'tcx> Expectation<'tcx> {\n+    fn only_has_type(self) -> Expectation<'tcx> {\n         match self {\n             NoExpectation | ExpectCastableToType(..) => NoExpectation,\n             ExpectHasType(t) => ExpectHasType(t)\n@@ -4703,7 +4712,7 @@ impl Expectation {\n     // Resolves `expected` by a single level if it is a variable. If\n     // there is no expected type or resolution is not possible (e.g.,\n     // no constraints yet present), just returns `None`.\n-    fn resolve(self, fcx: &FnCtxt) -> Expectation {\n+    fn resolve<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n         match self {\n             NoExpectation => {\n                 NoExpectation\n@@ -4719,27 +4728,29 @@ impl Expectation {\n         }\n     }\n \n-    fn map(self, fcx: &FnCtxt, unpack: |&ty::sty| -> Expectation) -> Expectation {\n+    fn map<'a>(self, fcx: &FnCtxt<'a, 'tcx>,\n+               unpack: |&ty::sty<'tcx>| -> Expectation<'tcx>)\n+               -> Expectation<'tcx> {\n         match self.resolve(fcx) {\n             NoExpectation => NoExpectation,\n-            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&ty::get(t).sty),\n+            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&t.sty),\n         }\n     }\n \n-    fn map_to_option<O>(self,\n-                        fcx: &FnCtxt,\n-                        unpack: |&ty::sty| -> Option<O>)\n-                        -> Option<O>\n+    fn map_to_option<'a, O>(self,\n+                            fcx: &FnCtxt<'a, 'tcx>,\n+                            unpack: |&ty::sty<'tcx>| -> Option<O>)\n+                            -> Option<O>\n     {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n-            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&ty::get(t).sty),\n+            ExpectCastableToType(t) | ExpectHasType(t) => unpack(&t.sty),\n         }\n     }\n }\n \n-impl Repr for Expectation {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for Expectation<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             NoExpectation => format!(\"NoExpectation\"),\n             ExpectHasType(t) => format!(\"ExpectHasType({})\",\n@@ -4842,9 +4853,9 @@ pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n     }\n }\n \n-fn check_block_with_expected(fcx: &FnCtxt,\n-                             blk: &ast::Block,\n-                             expected: Expectation) {\n+fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                       blk: &ast::Block,\n+                                       expected: Expectation<'tcx>) {\n     let prev = {\n         let mut fcx_ps = fcx.ps.borrow_mut();\n         let fn_style_state = fcx_ps.recurse(blk);\n@@ -4925,9 +4936,9 @@ fn check_block_with_expected(fcx: &FnCtxt,\n /// Checks a constant appearing in a type. At the moment this is just the\n /// length expression in a fixed-length vector, but someday it might be\n /// extended to type-level numeric literals.\n-pub fn check_const_in_type(tcx: &ty::ctxt,\n-                           expr: &ast::Expr,\n-                           expected_type: ty::t) {\n+pub fn check_const_in_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 expr: &ast::Expr,\n+                                 expected_type: Ty<'tcx>) {\n     // Synthesize a crate context. The trait map is not needed here (though I\n     // imagine it will be if we have associated statics --pcwalton), so we\n     // leave it blank.\n@@ -4951,10 +4962,10 @@ pub fn check_const(ccx: &CrateCtxt,\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n \n-pub fn check_const_with_ty(fcx: &FnCtxt,\n-                           _: Span,\n-                           e: &ast::Expr,\n-                           declty: ty::t) {\n+pub fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                     _: Span,\n+                                     e: &ast::Expr,\n+                                     declty: Ty<'tcx>) {\n     // Gather locals in statics (because of block expressions).\n     // This is technically unnecessary because locals in static items are forbidden,\n     // but prevents type checking from blowing up before const checking can properly\n@@ -5031,7 +5042,7 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n         span_err!(tcx.sess, sp, E0074, \"SIMD vector cannot be generic\");\n         return;\n     }\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_struct(did, ref substs) => {\n             let fields = ty::lookup_struct_fields(tcx, did);\n             if fields.is_empty() {\n@@ -5086,11 +5097,11 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n         }\n     }\n \n-    fn do_check(ccx: &CrateCtxt,\n-                vs: &[P<ast::Variant>],\n-                id: ast::NodeId,\n-                hint: attr::ReprAttr)\n-                -> Vec<Rc<ty::VariantInfo>> {\n+    fn do_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                          vs: &[P<ast::Variant>],\n+                          id: ast::NodeId,\n+                          hint: attr::ReprAttr)\n+                          -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n         let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n@@ -5211,10 +5222,10 @@ pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> def::Def {\n }\n \n // Returns the type parameter count and the type for the given definition.\n-pub fn polytype_for_def(fcx: &FnCtxt,\n-                        sp: Span,\n-                        defn: def::Def)\n-                        -> Polytype {\n+pub fn polytype_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  sp: Span,\n+                                  defn: def::Def)\n+                                  -> Polytype<'tcx> {\n     match defn {\n       def::DefLocal(nid) | def::DefUpvar(nid, _, _) => {\n           let typ = fcx.local_ty(sp, nid);\n@@ -5255,12 +5266,12 @@ pub fn polytype_for_def(fcx: &FnCtxt,\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n-pub fn instantiate_path(fcx: &FnCtxt,\n-                        path: &ast::Path,\n-                        polytype: Polytype,\n-                        def: def::Def,\n-                        span: Span,\n-                        node_id: ast::NodeId) {\n+pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  path: &ast::Path,\n+                                  polytype: Polytype<'tcx>,\n+                                  def: def::Def,\n+                                  span: Span,\n+                                  node_id: ast::NodeId) {\n     debug!(\"instantiate_path(path={}, def={}, node_id={}, polytype={})\",\n            path.repr(fcx.tcx()),\n            def.repr(fcx.tcx()),\n@@ -5472,14 +5483,14 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         }\n     }\n \n-    fn push_explicit_parameters_from_segment_to_substs(\n-        fcx: &FnCtxt,\n+    fn push_explicit_parameters_from_segment_to_substs<'a, 'tcx>(\n+        fcx: &FnCtxt<'a, 'tcx>,\n         space: subst::ParamSpace,\n         span: Span,\n-        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n         region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n         segment: &ast::PathSegment,\n-        substs: &mut Substs)\n+        substs: &mut Substs<'tcx>)\n     {\n         /*!\n          * Finds the parameters that the user provided and adds them\n@@ -5511,13 +5522,13 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         }\n     }\n \n-    fn push_explicit_angle_bracketed_parameters_from_segment_to_substs(\n-        fcx: &FnCtxt,\n+    fn push_explicit_angle_bracketed_parameters_from_segment_to_substs<'a, 'tcx>(\n+        fcx: &FnCtxt<'a, 'tcx>,\n         space: subst::ParamSpace,\n-        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n         region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n         data: &ast::AngleBracketedParameterData,\n-        substs: &mut Substs)\n+        substs: &mut Substs<'tcx>)\n     {\n         {\n             let type_count = type_defs.len(space);\n@@ -5556,13 +5567,13 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         }\n     }\n \n-    fn push_explicit_parenthesized_parameters_from_segment_to_substs(\n-        fcx: &FnCtxt,\n+    fn push_explicit_parenthesized_parameters_from_segment_to_substs<'a, 'tcx>(\n+        fcx: &FnCtxt<'a, 'tcx>,\n         space: subst::ParamSpace,\n         span: Span,\n-        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n         data: &ast::ParenthesizedParameterData,\n-        substs: &mut Substs)\n+        substs: &mut Substs<'tcx>)\n     {\n         /*!\n          * As with\n@@ -5581,7 +5592,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                       type_count);\n         }\n \n-        let input_tys: Vec<ty::t> =\n+        let input_tys: Vec<Ty> =\n             data.inputs.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n \n         let tuple_ty =\n@@ -5591,7 +5602,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n             substs.types.push(space, tuple_ty);\n         }\n \n-        let output_ty: Option<ty::t> =\n+        let output_ty: Option<Ty> =\n             data.output.as_ref().map(|ty| fcx.to_ty(&**ty));\n \n         let output_ty =\n@@ -5602,12 +5613,12 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         }\n     }\n \n-    fn adjust_type_parameters(\n-        fcx: &FnCtxt,\n+    fn adjust_type_parameters<'a, 'tcx>(\n+        fcx: &FnCtxt<'a, 'tcx>,\n         span: Span,\n         space: ParamSpace,\n-        defs: &VecPerParamSpace<ty::TypeParameterDef>,\n-        substs: &mut Substs)\n+        defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n+        substs: &mut Substs<'tcx>)\n     {\n         let provided_len = substs.types.len(space);\n         let desired = defs.get_slice(space);\n@@ -5707,7 +5718,8 @@ pub fn instantiate_path(fcx: &FnCtxt,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, mut ty: ty::t) -> ty::t {\n+pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                                            mut ty: Ty<'tcx>) -> Ty<'tcx> {\n     // If `ty` is a type variable, see whether we already know what it is.\n     ty = fcx.infcx().shallow_resolve(ty);\n \n@@ -5736,9 +5748,9 @@ pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, mut ty: ty::t) -> ty::\n }\n \n // Returns the one-level-deep structure of the given type.\n-pub fn structure_of<'a>(fcx: &FnCtxt, sp: Span, typ: ty::t)\n-                        -> &'a ty::sty {\n-    &ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n+pub fn structure_of<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span, typ: Ty<'tcx>)\n+                        -> &'tcx ty::sty<'tcx> {\n+    &structurally_resolved_type(fcx, sp, typ).sty\n }\n \n // Returns true if b contains a break that can exit from b\n@@ -5765,10 +5777,10 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n         }}))\n }\n \n-pub fn check_bounds_are_used(ccx: &CrateCtxt,\n-                             span: Span,\n-                             tps: &OwnedSlice<ast::TyParam>,\n-                             ty: ty::t) {\n+pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                       span: Span,\n+                                       tps: &OwnedSlice<ast::TyParam>,\n+                                       ty: Ty<'tcx>) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={})\",\n            tps.len(), ppaux::ty_to_string(ccx.tcx, ty));\n \n@@ -5777,7 +5789,7 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n     let mut tps_used = Vec::from_elem(tps.len(), false);\n \n     ty::walk_ty(ty, |t| {\n-            match ty::get(t).sty {\n+            match t.sty {\n                 ty::ty_param(ParamTy {idx, ..}) => {\n                     debug!(\"Found use of ty param num {}\", idx);\n                     tps_used[idx] = true;\n@@ -5796,7 +5808,7 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n }\n \n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n-    fn param(ccx: &CrateCtxt, n: uint) -> ty::t {\n+    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: uint) -> Ty<'tcx> {\n         ty::mk_param(ccx.tcx, subst::FnSpace, n, local_def(0))\n     }\n \n@@ -6077,8 +6089,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     }\n }\n \n-impl Repr for RegionObligation {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for RegionObligation<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"RegionObligation(sub_region={}, sup_type={}, origin={})\",\n                 self.sub_region.repr(tcx),\n                 self.sup_type.repr(tcx),"}, {"sha": "44c11318038d39c244c78072b8f5cc8f1abeadc5", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -122,7 +122,7 @@ use middle::def;\n use middle::mem_categorization as mc;\n use middle::traits;\n use middle::ty::{ReScope};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::FnCtxt;\n use middle::typeck::check::regionmanip;\n@@ -176,9 +176,9 @@ pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, blk: &ast::Block) {\n     fcx.infcx().resolve_regions_and_report_errors();\n }\n \n-pub fn regionck_ensure_component_tys_wf(fcx: &FnCtxt,\n-                                        span: Span,\n-                                        component_tys: &[ty::t]) {\n+pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                  span: Span,\n+                                                  component_tys: &[Ty<'tcx>]) {\n     /*!\n      * Checks that the types in `component_tys` are well-formed.\n      * This will add constraints into the region graph.\n@@ -215,15 +215,15 @@ macro_rules! ignore_err(\n // Stores parameters for a potential call to link_region()\n // to perform if an upvar reference is marked unique/mutable after\n // it has already been processed before.\n-struct MaybeLink {\n+struct MaybeLink<'tcx> {\n     span: Span,\n     borrow_region: ty::Region,\n     borrow_kind: ty::BorrowKind,\n-    borrow_cmt: mc::cmt\n+    borrow_cmt: mc::cmt<'tcx>\n }\n \n // A map associating an upvar ID to a vector of the above\n-type MaybeLinkMap = RefCell<FnvHashMap<ty::UpvarId, Vec<MaybeLink>>>;\n+type MaybeLinkMap<'tcx> = RefCell<FnvHashMap<ty::UpvarId, Vec<MaybeLink<'tcx>>>>;\n \n pub struct Rcx<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -235,7 +235,7 @@ pub struct Rcx<'a, 'tcx: 'a> {\n \n     // Possible region links we will establish if an upvar\n     // turns out to be unique/mutable\n-    maybe_links: MaybeLinkMap\n+    maybe_links: MaybeLinkMap<'tcx>\n }\n \n fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n@@ -282,7 +282,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         old_scope\n     }\n \n-    pub fn resolve_type(&self, unresolved_ty: ty::t) -> ty::t {\n+    pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n         /*!\n          * Try to resolve the type for the given node, returning\n          * t_err if an error results.  Note that we never care\n@@ -319,19 +319,19 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_node_type(&self, id: ast::NodeId) -> ty::t {\n+    fn resolve_node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n         let t = self.fcx.node_ty(id);\n         self.resolve_type(t)\n     }\n \n-    fn resolve_method_type(&self, method_call: MethodCall) -> Option<ty::t> {\n+    fn resolve_method_type(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n         let method_ty = self.fcx.inh.method_map.borrow()\n                             .get(&method_call).map(|method| method.ty);\n         method_ty.map(|method_ty| self.resolve_type(method_ty))\n     }\n \n     /// Try to resolve the type for the given node.\n-    pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> ty::t {\n+    pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> Ty<'tcx> {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n         if ty::type_is_error(ty_unadjusted) {\n             ty_unadjusted\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     }\n \n     fn relate_free_regions(&mut self,\n-                           fn_sig_tys: &[ty::t],\n+                           fn_sig_tys: &[Ty<'tcx>],\n                            body_id: ast::NodeId) {\n         /*!\n          * This method populates the region map's `free_region_map`.\n@@ -457,16 +457,16 @@ impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n         self.fcx.ccx.tcx\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n         let t = self.resolve_node_type(id);\n         if ty::type_is_error(t) {Err(())} else {Ok(t)}\n     }\n \n-    fn node_method_ty(&self, method_call: MethodCall) -> Option<ty::t> {\n+    fn node_method_ty(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n         self.resolve_method_type(method_call)\n     }\n \n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.fcx.inh.adjustments\n     }\n \n@@ -488,7 +488,7 @@ impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n     }\n \n     fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure>> {\n+                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n         &self.fcx.inh.unboxed_closures\n     }\n }\n@@ -693,7 +693,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 }\n                 None => rcx.resolve_node_type(base.id)\n             };\n-            match ty::get(base_ty).sty {\n+            match base_ty.sty {\n                 ty::ty_rptr(r_ptr, _) => {\n                     mk_subregion_due_to_dereference(rcx, expr.span,\n                                                     ty::ReScope(expr.id), r_ptr);\n@@ -807,14 +807,14 @@ fn constrain_cast(rcx: &mut Rcx,\n \n     walk_cast(rcx, cast_expr, source_ty, target_ty);\n \n-    fn walk_cast(rcx: &mut Rcx,\n-                 cast_expr: &ast::Expr,\n-                 from_ty: ty::t,\n-                 to_ty: ty::t) {\n+    fn walk_cast<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                           cast_expr: &ast::Expr,\n+                           from_ty: Ty<'tcx>,\n+                           to_ty: Ty<'tcx>) {\n         debug!(\"walk_cast(from_ty={}, to_ty={})\",\n                from_ty.repr(rcx.tcx()),\n                to_ty.repr(rcx.tcx()));\n-        match (&ty::get(from_ty).sty, &ty::get(to_ty).sty) {\n+        match (&from_ty.sty, &to_ty.sty) {\n             /*From:*/ (&ty::ty_rptr(from_r, ref from_mt),\n             /*To:  */  &ty::ty_rptr(to_r, ref to_mt)) => {\n                 // Target cannot outlive source, naturally.\n@@ -846,7 +846,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     let tcx = rcx.fcx.tcx();\n     let function_type = rcx.resolve_node_type(expr.id);\n \n-    match ty::get(function_type).sty {\n+    match function_type.sty {\n         ty::ty_closure(box ty::ClosureTy{store: ty::RegionTraitStore(..),\n                                          ref bounds,\n                                          ..}) => {\n@@ -889,7 +889,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     visit::walk_expr(rcx, expr);\n     rcx.set_repeating_scope(repeating_scope);\n \n-    match ty::get(function_type).sty {\n+    match function_type.sty {\n         ty::ty_closure(box ty::ClosureTy { store: ty::RegionTraitStore(..), .. }) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 propagate_upupvar_borrow_kind(rcx, expr, freevars);\n@@ -905,7 +905,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         _ => {}\n     }\n \n-    match ty::get(function_type).sty {\n+    match function_type.sty {\n         ty::ty_closure(box ty::ClosureTy {bounds, ..}) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);\n@@ -1092,7 +1092,7 @@ fn constrain_callee(rcx: &mut Rcx,\n     let call_region = ty::ReScope(call_expr.id);\n \n     let callee_ty = rcx.resolve_node_type(callee_id);\n-    match ty::get(callee_ty).sty {\n+    match callee_ty.sty {\n         ty::ty_bare_fn(..) => { }\n         ty::ty_closure(ref closure_ty) => {\n             let region = match closure_ty.store {\n@@ -1182,10 +1182,10 @@ fn constrain_call<'a, I: Iterator<&'a ast::Expr>>(rcx: &mut Rcx,\n     }\n }\n \n-fn constrain_autoderefs(rcx: &mut Rcx,\n-                        deref_expr: &ast::Expr,\n-                        derefs: uint,\n-                        mut derefd_ty: ty::t) {\n+fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                                  deref_expr: &ast::Expr,\n+                                  derefs: uint,\n+                                  mut derefd_ty: Ty<'tcx>) {\n     /*!\n      * Invoked on any auto-dereference that occurs.  Checks that if\n      * this is a region pointer being dereferenced, the lifetime of\n@@ -1204,7 +1204,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = ty::ty_fn_sig(method.ty);\n                 let self_ty = fn_sig.inputs[0];\n-                let (m, r) = match ty::get(self_ty).sty {\n+                let (m, r) = match self_ty.sty {\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                     _ => rcx.tcx().sess.span_bug(deref_expr.span,\n                             format!(\"bad overloaded deref type {}\",\n@@ -1232,7 +1232,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n             None => derefd_ty\n         };\n \n-        match ty::get(derefd_ty).sty {\n+        match derefd_ty.sty {\n             ty::ty_rptr(r_ptr, _) => {\n                 mk_subregion_due_to_dereference(rcx, deref_expr.span,\n                                                 r_deref_expr, r_ptr);\n@@ -1258,9 +1258,9 @@ pub fn mk_subregion_due_to_dereference(rcx: &mut Rcx,\n }\n \n \n-fn constrain_index(rcx: &mut Rcx,\n-                   index_expr: &ast::Expr,\n-                   indexed_ty: ty::t)\n+fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                             index_expr: &ast::Expr,\n+                             indexed_ty: Ty<'tcx>)\n {\n     /*!\n      * Invoked on any index expression that occurs.  Checks that if\n@@ -1272,8 +1272,8 @@ fn constrain_index(rcx: &mut Rcx,\n            rcx.fcx.infcx().ty_to_string(indexed_ty));\n \n     let r_index_expr = ty::ReScope(index_expr.id);\n-    match ty::get(indexed_ty).sty {\n-        ty::ty_rptr(r_ptr, mt) => match ty::get(mt.ty).sty {\n+    match indexed_ty.sty {\n+        ty::ty_rptr(r_ptr, mt) => match mt.ty.sty {\n             ty::ty_vec(_, None) | ty::ty_str => {\n                 rcx.fcx.mk_subr(infer::IndexSlice(index_expr.span),\n                                 r_index_expr, r_ptr);\n@@ -1285,9 +1285,9 @@ fn constrain_index(rcx: &mut Rcx,\n     }\n }\n \n-fn type_of_node_must_outlive(\n-    rcx: &mut Rcx,\n-    origin: infer::SubregionOrigin,\n+fn type_of_node_must_outlive<'a, 'tcx>(\n+    rcx: &mut Rcx<'a, 'tcx>,\n+    origin: infer::SubregionOrigin<'tcx>,\n     id: ast::NodeId,\n     minimum_lifetime: ty::Region)\n {\n@@ -1365,10 +1365,10 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     }\n }\n \n-fn link_pattern(rcx: &Rcx,\n-                mc: mc::MemCategorizationContext<Rcx>,\n-                discr_cmt: mc::cmt,\n-                root_pat: &ast::Pat) {\n+fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                          mc: mc::MemCategorizationContext<Rcx<'a, 'tcx>>,\n+                          discr_cmt: mc::cmt<'tcx>,\n+                          root_pat: &ast::Pat) {\n     /*!\n      * Link lifetimes of any ref bindings in `root_pat` to\n      * the pointers found in the discriminant, if needed.\n@@ -1441,11 +1441,11 @@ fn link_by_ref(rcx: &Rcx,\n     link_region(rcx, expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n }\n \n-fn link_region_from_node_type(rcx: &Rcx,\n-                              span: Span,\n-                              id: ast::NodeId,\n-                              mutbl: ast::Mutability,\n-                              cmt_borrowed: mc::cmt) {\n+fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                        span: Span,\n+                                        id: ast::NodeId,\n+                                        mutbl: ast::Mutability,\n+                                        cmt_borrowed: mc::cmt<'tcx>) {\n     /*!\n      * Like `link_region()`, except that the region is\n      * extracted from the type of `id`, which must be some\n@@ -1462,11 +1462,11 @@ fn link_region_from_node_type(rcx: &Rcx,\n     }\n }\n \n-fn link_region(rcx: &Rcx,\n-               span: Span,\n-               borrow_region: ty::Region,\n-               borrow_kind: ty::BorrowKind,\n-               borrow_cmt: mc::cmt) {\n+fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                         span: Span,\n+                         borrow_region: ty::Region,\n+                         borrow_kind: ty::BorrowKind,\n+                         borrow_cmt: mc::cmt<'tcx>) {\n     /*!\n      * Informs the inference engine that `borrow_cmt` is being\n      * borrowed with kind `borrow_kind` and lifetime `borrow_region`.\n@@ -1524,15 +1524,15 @@ fn link_region(rcx: &Rcx,\n     }\n }\n \n-fn link_reborrowed_region(rcx: &Rcx,\n-                          span: Span,\n-                          borrow_region: ty::Region,\n-                          borrow_kind: ty::BorrowKind,\n-                          ref_cmt: mc::cmt,\n-                          ref_region: ty::Region,\n-                          mut ref_kind: ty::BorrowKind,\n-                          note: mc::Note)\n-                          -> Option<(mc::cmt, ty::BorrowKind)>\n+fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                    span: Span,\n+                                    borrow_region: ty::Region,\n+                                    borrow_kind: ty::BorrowKind,\n+                                    ref_cmt: mc::cmt<'tcx>,\n+                                    ref_region: ty::Region,\n+                                    mut ref_kind: ty::BorrowKind,\n+                                    note: mc::Note)\n+                                    -> Option<(mc::cmt<'tcx>, ty::BorrowKind)>\n {\n     /*!\n      * This is the most complicated case: the path being borrowed is\n@@ -1727,8 +1727,8 @@ fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n     adjust_upvar_borrow_kind_for_mut(rcx, cmt);\n }\n \n-fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n-                                    cmt: mc::cmt) {\n+fn adjust_upvar_borrow_kind_for_mut<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                              cmt: mc::cmt<'tcx>) {\n     /*!\n      * Indicates that `cmt` is being directly mutated (e.g., assigned\n      * to).  If cmt contains any by-ref upvars, this implies that\n@@ -1785,7 +1785,7 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n     }\n }\n \n-fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n+fn adjust_upvar_borrow_kind_for_unique<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, cmt: mc::cmt<'tcx>) {\n     let mut cmt = cmt;\n     loop {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n@@ -1910,10 +1910,10 @@ fn adjust_upvar_borrow_kind(rcx: &Rcx,\n     }\n }\n \n-fn type_must_outlive(rcx: &mut Rcx,\n-                     origin: infer::SubregionOrigin,\n-                     ty: ty::t,\n-                     region: ty::Region)\n+fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                               origin: infer::SubregionOrigin<'tcx>,\n+                               ty: Ty<'tcx>,\n+                               region: ty::Region)\n {\n     /*!\n      * Ensures that all borrowed data reachable via `ty` outlives `region`.\n@@ -1949,10 +1949,10 @@ fn type_must_outlive(rcx: &mut Rcx,\n     }\n }\n \n-fn param_must_outlive(rcx: &Rcx,\n-                      origin: infer::SubregionOrigin,\n-                      region: ty::Region,\n-                      param_ty: ty::ParamTy) {\n+fn param_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                origin: infer::SubregionOrigin<'tcx>,\n+                                region: ty::Region,\n+                                param_ty: ty::ParamTy) {\n     let param_env = &rcx.fcx.inh.param_env;\n \n     debug!(\"param_must_outlive(region={}, param_ty={})\","}, {"sha": "9fd24c4ee784e411a0bfc2df0a9bff9bc391388f", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -13,7 +13,7 @@\n pub use self::WfConstraint::*;\n \n use middle::subst::{ParamSpace, Subst, Substs};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold::{TypeFolder};\n \n use syntax::ast;\n@@ -22,22 +22,22 @@ use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n \n-pub enum WfConstraint {\n-    RegionSubRegionConstraint(Option<ty::t>, ty::Region, ty::Region),\n-    RegionSubParamConstraint(Option<ty::t>, ty::Region, ty::ParamTy),\n+pub enum WfConstraint<'tcx> {\n+    RegionSubRegionConstraint(Option<Ty<'tcx>>, ty::Region, ty::Region),\n+    RegionSubParamConstraint(Option<Ty<'tcx>>, ty::Region, ty::ParamTy),\n }\n \n struct Wf<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    stack: Vec<(ty::Region, Option<ty::t>)>,\n-    out: Vec<WfConstraint>,\n+    stack: Vec<(ty::Region, Option<Ty<'tcx>>)>,\n+    out: Vec<WfConstraint<'tcx>>,\n }\n \n-pub fn region_wf_constraints(\n-    tcx: &ty::ctxt,\n-    ty: ty::t,\n+pub fn region_wf_constraints<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    ty: Ty<'tcx>,\n     outer_region: ty::Region)\n-    -> Vec<WfConstraint>\n+    -> Vec<WfConstraint<'tcx>>\n {\n     /*!\n      * This routine computes the well-formedness constraints that must\n@@ -55,11 +55,11 @@ pub fn region_wf_constraints(\n }\n \n impl<'a, 'tcx> Wf<'a, 'tcx> {\n-    fn accumulate_from_ty(&mut self, ty: ty::t) {\n+    fn accumulate_from_ty(&mut self, ty: Ty<'tcx>) {\n         debug!(\"Wf::accumulate_from_ty(ty={})\",\n                ty.repr(self.tcx));\n \n-        match ty::get(ty).sty {\n+        match ty.sty {\n             ty::ty_bool |\n             ty::ty_char |\n             ty::ty_int(..) |\n@@ -146,9 +146,9 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     }\n \n     fn accumulate_from_rptr(&mut self,\n-                            ty: ty::t,\n+                            ty: Ty<'tcx>,\n                             r_b: ty::Region,\n-                            ty_b: ty::t) {\n+                            ty_b: Ty<'tcx>) {\n         // We are walking down a type like this, and current\n         // position is indicated by caret:\n         //\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     }\n \n     fn push_sub_region_constraint(&mut self,\n-                                  opt_ty: Option<ty::t>,\n+                                  opt_ty: Option<Ty<'tcx>>,\n                                   r_a: ty::Region,\n                                   r_b: ty::Region) {\n         /*! Pushes a constraint that `r_a <= r_b`, due to `opt_ty` */\n@@ -213,16 +213,16 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n     fn push_param_constraint(&mut self,\n                              region: ty::Region,\n-                             opt_ty: Option<ty::t>,\n+                             opt_ty: Option<Ty<'tcx>>,\n                              param_ty: ty::ParamTy) {\n         /*! Pushes a constraint that `region <= param_ty`, due to `opt_ty` */\n         self.out.push(RegionSubParamConstraint(opt_ty, region, param_ty));\n     }\n \n     fn accumulate_from_adt(&mut self,\n-                           ty: ty::t,\n+                           ty: Ty<'tcx>,\n                            def_id: ast::DefId,\n-                           substs: &Substs)\n+                           substs: &Substs<'tcx>)\n     {\n         // The generic declarations from the type, appropriately\n         // substituted for the actual substitutions.\n@@ -322,8 +322,8 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     }\n \n     fn accumulate_from_closure_ty(&mut self,\n-                                  ty: ty::t,\n-                                  c: &ty::ClosureTy)\n+                                  ty: Ty<'tcx>,\n+                                  c: &ty::ClosureTy<'tcx>)\n     {\n         match c.store {\n             ty::RegionTraitStore(r_b, _) => {\n@@ -336,7 +336,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     }\n \n     fn accumulate_from_object_ty(&mut self,\n-                                 ty: ty::t,\n+                                 ty: Ty<'tcx>,\n                                  bounds: &ty::ExistentialBounds)\n     {\n         // Imagine a type like this:"}, {"sha": "99ffe898622297fc6cd86e77b93ae597b3c6eafd", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -14,7 +14,7 @@ use middle::traits::{SelectionError, OutputTypeParameterMismatch, Overflow, Unim\n use middle::traits::{Obligation, obligation_for_builtin_bound};\n use middle::traits::{FulfillmentError, CodeSelectionError, CodeAmbiguity};\n use middle::traits::{ObligationCause};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::check::{FnCtxt,\n                             structurally_resolved_type};\n use middle::typeck::infer;\n@@ -23,10 +23,10 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::{UserString, Repr, ty_to_string};\n \n-pub fn check_object_cast(fcx: &FnCtxt,\n-                         cast_expr: &ast::Expr,\n-                         source_expr: &ast::Expr,\n-                         target_object_ty: ty::t)\n+pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                   cast_expr: &ast::Expr,\n+                                   source_expr: &ast::Expr,\n+                                   target_object_ty: Ty<'tcx>)\n {\n     debug!(\"check_object_cast(cast_expr={}, target_object_ty={})\",\n            cast_expr.repr(fcx.tcx()),\n@@ -39,7 +39,7 @@ pub fn check_object_cast(fcx: &FnCtxt,\n     let source_ty = fcx.expr_ty(source_expr);\n     let source_ty = structurally_resolved_type(fcx, source_expr.span, source_ty);\n     debug!(\"source_ty={}\", source_ty.repr(fcx.tcx()));\n-    match (&ty::get(source_ty).sty, &ty::get(target_object_ty).sty) {\n+    match (&source_ty.sty, &target_object_ty.sty) {\n         (&ty::ty_uniq(referent_ty), &ty::ty_uniq(object_trait_ty)) => {\n             let object_trait = object_trait(&object_trait_ty);\n \n@@ -96,11 +96,8 @@ pub fn check_object_cast(fcx: &FnCtxt,\n         }\n     }\n \n-    // Because we currently give unsound lifetimes to the \"t_box\", I\n-    // could have written &'static ty::TyTrait here, but it seems\n-    // gratuitously unsafe.\n-    fn object_trait<'a>(t: &'a ty::t) -> &'a ty::TyTrait {\n-        match ty::get(*t).sty {\n+    fn object_trait<'a, 'tcx>(t: &'a Ty<'tcx>) -> &'a ty::TyTrait<'tcx> {\n+        match t.sty {\n             ty::ty_trait(ref ty_trait) => &**ty_trait,\n             _ => panic!(\"expected ty_trait\")\n         }\n@@ -113,10 +110,10 @@ pub fn check_object_cast(fcx: &FnCtxt,\n             (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n     }\n \n-    fn push_cast_obligation(fcx: &FnCtxt,\n-                            cast_expr: &ast::Expr,\n-                            object_trait: &ty::TyTrait,\n-                            referent_ty: ty::t) {\n+    fn push_cast_obligation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                      cast_expr: &ast::Expr,\n+                                      object_trait: &ty::TyTrait<'tcx>,\n+                                      referent_ty: Ty<'tcx>) {\n         let object_trait_ref =\n             register_object_cast_obligations(fcx,\n                                              cast_expr.span,\n@@ -135,7 +132,9 @@ pub fn check_object_cast(fcx: &FnCtxt,\n // methods are object-safe. A trait method is object-safe if it does not take\n // self by value, has no type parameters and does not use the `Self` type, except\n // in self position.\n-pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Span) {\n+pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 object_trait: &ty::TyTrait<'tcx>,\n+                                 span: Span) {\n     // Skip the fn_once lang item trait since only the compiler should call\n     // `call_once` which is the method which takes self by value. What could go\n     // wrong?\n@@ -169,7 +168,9 @@ pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Spa\n     }\n \n     // Returns a vec of error messages. If hte vec is empty - no errors!\n-    fn check_object_safety_of_method(tcx: &ty::ctxt, method: &ty::Method) -> Vec<String> {\n+    fn check_object_safety_of_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                           method: &ty::Method<'tcx>)\n+                                           -> Vec<String> {\n         /*!\n          * There are some limitations to calling functions through an\n          * object, because (a) the self type is not known\n@@ -231,11 +232,11 @@ pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Spa\n     }\n }\n \n-pub fn register_object_cast_obligations(fcx: &FnCtxt,\n-                                        span: Span,\n-                                        object_trait: &ty::TyTrait,\n-                                        referent_ty: ty::t)\n-                                        -> Rc<ty::TraitRef>\n+pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                  span: Span,\n+                                                  object_trait: &ty::TyTrait<'tcx>,\n+                                                  referent_ty: Ty<'tcx>)\n+                                                  -> Rc<ty::TraitRef<'tcx>>\n {\n     // This is just for better error reporting. Kinda goofy. The object type stuff\n     // needs some refactoring so there is a more convenient type to pass around.\n@@ -299,8 +300,8 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     }\n }\n \n-fn resolve_trait_ref(fcx: &FnCtxt, obligation: &Obligation)\n-                     -> (Rc<ty::TraitRef>, ty::t)\n+fn resolve_trait_ref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, obligation: &Obligation<'tcx>)\n+                               -> (Rc<ty::TraitRef<'tcx>>, Ty<'tcx>)\n {\n     let trait_ref =\n         fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n@@ -310,15 +311,15 @@ fn resolve_trait_ref(fcx: &FnCtxt, obligation: &Obligation)\n     (Rc::new(trait_ref), self_ty)\n }\n \n-pub fn report_fulfillment_errors(fcx: &FnCtxt,\n-                                 errors: &Vec<FulfillmentError>) {\n+pub fn report_fulfillment_errors<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                           errors: &Vec<FulfillmentError<'tcx>>) {\n     for error in errors.iter() {\n         report_fulfillment_error(fcx, error);\n     }\n }\n \n-pub fn report_fulfillment_error(fcx: &FnCtxt,\n-                                error: &FulfillmentError) {\n+pub fn report_fulfillment_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                          error: &FulfillmentError<'tcx>) {\n     match error.code {\n         CodeSelectionError(ref e) => {\n             report_selection_error(fcx, &error.obligation, e);\n@@ -329,9 +330,9 @@ pub fn report_fulfillment_error(fcx: &FnCtxt,\n     }\n }\n \n-pub fn report_selection_error(fcx: &FnCtxt,\n-                              obligation: &Obligation,\n-                              error: &SelectionError)\n+pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                        obligation: &Obligation<'tcx>,\n+                                        error: &SelectionError<'tcx>)\n {\n     match *error {\n         Overflow => {\n@@ -377,7 +378,8 @@ pub fn report_selection_error(fcx: &FnCtxt,\n     }\n }\n \n-pub fn maybe_report_ambiguity(fcx: &FnCtxt, obligation: &Obligation) {\n+pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                        obligation: &Obligation<'tcx>) {\n     // Unable to successfully determine, probably means\n     // insufficient type information, but could mean\n     // ambiguous impls. The latter *ought* to be a\n@@ -469,8 +471,8 @@ pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n     }\n }\n \n-fn note_obligation_cause(fcx: &FnCtxt,\n-                         obligation: &Obligation) {\n+fn note_obligation_cause<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                   obligation: &Obligation<'tcx>) {\n     let tcx = fcx.tcx();\n     let trait_name = ty::item_path_str(tcx, obligation.trait_ref.def_id);\n     match obligation.cause.code {"}, {"sha": "5cc619bba26ba48148dc85a4547de1dfd244abc7", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -11,7 +11,7 @@\n use middle::subst;\n use middle::subst::{Subst};\n use middle::traits;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::typeck::astconv::AstConv;\n@@ -29,15 +29,15 @@ use syntax::visit::Visitor;\n \n pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n     ccx: &'ccx CrateCtxt<'ccx, 'tcx>,\n-    cache: HashSet<ty::t>\n+    cache: HashSet<Ty<'tcx>>\n }\n \n impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     pub fn new(ccx: &'ccx CrateCtxt<'ccx, 'tcx>) -> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         CheckTypeWellFormedVisitor { ccx: ccx, cache: HashSet::new() }\n     }\n \n-    fn check_item_well_formed(&mut self, ccx: &CrateCtxt, item: &ast::Item) {\n+    fn check_item_well_formed(&mut self, item: &ast::Item) {\n         /*!\n          * Checks that the field types (in a struct def'n) or\n          * argument types (in an enum def'n) are well-formed,\n@@ -55,6 +55,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n          * the types first.\n          */\n \n+        let ccx = self.ccx;\n         debug!(\"check_item_well_formed(it.id={}, it.ident={})\",\n                item.id,\n                ty::item_path_str(ccx.tcx, local_def(item.id)));\n@@ -87,9 +88,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     }\n \n     fn with_fcx(&mut self,\n-                ccx: &CrateCtxt,\n                 item: &ast::Item,\n-                f: |&mut CheckTypeWellFormedVisitor, &FnCtxt|) {\n+                f: for<'fcx> |&mut CheckTypeWellFormedVisitor<'ccx, 'tcx>,\n+                              &FnCtxt<'fcx, 'tcx>|) {\n+        let ccx = self.ccx;\n         let item_def_id = local_def(item.id);\n         let polytype = ty::lookup_item_type(ccx.tcx, item_def_id);\n         let param_env =\n@@ -106,14 +108,15 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn check_type_defn(&mut self,\n                        item: &ast::Item,\n-                       lookup_fields: |&FnCtxt| -> Vec<AdtVariant>)\n+                       lookup_fields: for<'fcx> |&FnCtxt<'fcx, 'tcx>|\n+                                                 -> Vec<AdtVariant<'tcx>>)\n     {\n         /*!\n          * In a type definition, we check that to ensure that the types of the fields are\n          * well-formed.\n          */\n \n-        self.with_fcx(self.ccx, item, |this, fcx| {\n+        self.with_fcx(item, |this, fcx| {\n             let variants = lookup_fields(fcx);\n             let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n                                                         item.id, Some(&mut this.cache));\n@@ -139,7 +142,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n             }\n \n-            let field_tys: Vec<ty::t> =\n+            let field_tys: Vec<Ty> =\n                 variants.iter().flat_map(|v| v.fields.iter().map(|f| f.ty)).collect();\n \n             regionck::regionck_ensure_component_tys_wf(\n@@ -150,7 +153,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     fn check_item_type(&mut self,\n                        item: &ast::Item)\n     {\n-        self.with_fcx(self.ccx, item, |this, fcx| {\n+        self.with_fcx(item, |this, fcx| {\n             let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n                                                         item.id, Some(&mut this.cache));\n             let polytype = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n@@ -162,7 +165,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     fn check_impl(&mut self,\n                   item: &ast::Item)\n     {\n-        self.with_fcx(self.ccx, item, |this, fcx| {\n+        self.with_fcx(item, |this, fcx| {\n             let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n                                                         item.id, Some(&mut this.cache));\n \n@@ -190,7 +193,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 fcx.tcx().lang_items.drop_trait() == Some(trait_ref.def_id) &&\n                 !attr::contains_name(item.attrs.as_slice(), \"unsafe_destructor\")\n             {\n-                match ty::get(self_ty).sty {\n+                match self_ty.sty {\n                     ty::ty_struct(def_id, _) |\n                     ty::ty_enum(def_id, _) => {\n                         check_struct_safe_for_destructor(fcx, item.span, self_ty, def_id);\n@@ -245,8 +248,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n }\n \n impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n-    fn visit_item(&mut self, i: &'v ast::Item) {\n-        self.check_item_well_formed(self.ccx, i);\n+    fn visit_item(&mut self, i: &ast::Item) {\n+        self.check_item_well_formed(i);\n         visit::walk_item(self, i);\n     }\n }\n@@ -256,20 +259,20 @@ pub struct BoundsChecker<'cx,'tcx:'cx> {\n     span: Span,\n     scope_id: ast::NodeId,\n     binding_count: uint,\n-    cache: Option<&'cx mut HashSet<ty::t>>,\n+    cache: Option<&'cx mut HashSet<Ty<'tcx>>>,\n }\n \n impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n     pub fn new(fcx: &'cx FnCtxt<'cx,'tcx>,\n                span: Span,\n                scope_id: ast::NodeId,\n-               cache: Option<&'cx mut HashSet<ty::t>>)\n+               cache: Option<&'cx mut HashSet<Ty<'tcx>>>)\n                -> BoundsChecker<'cx,'tcx> {\n         BoundsChecker { fcx: fcx, span: span, scope_id: scope_id,\n                         cache: cache, binding_count: 0 }\n     }\n \n-    pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef) {\n+    pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n         /*!\n          * Given a trait ref like `A : Trait<B>`, where `Trait` is\n          * defined as (say):\n@@ -300,11 +303,11 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n         }\n     }\n \n-    pub fn check_ty(&mut self, ty: ty::t) {\n+    pub fn check_ty(&mut self, ty: Ty<'tcx>) {\n         ty.fold_with(self);\n     }\n \n-    fn check_traits_in_ty(&mut self, ty: ty::t) {\n+    fn check_traits_in_ty(&mut self, ty: Ty<'tcx>) {\n         // When checking types outside of a type def'n, we ignore\n         // region obligations. See discussion below in fold_ty().\n         self.binding_count += 1;\n@@ -318,7 +321,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         self.fcx.tcx()\n     }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"BoundsChecker t={}\",\n                t.repr(self.tcx()));\n \n@@ -333,7 +336,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n             None => { }\n         }\n \n-        match ty::get(t).sty{\n+        match t.sty{\n             ty::ty_struct(type_id, ref substs) |\n             ty::ty_enum(type_id, ref substs) => {\n                 let polytype = ty::lookup_item_type(self.fcx.tcx(), type_id);\n@@ -401,16 +404,18 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // ADT\n \n-struct AdtVariant {\n-    fields: Vec<AdtField>,\n+struct AdtVariant<'tcx> {\n+    fields: Vec<AdtField<'tcx>>,\n }\n \n-struct AdtField {\n-    ty: ty::t,\n+struct AdtField<'tcx> {\n+    ty: Ty<'tcx>,\n     span: Span,\n }\n \n-fn struct_variant(fcx: &FnCtxt, struct_def: &ast::StructDef) -> AdtVariant {\n+fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                            struct_def: &ast::StructDef)\n+                            -> AdtVariant<'tcx> {\n     let fields =\n         struct_def.fields\n         .iter()\n@@ -423,7 +428,9 @@ fn struct_variant(fcx: &FnCtxt, struct_def: &ast::StructDef) -> AdtVariant {\n     AdtVariant { fields: fields }\n }\n \n-fn enum_variants(fcx: &FnCtxt, enum_def: &ast::EnumDef) -> Vec<AdtVariant> {\n+fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                           enum_def: &ast::EnumDef)\n+                           -> Vec<AdtVariant<'tcx>> {\n     enum_def.variants.iter()\n         .map(|variant| {\n             match variant.node.kind {\n@@ -457,10 +464,10 @@ fn enum_variants(fcx: &FnCtxt, enum_def: &ast::EnumDef) -> Vec<AdtVariant> {\n ///////////////////////////////////////////////////////////////////////////\n // Special drop trait checking\n \n-fn check_struct_safe_for_destructor(fcx: &FnCtxt,\n-                                    span: Span,\n-                                    self_ty: ty::t,\n-                                    struct_did: ast::DefId) {\n+fn check_struct_safe_for_destructor<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                              span: Span,\n+                                              self_ty: Ty<'tcx>,\n+                                              struct_did: ast::DefId) {\n     let struct_tpt = ty::lookup_item_type(fcx.tcx(), struct_did);\n     if !struct_tpt.generics.has_type_params(subst::TypeSpace)\n         && !struct_tpt.generics.has_region_params(subst::TypeSpace)"}, {"sha": "76d9ed15e518018f08c0c5a239e1fb0bf7fa57b3", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -15,7 +15,7 @@ use self::ResolveReason::*;\n \n use middle::def;\n use middle::pat_util;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold::{TypeFolder,TypeFoldable};\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::FnCtxt;\n@@ -340,7 +340,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn resolve<T:ResolveIn>(&self, t: &T, reason: ResolveReason) -> T {\n+    fn resolve<T:ResolveIn<'tcx>>(&self, t: &T, reason: ResolveReason) -> T {\n         t.resolve_in(&mut Resolver::new(self.fcx, reason))\n     }\n }\n@@ -379,12 +379,12 @@ impl ResolveReason {\n ///////////////////////////////////////////////////////////////////////////\n // Convenience methods for resolving different kinds of things.\n \n-trait ResolveIn {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> Self;\n+trait ResolveIn<'tcx> {\n+    fn resolve_in<'a>(&self, resolver: &mut Resolver<'a, 'tcx>) -> Self;\n }\n \n-impl<T:TypeFoldable> ResolveIn for T {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> T {\n+impl<'tcx, T: TypeFoldable<'tcx>> ResolveIn<'tcx> for T {\n+    fn resolve_in<'a>(&self, resolver: &mut Resolver<'a, 'tcx>) -> T {\n         self.fold_with(resolver)\n     }\n }\n@@ -465,7 +465,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if !ty::type_needs_infer(t) {\n             return t;\n         }"}, {"sha": "1f32110a0933883744d33461d60a96af2354428a", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -20,10 +20,9 @@ use metadata::csearch::{each_impl, get_impl_trait};\n use metadata::csearch;\n use middle::subst;\n use middle::subst::{Substs};\n-use middle::ty::get;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n use middle::ty::{TypeTraitItemId, lookup_item_type};\n-use middle::ty::{t, ty_bool, ty_char, ty_enum, ty_err};\n+use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n use middle::ty::{ty_param, Polytype, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n@@ -55,10 +54,10 @@ use util::ppaux::Repr;\n mod orphan;\n mod overlap;\n \n-fn get_base_type(inference_context: &InferCtxt,\n-                 span: Span,\n-                 original_type: t)\n-                 -> Option<t> {\n+fn get_base_type<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n+                           span: Span,\n+                           original_type: Ty<'tcx>)\n+                           -> Option<Ty<'tcx>> {\n     let resolved_type = match resolve_type(inference_context,\n                                            Some(span),\n                                            original_type,\n@@ -71,7 +70,7 @@ fn get_base_type(inference_context: &InferCtxt,\n         }\n     };\n \n-    match get(resolved_type).sty {\n+    match resolved_type.sty {\n         ty_enum(..) | ty_struct(..) | ty_unboxed_closure(..) => {\n             debug!(\"(getting base type) found base type\");\n             Some(resolved_type)\n@@ -87,22 +86,22 @@ fn get_base_type(inference_context: &InferCtxt,\n         ty_infer(..) | ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n         ty_ptr(_) | ty_rptr(_, _) => {\n             debug!(\"(getting base type) no base type; found {}\",\n-                   get(original_type).sty);\n+                   original_type.sty);\n             None\n         }\n         ty_trait(..) => panic!(\"should have been caught\")\n     }\n }\n \n // Returns the def ID of the base type, if there is one.\n-fn get_base_type_def_id(inference_context: &InferCtxt,\n-                        span: Span,\n-                        original_type: t)\n-                        -> Option<DefId> {\n+fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n+                                  span: Span,\n+                                  original_type: Ty<'tcx>)\n+                                  -> Option<DefId> {\n     match get_base_type(inference_context, span, original_type) {\n         None => None,\n         Some(base_type) => {\n-            match get(base_type).sty {\n+            match base_type.sty {\n                 ty_enum(def_id, _) |\n                 ty_struct(def_id, _) |\n                 ty_unboxed_closure(def_id, _, _) => {\n@@ -111,7 +110,7 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n                 ty_ptr(ty::mt {ty, ..}) |\n                 ty_rptr(_, ty::mt {ty, ..}) |\n                 ty_uniq(ty) => {\n-                    match ty::get(ty).sty {\n+                    match ty.sty {\n                         ty_trait(box ty::TyTrait { ref principal, .. }) => {\n                             Some(principal.def_id)\n                         }\n@@ -242,7 +241,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     fn instantiate_default_methods(\n             &self,\n             impl_id: DefId,\n-            trait_ref: &ty::TraitRef,\n+            trait_ref: &ty::TraitRef<'tcx>,\n             all_impl_items: &mut Vec<ImplOrTraitItemId>) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id={}, trait_ref={})\",\n@@ -316,7 +315,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n-                                        -> Polytype {\n+                                        -> Polytype<'tcx> {\n         self.crate_context.tcx.tcache.borrow()[impl_did].clone()\n     }\n \n@@ -442,7 +441,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let method_def_id = items[0];\n \n             let self_type = self.get_self_type_for_implementation(impl_did);\n-            match ty::get(self_type.ty).sty {\n+            match self_type.ty.sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) |\n                 ty::ty_unboxed_closure(type_def_id, _, _) => {\n@@ -478,18 +477,18 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n }\n \n-pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,\n-                                      trait_ref: &ty::TraitRef,\n-                                      method: &ty::Method)\n-                                      -> subst::Substs\n+pub fn make_substs_for_receiver_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                            trait_ref: &ty::TraitRef<'tcx>,\n+                                            method: &ty::Method<'tcx>)\n+                                            -> subst::Substs<'tcx>\n {\n     /*!\n      * Substitutes the values for the receiver's type parameters\n      * that are found in method, leaving the method's type parameters\n      * intact.\n      */\n \n-    let meth_tps: Vec<ty::t> =\n+    let meth_tps: Vec<Ty> =\n         method.generics.types.get_slice(subst::FnSpace)\n               .iter()\n               .map(|def| ty::mk_param_from_def(tcx, def))\n@@ -503,14 +502,14 @@ pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,\n     trait_ref.substs.clone().with_method(meth_tps, meth_regions)\n }\n \n-fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n-                                     impl_id: ast::DefId,\n-                                     impl_poly_type: &ty::Polytype,\n-                                     trait_ref: &ty::TraitRef,\n-                                     new_def_id: ast::DefId,\n-                                     method: &ty::Method,\n-                                     provided_source: Option<ast::DefId>)\n-                                     -> ty::Method\n+fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                           impl_id: ast::DefId,\n+                                           impl_poly_type: &ty::Polytype<'tcx>,\n+                                           trait_ref: &ty::TraitRef<'tcx>,\n+                                           new_def_id: ast::DefId,\n+                                           method: &ty::Method<'tcx>,\n+                                           provided_source: Option<ast::DefId>)\n+                                           -> ty::Method<'tcx>\n {\n     let combined_substs = make_substs_for_receiver_types(tcx, trait_ref, method);\n "}, {"sha": "57ce7f79e030a11b3d18790bf93ee1098999863f", "filename": "src/librustc/middle/typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -51,7 +51,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                 // defined in this crate.\n                 debug!(\"coherence2::orphan check: inherent impl {}\", item.repr(self.tcx));\n                 let self_ty = ty::lookup_item_type(self.tcx, def_id).ty;\n-                match ty::get(self_ty).sty {\n+                match self_ty.sty {\n                     ty::ty_enum(def_id, _) |\n                     ty::ty_struct(def_id, _) => {\n                         self.check_def_id(item.span, def_id);"}, {"sha": "b0e8b664d06d7d7189d00d8ae88a6fbd47921575", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 164, "deletions": 159, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -40,7 +40,7 @@ use middle::subst;\n use middle::subst::{Substs};\n use middle::ty::{ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use middle::ty::{Polytype};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty, ast_region_to_region};\n@@ -136,26 +136,26 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Utility types and common code for the above passes.\n \n-pub trait ToTy {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t;\n+pub trait ToTy<'tcx> {\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx>;\n }\n \n-impl<'a,'tcx> ToTy for ImplCtxt<'a,'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t {\n+impl<'a,'tcx> ToTy<'tcx> for ImplCtxt<'a,'tcx> {\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n-impl<'a,'tcx> ToTy for CrateCtxt<'a,'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t {\n+impl<'a,'tcx> ToTy<'tcx> for CrateCtxt<'a,'tcx> {\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         if id.krate != ast::LOCAL_CRATE {\n             return csearch::get_type(self.tcx, id)\n         }\n@@ -177,37 +177,37 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         get_trait_def(self, id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         span_err!(self.tcx.sess, span, E0121,\n                   \"the type placeholder `_` is not allowed within types on item signatures.\");\n         ty::mk_err()\n     }\n \n-    fn associated_types_of_trait_are_valid(&self, _: ty::t, _: ast::DefId)\n+    fn associated_types_of_trait_are_valid(&self, _: Ty<'tcx>, _: ast::DefId)\n                                            -> bool {\n         false\n     }\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               _: Option<ty::t>,\n+                               _: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                _: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty<'tcx> {\n         self.tcx().sess.span_err(span, \"associated types may not be \\\n                                         referenced here\");\n         ty::mk_err()\n     }\n }\n \n-pub fn get_enum_variant_types(ccx: &CrateCtxt,\n-                              enum_ty: ty::t,\n-                              variants: &[P<ast::Variant>],\n-                              generics: &ast::Generics) {\n+pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                        enum_ty: Ty<'tcx>,\n+                                        variants: &[P<ast::Variant>],\n+                                        generics: &ast::Generics) {\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n@@ -253,9 +253,9 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n     }\n }\n \n-fn collect_trait_methods(ccx: &CrateCtxt,\n-                         trait_id: ast::NodeId,\n-                         trait_def: &ty::TraitDef) {\n+fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                   trait_id: ast::NodeId,\n+                                   trait_def: &ty::TraitDef<'tcx>) {\n     let tcx = ccx.tcx;\n     match tcx.map.get(trait_id) {\n         ast_map::NodeItem(item) => {\n@@ -365,26 +365,26 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n         _ => { /* Ignore things that aren't traits */ }\n     }\n \n-    fn make_method_ty(ccx: &CrateCtxt, m: &ty::Method) {\n+    fn make_method_ty<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n         ccx.tcx.tcache.borrow_mut().insert(\n             m.def_id,\n             Polytype {\n                 generics: m.generics.clone(),\n                 ty: ty::mk_bare_fn(ccx.tcx, m.fty.clone()) });\n     }\n \n-    fn ty_method_of_trait_method(ccx: &CrateCtxt,\n-                                 trait_id: ast::NodeId,\n-                                 trait_generics: &ty::Generics,\n-                                 trait_items: &[ast::TraitItem],\n-                                 m_id: &ast::NodeId,\n-                                 m_name: &ast::Name,\n-                                 m_explicit_self: &ast::ExplicitSelf,\n-                                 m_abi: abi::Abi,\n-                                 m_generics: &ast::Generics,\n-                                 m_fn_style: &ast::FnStyle,\n-                                 m_decl: &ast::FnDecl)\n-                                 -> ty::Method {\n+    fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                           trait_id: ast::NodeId,\n+                                           trait_generics: &ty::Generics<'tcx>,\n+                                           trait_items: &[ast::TraitItem],\n+                                           m_id: &ast::NodeId,\n+                                           m_name: &ast::Name,\n+                                           m_explicit_self: &ast::ExplicitSelf,\n+                                           m_abi: abi::Abi,\n+                                           m_generics: &ast::Generics,\n+                                           m_fn_style: &ast::FnStyle,\n+                                           m_decl: &ast::FnDecl)\n+                                           -> ty::Method<'tcx> {\n         let ty_generics =\n             ty_generics_for_fn_or_method(\n                 ccx,\n@@ -423,10 +423,10 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn convert_field(ccx: &CrateCtxt,\n-                     struct_generics: &ty::Generics,\n-                     v: &ast::StructField,\n-                     origin: ast::DefId) -> ty::field_ty {\n+pub fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                struct_generics: &ty::Generics<'tcx>,\n+                                v: &ast::StructField,\n+                                origin: ast::DefId) -> ty::field_ty {\n     let tt = ccx.to_ty(&ExplicitRscope, &*v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n@@ -456,10 +456,10 @@ pub fn convert_field(ccx: &CrateCtxt,\n     }\n }\n \n-fn convert_associated_type(ccx: &CrateCtxt,\n-                           trait_def: &ty::TraitDef,\n-                           associated_type: &ast::AssociatedType)\n-                           -> ty::Polytype {\n+fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                     trait_def: &ty::TraitDef<'tcx>,\n+                                     associated_type: &ast::AssociatedType)\n+                                     -> ty::Polytype<'tcx> {\n     // Find the type parameter ID corresponding to this\n     // associated type.\n     let type_parameter_def = trait_def.generics\n@@ -515,14 +515,14 @@ enum ConvertMethodContext<'a> {\n     TraitConvertMethodContext(ast::DefId, &'a [ast::TraitItem]),\n }\n \n-fn convert_methods<'a,I>(ccx: &CrateCtxt,\n-                         convert_method_context: ConvertMethodContext,\n-                         container: ImplOrTraitItemContainer,\n-                         mut ms: I,\n-                         untransformed_rcvr_ty: ty::t,\n-                         rcvr_ty_generics: &ty::Generics,\n-                         rcvr_visibility: ast::Visibility)\n-                         where I: Iterator<&'a ast::Method> {\n+fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                 convert_method_context: ConvertMethodContext,\n+                                 container: ImplOrTraitItemContainer,\n+                                 mut ms: I,\n+                                 untransformed_rcvr_ty: Ty<'tcx>,\n+                                 rcvr_ty_generics: &ty::Generics<'tcx>,\n+                                 rcvr_visibility: ast::Visibility)\n+                                 where I: Iterator<&'i ast::Method> {\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, \\\n             rcvr_ty_generics={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n@@ -564,14 +564,14 @@ fn convert_methods<'a,I>(ccx: &CrateCtxt,\n            .insert(mty.def_id, ty::MethodTraitItem(mty));\n     }\n \n-    fn ty_of_method(ccx: &CrateCtxt,\n+    fn ty_of_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     convert_method_context: ConvertMethodContext,\n-                    container: ImplOrTraitItemContainer,\n-                    m: &ast::Method,\n-                    untransformed_rcvr_ty: ty::t,\n-                    rcvr_ty_generics: &ty::Generics,\n-                    rcvr_visibility: ast::Visibility)\n-                    -> ty::Method {\n+                              container: ImplOrTraitItemContainer,\n+                              m: &ast::Method,\n+                              untransformed_rcvr_ty: Ty<'tcx>,\n+                              rcvr_ty_generics: &ty::Generics<'tcx>,\n+                              rcvr_visibility: ast::Visibility)\n+                              -> ty::Method<'tcx> {\n         let m_ty_generics =\n             ty_generics_for_fn_or_method(\n                 ccx,\n@@ -659,11 +659,11 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n     }\n }\n \n-fn is_associated_type_valid_for_param(ty: ty::t,\n+fn is_associated_type_valid_for_param(ty: Ty,\n                                       trait_id: ast::DefId,\n                                       generics: &ty::Generics)\n                                       -> bool {\n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_param(param_ty) => {\n             let type_parameter = generics.types.get(param_ty.space,\n                                                     param_ty.idx);\n@@ -679,12 +679,12 @@ fn is_associated_type_valid_for_param(ty: ty::t,\n     false\n }\n \n-fn find_associated_type_in_generics(tcx: &ty::ctxt,\n-                                    span: Span,\n-                                    ty: Option<ty::t>,\n-                                    associated_type_id: ast::DefId,\n-                                    generics: &ty::Generics)\n-                                    -> ty::t {\n+fn find_associated_type_in_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                          span: Span,\n+                                          ty: Option<Ty<'tcx>>,\n+                                          associated_type_id: ast::DefId,\n+                                          generics: &ty::Generics<'tcx>)\n+                                          -> Ty<'tcx> {\n     let ty = match ty {\n         None => {\n             tcx.sess.span_bug(span,\n@@ -694,7 +694,7 @@ fn find_associated_type_in_generics(tcx: &ty::ctxt,\n         Some(ty) => ty,\n     };\n \n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_param(ref param_ty) => {\n             /*let type_parameter = generics.types.get(param_ty.space,\n                                                     param_ty.idx);\n@@ -721,8 +721,8 @@ fn find_associated_type_in_generics(tcx: &ty::ctxt,\n     }\n }\n \n-fn type_is_self(ty: ty::t) -> bool {\n-    match ty::get(ty).sty {\n+fn type_is_self(ty: Ty) -> bool {\n+    match ty.sty {\n         ty::ty_param(ref param_ty) if param_ty.is_self() => true,\n         _ => false,\n     }\n@@ -732,28 +732,28 @@ struct ImplCtxt<'a,'tcx:'a> {\n     ccx: &'a CrateCtxt<'a,'tcx>,\n     opt_trait_ref_id: Option<ast::DefId>,\n     impl_items: &'a [ast::ImplItem],\n-    impl_generics: &'a ty::Generics,\n+    impl_generics: &'a ty::Generics<'tcx>,\n }\n \n impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         self.ccx.get_item_ty(id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         self.ccx.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.ccx.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: ty::t,\n+                                           ty: Ty<'tcx>,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         // OK if the trait with the associated type is the trait we're\n@@ -774,10 +774,10 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<ty::t>,\n+                               ty: Option<Ty<'tcx>>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t\n+                               -> Ty<'tcx>\n     {\n         let trait_def = ty::lookup_trait_def(self.tcx(), trait_id);\n         match self.opt_trait_ref_id {\n@@ -821,28 +821,28 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n \n struct FnCtxt<'a,'tcx:'a> {\n     ccx: &'a CrateCtxt<'a,'tcx>,\n-    generics: &'a ty::Generics,\n+    generics: &'a ty::Generics<'tcx>,\n }\n \n impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         self.ccx.get_item_ty(id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         self.ccx.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.ccx.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: ty::t,\n+                                           ty: Ty<'tcx>,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         // OK if the trait with the associated type is one of the traits in\n@@ -852,10 +852,10 @@ impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<ty::t>,\n+                               ty: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty<'tcx> {\n         debug!(\"collect::FnCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n@@ -870,39 +870,39 @@ impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n \n struct ImplMethodCtxt<'a,'tcx:'a> {\n     ccx: &'a CrateCtxt<'a,'tcx>,\n-    method_generics: &'a ty::Generics,\n+    method_generics: &'a ty::Generics<'tcx>,\n }\n \n impl<'a,'tcx> AstConv<'tcx> for ImplMethodCtxt<'a,'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         self.ccx.get_item_ty(id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         self.ccx.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.ccx.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: ty::t,\n+                                           ty: Ty<'tcx>,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         is_associated_type_valid_for_param(ty, trait_id, self.method_generics)\n     }\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<ty::t>,\n+                               ty: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty<'tcx> {\n         debug!(\"collect::ImplMethodCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n@@ -919,28 +919,28 @@ struct TraitMethodCtxt<'a,'tcx:'a> {\n     ccx: &'a CrateCtxt<'a,'tcx>,\n     trait_id: ast::DefId,\n     trait_items: &'a [ast::TraitItem],\n-    method_generics: &'a ty::Generics,\n+    method_generics: &'a ty::Generics<'tcx>,\n }\n \n impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         self.ccx.get_item_ty(id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         self.ccx.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.ccx.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: ty::t,\n+                                           ty: Ty<'tcx>,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         // OK if the trait with the associated type is this trait.\n@@ -955,10 +955,10 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<ty::t>,\n+                               ty: Option<Ty<'tcx>>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty<'tcx> {\n         debug!(\"collect::TraitMethodCtxt::associated_type_binding()\");\n \n         // If this is one of our own associated types, return it.\n@@ -997,30 +997,30 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n     }\n }\n \n-struct GenericsCtxt<'a,AC:'a> {\n+struct GenericsCtxt<'a,'tcx:'a,AC:'a> {\n     chain: &'a AC,\n-    associated_types_generics: &'a ty::Generics,\n+    associated_types_generics: &'a ty::Generics<'tcx>,\n }\n \n-impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,AC> {\n+impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,'tcx,AC> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.chain.tcx()\n     }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         self.chain.get_item_ty(id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         self.chain.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> ty::t {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.chain.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: ty::t,\n+                                           ty: Ty<'tcx>,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         // OK if the trait with the associated type is one of the traits in\n@@ -1032,10 +1032,10 @@ impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,AC> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<ty::t>,\n+                               ty: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n+                               -> Ty<'tcx> {\n         debug!(\"collect::GenericsCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n@@ -1241,10 +1241,10 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n     }\n }\n \n-pub fn convert_struct(ccx: &CrateCtxt,\n-                      struct_def: &ast::StructDef,\n-                      pty: ty::Polytype,\n-                      id: ast::NodeId) {\n+pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                struct_def: &ast::StructDef,\n+                                pty: ty::Polytype<'tcx>,\n+                                id: ast::NodeId) {\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members and check for duplicate fields.\n@@ -1324,7 +1324,9 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), pty);\n }\n \n-fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n+fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                           trait_id: ast::DefId)\n+                           -> Rc<ty::TraitDef<'tcx>> {\n     if trait_id.krate != ast::LOCAL_CRATE {\n         return ty::lookup_trait_def(ccx.tcx, trait_id)\n     }\n@@ -1338,7 +1340,9 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n     }\n }\n \n-pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n+pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                   it: &ast::Item)\n+                                   -> Rc<ty::TraitDef<'tcx>> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     match tcx.trait_defs.borrow().get(&def_id) {\n@@ -1387,11 +1391,11 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n \n     return trait_def;\n \n-    fn mk_trait_substs(ccx: &CrateCtxt,\n-                       trait_id: ast::NodeId,\n-                       generics: &ast::Generics,\n-                       items: &[ast::TraitItem])\n-                        -> subst::Substs\n+    fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                 trait_id: ast::NodeId,\n+                                 generics: &ast::Generics,\n+                                 items: &[ast::TraitItem])\n+                                 -> subst::Substs<'tcx>\n     {\n         // Creates a no-op substitution for the trait's type parameters.\n         let regions =\n@@ -1437,8 +1441,8 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n     }\n }\n \n-pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n-                  -> ty::Polytype {\n+pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n+                            -> ty::Polytype<'tcx> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     match tcx.tcache.borrow().get(&def_id) {\n@@ -1537,9 +1541,9 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n     }\n }\n \n-pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n-                          it: &ast::ForeignItem,\n-                          abi: abi::Abi) -> ty::Polytype\n+pub fn ty_of_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                    it: &ast::ForeignItem,\n+                                    abi: abi::Abi) -> ty::Polytype<'tcx>\n {\n     match it.node {\n         ast::ForeignItemFn(ref fn_decl, ref generics) => {\n@@ -1558,8 +1562,9 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n     }\n }\n \n-fn ty_of_trait_item(ccx: &CrateCtxt, trait_item: &ast::TraitItem)\n-                    -> ty::Polytype {\n+fn ty_of_trait_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                              trait_item: &ast::TraitItem)\n+                              -> ty::Polytype<'tcx> {\n     match *trait_item {\n         ast::RequiredMethod(ref m) => {\n             ccx.tcx.sess.span_bug(m.span,\n@@ -1584,11 +1589,11 @@ fn ty_of_trait_item(ccx: &CrateCtxt, trait_item: &ast::TraitItem)\n     }\n }\n \n-fn ty_generics_for_type(ccx: &CrateCtxt,\n-                        generics: &ast::Generics,\n-                        create_type_parameters_for_associated_types:\n-                            CreateTypeParametersForAssociatedTypesFlag)\n-                        -> ty::Generics {\n+fn ty_generics_for_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                  generics: &ast::Generics,\n+                                  create_type_parameters_for_associated_types:\n+                                      CreateTypeParametersForAssociatedTypesFlag)\n+                                  -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n                 generics.lifetimes.as_slice(),\n@@ -1598,12 +1603,12 @@ fn ty_generics_for_type(ccx: &CrateCtxt,\n                 create_type_parameters_for_associated_types)\n }\n \n-fn ty_generics_for_trait(ccx: &CrateCtxt,\n-                         trait_id: ast::NodeId,\n-                         substs: &subst::Substs,\n-                         ast_generics: &ast::Generics,\n-                         items: &[ast::TraitItem])\n-                         -> ty::Generics {\n+fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                   trait_id: ast::NodeId,\n+                                   substs: &subst::Substs<'tcx>,\n+                                   ast_generics: &ast::Generics,\n+                                   items: &[ast::TraitItem])\n+                                   -> ty::Generics<'tcx> {\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n@@ -1667,10 +1672,10 @@ fn ty_generics_for_trait(ccx: &CrateCtxt,\n fn ty_generics_for_fn_or_method<'tcx,AC>(\n         this: &AC,\n         generics: &ast::Generics,\n-        base_generics: ty::Generics,\n+        base_generics: ty::Generics<'tcx>,\n         create_type_parameters_for_associated_types:\n         CreateTypeParametersForAssociatedTypesFlag)\n-        -> ty::Generics\n+        -> ty::Generics<'tcx>\n         where AC: AstConv<'tcx> {\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n     ty_generics(this,\n@@ -1730,11 +1735,11 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                         space: subst::ParamSpace,\n                         lifetime_defs: &[ast::LifetimeDef],\n                         types: &[ast::TyParam],\n-                        base_generics: ty::Generics,\n+                        base_generics: ty::Generics<'tcx>,\n                         where_clause: &ast::WhereClause,\n                         create_type_parameters_for_associated_types_flag:\n                         CreateTypeParametersForAssociatedTypesFlag)\n-                        -> ty::Generics\n+                        -> ty::Generics<'tcx>\n                         where AC: AstConv<'tcx>\n {\n     let mut result = base_generics;\n@@ -1801,7 +1806,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n         this: &AC,\n         space: subst::ParamSpace,\n         types: &[ast::TyParam],\n-        associated_types_generics: &mut ty::Generics)\n+        associated_types_generics: &mut ty::Generics<'tcx>)\n         where AC: AstConv<'tcx>\n     {\n         // The idea here is roughly as follows. We start with\n@@ -1880,7 +1885,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n                                              index: uint,\n                                              where_clause: &ast::WhereClause,\n                                              associated_with: Option<ast::DefId>)\n-                                             -> ty::TypeParameterDef\n+                                             -> ty::TypeParameterDef<'tcx>\n     where AC: AstConv<'tcx>\n {\n     match this.tcx().ty_param_defs.borrow().get(&param.id) {\n@@ -1903,7 +1908,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n             let cur_idx = index;\n \n             ty::walk_ty(ty, |t| {\n-                match ty::get(t).sty {\n+                match t.sty {\n                     ty::ty_param(p) => if p.idx > cur_idx {\n                         span_err!(this.tcx().sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n@@ -1939,7 +1944,7 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n                            unbound: &Option<ast::TraitRef>,\n                            span: Span,\n                            where_clause: &ast::WhereClause)\n-                           -> ty::ParamBounds\n+                           -> ty::ParamBounds<'tcx>\n                            where AC: AstConv<'tcx> {\n     /*!\n      * Translate the AST's notion of ty param bounds (which are an\n@@ -1971,10 +1976,10 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n     param_bounds\n }\n \n-fn check_bounds_compatible(tcx: &ty::ctxt,\n-                           name_of_bounded_thing: ast::Name,\n-                           param_bounds: &ty::ParamBounds,\n-                           span: Span) {\n+fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 name_of_bounded_thing: ast::Name,\n+                                 param_bounds: &ty::ParamBounds<'tcx>,\n+                                 span: Span) {\n     // Currently the only bound which is incompatible with other bounds is\n     // Sized/Unsized.\n     if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n@@ -2000,7 +2005,7 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n                               param_ty: ty::ParamTy,\n                               ast_bounds: &[ast::TyParamBound],\n                               where_clause: &ast::WhereClause)\n-                              -> ty::ParamBounds\n+                              -> ty::ParamBounds<'tcx>\n                               where AC: AstConv<'tcx> {\n     let all_bounds =\n         merge_param_bounds(this.tcx(), param_ty, ast_bounds, where_clause);\n@@ -2064,12 +2069,12 @@ fn merge_param_bounds<'a>(tcx: &ty::ctxt,\n     result\n }\n \n-pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n-                             decl: &ast::FnDecl,\n-                             def_id: ast::DefId,\n-                             ast_generics: &ast::Generics,\n-                             abi: abi::Abi)\n-                             -> ty::Polytype {\n+pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                       decl: &ast::FnDecl,\n+                                       def_id: ast::DefId,\n+                                       ast_generics: &ast::Generics,\n+                                       abi: abi::Abi)\n+                                       -> ty::Polytype<'tcx> {\n     for i in decl.inputs.iter() {\n         match (*i).pat.node {\n             ast::PatIdent(_, _, _) => (),\n@@ -2117,9 +2122,9 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n     return pty;\n }\n \n-pub fn mk_item_substs(ccx: &CrateCtxt,\n-                      ty_generics: &ty::Generics)\n-                      -> subst::Substs\n+pub fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                ty_generics: &ty::Generics<'tcx>)\n+                                -> subst::Substs<'tcx>\n {\n     let types =\n         ty_generics.types.map(\n@@ -2135,17 +2140,17 @@ pub fn mk_item_substs(ccx: &CrateCtxt,\n \n /// Verifies that the explicit self type of a method matches the impl or\n /// trait.\n-fn check_method_self_type<RS:RegionScope>(\n-    crate_context: &CrateCtxt,\n+fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n+    crate_context: &CrateCtxt<'a, 'tcx>,\n     rs: &RS,\n-    required_type: ty::t,\n+    required_type: Ty<'tcx>,\n     explicit_self: &ast::ExplicitSelf,\n     body_id: ast::NodeId)\n {\n     match explicit_self.node {\n         ast::SelfExplicit(ref ast_type, _) => {\n             let typ = crate_context.to_ty(rs, &**ast_type);\n-            let base_type = match ty::get(typ).sty {\n+            let base_type = match typ.sty {\n                 ty::ty_ptr(tm) | ty::ty_rptr(_, tm) => tm.ty,\n                 ty::ty_uniq(typ) => typ,\n                 _ => typ,"}, {"sha": "49ac7178eb8db48d2fed3f25d59c2be8fc88e896", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -67,7 +67,7 @@ we may want to adjust precisely when coercions occur.\n use middle::subst;\n use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n use middle::ty::{mt};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n use middle::typeck::infer::combine::{CombineFields, Combine};\n use middle::typeck::infer::sub::Sub;\n@@ -88,7 +88,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let Coerce(ref v) = *self; v\n     }\n \n-    pub fn tys(&self, a: ty::t, b: ty::t) -> CoerceResult {\n+    pub fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n         debug!(\"Coerce.tys({} => {})\",\n                a.repr(self.get_ref().infcx.tcx),\n                b.repr(self.get_ref().infcx.tcx));\n@@ -105,9 +105,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         //\n         // Note: does not attempt to resolve type variables we encounter.\n         // See above for details.\n-        match ty::get(b).sty {\n+        match b.sty {\n             ty::ty_ptr(mt_b) => {\n-                match ty::get(mt_b.ty).sty {\n+                match mt_b.ty.sty {\n                     ty::ty_str => {\n                         return self.unpack_actual_value(a, |sty_a| {\n                             self.coerce_unsafe_ptr(a, sty_a, b, ast::MutImmutable)\n@@ -134,7 +134,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n \n             ty::ty_rptr(_, mt_b) => {\n-                match ty::get(mt_b.ty).sty {\n+                match mt_b.ty.sty {\n                     ty::ty_str => {\n                         return self.unpack_actual_value(a, |sty_a| {\n                             self.coerce_borrowed_pointer(a, sty_a, b, ast::MutImmutable)\n@@ -190,19 +190,19 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         })\n     }\n \n-    pub fn subtype(&self, a: ty::t, b: ty::t) -> CoerceResult {\n+    pub fn subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n         match Sub(self.get_ref().clone()).tys(a, b) {\n             Ok(_) => Ok(None),         // No coercion required.\n             Err(ref e) => Err(*e)\n         }\n     }\n \n-    pub fn unpack_actual_value<T>(&self, a: ty::t, f: |&ty::sty| -> T)\n+    pub fn unpack_actual_value<T>(&self, a: Ty<'tcx>, f: |&ty::sty<'tcx>| -> T)\n                                   -> T {\n         match resolve_type(self.get_ref().infcx, None,\n                            a, try_resolve_tvar_shallow) {\n             Ok(t) => {\n-                f(&ty::get(t).sty)\n+                f(&t.sty)\n             }\n             Err(e) => {\n                 self.get_ref().infcx.tcx.sess.span_bug(\n@@ -215,11 +215,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n     // ~T -> &T or &mut T -> &T (including where T = [U] or str)\n     pub fn coerce_borrowed_pointer(&self,\n-                                   a: ty::t,\n-                                   sty_a: &ty::sty,\n-                                   b: ty::t,\n+                                   a: Ty<'tcx>,\n+                                   sty_a: &ty::sty<'tcx>,\n+                                   b: Ty<'tcx>,\n                                    mutbl_b: ast::Mutability)\n-                                   -> CoerceResult {\n+                                   -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_pointer(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n@@ -258,10 +258,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // or &mut [T, ..n] -> &mut [T]\n     // or &Concrete -> &Trait, etc.\n     fn coerce_unsized(&self,\n-                      a: ty::t,\n-                      sty_a: &ty::sty,\n-                      b: ty::t)\n-                      -> CoerceResult {\n+                      a: Ty<'tcx>,\n+                      sty_a: &ty::sty<'tcx>,\n+                      b: Ty<'tcx>)\n+                      -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsized(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n@@ -273,7 +273,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         let sub = Sub(self.get_ref().clone());\n \n-        let sty_b = &ty::get(b).sty;\n+        let sty_b = &b.sty;\n         match (sty_a, sty_b) {\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_rptr(_, mt_b)) => {\n                 self.unpack_actual_value(t_a, |sty_a| {\n@@ -349,10 +349,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // performed to unsize it.\n     // E.g., `[T, ..n]` -> `([T], UnsizeLength(n))`\n     fn unsize_ty(&self,\n-                 ty_a: ty::t,\n-                 sty_a: &ty::sty,\n-                 ty_b: ty::t)\n-                 -> Option<(ty::t, ty::UnsizeKind)> {\n+                 ty_a: Ty<'tcx>,\n+                 sty_a: &ty::sty<'tcx>,\n+                 ty_b: Ty<'tcx>)\n+                 -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)> {\n         debug!(\"unsize_ty(sty_a={}, ty_b={})\", sty_a, ty_b.repr(self.get_ref().infcx.tcx));\n \n         let tcx = self.get_ref().infcx.tcx;\n@@ -425,10 +425,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     fn coerce_borrowed_object(&self,\n-                              a: ty::t,\n-                              sty_a: &ty::sty,\n-                              b: ty::t,\n-                              b_mutbl: ast::Mutability) -> CoerceResult\n+                              a: Ty<'tcx>,\n+                              sty_a: &ty::sty<'tcx>,\n+                              b: Ty<'tcx>,\n+                              b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n@@ -445,10 +445,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     fn coerce_unsafe_object(&self,\n-                            a: ty::t,\n-                            sty_a: &ty::sty,\n-                            b: ty::t,\n-                            b_mutbl: ast::Mutability) -> CoerceResult\n+                            a: Ty<'tcx>,\n+                            sty_a: &ty::sty<'tcx>,\n+                            b: Ty<'tcx>,\n+                            b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n@@ -462,17 +462,17 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     fn coerce_object(&self,\n-                     a: ty::t,\n-                     sty_a: &ty::sty,\n-                     b: ty::t,\n+                     a: Ty<'tcx>,\n+                     sty_a: &ty::sty<'tcx>,\n+                     b: Ty<'tcx>,\n                      b_mutbl: ast::Mutability,\n-                     mk_ty: |ty::t| -> ty::t,\n-                     mk_adjust: || -> ty::AutoRef) -> CoerceResult\n+                     mk_ty: |Ty<'tcx>| -> Ty<'tcx>,\n+                     mk_adjust: || -> ty::AutoRef<'tcx>) -> CoerceResult<'tcx>\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n         match *sty_a {\n-            ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty::get(ty).sty {\n+            ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty.sty {\n                 ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n                     debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n                     // FIXME what is purpose of this type `tr`?\n@@ -494,10 +494,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     pub fn coerce_borrowed_fn(&self,\n-                              a: ty::t,\n-                              sty_a: &ty::sty,\n-                              b: ty::t)\n-                              -> CoerceResult {\n+                              a: Ty<'tcx>,\n+                              sty_a: &ty::sty<'tcx>,\n+                              b: Ty<'tcx>)\n+                              -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_fn(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n@@ -512,8 +512,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n     }\n \n-    fn coerce_from_bare_fn(&self, a: ty::t, fn_ty_a: &ty::BareFnTy, b: ty::t)\n-                           -> CoerceResult {\n+    fn coerce_from_bare_fn(&self, a: Ty<'tcx>, fn_ty_a: &ty::BareFnTy<'tcx>, b: Ty<'tcx>)\n+                           -> CoerceResult<'tcx> {\n         /*!\n          *\n          * Attempts to coerce from a bare Rust function (`extern\n@@ -546,11 +546,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     pub fn coerce_unsafe_ptr(&self,\n-                             a: ty::t,\n-                             sty_a: &ty::sty,\n-                             b: ty::t,\n+                             a: Ty<'tcx>,\n+                             sty_a: &ty::sty<'tcx>,\n+                             b: Ty<'tcx>,\n                              mutbl_b: ast::Mutability)\n-                             -> CoerceResult {\n+                             -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));"}, {"sha": "763f204dc98bc5b942524195a0d32784d67b5483", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -38,7 +38,7 @@ use middle::subst::{ErasedRegions, NonerasedRegions, Substs};\n use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n use middle::ty::{IntType, UintType};\n use middle::ty::{BuiltinBounds};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold;\n use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n@@ -62,22 +62,22 @@ pub trait Combine<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.infcx().tcx }\n     fn tag(&self) -> String;\n     fn a_is_expected(&self) -> bool;\n-    fn trace(&self) -> TypeTrace;\n+    fn trace(&self) -> TypeTrace<'tcx>;\n \n     fn equate<'a>(&'a self) -> Equate<'a, 'tcx>;\n     fn sub<'a>(&'a self) -> Sub<'a, 'tcx>;\n     fn lub<'a>(&'a self) -> Lub<'a, 'tcx>;\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx>;\n \n-    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt>;\n-    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n-    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>>;\n+    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>>;\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>>;\n \n     fn tps(&self,\n            _: subst::ParamSpace,\n-           as_: &[ty::t],\n-           bs: &[ty::t])\n-           -> cres<Vec<ty::t>> {\n+           as_: &[Ty<'tcx>],\n+           bs: &[Ty<'tcx>])\n+           -> cres<'tcx, Vec<Ty<'tcx>>> {\n         // FIXME -- In general, we treat variance a bit wrong\n         // here. For historical reasons, we treat tps and Self\n         // as invariant. This is overly conservative.\n@@ -90,15 +90,15 @@ pub trait Combine<'tcx> {\n \n         try!(as_.iter().zip(bs.iter())\n                 .map(|(a, b)| self.equate().tys(*a, *b))\n-                .collect::<cres<Vec<ty::t>>>());\n+                .collect::<cres<Vec<Ty>>>());\n         Ok(as_.to_vec())\n     }\n \n     fn substs(&self,\n               item_def_id: ast::DefId,\n-              a_subst: &subst::Substs,\n-              b_subst: &subst::Substs)\n-              -> cres<subst::Substs>\n+              a_subst: &subst::Substs<'tcx>,\n+              b_subst: &subst::Substs<'tcx>)\n+              -> cres<'tcx, subst::Substs<'tcx>>\n     {\n         let variances = if self.infcx().tcx.variance_computed.get() {\n             Some(ty::item_variances(self.infcx().tcx, item_def_id))\n@@ -110,9 +110,9 @@ pub trait Combine<'tcx> {\n \n     fn substs_variances(&self,\n                         variances: Option<&ty::ItemVariances>,\n-                        a_subst: &subst::Substs,\n-                        b_subst: &subst::Substs)\n-                        -> cres<subst::Substs>\n+                        a_subst: &subst::Substs<'tcx>,\n+                        b_subst: &subst::Substs<'tcx>)\n+                        -> cres<'tcx, subst::Substs<'tcx>>\n     {\n         let mut substs = subst::Substs::empty();\n \n@@ -161,7 +161,7 @@ pub trait Combine<'tcx> {\n                                                         variances: &[ty::Variance],\n                                                         a_rs: &[ty::Region],\n                                                         b_rs: &[ty::Region])\n-                                                        -> cres<Vec<ty::Region>> {\n+                                                        -> cres<'tcx, Vec<ty::Region>> {\n             let tcx = this.infcx().tcx;\n             let num_region_params = variances.len();\n \n@@ -192,8 +192,8 @@ pub trait Combine<'tcx> {\n         }\n     }\n \n-    fn bare_fn_tys(&self, a: &ty::BareFnTy,\n-                   b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n+    fn bare_fn_tys(&self, a: &ty::BareFnTy<'tcx>,\n+                   b: &ty::BareFnTy<'tcx>) -> cres<'tcx, ty::BareFnTy<'tcx>> {\n         let fn_style = try!(self.fn_styles(a.fn_style, b.fn_style));\n         let abi = try!(self.abi(a.abi, b.abi));\n         let sig = try!(self.fn_sigs(&a.sig, &b.sig));\n@@ -202,8 +202,8 @@ pub trait Combine<'tcx> {\n                 sig: sig})\n     }\n \n-    fn closure_tys(&self, a: &ty::ClosureTy,\n-                   b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n+    fn closure_tys(&self, a: &ty::ClosureTy<'tcx>,\n+                   b: &ty::ClosureTy<'tcx>) -> cres<'tcx, ty::ClosureTy<'tcx>> {\n \n         let store = match (a.store, b.store) {\n             (ty::RegionTraitStore(a_r, a_m),\n@@ -235,28 +235,28 @@ pub trait Combine<'tcx> {\n         })\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n+    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>) -> cres<'tcx, ty::FnSig<'tcx>>;\n \n-    fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn args(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         self.contratys(a, b).and_then(|t| Ok(t))\n     }\n \n-    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle>;\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<'tcx, FnStyle>;\n \n-    fn abi(&self, a: abi::Abi, b: abi::Abi) -> cres<abi::Abi> {\n+    fn abi(&self, a: abi::Abi, b: abi::Abi) -> cres<'tcx, abi::Abi> {\n         if a == b {\n             Ok(a)\n         } else {\n             Err(ty::terr_abi_mismatch(expected_found(self, a, b)))\n         }\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness>;\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness>;\n \n     fn existential_bounds(&self,\n                           a: ty::ExistentialBounds,\n                           b: ty::ExistentialBounds)\n-                          -> cres<ty::ExistentialBounds>\n+                          -> cres<'tcx, ty::ExistentialBounds>\n     {\n         let r = try!(self.contraregions(a.region_bound, b.region_bound));\n         let nb = try!(self.builtin_bounds(a.builtin_bounds, b.builtin_bounds));\n@@ -267,18 +267,18 @@ pub trait Combine<'tcx> {\n     fn builtin_bounds(&self,\n                       a: ty::BuiltinBounds,\n                       b: ty::BuiltinBounds)\n-                      -> cres<ty::BuiltinBounds>;\n+                      -> cres<'tcx, ty::BuiltinBounds>;\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                  -> cres<ty::Region>;\n+                  -> cres<'tcx, ty::Region>;\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n \n     fn trait_stores(&self,\n                     vk: ty::terr_vstore_kind,\n                     a: ty::TraitStore,\n                     b: ty::TraitStore)\n-                    -> cres<ty::TraitStore> {\n+                    -> cres<'tcx, ty::TraitStore> {\n         debug!(\"{}.trait_stores(a={}, b={})\", self.tag(), a, b);\n \n         match (a, b) {\n@@ -300,9 +300,9 @@ pub trait Combine<'tcx> {\n     }\n \n     fn trait_refs(&self,\n-                  a: &ty::TraitRef,\n-                  b: &ty::TraitRef)\n-                  -> cres<ty::TraitRef>;\n+                  a: &ty::TraitRef<'tcx>,\n+                  b: &ty::TraitRef<'tcx>)\n+                  -> cres<'tcx, ty::TraitRef<'tcx>>;\n     // this must be overridden to do correctly, so as to account for higher-ranked\n     // behavior\n }\n@@ -311,7 +311,7 @@ pub trait Combine<'tcx> {\n pub struct CombineFields<'a, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub a_is_expected: bool,\n-    pub trace: TypeTrace,\n+    pub trace: TypeTrace<'tcx>,\n }\n \n pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n@@ -323,11 +323,14 @@ pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n     }\n }\n \n-pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n+pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n+                                         a: Ty<'tcx>,\n+                                         b: Ty<'tcx>)\n+                                         -> cres<'tcx, Ty<'tcx>> {\n \n     let tcx = this.infcx().tcx;\n-    let a_sty = &ty::get(a).sty;\n-    let b_sty = &ty::get(b).sty;\n+    let a_sty = &a.sty;\n+    let b_sty = &b.sty;\n     debug!(\"super_tys: a_sty={} b_sty={}\", a_sty, b_sty);\n     return match (a_sty, b_sty) {\n       // The \"subtype\" ought to be handling cases involving var:\n@@ -384,7 +387,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n       (&ty::ty_int(_), _) |\n       (&ty::ty_uint(_), _) |\n       (&ty::ty_float(_), _) => {\n-        if ty::get(a).sty == ty::get(b).sty {\n+        if a == b {\n             Ok(a)\n         } else {\n             Err(ty::terr_sorts(expected_found(this, a, b)))\n@@ -446,7 +449,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n             // used to use covariant subtyping. I have preserved this behaviour,\n             // even though it is probably incorrect. So don't go down the usual\n             // path which would require invariance.\n-            let mt = match (&ty::get(a_mt.ty).sty, &ty::get(b_mt.ty).sty) {\n+            let mt = match (&a_mt.ty.sty, &b_mt.ty.sty) {\n                 (&ty::ty_trait(..), &ty::ty_trait(..)) if a_mt.mutbl == b_mt.mutbl => {\n                     let ty = try!(this.tys(a_mt.ty, b_mt.ty));\n                     ty::mt { ty: ty, mutbl: a_mt.mutbl }\n@@ -513,7 +516,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n         this: &C,\n         vid_is_expected: bool,\n         vid: ty::IntVid,\n-        val: ty::IntVarValue) -> cres<ty::t>\n+        val: ty::IntVarValue) -> cres<'tcx, Ty<'tcx>>\n     {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         match val {\n@@ -526,7 +529,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n         this: &C,\n         vid_is_expected: bool,\n         vid: ty::FloatVid,\n-        val: ast::FloatTy) -> cres<ty::t>\n+        val: ast::FloatTy) -> cres<'tcx, Ty<'tcx>>\n     {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         Ok(ty::mk_mach_float(val))\n@@ -550,10 +553,10 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n     }\n \n     pub fn instantiate(&self,\n-                       a_ty: ty::t,\n+                       a_ty: Ty<'tcx>,\n                        dir: RelationDir,\n                        b_vid: ty::TyVid)\n-                       -> cres<()>\n+                       -> cres<'tcx, ()>\n     {\n         let tcx = self.infcx.tcx;\n         let mut stack = Vec::new();\n@@ -640,10 +643,10 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n     }\n \n     fn generalize(&self,\n-                  ty: ty::t,\n+                  ty: Ty<'tcx>,\n                   for_vid: ty::TyVid,\n                   make_region_vars: bool)\n-                  -> cres<ty::t>\n+                  -> cres<'tcx, Ty<'tcx>>\n     {\n         /*!\n          * Attempts to generalize `ty` for the type variable\n@@ -681,15 +684,15 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         // Check to see whether the type we are genealizing references\n         // `vid`. At the same time, also update any type variables to\n         // the values that they are bound to. This is needed to truly\n         // check for cycles, but also just makes things readable.\n         //\n         // (In particular, you could have something like `$0 = Box<$1>`\n         //  where `$1` has already been instantiated with `Box<$0>`)\n-        match ty::get(t).sty {\n+        match t.sty {\n             ty::ty_infer(ty::TyVar(vid)) => {\n                 if vid == self.for_vid {\n                     self.cycle_detected = true;"}, {"sha": "356081c199afa5b9b144299cedc29c368ead685d", "filename": "src/librustc/middle/typeck/infer/equate.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::ty::{BuiltinBounds};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::TyVar;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::{cres};\n@@ -36,22 +36,22 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"eq\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n+    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n \n     fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n     fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n     fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n-    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         self.tys(a, b)\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn contraregions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         self.regions(a, b)\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.fields.infcx.tcx),\n@@ -60,7 +60,7 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         Ok(a)\n     }\n \n-    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         debug!(\"mts({} <: {})\",\n                a.repr(self.fields.infcx.tcx),\n                b.repr(self.fields.infcx.tcx));\n@@ -70,15 +70,15 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         Ok(ty::mt { mutbl: a.mutbl, ty: t })\n     }\n \n-    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<'tcx, FnStyle> {\n         if a != b {\n             Err(ty::terr_fn_style_mismatch(expected_found(self, a, b)))\n         } else {\n             Ok(a)\n         }\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness> {\n         if a != b {\n             Err(ty::terr_onceness_mismatch(expected_found(self, a, b)))\n         } else {\n@@ -89,7 +89,7 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n     fn builtin_bounds(&self,\n                       a: BuiltinBounds,\n                       b: BuiltinBounds)\n-                      -> cres<BuiltinBounds>\n+                      -> cres<'tcx, BuiltinBounds>\n     {\n         // More bounds is a subtype of fewer bounds.\n         //\n@@ -103,15 +103,15 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         }\n     }\n \n-    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n         let a = infcx.type_variables.borrow().replace_if_possible(a);\n         let b = infcx.type_variables.borrow().replace_if_possible(b);\n-        match (&ty::get(a).sty, &ty::get(b).sty) {\n+        match (&a.sty, &b.sty) {\n             (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().relate_vars(a_id, EqTo, b_id);\n                 Ok(a)\n@@ -133,12 +133,14 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         }\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n+               -> cres<'tcx, ty::FnSig<'tcx>> {\n         try!(self.sub().fn_sigs(a, b));\n         self.sub().fn_sigs(b, a)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n+                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n         try!(self.sub().trait_refs(a, b));\n         self.sub().trait_refs(b, a)\n     }"}, {"sha": "7a7a7c796740aa646feab24154e764124edb56e3", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -63,7 +63,7 @@ use self::FreshOrKept::*;\n use std::collections::HashSet;\n use middle::def;\n use middle::subst;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::{Region, ReFree};\n use middle::typeck::infer;\n use middle::typeck::infer::InferCtxt;\n@@ -97,65 +97,65 @@ use util::ppaux::note_and_explain_region;\n // messages shouldn't include debug serializations.\n use util::ppaux::UserString;\n \n-pub trait ErrorReporting {\n+pub trait ErrorReporting<'tcx> {\n     fn report_region_errors(&self,\n-                            errors: &Vec<RegionResolutionError>);\n+                            errors: &Vec<RegionResolutionError<'tcx>>);\n \n-    fn process_errors(&self, errors: &Vec<RegionResolutionError>)\n-                      -> Vec<RegionResolutionError>;\n+    fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n+                      -> Vec<RegionResolutionError<'tcx>>;\n \n-    fn report_type_error(&self, trace: TypeTrace, terr: &ty::type_err);\n+    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::type_err<'tcx>);\n \n     fn report_and_explain_type_error(&self,\n-                                     trace: TypeTrace,\n-                                     terr: &ty::type_err);\n+                                     trace: TypeTrace<'tcx>,\n+                                     terr: &ty::type_err<'tcx>);\n \n-    fn values_str(&self, values: &ValuePairs) -> Option<String>;\n+    fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n-    fn expected_found_str<T: UserString + Resolvable>(\n+    fn expected_found_str<T: UserString<'tcx> + Resolvable<'tcx>>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>;\n \n     fn report_concrete_failure(&self,\n-                               origin: SubregionOrigin,\n+                               origin: SubregionOrigin<'tcx>,\n                                sub: Region,\n                                sup: Region);\n \n     fn report_param_bound_failure(&self,\n-                                  origin: SubregionOrigin,\n+                                  origin: SubregionOrigin<'tcx>,\n                                   param_ty: ty::ParamTy,\n                                   sub: Region,\n                                   sups: Vec<Region>);\n \n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n-                               sub_origin: SubregionOrigin,\n+                               sub_origin: SubregionOrigin<'tcx>,\n                                sub_region: Region,\n-                               sup_origin: SubregionOrigin,\n+                               sup_origin: SubregionOrigin<'tcx>,\n                                sup_region: Region);\n \n     fn report_sup_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n-                               origin1: SubregionOrigin,\n+                               origin1: SubregionOrigin<'tcx>,\n                                region1: Region,\n-                               origin2: SubregionOrigin,\n+                               origin2: SubregionOrigin<'tcx>,\n                                region2: Region);\n \n     fn report_processed_errors(&self,\n                                var_origin: &[RegionVariableOrigin],\n-                               trace_origin: &[(TypeTrace, ty::type_err)],\n+                               trace_origin: &[(TypeTrace<'tcx>, ty::type_err<'tcx>)],\n                                same_regions: &[SameRegions]);\n \n     fn give_suggestion(&self, same_regions: &[SameRegions]);\n }\n \n-trait ErrorReportingHelpers {\n+trait ErrorReportingHelpers<'tcx> {\n     fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin);\n \n     fn note_region_origin(&self,\n-                          origin: &SubregionOrigin);\n+                          origin: &SubregionOrigin<'tcx>);\n \n     fn give_expl_lifetime_param(&self,\n                                 decl: &ast::FnDecl,\n@@ -166,9 +166,9 @@ trait ErrorReportingHelpers {\n                                 span: codemap::Span);\n }\n \n-impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_region_errors(&self,\n-                            errors: &Vec<RegionResolutionError>) {\n+                            errors: &Vec<RegionResolutionError<'tcx>>) {\n         let p_errors = self.process_errors(errors);\n         let errors = if p_errors.is_empty() { errors } else { &p_errors };\n         for error in errors.iter() {\n@@ -216,8 +216,8 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n     // complete view of what lifetimes should be the same.\n     // If the return value is an empty vector, it means that processing\n     // failed (so the return value of this method should not be used)\n-    fn process_errors(&self, errors: &Vec<RegionResolutionError>)\n-                      -> Vec<RegionResolutionError> {\n+    fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n+                      -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"process_errors()\");\n         let mut var_origins = Vec::new();\n         let mut trace_origins = Vec::new();\n@@ -350,7 +350,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn report_type_error(&self, trace: TypeTrace, terr: &ty::type_err) {\n+    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::type_err<'tcx>) {\n         let expected_found_str = match self.values_str(&trace.values) {\n             Some(v) => v,\n             None => {\n@@ -385,13 +385,13 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n     }\n \n     fn report_and_explain_type_error(&self,\n-                                     trace: TypeTrace,\n-                                     terr: &ty::type_err) {\n+                                     trace: TypeTrace<'tcx>,\n+                                     terr: &ty::type_err<'tcx>) {\n         self.report_type_error(trace, terr);\n         ty::note_and_explain_type_err(self.tcx, terr);\n     }\n \n-    fn values_str(&self, values: &ValuePairs) -> Option<String> {\n+    fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String> {\n         /*!\n          * Returns a string of the form \"expected `{}`, found `{}`\",\n          * or None if this is a derived error.\n@@ -402,7 +402,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn expected_found_str<T: UserString + Resolvable>(\n+    fn expected_found_str<T: UserString<'tcx> + Resolvable<'tcx>>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n     }\n \n     fn report_param_bound_failure(&self,\n-                                  origin: SubregionOrigin,\n+                                  origin: SubregionOrigin<'tcx>,\n                                   param_ty: ty::ParamTy,\n                                   sub: Region,\n                                   _sups: Vec<Region>) {\n@@ -488,7 +488,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n     }\n \n     fn report_concrete_failure(&self,\n-                               origin: SubregionOrigin,\n+                               origin: SubregionOrigin<'tcx>,\n                                sub: Region,\n                                sup: Region) {\n         match origin {\n@@ -786,9 +786,9 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n \n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n-                               sub_origin: SubregionOrigin,\n+                               sub_origin: SubregionOrigin<'tcx>,\n                                sub_region: Region,\n-                               sup_origin: SubregionOrigin,\n+                               sup_origin: SubregionOrigin<'tcx>,\n                                sup_region: Region) {\n         self.report_inference_failure(var_origin);\n \n@@ -811,9 +811,9 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n \n     fn report_sup_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n-                               origin1: SubregionOrigin,\n+                               origin1: SubregionOrigin<'tcx>,\n                                region1: Region,\n-                               origin2: SubregionOrigin,\n+                               origin2: SubregionOrigin<'tcx>,\n                                region2: Region) {\n         self.report_inference_failure(var_origin);\n \n@@ -836,7 +836,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n \n     fn report_processed_errors(&self,\n                                var_origins: &[RegionVariableOrigin],\n-                               trace_origins: &[(TypeTrace, ty::type_err)],\n+                               trace_origins: &[(TypeTrace<'tcx>, ty::type_err<'tcx>)],\n                                same_regions: &[SameRegions]) {\n         for vo in var_origins.iter() {\n             self.report_inference_failure(vo.clone());\n@@ -1430,7 +1430,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n     fn give_expl_lifetime_param(&self,\n                                 decl: &ast::FnDecl,\n                                 fn_style: ast::FnStyle,\n@@ -1483,7 +1483,7 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n                     var_description).as_slice());\n     }\n \n-    fn note_region_origin(&self, origin: &SubregionOrigin) {\n+    fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n             infer::Subtype(ref trace) => {\n                 let desc = match trace.origin {\n@@ -1674,22 +1674,23 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n     }\n }\n \n-pub trait Resolvable {\n-    fn resolve(&self, infcx: &InferCtxt) -> Self;\n+pub trait Resolvable<'tcx> {\n+    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Self;\n     fn contains_error(&self) -> bool;\n }\n \n-impl Resolvable for ty::t {\n-    fn resolve(&self, infcx: &InferCtxt) -> ty::t {\n+impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n+    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         infcx.resolve_type_vars_if_possible(*self)\n     }\n     fn contains_error(&self) -> bool {\n         ty::type_is_error(*self)\n     }\n }\n \n-impl Resolvable for Rc<ty::TraitRef> {\n-    fn resolve(&self, infcx: &InferCtxt) -> Rc<ty::TraitRef> {\n+impl<'tcx> Resolvable<'tcx> for Rc<ty::TraitRef<'tcx>> {\n+    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n+                   -> Rc<ty::TraitRef<'tcx>> {\n         Rc::new(infcx.resolve_type_vars_in_trait_ref_if_possible(&**self))\n     }\n     fn contains_error(&self) -> bool {"}, {"sha": "671d2e3837c798d8bad9bc820be0e4c4edd602d8", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -10,7 +10,7 @@\n \n \n use middle::ty::{BuiltinBounds};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::equate::Equate;\n@@ -39,14 +39,14 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"glb\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n+    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n \n     fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n     fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n     fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n-    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         let tcx = self.fields.infcx.tcx;\n \n         debug!(\"{}.mts({}, {})\",\n@@ -77,18 +77,18 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         }\n     }\n \n-    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         self.lub().tys(a, b)\n     }\n \n-    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<'tcx, FnStyle> {\n         match (a, b) {\n           (NormalFn, _) | (_, NormalFn) => Ok(NormalFn),\n           (UnsafeFn, UnsafeFn) => Ok(UnsafeFn)\n         }\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness> {\n         match (a, b) {\n             (Many, _) | (_, Many) => Ok(Many),\n             (Once, Once) => Ok(Once)\n@@ -98,13 +98,13 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n     fn builtin_bounds(&self,\n                       a: ty::BuiltinBounds,\n                       b: ty::BuiltinBounds)\n-                      -> cres<ty::BuiltinBounds> {\n+                      -> cres<'tcx, ty::BuiltinBounds> {\n         // More bounds is a subtype of fewer bounds, so\n         // the GLB (mutual subtype) is the union.\n         Ok(a.union(b))\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.fields.infcx.tcx),\n@@ -114,19 +114,21 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                    -> cres<ty::Region> {\n+                    -> cres<'tcx, ty::Region> {\n         self.lub().regions(a, b)\n     }\n \n-    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         super_lattice_tys(self, a, b)\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n+               -> cres<'tcx, ty::FnSig<'tcx>> {\n         self.higher_ranked_glb(a, b)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n+                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n         self.higher_ranked_glb(a, b)\n     }\n }"}, {"sha": "812aa5c55572814c22e4df034da1b32fbc31d5b9", "filename": "src/librustc/middle/typeck/infer/higher_ranked/mod.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -13,8 +13,7 @@\n  * the end of the file for details.\n  */\n \n-use middle::ty;\n-use middle::ty::replace_late_bound_regions;\n+use middle::ty::{mod, Ty, replace_late_bound_regions};\n use middle::typeck::infer::{mod, combine, cres, InferCtxt};\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::region_inference::{RegionMark};\n@@ -23,26 +22,27 @@ use syntax::codemap::Span;\n use util::nodemap::FnvHashMap;\n use util::ppaux::{bound_region_to_string, Repr};\n \n-pub trait HigherRankedCombineable : HigherRankedFoldable + TypeFoldable + Repr {\n-    fn super_combine<'tcx,C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<Self>;\n+pub trait HigherRankedCombineable<'tcx>: HigherRankedFoldable<'tcx> +\n+                                         TypeFoldable<'tcx> + Repr<'tcx> {\n+    fn super_combine<C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<'tcx, Self>;\n }\n \n-pub trait HigherRankedRelations {\n-    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<T>\n-        where T : HigherRankedCombineable;\n+pub trait HigherRankedRelations<'tcx> {\n+    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n+        where T : HigherRankedCombineable<'tcx>;\n \n-    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<T>\n-        where T : HigherRankedCombineable;\n+    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n+        where T : HigherRankedCombineable<'tcx>;\n \n-    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<T>\n-        where T : HigherRankedCombineable;\n+    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n+        where T : HigherRankedCombineable<'tcx>;\n }\n \n-impl<'tcx,C> HigherRankedRelations for C\n+impl<'tcx,C> HigherRankedRelations<'tcx> for C\n     where C : Combine<'tcx>\n {\n-    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<T>\n-        where T : HigherRankedCombineable\n+    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n+        where T : HigherRankedCombineable<'tcx>\n     {\n         debug!(\"higher_ranked_sub(a={}, b={})\",\n                a.repr(self.tcx()), b.repr(self.tcx()));\n@@ -122,8 +122,8 @@ impl<'tcx,C> HigherRankedRelations for C\n         return Ok(result);\n     }\n \n-    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<T>\n-        where T : HigherRankedCombineable\n+    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n+        where T : HigherRankedCombineable<'tcx>\n     {\n         // Make a mark so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n@@ -210,8 +210,8 @@ impl<'tcx,C> HigherRankedRelations for C\n         }\n     }\n \n-    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<T>\n-        where T : HigherRankedCombineable\n+    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n+        where T : HigherRankedCombineable<'tcx>\n     {\n         debug!(\"{}.higher_ranked_glb({}, {})\",\n                self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n@@ -346,9 +346,9 @@ impl<'tcx,C> HigherRankedRelations for C\n     }\n }\n \n-impl HigherRankedCombineable for ty::FnSig {\n-    fn super_combine<'tcx,C:Combine<'tcx>>(combiner: &C, a: &ty::FnSig, b: &ty::FnSig)\n-                                           -> cres<ty::FnSig>\n+impl<'tcx> HigherRankedCombineable<'tcx> for ty::FnSig<'tcx> {\n+    fn super_combine<C:Combine<'tcx>>(combiner: &C, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n+                                      -> cres<'tcx, ty::FnSig<'tcx>>\n     {\n         if a.variadic != b.variadic {\n             return Err(ty::terr_variadic_mismatch(\n@@ -375,9 +375,9 @@ impl HigherRankedCombineable for ty::FnSig {\n \n \n         fn argvecs<'tcx, C: Combine<'tcx>>(combiner: &C,\n-                                           a_args: &[ty::t],\n-                                           b_args: &[ty::t])\n-                                           -> cres<Vec<ty::t>>\n+                                           a_args: &[Ty<'tcx>],\n+                                           b_args: &[Ty<'tcx>])\n+                                           -> cres<'tcx, Vec<Ty<'tcx>>>\n         {\n             if a_args.len() == b_args.len() {\n                 a_args.iter().zip(b_args.iter())\n@@ -389,9 +389,11 @@ impl HigherRankedCombineable for ty::FnSig {\n     }\n }\n \n-impl HigherRankedCombineable for ty::TraitRef {\n-    fn super_combine<'tcx,C:Combine<'tcx>>(combiner: &C, a: &ty::TraitRef, b: &ty::TraitRef)\n-                                           -> cres<ty::TraitRef>\n+impl<'tcx> HigherRankedCombineable<'tcx> for ty::TraitRef<'tcx> {\n+    fn super_combine<C:Combine<'tcx>>(combiner: &C,\n+                                      a: &ty::TraitRef<'tcx>,\n+                                      b: &ty::TraitRef<'tcx>)\n+                                      -> cres<'tcx, ty::TraitRef<'tcx>>\n     {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n@@ -425,10 +427,11 @@ fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     }\n }\n \n-fn fold_regions_in<T:HigherRankedFoldable>(tcx: &ty::ctxt,\n-                                           value: &T,\n-                                           fldr: |ty::Region, ty::DebruijnIndex| -> ty::Region)\n-                                           -> T\n+fn fold_regions_in<'tcx, T>(tcx: &ty::ctxt<'tcx>,\n+                            value: &T,\n+                            fldr: |ty::Region, ty::DebruijnIndex| -> ty::Region)\n+                            -> T\n+    where T: HigherRankedFoldable<'tcx>\n {\n     value.fold_contents(&mut ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,"}, {"sha": "6e6c631f007490382f221058a5c68814448cb750", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -32,41 +32,41 @@\n  */\n \n use middle::ty::{TyVar};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::*;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use util::ppaux::Repr;\n \n-pub trait LatticeDir {\n+pub trait LatticeDir<'tcx> {\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n-    fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()>;\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, ()>;\n }\n \n-impl<'a, 'tcx> LatticeDir for Lub<'a, 'tcx> {\n-    fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()> {\n+impl<'a, 'tcx> LatticeDir<'tcx> for Lub<'a, 'tcx> {\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, ()> {\n         let sub = self.sub();\n         try!(sub.tys(a, v));\n         try!(sub.tys(b, v));\n         Ok(())\n     }\n }\n \n-impl<'a, 'tcx> LatticeDir for Glb<'a, 'tcx> {\n-    fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()> {\n+impl<'a, 'tcx> LatticeDir<'tcx> for Glb<'a, 'tcx> {\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, ()> {\n         let sub = self.sub();\n         try!(sub.tys(v, a));\n         try!(sub.tys(v, b));\n         Ok(())\n     }\n }\n \n-pub fn super_lattice_tys<'tcx, L:LatticeDir+Combine<'tcx>>(this: &L,\n-                                                           a: ty::t,\n-                                                           b: ty::t)\n-                                                           -> cres<ty::t>\n+pub fn super_lattice_tys<'tcx, L:LatticeDir<'tcx>+Combine<'tcx>>(this: &L,\n+                                                                 a: Ty<'tcx>,\n+                                                                 b: Ty<'tcx>)\n+                                                                 -> cres<'tcx, Ty<'tcx>>\n {\n     debug!(\"{}.lattice_tys({}, {})\",\n            this.tag(),\n@@ -80,7 +80,7 @@ pub fn super_lattice_tys<'tcx, L:LatticeDir+Combine<'tcx>>(this: &L,\n     let infcx = this.infcx();\n     let a = infcx.type_variables.borrow().replace_if_possible(a);\n     let b = infcx.type_variables.borrow().replace_if_possible(b);\n-    match (&ty::get(a).sty, &ty::get(b).sty) {\n+    match (&a.sty, &b.sty) {\n         (&ty::ty_infer(TyVar(..)), &ty::ty_infer(TyVar(..)))\n             if infcx.type_var_diverges(a) && infcx.type_var_diverges(b) => {\n             let v = infcx.next_diverging_ty_var();"}, {"sha": "e7bd1f3716c12e3ddef4bef12f63be027fbc8399", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::ty::{BuiltinBounds};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n@@ -39,14 +39,14 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"lub\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n+    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n \n     fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n     fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n     fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n-    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         let tcx = self.tcx();\n \n         debug!(\"{}.mts({}, {})\",\n@@ -72,18 +72,18 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         }\n     }\n \n-    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         self.glb().tys(a, b)\n     }\n \n-    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<'tcx, FnStyle> {\n         match (a, b) {\n           (UnsafeFn, _) | (_, UnsafeFn) => Ok(UnsafeFn),\n           (NormalFn, NormalFn) => Ok(NormalFn),\n         }\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness> {\n         match (a, b) {\n             (Once, _) | (_, Once) => Ok(Once),\n             (Many, Many) => Ok(Many)\n@@ -93,18 +93,18 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n     fn builtin_bounds(&self,\n                       a: ty::BuiltinBounds,\n                       b: ty::BuiltinBounds)\n-                      -> cres<ty::BuiltinBounds> {\n+                      -> cres<'tcx, ty::BuiltinBounds> {\n         // More bounds is a subtype of fewer bounds, so\n         // the LUB (mutual supertype) is the intersection.\n         Ok(a.intersection(b))\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                    -> cres<ty::Region> {\n+                    -> cres<'tcx, ty::Region> {\n         self.glb().regions(a, b)\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.tcx()),\n@@ -113,15 +113,17 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         Ok(self.infcx().region_vars.lub_regions(Subtype(self.trace()), a, b))\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n+               -> cres<'tcx, ty::FnSig<'tcx>> {\n         self.higher_ranked_lub(a, b)\n     }\n \n-    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         super_lattice_tys(self, a, b)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n+                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n         self.higher_ranked_lub(a, b)\n     }\n }"}, {"sha": "93c11693091c2daef28c7dd05d2dd25640eeb058", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 143, "deletions": 135, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -32,7 +32,7 @@ use middle::subst;\n use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n use middle::ty::replace_late_bound_regions;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold::{HigherRankedFoldable, TypeFolder, TypeFoldable};\n use std::cell::{RefCell};\n use std::rc::Rc;\n@@ -72,18 +72,18 @@ pub mod unify;\n \n pub type Bound<T> = Option<T>;\n \n-pub type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n-pub type ures = cres<()>; // \"unify result\"\n+pub type cres<'tcx, T> = Result<T,ty::type_err<'tcx>>; // \"combine result\"\n+pub type ures<'tcx> = cres<'tcx, ()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n-pub type CoerceResult = cres<Option<ty::AutoAdjustment>>;\n+pub type CoerceResult<'tcx> = cres<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n \n pub struct InferCtxt<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n \n-    // We instantiate UnificationTable with bounds<ty::t> because the\n+    // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    type_variables: RefCell<type_variable::TypeVariableTable>,\n+    type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n     // Map from integral variable to the kind of integer it represents\n     int_unification_table:\n@@ -134,28 +134,28 @@ pub enum TypeOrigin {\n \n /// See `error_reporting.rs` for more details\n #[deriving(Clone, Show)]\n-pub enum ValuePairs {\n-    Types(ty::expected_found<ty::t>),\n-    TraitRefs(ty::expected_found<Rc<ty::TraitRef>>),\n+pub enum ValuePairs<'tcx> {\n+    Types(ty::expected_found<Ty<'tcx>>),\n+    TraitRefs(ty::expected_found<Rc<ty::TraitRef<'tcx>>>),\n }\n \n /// The trace designates the path through inference that we took to\n /// encounter an error or subtyping constraint.\n ///\n /// See `error_reporting.rs` for more details.\n #[deriving(Clone, Show)]\n-pub struct TypeTrace {\n+pub struct TypeTrace<'tcx> {\n     origin: TypeOrigin,\n-    values: ValuePairs,\n+    values: ValuePairs<'tcx>,\n }\n \n /// The origin of a `r1 <= r2` constraint.\n ///\n /// See `error_reporting.rs` for more details\n #[deriving(Clone, Show)]\n-pub enum SubregionOrigin {\n+pub enum SubregionOrigin<'tcx> {\n     // Arose from a subtyping relation\n-    Subtype(TypeTrace),\n+    Subtype(TypeTrace<'tcx>),\n \n     // Stack-allocated closures cannot outlive innermost loop\n     // or function so as to ensure we only require finite stack\n@@ -182,19 +182,19 @@ pub enum SubregionOrigin {\n \n     // When closing over a variable in a closure/proc, ensure that the\n     // type of the variable outlives the lifetime bound.\n-    RelateProcBound(Span, ast::NodeId, ty::t),\n+    RelateProcBound(Span, ast::NodeId, Ty<'tcx>),\n \n     // Some type parameter was instantiated with the given type,\n     // and that type must outlive some region.\n-    RelateParamBound(Span, ty::t),\n+    RelateParamBound(Span, Ty<'tcx>),\n \n     // The given region parameter was instantiated with a region\n     // that must outlive some other region.\n     RelateRegionParamBound(Span),\n \n     // A bound placed on type parameters that states that must outlive\n     // the moment of their instantiation.\n-    RelateDefaultParamBound(Span, ty::t),\n+    RelateDefaultParamBound(Span, Ty<'tcx>),\n \n     // Creating a pointer `b` to contents of another reference\n     Reborrow(Span),\n@@ -203,10 +203,10 @@ pub enum SubregionOrigin {\n     ReborrowUpvar(Span, ty::UpvarId),\n \n     // (&'a &'b T) where a >= b\n-    ReferenceOutlivesReferent(ty::t, Span),\n+    ReferenceOutlivesReferent(Ty<'tcx>, Span),\n \n     // The type T of an expression E must outlive the lifetime for E.\n-    ExprTypeIsNotInScope(ty::t, Span),\n+    ExprTypeIsNotInScope(Ty<'tcx>, Span),\n \n     // A `ref b` whose region does not enclose the decl site\n     BindingTypeIsNotValidAtDecl(Span),\n@@ -241,7 +241,7 @@ pub enum LateBoundRegionConversionTime {\n ///\n /// See `error_reporting.rs` for more details\n #[deriving(Clone, Show)]\n-pub enum RegionVariableOrigin {\n+pub enum RegionVariableOrigin<'tcx> {\n     // Region variables created for ill-categorized reasons,\n     // mostly indicates places in need of refactoring\n     MiscVariable(Span),\n@@ -259,7 +259,7 @@ pub enum RegionVariableOrigin {\n     Autoref(Span),\n \n     // Regions created as part of an automatic coercion\n-    Coercion(TypeTrace),\n+    Coercion(TypeTrace<'tcx>),\n \n     // Region variables created as the values for early-bound regions\n     EarlyBoundRegion(Span, ast::Name),\n@@ -305,12 +305,12 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>)\n     }\n }\n \n-pub fn common_supertype(cx: &InferCtxt,\n-                        origin: TypeOrigin,\n-                        a_is_expected: bool,\n-                        a: ty::t,\n-                        b: ty::t)\n-                        -> ty::t\n+pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                                  origin: TypeOrigin,\n+                                  a_is_expected: bool,\n+                                  a: Ty<'tcx>,\n+                                  b: Ty<'tcx>)\n+                                  -> Ty<'tcx>\n {\n     /*!\n      * Computes the least upper-bound of `a` and `b`. If this is\n@@ -336,20 +336,23 @@ pub fn common_supertype(cx: &InferCtxt,\n     }\n }\n \n-pub fn mk_subty(cx: &InferCtxt,\n-                a_is_expected: bool,\n-                origin: TypeOrigin,\n-                a: ty::t,\n-                b: ty::t)\n-                -> ures\n+pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                          a_is_expected: bool,\n+                          origin: TypeOrigin,\n+                          a: Ty<'tcx>,\n+                          b: Ty<'tcx>)\n+                          -> ures<'tcx>\n {\n     debug!(\"mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.commit_if_ok(|| {\n         cx.sub_types(a_is_expected, origin, a, b)\n     })\n }\n \n-pub fn can_mk_subty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                              a: Ty<'tcx>,\n+                              b: Ty<'tcx>)\n+                              -> ures<'tcx> {\n     debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.probe(|| {\n         let trace = TypeTrace {\n@@ -360,7 +363,9 @@ pub fn can_mk_subty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n     })\n }\n \n-pub fn can_mk_eqty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                             a: Ty<'tcx>, b: Ty<'tcx>)\n+                             -> ures<'tcx> {\n     debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.probe(|| {\n         let trace = TypeTrace {\n@@ -371,21 +376,21 @@ pub fn can_mk_eqty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n     }).to_ures()\n }\n \n-pub fn mk_subr(cx: &InferCtxt,\n-               origin: SubregionOrigin,\n-               a: ty::Region,\n-               b: ty::Region) {\n+pub fn mk_subr<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                         origin: SubregionOrigin<'tcx>,\n+                         a: ty::Region,\n+                         b: ty::Region) {\n     debug!(\"mk_subr({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     let snapshot = cx.region_vars.start_snapshot();\n     cx.region_vars.make_subregion(origin, a, b);\n     cx.region_vars.commit(snapshot);\n }\n \n-pub fn verify_param_bound(cx: &InferCtxt,\n-                          origin: SubregionOrigin,\n-                          param_ty: ty::ParamTy,\n-                          a: ty::Region,\n-                          bs: Vec<ty::Region>) {\n+pub fn verify_param_bound<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                                    origin: SubregionOrigin<'tcx>,\n+                                    param_ty: ty::ParamTy,\n+                                    a: ty::Region,\n+                                    bs: Vec<ty::Region>) {\n     debug!(\"verify_param_bound({}, {} <: {})\",\n            param_ty.repr(cx.tcx),\n            a.repr(cx.tcx),\n@@ -394,24 +399,24 @@ pub fn verify_param_bound(cx: &InferCtxt,\n     cx.region_vars.verify_param_bound(origin, param_ty, a, bs);\n }\n \n-pub fn mk_eqty(cx: &InferCtxt,\n-               a_is_expected: bool,\n-               origin: TypeOrigin,\n-               a: ty::t,\n-               b: ty::t)\n-            -> ures\n+pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                         a_is_expected: bool,\n+                         origin: TypeOrigin,\n+                         a: Ty<'tcx>,\n+                         b: Ty<'tcx>)\n+                         -> ures<'tcx>\n {\n     debug!(\"mk_eqty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.commit_if_ok(\n         || cx.eq_types(a_is_expected, origin, a, b))\n }\n \n-pub fn mk_sub_trait_refs(cx: &InferCtxt,\n-                         a_is_expected: bool,\n-                         origin: TypeOrigin,\n-                         a: Rc<ty::TraitRef>,\n-                         b: Rc<ty::TraitRef>)\n-                         -> ures\n+pub fn mk_sub_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                                   a_is_expected: bool,\n+                                   origin: TypeOrigin,\n+                                   a: Rc<ty::TraitRef<'tcx>>,\n+                                   b: Rc<ty::TraitRef<'tcx>>)\n+                                   -> ures<'tcx>\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n            a.repr(cx.tcx), b.repr(cx.tcx));\n@@ -431,12 +436,12 @@ fn expected_found<T>(a_is_expected: bool,\n     }\n }\n \n-pub fn mk_coercety(cx: &InferCtxt,\n-                   a_is_expected: bool,\n-                   origin: TypeOrigin,\n-                   a: ty::t,\n-                   b: ty::t)\n-                -> CoerceResult {\n+pub fn mk_coercety<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                             a_is_expected: bool,\n+                             origin: TypeOrigin,\n+                             a: Ty<'tcx>,\n+                             b: Ty<'tcx>)\n+                             -> CoerceResult<'tcx> {\n     debug!(\"mk_coercety({} -> {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     indent(|| {\n         cx.commit_if_ok(|| {\n@@ -450,11 +455,11 @@ pub fn mk_coercety(cx: &InferCtxt,\n }\n \n // See comment on the type `resolve_state` below\n-pub fn resolve_type(cx: &InferCtxt,\n-                    span: Option<Span>,\n-                    a: ty::t,\n-                    modes: uint)\n-                    -> fres<ty::t> {\n+pub fn resolve_type<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                              span: Option<Span>,\n+                              a: Ty<'tcx>,\n+                              modes: uint)\n+                              -> fres<Ty<'tcx>> {\n     let mut resolver = resolver(cx, modes, span);\n     cx.commit_unconditionally(|| resolver.resolve_type_chk(a))\n }\n@@ -465,37 +470,37 @@ pub fn resolve_region(cx: &InferCtxt, r: ty::Region, modes: uint)\n     resolver.resolve_region_chk(r)\n }\n \n-trait then {\n-    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err>)\n-        -> Result<T,ty::type_err>;\n+trait then<'tcx> {\n+    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err<'tcx>>)\n+        -> Result<T,ty::type_err<'tcx>>;\n }\n \n-impl then for ures {\n-    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err>)\n-        -> Result<T,ty::type_err> {\n+impl<'tcx> then<'tcx> for ures<'tcx> {\n+    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err<'tcx>>)\n+        -> Result<T,ty::type_err<'tcx>> {\n         self.and_then(|_i| f())\n     }\n }\n \n-trait ToUres {\n-    fn to_ures(&self) -> ures;\n+trait ToUres<'tcx> {\n+    fn to_ures(&self) -> ures<'tcx>;\n }\n \n-impl<T> ToUres for cres<T> {\n-    fn to_ures(&self) -> ures {\n+impl<'tcx, T> ToUres<'tcx> for cres<'tcx, T> {\n+    fn to_ures(&self) -> ures<'tcx> {\n         match *self {\n           Ok(ref _v) => Ok(()),\n           Err(ref e) => Err((*e))\n         }\n     }\n }\n \n-trait CresCompare<T> {\n-    fn compare(&self, t: T, f: || -> ty::type_err) -> cres<T>;\n+trait CresCompare<'tcx, T> {\n+    fn compare(&self, t: T, f: || -> ty::type_err<'tcx>) -> cres<'tcx, T>;\n }\n \n-impl<T:Clone + PartialEq> CresCompare<T> for cres<T> {\n-    fn compare(&self, t: T, f: || -> ty::type_err) -> cres<T> {\n+impl<'tcx, T:Clone + PartialEq> CresCompare<'tcx, T> for cres<'tcx, T> {\n+    fn compare(&self, t: T, f: || -> ty::type_err<'tcx>) -> cres<'tcx, T> {\n         (*self).clone().and_then(|s| {\n             if s == t {\n                 (*self).clone()\n@@ -506,7 +511,7 @@ impl<T:Clone + PartialEq> CresCompare<T> for cres<T> {\n     }\n }\n \n-pub fn uok() -> ures {\n+pub fn uok<'tcx>() -> ures<'tcx> {\n     Ok(())\n }\n \n@@ -518,12 +523,12 @@ pub struct CombinedSnapshot {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn skolemize<T:TypeFoldable>(&self, t: T) -> T {\n+    pub fn skolemize<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.skolemizer())\n     }\n \n-    pub fn type_var_diverges(&'a self, ty: ty::t) -> bool {\n-        match ty::get(ty).sty {\n+    pub fn type_var_diverges(&'a self, ty: Ty) -> bool {\n+        match ty.sty {\n             ty::ty_infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n             _ => false\n         }\n@@ -533,22 +538,25 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         skolemize::TypeSkolemizer::new(self)\n     }\n \n-    pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace)\n+    pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n                               -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn equate<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Equate<'a, 'tcx> {\n+    pub fn equate<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                      -> Equate<'a, 'tcx> {\n         Equate(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Sub<'a, 'tcx> {\n+    pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                   -> Sub<'a, 'tcx> {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn lub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Lub<'a, 'tcx> {\n+    pub fn lub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                   -> Lub<'a, 'tcx> {\n         Lub(self.combine_fields(a_is_expected, trace))\n     }\n \n@@ -651,9 +659,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn sub_types(&self,\n                      a_is_expected: bool,\n                      origin: TypeOrigin,\n-                     a: ty::t,\n-                     b: ty::t)\n-                     -> ures\n+                     a: Ty<'tcx>,\n+                     b: Ty<'tcx>)\n+                     -> ures<'tcx>\n     {\n         debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n         self.commit_if_ok(|| {\n@@ -668,9 +676,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn eq_types(&self,\n                     a_is_expected: bool,\n                     origin: TypeOrigin,\n-                    a: ty::t,\n-                    b: ty::t)\n-                    -> ures\n+                    a: Ty<'tcx>,\n+                    b: Ty<'tcx>)\n+                    -> ures<'tcx>\n     {\n         self.commit_if_ok(|| {\n             let trace = TypeTrace {\n@@ -684,9 +692,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn sub_trait_refs(&self,\n                           a_is_expected: bool,\n                           origin: TypeOrigin,\n-                          a: Rc<ty::TraitRef>,\n-                          b: Rc<ty::TraitRef>)\n-                          -> ures\n+                          a: Rc<ty::TraitRef<'tcx>>,\n+                          b: Rc<ty::TraitRef<'tcx>>)\n+                          -> ures<'tcx>\n     {\n         debug!(\"sub_trait_refs({} <: {})\",\n                a.repr(self.tcx),\n@@ -709,15 +717,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .new_var(diverging)\n     }\n \n-    pub fn next_ty_var(&self) -> ty::t {\n+    pub fn next_ty_var(&self) -> Ty<'tcx> {\n         ty::mk_var(self.tcx, self.next_ty_var_id(false))\n     }\n \n-    pub fn next_diverging_ty_var(&self) -> ty::t {\n+    pub fn next_diverging_ty_var(&self) -> Ty<'tcx> {\n         ty::mk_var(self.tcx, self.next_ty_var_id(true))\n     }\n \n-    pub fn next_ty_vars(&self, n: uint) -> Vec<ty::t> {\n+    pub fn next_ty_vars(&self, n: uint) -> Vec<Ty<'tcx>> {\n         Vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n@@ -733,7 +741,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .new_key(None)\n     }\n \n-    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region {\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin<'tcx>) -> ty::Region {\n         ty::ReInfer(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n@@ -748,8 +756,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn fresh_substs_for_generics(&self,\n                                      span: Span,\n-                                     generics: &ty::Generics)\n-                                     -> subst::Substs\n+                                     generics: &ty::Generics<'tcx>)\n+                                     -> subst::Substs<'tcx>\n     {\n         /*!\n          * Given a set of generics defined on a type or impl, returns\n@@ -768,9 +776,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn fresh_substs_for_trait(&self,\n                                   span: Span,\n-                                  generics: &ty::Generics,\n-                                  self_ty: ty::t)\n-                                  -> subst::Substs\n+                                  generics: &ty::Generics<'tcx>,\n+                                  self_ty: Ty<'tcx>)\n+                                  -> subst::Substs<'tcx>\n     {\n         /*!\n          * Given a set of generics defined on a trait, returns a\n@@ -805,22 +813,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.report_region_errors(&errors); // see error_reporting.rs\n     }\n \n-    pub fn ty_to_string(&self, t: ty::t) -> String {\n+    pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n         ty_to_string(self.tcx,\n                      self.resolve_type_vars_if_possible(t))\n     }\n \n-    pub fn tys_to_string(&self, ts: &[ty::t]) -> String {\n+    pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n         let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_string(*t)).collect();\n         format!(\"({})\", tstrs.connect(\", \"))\n     }\n \n-    pub fn trait_ref_to_string(&self, t: &Rc<ty::TraitRef>) -> String {\n+    pub fn trait_ref_to_string(&self, t: &Rc<ty::TraitRef<'tcx>>) -> String {\n         let t = self.resolve_type_vars_in_trait_ref_if_possible(&**t);\n         trait_ref_to_string(self.tcx, &t)\n     }\n \n-    pub fn contains_unbound_type_variables(&self, typ: ty::t) -> ty::t {\n+    pub fn contains_unbound_type_variables(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match resolve_type(self,\n                            None,\n                            typ, resolve_nested_tvar | resolve_ivar) {\n@@ -829,8 +837,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn shallow_resolve(&self, typ: ty::t) -> ty::t {\n-        match ty::get(typ).sty {\n+    pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n+        match typ.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n                 self.type_variables.borrow()\n                     .probe(v)\n@@ -853,7 +861,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_type_vars_if_possible(&self, typ: ty::t) -> ty::t {\n+    pub fn resolve_type_vars_if_possible(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match resolve_type(self,\n                            None,\n                            typ, resolve_nested_tvar | resolve_ivar) {\n@@ -863,14 +871,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn resolve_type_vars_in_trait_ref_if_possible(&self,\n-                                                      trait_ref: &ty::TraitRef)\n-                                                      -> ty::TraitRef {\n+                                                      trait_ref: &ty::TraitRef<'tcx>)\n+                                                      -> ty::TraitRef<'tcx> {\n         // make up a dummy type just to reuse/abuse the resolve machinery\n         let dummy0 = ty::mk_trait(self.tcx,\n                                   (*trait_ref).clone(),\n                                   ty::region_existential_bound(ty::ReStatic));\n         let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n-        match ty::get(dummy1).sty {\n+        match dummy1.sty {\n             ty::ty_trait(box ty::TyTrait { ref principal, .. }) => {\n                 (*principal).clone()\n             }\n@@ -899,7 +907,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                   sp: Span,\n                                   mk_msg: |Option<String>, String| -> String,\n                                   actual_ty: String,\n-                                  err: Option<&ty::type_err>) {\n+                                  err: Option<&ty::type_err<'tcx>>) {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n@@ -908,9 +916,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 mk_msg: |Option<String>,\n                                                          String|\n                                                          -> String,\n-                                                expected_ty: Option<ty::t>,\n+                                                expected_ty: Option<Ty<'tcx>>,\n                                                 actual_ty: String,\n-                                                err: Option<&ty::type_err>) {\n+                                                err: Option<&ty::type_err<'tcx>>) {\n         debug!(\"hi! expected_ty = {}, actual_ty = {}\", expected_ty, actual_ty);\n \n         let resolved_expected = expected_ty.map(|e_ty| {\n@@ -938,8 +946,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn type_error_message(&self,\n                               sp: Span,\n                               mk_msg: |String| -> String,\n-                              actual_ty: ty::t,\n-                              err: Option<&ty::type_err>) {\n+                              actual_ty: Ty<'tcx>,\n+                              err: Option<&ty::type_err<'tcx>>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n \n         // Don't report an error if actual type is ty_err.\n@@ -952,9 +960,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn report_mismatched_types(&self,\n                                    span: Span,\n-                                   expected: ty::t,\n-                                   actual: ty::t,\n-                                   err: &ty::type_err) {\n+                                   expected: Ty<'tcx>,\n+                                   actual: Ty<'tcx>,\n+                                   err: &ty::type_err<'tcx>) {\n         let trace = TypeTrace {\n             origin: Misc(span),\n             values: Types(ty::expected_found {\n@@ -971,7 +979,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         lbrct: LateBoundRegionConversionTime,\n         value: &T)\n         -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n-        where T : HigherRankedFoldable\n+        where T : HigherRankedFoldable<'tcx>\n     {\n         ty::replace_late_bound_regions(\n             self.tcx,\n@@ -980,12 +988,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n-impl TypeTrace {\n+impl<'tcx> TypeTrace<'tcx> {\n     pub fn span(&self) -> Span {\n         self.origin.span()\n     }\n \n-    pub fn dummy() -> TypeTrace {\n+    pub fn dummy() -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(ty::expected_found {\n@@ -996,7 +1004,7 @@ impl TypeTrace {\n     }\n }\n \n-impl Repr for TypeTrace {\n+impl<'tcx> Repr<'tcx> for TypeTrace<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"TypeTrace({})\", self.origin.repr(tcx))\n     }\n@@ -1018,7 +1026,7 @@ impl TypeOrigin {\n     }\n }\n \n-impl Repr for TypeOrigin {\n+impl<'tcx> Repr<'tcx> for TypeOrigin {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             MethodCompatCheck(a) => {\n@@ -1050,7 +1058,7 @@ impl Repr for TypeOrigin {\n     }\n }\n \n-impl SubregionOrigin {\n+impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n             Subtype(ref a) => a.span(),\n@@ -1079,8 +1087,8 @@ impl SubregionOrigin {\n     }\n }\n \n-impl Repr for SubregionOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             Subtype(ref a) => {\n                 format!(\"Subtype({})\", a.repr(tcx))\n@@ -1150,7 +1158,7 @@ impl Repr for SubregionOrigin {\n     }\n }\n \n-impl RegionVariableOrigin {\n+impl<'tcx> RegionVariableOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n             MiscVariable(a) => a,\n@@ -1167,8 +1175,8 @@ impl RegionVariableOrigin {\n     }\n }\n \n-impl Repr for RegionVariableOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for RegionVariableOrigin<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             MiscVariable(a) => {\n                 format!(\"MiscVariable({})\", a.repr(tcx))"}, {"sha": "5452a99127fc47f643af5fca363e28d3daf00a14", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -52,17 +52,17 @@ pub enum Constraint {\n \n // Something we have to verify after region inference is done, but\n // which does not directly influence the inference process\n-pub enum Verify {\n+pub enum Verify<'tcx> {\n     // VerifyRegSubReg(a, b): Verify that `a <= b`. Neither `a` nor\n     // `b` are inference variables.\n-    VerifyRegSubReg(SubregionOrigin, Region, Region),\n+    VerifyRegSubReg(SubregionOrigin<'tcx>, Region, Region),\n \n     // VerifyParamBound(T, _, R, RS): The parameter type `T` must\n     // outlive the region `R`. `T` is known to outlive `RS`. Therefore\n     // verify that `R <= RS[i]` for some `i`. Inference variables may\n     // be involved (but this verification step doesn't influence\n     // inference).\n-    VerifyParamBound(ty::ParamTy, SubregionOrigin, Region, Vec<Region>),\n+    VerifyParamBound(ty::ParamTy, SubregionOrigin<'tcx>, Region, Vec<Region>),\n }\n \n #[deriving(PartialEq, Eq, Hash)]\n@@ -89,43 +89,43 @@ pub enum CombineMapType {\n }\n \n #[deriving(Clone, Show)]\n-pub enum RegionResolutionError {\n+pub enum RegionResolutionError<'tcx> {\n     /// `ConcreteFailure(o, a, b)`:\n     ///\n     /// `o` requires that `a <= b`, but this does not hold\n-    ConcreteFailure(SubregionOrigin, Region, Region),\n+    ConcreteFailure(SubregionOrigin<'tcx>, Region, Region),\n \n     /// `ParamBoundFailure(p, s, a, bs)\n     ///\n     /// The parameter type `p` must be known to outlive the lifetime\n     /// `a`, but it is only known to outlive `bs` (and none of the\n     /// regions in `bs` outlive `a`).\n-    ParamBoundFailure(SubregionOrigin, ty::ParamTy, Region, Vec<Region>),\n+    ParamBoundFailure(SubregionOrigin<'tcx>, ty::ParamTy, Region, Vec<Region>),\n \n     /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n     /// Could not infer a value for `v` because `sub_r <= v` (due to\n     /// `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n     /// `sub_r <= sup_r` does not hold.\n-    SubSupConflict(RegionVariableOrigin,\n-                   SubregionOrigin, Region,\n-                   SubregionOrigin, Region),\n+    SubSupConflict(RegionVariableOrigin<'tcx>,\n+                   SubregionOrigin<'tcx>, Region,\n+                   SubregionOrigin<'tcx>, Region),\n \n     /// `SupSupConflict(v, origin1, r1, origin2, r2)`:\n     ///\n     /// Could not infer a value for `v` because `v <= r1` (due to\n     /// `origin1`) and `v <= r2` (due to `origin2`) and\n     /// `r1` and `r2` have no intersection.\n-    SupSupConflict(RegionVariableOrigin,\n-                   SubregionOrigin, Region,\n-                   SubregionOrigin, Region),\n+    SupSupConflict(RegionVariableOrigin<'tcx>,\n+                   SubregionOrigin<'tcx>, Region,\n+                   SubregionOrigin<'tcx>, Region),\n \n     /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n     /// more specific errors message by suggesting to the user where they\n     /// should put a lifetime. In those cases we process and put those errors\n     /// into `ProcessedErrors` before we do any reporting.\n-    ProcessedErrors(Vec<RegionVariableOrigin>,\n-                    Vec<(TypeTrace, ty::type_err)>,\n+    ProcessedErrors(Vec<RegionVariableOrigin<'tcx>>,\n+                    Vec<(TypeTrace<'tcx>, ty::type_err<'tcx>)>,\n                     Vec<SameRegions>),\n }\n \n@@ -160,19 +160,19 @@ pub type CombineMap = FnvHashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    var_origins: RefCell<Vec<RegionVariableOrigin>>,\n+    var_origins: RefCell<Vec<RegionVariableOrigin<'tcx>>>,\n \n     // Constraints of the form `A <= B` introduced by the region\n     // checker.  Here at least one of `A` and `B` must be a region\n     // variable.\n-    constraints: RefCell<FnvHashMap<Constraint, SubregionOrigin>>,\n+    constraints: RefCell<FnvHashMap<Constraint, SubregionOrigin<'tcx>>>,\n \n     // A \"verify\" is something that we need to verify after inference is\n     // done, but which does not directly affect inference in any way.\n     //\n     // An example is a `A <= B` where neither `A` nor `B` are\n     // inference variables.\n-    verifys: RefCell<Vec<Verify>>,\n+    verifys: RefCell<Vec<Verify<'tcx>>>,\n \n     // A \"given\" is a relationship that is known to hold. In particular,\n     // we often know from closure fn signatures that a particular free\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.var_origins.borrow().len()\n     }\n \n-    pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n+    pub fn new_region_var(&self, origin: RegionVariableOrigin<'tcx>) -> RegionVid {\n         let id = self.num_vars();\n         self.var_origins.borrow_mut().push(origin.clone());\n         let vid = RegionVid { index: id };\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n     fn add_constraint(&self,\n                       constraint: Constraint,\n-                      origin: SubregionOrigin) {\n+                      origin: SubregionOrigin<'tcx>) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -382,7 +382,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn add_verify(&self,\n-                  verify: Verify) {\n+                  verify: Verify<'tcx>) {\n         // cannot add verifys once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -414,7 +414,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn make_eqregion(&self,\n-                         origin: SubregionOrigin,\n+                         origin: SubregionOrigin<'tcx>,\n                          sub: Region,\n                          sup: Region) {\n         if sub != sup {\n@@ -426,7 +426,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn make_subregion(&self,\n-                          origin: SubregionOrigin,\n+                          origin: SubregionOrigin<'tcx>,\n                           sub: Region,\n                           sup: Region) {\n         // cannot add constraints once regions are resolved\n@@ -474,15 +474,15 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn verify_param_bound(&self,\n-                              origin: SubregionOrigin,\n+                              origin: SubregionOrigin<'tcx>,\n                               param_ty: ty::ParamTy,\n                               sub: Region,\n                               sups: Vec<Region>) {\n         self.add_verify(VerifyParamBound(param_ty, origin, sub, sups));\n     }\n \n     pub fn lub_regions(&self,\n-                       origin: SubregionOrigin,\n+                       origin: SubregionOrigin<'tcx>,\n                        a: Region,\n                        b: Region)\n                        -> Region {\n@@ -507,7 +507,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn glb_regions(&self,\n-                       origin: SubregionOrigin,\n+                       origin: SubregionOrigin<'tcx>,\n                        a: Region,\n                        b: Region)\n                        -> Region {\n@@ -560,8 +560,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         t: CombineMapType,\n                         a: Region,\n                         b: Region,\n-                        origin: SubregionOrigin,\n-                        relate: |this: &RegionVarBindings,\n+                        origin: SubregionOrigin<'tcx>,\n+                        relate: |this: &RegionVarBindings<'a, 'tcx>,\n                                  old_r: Region,\n                                  new_r: Region|)\n                         -> Region {\n@@ -700,7 +700,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     constraints, assuming such values can be found; if they cannot,\n     errors are reported.\n     */\n-    pub fn resolve_regions(&self) -> Vec<RegionResolutionError> {\n+    pub fn resolve_regions(&self) -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = vec!();\n         let v = self.infer_variable_values(&mut errors);\n@@ -815,7 +815,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn glb_concrete_regions(&self,\n                             a: Region,\n                             b: Region)\n-                         -> cres<Region> {\n+                         -> cres<'tcx, Region> {\n         debug!(\"glb_concrete_regions({}, {})\", a, b);\n         match (a, b) {\n             (ReLateBound(..), _) |\n@@ -885,7 +885,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n     fn glb_free_regions(&self,\n                         a: &FreeRegion,\n-                        b: &FreeRegion) -> cres<ty::Region>\n+                        b: &FreeRegion) -> cres<'tcx, ty::Region>\n     {\n         /*!\n          * Computes a region that is enclosed by both free region arguments,\n@@ -899,9 +899,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             Equal => Ok(ty::ReFree(*a))\n         };\n \n-        fn helper(this: &RegionVarBindings,\n-                  a: &FreeRegion,\n-                  b: &FreeRegion) -> cres<ty::Region>\n+        fn helper<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n+                            a: &FreeRegion,\n+                            b: &FreeRegion) -> cres<'tcx, ty::Region>\n         {\n             if this.tcx.region_maps.sub_free_region(*a, *b) {\n                 Ok(ty::ReFree(*a))\n@@ -918,7 +918,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         region_a: ty::Region,\n                         region_b: ty::Region,\n                         scope_a: ast::NodeId,\n-                        scope_b: ast::NodeId) -> cres<Region>\n+                        scope_b: ast::NodeId) -> cres<'tcx, Region>\n     {\n         // We want to generate the intersection of two\n         // scopes or two free regions.  So, if one of\n@@ -946,16 +946,16 @@ struct VarData {\n     value: VarValue,\n }\n \n-struct RegionAndOrigin {\n+struct RegionAndOrigin<'tcx> {\n     region: Region,\n-    origin: SubregionOrigin,\n+    origin: SubregionOrigin<'tcx>,\n }\n \n type RegionGraph = graph::Graph<(), Constraint>;\n \n impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn infer_variable_values(&self,\n-                             errors: &mut Vec<RegionResolutionError>)\n+                             errors: &mut Vec<RegionResolutionError<'tcx>>)\n                              -> Vec<VarValue>\n     {\n         let mut var_data = self.construct_var_data();\n@@ -1188,7 +1188,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n     fn collect_concrete_region_errors(&self,\n                                       values: &Vec<VarValue>,\n-                                      errors: &mut Vec<RegionResolutionError>)\n+                                      errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n         let mut reg_reg_dups = FnvHashSet::new();\n         for verify in self.verifys.borrow().iter() {\n@@ -1230,7 +1230,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn extract_values_and_collect_conflicts(\n         &self,\n         var_data: &[VarData],\n-        errors: &mut Vec<RegionResolutionError>)\n+        errors: &mut Vec<RegionResolutionError<'tcx>>)\n         -> Vec<VarValue>\n     {\n         debug!(\"extract_values_and_collect_conflicts()\");\n@@ -1353,7 +1353,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         var_data: &[VarData],\n         dup_vec: &mut [uint],\n         node_idx: RegionVid,\n-        errors: &mut Vec<RegionResolutionError>)\n+        errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n@@ -1414,7 +1414,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         var_data: &[VarData],\n         dup_vec: &mut [uint],\n         node_idx: RegionVid,\n-        errors: &mut Vec<RegionResolutionError>)\n+        errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n         // Errors in contracting nodes result from two upper-bounds\n         // that have no intersection.\n@@ -1458,11 +1458,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction,\n                                 dup_vec: &mut [uint])\n-                                -> (Vec<RegionAndOrigin> , bool) {\n-        struct WalkState {\n+                                -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n+        struct WalkState<'tcx> {\n             set: FnvHashSet<RegionVid>,\n-            stack: Vec<RegionVid> ,\n-            result: Vec<RegionAndOrigin> ,\n+            stack: Vec<RegionVid>,\n+            result: Vec<RegionAndOrigin<'tcx>>,\n             dup_found: bool\n         }\n         let mut state = WalkState {\n@@ -1505,8 +1505,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let WalkState {result, dup_found, ..} = state;\n         return (result, dup_found);\n \n-        fn process_edges(this: &RegionVarBindings,\n-                         state: &mut WalkState,\n+        fn process_edges<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n+                         state: &mut WalkState<'tcx>,\n                          graph: &RegionGraph,\n                          source_vid: RegionVid,\n                          dir: Direction) {\n@@ -1559,7 +1559,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n }\n \n-impl Repr for Constraint {\n+impl<'tcx> Repr<'tcx> for Constraint {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             ConstrainVarSubVar(a, b) => {\n@@ -1575,8 +1575,8 @@ impl Repr for Constraint {\n     }\n }\n \n-impl Repr for Verify {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for Verify<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             VerifyRegSubReg(_, ref a, ref b) => {\n                 format!(\"VerifyRegSubReg({}, {})\", a.repr(tcx), b.repr(tcx))\n@@ -1604,7 +1604,7 @@ fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n     }\n }\n \n-impl Repr for VarValue {\n+impl<'tcx> Repr<'tcx> for VarValue {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             NoValue => format!(\"NoValue\"),\n@@ -1614,8 +1614,8 @@ impl Repr for VarValue {\n     }\n }\n \n-impl Repr for RegionAndOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for RegionAndOrigin<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"RegionAndOrigin({},{})\",\n                 self.region.repr(tcx),\n                 self.origin.repr(tcx))"}, {"sha": "cf5efd188ed96ed8724cf8628e9e9f8dcb40b7af", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -50,7 +50,7 @@\n \n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n use middle::ty::{IntType, UintType};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold;\n use middle::typeck::infer::{fixup_err, fres, InferCtxt};\n use middle::typeck::infer::{unresolved_int_ty,unresolved_float_ty,unresolved_ty};\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for ResolveState<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         self.resolve_type(t)\n     }\n \n@@ -112,10 +112,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         (self.modes & mode) == mode\n     }\n \n-    pub fn resolve_type_chk(&mut self,\n-                            typ: ty::t)\n-                            -> fres<ty::t>\n-    {\n+    pub fn resolve_type_chk(&mut self, typ: Ty<'tcx>) -> fres<Ty<'tcx>> {\n         self.err = None;\n \n         debug!(\"Resolving {} (modes={:x})\",\n@@ -151,7 +148,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_type(&mut self, typ: ty::t) -> ty::t {\n+    pub fn resolve_type(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"resolve_type({})\", typ.repr(self.infcx.tcx));\n \n         if !ty::type_needs_infer(typ) {\n@@ -162,7 +159,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n             return typ;\n         }\n \n-        match ty::get(typ).sty {\n+        match typ.sty {\n             ty::ty_infer(TyVar(vid)) => {\n                 self.resolve_ty_var(vid)\n             }\n@@ -203,7 +200,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         self.infcx.region_vars.resolve_var(rid)\n     }\n \n-    pub fn resolve_ty_var(&mut self, vid: TyVid) -> ty::t {\n+    pub fn resolve_ty_var(&mut self, vid: TyVid) -> Ty<'tcx> {\n         let tcx = self.infcx.tcx;\n         let tv = self.infcx.type_variables.borrow();\n         match tv.probe(vid) {\n@@ -219,7 +216,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_int_var(&mut self, vid: IntVid) -> ty::t {\n+    pub fn resolve_int_var(&mut self, vid: IntVid) -> Ty<'tcx> {\n         if !self.should(resolve_ivar) {\n             return ty::mk_int_var(self.infcx.tcx, vid);\n         }\n@@ -240,7 +237,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_float_var(&mut self, vid: FloatVid) -> ty::t {\n+    pub fn resolve_float_var(&mut self, vid: FloatVid) -> Ty<'tcx> {\n         if !self.should(resolve_fvar) {\n             return ty::mk_float_var(self.infcx.tcx, vid);\n         }"}, {"sha": "5907a2bb9b61d945d2eee360d7ea99653f65d937", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -40,7 +40,7 @@\n  * it is reasonable to ask what the type inferencer knows \"so far\".\n  */\n \n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold;\n use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n@@ -52,7 +52,7 @@ use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n pub struct TypeSkolemizer<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     skolemization_count: uint,\n-    skolemization_map: hash_map::HashMap<ty::InferTy, ty::t>,\n+    skolemization_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n@@ -65,10 +65,10 @@ impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n     }\n \n     fn skolemize(&mut self,\n-                 opt_ty: Option<ty::t>,\n+                 opt_ty: Option<Ty<'tcx>>,\n                  key: ty::InferTy,\n                  skolemizer: |uint| -> ty::InferTy)\n-                 -> ty::t\n+                 -> Ty<'tcx>\n     {\n         match opt_ty {\n             Some(ty) => { return ty.fold_with(self); }\n@@ -112,8 +112,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n-        match ty::get(t).sty {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n                 self.skolemize(self.infcx.type_variables.borrow().probe(v),\n                                ty::TyVar(v),"}, {"sha": "65d2a5133936c974e6ab42e6ca258b74de13b9ed", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -10,7 +10,7 @@\n \n \n use middle::ty::{BuiltinBounds};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::TyVar;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::{cres, CresCompare};\n@@ -40,27 +40,27 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"sub\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n+    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n \n     fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n     fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n     fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n-    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         Sub(self.fields.switch_expected()).tys(b, a)\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                     -> cres<ty::Region> {\n+                     -> cres<'tcx, ty::Region> {\n                          let opp = CombineFields {\n                              a_is_expected: !self.fields.a_is_expected,\n                              ..self.fields.clone()\n                          };\n                          Sub(opp).regions(b, a)\n                      }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.tcx()),\n@@ -69,7 +69,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         Ok(a)\n     }\n \n-    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         debug!(\"mts({} <: {})\",\n                a.repr(self.tcx()),\n                b.repr(self.tcx()));\n@@ -93,20 +93,20 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         Ok(*a) // return is meaningless in sub, just return *a\n     }\n \n-    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<'tcx, FnStyle> {\n         self.lub().fn_styles(a, b).compare(b, || {\n             ty::terr_fn_style_mismatch(expected_found(self, a, b))\n         })\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness> {\n         self.lub().oncenesses(a, b).compare(b, || {\n             ty::terr_onceness_mismatch(expected_found(self, a, b))\n         })\n     }\n \n     fn builtin_bounds(&self, a: BuiltinBounds, b: BuiltinBounds)\n-                      -> cres<BuiltinBounds> {\n+                      -> cres<'tcx, BuiltinBounds> {\n         // More bounds is a subtype of fewer bounds.\n         //\n         // e.g., fn:Copy() <: fn(), because the former is a function\n@@ -119,15 +119,15 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         }\n     }\n \n-    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.tcx()), b.repr(self.tcx()));\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n         let a = infcx.type_variables.borrow().replace_if_possible(a);\n         let b = infcx.type_variables.borrow().replace_if_possible(b);\n-        match (&ty::get(a).sty, &ty::get(b).sty) {\n+        match (&a.sty, &b.sty) {\n             (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n                 infcx.type_variables\n                     .borrow_mut()\n@@ -155,11 +155,13 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         }\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n+               -> cres<'tcx, ty::FnSig<'tcx>> {\n         self.higher_ranked_sub(a, b)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n+                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n         self.higher_ranked_sub(a, b)\n     }\n }"}, {"sha": "f7f7389602f8292892a8c92ee9f4c88455cb4203", "filename": "src/librustc/middle/typeck/infer/type_variable.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -12,21 +12,21 @@ pub use self::RelationDir::*;\n use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n \n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use std::mem;\n use util::snapshot_vec as sv;\n \n-pub struct TypeVariableTable {\n-    values: sv::SnapshotVec<TypeVariableData,UndoEntry,Delegate>,\n+pub struct TypeVariableTable<'tcx> {\n+    values: sv::SnapshotVec<TypeVariableData<'tcx>,UndoEntry,Delegate>,\n }\n \n-struct TypeVariableData {\n-    value: TypeVariableValue,\n+struct TypeVariableData<'tcx> {\n+    value: TypeVariableValue<'tcx>,\n     diverging: bool\n }\n \n-enum TypeVariableValue {\n-    Known(ty::t),\n+enum TypeVariableValue<'tcx> {\n+    Known(Ty<'tcx>),\n     Bounded(Vec<Relation>),\n }\n \n@@ -59,8 +59,8 @@ impl RelationDir {\n     }\n }\n \n-impl TypeVariableTable {\n-    pub fn new() -> TypeVariableTable {\n+impl<'tcx> TypeVariableTable<'tcx> {\n+    pub fn new() -> TypeVariableTable<'tcx> {\n         TypeVariableTable { values: sv::SnapshotVec::new(Delegate) }\n     }\n \n@@ -89,8 +89,8 @@ impl TypeVariableTable {\n     pub fn instantiate_and_push(\n         &mut self,\n         vid: ty::TyVid,\n-        ty: ty::t,\n-        stack: &mut Vec<(ty::t, RelationDir, ty::TyVid)>)\n+        ty: Ty<'tcx>,\n+        stack: &mut Vec<(Ty<'tcx>, RelationDir, ty::TyVid)>)\n     {\n         /*!\n          * Instantiates `vid` with the type `ty` and then pushes an\n@@ -125,15 +125,15 @@ impl TypeVariableTable {\n         ty::TyVid { index: index }\n     }\n \n-    pub fn probe(&self, vid: ty::TyVid) -> Option<ty::t> {\n+    pub fn probe(&self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n         match self.values.get(vid.index).value {\n             Bounded(..) => None,\n             Known(t) => Some(t)\n         }\n     }\n \n-    pub fn replace_if_possible(&self, t: ty::t) -> ty::t {\n-        match ty::get(t).sty {\n+    pub fn replace_if_possible(&self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n                 match self.probe(v) {\n                     None => t,\n@@ -157,7 +157,7 @@ impl TypeVariableTable {\n     }\n }\n \n-impl sv::SnapshotVecDelegate<TypeVariableData,UndoEntry> for Delegate {\n+impl<'tcx> sv::SnapshotVecDelegate<TypeVariableData<'tcx>,UndoEntry> for Delegate {\n     fn reverse(&mut self,\n                values: &mut Vec<TypeVariableData>,\n                action: UndoEntry) {"}, {"sha": "fcf042b3f8b80e4cb56f1e565c809bbd7304b5a8", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -13,7 +13,7 @@ pub use self::VarValue::*;\n use std::kinds::marker;\n \n use middle::ty::{expected_found, IntVarValue};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::{uok, ures};\n use middle::typeck::infer::InferCtxt;\n use std::cell::RefCell;\n@@ -34,7 +34,7 @@ use util::snapshot_vec as sv;\n  *\n  * Implementations of this trait are at the end of this file.\n  */\n-pub trait UnifyKey<V> : Clone + Show + PartialEq + Repr {\n+pub trait UnifyKey<'tcx, V> : Clone + Show + PartialEq + Repr<'tcx> {\n     fn index(&self) -> uint;\n \n     fn from_index(u: uint) -> Self;\n@@ -57,7 +57,7 @@ pub trait UnifyKey<V> : Clone + Show + PartialEq + Repr {\n  *\n  * Implementations of this trait are at the end of this file.\n  */\n-pub trait UnifyValue : Clone + Repr + PartialEq {\n+pub trait UnifyValue<'tcx> : Clone + Repr<'tcx> + PartialEq {\n }\n \n /**\n@@ -114,7 +114,7 @@ pub struct Delegate;\n // other type parameter U, and we have no way to say\n // Option<U>:LatticeValue.\n \n-impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n+impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K,V> {\n     pub fn new() -> UnificationTable<K,V> {\n         UnificationTable {\n             values: sv::SnapshotVec::new(Delegate),\n@@ -189,7 +189,7 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n     }\n \n     pub fn set(&mut self,\n-               tcx: &ty::ctxt,\n+               tcx: &ty::ctxt<'tcx>,\n                key: K,\n                new_value: VarValue<K,V>)\n     {\n@@ -208,7 +208,7 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n     }\n \n     pub fn unify(&mut self,\n-                 tcx: &ty::ctxt,\n+                 tcx: &ty::ctxt<'tcx>,\n                  node_a: &Node<K,V>,\n                  node_b: &Node<K,V>)\n                  -> (K, uint)\n@@ -259,15 +259,15 @@ impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n  * Indicates a type that does not have any kind of subtyping\n  * relationship.\n  */\n-pub trait SimplyUnifiable : Clone + PartialEq + Repr {\n-    fn to_type(&self) -> ty::t;\n-    fn to_type_err(expected_found<Self>) -> ty::type_err;\n+pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Repr<'tcx> {\n+    fn to_type(&self) -> Ty<'tcx>;\n+    fn to_type_err(expected_found<Self>) -> ty::type_err<'tcx>;\n }\n \n-pub fn err<V:SimplyUnifiable>(a_is_expected: bool,\n-                              a_t: V,\n-                              b_t: V)\n-                              -> ures {\n+pub fn err<'tcx, V:SimplyUnifiable<'tcx>>(a_is_expected: bool,\n+                                          a_t: V,\n+                                          b_t: V)\n+                                          -> ures<'tcx> {\n     if a_is_expected {\n         Err(SimplyUnifiable::to_type_err(\n             ty::expected_found {expected: a_t, found: b_t}))\n@@ -277,29 +277,29 @@ pub fn err<V:SimplyUnifiable>(a_is_expected: bool,\n     }\n }\n \n-pub trait InferCtxtMethodsForSimplyUnifiableTypes<V:SimplyUnifiable,\n-                                                  K:UnifyKey<Option<V>>> {\n+pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V:SimplyUnifiable<'tcx>,\n+                                                  K:UnifyKey<'tcx, Option<V>>> {\n     fn simple_vars(&self,\n                    a_is_expected: bool,\n                    a_id: K,\n                    b_id: K)\n-                   -> ures;\n+                   -> ures<'tcx>;\n     fn simple_var_t(&self,\n                     a_is_expected: bool,\n                     a_id: K,\n                     b: V)\n-                    -> ures;\n-    fn probe_var(&self, a_id: K) -> Option<ty::t>;\n+                    -> ures<'tcx>;\n+    fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>>;\n }\n \n-impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n-    InferCtxtMethodsForSimplyUnifiableTypes<V,K> for InferCtxt<'a, 'tcx>\n+impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n+    InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V, K> for InferCtxt<'a, 'tcx>\n {\n     fn simple_vars(&self,\n                    a_is_expected: bool,\n                    a_id: K,\n                    b_id: K)\n-                   -> ures\n+                   -> ures<'tcx>\n     {\n         /*!\n          * Unifies two simple keys.  Because simple keys do\n@@ -345,7 +345,7 @@ impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n                     a_is_expected: bool,\n                     a_id: K,\n                     b: V)\n-                    -> ures\n+                    -> ures<'tcx>\n     {\n         /*!\n          * Sets the value of the key `a_id` to `b`.  Because\n@@ -375,7 +375,7 @@ impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n         }\n     }\n \n-    fn probe_var(&self, a_id: K) -> Option<ty::t> {\n+    fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>> {\n         let tcx = self.tcx;\n         let table = UnifyKey::unification_table(self);\n         let node_a = table.borrow_mut().get(tcx, a_id);\n@@ -390,7 +390,7 @@ impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n \n // Integral type keys\n \n-impl UnifyKey<Option<IntVarValue>> for ty::IntVid {\n+impl<'tcx> UnifyKey<'tcx, Option<IntVarValue>> for ty::IntVid {\n     fn index(&self) -> uint { self.index }\n \n     fn from_index(i: uint) -> ty::IntVid { ty::IntVid { index: i } }\n@@ -406,24 +406,24 @@ impl UnifyKey<Option<IntVarValue>> for ty::IntVid {\n     }\n }\n \n-impl SimplyUnifiable for IntVarValue {\n-    fn to_type(&self) -> ty::t {\n+impl<'tcx> SimplyUnifiable<'tcx> for IntVarValue {\n+    fn to_type(&self) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => ty::mk_mach_int(i),\n             ty::UintType(i) => ty::mk_mach_uint(i),\n         }\n     }\n \n-    fn to_type_err(err: expected_found<IntVarValue>) -> ty::type_err {\n+    fn to_type_err(err: expected_found<IntVarValue>) -> ty::type_err<'tcx> {\n         return ty::terr_int_mismatch(err);\n     }\n }\n \n-impl UnifyValue for Option<IntVarValue> { }\n+impl<'tcx> UnifyValue<'tcx> for Option<IntVarValue> { }\n \n // Floating point type keys\n \n-impl UnifyKey<Option<ast::FloatTy>> for ty::FloatVid {\n+impl<'tcx> UnifyKey<'tcx, Option<ast::FloatTy>> for ty::FloatVid {\n     fn index(&self) -> uint { self.index }\n \n     fn from_index(i: uint) -> ty::FloatVid { ty::FloatVid { index: i } }\n@@ -439,21 +439,21 @@ impl UnifyKey<Option<ast::FloatTy>> for ty::FloatVid {\n     }\n }\n \n-impl UnifyValue for Option<ast::FloatTy> {\n+impl<'tcx> UnifyValue<'tcx> for Option<ast::FloatTy> {\n }\n \n-impl SimplyUnifiable for ast::FloatTy {\n-    fn to_type(&self) -> ty::t {\n+impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n+    fn to_type(&self) -> Ty<'tcx> {\n         ty::mk_mach_float(*self)\n     }\n \n-    fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err {\n-        return ty::terr_float_mismatch(err);\n+    fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err<'tcx> {\n+        ty::terr_float_mismatch(err)\n     }\n }\n \n-impl<K:Repr,V:Repr> Repr for VarValue<K,V> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx, K:Repr<'tcx>, V:Repr<'tcx>> Repr<'tcx> for VarValue<K,V> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             Redirect(ref k) => format!(\"Redirect({})\", k.repr(tcx)),\n             Root(ref v, r) => format!(\"Root({}, {})\", v.repr(tcx), r)"}, {"sha": "ad64537e1533ea2c5cec285dcfd4b4fed2b746c4", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -69,7 +69,7 @@ use middle::def;\n use middle::resolve;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use session::config;\n use util::common::time;\n use util::ppaux::Repr;\n@@ -97,38 +97,38 @@ pub struct param_index {\n }\n \n #[deriving(Clone, Show)]\n-pub enum MethodOrigin {\n+pub enum MethodOrigin<'tcx> {\n     // fully statically resolved method\n     MethodStatic(ast::DefId),\n \n     // fully statically resolved unboxed closure invocation\n     MethodStaticUnboxedClosure(ast::DefId),\n \n     // method invoked on a type parameter with a bounded trait\n-    MethodTypeParam(MethodParam),\n+    MethodTypeParam(MethodParam<'tcx>),\n \n     // method invoked on a trait instance\n-    MethodTraitObject(MethodObject),\n+    MethodTraitObject(MethodObject<'tcx>),\n \n }\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n #[deriving(Clone, Show)]\n-pub struct MethodParam {\n+pub struct MethodParam<'tcx> {\n     // the precise trait reference that occurs as a bound -- this may\n     // be a supertrait of what the user actually typed.\n-    pub trait_ref: Rc<ty::TraitRef>,\n+    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n     // index of uint in the list of methods for the trait\n     pub method_num: uint,\n }\n \n // details for a method invoked with a receiver whose type is an object\n #[deriving(Clone, Show)]\n-pub struct MethodObject {\n+pub struct MethodObject<'tcx> {\n     // the (super)trait containing the method to be invoked\n-    pub trait_ref: Rc<ty::TraitRef>,\n+    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n     // the actual base trait id of the object\n     pub object_trait_id: ast::DefId,\n@@ -144,10 +144,10 @@ pub struct MethodObject {\n }\n \n #[deriving(Clone)]\n-pub struct MethodCallee {\n-    pub origin: MethodOrigin,\n-    pub ty: ty::t,\n-    pub substs: subst::Substs\n+pub struct MethodCallee<'tcx> {\n+    pub origin: MethodOrigin<'tcx>,\n+    pub ty: Ty<'tcx>,\n+    pub substs: subst::Substs<'tcx>\n }\n \n /**\n@@ -177,9 +177,9 @@ pub enum ExprAdjustment {\n     AutoObject\n }\n \n-pub struct TypeAndSubsts {\n-    pub substs: subst::Substs,\n-    pub ty: ty::t,\n+pub struct TypeAndSubsts<'tcx> {\n+    pub substs: subst::Substs<'tcx>,\n+    pub ty: Ty<'tcx>,\n }\n \n impl MethodCall {\n@@ -207,21 +207,21 @@ impl MethodCall {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type MethodMap = RefCell<FnvHashMap<MethodCall, MethodCallee>>;\n+pub type MethodMap<'tcx> = RefCell<FnvHashMap<MethodCall, MethodCallee<'tcx>>>;\n \n-pub type vtable_param_res = Vec<vtable_origin>;\n+pub type vtable_param_res<'tcx> = Vec<vtable_origin<'tcx>>;\n \n // Resolutions for bounds of all parameters, left to right, for a given path.\n-pub type vtable_res = VecPerParamSpace<vtable_param_res>;\n+pub type vtable_res<'tcx> = VecPerParamSpace<vtable_param_res<'tcx>>;\n \n #[deriving(Clone)]\n-pub enum vtable_origin {\n+pub enum vtable_origin<'tcx> {\n     /*\n       Statically known vtable. def_id gives the impl item\n       from whence comes the vtable, and tys are the type substs.\n       vtable_res is the vtable itself.\n      */\n-    vtable_static(ast::DefId, subst::Substs, vtable_res),\n+    vtable_static(ast::DefId, subst::Substs<'tcx>, vtable_res<'tcx>),\n \n     /*\n       Dynamic vtable, comes from a parameter that has a bound on it:\n@@ -248,8 +248,8 @@ pub enum vtable_origin {\n     vtable_error,\n }\n \n-impl Repr for vtable_origin {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for vtable_origin<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n                 format!(\"vtable_static({}:{}, {}, {})\",\n@@ -276,7 +276,7 @@ impl Repr for vtable_origin {\n \n // For every explicit cast into an object type, maps from the cast\n // expr to the associated trait ref.\n-pub type ObjectCastMap = RefCell<NodeMap<Rc<ty::TraitRef>>>;\n+pub type ObjectCastMap<'tcx> = RefCell<NodeMap<Rc<ty::TraitRef<'tcx>>>>;\n \n pub struct CrateCtxt<'a, 'tcx: 'a> {\n     // A mapping from method call sites to traits that have that method.\n@@ -285,15 +285,15 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n }\n \n // Functions that write types into the node type table\n-pub fn write_ty_to_tcx(tcx: &ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n+pub fn write_ty_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n     debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_string(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n     tcx.node_types.borrow_mut().insert(node_id, ty);\n }\n \n-pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n-                           node_id: ast::NodeId,\n-                           item_substs: ty::ItemSubsts) {\n+pub fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 node_id: ast::NodeId,\n+                                 item_substs: ty::ItemSubsts<'tcx>) {\n     if !item_substs.is_noop() {\n         debug!(\"write_substs_to_tcx({}, {})\",\n                node_id,\n@@ -318,22 +318,22 @@ pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n \n-pub fn no_params(t: ty::t) -> ty::Polytype {\n+pub fn no_params<'tcx>(t: Ty<'tcx>) -> ty::Polytype<'tcx> {\n     ty::Polytype {\n         generics: ty::Generics {types: VecPerParamSpace::empty(),\n                                 regions: VecPerParamSpace::empty()},\n         ty: t\n     }\n }\n \n-pub fn require_same_types(tcx: &ty::ctxt,\n-                          maybe_infcx: Option<&infer::InferCtxt>,\n-                          t1_is_expected: bool,\n-                          span: Span,\n-                          t1: ty::t,\n-                          t2: ty::t,\n-                          msg: || -> String)\n-                          -> bool {\n+pub fn require_same_types<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                    maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n+                                    t1_is_expected: bool,\n+                                    span: Span,\n+                                    t1: Ty<'tcx>,\n+                                    t2: Ty<'tcx>,\n+                                    msg: || -> String)\n+                                    -> bool {\n     let result = match maybe_infcx {\n         None => {\n             let infcx = infer::new_infer_ctxt(tcx);\n@@ -363,7 +363,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_span: Span) {\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n-    match ty::get(main_t).sty {\n+    match main_t.sty {\n         ty::ty_bare_fn(..) => {\n             match tcx.map.find(main_id) {\n                 Some(ast_map::NodeItem(it)) => {\n@@ -410,7 +410,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                      start_span: Span) {\n     let tcx = ccx.tcx;\n     let start_t = ty::node_id_to_type(tcx, start_id);\n-    match ty::get(start_t).sty {\n+    match start_t.sty {\n         ty::ty_bare_fn(_) => {\n             match tcx.map.find(start_id) {\n                 Some(ast_map::NodeItem(it)) => {"}, {"sha": "b20ab0b05488025e6c685ba59772c6214f9de67a", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -199,7 +199,7 @@ use arena::Arena;\n use middle::resolve_lifetime as rl;\n use middle::subst;\n use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -725,11 +725,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for an instance of `ty` appearing\n     /// in a context with ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n-                               ty: ty::t,\n+                               ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n \n-        match ty::get(ty).sty {\n+        match ty.sty {\n             ty::ty_bool |\n             ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) |\n             ty::ty_float(_) | ty::ty_str => {\n@@ -854,9 +854,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,\n                                    def_id: ast::DefId,\n-                                   type_param_defs: &[ty::TypeParameterDef],\n+                                   type_param_defs: &[ty::TypeParameterDef<'tcx>],\n                                    region_param_defs: &[ty::RegionParameterDef],\n-                                   substs: &subst::Substs,\n+                                   substs: &subst::Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={})\", def_id);\n \n@@ -882,7 +882,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n-                                sig: &ty::FnSig,\n+                                sig: &ty::FnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n         for &input in sig.inputs.iter() {\n@@ -929,7 +929,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a mutability-type pair\n     /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_mt(&mut self,\n-                               mt: &ty::mt,\n+                               mt: &ty::mt<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {\n             ast::MutMutable => {"}, {"sha": "76055372a61491ca7dbe612008bbabaf24fe5f1e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 156, "deletions": 155, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -16,7 +16,7 @@ use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{ReEarlyBound, BrFresh, ctxt};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region, ReEmpty};\n use middle::ty::{ReSkolemized, ReVar, BrEnv};\n-use middle::ty::{mt, t, ParamTy};\n+use middle::ty::{mt, Ty, ParamTy};\n use middle::ty::{ty_bool, ty_char, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n@@ -37,13 +37,13 @@ use syntax::{ast, ast_util};\n use syntax::owned_slice::OwnedSlice;\n \n /// Produces a string suitable for debugging output.\n-pub trait Repr for Sized? {\n-    fn repr(&self, tcx: &ctxt) -> String;\n+pub trait Repr<'tcx> for Sized? {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String;\n }\n \n /// Produces a string suitable for showing to the user.\n-pub trait UserString {\n-    fn user_string(&self, tcx: &ctxt) -> String;\n+pub trait UserString<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String;\n }\n \n pub fn note_and_explain_region(cx: &ctxt,\n@@ -231,7 +231,7 @@ pub fn mutability_to_string(m: ast::Mutability) -> String {\n     }\n }\n \n-pub fn mt_to_string(cx: &ctxt, m: &mt) -> String {\n+pub fn mt_to_string<'tcx>(cx: &ctxt<'tcx>, m: &mt<'tcx>) -> String {\n     format!(\"{}{}\",\n         mutability_to_string(m.mutbl),\n         ty_to_string(cx, m.ty))\n@@ -251,21 +251,22 @@ pub fn vec_map_to_string<T>(ts: &[T], f: |t: &T| -> String) -> String {\n     format!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n-pub fn fn_sig_to_string(cx: &ctxt, typ: &ty::FnSig) -> String {\n+pub fn fn_sig_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::FnSig<'tcx>) -> String {\n     format!(\"fn{} -> {}\", typ.inputs.repr(cx), typ.output.repr(cx))\n }\n \n-pub fn trait_ref_to_string(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n+pub fn trait_ref_to_string<'tcx>(cx: &ctxt<'tcx>,\n+                                 trait_ref: &ty::TraitRef<'tcx>) -> String {\n     trait_ref.user_string(cx).to_string()\n }\n \n-pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n-    fn bare_fn_to_string(cx: &ctxt,\n-                         fn_style: ast::FnStyle,\n-                         abi: abi::Abi,\n-                         ident: Option<ast::Ident>,\n-                         sig: &ty::FnSig)\n-                         -> String {\n+pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n+    fn bare_fn_to_string<'tcx>(cx: &ctxt<'tcx>,\n+                               fn_style: ast::FnStyle,\n+                               abi: abi::Abi,\n+                               ident: Option<ast::Ident>,\n+                               sig: &ty::FnSig<'tcx>)\n+                               -> String {\n         let mut s = String::new();\n         match fn_style {\n             ast::NormalFn => {}\n@@ -294,7 +295,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n         s\n     }\n \n-    fn closure_to_string(cx: &ctxt, cty: &ty::ClosureTy) -> String {\n+    fn closure_to_string<'tcx>(cx: &ctxt<'tcx>, cty: &ty::ClosureTy<'tcx>) -> String {\n         let mut s = String::new();\n \n         match cty.store {\n@@ -334,12 +335,12 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n         s\n     }\n \n-    fn push_sig_to_string(cx: &ctxt,\n-                       s: &mut String,\n-                       bra: char,\n-                       ket: char,\n-                       sig: &ty::FnSig,\n-                       bounds: &str) {\n+    fn push_sig_to_string<'tcx>(cx: &ctxt<'tcx>,\n+                                s: &mut String,\n+                                bra: char,\n+                                ket: char,\n+                                sig: &ty::FnSig<'tcx>,\n+                                bounds: &str) {\n         s.push(bra);\n         let strs = sig.inputs\n             .iter()\n@@ -382,7 +383,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n     }\n \n     // pretty print the structural type representation:\n-    match ty::get(typ).sty {\n+    match typ.sty {\n         ty_bool => \"bool\".to_string(),\n         ty_char => \"char\".to_string(),\n         ty_int(t) => ast_util::int_ty_to_string(t, None).to_string(),\n@@ -476,11 +477,11 @@ pub fn explicit_self_category_to_str(category: &ty::ExplicitSelfCategory)\n     }\n }\n \n-pub fn parameterized(cx: &ctxt,\n-                     base: &str,\n-                     substs: &subst::Substs,\n-                     generics: &ty::Generics)\n-                     -> String\n+pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n+                           base: &str,\n+                           substs: &subst::Substs<'tcx>,\n+                           generics: &ty::Generics<'tcx>)\n+                           -> String\n {\n     if cx.sess.verbose() {\n         if substs.is_noop() {\n@@ -539,102 +540,102 @@ pub fn parameterized(cx: &ctxt,\n     }\n }\n \n-pub fn ty_to_short_str(cx: &ctxt, typ: t) -> String {\n+pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n     let mut s = typ.repr(cx).to_string();\n     if s.len() >= 32u {\n         s = s.as_slice().slice(0u, 32u).to_string();\n     }\n     return s;\n }\n \n-impl<T:Repr> Repr for Option<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Option<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match self {\n             &None => \"None\".to_string(),\n             &Some(ref t) => t.repr(tcx),\n         }\n     }\n }\n \n-impl<T:Repr> Repr for P<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for P<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         (*self).repr(tcx)\n     }\n }\n \n-impl<T:Repr,U:Repr> Repr for Result<T,U> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx,T:Repr<'tcx>,U:Repr<'tcx>> Repr<'tcx> for Result<T,U> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match self {\n             &Ok(ref t) => t.repr(tcx),\n             &Err(ref u) => format!(\"Err({})\", u.repr(tcx))\n         }\n     }\n }\n \n-impl Repr for () {\n+impl<'tcx> Repr<'tcx> for () {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         \"()\".to_string()\n     }\n }\n \n-impl<'a, Sized? T:Repr> Repr for &'a T {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'a, 'tcx, Sized? T:Repr<'tcx>> Repr<'tcx> for &'a T {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         Repr::repr(*self, tcx)\n     }\n }\n \n-impl<T:Repr> Repr for Rc<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Rc<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         (&**self).repr(tcx)\n     }\n }\n \n-impl<T:Repr> Repr for Box<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Box<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         (&**self).repr(tcx)\n     }\n }\n \n-fn repr_vec<T:Repr>(tcx: &ctxt, v: &[T]) -> String {\n+fn repr_vec<'tcx, T:Repr<'tcx>>(tcx: &ctxt<'tcx>, v: &[T]) -> String {\n     vec_map_to_string(v, |t| t.repr(tcx))\n }\n \n-impl<T:Repr> Repr for [T] {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         repr_vec(tcx, self)\n     }\n }\n \n-impl<T:Repr> Repr for OwnedSlice<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         repr_vec(tcx, self.as_slice())\n     }\n }\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n-impl<T:Repr> Repr for Vec<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         repr_vec(tcx, self.as_slice())\n     }\n }\n \n-impl<T:UserString> UserString for Vec<T> {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:UserString<'tcx>> UserString<'tcx> for Vec<T> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         let strs: Vec<String> =\n             self.iter().map(|t| t.user_string(tcx)).collect();\n         strs.connect(\", \")\n     }\n }\n \n-impl Repr for def::Def {\n+impl<'tcx> Repr<'tcx> for def::Def {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ty::TypeParameterDef {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::TypeParameterDef<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"TypeParameterDef({}, {}, {}/{})\",\n                 self.def_id,\n                 self.bounds.repr(tcx),\n@@ -643,7 +644,7 @@ impl Repr for ty::TypeParameterDef {\n     }\n }\n \n-impl Repr for ty::RegionParameterDef {\n+impl<'tcx> Repr<'tcx> for ty::RegionParameterDef {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"RegionParameterDef(name={}, def_id={}, bounds={})\",\n                 token::get_name(self.name),\n@@ -652,28 +653,28 @@ impl Repr for ty::RegionParameterDef {\n     }\n }\n \n-impl Repr for ty::t {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        ty_to_string(tcx, *self)\n+impl<'tcx> Repr<'tcx> for ty::TyS<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        ty_to_string(tcx, self)\n     }\n }\n \n-impl Repr for ty::mt {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::mt<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         mt_to_string(tcx, self)\n     }\n }\n \n-impl Repr for subst::Substs {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for subst::Substs<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"Substs[types={}, regions={}]\",\n                        self.types.repr(tcx),\n                        self.regions.repr(tcx))\n     }\n }\n \n-impl<T:Repr> Repr for subst::VecPerParamSpace<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for subst::VecPerParamSpace<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"[{};{};{};{}]\",\n                 self.get_slice(subst::TypeSpace).repr(tcx),\n                 self.get_slice(subst::SelfSpace).repr(tcx),\n@@ -682,13 +683,13 @@ impl<T:Repr> Repr for subst::VecPerParamSpace<T> {\n     }\n }\n \n-impl Repr for ty::ItemSubsts {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::ItemSubsts<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"ItemSubsts({})\", self.substs.repr(tcx))\n     }\n }\n \n-impl Repr for subst::RegionSubsts {\n+impl<'tcx> Repr<'tcx> for subst::RegionSubsts {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             subst::ErasedRegions => \"erased\".to_string(),\n@@ -697,7 +698,7 @@ impl Repr for subst::RegionSubsts {\n     }\n }\n \n-impl Repr for ty::BuiltinBounds {\n+impl<'tcx> Repr<'tcx> for ty::BuiltinBounds {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         let mut res = Vec::new();\n         for b in self.iter() {\n@@ -712,14 +713,14 @@ impl Repr for ty::BuiltinBounds {\n     }\n }\n \n-impl Repr for ty::ExistentialBounds {\n+impl<'tcx> Repr<'tcx> for ty::ExistentialBounds {\n     fn repr(&self, tcx: &ctxt) -> String {\n         self.user_string(tcx)\n     }\n }\n \n-impl Repr for ty::ParamBounds {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::ParamBounds<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut res = Vec::new();\n         res.push(self.builtin_bounds.repr(tcx));\n         for t in self.trait_bounds.iter() {\n@@ -729,8 +730,8 @@ impl Repr for ty::ParamBounds {\n     }\n }\n \n-impl Repr for ty::TraitRef {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         // when printing out the debug representation, we don't need\n         // to enumerate the `for<...>` etc because the debruijn index\n         // tells you everything you need to know.\n@@ -742,16 +743,16 @@ impl Repr for ty::TraitRef {\n     }\n }\n \n-impl Repr for ty::TraitDef {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::TraitDef<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"TraitDef(generics={}, bounds={}, trait_ref={})\",\n                 self.generics.repr(tcx),\n                 self.bounds.repr(tcx),\n                 self.trait_ref.repr(tcx))\n     }\n }\n \n-impl Repr for ast::TraitItem {\n+impl<'tcx> Repr<'tcx> for ast::TraitItem {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         match *self {\n             ast::RequiredMethod(ref data) => format!(\"RequiredMethod({}, id={})\",\n@@ -764,57 +765,57 @@ impl Repr for ast::TraitItem {\n     }\n }\n \n-impl Repr for ast::Expr {\n+impl<'tcx> Repr<'tcx> for ast::Expr {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"expr({}: {})\", self.id, pprust::expr_to_string(self))\n     }\n }\n \n-impl Repr for ast::Path {\n+impl<'tcx> Repr<'tcx> for ast::Path {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"path({})\", pprust::path_to_string(self))\n     }\n }\n \n-impl UserString for ast::Path {\n+impl<'tcx> UserString<'tcx> for ast::Path {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         pprust::path_to_string(self)\n     }\n }\n \n-impl Repr for ast::Ty {\n+impl<'tcx> Repr<'tcx> for ast::Ty {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"type({})\", pprust::ty_to_string(self))\n     }\n }\n \n-impl Repr for ast::Item {\n+impl<'tcx> Repr<'tcx> for ast::Item {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"item({})\", tcx.map.node_to_string(self.id))\n     }\n }\n \n-impl Repr for ast::Lifetime {\n+impl<'tcx> Repr<'tcx> for ast::Lifetime {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"lifetime({}: {})\", self.id, pprust::lifetime_to_string(self))\n     }\n }\n \n-impl Repr for ast::Stmt {\n+impl<'tcx> Repr<'tcx> for ast::Stmt {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"stmt({}: {})\",\n                 ast_util::stmt_id(self),\n                 pprust::stmt_to_string(self))\n     }\n }\n \n-impl Repr for ast::Pat {\n+impl<'tcx> Repr<'tcx> for ast::Pat {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"pat({}: {})\", self.id, pprust::pat_to_string(self))\n     }\n }\n \n-impl Repr for ty::BoundRegion {\n+impl<'tcx> Repr<'tcx> for ty::BoundRegion {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             ty::BrAnon(id) => format!(\"BrAnon({})\", id),\n@@ -827,7 +828,7 @@ impl Repr for ty::BoundRegion {\n     }\n }\n \n-impl Repr for ty::Region {\n+impl<'tcx> Repr<'tcx> for ty::Region {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             ty::ReEarlyBound(id, space, index, name) => {\n@@ -869,21 +870,21 @@ impl Repr for ty::Region {\n     }\n }\n \n-impl UserString for ty::Region {\n+impl<'tcx> UserString<'tcx> for ty::Region {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         region_to_string(tcx, \"\", false, *self)\n     }\n }\n \n-impl Repr for ty::FreeRegion {\n+impl<'tcx> Repr<'tcx> for ty::FreeRegion {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"ReFree({}, {})\",\n                 self.scope_id,\n                 self.bound_region.repr(tcx))\n     }\n }\n \n-impl Repr for ast::DefId {\n+impl<'tcx> Repr<'tcx> for ast::DefId {\n     fn repr(&self, tcx: &ctxt) -> String {\n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n@@ -908,31 +909,31 @@ impl Repr for ast::DefId {\n     }\n }\n \n-impl Repr for ty::Polytype {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::Polytype<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"Polytype {{generics: {}, ty: {}}}\",\n                 self.generics.repr(tcx),\n                 self.ty.repr(tcx))\n     }\n }\n \n-impl Repr for ty::Generics {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::Generics<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"Generics(types: {}, regions: {})\",\n                 self.types.repr(tcx),\n                 self.regions.repr(tcx))\n     }\n }\n \n-impl Repr for ty::GenericBounds {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::GenericBounds<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"GenericBounds(types: {}, regions: {})\",\n                 self.types.repr(tcx),\n                 self.regions.repr(tcx))\n     }\n }\n \n-impl Repr for ty::ItemVariances {\n+impl<'tcx> Repr<'tcx> for ty::ItemVariances {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"ItemVariances(types={}, \\\n                 regions={})\",\n@@ -941,7 +942,7 @@ impl Repr for ty::ItemVariances {\n     }\n }\n \n-impl Repr for ty::Variance {\n+impl<'tcx> Repr<'tcx> for ty::Variance {\n     fn repr(&self, _: &ctxt) -> String {\n         // The first `.to_string()` returns a &'static str (it is not an implementation\n         // of the ToString trait). Because of that, we need to call `.to_string()` again\n@@ -951,8 +952,8 @@ impl Repr for ty::Variance {\n     }\n }\n \n-impl Repr for ty::Method {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::Method<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"method(name: {}, generics: {}, fty: {}, \\\n                  explicit_self: {}, vis: {}, def_id: {})\",\n                 self.name.repr(tcx),\n@@ -964,53 +965,53 @@ impl Repr for ty::Method {\n     }\n }\n \n-impl Repr for ast::Name {\n+impl<'tcx> Repr<'tcx> for ast::Name {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         token::get_name(*self).get().to_string()\n     }\n }\n \n-impl UserString for ast::Name {\n+impl<'tcx> UserString<'tcx> for ast::Name {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         token::get_name(*self).get().to_string()\n     }\n }\n \n-impl Repr for ast::Ident {\n+impl<'tcx> Repr<'tcx> for ast::Ident {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         token::get_ident(*self).get().to_string()\n     }\n }\n \n-impl Repr for ast::ExplicitSelf_ {\n+impl<'tcx> Repr<'tcx> for ast::ExplicitSelf_ {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ast::Visibility {\n+impl<'tcx> Repr<'tcx> for ast::Visibility {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ty::BareFnTy {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::BareFnTy<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"BareFnTy {{fn_style: {}, abi: {}, sig: {}}}\",\n                 self.fn_style,\n                 self.abi.to_string(),\n                 self.sig.repr(tcx))\n     }\n }\n \n-impl Repr for ty::FnSig {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::FnSig<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         fn_sig_to_string(tcx, self)\n     }\n }\n \n-impl Repr for ty::FnOutput {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::FnOutput<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n             ty::FnConverging(ty) =>\n                 format!(\"FnConverging({0})\", ty.repr(tcx)),\n@@ -1020,17 +1021,17 @@ impl Repr for ty::FnOutput {\n     }\n }\n \n-impl Repr for typeck::MethodCallee {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for typeck::MethodCallee<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"MethodCallee {{origin: {}, ty: {}, {}}}\",\n                 self.origin.repr(tcx),\n                 self.ty.repr(tcx),\n                 self.substs.repr(tcx))\n     }\n }\n \n-impl Repr for typeck::MethodOrigin {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for typeck::MethodOrigin<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match self {\n             &typeck::MethodStatic(def_id) => {\n                 format!(\"MethodStatic({})\", def_id.repr(tcx))\n@@ -1048,36 +1049,36 @@ impl Repr for typeck::MethodOrigin {\n     }\n }\n \n-impl Repr for typeck::MethodParam {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for typeck::MethodParam<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"MethodParam({},{})\",\n                 self.trait_ref.repr(tcx),\n                 self.method_num)\n     }\n }\n \n-impl Repr for typeck::MethodObject {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for typeck::MethodObject<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"MethodObject({},{},{})\",\n                 self.trait_ref.repr(tcx),\n                 self.method_num,\n                 self.real_index)\n     }\n }\n \n-impl Repr for ty::TraitStore {\n+impl<'tcx> Repr<'tcx> for ty::TraitStore {\n     fn repr(&self, tcx: &ctxt) -> String {\n         trait_store_to_string(tcx, *self)\n     }\n }\n \n-impl Repr for ty::BuiltinBound {\n+impl<'tcx> Repr<'tcx> for ty::BuiltinBound {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl UserString for ty::BuiltinBound {\n+impl<'tcx> UserString<'tcx> for ty::BuiltinBound {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         match *self {\n             ty::BoundSend => \"Send\".to_string(),\n@@ -1088,21 +1089,21 @@ impl UserString for ty::BuiltinBound {\n     }\n }\n \n-impl Repr for Span {\n+impl<'tcx> Repr<'tcx> for Span {\n     fn repr(&self, tcx: &ctxt) -> String {\n         tcx.sess.codemap().span_to_string(*self).to_string()\n     }\n }\n \n-impl<A:UserString> UserString for Rc<A> {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl<'tcx, A:UserString<'tcx>> UserString<'tcx> for Rc<A> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         let this: &A = &**self;\n         this.user_string(tcx)\n     }\n }\n \n-impl UserString for ty::ParamBounds {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl<'tcx> UserString<'tcx> for ty::ParamBounds<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut result = Vec::new();\n         let s = self.builtin_bounds.user_string(tcx);\n         if !s.is_empty() {\n@@ -1115,7 +1116,7 @@ impl UserString for ty::ParamBounds {\n     }\n }\n \n-impl UserString for ty::ExistentialBounds {\n+impl<'tcx> UserString<'tcx> for ty::ExistentialBounds {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         if self.builtin_bounds.contains(&ty::BoundSend) &&\n             self.region_bound == ty::ReStatic\n@@ -1138,7 +1139,7 @@ impl UserString for ty::ExistentialBounds {\n     }\n }\n \n-impl UserString for ty::BuiltinBounds {\n+impl<'tcx> UserString<'tcx> for ty::BuiltinBounds {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         self.iter()\n             .map(|bb| bb.user_string(tcx))\n@@ -1148,8 +1149,8 @@ impl UserString for ty::BuiltinBounds {\n     }\n }\n \n-impl UserString for ty::TraitRef {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         // Replace any anonymous late-bound regions with named\n         // variants, using gensym'd identifiers, so that we can\n         // clearly differentiate between named and unnamed regions in\n@@ -1188,31 +1189,31 @@ impl UserString for ty::TraitRef {\n     }\n }\n \n-impl UserString for ty::t {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl<'tcx> UserString<'tcx> for Ty<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         ty_to_string(tcx, *self)\n     }\n }\n \n-impl UserString for ast::Ident {\n+impl<'tcx> UserString<'tcx> for ast::Ident {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         token::get_name(self.name).get().to_string()\n     }\n }\n \n-impl Repr for abi::Abi {\n+impl<'tcx> Repr<'tcx> for abi::Abi {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         self.to_string()\n     }\n }\n \n-impl UserString for abi::Abi {\n+impl<'tcx> UserString<'tcx> for abi::Abi {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         self.to_string()\n     }\n }\n \n-impl Repr for ty::UpvarId {\n+impl<'tcx> Repr<'tcx> for ty::UpvarId {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"UpvarId({};`{}`;{})\",\n                 self.var_id,\n@@ -1221,82 +1222,82 @@ impl Repr for ty::UpvarId {\n     }\n }\n \n-impl Repr for ast::Mutability {\n+impl<'tcx> Repr<'tcx> for ast::Mutability {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ty::BorrowKind {\n+impl<'tcx> Repr<'tcx> for ty::BorrowKind {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ty::UpvarBorrow {\n+impl<'tcx> Repr<'tcx> for ty::UpvarBorrow {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"UpvarBorrow({}, {})\",\n                 self.kind.repr(tcx),\n                 self.region.repr(tcx))\n     }\n }\n \n-impl Repr for ty::IntVid {\n+impl<'tcx> Repr<'tcx> for ty::IntVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", self)\n     }\n }\n \n-impl Repr for ty::FloatVid {\n+impl<'tcx> Repr<'tcx> for ty::FloatVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", self)\n     }\n }\n \n-impl Repr for ty::RegionVid {\n+impl<'tcx> Repr<'tcx> for ty::RegionVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", self)\n     }\n }\n \n-impl Repr for ty::TyVid {\n+impl<'tcx> Repr<'tcx> for ty::TyVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", self)\n     }\n }\n \n-impl Repr for ty::IntVarValue {\n+impl<'tcx> Repr<'tcx> for ty::IntVarValue {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ast::IntTy {\n+impl<'tcx> Repr<'tcx> for ast::IntTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ast::UintTy {\n+impl<'tcx> Repr<'tcx> for ast::UintTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ast::FloatTy {\n+impl<'tcx> Repr<'tcx> for ast::FloatTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ty::ExplicitSelfCategory {\n+impl<'tcx> Repr<'tcx> for ty::ExplicitSelfCategory {\n     fn repr(&self, _: &ctxt) -> String {\n         explicit_self_category_to_str(self).to_string()\n     }\n }\n \n \n-impl Repr for regionmanip::WfConstraint {\n+impl<'tcx> Repr<'tcx> for regionmanip::WfConstraint<'tcx> {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             regionmanip::RegionSubRegionConstraint(_, r_a, r_b) => {\n@@ -1314,7 +1315,7 @@ impl Repr for regionmanip::WfConstraint {\n     }\n }\n \n-impl UserString for ParamTy {\n+impl<'tcx> UserString<'tcx> for ParamTy {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         let id = self.idx;\n         let did = self.def_id;\n@@ -1329,22 +1330,22 @@ impl UserString for ParamTy {\n     }\n }\n \n-impl Repr for ParamTy {\n+impl<'tcx> Repr<'tcx> for ParamTy {\n     fn repr(&self, tcx: &ctxt) -> String {\n         let ident = self.user_string(tcx);\n         format!(\"{}/{}.{}\", ident, self.space, self.idx)\n     }\n }\n \n-impl<A:Repr,B:Repr> Repr for (A,B) {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, A:Repr<'tcx>, B:Repr<'tcx>> Repr<'tcx> for (A,B) {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let &(ref a, ref b) = self;\n         format!(\"({},{})\", a.repr(tcx), b.repr(tcx))\n     }\n }\n \n-impl<T:Repr> Repr for ty::Binder<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"Binder({})\", self.value.repr(tcx))\n     }\n }"}, {"sha": "d27a338b308c70babc25b0ea2ee238b073eed771", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -22,7 +22,7 @@ use metadata::common::LinkMeta;\n use metadata::{encoder, cstore, filesearch, csearch, creader};\n use trans::context::CrateContext;\n use trans::common::gensym_name;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::common::time;\n use util::ppaux;\n use util::sha2::{Digest, Sha256};\n@@ -196,11 +196,11 @@ fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n \n \n // This calculates STH for a symbol, as defined above\n-fn symbol_hash(tcx: &ty::ctxt,\n-               symbol_hasher: &mut Sha256,\n-               t: ty::t,\n-               link_meta: &LinkMeta)\n-               -> String {\n+fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                     symbol_hasher: &mut Sha256,\n+                     t: Ty<'tcx>,\n+                     link_meta: &LinkMeta)\n+                     -> String {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -219,7 +219,7 @@ fn symbol_hash(tcx: &ty::ctxt,\n     hash\n }\n \n-fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> String {\n+fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> String {\n     match ccx.type_hashcodes().borrow().get(&t) {\n         Some(h) => return h.to_string(),\n         None => {}\n@@ -320,8 +320,8 @@ pub fn exported_name(path: PathElems, hash: &str) -> String {\n     mangle(path, Some(hash))\n }\n \n-pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n-                            t: ty::t, id: ast::NodeId) -> String {\n+pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathElems,\n+                                      t: Ty<'tcx>, id: ast::NodeId) -> String {\n     let mut hash = get_symbol_hash(ccx, t);\n \n     // Paths can be completely identical for different nodes,\n@@ -345,9 +345,9 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n     exported_name(path, hash.as_slice())\n }\n \n-pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n-                                            t: ty::t,\n-                                            name: &str) -> String {\n+pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                      t: Ty<'tcx>,\n+                                                      name: &str) -> String {\n     let s = ppaux::ty_to_string(ccx.tcx(), t);\n     let path = [PathName(token::intern(s.as_slice())),\n                 gensym_name(name)];"}, {"sha": "98cf779fcd2a28fc8dfa35b4bce70fc6f62f2d7d", "filename": "src/librustc_trans/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -358,7 +358,7 @@ pub struct CrateAnalysis<'tcx> {\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                                          ast_map: ast_map::Map<'tcx>,\n-                                         type_arena: &'tcx TypedArena<ty::t_box_>,\n+                                         type_arena: &'tcx TypedArena<ty::TyS<'tcx>>,\n                                          name: String) -> CrateAnalysis<'tcx> {\n     let time_passes = sess.time_passes();\n     let krate = ast_map.krate();"}, {"sha": "aa6ac6564e205a4613a4e0a0f1cb44d8334160d4", "filename": "src/librustc_trans/driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdriver%2Fpretty.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -98,7 +98,7 @@ impl PpSourceMode {\n     fn call_with_pp_support<'tcx, A, B>(&self,\n                                         sess: Session,\n                                         ast_map: Option<ast_map::Map<'tcx>>,\n-                                        type_arena: &'tcx TypedArena<ty::t_box_>,\n+                                        type_arena: &'tcx TypedArena<ty::TyS<'tcx>>,\n                                         id: String,\n                                         payload: B,\n                                         f: |&PrinterSupport, B| -> A) -> A {"}, {"sha": "2591051e9b90a23e808f6f1b488bbe71ffbfe1f7", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -31,7 +31,7 @@ use driver::driver::CrateAnalysis;\n use session::Session;\n \n use middle::def;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck;\n \n use std::cell::Cell;\n@@ -1300,9 +1300,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex);\n-                let t_box = ty::get(t);\n-                match t_box.sty {\n+                match ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for f in fields.iter() {\n@@ -1328,9 +1326,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n                 self.visit_expr(&**sub_ex);\n \n-                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex);\n-                let t_box = ty::get(t);\n-                match t_box.sty {\n+                match ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty {\n                     ty::ty_struct(def_id, _) => {\n                         let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n                         for (i, f) in fields.iter().enumerate() {"}, {"sha": "984c1f99720eae65a5d82ab36d3f9b45544a75c9", "filename": "src/librustc_trans/test.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftest.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -24,7 +24,7 @@ use middle::resolve_lifetime;\n use middle::stability;\n use middle::subst;\n use middle::subst::Subst;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer;\n use middle::typeck::infer::lub::Lub;\n@@ -215,60 +215,59 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         }\n     }\n \n-    pub fn make_subtype(&self, a: ty::t, b: ty::t) -> bool {\n+    pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match infer::mk_subty(self.infcx, true, infer::Misc(DUMMY_SP), a, b) {\n             Ok(_) => true,\n             Err(ref e) => panic!(\"Encountered error: {}\",\n                                 ty::type_err_to_str(self.infcx.tcx, e))\n         }\n     }\n \n-    pub fn is_subtype(&self, a: ty::t, b: ty::t) -> bool {\n+    pub fn is_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match infer::can_mk_subty(self.infcx, a, b) {\n             Ok(_) => true,\n             Err(_) => false\n         }\n     }\n \n-    pub fn assert_subtype(&self, a: ty::t, b: ty::t) {\n+    pub fn assert_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) {\n         if !self.is_subtype(a, b) {\n             panic!(\"{} is not a subtype of {}, but it should be\",\n                   self.ty_to_string(a),\n                   self.ty_to_string(b));\n         }\n     }\n \n-    pub fn assert_eq(&self, a: ty::t, b: ty::t) {\n+    pub fn assert_eq(&self, a: Ty<'tcx>, b: Ty<'tcx>) {\n         self.assert_subtype(a, b);\n         self.assert_subtype(b, a);\n     }\n \n-    pub fn ty_to_string(&self, a: ty::t) -> String {\n+    pub fn ty_to_string(&self, a: Ty<'tcx>) -> String {\n         ty_to_string(self.infcx.tcx, a)\n     }\n \n     pub fn t_fn(&self,\n-                input_tys: &[ty::t],\n-                output_ty: ty::t)\n-                -> ty::t\n+                input_tys: &[Ty<'tcx>],\n+                output_ty: Ty<'tcx>)\n+                -> Ty<'tcx>\n     {\n         ty::mk_ctor_fn(self.infcx.tcx, input_tys, output_ty)\n     }\n \n-    pub fn t_nil(&self) -> ty::t {\n+    pub fn t_nil(&self) -> Ty<'tcx> {\n         ty::mk_nil(self.infcx.tcx)\n     }\n \n-    pub fn t_pair(&self, ty1: ty::t, ty2: ty::t) -> ty::t\n-    {\n+    pub fn t_pair(&self, ty1: Ty<'tcx>, ty2: Ty<'tcx>) -> Ty<'tcx> {\n         ty::mk_tup(self.infcx.tcx, vec![ty1, ty2])\n     }\n \n     pub fn t_closure(&self,\n-                     input_tys: &[ty::t],\n-                     output_ty: ty::t,\n+                     input_tys: &[Ty<'tcx>],\n+                     output_ty: Ty<'tcx>,\n                      region_bound: ty::Region)\n-                     -> ty::t\n+                     -> Ty<'tcx>\n     {\n         ty::mk_closure(self.infcx.tcx, ty::ClosureTy {\n             fn_style: ast::NormalFn,\n@@ -284,7 +283,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         })\n     }\n \n-    pub fn t_param(&self, space: subst::ParamSpace, index: uint) -> ty::t {\n+    pub fn t_param(&self, space: subst::ParamSpace, index: uint) -> Ty<'tcx> {\n         ty::mk_param(self.infcx.tcx, space, index, ast_util::local_def(ast::DUMMY_NODE_ID))\n     }\n \n@@ -302,23 +301,26 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         ty::ReLateBound(debruijn, ty::BrAnon(id))\n     }\n \n-    pub fn t_rptr(&self, r: ty::Region) -> ty::t {\n+    pub fn t_rptr(&self, r: ty::Region) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx, r, ty::mk_int())\n     }\n \n-    pub fn t_rptr_late_bound(&self, id: uint) -> ty::t {\n+    pub fn t_rptr_late_bound(&self, id: uint) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1)),\n                         ty::mk_int())\n     }\n \n-    pub fn t_rptr_late_bound_with_debruijn(&self, id: uint, debruijn: ty::DebruijnIndex) -> ty::t {\n+    pub fn t_rptr_late_bound_with_debruijn(&self,\n+                                           id: uint,\n+                                           debruijn: ty::DebruijnIndex)\n+                                           -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.re_late_bound_with_debruijn(id, debruijn),\n                         ty::mk_int())\n     }\n \n-    pub fn t_rptr_scope(&self, id: ast::NodeId) -> ty::t {\n+    pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx, ty::ReScope(id), ty::mk_int())\n     }\n \n@@ -327,15 +329,15 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                                    bound_region: ty::BrAnon(id)})\n     }\n \n-    pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> ty::t {\n+    pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx, self.re_free(nid, id), ty::mk_int())\n     }\n \n-    pub fn t_rptr_static(&self) -> ty::t {\n+    pub fn t_rptr_static(&self) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx, ty::ReStatic, ty::mk_int())\n     }\n \n-    pub fn dummy_type_trace(&self) -> infer::TypeTrace {\n+    pub fn dummy_type_trace(&self) -> infer::TypeTrace<'tcx> {\n         infer::TypeTrace::dummy()\n     }\n \n@@ -349,7 +351,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         Glb(self.infcx.combine_fields(true, trace))\n     }\n \n-    pub fn make_lub_ty(&self, t1: ty::t, t2: ty::t) -> ty::t {\n+    pub fn make_lub_ty(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> Ty<'tcx> {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => t,\n             Err(ref e) => panic!(\"unexpected error computing LUB: {}\",\n@@ -358,7 +360,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     /// Checks that `LUB(t1,t2) == t_lub`\n-    pub fn check_lub(&self, t1: ty::t, t2: ty::t, t_lub: ty::t) {\n+    pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n@@ -371,7 +373,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n-    pub fn check_glb(&self, t1: ty::t, t2: ty::t, t_glb: ty::t) {\n+    pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n         debug!(\"check_glb(t1={}, t2={}, t_glb={})\",\n                self.ty_to_string(t1),\n                self.ty_to_string(t2),"}, {"sha": "de406cff6e74124378a5cbce2f472bd0eefbf961", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -217,7 +217,7 @@ use trans::expr::{mod, Dest};\n use trans::tvec;\n use trans::type_of;\n use trans::debuginfo;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use session::config::FullDebugInfo;\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n@@ -248,16 +248,16 @@ impl<'a> ConstantExpr<'a> {\n \n // An option identifying a branch (either a literal, an enum variant or a range)\n #[deriving(Show)]\n-enum Opt<'a> {\n+enum Opt<'a, 'tcx> {\n     ConstantValue(ConstantExpr<'a>),\n     ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>),\n-    Variant(ty::Disr, Rc<adt::Repr>, ast::DefId),\n+    Variant(ty::Disr, Rc<adt::Repr<'tcx>>, ast::DefId),\n     SliceLengthEqual(uint),\n     SliceLengthGreaterOrEqual(/* prefix length */ uint, /* suffix length */ uint),\n }\n \n-impl<'a> Opt<'a> {\n-    fn eq(&self, other: &Opt<'a>, tcx: &ty::ctxt) -> bool {\n+impl<'a, 'tcx> Opt<'a, 'tcx> {\n+    fn eq(&self, other: &Opt<'a, 'tcx>, tcx: &ty::ctxt<'tcx>) -> bool {\n         match (self, other) {\n             (&ConstantValue(a), &ConstantValue(b)) => a.eq(b, tcx),\n             (&ConstantRange(a1, a2), &ConstantRange(b1, b2)) => {\n@@ -274,7 +274,7 @@ impl<'a> Opt<'a> {\n         }\n     }\n \n-    fn trans<'blk, 'tcx>(&self, mut bcx: Block<'blk, 'tcx>) -> OptResult<'blk, 'tcx> {\n+    fn trans<'blk>(&self, mut bcx: Block<'blk, 'tcx>) -> OptResult<'blk, 'tcx> {\n         let _icx = push_ctxt(\"match::trans_opt\");\n         let ccx = bcx.ccx();\n         match *self {\n@@ -334,20 +334,20 @@ pub enum TransBindingMode {\n  * - `id` is the node id of the binding\n  * - `ty` is the Rust type of the binding */\n  #[deriving(Clone)]\n-pub struct BindingInfo {\n+pub struct BindingInfo<'tcx> {\n     pub llmatch: ValueRef,\n     pub trmode: TransBindingMode,\n     pub id: ast::NodeId,\n     pub span: Span,\n-    pub ty: ty::t,\n+    pub ty: Ty<'tcx>,\n }\n \n-type BindingsMap = FnvHashMap<Ident, BindingInfo>;\n+type BindingsMap<'tcx> = FnvHashMap<Ident, BindingInfo<'tcx>>;\n \n struct ArmData<'p, 'blk, 'tcx: 'blk> {\n     bodycx: Block<'blk, 'tcx>,\n     arm: &'p ast::Arm,\n-    bindings_map: BindingsMap\n+    bindings_map: BindingsMap<'tcx>\n }\n \n /**\n@@ -362,7 +362,7 @@ struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     bound_ptrs: Vec<(Ident, ValueRef)>,\n }\n \n-impl<'a, 'p, 'blk, 'tcx> Repr for Match<'a, 'p, 'blk, 'tcx> {\n+impl<'a, 'p, 'blk, 'tcx> Repr<'tcx> for Match<'a, 'p, 'blk, 'tcx> {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n@@ -564,7 +564,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n // on a set of enum variants or a literal.\n fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     m: &[Match<'a, 'p, 'blk, 'tcx>], col: uint)\n-                                    -> Vec<Opt<'p>> {\n+                                    -> Vec<Opt<'p, 'tcx>> {\n     let tcx = bcx.tcx();\n \n     let mut found: Vec<Opt> = vec![];\n@@ -608,7 +608,7 @@ struct ExtractedBlock<'blk, 'tcx: 'blk> {\n }\n \n fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    repr: &adt::Repr,\n+                                    repr: &adt::Repr<'tcx>,\n                                     disr_val: ty::Disr,\n                                     val: ValueRef)\n                                     -> ExtractedBlock<'blk, 'tcx> {\n@@ -620,7 +620,7 @@ fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n-fn match_datum(val: ValueRef, left_ty: ty::t) -> Datum<Lvalue> {\n+fn match_datum<'tcx>(val: ValueRef, left_ty: Ty<'tcx>) -> Datum<'tcx, Lvalue> {\n     /*!\n      * Helper for converting from the ValueRef that we pass around in\n      * the match code, which is always an lvalue, into a Datum. Eventually\n@@ -655,7 +655,7 @@ fn bind_subslice_pat(bcx: Block,\n }\n \n fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 left_ty: ty::t,\n+                                 left_ty: Ty,\n                                  before: uint,\n                                  after: uint,\n                                  val: ValueRef)\n@@ -790,12 +790,12 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               lhs: ValueRef,\n                               rhs: ValueRef,\n-                              rhs_t: ty::t)\n+                              rhs_t: Ty<'tcx>)\n                               -> Result<'blk, 'tcx> {\n     fn compare_str<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                lhs: ValueRef,\n                                rhs: ValueRef,\n-                               rhs_t: ty::t)\n+                               rhs_t: Ty<'tcx>)\n                                -> Result<'blk, 'tcx> {\n         let did = langcall(cx,\n                            None,\n@@ -811,10 +811,10 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         return Result::new(rs.bcx, rs.val);\n     }\n \n-    match ty::get(rhs_t).sty {\n-        ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+    match rhs_t.sty {\n+        ty::ty_rptr(_, mt) => match mt.ty.sty {\n             ty::ty_str => compare_str(cx, lhs, rhs, rhs_t),\n-            ty::ty_vec(ty, _) => match ty::get(ty).sty {\n+            ty::ty_vec(ty, _) => match ty.sty {\n                 ty::ty_uint(ast::TyU8) => {\n                     // NOTE: cast &[u8] to &str and abuse the str_eq lang item,\n                     // which calls memcmp().\n@@ -832,7 +832,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n }\n \n fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                               bindings_map: &BindingsMap,\n+                               bindings_map: &BindingsMap<'tcx>,\n                                cs: Option<cleanup::ScopeId>)\n                                -> Block<'blk, 'tcx> {\n     /*!\n@@ -889,7 +889,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      guard_expr: &ast::Expr,\n-                                     data: &ArmData,\n+                                     data: &ArmData<'p, 'blk, 'tcx>,\n                                      m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                      vals: &[ValueRef],\n                                      chk: &FailureHandler,\n@@ -1034,7 +1034,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     } else if any_uniq_pat(m, col) || any_region_pat(m, col) {\n         Some(vec!(Load(bcx, val)))\n     } else {\n-        match ty::get(left_ty).sty {\n+        match left_ty.sty {\n             ty::ty_vec(_, Some(n)) => {\n                 let args = extract_vec_elems(bcx, left_ty, n, 0, val);\n                 Some(args.vals)\n@@ -1272,7 +1272,7 @@ struct ReassignmentChecker {\n     reassigned: bool\n }\n \n-impl euv::Delegate for ReassignmentChecker {\n+impl<'tcx> euv::Delegate<'tcx> for ReassignmentChecker {\n     fn consume(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: euv::ConsumeMode) {}\n     fn consume_pat(&mut self, _: &ast::Pat, _: mc::cmt, _: euv::ConsumeMode) {}\n     fn borrow(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: ty::Region,\n@@ -1288,8 +1288,9 @@ impl euv::Delegate for ReassignmentChecker {\n     }\n }\n \n-fn create_bindings_map(bcx: Block, pat: &ast::Pat,\n-                      discr: &ast::Expr, body: &ast::Expr) -> BindingsMap {\n+fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n+                                   discr: &ast::Expr, body: &ast::Expr)\n+                                   -> BindingsMap<'tcx> {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n     // Note that we use the names because each binding will have many ids\n@@ -1482,7 +1483,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              pat: &ast::Pat,\n-                             arg: Datum<Rvalue>,\n+                             arg: Datum<'tcx, Rvalue>,\n                              arg_scope: cleanup::ScopeId)\n                              -> Block<'blk, 'tcx> {\n     /*!\n@@ -1560,7 +1561,7 @@ fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n                                     ident: &ast::Ident,\n                                     cleanup_scope: cleanup::ScopeId,\n                                     arg: A,\n-                                    populate: |A, Block<'blk, 'tcx>, ValueRef, ty::t|\n+                                    populate: |A, Block<'blk, 'tcx>, ValueRef, Ty<'tcx>|\n                                               -> Block<'blk, 'tcx>)\n                                     -> Block<'blk, 'tcx> {\n     let var_ty = node_id_type(bcx, p_id);"}, {"sha": "c5f66cf0c542ffbda014fa31bbf649ecb305d271", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 84, "deletions": 64, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -64,7 +64,7 @@ use trans::datum;\n use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty::Disr;\n use syntax::ast;\n use syntax::attr;\n@@ -76,7 +76,7 @@ type Hint = attr::ReprAttr;\n \n /// Representations.\n #[deriving(Eq, PartialEq, Show)]\n-pub enum Repr {\n+pub enum Repr<'tcx> {\n     /// C-like enums; basically an int.\n     CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n     /**\n@@ -86,7 +86,7 @@ pub enum Repr {\n      * avoid running the destructor too many times; this is included\n      * in the `Struct` if present.\n      */\n-    Univariant(Struct, bool),\n+    Univariant(Struct<'tcx>, bool),\n     /**\n      * General-case enums: for each case there is a struct, and they\n      * all start with a field for the discriminant.\n@@ -95,7 +95,7 @@ pub enum Repr {\n      * avoid running the destructor too many times; the last argument\n      * indicates whether such a flag is present.\n      */\n-    General(IntType, Vec<Struct>, bool),\n+    General(IntType, Vec<Struct<'tcx>>, bool),\n     /**\n      * Two cases distinguished by a nullable pointer: the case with discriminant\n      * `nndiscr` must have single field which is known to be nonnull due to its type.\n@@ -105,8 +105,8 @@ pub enum Repr {\n      */\n     RawNullablePointer {\n         nndiscr: Disr,\n-        nnty: ty::t,\n-        nullfields: Vec<ty::t>\n+        nnty: Ty<'tcx>,\n+        nullfields: Vec<Ty<'tcx>>\n     },\n     /**\n      * Two cases distinguished by a nullable pointer: the case with discriminant\n@@ -120,36 +120,38 @@ pub enum Repr {\n      * identity function.\n      */\n     StructWrappedNullablePointer {\n-        nonnull: Struct,\n+        nonnull: Struct<'tcx>,\n         nndiscr: Disr,\n         ptrfield: PointerField,\n-        nullfields: Vec<ty::t>,\n+        nullfields: Vec<Ty<'tcx>>,\n     }\n }\n \n /// For structs, and struct-like parts of anything fancier.\n #[deriving(Eq, PartialEq, Show)]\n-pub struct Struct {\n+pub struct Struct<'tcx> {\n     // If the struct is DST, then the size and alignment do not take into\n     // account the unsized fields of the struct.\n     pub size: u64,\n     pub align: u32,\n     pub sized: bool,\n     pub packed: bool,\n-    pub fields: Vec<ty::t>\n+    pub fields: Vec<Ty<'tcx>>\n }\n \n /**\n  * Convenience for `represent_type`.  There should probably be more or\n- * these, for places in trans where the `ty::t` isn't directly\n+ * these, for places in trans where the `Ty` isn't directly\n  * available.\n  */\n-pub fn represent_node(bcx: Block, node: ast::NodeId) -> Rc<Repr> {\n+pub fn represent_node<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  node: ast::NodeId) -> Rc<Repr<'tcx>> {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n /// Decides how to represent a given type.\n-pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n+pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                t: Ty<'tcx>) -> Rc<Repr<'tcx>> {\n     debug!(\"Representing: {}\", ty_to_string(cx.tcx(), t));\n     match cx.adt_reprs().borrow().get(&t) {\n         Some(repr) => return repr.clone(),\n@@ -162,10 +164,11 @@ pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n     repr\n }\n \n-fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n-    match ty::get(t).sty {\n+fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                     t: Ty<'tcx>) -> Repr<'tcx> {\n+    match t.sty {\n         ty::ty_tup(ref elems) => {\n-            return Univariant(mk_struct(cx, elems.as_slice(), false, t), false)\n+            Univariant(mk_struct(cx, elems.as_slice(), false, t), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -176,13 +179,12 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n \n-            return Univariant(mk_struct(cx, ftys.as_slice(), packed, t), dtor)\n+            Univariant(mk_struct(cx, ftys.as_slice(), packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _, ref substs) => {\n             let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs);\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            return Univariant(mk_struct(cx, upvar_types.as_slice(), false, t),\n-                              false)\n+            Univariant(mk_struct(cx, upvar_types.as_slice(), false, t), false)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n@@ -285,9 +287,9 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n }\n \n // this should probably all be in ty\n-struct Case {\n+struct Case<'tcx> {\n     discr: Disr,\n-    tys: Vec<ty::t>\n+    tys: Vec<Ty<'tcx>>\n }\n \n \n@@ -297,16 +299,16 @@ pub enum PointerField {\n     FatPointer(uint)\n }\n \n-impl Case {\n-    fn is_zerolen(&self, cx: &CrateContext, scapegoat: ty::t) -> bool {\n+impl<'tcx> Case<'tcx> {\n+    fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>) -> bool {\n         mk_struct(cx, self.tys.as_slice(), false, scapegoat).size == 0\n     }\n \n-    fn find_ptr(&self, cx: &CrateContext) -> Option<PointerField> {\n+    fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<PointerField> {\n         for (i, &ty) in self.tys.iter().enumerate() {\n-            match ty::get(ty).sty {\n+            match ty.sty {\n                 // &T/&mut T/Box<T> could either be a thin or fat pointer depending on T\n-                ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) => match ty::get(ty).sty {\n+                ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) => match ty.sty {\n                     // &[T] and &str are a pointer and length pair\n                     ty::ty_vec(_, None) | ty::ty_str => return Some(FatPointer(i)),\n \n@@ -336,7 +338,10 @@ impl Case {\n     }\n }\n \n-fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &subst::Substs) -> Vec<Case> {\n+fn get_cases<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                   def_id: ast::DefId,\n+                   substs: &subst::Substs<'tcx>)\n+                   -> Vec<Case<'tcx>> {\n     ty::enum_variants(tcx, def_id).iter().map(|vi| {\n         let arg_tys = vi.args.iter().map(|&raw_ty| {\n             raw_ty.subst(tcx, substs)\n@@ -345,7 +350,10 @@ fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &subst::Substs) -> Vec<\n     }).collect()\n }\n \n-fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool, scapegoat: ty::t) -> Struct {\n+fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                       tys: &[Ty<'tcx>], packed: bool,\n+                       scapegoat: Ty<'tcx>)\n+                       -> Struct<'tcx> {\n     let sized = tys.iter().all(|&ty| ty::type_is_sized(cx.tcx(), ty));\n     let lltys : Vec<Type> = if sized {\n         tys.iter()\n@@ -375,7 +383,9 @@ struct IntBounds {\n     uhi: u64\n }\n \n-fn mk_cenum(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> Repr {\n+fn mk_cenum<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                      hint: Hint, bounds: &IntBounds)\n+                      -> Repr<'tcx> {\n     let it = range_to_inttype(cx, hint, bounds);\n     match it {\n         attr::SignedInt(_) => CEnum(it, bounds.slo as Disr, bounds.shi as Disr),\n@@ -450,18 +460,19 @@ fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n     }\n }\n \n-pub fn ty_of_inttype(ity: IntType) -> ty::t {\n+// FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n+pub fn ty_of_inttype<'tcx>(ity: IntType) -> Ty<'tcx> {\n     match ity {\n         attr::SignedInt(t) => ty::mk_mach_int(t),\n         attr::UnsignedInt(t) => ty::mk_mach_uint(t)\n     }\n }\n \n // LLVM doesn't like types that don't fit in the address space\n-fn ensure_struct_fits_in_address_space(ccx: &CrateContext,\n-                                       fields: &[Type],\n-                                       packed: bool,\n-                                       scapegoat: ty::t) {\n+fn ensure_struct_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                 fields: &[Type],\n+                                                 packed: bool,\n+                                                 scapegoat: Ty<'tcx>) {\n     let mut offset = 0;\n     for &llty in fields.iter() {\n         // Invariant: offset < ccx.max_obj_size() <= 1<<61\n@@ -486,10 +497,10 @@ fn union_size_and_align(sts: &[Struct]) -> (machine::llsize, machine::llalign) {\n     (size, most_aligned.align)\n }\n \n-fn ensure_enum_fits_in_address_space(ccx: &CrateContext,\n-                                     discr: IntType,\n-                                     fields: &[Struct],\n-                                     scapegoat: ty::t) {\n+fn ensure_enum_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                               discr: IntType,\n+                                               fields: &[Struct],\n+                                               scapegoat: Ty<'tcx>) {\n     let discr_size = machine::llsize_of_alloc(ccx, ll_inttype(ccx, discr));\n     let (field_size, field_align) = union_size_and_align(fields);\n \n@@ -513,19 +524,22 @@ fn ensure_enum_fits_in_address_space(ccx: &CrateContext,\n  * and fill in the actual contents in a second pass to prevent\n  * unbounded recursion; see also the comments in `trans::type_of`.\n  */\n-pub fn type_of(cx: &CrateContext, r: &Repr) -> Type {\n+pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>) -> Type {\n     generic_type_of(cx, r, None, false, false)\n }\n // Pass dst=true if the type you are passing is a DST. Yes, we could figure\n // this out, but if you call this on an unsized type without realising it, you\n // are going to get the wrong type (it will not include the unsized parts of it).\n-pub fn sizing_type_of(cx: &CrateContext, r: &Repr, dst: bool) -> Type {\n+pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                r: &Repr<'tcx>, dst: bool) -> Type {\n     generic_type_of(cx, r, None, true, dst)\n }\n-pub fn incomplete_type_of(cx: &CrateContext, r: &Repr, name: &str) -> Type {\n+pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                    r: &Repr<'tcx>, name: &str) -> Type {\n     generic_type_of(cx, r, Some(name), false, false)\n }\n-pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n+pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                r: &Repr<'tcx>, llty: &mut Type) {\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n@@ -534,11 +548,11 @@ pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n     }\n }\n \n-fn generic_type_of(cx: &CrateContext,\n-                   r: &Repr,\n-                   name: Option<&str>,\n-                   sizing: bool,\n-                   dst: bool) -> Type {\n+fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                             r: &Repr<'tcx>,\n+                             name: Option<&str>,\n+                             sizing: bool,\n+                             dst: bool) -> Type {\n     match *r {\n         CEnum(ity, _, _) => ll_inttype(cx, ity),\n         RawNullablePointer { nnty, .. } => type_of::sizing_type_of(cx, nnty),\n@@ -596,7 +610,8 @@ fn generic_type_of(cx: &CrateContext,\n     }\n }\n \n-fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool, dst: bool) -> Vec<Type> {\n+fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, st: &Struct<'tcx>,\n+                             sizing: bool, dst: bool) -> Vec<Type> {\n     if sizing {\n         st.fields.iter().filter(|&ty| !dst || ty::type_is_sized(cx.tcx(), *ty))\n             .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n@@ -611,8 +626,9 @@ fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool, dst: bool) -> V\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_switch(bcx: Block, r: &Repr, scrutinee: ValueRef)\n-    -> (_match::BranchKind, Option<ValueRef>) {\n+pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                r: &Repr<'tcx>, scrutinee: ValueRef)\n+                                -> (_match::BranchKind, Option<ValueRef>) {\n     match *r {\n         CEnum(..) | General(..) |\n         RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n@@ -627,7 +643,8 @@ pub fn trans_switch(bcx: Block, r: &Repr, scrutinee: ValueRef)\n \n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr(bcx: Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n+pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n+                                   scrutinee: ValueRef, cast_to: Option<Type>)\n     -> ValueRef {\n     let signed;\n     let val;\n@@ -728,7 +745,8 @@ pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n  * Set the discriminant for a new value of the given case of the given\n  * representation.\n  */\n-pub fn trans_set_discr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr) {\n+pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n+                                   val: ValueRef, discr: Disr) {\n     match *r {\n         CEnum(ity, min, max) => {\n             assert_discr_in_range(ity, min, max, discr);\n@@ -806,8 +824,8 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr,\n-                       ix: uint) -> ValueRef {\n+pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n+                                   val: ValueRef, discr: Disr, ix: uint) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n@@ -845,8 +863,8 @@ pub fn trans_field_ptr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr,\n     }\n }\n \n-pub fn struct_field_ptr(bcx: Block, st: &Struct, val: ValueRef,\n-                        ix: uint, needs_cast: bool) -> ValueRef {\n+pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, val: ValueRef,\n+                                    ix: uint, needs_cast: bool) -> ValueRef {\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n@@ -860,8 +878,8 @@ pub fn struct_field_ptr(bcx: Block, st: &Struct, val: ValueRef,\n }\n \n pub fn fold_variants<'blk, 'tcx>(\n-        bcx: Block<'blk, 'tcx>, r: &Repr, value: ValueRef,\n-        f: |Block<'blk, 'tcx>, &Struct, ValueRef| -> Block<'blk, 'tcx>)\n+        bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>, value: ValueRef,\n+        f: |Block<'blk, 'tcx>, &Struct<'tcx>, ValueRef| -> Block<'blk, 'tcx>)\n         -> Block<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     match *r {\n@@ -900,7 +918,7 @@ pub fn fold_variants<'blk, 'tcx>(\n }\n \n /// Access the struct drop flag, if present.\n-pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr, val: ValueRef)\n+pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>, val: ValueRef)\n                                        -> datum::DatumBlock<'blk, 'tcx, datum::Expr> {\n     let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), ty::mk_bool());\n     match *r {\n@@ -949,8 +967,8 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr, val\n  * this could be changed in the future to avoid allocating unnecessary\n  * space after values of shorter-than-maximum cases.\n  */\n-pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n-                   vals: &[ValueRef]) -> ValueRef {\n+pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr: Disr,\n+                             vals: &[ValueRef]) -> ValueRef {\n     match *r {\n         CEnum(ity, min, max) => {\n             assert_eq!(vals.len(), 0);\n@@ -1004,7 +1022,8 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n /**\n  * Compute struct field offsets relative to struct begin.\n  */\n-fn compute_struct_field_offsets(ccx: &CrateContext, st: &Struct) -> Vec<u64> {\n+fn compute_struct_field_offsets<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                          st: &Struct<'tcx>) -> Vec<u64> {\n     let mut offsets = vec!();\n \n     let mut offset = 0;\n@@ -1031,8 +1050,9 @@ fn compute_struct_field_offsets(ccx: &CrateContext, st: &Struct) -> Vec<u64> {\n  * a two-element struct will locate it at offset 4, and accesses to it\n  * will read the wrong memory.\n  */\n-fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n-    -> Vec<ValueRef> {\n+fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                st: &Struct<'tcx>, vals: &[ValueRef])\n+                                -> Vec<ValueRef> {\n     assert_eq!(vals.len(), st.fields.len());\n \n     let target_offsets = compute_struct_field_offsets(ccx, st);"}, {"sha": "b3f64e3fd798c612a4a5ae1abad7be32834c2dd5", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 174, "deletions": 163, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -17,15 +17,14 @@\n //\n // Hopefully useful general knowledge about trans:\n //\n-//   * There's no way to find out the ty::t type of a ValueRef.  Doing so\n+//   * There's no way to find out the Ty type of a ValueRef.  Doing so\n //     would be \"trying to get the eggs out of an omelette\" (credit:\n //     pcwalton).  You can, instead, find out its TypeRef by calling val_ty,\n-//     but one TypeRef corresponds to many `ty::t`s; for instance, tup(int, int,\n+//     but one TypeRef corresponds to many `Ty`s; for instance, tup(int, int,\n //     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n \n #![allow(non_camel_case_types)]\n \n-pub use self::IsUnboxedClosureFlag::*;\n pub use self::ValueOrigin::*;\n pub use self::scalar_type::*;\n \n@@ -40,22 +39,23 @@ use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::subst;\n use middle::weak_lang_items;\n-use middle::subst::Subst;\n-use middle::ty;\n+use middle::subst::{Subst, Substs};\n+use middle::ty::{mod, Ty};\n use session::config::{mod, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use trans::_match;\n use trans::adt;\n use trans::build::*;\n use trans::builder::{Builder, noname};\n use trans::callee;\n-use trans::cleanup::{CleanupMethods, ScopeId};\n+use trans::cleanup::CleanupMethods;\n use trans::cleanup;\n+use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_uint, C_undef};\n use trans::common::{CrateContext, ExternMap, FunctionContext};\n-use trans::common::{NodeInfo, Result, SubstP};\n-use trans::common::{node_id_type, param_substs, return_type_is_void};\n+use trans::common::{NodeInfo, Result};\n+use trans::common::{node_id_type, return_type_is_void};\n use trans::common::{tydesc_info, type_is_immediate};\n use trans::common::{type_is_zero_size, val_ty};\n use trans::common;\n@@ -170,7 +170,7 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n \n // only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n-           ty: Type, output: ty::FnOutput) -> ValueRef {\n+               ty: Type, output: ty::FnOutput) -> ValueRef {\n \n     let llfn: ValueRef = name.with_c_str(|buf| {\n         unsafe {\n@@ -203,7 +203,7 @@ pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n pub fn decl_cdecl_fn(ccx: &CrateContext,\n                      name: &str,\n                      ty: Type,\n-                     output: ty::t) -> ValueRef {\n+                     output: Ty) -> ValueRef {\n     decl_fn(ccx, name, llvm::CCallConv, ty, ty::FnConverging(output))\n }\n \n@@ -213,7 +213,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n                      name: &str,\n                      cc: llvm::CallConv,\n                      ty: Type,\n-                     output: ty::t)\n+                     output: Ty)\n                      -> ValueRef {\n     match externs.get(name) {\n         Some(n) => return *n,\n@@ -224,7 +224,8 @@ pub fn get_extern_fn(ccx: &CrateContext,\n     f\n }\n \n-fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::DefId) -> ValueRef {\n+fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n+                                name: &str, did: ast::DefId) -> ValueRef {\n     match ccx.externs().borrow().get(name) {\n         Some(n) => return *n,\n         None => ()\n@@ -240,10 +241,10 @@ fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::De\n     f\n }\n \n-pub fn self_type_for_unboxed_closure(ccx: &CrateContext,\n+pub fn self_type_for_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      closure_id: ast::DefId,\n-                                     fn_ty: ty::t)\n-                                     -> ty::t {\n+                                     fn_ty: Ty<'tcx>)\n+                                     -> Ty<'tcx> {\n     let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n     let unboxed_closure = &(*unboxed_closures)[closure_id];\n     match unboxed_closure.kind {\n@@ -263,8 +264,9 @@ pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n     (*unboxed_closures)[closure_id].kind\n }\n \n-pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n-    let (inputs, output, abi, env) = match ty::get(fn_ty).sty {\n+pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                              fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n+    let (inputs, output, abi, env) = match fn_ty.sty {\n         ty::ty_bare_fn(ref f) => {\n             (f.sig.inputs.clone(), f.sig.output, f.abi, None)\n         }\n@@ -297,14 +299,15 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n     llfn\n }\n \n-pub fn decl_internal_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n+pub fn decl_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                       fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n     let llfn = decl_rust_fn(ccx, fn_ty, name);\n     llvm::SetLinkage(llfn, llvm::InternalLinkage);\n     llfn\n }\n \n-pub fn get_extern_const(ccx: &CrateContext, did: ast::DefId,\n-                        t: ty::t) -> ValueRef {\n+pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n+                                  t: Ty<'tcx>) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     let ty = type_of(ccx, t);\n     match ccx.externs().borrow_mut().get(&name) {\n@@ -335,15 +338,17 @@ pub fn get_extern_const(ccx: &CrateContext, did: ast::DefId,\n // Returns a pointer to the body for the box. The box may be an opaque\n // box. The result will be casted to the type of body_t, if it is statically\n // known.\n-pub fn at_box_body(bcx: Block, body_t: ty::t, boxptr: ValueRef) -> ValueRef {\n+pub fn at_box_body<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               body_t: Ty<'tcx>, boxptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"at_box_body\");\n     let ccx = bcx.ccx();\n     let ty = Type::at_box(ccx, type_of(ccx, body_t));\n     let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n     GEPi(bcx, boxptr, &[0u, abi::box_field_body])\n }\n \n-fn require_alloc_fn(bcx: Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n+fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                info_ty: Ty<'tcx>, it: LangItem) -> ast::DefId {\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n         Err(s) => {\n@@ -359,7 +364,7 @@ fn require_alloc_fn(bcx: Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n \n pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   llty_ptr: Type,\n-                                  info_ty: ty::t,\n+                                  info_ty: Ty<'tcx>,\n                                   size: ValueRef,\n                                   align: ValueRef)\n                                   -> Result<'blk, 'tcx> {\n@@ -374,7 +379,8 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n-pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: ty::t) -> Result<'blk, 'tcx> {\n+pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>)\n+                                       -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"malloc_raw_dyn_proc\");\n     let ccx = bcx.ccx();\n \n@@ -399,7 +405,8 @@ pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: ty::t) -> Resu\n \n // Type descriptor and type glue stuff\n \n-pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> Rc<tydesc_info> {\n+pub fn get_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                            t: Ty<'tcx>) -> Rc<tydesc_info<'tcx>> {\n     match ccx.tydescs().borrow().get(&t) {\n         Some(inf) => return inf.clone(),\n         _ => { }\n@@ -494,12 +501,12 @@ pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n }\n \n \n-pub fn get_res_dtor(ccx: &CrateContext,\n-                    did: ast::DefId,\n-                    t: ty::t,\n-                    parent_id: ast::DefId,\n-                    substs: &subst::Substs)\n-                 -> ValueRef {\n+pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                              did: ast::DefId,\n+                              t: Ty<'tcx>,\n+                              parent_id: ast::DefId,\n+                              substs: &subst::Substs<'tcx>)\n+                              -> ValueRef {\n     let _icx = push_ctxt(\"trans_res_dtor\");\n     let did = inline::maybe_instantiate_inline(ccx, did);\n \n@@ -549,12 +556,12 @@ pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                         lhs: ValueRef,\n                                         rhs: ValueRef,\n-                                        t: ty::t,\n+                                        t: Ty<'tcx>,\n                                         op: ast::BinOp)\n                                         -> Result<'blk, 'tcx> {\n     let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n \n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_tup(ref tys) if tys.is_empty() => f(nil_type),\n         ty::ty_bool | ty::ty_uint(_) | ty::ty_char => f(unsigned_int),\n         ty::ty_ptr(mt) if ty::type_is_sized(cx.tcx(), mt.ty) => f(unsigned_int),\n@@ -627,15 +634,15 @@ pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn compare_simd_types(\n-                    cx: Block,\n+pub fn compare_simd_types<'blk, 'tcx>(\n+                    cx: Block<'blk, 'tcx>,\n                     lhs: ValueRef,\n                     rhs: ValueRef,\n-                    t: ty::t,\n+                    t: Ty<'tcx>,\n                     size: uint,\n                     op: ast::BinOp)\n                     -> ValueRef {\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_float(_) => {\n             // The comparison operators for floating point vectors are challenging.\n             // LLVM outputs a `< size x i1 >`, but if we perform a sign extension\n@@ -666,21 +673,21 @@ pub fn compare_simd_types(\n }\n \n pub type val_and_ty_fn<'a, 'blk, 'tcx> =\n-    |Block<'blk, 'tcx>, ValueRef, ty::t|: 'a -> Block<'blk, 'tcx>;\n+    |Block<'blk, 'tcx>, ValueRef, Ty<'tcx>|: 'a -> Block<'blk, 'tcx>;\n \n // Iterates through the elements of a structural type.\n pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                           av: ValueRef,\n-                                          t: ty::t,\n+                                          t: Ty<'tcx>,\n                                           f: val_and_ty_fn<'a, 'blk, 'tcx>)\n                                           -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"iter_structural_ty\");\n \n     fn iter_variant<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                    repr: &adt::Repr,\n+                                    repr: &adt::Repr<'tcx>,\n                                     av: ValueRef,\n-                                    variant: &ty::VariantInfo,\n-                                    substs: &subst::Substs,\n+                                    variant: &ty::VariantInfo<'tcx>,\n+                                    substs: &subst::Substs<'tcx>,\n                                     f: val_and_ty_fn<'a, 'blk, 'tcx>)\n                                     -> Block<'blk, 'tcx> {\n         let _icx = push_ctxt(\"iter_variant\");\n@@ -704,7 +711,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     };\n \n     let mut cx = cx;\n-    match ty::get(t).sty {\n+    match t.sty {\n       ty::ty_struct(..) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           expr::with_field_tys(cx.tcx(), t, None, |discr, field_tys| {\n@@ -855,7 +862,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n                                 divrem: ast::BinOp,\n                                 lhs: ValueRef,\n                                 rhs: ValueRef,\n-                                rhs_t: ty::t)\n+                                rhs_t: Ty<'tcx>)\n                                 -> Block<'blk, 'tcx> {\n     let (zero_text, overflow_text) = if divrem == ast::BiDiv {\n         (\"attempted to divide by zero\",\n@@ -864,7 +871,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         (\"attempted remainder with a divisor of zero\",\n          \"attempted remainder with overflow\")\n     };\n-    let (is_zero, is_signed) = match ty::get(rhs_t).sty {\n+    let (is_zero, is_signed) = match rhs_t.sty {\n         ty::ty_int(t) => {\n             let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0u64, false);\n             (ICmp(cx, llvm::IntEQ, rhs, zero), true)\n@@ -892,7 +899,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n     // signed division/remainder which would trigger overflow. For unsigned\n     // integers, no action beyond checking for zero need be taken.\n     if is_signed {\n-        let (llty, min) = match ty::get(rhs_t).sty {\n+        let (llty, min) = match rhs_t.sty {\n             ty::ty_int(t) => {\n                 let llty = Type::int_from_ty(cx.ccx(), t);\n                 let min = match t {\n@@ -922,9 +929,10 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n     }\n }\n \n-pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {\n+pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                     did: ast::DefId, t: Ty<'tcx>) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n-    match ty::get(t).sty {\n+    match t.sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n                 Rust | RustCall => {\n@@ -951,7 +959,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           llfn: ValueRef,\n                           llargs: Vec<ValueRef> ,\n-                          fn_ty: ty::t,\n+                          fn_ty: Ty<'tcx>,\n                           call_info: Option<NodeInfo>,\n                           // FIXME(15064) is_lang_item is a horrible hack, please remove it\n                           // at the soonest opportunity.\n@@ -1028,13 +1036,15 @@ pub fn need_invoke(bcx: Block) -> bool {\n     bcx.fcx.needs_invoke()\n }\n \n-pub fn load_if_immediate(cx: Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_if_immediate<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                     v: ValueRef, t: Ty<'tcx>) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return load_ty(cx, v, t); }\n     return v;\n }\n \n-pub fn load_ty(cx: Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                           ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n     /*!\n      * Helper for loading values from memory. Does the necessary conversion if\n      * the in-memory type differs from the type used for SSA values. Also\n@@ -1054,7 +1064,7 @@ pub fn load_ty(cx: Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n     }\n }\n \n-pub fn store_ty(cx: Block, v: ValueRef, dst: ValueRef, t: ty::t) {\n+pub fn store_ty(cx: Block, v: ValueRef, dst: ValueRef, t: Ty) {\n     /*!\n      * Helper for storing values in memory. Does the necessary conversion if\n      * the in-memory type differs from the type used for SSA values.\n@@ -1148,7 +1158,9 @@ pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n     Call(cx, memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n-pub fn memcpy_ty(bcx: Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n+pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             dst: ValueRef, src: ValueRef,\n+                             t: Ty<'tcx>) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n@@ -1161,7 +1173,7 @@ pub fn memcpy_ty(bcx: Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     }\n }\n \n-pub fn zero_mem(cx: Block, llptr: ValueRef, t: ty::t) {\n+pub fn zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n     if cx.unreachable.get() { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n@@ -1173,7 +1185,7 @@ pub fn zero_mem(cx: Block, llptr: ValueRef, t: ty::t) {\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-fn memzero(b: &Builder, llptr: ValueRef, ty: ty::t) {\n+fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n     let _icx = push_ctxt(\"memzero\");\n     let ccx = b.ccx;\n \n@@ -1194,7 +1206,7 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: ty::t) {\n     b.call(llintrinsicfn, &[llptr, llzeroval, size, align, volatile], None);\n }\n \n-pub fn alloc_ty(bcx: Block, t: ty::t, name: &str) -> ValueRef {\n+pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n@@ -1220,7 +1232,8 @@ pub fn alloca_no_lifetime(cx: Block, ty: Type, name: &str) -> ValueRef {\n     Alloca(cx, ty, name)\n }\n \n-pub fn alloca_zeroed(cx: Block, ty: ty::t, name: &str) -> ValueRef {\n+pub fn alloca_zeroed<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ty: Ty<'tcx>,\n+                                 name: &str) -> ValueRef {\n     let llty = type_of::type_of(cx.ccx(), ty);\n     if cx.unreachable.get() {\n         unsafe {\n@@ -1248,7 +1261,8 @@ pub fn arrayalloca(cx: Block, ty: Type, v: ValueRef) -> ValueRef {\n }\n \n // Creates the alloca slot which holds the pointer to the slot for the final return value\n-pub fn make_return_slot_pointer(fcx: &FunctionContext, output_type: ty::t) -> ValueRef {\n+pub fn make_return_slot_pointer<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+                                          output_type: Ty<'tcx>) -> ValueRef {\n     let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n \n     // We create an alloca to hold a pointer of type `output_type`\n@@ -1407,12 +1421,12 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                              llfndecl: ValueRef,\n                              id: ast::NodeId,\n                              has_env: bool,\n-                             output_type: ty::FnOutput,\n-                             param_substs: &'a param_substs,\n+                             output_type: ty::FnOutput<'tcx>,\n+                             param_substs: &'a Substs<'tcx>,\n                              sp: Option<Span>,\n                              block_arena: &'a TypedArena<common::BlockS<'a, 'tcx>>)\n                              -> FunctionContext<'a, 'tcx> {\n-    param_substs.validate();\n+    common::validate_substs(param_substs);\n \n     debug!(\"new_fn_ctxt(path={}, id={}, param_substs={})\",\n            if id == -1 {\n@@ -1424,7 +1438,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n \n     let uses_outptr = match output_type {\n         ty::FnConverging(output_type) => {\n-            let substd_output_type = output_type.substp(ccx.tcx(), param_substs);\n+            let substd_output_type = output_type.subst(ccx.tcx(), param_substs);\n             type_of::return_uses_outptr(ccx, substd_output_type)\n         }\n         ty::FnDiverging => false\n@@ -1463,7 +1477,8 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n /// and allocating space for the return pointer.\n pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n                                skip_retptr: bool,\n-                               output: ty::FnOutput) -> Block<'a, 'tcx> {\n+                               output: ty::FnOutput<'tcx>)\n+                               -> Block<'a, 'tcx> {\n     let entry_bcx = fcx.new_temp_block(\"entry-block\");\n \n     // Use a dummy instruction as the insertion point for all allocas.\n@@ -1476,7 +1491,7 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n     if let ty::FnConverging(output_type) = output {\n         // This shouldn't need to recompute the return type,\n         // as new_fn_ctxt did it already.\n-        let substd_output_type = output_type.substp(fcx.ccx.tcx(), fcx.param_substs);\n+        let substd_output_type = output_type.subst(fcx.ccx.tcx(), fcx.param_substs);\n         if !return_type_is_void(fcx.ccx, substd_output_type) {\n             // If the function returns nil/bot, there is no real return\n             // value, so do not set `llretslotptr`.\n@@ -1499,7 +1514,8 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n //  - new_fn_ctxt\n //  - trans_args\n \n-pub fn arg_kind(cx: &FunctionContext, t: ty::t) -> datum::Rvalue {\n+pub fn arg_kind<'a, 'tcx>(cx: &FunctionContext<'a, 'tcx>, t: Ty<'tcx>)\n+                          -> datum::Rvalue {\n     use trans::datum::{ByRef, ByValue};\n \n     datum::Rvalue {\n@@ -1508,15 +1524,15 @@ pub fn arg_kind(cx: &FunctionContext, t: ty::t) -> datum::Rvalue {\n }\n \n // work around bizarre resolve errors\n-pub type RvalueDatum = datum::Datum<datum::Rvalue>;\n-pub type LvalueDatum = datum::Datum<datum::Lvalue>;\n+pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n+pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n \n // create_datums_for_fn_args: creates rvalue datums for each of the\n // incoming function arguments. These will later be stored into\n // appropriate lvalue datums.\n-pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n-                                 arg_tys: &[ty::t])\n-                                 -> Vec<RvalueDatum> {\n+pub fn create_datums_for_fn_args<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+                                           arg_tys: &[Ty<'tcx>])\n+                                           -> Vec<RvalueDatum<'tcx>> {\n     let _icx = push_ctxt(\"create_datums_for_fn_args\");\n \n     // Return an array wrapping the ValueRefs that we get from `get_param` for\n@@ -1532,11 +1548,11 @@ pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n /// datums.\n ///\n /// FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n-fn create_datums_for_fn_args_under_call_abi(\n-        mut bcx: Block,\n+fn create_datums_for_fn_args_under_call_abi<'blk, 'tcx>(\n+        mut bcx: Block<'blk, 'tcx>,\n         arg_scope: cleanup::CustomScopeIndex,\n-        arg_tys: &[ty::t])\n-        -> Vec<RvalueDatum> {\n+        arg_tys: &[Ty<'tcx>])\n+        -> Vec<RvalueDatum<'tcx>> {\n     let mut result = Vec::new();\n     for (i, &arg_ty) in arg_tys.iter().enumerate() {\n         if i < arg_tys.len() - 1 {\n@@ -1548,7 +1564,7 @@ fn create_datums_for_fn_args_under_call_abi(\n         }\n \n         // This is the last argument. Tuple it.\n-        match ty::get(arg_ty).sty {\n+        match arg_ty.sty {\n             ty::ty_tup(ref tupled_arg_tys) => {\n                 let tuple_args_scope_id = cleanup::CustomScope(arg_scope);\n                 let tuple =\n@@ -1597,7 +1613,7 @@ fn copy_args_to_allocas<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n                                     arg_scope: cleanup::CustomScopeIndex,\n                                     bcx: Block<'blk, 'tcx>,\n                                     args: &[ast::Arg],\n-                                    arg_datums: Vec<RvalueDatum> )\n+                                    arg_datums: Vec<RvalueDatum<'tcx>>)\n                                     -> Block<'blk, 'tcx> {\n     debug!(\"copy_args_to_allocas\");\n \n@@ -1629,8 +1645,8 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                                         mut bcx: Block<'blk, 'tcx>,\n                                         arg_scope: cleanup::CustomScopeIndex,\n                                         args: &[ast::Arg],\n-                                        arg_datums: Vec<RvalueDatum>,\n-                                        monomorphized_arg_types: &[ty::t])\n+                                        arg_datums: Vec<RvalueDatum<'tcx>>,\n+                                        monomorphized_arg_types: &[Ty<'tcx>])\n                                         -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"copy_unboxed_closure_args_to_allocas\");\n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n@@ -1645,7 +1661,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                       arg_datum.to_lvalue_datum_in_scope(bcx,\n                                                          \"argtuple\",\n                                                          arg_scope_id));\n-    let untupled_arg_types = match ty::get(monomorphized_arg_types[0]).sty {\n+    let untupled_arg_types = match monomorphized_arg_types[0].sty {\n         ty::ty_tup(ref types) => types.as_slice(),\n         _ => {\n             bcx.tcx().sess.span_bug(args[0].pat.span,\n@@ -1681,7 +1697,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n // and builds the return block.\n pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n                              last_bcx: Block<'blk, 'tcx>,\n-                             retty: ty::FnOutput) {\n+                             retty: ty::FnOutput<'tcx>) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n     let ret_cx = match fcx.llreturn.get() {\n@@ -1696,15 +1712,17 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n \n     // This shouldn't need to recompute the return type,\n     // as new_fn_ctxt did it already.\n-    let substd_retty = retty.substp(fcx.ccx.tcx(), fcx.param_substs);\n+    let substd_retty = retty.subst(fcx.ccx.tcx(), fcx.param_substs);\n     build_return_block(fcx, ret_cx, substd_retty);\n \n     debuginfo::clear_source_location(fcx);\n     fcx.cleanup();\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: &FunctionContext, ret_cx: Block, retty: ty::FnOutput) {\n+pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n+                                      ret_cx: Block<'blk, 'tcx>,\n+                                      retty: ty::FnOutput<'tcx>) {\n     if fcx.llretslotptr.get().is_none() ||\n        (!fcx.needs_ret_allocas && fcx.caller_expects_out_pointer) {\n         return RetVoid(ret_cx);\n@@ -1763,28 +1781,19 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: Block, retty: ty::FnOut\n     }\n }\n \n-#[deriving(Clone, Eq, PartialEq)]\n-pub enum IsUnboxedClosureFlag {\n-    NotUnboxedClosure,\n-    IsUnboxedClosure,\n-}\n-\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-pub fn trans_closure(ccx: &CrateContext,\n-                     decl: &ast::FnDecl,\n-                     body: &ast::Block,\n-                     llfndecl: ValueRef,\n-                     param_substs: &param_substs,\n-                     fn_ast_id: ast::NodeId,\n-                     _attributes: &[ast::Attribute],\n-                     output_type: ty::FnOutput,\n-                     abi: Abi,\n-                     has_env: bool,\n-                     is_unboxed_closure: IsUnboxedClosureFlag,\n-                     maybe_load_env: for<'blk, 'tcx> |Block<'blk, 'tcx>, ScopeId|\n-                                                     -> Block<'blk, 'tcx>) {\n+pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                   decl: &ast::FnDecl,\n+                                   body: &ast::Block,\n+                                   llfndecl: ValueRef,\n+                                   param_substs: &Substs<'tcx>,\n+                                   fn_ast_id: ast::NodeId,\n+                                   _attributes: &[ast::Attribute],\n+                                   output_type: ty::FnOutput<'tcx>,\n+                                   abi: Abi,\n+                                   closure_env: closure::ClosureEnv<'b, 'tcx>) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n@@ -1797,7 +1806,7 @@ pub fn trans_closure(ccx: &CrateContext,\n     let fcx = new_fn_ctxt(ccx,\n                           llfndecl,\n                           fn_ast_id,\n-                          has_env,\n+                          closure_env.kind != closure::NotClosure,\n                           output_type,\n                           param_substs,\n                           Some(body.span),\n@@ -1816,11 +1825,15 @@ pub fn trans_closure(ccx: &CrateContext,\n         decl.inputs.iter()\n                    .map(|arg| node_id_type(bcx, arg.id))\n                    .collect::<Vec<_>>();\n-    let monomorphized_arg_types = match is_unboxed_closure {\n-        NotUnboxedClosure => monomorphized_arg_types,\n+    let monomorphized_arg_types = match closure_env.kind {\n+        closure::NotClosure | closure::BoxedClosure(..) => {\n+            monomorphized_arg_types\n+        }\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n-        IsUnboxedClosure => vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n+        closure::UnboxedClosure(..) => {\n+            vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n+        }\n     };\n     for monomorphized_arg_type in monomorphized_arg_types.iter() {\n         debug!(\"trans_closure: monomorphized_arg_type: {}\",\n@@ -1839,15 +1852,15 @@ pub fn trans_closure(ccx: &CrateContext,\n             monomorphized_arg_types.as_slice())\n     };\n \n-    bcx = match is_unboxed_closure {\n-        NotUnboxedClosure => {\n+    bcx = match closure_env.kind {\n+        closure::NotClosure | closure::BoxedClosure(..) => {\n             copy_args_to_allocas(&fcx,\n                                  arg_scope,\n                                  bcx,\n                                  decl.inputs.as_slice(),\n                                  arg_datums)\n         }\n-        IsUnboxedClosure => {\n+        closure::UnboxedClosure(..) => {\n             copy_unboxed_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n@@ -1857,7 +1870,7 @@ pub fn trans_closure(ccx: &CrateContext,\n         }\n     };\n \n-    bcx = maybe_load_env(bcx, cleanup::CustomScope(arg_scope));\n+    bcx = closure_env.load(bcx, cleanup::CustomScope(arg_scope));\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n@@ -1912,13 +1925,13 @@ pub fn trans_closure(ccx: &CrateContext,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-pub fn trans_fn(ccx: &CrateContext,\n-                decl: &ast::FnDecl,\n-                body: &ast::Block,\n-                llfndecl: ValueRef,\n-                param_substs: &param_substs,\n-                id: ast::NodeId,\n-                attrs: &[ast::Attribute]) {\n+pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                          decl: &ast::FnDecl,\n+                          body: &ast::Block,\n+                          llfndecl: ValueRef,\n+                          param_substs: &Substs<'tcx>,\n+                          id: ast::NodeId,\n+                          attrs: &[ast::Attribute]) {\n     let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n     debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n     let _icx = push_ctxt(\"trans_fn\");\n@@ -1934,18 +1947,16 @@ pub fn trans_fn(ccx: &CrateContext,\n                   attrs,\n                   output_type,\n                   abi,\n-                  false,\n-                  NotUnboxedClosure,\n-                  |bcx, _| bcx);\n-}\n-\n-pub fn trans_enum_variant(ccx: &CrateContext,\n-                          _enum_id: ast::NodeId,\n-                          variant: &ast::Variant,\n-                          _args: &[ast::VariantArg],\n-                          disr: ty::Disr,\n-                          param_substs: &param_substs,\n-                          llfndecl: ValueRef) {\n+                  closure::ClosureEnv::new(&[], closure::NotClosure));\n+}\n+\n+pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    _enum_id: ast::NodeId,\n+                                    variant: &ast::Variant,\n+                                    _args: &[ast::VariantArg],\n+                                    disr: ty::Disr,\n+                                    param_substs: &Substs<'tcx>,\n+                                    llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n \n     trans_enum_variant_or_tuple_like_struct(\n@@ -1957,7 +1968,7 @@ pub fn trans_enum_variant(ccx: &CrateContext,\n }\n \n pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                                 ctor_ty: ty::t,\n+                                                 ctor_ty: Ty<'tcx>,\n                                                  disr: ty::Disr,\n                                                  args: callee::CallArgs,\n                                                  dest: expr::Dest,\n@@ -1967,7 +1978,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.fcx.ccx;\n     let tcx = ccx.tcx();\n \n-    let result_ty = match ty::get(ctor_ty).sty {\n+    let result_ty = match ctor_ty.sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output.unwrap(),\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_constructor: \\\n@@ -2016,11 +2027,11 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     Result::new(bcx, llresult)\n }\n \n-pub fn trans_tuple_struct(ccx: &CrateContext,\n-                          _fields: &[ast::StructField],\n-                          ctor_id: ast::NodeId,\n-                          param_substs: &param_substs,\n-                          llfndecl: ValueRef) {\n+pub fn trans_tuple_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    _fields: &[ast::StructField],\n+                                    ctor_id: ast::NodeId,\n+                                    param_substs: &Substs<'tcx>,\n+                                    llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_tuple_struct\");\n \n     trans_enum_variant_or_tuple_like_struct(\n@@ -2031,15 +2042,15 @@ pub fn trans_tuple_struct(ccx: &CrateContext,\n         llfndecl);\n }\n \n-fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n-                                           ctor_id: ast::NodeId,\n-                                           disr: ty::Disr,\n-                                           param_substs: &param_substs,\n-                                           llfndecl: ValueRef) {\n+fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                     ctor_id: ast::NodeId,\n+                                                     disr: ty::Disr,\n+                                                     param_substs: &Substs<'tcx>,\n+                                                     llfndecl: ValueRef) {\n     let ctor_ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n-    let ctor_ty = ctor_ty.substp(ccx.tcx(), param_substs);\n+    let ctor_ty = ctor_ty.subst(ccx.tcx(), param_substs);\n \n-    let result_ty = match ty::get(ctor_ty).sty {\n+    let result_ty = match ctor_ty.sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n@@ -2253,15 +2264,15 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                                                             &**body,\n                                                             item.attrs.as_slice(),\n                                                             llfn,\n-                                                            &param_substs::empty(),\n+                                                            &Substs::trans_empty(),\n                                                             item.id,\n                                                             None);\n                 } else {\n                     trans_fn(ccx,\n                              &**decl,\n                              &**body,\n                              llfn,\n-                             &param_substs::empty(),\n+                             &Substs::trans_empty(),\n                              item.id,\n                              item.attrs.as_slice());\n                 }\n@@ -2370,13 +2381,13 @@ fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::N\n     }\n }\n \n-fn register_fn(ccx: &CrateContext,\n-               sp: Span,\n-               sym: String,\n-               node_id: ast::NodeId,\n-               node_type: ty::t)\n-               -> ValueRef {\n-    match ty::get(node_type).sty {\n+fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                         sp: Span,\n+                         sym: String,\n+                         node_id: ast::NodeId,\n+                         node_type: Ty<'tcx>)\n+                         -> ValueRef {\n+    match node_type.sty {\n         ty::ty_bare_fn(ref f) => {\n             assert!(f.abi == Rust || f.abi == RustCall);\n         }\n@@ -2388,11 +2399,11 @@ fn register_fn(ccx: &CrateContext,\n     llfn\n }\n \n-pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n-                              -> llvm::AttrBuilder {\n+pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>)\n+                                        -> llvm::AttrBuilder {\n     use middle::ty::{BrAnon, ReLateBound};\n \n-    let (fn_sig, abi, has_env) = match ty::get(fn_ty).sty {\n+    let (fn_sig, abi, has_env) = match fn_ty.sty {\n         ty::ty_closure(ref f) => (f.sig.clone(), f.abi, true),\n         ty::ty_bare_fn(ref f) => (f.sig.clone(), f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _, ref substs) => {\n@@ -2414,19 +2425,19 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n \n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n-    let input_tys = match ty::get(fn_ty).sty {\n+    let input_tys = match fn_ty.sty {\n         ty::ty_unboxed_closure(_, _, _) => {\n             assert!(abi == RustCall);\n \n-            match ty::get(fn_sig.inputs[0]).sty {\n+            match fn_sig.inputs[0].sty {\n                 ty::ty_tup(ref inputs) => inputs.clone(),\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n         ty::ty_bare_fn(_) if abi == RustCall => {\n             let mut inputs = vec![fn_sig.inputs[0]];\n \n-            match ty::get(fn_sig.inputs[1]).sty {\n+            match fn_sig.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n                     inputs.push_all(t_in.as_slice());\n                     inputs\n@@ -2458,7 +2469,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         } else {\n             // The `noalias` attribute on the return value is useful to a\n             // function ptr caller.\n-            match ty::get(ret_ty).sty {\n+            match ret_ty.sty {\n                 // `~` pointer return values never alias because ownership\n                 // is transferred\n                 ty::ty_uniq(it) if !ty::type_is_sized(ccx.tcx(), it) => {}\n@@ -2469,7 +2480,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n             }\n \n             // We can also mark the return value as `dereferenceable` in certain cases\n-            match ty::get(ret_ty).sty {\n+            match ret_ty.sty {\n                 // These are not really pointers but pairs, (pointer, len)\n                 ty::ty_uniq(it) |\n                 ty::ty_rptr(_, ty::mt { ty: it, .. }) if !ty::type_is_sized(ccx.tcx(), it) => {}\n@@ -2480,7 +2491,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n                 _ => {}\n             }\n \n-            match ty::get(ret_ty).sty {\n+            match ret_ty.sty {\n                 ty::ty_bool => {\n                     attrs.ret(llvm::ZExtAttribute);\n                 }\n@@ -2490,7 +2501,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n     }\n \n     for (idx, &t) in input_tys.iter().enumerate().map(|(i, v)| (i + first_arg_offset, v)) {\n-        match ty::get(t).sty {\n+        match t.sty {\n             // this needs to be first to prevent fat pointers from falling through\n             _ if !type_is_immediate(ccx, t) => {\n                 let llarg_sz = llsize_of_real(ccx, type_of::type_of(ccx, t));\n@@ -2664,8 +2675,8 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n     }\n }\n \n-fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n-                 ty: ty::t, attrs: &[ast::Attribute]) -> String {\n+fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, id: ast::NodeId,\n+                           ty: Ty<'tcx>, attrs: &[ast::Attribute]) -> String {\n     match ccx.external_srcs().borrow().get(&id) {\n         Some(&did) => {\n             let sym = csearch::get_symbol(&ccx.sess().cstore, did);"}, {"sha": "bf7adbbecef1a847d03e2a28d58b344f96125c6c", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 60, "deletions": 62, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -29,7 +29,7 @@ use llvm;\n use metadata::csearch;\n use middle::def;\n use middle::subst;\n-use middle::subst::{Subst};\n+use middle::subst::{Subst, Substs};\n use trans::adt;\n use trans::base;\n use trans::base::*;\n@@ -50,7 +50,7 @@ use trans::meth;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::typeck::coherence::make_substs_for_receiver_types;\n use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n@@ -66,26 +66,26 @@ pub struct MethodData {\n     pub llself: ValueRef,\n }\n \n-pub enum CalleeData {\n-    Closure(Datum<Lvalue>),\n+pub enum CalleeData<'tcx> {\n+    Closure(Datum<'tcx, Lvalue>),\n \n     // Constructor for enum variant/tuple-like-struct\n     // i.e. Some, Ok\n-    NamedTupleConstructor(subst::Substs, ty::Disr),\n+    NamedTupleConstructor(subst::Substs<'tcx>, ty::Disr),\n \n     // Represents a (possibly monomorphized) top-level fn item or method\n     // item. Note that this is just the fn-ptr and is not a Rust closure\n     // value (which is a pair).\n     Fn(/* llfn */ ValueRef),\n \n-    Intrinsic(ast::NodeId, subst::Substs),\n+    Intrinsic(ast::NodeId, subst::Substs<'tcx>),\n \n     TraitItem(MethodData)\n }\n \n pub struct Callee<'blk, 'tcx: 'blk> {\n     pub bcx: Block<'blk, 'tcx>,\n-    pub data: CalleeData,\n+    pub data: CalleeData<'tcx>,\n }\n \n fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n@@ -107,7 +107,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n     fn datum_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                                 -> Callee<'blk, 'tcx> {\n         let DatumBlock {mut bcx, datum} = expr::trans(bcx, expr);\n-        match ty::get(datum.ty).sty {\n+        match datum.ty.sty {\n             ty::ty_bare_fn(..) => {\n                 let llval = datum.to_llscalarish(bcx);\n                 return Callee {\n@@ -163,7 +163,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     data: NamedTupleConstructor(substs, 0)\n                 }\n             }\n-            def::DefFn(did, _) if match ty::get(expr_ty).sty {\n+            def::DefFn(did, _) if match expr_ty.sty {\n                 ty::ty_bare_fn(ref f) => f.abi == synabi::RustIntrinsic,\n                 _ => false\n             } => {\n@@ -240,7 +240,7 @@ pub fn trans_fn_ref(bcx: Block, def_id: ast::DefId, node: ExprOrMethodCall) -> V\n fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                   def_id: ast::DefId,\n                                                   ref_id: ast::NodeId,\n-                                                  substs: subst::Substs)\n+                                                  substs: subst::Substs<'tcx>)\n                                                   -> Callee<'blk, 'tcx> {\n     Callee {\n         bcx: bcx,\n@@ -253,12 +253,12 @@ fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n /// Translates the adapter that deconstructs a `Box<Trait>` object into\n /// `Trait` so that a by-value self method can be called.\n-pub fn trans_unboxing_shim(bcx: Block,\n-                           llshimmedfn: ValueRef,\n-                           fty: &ty::BareFnTy,\n-                           method_id: ast::DefId,\n-                           substs: &subst::Substs)\n-                           -> ValueRef {\n+pub fn trans_unboxing_shim<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       llshimmedfn: ValueRef,\n+                                       fty: &ty::BareFnTy<'tcx>,\n+                                       method_id: ast::DefId,\n+                                       substs: &subst::Substs<'tcx>)\n+                                       -> ValueRef {\n     let _icx = push_ctxt(\"trans_unboxing_shim\");\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n@@ -319,7 +319,7 @@ pub fn trans_unboxing_shim(bcx: Block,\n                                      function_name.as_slice());\n \n     let block_arena = TypedArena::new();\n-    let empty_param_substs = param_substs::empty();\n+    let empty_param_substs = Substs::trans_empty();\n     let return_type = ty::ty_fn_ret(boxed_function_type);\n     let fcx = new_fn_ctxt(ccx,\n                           llfn,\n@@ -334,8 +334,7 @@ pub fn trans_unboxing_shim(bcx: Block,\n     // Create the substituted versions of the self type.\n     let arg_scope = fcx.push_custom_cleanup_scope();\n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n-    let boxed_arg_types = ty::ty_fn_args(boxed_function_type);\n-    let boxed_self_type = boxed_arg_types[0];\n+    let boxed_self_type = ty::ty_fn_args(boxed_function_type)[0];\n     let arg_types = ty::ty_fn_args(function_type);\n     let self_type = arg_types[0];\n     let boxed_self_kind = arg_kind(&fcx, boxed_self_type);\n@@ -399,11 +398,11 @@ pub fn trans_unboxing_shim(bcx: Block,\n     llfn\n }\n \n-pub fn trans_fn_ref_with_substs(\n-    bcx: Block,                  //\n+pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n+    bcx: Block<'blk, 'tcx>,      //\n     def_id: ast::DefId,          // def id of fn\n     node: ExprOrMethodCall,      // node id of use of fn; may be zero if N/A\n-    substs: subst::Substs)       // vtables for the call\n+    substs: subst::Substs<'tcx>) // vtables for the call\n     -> ValueRef\n {\n     /*!\n@@ -610,12 +609,12 @@ pub fn trans_fn_ref_with_substs(\n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_call<'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n-                              call_ex: &ast::Expr,\n-                              f: &ast::Expr,\n-                              args: CallArgs,\n-                              dest: expr::Dest)\n-                              -> Block<'blk, 'tcx> {\n+pub fn trans_call<'a, 'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n+                                  call_ex: &ast::Expr,\n+                                  f: &ast::Expr,\n+                                  args: CallArgs<'a, 'tcx>,\n+                                  dest: expr::Dest)\n+                                  -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n                      Some(common::expr_info(call_ex)),\n@@ -625,12 +624,12 @@ pub fn trans_call<'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n                      Some(dest)).bcx\n }\n \n-pub fn trans_method_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     call_ex: &ast::Expr,\n-                                     rcvr: &ast::Expr,\n-                                     args: CallArgs,\n-                                     dest: expr::Dest)\n-                                     -> Block<'blk, 'tcx> {\n+pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                         call_ex: &ast::Expr,\n+                                         rcvr: &ast::Expr,\n+                                         args: CallArgs<'a, 'tcx>,\n+                                         dest: expr::Dest)\n+                                         -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n     let method_call = MethodCall::expr(call_ex.id);\n@@ -669,15 +668,15 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              dest)\n }\n \n-pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    call_info: Option<NodeInfo>,\n-                                    callee_ty: ty::t,\n-                                    get_callee: |bcx: Block<'blk, 'tcx>,\n-                                                arg_cleanup_scope: cleanup::ScopeId|\n-                                                -> Callee<'blk, 'tcx>,\n-                                    args: CallArgs,\n-                                    dest: Option<expr::Dest>)\n-                                    -> Result<'blk, 'tcx> {\n+pub fn trans_call_inner<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        call_info: Option<NodeInfo>,\n+                                        callee_ty: Ty<'tcx>,\n+                                        get_callee: |bcx: Block<'blk, 'tcx>,\n+                                                     arg_cleanup_scope: cleanup::ScopeId|\n+                                                     -> Callee<'blk, 'tcx>,\n+                                        args: CallArgs<'a, 'tcx>,\n+                                        dest: Option<expr::Dest>)\n+                                        -> Result<'blk, 'tcx> {\n     /*!\n      * This behemoth of a function translates function calls.\n      * Unfortunately, in order to generate more efficient LLVM\n@@ -708,7 +707,7 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let callee = get_callee(bcx, cleanup::CustomScope(arg_cleanup_scope));\n     let mut bcx = callee.bcx;\n \n-    let (abi, ret_ty) = match ty::get(callee_ty).sty {\n+    let (abi, ret_ty) = match callee_ty.sty {\n         ty::ty_bare_fn(ref f) => (f.abi, f.sig.output),\n         ty::ty_closure(ref f) => (f.abi, f.sig.output),\n         _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n@@ -890,7 +889,7 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     Result::new(bcx, llresult)\n }\n \n-pub enum CallArgs<'a> {\n+pub enum CallArgs<'a, 'tcx> {\n     // Supply value of arguments as a list of expressions that must be\n     // translated. This is used in the common case of `foo(bar, qux)`.\n     ArgExprs(&'a [P<ast::Expr>]),\n@@ -903,7 +902,7 @@ pub enum CallArgs<'a> {\n     // For overloaded operators: `(lhs, Vec(rhs, rhs_id))`. `lhs`\n     // is the left-hand-side and `rhs/rhs_id` is the datum/expr-id of\n     // the right-hand-side arguments (if any).\n-    ArgOverloadedOp(Datum<Expr>, Vec<(Datum<Expr>, ast::NodeId)>),\n+    ArgOverloadedOp(Datum<'tcx, Expr>, Vec<(Datum<'tcx, Expr>, ast::NodeId)>),\n \n     // Supply value of arguments as a list of expressions that must be\n     // translated, for overloaded call operators.\n@@ -913,18 +912,17 @@ pub enum CallArgs<'a> {\n fn trans_args_under_call_abi<'blk, 'tcx>(\n                              mut bcx: Block<'blk, 'tcx>,\n                              arg_exprs: &[P<ast::Expr>],\n-                             fn_ty: ty::t,\n+                             fn_ty: Ty<'tcx>,\n                              llargs: &mut Vec<ValueRef>,\n                              arg_cleanup_scope: cleanup::ScopeId,\n                              ignore_self: bool)\n                              -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n-    let arg_tys = ty::ty_fn_args(fn_ty);\n     if !ignore_self {\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n             trans_arg_datum(bcx,\n-                            arg_tys[0],\n+                            ty::ty_fn_args(fn_ty)[0],\n                             arg_datum,\n                             arg_cleanup_scope,\n                             DontAutorefArg)\n@@ -935,7 +933,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n     let tuple_expr = &arg_exprs[1];\n     let tuple_type = node_id_type(bcx, tuple_expr.id);\n \n-    match ty::get(tuple_type).sty {\n+    match tuple_type.sty {\n         ty::ty_tup(ref field_types) => {\n             let tuple_datum = unpack_datum!(bcx,\n                                             expr::trans(bcx, &**tuple_expr));\n@@ -973,7 +971,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n fn trans_overloaded_call_args<'blk, 'tcx>(\n                               mut bcx: Block<'blk, 'tcx>,\n                               arg_exprs: Vec<&ast::Expr>,\n-                              fn_ty: ty::t,\n+                              fn_ty: Ty<'tcx>,\n                               llargs: &mut Vec<ValueRef>,\n                               arg_cleanup_scope: cleanup::ScopeId,\n                               ignore_self: bool)\n@@ -993,7 +991,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n \n     // Now untuple the rest of the arguments.\n     let tuple_type = arg_tys[1];\n-    match ty::get(tuple_type).sty {\n+    match tuple_type.sty {\n         ty::ty_tup(ref field_types) => {\n             for (i, &field_type) in field_types.iter().enumerate() {\n                 let arg_datum =\n@@ -1016,14 +1014,14 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n     bcx\n }\n \n-pub fn trans_args<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                              args: CallArgs,\n-                              fn_ty: ty::t,\n-                              llargs: &mut Vec<ValueRef> ,\n-                              arg_cleanup_scope: cleanup::ScopeId,\n-                              ignore_self: bool,\n-                              abi: synabi::Abi)\n-                              -> Block<'blk, 'tcx> {\n+pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                  args: CallArgs<'a, 'tcx>,\n+                                  fn_ty: Ty<'tcx>,\n+                                  llargs: &mut Vec<ValueRef>,\n+                                  arg_cleanup_scope: cleanup::ScopeId,\n+                                  ignore_self: bool,\n+                                  abi: synabi::Abi)\n+                                  -> Block<'blk, 'tcx> {\n     debug!(\"trans_args(abi={})\", abi);\n \n     let _icx = push_ctxt(\"trans_args\");\n@@ -1108,8 +1106,8 @@ pub enum AutorefArg {\n }\n \n pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   formal_arg_ty: ty::t,\n-                                   arg_datum: Datum<Expr>,\n+                                   formal_arg_ty: Ty<'tcx>,\n+                                   arg_datum: Datum<'tcx, Expr>,\n                                    arg_cleanup_scope: cleanup::ScopeId,\n                                    autoref_arg: AutorefArg)\n                                    -> Result<'blk, 'tcx> {"}, {"sha": "0a26922e1846836b2d002032386f75506d8941e4", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -27,7 +27,7 @@ use trans::common::{Block, FunctionContext, ExprId, NodeInfo};\n use trans::debuginfo;\n use trans::glue;\n use trans::type_::Type;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use std::fmt;\n use syntax::ast;\n use util::ppaux::Repr;\n@@ -41,7 +41,7 @@ pub struct CleanupScope<'blk, 'tcx: 'blk> {\n     kind: CleanupScopeKind<'blk, 'tcx>,\n \n     // Cleanups to run upon scope exit.\n-    cleanups: Vec<CleanupObj>,\n+    cleanups: Vec<CleanupObj<'tcx>>,\n \n     // The debug location any drop calls generated for this scope will be\n     // associated with.\n@@ -94,17 +94,17 @@ pub struct CachedEarlyExit {\n     cleanup_block: BasicBlockRef,\n }\n \n-pub trait Cleanup {\n+pub trait Cleanup<'tcx> {\n     fn must_unwind(&self) -> bool;\n     fn clean_on_unwind(&self) -> bool;\n     fn is_lifetime_end(&self) -> bool;\n-    fn trans<'blk, 'tcx>(&self,\n-                         bcx: Block<'blk, 'tcx>,\n-                         debug_loc: Option<NodeInfo>)\n-                      -> Block<'blk, 'tcx>;\n+    fn trans<'blk>(&self,\n+                   bcx: Block<'blk, 'tcx>,\n+                   debug_loc: Option<NodeInfo>)\n+                   -> Block<'blk, 'tcx>;\n }\n \n-pub type CleanupObj = Box<Cleanup+'static>;\n+pub type CleanupObj<'tcx> = Box<Cleanup<'tcx>+'tcx>;\n \n #[deriving(Show)]\n pub enum ScopeId {\n@@ -307,7 +307,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_mem(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n-                         ty: ty::t) {\n+                         ty: Ty<'tcx>) {\n         /*!\n          * Schedules a (deep) drop of `val`, which is a pointer to an\n          * instance of `ty`\n@@ -333,7 +333,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_and_zero_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n-                                  ty: ty::t) {\n+                                  ty: Ty<'tcx>) {\n         /*!\n          * Schedules a (deep) drop and zero-ing of `val`, which is a pointer\n          * to an instance of `ty`\n@@ -360,7 +360,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_immediate(&self,\n                                cleanup_scope: ScopeId,\n                                val: ValueRef,\n-                               ty: ty::t) {\n+                               ty: Ty<'tcx>) {\n         /*!\n          * Schedules a (deep) drop of `val`, which is an instance of `ty`\n          */\n@@ -386,7 +386,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,\n                            heap: Heap,\n-                           content_ty: ty::t) {\n+                           content_ty: Ty<'tcx>) {\n         /*!\n          * Schedules a call to `free(val)`. Note that this is a shallow\n          * operation.\n@@ -425,7 +425,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n-                      cleanup: CleanupObj) {\n+                      cleanup: CleanupObj<'tcx>) {\n         match cleanup_scope {\n             AstScope(id) => self.schedule_clean_in_ast_scope(id, cleanup),\n             CustomScope(id) => self.schedule_clean_in_custom_scope(id, cleanup),\n@@ -434,7 +434,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n     fn schedule_clean_in_ast_scope(&self,\n                                    cleanup_scope: ast::NodeId,\n-                                   cleanup: CleanupObj) {\n+                                   cleanup: CleanupObj<'tcx>) {\n         /*!\n          * Schedules a cleanup to occur upon exit from `cleanup_scope`.\n          * If `cleanup_scope` is not provided, then the cleanup is scheduled\n@@ -462,7 +462,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n     fn schedule_clean_in_custom_scope(&self,\n                                       custom_scope: CustomScopeIndex,\n-                                      cleanup: CleanupObj) {\n+                                      cleanup: CleanupObj<'tcx>) {\n         /*!\n          * Schedules a cleanup to occur in the top-most scope,\n          * which must be a temporary scope.\n@@ -559,7 +559,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n \n     fn trans_scope_cleanups(&self, // cannot borrow self, will recurse\n                             bcx: Block<'blk, 'tcx>,\n-                            scope: &CleanupScope) -> Block<'blk, 'tcx> {\n+                            scope: &CleanupScope<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n         /*! Generates the cleanups for `scope` into `bcx` */\n \n         let mut bcx = bcx;\n@@ -955,15 +955,15 @@ impl EarlyExitLabel {\n ///////////////////////////////////////////////////////////////////////////\n // Cleanup types\n \n-pub struct DropValue {\n+pub struct DropValue<'tcx> {\n     is_immediate: bool,\n     must_unwind: bool,\n     val: ValueRef,\n-    ty: ty::t,\n+    ty: Ty<'tcx>,\n     zero: bool\n }\n \n-impl Cleanup for DropValue {\n+impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n     fn must_unwind(&self) -> bool {\n         self.must_unwind\n     }\n@@ -976,10 +976,10 @@ impl Cleanup for DropValue {\n         false\n     }\n \n-    fn trans<'blk, 'tcx>(&self,\n-                         bcx: Block<'blk, 'tcx>,\n-                         debug_loc: Option<NodeInfo>)\n-                         -> Block<'blk, 'tcx> {\n+    fn trans<'blk>(&self,\n+                   bcx: Block<'blk, 'tcx>,\n+                   debug_loc: Option<NodeInfo>)\n+                   -> Block<'blk, 'tcx> {\n         let bcx = if self.is_immediate {\n             glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc)\n         } else {\n@@ -997,13 +997,13 @@ pub enum Heap {\n     HeapExchange\n }\n \n-pub struct FreeValue {\n+pub struct FreeValue<'tcx> {\n     ptr: ValueRef,\n     heap: Heap,\n-    content_ty: ty::t\n+    content_ty: Ty<'tcx>\n }\n \n-impl Cleanup for FreeValue {\n+impl<'tcx> Cleanup<'tcx> for FreeValue<'tcx> {\n     fn must_unwind(&self) -> bool {\n         true\n     }\n@@ -1016,10 +1016,10 @@ impl Cleanup for FreeValue {\n         false\n     }\n \n-    fn trans<'blk, 'tcx>(&self,\n-                         bcx: Block<'blk, 'tcx>,\n-                         debug_loc: Option<NodeInfo>)\n-                      -> Block<'blk, 'tcx> {\n+    fn trans<'blk>(&self,\n+                   bcx: Block<'blk, 'tcx>,\n+                   debug_loc: Option<NodeInfo>)\n+                   -> Block<'blk, 'tcx> {\n         apply_debug_loc(bcx.fcx, debug_loc);\n \n         match self.heap {\n@@ -1037,7 +1037,7 @@ pub struct FreeSlice {\n     heap: Heap,\n }\n \n-impl Cleanup for FreeSlice {\n+impl<'tcx> Cleanup<'tcx> for FreeSlice {\n     fn must_unwind(&self) -> bool {\n         true\n     }\n@@ -1068,7 +1068,7 @@ pub struct LifetimeEnd {\n     ptr: ValueRef,\n }\n \n-impl Cleanup for LifetimeEnd {\n+impl<'tcx> Cleanup<'tcx> for LifetimeEnd {\n     fn must_unwind(&self) -> bool {\n         false\n     }\n@@ -1166,20 +1166,20 @@ pub trait CleanupMethods<'blk, 'tcx> {\n     fn schedule_drop_mem(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n-                         ty: ty::t);\n+                         ty: Ty<'tcx>);\n     fn schedule_drop_and_zero_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n-                                  ty: ty::t);\n+                                  ty: Ty<'tcx>);\n     fn schedule_drop_immediate(&self,\n                                cleanup_scope: ScopeId,\n                                val: ValueRef,\n-                               ty: ty::t);\n+                               ty: Ty<'tcx>);\n     fn schedule_free_value(&self,\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,\n                            heap: Heap,\n-                           content_ty: ty::t);\n+                           content_ty: Ty<'tcx>);\n     fn schedule_free_slice(&self,\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,\n@@ -1188,13 +1188,13 @@ pub trait CleanupMethods<'blk, 'tcx> {\n                            heap: Heap);\n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n-                      cleanup: CleanupObj);\n+                      cleanup: CleanupObj<'tcx>);\n     fn schedule_clean_in_ast_scope(&self,\n                                    cleanup_scope: ast::NodeId,\n-                                   cleanup: CleanupObj);\n+                                   cleanup: CleanupObj<'tcx>);\n     fn schedule_clean_in_custom_scope(&self,\n                                     custom_scope: CustomScopeIndex,\n-                                    cleanup: CleanupObj);\n+                                    cleanup: CleanupObj<'tcx>);\n     fn needs_invoke(&self) -> bool;\n     fn get_landing_pad(&'blk self) -> BasicBlockRef;\n }"}, {"sha": "d4c93be7eafca17c26ae6976d14de5312ed25f6f", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 77, "deletions": 51, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub use self::ClosureKind::*;\n \n use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n@@ -25,7 +26,7 @@ use trans::expr;\n use trans::monomorphize::MonoId;\n use trans::type_of::*;\n use trans::type_::Type;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::subst::{Subst, Substs};\n use session::config::FullDebugInfo;\n use util::ppaux::Repr;\n@@ -101,21 +102,21 @@ use syntax::ast_util;\n //\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-pub struct EnvValue {\n+pub struct EnvValue<'tcx> {\n     action: ast::CaptureClause,\n-    datum: Datum<Lvalue>\n+    datum: Datum<'tcx, Lvalue>\n }\n \n-impl EnvValue {\n-    pub fn to_string(&self, ccx: &CrateContext) -> String {\n+impl<'tcx> EnvValue<'tcx> {\n+    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n         format!(\"{}({})\", self.action, self.datum.to_string(ccx))\n     }\n }\n \n // Given a closure ty, emits a corresponding tuple ty\n-pub fn mk_closure_tys(tcx: &ty::ctxt,\n-                      bound_values: &[EnvValue])\n-                   -> ty::t {\n+pub fn mk_closure_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                            bound_values: &[EnvValue<'tcx>])\n+                            -> Ty<'tcx> {\n     // determine the types of the values in the env.  Note that this\n     // is the actual types that will be stored in the map, not the\n     // logical types as the user sees them, so by-ref upvars must be\n@@ -131,14 +132,14 @@ pub fn mk_closure_tys(tcx: &ty::ctxt,\n     return cdata_ty;\n }\n \n-fn tuplify_box_ty(tcx: &ty::ctxt, t: ty::t) -> ty::t {\n+fn tuplify_box_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n     let ptr = ty::mk_imm_ptr(tcx, ty::mk_i8());\n     ty::mk_tup(tcx, vec!(ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t))\n }\n \n fn allocate_cbox<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              store: ty::TraitStore,\n-                             cdata_ty: ty::t)\n+                             cdata_ty: Ty<'tcx>)\n                              -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let tcx = bcx.tcx();\n@@ -157,8 +158,8 @@ fn allocate_cbox<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub struct ClosureResult<'blk, 'tcx: 'blk> {\n-    llbox: ValueRef,    // llvalue of ptr to closure\n-    cdata_ty: ty::t,    // type of the closure data\n+    llbox: ValueRef,        // llvalue of ptr to closure\n+    cdata_ty: Ty<'tcx>,     // type of the closure data\n     bcx: Block<'blk, 'tcx>  // final bcx\n }\n \n@@ -167,7 +168,7 @@ pub struct ClosureResult<'blk, 'tcx: 'blk> {\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     bound_values: Vec<EnvValue> ,\n+                                     bound_values: Vec<EnvValue<'tcx>> ,\n                                      store: ty::TraitStore)\n                                      -> ClosureResult<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::store_environment\");\n@@ -248,17 +249,12 @@ fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                cdata_ty: ty::t,\n-                                freevars: &Vec<ty::Freevar>,\n+                                cdata_ty: Ty<'tcx>,\n+                                freevars: &[ty::Freevar],\n                                 store: ty::TraitStore)\n                                 -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n-    // Don't bother to create the block if there's nothing to load\n-    if freevars.len() == 0 {\n-        return bcx;\n-    }\n-\n     // Load a pointer to the closure data, skipping over the box header:\n     let llcdata = at_box_body(bcx, cdata_ty, bcx.fcx.llenv.unwrap());\n \n@@ -304,16 +300,12 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n                                     bcx: Block<'blk, 'tcx>,\n                                     arg_scope_id: ScopeId,\n                                     freevar_mode: ast::CaptureClause,\n-                                    freevars: &Vec<ty::Freevar>,\n-                                    closure_id: ast::DefId)\n+                                    freevars: &[ty::Freevar])\n                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n-    if freevars.len() == 0 {\n-        return bcx\n-    }\n-\n     // Special case for small by-value selfs.\n+    let closure_id = ast_util::local_def(bcx.fcx.id);\n     let self_type = self_type_for_unboxed_closure(bcx.ccx(), closure_id,\n                                                   node_id_type(bcx, closure_id.node));\n     let kind = kind_for_unboxed_closure(bcx.ccx(), closure_id);\n@@ -352,6 +344,48 @@ fn fill_fn_pair(bcx: Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef)\n     Store(bcx, llenvptr, GEPi(bcx, pair, &[0u, abi::fn_field_box]));\n }\n \n+#[deriving(PartialEq)]\n+pub enum ClosureKind<'tcx> {\n+    NotClosure,\n+    // See load_environment.\n+    BoxedClosure(Ty<'tcx>, ty::TraitStore),\n+    // See load_unboxed_closure_environment.\n+    UnboxedClosure(ast::CaptureClause)\n+}\n+\n+pub struct ClosureEnv<'a, 'tcx> {\n+    freevars: &'a [ty::Freevar],\n+    pub kind: ClosureKind<'tcx>\n+}\n+\n+impl<'a, 'tcx> ClosureEnv<'a, 'tcx> {\n+    pub fn new(freevars: &'a [ty::Freevar], kind: ClosureKind<'tcx>)\n+               -> ClosureEnv<'a, 'tcx> {\n+        ClosureEnv {\n+            freevars: freevars,\n+            kind: kind\n+        }\n+    }\n+\n+    pub fn load<'blk>(self, bcx: Block<'blk, 'tcx>, arg_scope: ScopeId)\n+                      -> Block<'blk, 'tcx> {\n+        // Don't bother to create the block if there's nothing to load\n+        if self.freevars.is_empty() {\n+            return bcx;\n+        }\n+\n+        match self.kind {\n+            NotClosure => bcx,\n+            BoxedClosure(cdata_ty, store) => {\n+                load_environment(bcx, cdata_ty, self.freevars, store)\n+            }\n+            UnboxedClosure(freevar_mode) => {\n+                load_unboxed_closure_environment(bcx, arg_scope, freevar_mode, self.freevars)\n+            }\n+        }\n+    }\n+}\n+\n pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  store: ty::TraitStore,\n                                  decl: &ast::FnDecl,\n@@ -401,6 +435,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         cdata_ty,\n         bcx\n     } = build_closure(bcx, freevar_mode, &freevars, store);\n+\n     trans_closure(ccx,\n                   decl,\n                   body,\n@@ -410,9 +445,8 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   &[],\n                   ty::ty_fn_ret(fty),\n                   ty::ty_fn_abi(fty),\n-                  true,\n-                  NotUnboxedClosure,\n-                  |bcx, _| load_environment(bcx, cdata_ty, &freevars, store));\n+                  ClosureEnv::new(freevars.as_slice(),\n+                                  BoxedClosure(cdata_ty, store)));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n     bcx\n }\n@@ -421,7 +455,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// if necessary. If the ID does not correspond to a closure ID, returns None.\n pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                                 closure_id: ast::DefId,\n-                                                                substs: &Substs)\n+                                                                substs: &Substs<'tcx>)\n                                                                 -> Option<ValueRef> {\n     let ccx = bcx.ccx();\n     if !ccx.tcx().unboxed_closures.borrow().contains_key(&closure_id) {\n@@ -435,7 +469,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk,\n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n     let function_type = ty::normalize_ty(bcx.tcx(), function_type);\n-    let params = match ty::get(function_type).sty {\n+    let params = match function_type.sty {\n         ty::ty_unboxed_closure(_, _, ref substs) => substs.types.clone(),\n         _ => unreachable!()\n     };\n@@ -486,7 +520,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n     let llfn = get_or_create_declaration_if_unboxed_closure(\n         bcx,\n         closure_id,\n-        bcx.fcx.param_substs.substs()).unwrap();\n+        bcx.fcx.param_substs).unwrap();\n \n     let function_type = (*bcx.tcx().unboxed_closures.borrow())[closure_id]\n                                                               .closure_type\n@@ -495,7 +529,6 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n \n     let freevars: Vec<ty::Freevar> =\n         ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n-    let freevars_ptr = &freevars;\n     let freevar_mode = bcx.tcx().capture_mode(id);\n \n     trans_closure(bcx.ccx(),\n@@ -507,15 +540,8 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                   &[],\n                   ty::ty_fn_ret(function_type),\n                   ty::ty_fn_abi(function_type),\n-                  true,\n-                  IsUnboxedClosure,\n-                  |bcx, arg_scope| {\n-                      load_unboxed_closure_environment(bcx,\n-                                                       arg_scope,\n-                                                       freevar_mode,\n-                                                       freevars_ptr,\n-                                                       closure_id)\n-                  });\n+                  ClosureEnv::new(freevars.as_slice(),\n+                                  UnboxedClosure(freevar_mode)));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size unboxed closure (in which case dest will be\n@@ -531,7 +557,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n     let repr = adt::represent_type(bcx.ccx(), node_id_type(bcx, id));\n \n     // Create the closure.\n-    for (i, freevar) in freevars_ptr.iter().enumerate() {\n+    for (i, freevar) in freevars.iter().enumerate() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n         let upvar_slot_dest = adt::trans_field_ptr(bcx,\n                                                    &*repr,\n@@ -552,11 +578,11 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n     bcx\n }\n \n-pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n-                               closure_ty: ty::t,\n-                               def: def::Def,\n-                               fn_ptr: ValueRef,\n-                               is_local: bool) -> ValueRef {\n+pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                         closure_ty: Ty<'tcx>,\n+                                         def: def::Def,\n+                                         fn_ptr: ValueRef,\n+                                         is_local: bool) -> ValueRef {\n \n     let def_id = match def {\n         def::DefFn(did, _) | def::DefStaticMethod(did, _) |\n@@ -578,7 +604,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n \n     debug!(\"get_wrapper_for_bare_fn(closure_ty={})\", closure_ty.repr(tcx));\n \n-    let f = match ty::get(closure_ty).sty {\n+    let f = match closure_ty.sty {\n         ty::ty_closure(ref f) => f,\n         _ => {\n             ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n@@ -607,7 +633,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n     let _icx = push_ctxt(\"closure::get_wrapper_for_bare_fn\");\n \n     let arena = TypedArena::new();\n-    let empty_param_substs = param_substs::empty();\n+    let empty_param_substs = Substs::trans_empty();\n     let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, true, f.sig.output,\n                           &empty_param_substs, None, &arena);\n     let bcx = init_function(&fcx, true, f.sig.output);\n@@ -647,7 +673,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n }\n \n pub fn make_closure_from_bare_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                             closure_ty: ty::t,\n+                                             closure_ty: Ty<'tcx>,\n                                              def: def::Def,\n                                              fn_ptr: ValueRef)\n                                              -> DatumBlock<'blk, 'tcx, Expr>  {"}, {"sha": "9cd249f1e005dd106cd2114197899591de6696a8", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 38, "deletions": 77, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -22,7 +22,7 @@ use middle::def;\n use middle::lang_items::LangItem;\n use middle::mem_categorization as mc;\n use middle::subst;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, Substs};\n use trans::base;\n use trans::build;\n use trans::cleanup;\n@@ -32,7 +32,7 @@ use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n use middle::traits;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use middle::ty_fold;\n use middle::ty_fold::TypeFoldable;\n use middle::typeck;\n@@ -55,8 +55,9 @@ use syntax::parse::token;\n \n pub use trans::context::CrateContext;\n \n-fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n-    match ty::get(ty).sty {\n+fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                       ty: Ty<'tcx>) -> bool {\n+    match ty.sty {\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n             fields.len() == 1 &&\n@@ -68,7 +69,7 @@ fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     }\n }\n \n-pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n+pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     use trans::machine::llsize_of_alloc;\n     use trans::type_of::sizing_type_of;\n \n@@ -83,7 +84,7 @@ pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     if !ty::type_is_sized(tcx, ty) {\n         return false;\n     }\n-    match ty::get(ty).sty {\n+    match ty.sty {\n         ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n         ty::ty_unboxed_closure(..) => {\n             let llty = sizing_type_of(ccx, ty);\n@@ -93,7 +94,7 @@ pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     }\n }\n \n-pub fn type_is_zero_size(ccx: &CrateContext, ty: ty::t) -> bool {\n+pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     /*!\n      * Identify types which have size zero at runtime.\n      */\n@@ -104,7 +105,7 @@ pub fn type_is_zero_size(ccx: &CrateContext, ty: ty::t) -> bool {\n     llsize_of_alloc(ccx, llty) == 0\n }\n \n-pub fn return_type_is_void(ccx: &CrateContext, ty: ty::t) -> bool {\n+pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n     /*!\n      * Identifies types which we declare to be equivalent to `void`\n      * in C for the purpose of function return types. These are\n@@ -125,8 +126,8 @@ pub fn gensym_name(name: &str) -> PathElem {\n     PathName(token::gensym(format!(\"{}:{}\", name, num).as_slice()))\n }\n \n-pub struct tydesc_info {\n-    pub ty: ty::t,\n+pub struct tydesc_info<'tcx> {\n+    pub ty: Ty<'tcx>,\n     pub tydesc: ValueRef,\n     pub size: ValueRef,\n     pub align: ValueRef,\n@@ -188,55 +189,13 @@ pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n \n pub type ExternMap = FnvHashMap<String, ValueRef>;\n \n-// Here `self_ty` is the real type of the self parameter to this method. It\n-// will only be set in the case of default methods.\n-pub struct param_substs {\n-    substs: subst::Substs,\n-}\n-\n-impl param_substs {\n-    pub fn new(substs: subst::Substs) -> param_substs {\n-        assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n-        assert!(substs.types.all(|t| !ty::type_has_params(*t)));\n-        assert!(substs.types.all(|t| !ty::type_has_escaping_regions(*t)));\n-        param_substs { substs: substs.erase_regions() }\n-    }\n-\n-    pub fn substs(&self) -> &subst::Substs {\n-        &self.substs\n-    }\n-\n-    pub fn empty() -> param_substs {\n-        param_substs {\n-            substs: subst::Substs::trans_empty(),\n-        }\n-    }\n-\n-    pub fn validate(&self) {\n-        assert!(self.substs.types.all(|t| !ty::type_needs_infer(*t)));\n-    }\n-}\n-\n-impl Repr for param_substs {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        self.substs.repr(tcx)\n-    }\n-}\n-\n-pub trait SubstP {\n-    fn substp(&self, tcx: &ty::ctxt, param_substs: &param_substs)\n-              -> Self;\n-}\n-\n-impl<T: Subst + Clone> SubstP for T {\n-    fn substp(&self, tcx: &ty::ctxt, substs: &param_substs) -> T {\n-        self.subst(tcx, &substs.substs)\n-    }\n+pub fn validate_substs(substs: &Substs) {\n+    assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n }\n \n // work around bizarre resolve errors\n-pub type RvalueDatum = datum::Datum<datum::Rvalue>;\n-pub type LvalueDatum = datum::Datum<datum::Lvalue>;\n+pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n+pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n \n // Function context.  Every LLVM function we create will have one of\n // these.\n@@ -280,7 +239,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n     // Maps the DefId's for local variables to the allocas created for\n     // them in llallocas.\n-    pub lllocals: RefCell<NodeMap<LvalueDatum>>,\n+    pub lllocals: RefCell<NodeMap<LvalueDatum<'tcx>>>,\n \n     // Same as above, but for closure upvars\n     pub llupvars: RefCell<NodeMap<ValueRef>>,\n@@ -291,7 +250,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n-    pub param_substs: &'a param_substs,\n+    pub param_substs: &'a Substs<'tcx>,\n \n     // The source span and nesting context where this function comes from, for\n     // error reporting and symbol generation.\n@@ -354,7 +313,9 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         self.llreturn.get().unwrap()\n     }\n \n-    pub fn get_ret_slot(&self, bcx: Block, output: ty::FnOutput, name: &str) -> ValueRef {\n+    pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>,\n+                        output: ty::FnOutput<'tcx>,\n+                        name: &str) -> ValueRef {\n         if self.needs_ret_allocas {\n             base::alloca_no_lifetime(bcx, match output {\n                 ty::FnConverging(output_type) => type_of::type_of(bcx.ccx(), output_type),\n@@ -495,7 +456,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.ccx().tn().type_to_string(ty)\n     }\n \n-    pub fn ty_to_string(&self, t: ty::t) -> String {\n+    pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n         t.repr(self.tcx())\n     }\n \n@@ -509,19 +470,19 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx()\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n         Ok(node_id_type(self, id))\n     }\n \n-    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<Ty<'tcx>> {\n         self.tcx()\n             .method_map\n             .borrow()\n             .get(&method_call)\n             .map(|method| monomorphize_type(self, method.ty))\n     }\n \n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.tcx().adjustments\n     }\n \n@@ -534,7 +495,7 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n \n     fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure>> {\n+                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n         &self.tcx().unboxed_closures\n     }\n \n@@ -788,28 +749,28 @@ pub fn is_null(val: ValueRef) -> bool {\n     }\n }\n \n-pub fn monomorphize_type(bcx: &BlockS, t: ty::t) -> ty::t {\n-    t.subst(bcx.tcx(), &bcx.fcx.param_substs.substs)\n+pub fn monomorphize_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n+    t.subst(bcx.tcx(), bcx.fcx.param_substs)\n }\n \n-pub fn node_id_type(bcx: &BlockS, id: ast::NodeId) -> ty::t {\n+pub fn node_id_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty(bcx: Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted(bcx: Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n     monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n }\n \n-pub fn fulfill_obligation(ccx: &CrateContext,\n-                          span: Span,\n-                          trait_ref: Rc<ty::TraitRef>)\n-                          -> traits::Vtable<()>\n+pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    span: Span,\n+                                    trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                                    -> traits::Vtable<'tcx, ()>\n {\n     /*!\n      * Attempts to resolve an obligation. The result is a shallow\n@@ -923,9 +884,9 @@ pub enum ExprOrMethodCall {\n     MethodCall(typeck::MethodCall)\n }\n \n-pub fn node_id_substs(bcx: Block,\n-                      node: ExprOrMethodCall)\n-                      -> subst::Substs\n+pub fn node_id_substs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  node: ExprOrMethodCall)\n+                                  -> subst::Substs<'tcx>\n {\n     let tcx = bcx.tcx();\n \n@@ -947,7 +908,7 @@ pub fn node_id_substs(bcx: Block,\n     }\n \n     let substs = substs.erase_regions();\n-    substs.substp(tcx, bcx.fcx.param_substs)\n+    substs.subst(tcx, bcx.fcx.param_substs)\n }\n \n pub fn langcall(bcx: Block,"}, {"sha": "4213e9417276c8ac447810b58bef2ffd9c774446", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -29,7 +29,7 @@ use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n use trans::debuginfo;\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use util::ppaux::{Repr, ty_to_string};\n \n use std::c_str::ToCStr;\n@@ -52,7 +52,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         }\n         ast::LitInt(i, ast::UnsuffixedIntLit(_)) => {\n             let lit_int_ty = ty::node_id_to_type(cx.tcx(), e.id);\n-            match ty::get(lit_int_ty).sty {\n+            match lit_int_ty.sty {\n                 ty::ty_int(t) => {\n                     C_integral(Type::int_from_ty(cx, t), i as u64, true)\n                 }\n@@ -70,7 +70,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         }\n         ast::LitFloatUnsuffixed(ref fs) => {\n             let lit_float_ty = ty::node_id_to_type(cx.tcx(), e.id);\n-            match ty::get(lit_float_ty).sty {\n+            match lit_float_ty.sty {\n                 ty::ty_float(t) => {\n                     C_floating(fs.get(), Type::float_from_ty(cx, t))\n                 }\n@@ -133,17 +133,18 @@ fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_newtype(cx: &CrateContext, v: ValueRef, t: ty::t)\n+fn const_deref_newtype<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef, t: Ty<'tcx>)\n     -> ValueRef {\n     let repr = adt::represent_type(cx, t);\n     adt::const_get_field(cx, &*repr, v, 0, 0)\n }\n \n-fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n-    -> (ValueRef, ty::t) {\n+fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef,\n+                         t: Ty<'tcx>, explicit: bool)\n+                         -> (ValueRef, Ty<'tcx>) {\n     match ty::deref(t, explicit) {\n         Some(ref mt) => {\n-            match ty::get(t).sty {\n+            match t.sty {\n                 ty::ty_ptr(mt) | ty::ty_rptr(_, mt) => {\n                     if ty::type_is_sized(cx.tcx(), mt.ty) {\n                         (const_deref_ptr(cx, v), mt.ty)\n@@ -187,7 +188,8 @@ pub fn get_const_val(cx: &CrateContext,\n     cx.const_values().borrow()[def_id.node].clone()\n }\n \n-pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n+pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n+                            -> (ValueRef, Ty<'tcx>) {\n     let llconst = const_expr_unadjusted(cx, e);\n     let mut llconst = llconst;\n     let ety = ty::expr_ty(cx.tcx(), e);\n@@ -258,7 +260,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n                                         llconst = const_addr_of(cx, llconst, ast::MutImmutable)\n                                     }\n \n-                                    match ty::get(ty).sty {\n+                                    match ty.sty {\n                                         ty::ty_vec(unit_ty, Some(len)) => {\n                                             let llunitty = type_of::type_of(cx, unit_ty);\n                                             let llptr = const_ptrcast(cx, llconst, llunitty);\n@@ -440,9 +442,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   _ => cx.sess().span_bug(index.span,\n                                           \"index is not an integer-constant expression\")\n               };\n-              let (arr, len) = match ty::get(bt).sty {\n+              let (arr, len) = match bt.sty {\n                   ty::ty_vec(_, Some(u)) => (bv, C_uint(cx, u)),\n-                  ty::ty_open(ty) => match ty::get(ty).sty {\n+                  ty::ty_open(ty) => match ty.sty {\n                       ty::ty_vec(_, None) | ty::ty_str => {\n                           let e1 = const_get_elt(cx, bv, &[0]);\n                           (const_deref_ptr(cx, e1), const_get_elt(cx, bv, &[1]))\n@@ -452,7 +454,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                                                        or string type, found {}\",\n                                                       ty_to_string(cx.tcx(), bt)).as_slice())\n                   },\n-                  ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+                  ty::ty_rptr(_, mt) => match mt.ty.sty {\n                       ty::ty_vec(_, Some(u)) => {\n                           (const_deref_ptr(cx, bv), C_uint(cx, u))\n                       },\n@@ -468,8 +470,8 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n-              let len = match ty::get(bt).sty {\n-                  ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+              let len = match bt.sty {\n+                  ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty.sty {\n                       ty::ty_str => {\n                           assert!(len > 0);\n                           len - 1\n@@ -725,7 +727,8 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n     }\n }\n \n-fn get_static_val(ccx: &CrateContext, did: ast::DefId, ty: ty::t) -> ValueRef {\n+fn get_static_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n+                            ty: Ty<'tcx>) -> ValueRef {\n     if ast_util::is_local(did) { return base::get_item_val(ccx, did.node) }\n     base::trans_external_path(ccx, did, ty)\n }"}, {"sha": "4822299d1488614336f4b54eb77cacb52a31d522", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d", "patch": "@@ -22,7 +22,7 @@ use trans::common::{ExternMap,tydesc_info,BuilderRef_res};\n use trans::debuginfo;\n use trans::monomorphize::MonoId;\n use trans::type_::{Type, TypeNames};\n-use middle::ty;\n+use middle::ty::{mod, Ty};\n use session::config::NoDebugInfo;\n use session::Session;\n use util::ppaux::Repr;\n@@ -56,7 +56,7 @@ pub struct Stats {\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n pub struct SharedCrateContext<'tcx> {\n-    local_ccxs: Vec<LocalCrateContext>,\n+    local_ccxs: Vec<LocalCrateContext<'tcx>>,\n \n     metadata_llmod: ModuleRef,\n     metadata_llcx: ContextRef,\n@@ -70,22 +70,22 @@ pub struct SharedCrateContext<'tcx> {\n     stats: Stats,\n \n     available_monomorphizations: RefCell<FnvHashSet<String>>,\n-    available_drop_glues: RefCell<FnvHashMap<ty::t, String>>,\n+    available_drop_glues: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n /// per compilation unit.  Each one has its own LLVM `ContextRef` so that\n /// several compilation units may be optimized in parallel.  All other LLVM\n /// data structures in the `LocalCrateContext` are tied to that `ContextRef`.\n-pub struct LocalCrateContext {\n+pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     td: TargetData,\n     tn: TypeNames,\n     externs: RefCell<ExternMap>,\n     item_vals: RefCell<NodeMap<ValueRef>>,\n-    drop_glues: RefCell<FnvHashMap<ty::t, ValueRef>>,\n-    tydescs: RefCell<FnvHashMap<ty::t, Rc<tydesc_info>>>,\n+    drop_glues: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n+    tydescs: RefCell<FnvHashMap<Ty<'tcx>, Rc<tydesc_info<'tcx>>>>,\n     /// Set when running emit_tydescs to enforce that no more tydescs are\n     /// created.\n     finished_tydescs: Cell<bool>,\n@@ -95,10 +95,10 @@ pub struct LocalCrateContext {\n     /// came from)\n     external_srcs: RefCell<NodeMap<ast::DefId>>,\n     /// Cache instances of monomorphized functions\n-    monomorphized: RefCell<FnvHashMap<MonoId, ValueRef>>,\n+    monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FnvHashMap<(ty::t,Rc<ty::TraitRef>), ValueRef>>,\n+    vtables: RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::TraitRef<'tcx>>), ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n \n@@ -126,19 +126,19 @@ pub struct LocalCrateContext {\n     /// Cache of closure wrappers for bare fn's.\n     closure_bare_wrapper_cache: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n \n-    lltypes: RefCell<FnvHashMap<ty::t, Type>>,\n-    llsizingtypes: RefCell<FnvHashMap<ty::t, Type>>,\n-    adt_reprs: RefCell<FnvHashMap<ty::t, Rc<adt::Repr>>>,\n-    type_hashcodes: RefCell<FnvHashMap<ty::t, String>>,\n+    lltypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n+    llsizingtypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n+    adt_reprs: RefCell<FnvHashMap<Ty<'tcx>, Rc<adt::Repr<'tcx>>>>,\n+    type_hashcodes: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n     all_llvm_symbols: RefCell<FnvHashSet<String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n     builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    unboxed_closure_vals: RefCell<FnvHashMap<MonoId, ValueRef>>,\n+    unboxed_closure_vals: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n \n-    dbg_cx: Option<debuginfo::CrateDebugContext>,\n+    dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n     eh_personality: RefCell<Option<ValueRef>>,\n \n@@ -149,13 +149,13 @@ pub struct LocalCrateContext {\n     /// contexts around the same size.\n     n_llvm_insns: Cell<uint>,\n \n-    trait_cache: RefCell<FnvHashMap<Rc<ty::TraitRef>,\n-                                    traits::Vtable<()>>>,\n+    trait_cache: RefCell<FnvHashMap<Rc<ty::TraitRef<'tcx>>,\n+                                    traits::Vtable<'tcx, ()>>>,\n }\n \n pub struct CrateContext<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'tcx>,\n-    local: &'a LocalCrateContext,\n+    local: &'a LocalCrateContext<'tcx>,\n     /// The index of `local` in `shared.local_ccxs`.  This is used in\n     /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n     index: uint,\n@@ -367,10 +367,10 @@ impl<'tcx> SharedCrateContext<'tcx> {\n     }\n }\n \n-impl LocalCrateContext {\n-    fn new(shared: &SharedCrateContext,\n+impl<'tcx> LocalCrateContext<'tcx> {\n+    fn new(shared: &SharedCrateContext<'tcx>,\n            name: &str)\n-           -> LocalCrateContext {\n+           -> LocalCrateContext<'tcx> {\n         unsafe {\n             let (llcx, llmod) = create_context_and_module(&shared.tcx.sess, name);\n \n@@ -456,8 +456,8 @@ impl LocalCrateContext {\n     /// This is used in the `LocalCrateContext` constructor to allow calling\n     /// functions that expect a complete `CrateContext`, even before the local\n     /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx<'a, 'tcx>(&'a self, shared: &'a SharedCrateContext<'tcx>)\n-                           -> CrateContext<'a, 'tcx> {\n+    fn dummy_ccx<'a>(&'a self, shared: &'a SharedCrateContext<'tcx>)\n+                     -> CrateContext<'a, 'tcx> {\n         CrateContext {\n             shared: shared,\n             local: self,\n@@ -471,7 +471,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared\n     }\n \n-    pub fn local(&self) -> &'b LocalCrateContext {\n+    pub fn local(&self) -> &'b LocalCrateContext<'tcx> {\n         self.local\n     }\n \n@@ -574,11 +574,11 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.link_meta\n     }\n \n-    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, ValueRef>> {\n+    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n         &self.local.drop_glues\n     }\n \n-    pub fn tydescs<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, Rc<tydesc_info>>> {\n+    pub fn tydescs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Rc<tydesc_info<'tcx>>>> {\n         &self.local.tydescs\n     }\n \n@@ -594,15 +594,16 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.external_srcs\n     }\n \n-    pub fn monomorphized<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId, ValueRef>> {\n+    pub fn monomorphized<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>> {\n         &self.local.monomorphized\n     }\n \n     pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<uint>> {\n         &self.local.monomorphizing\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(ty::t,Rc<ty::TraitRef>), ValueRef>> {\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::TraitRef<'tcx>>),\n+                                                            ValueRef>> {\n         &self.local.vtables\n     }\n \n@@ -635,23 +636,23 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.closure_bare_wrapper_cache\n     }\n \n-    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, Type>> {\n+    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n         &self.local.lltypes\n     }\n \n-    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, Type>> {\n+    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n         &self.local.llsizingtypes\n     }\n \n-    pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, Rc<adt::Repr>>> {\n+    pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Rc<adt::Repr<'tcx>>>> {\n         &self.local.adt_reprs\n     }\n \n     pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n         &self.shared.symbol_hasher\n     }\n \n-    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, String>> {\n+    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n         &self.local.type_hashcodes\n     }\n \n@@ -667,7 +668,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.available_monomorphizations\n     }\n \n-    pub fn available_drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::t, String>> {\n+    pub fn available_drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n         &self.shared.available_drop_glues\n     }\n \n@@ -679,11 +680,11 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.opaque_vec_type\n     }\n \n-    pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId,ValueRef>> {\n+    pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId<'tcx>,ValueRef>> {\n         &self.local.unboxed_closure_vals\n     }\n \n-    pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext> {\n+    pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {\n         &self.local.dbg_cx\n     }\n \n@@ -699,15 +700,16 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n     }\n \n-    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<Rc<ty::TraitRef>, traits::Vtable<()>>> {\n+    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<Rc<ty::TraitRef<'tcx>>,\n+                                                     traits::Vtable<'tcx, ()>>> {\n         &self.local.trait_cache\n     }\n \n     pub fn max_obj_size(&self) -> u64 {\n         1<<31 /* FIXME #18069: select based on architecture */\n     }\n \n-    pub fn report_overbig_object(&self, obj: ty::t) -> ! {\n+    pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n         self.sess().fatal(\n             format!(\"the type `{}` is too big for the current architecture\",\n                     obj.repr(self.tcx())).as_slice())"}, {"sha": "354a6072207156f9ca5d622532ed1ffa8a198784", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "7b3f619f41f1a5139db159e0b70173dd6903dc20", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 206, "deletions": 199, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "a5281e582f13651e9771e2f9b7a0d7d4f847184e", "filename": "src/librustc_trans/trans/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdoc.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "8ccc59831993ac3f2919e1d4c221080b049b5f1a", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 61, "deletions": 63, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "1f6aeacc860586cad25b8d3980aabebe08a67d89", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "67b3310dbdf88d25cf30711634ab75b95bb8bb37", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "bde9051ec74d6a65c5a95aaa07f81445a688fc87", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "6bdb35f8d6074dc345f03e62a63492f6391b0401", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "0311d37c3de524cf1f1c0bcd522fb3904f7808ca", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "bf7d560fdaa598ed01d0083ababa652f7032f58a", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "359f74bdbf134d866fc1df7a27054422ed9aa8c1", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "31e8130dd751334b982bd9e786239af68cbc8b56", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "16edccd154302ce4118d4a653536ef6e9b28c1dd", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}, {"sha": "209d8c7ca0f29395142f9d5e48c3f38cc60e4ece", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7df1e6382e239619a8447719c3c19787d7b60d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=cf7df1e6382e239619a8447719c3c19787d7b60d"}]}