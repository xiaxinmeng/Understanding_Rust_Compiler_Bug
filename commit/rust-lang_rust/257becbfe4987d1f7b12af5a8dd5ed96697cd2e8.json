{"sha": "257becbfe4987d1f7b12af5a8dd5ed96697cd2e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1N2JlY2JmZTQ5ODdkMWY3YjEyYWY1YThkZDVlZDk2Njk3Y2QyZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-27T18:55:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-27T18:55:33Z"}, "message": "Auto merge of #80181 - jyn514:intra-doc-primitives, r=Manishearth\n\nFix intra-doc links for non-path primitives\n\nThis does *not* currently work for associated items that are\nauto-implemented by the compiler (e.g. `never::eq`), because they aren't\npresent in the source code. I plan to fix this in a follow-up PR.\n\nFixes https://github.com/rust-lang/rust/issues/63351 using the approach mentioned in https://github.com/rust-lang/rust/issues/63351#issuecomment-683352130.\n\nr? `@Manishearth`\n\ncc `@petrochenkov` - this makes `rustc_resolve::Res` public, is that ok? I'd just add an identical type alias in rustdoc if not, which seems a waste.", "tree": {"sha": "9e92950cce2d79e9fc34d90bd53514a2ac8b2923", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e92950cce2d79e9fc34d90bd53514a2ac8b2923"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8", "html_url": "https://github.com/rust-lang/rust/commit/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76188b6830897a875a1289809c12b5c5d69bb7ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/76188b6830897a875a1289809c12b5c5d69bb7ef", "html_url": "https://github.com/rust-lang/rust/commit/76188b6830897a875a1289809c12b5c5d69bb7ef"}, {"sha": "6ac52f0d9dc2f3f8a423e3b54663f42ac4ebab05", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac52f0d9dc2f3f8a423e3b54663f42ac4ebab05", "html_url": "https://github.com/rust-lang/rust/commit/6ac52f0d9dc2f3f8a423e3b54663f42ac4ebab05"}], "stats": {"total": 453, "additions": 322, "deletions": 131}, "files": [{"sha": "4126c8b714f7a50f9f7e8f47e999cec394d99980", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=257becbfe4987d1f7b12af5a8dd5ed96697cd2e8", "patch": "@@ -175,7 +175,7 @@\n //! [`str`]: prim@str\n //! [`mpsc`]: sync::mpsc\n //! [`std::cmp`]: cmp\n-//! [`std::slice`]: slice\n+//! [`std::slice`]: mod@slice\n //! [`use std::env`]: env/index.html\n //! [`use`]: ../book/ch07-02-defining-modules-to-control-scope-and-privacy.html\n //! [crates.io]: https://crates.io\n@@ -185,7 +185,8 @@\n //! [other]: #what-is-in-the-standard-library-documentation\n //! [primitive types]: ../book/ch03-02-data-types.html\n //! [rust-discord]: https://discord.gg/rust-lang\n-\n+#![cfg_attr(not(bootstrap), doc = \"[array]: prim@array\")]\n+#![cfg_attr(not(bootstrap), doc = \"[slice]: prim@slice\")]\n #![cfg_attr(not(feature = \"restricted-std\"), stable(feature = \"rust1\", since = \"1.0.0\"))]\n #![cfg_attr(feature = \"restricted-std\", unstable(feature = \"restricted_std\", issue = \"none\"))]\n #![doc("}, {"sha": "2d26e3b71cac38072e2ccd9294e27b7d78b20918", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 177, "deletions": 129, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=257becbfe4987d1f7b12af5a8dd5ed96697cd2e8", "patch": "@@ -10,24 +10,24 @@ use rustc_hir as hir;\n use rustc_hir::def::{\n     DefKind,\n     Namespace::{self, *},\n-    PerNS, Res,\n+    PerNS,\n };\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_middle::ty;\n+use rustc_middle::{bug, ty};\n use rustc_resolve::ParentScope;\n use rustc_session::lint::{\n     builtin::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS},\n     Lint,\n };\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::symbol::sym;\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n use smallvec::{smallvec, SmallVec};\n \n use std::borrow::Cow;\n use std::cell::Cell;\n+use std::convert::{TryFrom, TryInto};\n use std::mem;\n use std::ops::Range;\n \n@@ -61,6 +61,71 @@ impl<'a> From<ResolutionFailure<'a>> for ErrorKind<'a> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, Hash)]\n+enum Res {\n+    Def(DefKind, DefId),\n+    Primitive(PrimitiveType),\n+}\n+\n+type ResolveRes = rustc_hir::def::Res<rustc_ast::NodeId>;\n+\n+impl Res {\n+    fn descr(self) -> &'static str {\n+        match self {\n+            Res::Def(kind, id) => ResolveRes::Def(kind, id).descr(),\n+            Res::Primitive(_) => \"builtin type\",\n+        }\n+    }\n+\n+    fn article(self) -> &'static str {\n+        match self {\n+            Res::Def(kind, id) => ResolveRes::Def(kind, id).article(),\n+            Res::Primitive(_) => \"a\",\n+        }\n+    }\n+\n+    fn name(self, tcx: ty::TyCtxt<'_>) -> String {\n+        match self {\n+            Res::Def(_, id) => tcx.item_name(id).to_string(),\n+            Res::Primitive(prim) => prim.as_str().to_string(),\n+        }\n+    }\n+\n+    fn def_id(self) -> DefId {\n+        self.opt_def_id().expect(\"called def_id() on a primitive\")\n+    }\n+\n+    fn opt_def_id(self) -> Option<DefId> {\n+        match self {\n+            Res::Def(_, id) => Some(id),\n+            Res::Primitive(_) => None,\n+        }\n+    }\n+\n+    fn as_hir_res(self) -> Option<rustc_hir::def::Res> {\n+        match self {\n+            Res::Def(kind, id) => Some(rustc_hir::def::Res::Def(kind, id)),\n+            // FIXME: maybe this should handle the subset of PrimitiveType that fits into hir::PrimTy?\n+            Res::Primitive(_) => None,\n+        }\n+    }\n+}\n+\n+impl TryFrom<ResolveRes> for Res {\n+    type Error = ();\n+\n+    fn try_from(res: ResolveRes) -> Result<Self, ()> {\n+        use rustc_hir::def::Res::*;\n+        match res {\n+            Def(kind, id) => Ok(Res::Def(kind, id)),\n+            PrimTy(prim) => Ok(Res::Primitive(PrimitiveType::from_hir(prim))),\n+            // e.g. `#[derive]`\n+            NonMacroAttr(..) | Err => Result::Err(()),\n+            other => bug!(\"unrecognized res {:?}\", other),\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n /// A link failed to resolve.\n enum ResolutionFailure<'a> {\n@@ -253,12 +318,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             .enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n             })\n-            .map(|(_, res)| res)\n-            .unwrap_or(Res::Err);\n-        if let Res::Err = ty_res {\n-            return Err(no_res().into());\n-        }\n-        let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n+            .and_then(|(_, res)| res.try_into())\n+            .map_err(|()| no_res())?;\n+\n         match ty_res {\n             Res::Def(DefKind::Enum, did) => {\n                 if cx\n@@ -309,15 +371,15 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// lifetimes on `&'path` will work.\n     fn resolve_primitive_associated_item(\n         &self,\n-        prim_ty: hir::PrimTy,\n+        prim_ty: PrimitiveType,\n         ns: Namespace,\n         module_id: DefId,\n         item_name: Symbol,\n         item_str: &'path str,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n \n-        PrimitiveType::from_hir(prim_ty)\n+        prim_ty\n             .impls(cx.tcx)\n             .into_iter()\n             .find_map(|&impl_| {\n@@ -336,21 +398,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     })\n                     .map(|out| {\n                         (\n-                            Res::PrimTy(prim_ty),\n-                            Some(format!(\"{}#{}.{}\", prim_ty.name(), out, item_str)),\n+                            Res::Primitive(prim_ty),\n+                            Some(format!(\"{}#{}.{}\", prim_ty.as_str(), out, item_str)),\n                         )\n                     })\n             })\n             .ok_or_else(|| {\n                 debug!(\n                     \"returning primitive error for {}::{} in {} namespace\",\n-                    prim_ty.name(),\n+                    prim_ty.as_str(),\n                     item_name,\n                     ns.descr()\n                 );\n                 ResolutionFailure::NotResolved {\n                     module_id,\n-                    partial_res: Some(Res::PrimTy(prim_ty)),\n+                    partial_res: Some(Res::Primitive(prim_ty)),\n                     unresolved: item_str.into(),\n                 }\n                 .into()\n@@ -377,19 +439,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 false,\n             ) {\n                 if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n-                    return Ok(res.map_id(|_| panic!(\"unexpected id\")));\n+                    return Ok(res.try_into().unwrap());\n                 }\n             }\n-            if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-                return Ok(res.map_id(|_| panic!(\"unexpected id\")));\n+            if let Some(&res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n+                return Ok(res.try_into().unwrap());\n             }\n             debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n             if let Ok((_, res)) =\n                 resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n             {\n                 // don't resolve builtins like `#[derive]`\n-                if let Res::Def(..) = res {\n-                    let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+                if let Ok(res) = res.try_into() {\n                     return Ok(res);\n                 }\n             }\n@@ -408,14 +469,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// Associated items will never be resolved by this function.\n     fn resolve_path(&self, path_str: &str, ns: Namespace, module_id: DefId) -> Option<Res> {\n         let result = self.cx.enter_resolver(|resolver| {\n-            resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n+            resolver\n+                .resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n+                .and_then(|(_, res)| res.try_into())\n         });\n         debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n-        match result.map(|(_, res)| res) {\n-            // resolver doesn't know about true and false so we'll have to resolve them\n+        match result {\n+            // resolver doesn't know about true, false, and types that aren't paths (e.g. `()`)\n             // manually as bool\n-            Ok(Res::Err) | Err(()) => is_bool_value(path_str, ns).map(|(_, res)| res),\n-            Ok(res) => Some(res.map_id(|_| panic!(\"unexpected node_id\"))),\n+            Err(()) => resolve_primitive(path_str, ns),\n+            Ok(res) => Some(res),\n         }\n     }\n \n@@ -444,13 +507,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     return handle_variant(cx, res, extra_fragment);\n                 }\n                 // Not a trait item; just return what we found.\n-                Res::PrimTy(ty) => {\n+                Res::Primitive(ty) => {\n                     if extra_fragment.is_some() {\n                         return Err(ErrorKind::AnchorFailure(\n                             AnchorFailure::RustdocAnchorConflict(res),\n                         ));\n                     }\n-                    return Ok((res, Some(ty.name_str().to_owned())));\n+                    return Ok((res, Some(ty.as_str().to_owned())));\n                 }\n                 Res::Def(DefKind::Mod, _) => {\n                     return Ok((res, extra_fragment.clone()));\n@@ -483,7 +546,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n         // FIXME: are these both necessary?\n         let ty_res = if let Some(ty_res) = resolve_primitive(&path_root, TypeNS)\n-            .map(|(_, res)| res)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n         {\n             ty_res\n@@ -502,7 +564,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         };\n \n         let res = match ty_res {\n-            Res::PrimTy(prim) => Some(\n+            Res::Primitive(prim) => Some(\n                 self.resolve_primitive_associated_item(prim, ns, module_id, item_name, item_str),\n             ),\n             Res::Def(\n@@ -958,7 +1020,7 @@ impl LinkCollector<'_, '_> {\n             (link.trim(), None)\n         };\n \n-        if path_str.contains(|ch: char| !(ch.is_alphanumeric() || \":_<>, !\".contains(ch))) {\n+        if path_str.contains(|ch: char| !(ch.is_alphanumeric() || \":_<>, !*&;\".contains(ch))) {\n             return None;\n         }\n \n@@ -1046,9 +1108,8 @@ impl LinkCollector<'_, '_> {\n         // Sanity check to make sure we don't have any angle brackets after stripping generics.\n         assert!(!path_str.contains(['<', '>'].as_slice()));\n \n-        // The link is not an intra-doc link if it still contains commas or spaces after\n-        // stripping generics.\n-        if path_str.contains([',', ' '].as_slice()) {\n+        // The link is not an intra-doc link if it still contains spaces after stripping generics.\n+        if path_str.contains(' ') {\n             return None;\n         }\n \n@@ -1068,9 +1129,9 @@ impl LinkCollector<'_, '_> {\n         if matches!(\n             disambiguator,\n             None | Some(Disambiguator::Namespace(Namespace::TypeNS) | Disambiguator::Primitive)\n-        ) && !matches!(res, Res::PrimTy(_))\n+        ) && !matches!(res, Res::Primitive(_))\n         {\n-            if let Some((path, prim)) = resolve_primitive(path_str, TypeNS) {\n+            if let Some(prim) = resolve_primitive(path_str, TypeNS) {\n                 // `prim@char`\n                 if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n                     if fragment.is_some() {\n@@ -1085,7 +1146,7 @@ impl LinkCollector<'_, '_> {\n                         return None;\n                     }\n                     res = prim;\n-                    fragment = Some(path.as_str().to_string());\n+                    fragment = Some(prim.name(self.cx.tcx));\n                 } else {\n                     // `[char]` when a `char` module is in scope\n                     let candidates = vec![res, prim];\n@@ -1111,21 +1172,20 @@ impl LinkCollector<'_, '_> {\n             };\n             report_diagnostic(cx, BROKEN_INTRA_DOC_LINKS, &msg, &item, dox, &link_range, callback);\n         };\n-        if let Res::PrimTy(..) = res {\n-            match disambiguator {\n+        match res {\n+            Res::Primitive(_) => match disambiguator {\n                 Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n                     Some(ItemLink { link: ori_link, link_text, did: None, fragment })\n                 }\n                 Some(other) => {\n                     report_mismatch(other, Disambiguator::Primitive);\n                     None\n                 }\n-            }\n-        } else {\n-            debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n+            },\n+            Res::Def(kind, id) => {\n+                debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n \n-            // Disallow e.g. linking to enums with `struct@`\n-            if let Res::Def(kind, _) = res {\n+                // Disallow e.g. linking to enums with `struct@`\n                 debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n                 match (self.kind_side_channel.take().map(|(kind, _)| kind).unwrap_or(kind), disambiguator) {\n                     | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n@@ -1144,27 +1204,26 @@ impl LinkCollector<'_, '_> {\n                         return None;\n                     }\n                 }\n-            }\n \n-            // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n-            if let Some((src_id, dst_id)) = res\n-                .opt_def_id()\n-                .and_then(|def_id| def_id.as_local())\n-                .and_then(|dst_id| item.def_id.as_local().map(|src_id| (src_id, dst_id)))\n-            {\n-                use rustc_hir::def_id::LOCAL_CRATE;\n+                // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n+                if let Some((src_id, dst_id)) = id\n+                    .as_local()\n+                    .and_then(|dst_id| item.def_id.as_local().map(|src_id| (src_id, dst_id)))\n+                {\n+                    use rustc_hir::def_id::LOCAL_CRATE;\n \n-                let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n-                let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n+                    let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n+                    let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n \n-                if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n-                    && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n-                {\n-                    privacy_error(cx, &item, &path_str, dox, link_range);\n+                    if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n+                        && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n+                    {\n+                        privacy_error(cx, &item, &path_str, dox, link_range);\n+                    }\n                 }\n+                let id = clean::register_res(cx, rustc_hir::def::Res::Def(kind, id));\n+                Some(ItemLink { link: ori_link, link_text, did: Some(id), fragment })\n             }\n-            let id = clean::register_res(cx, res);\n-            Some(ItemLink { link: ori_link, link_text, did: Some(id), fragment })\n         }\n     }\n \n@@ -1296,16 +1355,18 @@ impl LinkCollector<'_, '_> {\n                     .and_then(|(res, fragment)| {\n                         // Constructors are picked up in the type namespace.\n                         match res {\n-                            Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => {\n+                            Res::Def(DefKind::Ctor(..), _) => {\n                                 Err(ResolutionFailure::WrongNamespace(res, TypeNS))\n                             }\n-                            _ => match (fragment, extra_fragment.clone()) {\n-                                (Some(fragment), Some(_)) => {\n-                                    // Shouldn't happen but who knows?\n-                                    Ok((res, Some(fragment)))\n+                            _ => {\n+                                match (fragment, extra_fragment.clone()) {\n+                                    (Some(fragment), Some(_)) => {\n+                                        // Shouldn't happen but who knows?\n+                                        Ok((res, Some(fragment)))\n+                                    }\n+                                    (fragment, None) | (None, fragment) => Ok((res, fragment)),\n                                 }\n-                                (fragment, None) | (None, fragment) => Ok((res, fragment)),\n-                            },\n+                            }\n                         }\n                     }),\n                 };\n@@ -1414,8 +1475,11 @@ impl Disambiguator {\n                 (\"!\", DefKind::Macro(MacroKind::Bang)),\n             ];\n             for &(suffix, kind) in &suffixes {\n-                if link.ends_with(suffix) {\n-                    return Ok((Kind(kind), link.trim_end_matches(suffix)));\n+                if let Some(link) = link.strip_suffix(suffix) {\n+                    // Avoid turning `!` or `()` into an empty string\n+                    if !link.is_empty() {\n+                        return Ok((Kind(kind), link));\n+                    }\n                 }\n             }\n             Err(())\n@@ -1445,12 +1509,10 @@ impl Disambiguator {\n         }\n     }\n \n-    /// WARNING: panics on `Res::Err`\n     fn from_res(res: Res) -> Self {\n         match res {\n             Res::Def(kind, _) => Disambiguator::Kind(kind),\n-            Res::PrimTy(_) => Disambiguator::Primitive,\n-            _ => Disambiguator::Namespace(res.ns().expect(\"can't call `from_res` on Res::err\")),\n+            Res::Primitive(_) => Disambiguator::Primitive,\n         }\n     }\n \n@@ -1626,6 +1688,7 @@ fn resolution_failure(\n     link_range: Range<usize>,\n     kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n ) {\n+    let tcx = collector.cx.tcx;\n     report_diagnostic(\n         collector.cx,\n         BROKEN_INTRA_DOC_LINKS,\n@@ -1634,16 +1697,9 @@ fn resolution_failure(\n         dox,\n         &link_range,\n         |diag, sp| {\n-            let item = |res: Res| {\n-                format!(\n-                    \"the {} `{}`\",\n-                    res.descr(),\n-                    collector.cx.tcx.item_name(res.def_id()).to_string()\n-                )\n-            };\n+            let item = |res: Res| format!(\"the {} `{}`\", res.descr(), res.name(tcx),);\n             let assoc_item_not_allowed = |res: Res| {\n-                let def_id = res.def_id();\n-                let name = collector.cx.tcx.item_name(def_id);\n+                let name = res.name(tcx);\n                 format!(\n                     \"`{}` is {} {}, not a module or type, and cannot have associated items\",\n                     name,\n@@ -1709,7 +1765,7 @@ fn resolution_failure(\n                     if let Some(module) = last_found_module {\n                         let note = if partial_res.is_some() {\n                             // Part of the link resolved; e.g. `std::io::nonexistent`\n-                            let module_name = collector.cx.tcx.item_name(module);\n+                            let module_name = tcx.item_name(module);\n                             format!(\"no item named `{}` in module `{}`\", unresolved, module_name)\n                         } else {\n                             // None of the link resolved; e.g. `Notimported`\n@@ -1733,14 +1789,10 @@ fn resolution_failure(\n \n                     // Otherwise, it must be an associated item or variant\n                     let res = partial_res.expect(\"None case was handled by `last_found_module`\");\n-                    let diagnostic_name;\n-                    let (kind, name) = match res {\n-                        Res::Def(kind, def_id) => {\n-                            diagnostic_name = collector.cx.tcx.item_name(def_id).as_str();\n-                            (Some(kind), &*diagnostic_name)\n-                        }\n-                        Res::PrimTy(ty) => (None, ty.name_str()),\n-                        _ => unreachable!(\"only ADTs and primitives are in scope at module level\"),\n+                    let name = res.name(tcx);\n+                    let kind = match res {\n+                        Res::Def(kind, _) => Some(kind),\n+                        Res::Primitive(_) => None,\n                     };\n                     let path_description = if let Some(kind) = kind {\n                         match kind {\n@@ -1997,53 +2049,49 @@ fn handle_variant(\n         .parent(res.def_id())\n         .map(|parent| {\n             let parent_def = Res::Def(DefKind::Enum, parent);\n-            let variant = cx.tcx.expect_variant_res(res);\n+            let variant = cx.tcx.expect_variant_res(res.as_hir_res().unwrap());\n             (parent_def, Some(format!(\"variant.{}\", variant.ident.name)))\n         })\n         .ok_or_else(|| ResolutionFailure::NoParentItem.into())\n }\n \n-// FIXME: At this point, this is basically a copy of the PrimitiveTypeTable\n-const PRIMITIVES: &[(Symbol, Res)] = &[\n-    (sym::u8, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U8))),\n-    (sym::u16, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U16))),\n-    (sym::u32, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U32))),\n-    (sym::u64, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U64))),\n-    (sym::u128, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U128))),\n-    (sym::usize, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::Usize))),\n-    (sym::i8, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I8))),\n-    (sym::i16, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I16))),\n-    (sym::i32, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I32))),\n-    (sym::i64, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I64))),\n-    (sym::i128, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I128))),\n-    (sym::isize, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::Isize))),\n-    (sym::f32, Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F32))),\n-    (sym::f64, Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F64))),\n-    (sym::str, Res::PrimTy(hir::PrimTy::Str)),\n-    (sym::bool, Res::PrimTy(hir::PrimTy::Bool)),\n-    (sym::char, Res::PrimTy(hir::PrimTy::Char)),\n-];\n-\n /// Resolve a primitive type or value.\n-fn resolve_primitive(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n-    is_bool_value(path_str, ns).or_else(|| {\n-        if ns == TypeNS {\n-            // FIXME: this should be replaced by a lookup in PrimitiveTypeTable\n-            let maybe_primitive = Symbol::intern(path_str);\n-            PRIMITIVES.iter().find(|x| x.0 == maybe_primitive).copied()\n-        } else {\n-            None\n-        }\n-    })\n-}\n-\n-/// Resolve a primitive value.\n-fn is_bool_value(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n-    if ns == TypeNS && (path_str == \"true\" || path_str == \"false\") {\n-        Some((sym::bool, Res::PrimTy(hir::PrimTy::Bool)))\n-    } else {\n-        None\n+fn resolve_primitive(path_str: &str, ns: Namespace) -> Option<Res> {\n+    if ns != TypeNS {\n+        return None;\n     }\n+    use PrimitiveType::*;\n+    let prim = match path_str {\n+        \"isize\" => Isize,\n+        \"i8\" => I8,\n+        \"i16\" => I16,\n+        \"i32\" => I32,\n+        \"i64\" => I64,\n+        \"i128\" => I128,\n+        \"usize\" => Usize,\n+        \"u8\" => U8,\n+        \"u16\" => U16,\n+        \"u32\" => U32,\n+        \"u64\" => U64,\n+        \"u128\" => U128,\n+        \"f32\" => F32,\n+        \"f64\" => F64,\n+        \"char\" => Char,\n+        \"bool\" | \"true\" | \"false\" => Bool,\n+        \"str\" => Str,\n+        // See #80181 for why these don't have symbols associated.\n+        \"slice\" => Slice,\n+        \"array\" => Array,\n+        \"tuple\" => Tuple,\n+        \"unit\" => Unit,\n+        \"pointer\" | \"*\" | \"*const\" | \"*mut\" => RawPointer,\n+        \"reference\" | \"&\" | \"&mut\" => Reference,\n+        \"fn\" => Fn,\n+        \"never\" | \"!\" => Never,\n+        _ => return None,\n+    };\n+    debug!(\"resolved primitives {:?}\", prim);\n+    Some(Res::Primitive(prim))\n }\n \n fn strip_generics_from_path(path_str: &str) -> Result<String, ResolutionFailure<'static>> {"}, {"sha": "114502b0ddf4ebfce1cfd6a9c23be74433d89888", "filename": "src/test/rustdoc-ui/intra-doc/non-path-primitives.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.rs?ref=257becbfe4987d1f7b12af5a8dd5ed96697cd2e8", "patch": "@@ -0,0 +1,34 @@\n+#![deny(broken_intra_doc_links)]\n+// These are links that could reasonably expected to work, but don't.\n+\n+// `[]` isn't supported because it had too many false positives.\n+//! [X]([T]::not_here)\n+//! [Y](&[]::not_here)\n+//! [X]([]::not_here)\n+//! [Y]([T;N]::not_here)\n+\n+// These don't work because markdown syntax doesn't allow it.\n+//! [[T]::rotate_left] //~ ERROR unresolved link to `T`\n+//! [&[]::not_here]\n+//![Z]([T; N]::map) //~ ERROR unresolved link to `Z`\n+//! [`[T; N]::map`]\n+//! [[]::map]\n+//! [Z][] //~ ERROR unresolved link to `Z`\n+//!\n+//! [Z]: [T; N]::map //~ ERROR unresolved link to `Z`\n+\n+// `()` isn't supported because it had too many false positives.\n+//! [()::not_here]\n+//! [X]((,)::not_here)\n+//! [(,)::not_here]\n+\n+// FIXME: Associated items on some primitives aren't working, because the impls\n+// are part of the compiler instead of being part of the source code.\n+//! [unit::eq] //~ ERROR unresolved\n+//! [tuple::eq] //~ ERROR unresolved\n+//! [fn::eq] //~ ERROR unresolved\n+//! [never::eq] //~ ERROR unresolved\n+\n+// FIXME(#78800): This breaks because it's a blanket impl\n+// (I think? Might break for other reasons too.)\n+//! [reference::deref] //~ ERROR unresolved"}, {"sha": "ea831e648f63805811ec1f6ceb213c895d4d9bc9", "filename": "src/test/rustdoc-ui/intra-doc/non-path-primitives.stderr", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr?ref=257becbfe4987d1f7b12af5a8dd5ed96697cd2e8", "patch": "@@ -0,0 +1,69 @@\n+error: unresolved link to `T`\n+  --> $DIR/non-path-primitives.rs:11:7\n+   |\n+LL | //! [[T]::rotate_left]\n+   |       ^ no item named `T` in scope\n+   |\n+note: the lint level is defined here\n+  --> $DIR/non-path-primitives.rs:1:9\n+   |\n+LL | #![deny(broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `Z`\n+  --> $DIR/non-path-primitives.rs:13:5\n+   |\n+LL | //![Z]([T; N]::map)\n+   |     ^ no item named `Z` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `Z`\n+  --> $DIR/non-path-primitives.rs:16:6\n+   |\n+LL | //! [Z][]\n+   |      ^ no item named `Z` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `Z`\n+  --> $DIR/non-path-primitives.rs:18:6\n+   |\n+LL | //! [Z]: [T; N]::map\n+   |      ^ no item named `Z` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `unit::eq`\n+  --> $DIR/non-path-primitives.rs:27:6\n+   |\n+LL | //! [unit::eq]\n+   |      ^^^^^^^^ the builtin type `unit` has no associated item named `eq`\n+\n+error: unresolved link to `tuple::eq`\n+  --> $DIR/non-path-primitives.rs:28:6\n+   |\n+LL | //! [tuple::eq]\n+   |      ^^^^^^^^^ the builtin type `tuple` has no associated item named `eq`\n+\n+error: unresolved link to `fn::eq`\n+  --> $DIR/non-path-primitives.rs:29:6\n+   |\n+LL | //! [fn::eq]\n+   |      ^^^^^^ the builtin type `fn` has no associated item named `eq`\n+\n+error: unresolved link to `never::eq`\n+  --> $DIR/non-path-primitives.rs:30:6\n+   |\n+LL | //! [never::eq]\n+   |      ^^^^^^^^^ the builtin type `never` has no associated item named `eq`\n+\n+error: unresolved link to `reference::deref`\n+  --> $DIR/non-path-primitives.rs:34:6\n+   |\n+LL | //! [reference::deref]\n+   |      ^^^^^^^^^^^^^^^^ the builtin type `reference` has no associated item named `deref`\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "ad4f6ddd9de698e53248e713d656187a10de3f57", "filename": "src/test/rustdoc/intra-doc/non-path-primitives.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8/src%2Ftest%2Frustdoc%2Fintra-doc%2Fnon-path-primitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257becbfe4987d1f7b12af5a8dd5ed96697cd2e8/src%2Ftest%2Frustdoc%2Fintra-doc%2Fnon-path-primitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fnon-path-primitives.rs?ref=257becbfe4987d1f7b12af5a8dd5ed96697cd2e8", "patch": "@@ -0,0 +1,39 @@\n+// ignore-tidy-linelength\n+#![crate_name = \"foo\"]\n+#![deny(broken_intra_doc_links)]\n+\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.rotate_left\"]' 'slice::rotate_left'\n+//! [slice::rotate_left]\n+\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.array.html#method.map\"]' 'array::map'\n+//! [array::map]\n+\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.is_null\"]' 'pointer::is_null'\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.is_null\"]' '*const::is_null'\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.is_null\"]' '*mut::is_null'\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.is_null\"]' '*::is_null'\n+//! [pointer::is_null]\n+//! [*const::is_null]\n+//! [*mut::is_null]\n+//! [*::is_null]\n+\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\"]' 'unit'\n+//! [unit]\n+\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.tuple.html\"]' 'tuple'\n+//! [tuple]\n+\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\"]' 'reference'\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\"]' '&'\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\"]' '&mut'\n+//! [reference]\n+//! [&]\n+//! [&mut]\n+\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.fn.html\"]' 'fn'\n+//! [fn]\n+\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.never.html\"]' 'never'\n+// @has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/primitive.never.html\"]' '!'\n+//! [never]\n+//! [!]"}]}