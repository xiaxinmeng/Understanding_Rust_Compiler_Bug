{"sha": "bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkOTBjN2EzY2JmNDcwYjUwODU3YTg0ZTJlODQwN2I3ZWJlZDdjZTI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-08T20:48:19Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-09T11:08:38Z"}, "message": "Add new visitor framework", "tree": {"sha": "f74227f92f2857b8e8fa1ec4a4e9530dabb82e4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f74227f92f2857b8e8fa1ec4a4e9530dabb82e4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2", "html_url": "https://github.com/rust-lang/rust/commit/bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6feb1dfd7672838fe3a621250a832f97c39f2260", "url": "https://api.github.com/repos/rust-lang/rust/commits/6feb1dfd7672838fe3a621250a832f97c39f2260", "html_url": "https://github.com/rust-lang/rust/commit/6feb1dfd7672838fe3a621250a832f97c39f2260"}], "stats": {"total": 391, "additions": 391, "deletions": 0}, "files": [{"sha": "79f74c8f3e890111fb6ca087bd073db40421497f", "filename": "src/comp/middle/visit.rs", "status": "added", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2/src%2Fcomp%2Fmiddle%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2/src%2Fcomp%2Fmiddle%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fvisit.rs?ref=bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2", "patch": "@@ -0,0 +1,381 @@\n+import front::ast::*;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+import util::common::span;\n+\n+// Lots of redundant indirection and refcounting. Our typesystem doesn't do\n+// circular types, so the visitor record can not hold functions that take\n+// visitors. A tag breaks the cycle.\n+tag vt[E] { vtor(visitor[E]); }\n+fn vt[E](&vt[E] x) -> visitor[E] {\n+    alt (x) { case (vtor(?v)) { ret v; } }\n+}\n+\n+type visitor[E] =\n+    @rec(fn(&_mod m, &span sp, &E e, &vt[E] v) visit_mod,\n+         fn(&@native_item i, &E e, &vt[E] v)   visit_native_item,\n+         fn(&@item i, &E e, &vt[E] v)          visit_item,\n+         fn(&block b, &E e, &vt[E] v)          visit_block,\n+         fn(&@stmt s, &E e, &vt[E] v)          visit_stmt,\n+         fn(&arm a, &E e, &vt[E] v)            visit_arm,\n+         fn(&@pat p, &E e, &vt[E] v)           visit_pat,\n+         fn(&@decl d, &E e, &vt[E] v)          visit_decl,\n+         fn(&@expr ex, &E e, &vt[E] v)         visit_expr,\n+         fn(&@ty t, &E e, &vt[E] v)            visit_ty,\n+         fn(&_fn f, &span sp, &ident name, \n+            &def_id d_id, &ann a,\n+            &E e, &vt[E] v)                    visit_fn);\n+\n+fn default_visitor[E]() -> visitor[E] {\n+    ret @rec(visit_mod = bind visit_mod[E](_, _, _, _),\n+             visit_native_item = bind visit_native_item[E](_, _, _),\n+             visit_item = bind visit_item[E](_, _, _),\n+             visit_block = bind visit_block[E](_, _, _),\n+             visit_stmt = bind visit_stmt[E](_, _, _),\n+             visit_arm = bind visit_arm[E](_, _, _),\n+             visit_pat = bind visit_pat[E](_, _, _),\n+             visit_decl = bind visit_decl[E](_, _, _),\n+             visit_expr = bind visit_expr[E](_, _, _),\n+             visit_ty = bind visit_ty[E](_, _, _),\n+             visit_fn = bind visit_fn[E](_, _, _, _, _, _, _));\n+}\n+\n+fn visit_crate[E](&crate c, &E e, &vt[E] v) {\n+    vt(v).visit_mod(c.node.module, c.span, e, v);\n+}\n+\n+fn visit_mod[E](&_mod m, &span sp, &E e, &vt[E] v) {\n+    for (@item i in m.items) {\n+        vt(v).visit_item(i, e, v);\n+    }\n+}\n+\n+fn visit_item[E](&@item i, &E e, &vt[E] v) {\n+    alt (i.node) {\n+        case (item_const(_, ?t, ?ex, _, _)) {\n+            vt(v).visit_ty(t, e, v);\n+            vt(v).visit_expr(ex, e, v);\n+        }\n+        case (item_fn(?nm, ?f, _, ?d, ?a)) {\n+            vt(v).visit_fn(f, i.span, nm, d, a, e, v);\n+        }\n+        case (item_mod(_, ?m, _)) {\n+            vt(v).visit_mod(m, i.span, e, v);\n+        }\n+        case (item_native_mod(_, ?nm, _)) {\n+            for (@native_item ni in nm.items) {\n+                vt(v).visit_native_item(ni, e, v);\n+            }\n+        }\n+        case (item_ty(_, ?t, _, _, _)) {\n+            vt(v).visit_ty(t, e, v);\n+        }\n+        case (item_tag(_, ?variants, _, _, _)) {\n+            for (variant vr in variants) {\n+                for (variant_arg va in vr.node.args) {\n+                    vt(v).visit_ty(va.ty, e, v);\n+                }\n+            }\n+        }\n+        case (item_obj(_, ?ob, _, _, _)) {\n+            for (obj_field f in ob.fields) {\n+                vt(v).visit_ty(f.ty, e, v);\n+            }\n+            for (@method m in ob.methods) {\n+                vt(v).visit_fn(m.node.meth, m.span, m.node.ident, m.node.id,\n+                           m.node.ann, e, v);\n+            }\n+            alt (ob.dtor) {\n+                case (none) {}\n+                case (some(?m)) {\n+                    vt(v).visit_fn(m.node.meth, m.span, m.node.ident,\n+                                   m.node.id, m.node.ann, e, v);\n+                }\n+            }\n+        }\n+\n+    }\n+}\n+\n+fn visit_ty[E](&@ty t, &E e, &vt[E] v) {\n+    alt (t.node) {\n+        case (ty_box(?mt)) { vt(v).visit_ty(mt.ty, e, v); }\n+        case (ty_vec(?mt)) { vt(v).visit_ty(mt.ty, e, v); }\n+        case (ty_ptr(?mt)) { vt(v).visit_ty(mt.ty, e, v); }\n+        case (ty_port(?t)) { vt(v).visit_ty(t, e, v); }\n+        case (ty_chan(?t)) { vt(v).visit_ty(t, e, v); }\n+        case (ty_tup(?mts)) {\n+            for (mt mt in mts) {\n+                vt(v).visit_ty(mt.ty, e, v);\n+            }\n+        }\n+        case (ty_rec(?flds)) {\n+            for (ty_field f in flds) {\n+                vt(v).visit_ty(f.node.mt.ty, e, v);\n+            }\n+        }\n+        case (ty_fn(_, ?args, ?out, _)) {\n+            for (ty_arg a in args) {\n+                vt(v).visit_ty(a.node.ty, e, v);\n+            }\n+            vt(v).visit_ty(out, e, v);\n+        }\n+        case (ty_obj(?tmeths)) {\n+            for (ty_method m in tmeths) {\n+                for (ty_arg a in m.node.inputs) {\n+                    vt(v).visit_ty(a.node.ty, e, v);\n+                }\n+                vt(v).visit_ty(m.node.output, e, v);\n+            }\n+        }\n+        case (ty_path(?p, _)) {\n+            for (@ty tp in p.node.types) {\n+                vt(v).visit_ty(tp, e, v);\n+            }\n+        }\n+        case (ty_constr(?t, _)) { vt(v).visit_ty(t, e, v); }\n+        case (_) {}\n+    }\n+}\n+\n+fn visit_pat[E](&@pat p, &E e, &vt[E] v) {\n+    alt (p.node) {\n+        case (pat_tag(?path, ?children, _)) {\n+            for (@pat child in children) {\n+                vt(v).visit_pat(child, e, v);\n+            }\n+        }\n+        case (_) {}\n+    }\n+}\n+\n+fn visit_native_item[E](&@native_item ni, &E e, &vt[E] v) {\n+    alt (ni.node) {\n+        case (native_item_fn(_, _, ?fd, _, _, _)) {\n+            visit_fn_decl(fd, e, v);\n+        }\n+        case (native_item_ty(_, _)) {}\n+    }\n+}\n+\n+fn visit_fn_decl[E](&fn_decl fd, &E e, &vt[E] v) {\n+    for (arg a in fd.inputs) {\n+        vt(v).visit_ty(a.ty, e, v);\n+    }\n+    vt(v).visit_ty(fd.output, e, v);\n+}\n+\n+fn visit_fn[E](&_fn f, &span sp, &ident i, &def_id d, &ann a,\n+               &E e, &vt[E] v) {\n+    visit_fn_decl(f.decl, e, v);\n+    vt(v).visit_block(f.body, e, v);\n+}\n+\n+fn visit_block[E](&block b, &E e, &vt[E] v) {\n+    for (@stmt s in b.node.stmts) { vt(v).visit_stmt(s, e, v); }\n+    visit_expr_opt(b.node.expr, e, v);\n+}\n+\n+fn visit_stmt[E](&@stmt s, &E e, &vt[E] v) {\n+    alt (s.node) {\n+        case (stmt_decl(?d, _)) { vt(v).visit_decl(d, e, v); }\n+        case (stmt_expr(?ex, _)) { vt(v).visit_expr(ex, e, v); }\n+        case (stmt_crate_directive(?cdir)) {}\n+    }\n+}\n+\n+fn visit_decl[E](&@decl d, &E e, &vt[E] v) {\n+    alt (d.node) {\n+        case (decl_local(?loc)) {\n+            alt (loc.ty) {\n+                case (none) {}\n+                case (some(?t)) { vt(v).visit_ty(t, e, v); }\n+            }\n+            alt (loc.init) {\n+                case (none) {}\n+                case (some(?i)) { vt(v).visit_expr(i.expr, e, v); }\n+            }\n+        }\n+        case (decl_item(?it)) { vt(v).visit_item(it, e, v); }\n+    }\n+}\n+\n+fn visit_expr_opt[E](option::t[@expr] eo, &E e, &vt[E] v) {\n+    alt (eo) {\n+        case (none) {}\n+        case (some(?ex)) { vt(v).visit_expr(ex, e, v);\n+        }\n+    }\n+}\n+\n+fn visit_exprs[E](vec[@expr] exprs, &E e, &vt[E] v) {\n+    for (@expr ex in exprs) { vt(v).visit_expr(ex, e, v); }\n+}\n+\n+fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n+    alt (ex.node) {\n+        case (expr_vec(?es, _, _)) {\n+            visit_exprs(es, e, v);\n+        }\n+        case (expr_tup(?elts, _)) {\n+            for (elt el in elts) { vt(v).visit_expr(el.expr, e, v); }\n+        }\n+        case (expr_rec(?flds, ?base, _)) {\n+            for (field f in flds) { vt(v).visit_expr(f.node.expr, e, v); }\n+            visit_expr_opt(base, e, v);\n+        }\n+        case (expr_call(?callee, ?args, _)) {\n+            vt(v).visit_expr(callee, e, v);\n+            visit_exprs(args, e, v);\n+        }\n+        case (expr_self_method(_, _)) { }\n+        case (expr_bind(?callee, ?args, _)) {\n+            vt(v).visit_expr(callee, e, v);\n+            for (option::t[@expr] eo in args) { visit_expr_opt(eo, e, v); }\n+        }\n+        case (expr_spawn(_, _, ?callee, ?args, _)) {\n+            vt(v).visit_expr(callee, e, v);\n+            visit_exprs(args, e, v);\n+        }\n+        case (expr_binary(_, ?a, ?b, _)) {\n+            vt(v).visit_expr(a, e, v);\n+            vt(v).visit_expr(b, e, v);\n+        }\n+        case (expr_unary(_, ?a, _)) {\n+            vt(v).visit_expr(a, e, v);\n+        }\n+        case (expr_lit(_, _)) { }\n+        case (expr_cast(?x, ?t, _)) {\n+            vt(v).visit_expr(x, e, v);\n+            vt(v).visit_ty(t, e, v);\n+        }\n+        case (expr_if(?x, ?b, ?eo, _)) {\n+            vt(v).visit_expr(x, e, v);\n+            vt(v).visit_block(b, e, v);\n+            visit_expr_opt(eo, e, v);\n+        }\n+        case (expr_while(?x, ?b, _)) {\n+            vt(v).visit_expr(x, e, v);\n+            vt(v).visit_block(b, e, v);\n+        }\n+        case (expr_for(?dcl, ?x, ?b, _)) {\n+            vt(v).visit_decl(dcl, e, v);\n+            vt(v).visit_expr(x, e, v);\n+            vt(v).visit_block(b, e, v);\n+        }\n+        case (expr_for_each(?dcl, ?x, ?b, _)) {\n+            vt(v).visit_decl(dcl, e, v);\n+            vt(v).visit_expr(x, e, v);\n+            vt(v).visit_block(b, e, v);\n+        }\n+        case (expr_do_while(?b, ?x, _)) {\n+            vt(v).visit_block(b, e, v);\n+            vt(v).visit_expr(x, e, v);\n+        }\n+        case (expr_alt(?x, ?arms, _)) {\n+            vt(v).visit_expr(x, e, v);\n+            for (arm a in arms) {\n+                vt(v).visit_arm(a, e, v);\n+            }\n+        }\n+        case (expr_block(?b, _)) {\n+            vt(v).visit_block(b, e, v);\n+        }\n+        case (expr_assign(?a, ?b, _)) {\n+            vt(v).visit_expr(b, e, v);\n+            vt(v).visit_expr(a, e, v);\n+        }\n+        case (expr_move(?a, ?b, _)) {\n+            vt(v).visit_expr(b, e, v);\n+            vt(v).visit_expr(a, e, v);\n+        }\n+        case (expr_assign_op(_, ?a, ?b, _)) {\n+            vt(v).visit_expr(b, e, v);\n+            vt(v).visit_expr(a, e, v);\n+        }\n+        case (expr_send(?a, ?b, _)) {\n+            vt(v).visit_expr(a, e, v);\n+            vt(v).visit_expr(b, e, v);\n+        }\n+        case (expr_recv(?a, ?b, _)) {\n+            vt(v).visit_expr(a, e, v);\n+            vt(v).visit_expr(b, e, v);\n+        }\n+        case (expr_field(?x, _, _)) {\n+            vt(v).visit_expr(x, e, v);\n+        }\n+        case (expr_index(?a, ?b, _)) {\n+            vt(v).visit_expr(a, e, v);\n+            vt(v).visit_expr(b, e, v);\n+        }\n+        case (expr_path(?p, _)) {\n+            for (@ty tp in p.node.types) {\n+                vt(v).visit_ty(tp, e, v);\n+            }\n+        }\n+        case (expr_ext(_, _, _, ?expansion, _)) {\n+            vt(v).visit_expr(expansion, e, v);\n+        }\n+        case (expr_fail(_, _)) { }\n+        case (expr_break(_)) { }\n+        case (expr_cont(_)) { }\n+        case (expr_ret(?eo, _)) {\n+            visit_expr_opt(eo, e, v);\n+        }\n+        case (expr_put(?eo, _)) {\n+            visit_expr_opt(eo, e, v);\n+        }\n+        case (expr_be(?x, _)) {\n+            vt(v).visit_expr(x, e, v);\n+        }\n+        case (expr_log(_,?x, _)) {\n+            vt(v).visit_expr(x, e, v);\n+        }\n+        case (expr_check(?x, _)) {\n+            vt(v).visit_expr(x, e, v);\n+        }\n+        case (expr_assert(?x, _)) {\n+            vt(v).visit_expr(x, e, v);\n+        }\n+        case (expr_port(_)) { }\n+        case (expr_chan(?x, _)) {\n+            vt(v).visit_expr(x, e, v);\n+        }\n+\n+        case (expr_anon_obj(?anon_obj,_,_,_)) { \n+            alt (anon_obj.fields) {\n+                case (none) { }\n+                case (some(?fields)) {\n+                    for (obj_field f in fields) {\n+                        vt(v).visit_ty(f.ty, e, v);\n+                    }\n+                }\n+            }\n+            alt (anon_obj.with_obj) {\n+                case (none) { }\n+                case (some(?ex)) {\n+                    vt(v).visit_expr(ex, e, v);\n+                }\n+            }\n+            for (@method m in anon_obj.methods) {\n+                vt(v).visit_fn(m.node.meth, m.span, m.node.ident, \n+                           m.node.id, m.node.ann, e, v);\n+            }\n+        }\n+    }\n+}\n+\n+fn visit_arm[E](&arm a, &E e, &vt[E] v) {\n+    vt(v).visit_pat(a.pat, e, v);\n+    vt(v).visit_block(a.block, e, v);\n+}\n+\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "1b323182cf0cddfaa7cc29b77560a2c352c3eef2", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2", "patch": "@@ -16,6 +16,7 @@ mod middle {\n     mod trans;\n     mod ty;\n     mod walk;\n+    mod visit;\n     mod metadata;\n     mod resolve;\n     mod typeck;"}, {"sha": "bc050173bc0df32c193948cc29d0c333541b9265", "filename": "src/test/compile-fail/unsafe-for.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs?ref=bd90c7a3cbf470b50857a84e2e8407b7ebed7ce2", "patch": "@@ -0,0 +1,9 @@\n+// error-pattern:invalidate alias x\n+\n+fn main() {\n+    let vec[mutable int] v = [mutable 1, 2, 3];\n+    for (int x in v) {\n+        v.(0) = 10;\n+        log x;\n+    }\n+}"}]}