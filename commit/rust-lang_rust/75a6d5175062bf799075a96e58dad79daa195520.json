{"sha": "75a6d5175062bf799075a96e58dad79daa195520", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1YTZkNTE3NTA2MmJmNzk5MDc1YTk2ZTU4ZGFkNzlkYWExOTU1MjA=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-10-29T19:18:33Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-11-03T12:56:06Z"}, "message": "Make some edits as per No Starch.\n\nLots of little details and things.", "tree": {"sha": "61eda7fa503b1c8b5784f7b1a73bc434cafd2983", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61eda7fa503b1c8b5784f7b1a73bc434cafd2983"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75a6d5175062bf799075a96e58dad79daa195520", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75a6d5175062bf799075a96e58dad79daa195520", "html_url": "https://github.com/rust-lang/rust/commit/75a6d5175062bf799075a96e58dad79daa195520", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75a6d5175062bf799075a96e58dad79daa195520/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fffe0757086b8f381226cb5ddcb6c129a815b96d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fffe0757086b8f381226cb5ddcb6c129a815b96d", "html_url": "https://github.com/rust-lang/rust/commit/fffe0757086b8f381226cb5ddcb6c129a815b96d"}], "stats": {"total": 584, "additions": 313, "deletions": 271}, "files": [{"sha": "3fac3e3bf04ad4d77424677275c5ccf44dc3aaca", "filename": "src/doc/trpl/hello-cargo.md", "status": "modified", "additions": 134, "deletions": 101, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/75a6d5175062bf799075a96e58dad79daa195520/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/75a6d5175062bf799075a96e58dad79daa195520/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-cargo.md?ref=75a6d5175062bf799075a96e58dad79daa195520", "patch": "@@ -1,61 +1,83 @@\n % Hello, Cargo!\n \n-[Cargo][cratesio] is a tool that Rustaceans use to help manage their Rust\n-projects. Cargo is currently in a pre-1.0 state, and so it is still a work in\n-progress. However, it is already good enough to use for many Rust projects, and\n-so it is assumed that Rust projects will use Cargo from the beginning.\n+Cargo is Rust\u2019s build system and package manager, and Rustaceans use Cargo to\n+manage their Rust projects. Cargo manages three things: building your code,\n+downloading the libraries your code depends on, and building those libraries.\n+We call libraries your code needs \u2018dependencies\u2019, since your code depends on\n+them.\n+\n+The simplest Rust programs don\u2019t have any dependencies, so right now, you'd\n+only use the first part of its functionality. As you write more complex Rust\n+programs, you\u2019ll want to add dependencies, and if you start off using Cargo,\n+that will be a lot easier to do.\n+\n+As the vast, vast majority of Rust projects use Cargo, we will assume that\n+you\u2019re using it for the rest of the book. Cargo comes installed with Rust\n+itself, if you used the official installers. If you installed Rust through some\n+other means, you can check if you have Cargo installed by typing:\n \n-[cratesio]: http://doc.crates.io\n+```bash\n+$ cargo --version\n+```\n \n-Cargo manages three things: building our code, downloading the dependencies our\n-code needs, and building those dependencies. At first, our program doesn\u2019t have\n-any dependencies, so we\u2019ll only be using the first part of its functionality.\n-Eventually, we\u2019ll add more. Since we started off by using Cargo, it'll be easy\n-to add later.\n+Into a terminal. If you see a version number, great! If you see an error like\n+\u2018`command not found`\u2019, then you should look at the documentation for the system\n+in which you installed Rust, to determine if Cargo is separate.\n \n-If you installed Rust via the official installers you will also have Cargo. If\n-you installed Rust some other way, you may want to\n-[check the Cargo README][cargoreadme] for specific instructions about installing\n-it.\n+## Converting to Cargo\n \n-[cargoreadme]: https://github.com/rust-lang/cargo#installing-cargo-from-nightlies\n+Let\u2019s convert the Hello World program to Cargo. To Cargo-fy a project, you need\n+to do three things: \n \n-## Converting to Cargo\n+1. Put your source file in the right directory.\n+2. Get rid of the old executable (`main.exe` on Windows, `main` everywhere else)\n+   and make a new one.\n+3. Make a Cargo configuration file.\n+\n+Let's get started!\n \n-Let\u2019s convert Hello World to Cargo.\n+### Creating a new Executable and Source Directory\n \n-To Cargo-ify our project, we need to do three things: Make a `Cargo.toml`\n-configuration file, put our source file in the right place, and get rid of the\n-old executable (`main.exe` on Windows, `main` everywhere else). Let's do that part first:\n+First, go back to your terminal, move to your *hello_world* directory, and\n+enter the following commands:\n \n ```bash\n $ mkdir src\n $ mv main.rs src/main.rs\n $ rm main  # or 'del main.exe' on Windows\n ```\n \n-> Note: since we're creating an executable, we retain `main.rs` as the source\n-> filename. If we want to make a library instead, we should use `lib.rs`. This\n-> convention is used by Cargo to successfully compile our projects, but it can\n-> be overridden if we wish. Custom file locations for the entry point can be\n-> specified with a [`[lib]` or `[[bin]]`][crates-custom] key in the TOML file.\n+Cargo expects your source files to live inside a *src* directory, so do that\n+first. This leaves the top level project directory (in this case,\n+*hello_world*) for READMEs, license information, and anything else not related\n+to your code. In this way, using Cargo helps you keep your projects nice and\n+tidy. There's a place for everything, and everything is in its place. \n \n-[crates-custom]: http://doc.crates.io/manifest.html#configuring-a-target\n+Now, copy *main.rs* to the *src* directory, and delete the compiled file you\n+created with `rustc`. As usual, replace `main` with `main.exe` if you're on\n+Windows.\n \n-Cargo expects our source files to live inside a `src` directory. That leaves the\n-top level for other things, like READMEs, license information, and anything not\n-related to our code. Cargo helps us keep our projects nice and tidy. A place for\n-everything, and everything in its place.\n+This example retains `main.rs` as the source filename because it's creating an\n+executable. If you wanted to make a library instead, you'd name the file\n+`lib.rs`. This convention is used by Cargo to successfully compile your\n+projects, but it can be overridden if you wish. \n \n-Next, our configuration file:\n+### Creating a Configuration File\n \n-```bash\n-$ editor Cargo.toml # or 'notepad Cargo.toml' on Windows\n-```\n+Next, create a new file inside your *hello_world* directory, and call it\n+`Cargo.toml`.\n+\n+Make sure to capitalize the `C` in `Cargo.toml`, or Cargo won't know what to do\n+with the configuration file. \n \n-Make sure to get this name right: we need the capital `C`!\n+This file is in the *[TOML]* (Tom's Obvious, Minimal Language) format. TOML is\n+similar to INI, but has some extra goodies. According to the TOML docs, TOML\n+\u201caims to be a minimal configuration file format that's easy to read\u201d, and so we\n+chose it as the format Cargo uses.\n \n-Put this inside:\n+[TOML]: https://github.com/toml-lang/toml\n+\n+Inside this file, type the following information:\n \n ```toml\n [package]\n@@ -65,18 +87,21 @@ version = \"0.0.1\"\n authors = [ \"Your name <you@example.com>\" ]\n ```\n \n-This file is in the [TOML][toml] format. TOML is similar to INI, but has some\n-extra goodies. According to the TOML docs,\n+The first line, `[package]`, indicates that the following statements are\n+configuring a package. As we add more information to this file, we\u2019ll add other\n+sections, but for now, we just have the package configuration.\n+\n+The other three lines set the three bits of configuration that Cargo needs to\n+know to compile your program: its name, what version it is, and who wrote it.\n \n-> TOML aims to be a minimal configuration file format that's easy to read due\n-> to obvious semantics. TOML is designed to map unambiguously to a hash table.\n-> TOML should be easy to parse into data structures in a wide variety of\n-> languages.\n+Once you've added this information to the *Cargo.toml* file, save it to finish\n+creating the configuration file.\n \n-[toml]: https://github.com/toml-lang/toml\n+## Building and Running a Cargo Project \n \n-Once we have this file in place in our project's root directory, we should be\n-ready to build! To do so, run:\n+With your *Cargo.toml* file in place in your project's root directory, you\n+should be ready to build and run your Hello World program! To do so, enter the\n+following commands:\n \n ```bash\n $ cargo build\n@@ -85,18 +110,22 @@ $ ./target/debug/hello_world\n Hello, world!\n ```\n \n-Bam! We built our project with `cargo build`, and ran it with\n-`./target/debug/hello_world`. We can do both in one step with `cargo run`:\n+Bam! If all goes well, `Hello, world!` should print to the terminal once more. \n+\n+You just built a project with `cargo build` and ran it with\n+`./target/debug/hello_world`, but you can actually do both in one step with\n+`cargo run` as follows:\n \n ```bash\n $ cargo run\n      Running `target/debug/hello_world`\n Hello, world!\n ```\n \n-Notice that we didn\u2019t re-build the project this time. Cargo figured out that\n-we hadn\u2019t changed the source file, and so it just ran the binary. If we had\n-made a modification, we would have seen it do both:\n+Notice that this example didn\u2019t re-build the project. Cargo figured out that\n+the hasn\u2019t changed, and so it just ran the binary. If you'd modified your\n+program, Cargo would have built the file before running it, and you would have\n+seen something like this:\n \n ```bash\n $ cargo run\n@@ -105,70 +134,71 @@ $ cargo run\n Hello, world!\n ```\n \n-This hasn\u2019t bought us a whole lot over our simple use of `rustc`, but think\n-about the future: when our project gets more complex, we need to do more\n-things to get all of the parts to properly compile. With Cargo, as our project\n-grows, we can just run `cargo build`, and it\u2019ll work the right way.\n+Cargo checks to see if any of your project\u2019s files have been modified, and only\n+rebuilds your project if they\u2019ve changed since the last time you built it.\n+\n+With simple projects, Cargo doesn't bring a whole lot over just using `rustc`,\n+but it will become useful in future. When your projects get more complex,\n+you'll need to do more things to get all of the parts to properly compile. With\n+Cargo, you can just run `cargo build`, and it should work the right way.\n+\n+## Building for Release\n \n-When our project is finally ready for release, we can use `cargo build\n---release` to compile our project with optimizations.\n+When your project is finally ready for release, you can use `cargo build\n+--release` to compile your project with optimizations. These optimizations make\n+your Rust code run faster, but turning them on makes your program take longer\n+to compile. This is why there are two different profiles, one for development,\n+and one for building the final program you\u2019ll give to a user.\n \n-You'll also notice that Cargo has created a new file: `Cargo.lock`.\n+Running this command also causes Cargo to create a new file called\n+*Cargo.lock*, which looks like this:\n \n ```toml\n [root]\n name = \"hello_world\"\n version = \"0.0.1\"\n ```\n \n-The `Cargo.lock` file is used by Cargo to keep track of dependencies in our\n-application. Right now, we don\u2019t have any, so it\u2019s a bit sparse. We won't ever\n-need to touch this file ourselves, just let Cargo handle it.\n+Cargo uses the *Cargo.lock* file to keep track of dependencies in your\n+application. This is the Hello World project's *Cargo.lock* file. This project\n+doesn't have dependencies, so the file is a bit sparse. Realistically, you\n+won't ever need to touch this file yourself; just let Cargo handle it.\n \n-That\u2019s it! We\u2019ve successfully built `hello_world` with Cargo. Even though our\n-program is simple, it\u2019s using much of the real tooling that we\u2019ll use for the\n-rest of our Rust career. We can expect to do this to get started with virtually\n-all Rust projects:\n+That\u2019s it! If you've been following along, you should have successfully built\n+`hello_world` with Cargo. \n+\n+Even though the project is simple, it now uses much of the real tooling you\u2019ll\n+use for the rest of your Rust career. In fact, you can expect to start\n+virtually all Rust projects with some variation on the following commands:\n \n ```bash\n $ git clone someurl.com/foo\n $ cd foo\n $ cargo build\n ```\n \n-## A New Project\n+## Making A New Cargo Project the Easy Way\n \n-We don\u2019t have to go through this whole process every time we want to start a new\n-project! Cargo has the ability to make a bare-bones project directory in which\n-we can start developing right away.\n+You don\u2019t have to go through that previous process every time you want to start\n+a new project! Cargo can quickly make a bare-bones project directory that you\n+can start developing in right away.\n \n-To start a new project with Cargo, we use `cargo new`:\n+To start a new project with Cargo, enter `cargo new` at the command line:\n \n ```bash\n $ cargo new hello_world --bin\n ```\n \n-We\u2019re passing `--bin` because our goal is to get straight to making an\n+This command passes `--bin` because the goal is to get straight to making an\n executable application, as opposed to a library. Executables are often called\n-\u2018binaries.\u2019 (as in `/usr/bin`, if we\u2019re on a Unix system)\n-\n-Let's check out what Cargo has generated for us:\n+*binaries* (as in `/usr/bin`, if you\u2019re on a Unix system).\n \n-```bash\n-$ cd hello_world\n-$ tree .\n-.\n-\u251c\u2500\u2500 Cargo.toml\n-\u2514\u2500\u2500 src\n-    \u2514\u2500\u2500 main.rs\n-\n-1 directory, 2 files\n-```\n-\n-If we don't have the `tree` command, we can probably get it from our\n-distribution\u2019s package manager. It\u2019s not necessary, but it\u2019s certainly useful.\n+Cargo has generated two files and one directory for us: a `Cargo.toml` and a\n+*src* directory with a *main.rs* file inside. These should look familliar,\n+they\u2019re exactly what we created by hand, above.\n \n-This is all we need to get started. First, let\u2019s check out `Cargo.toml`:\n+This output is all you need to get started. First, open `Cargo.toml`. It should\n+look something like this:\n \n ```toml\n [package]\n@@ -178,33 +208,36 @@ version = \"0.1.0\"\n authors = [\"Your Name <you@example.com>\"]\n ```\n \n-Cargo has populated this file with reasonable defaults based off the arguments\n-we gave it and our `git` global configuration. You may notice that Cargo has\n+Cargo has populated *Cargo.toml* with reasonable defaults based on the arguments\n+you gave it and your `git` global configuration. You may notice that Cargo has\n also initialized the `hello_world` directory as a `git` repository.\n \n-Here\u2019s what\u2019s in `src/main.rs`:\n+Here\u2019s what should be in `src/main.rs`:\n \n ```rust\n fn main() {\n     println!(\"Hello, world!\");\n }\n ```\n \n-Cargo has generated a \"Hello World!\" for us, and we\u2019re ready to start coding!\n-Cargo has its own [guide][guide] which covers Cargo\u2019s features in much more\n-depth.\n+Cargo has generated a \"Hello World!\" for you, and you\u2019re ready to start coding! \n+\n+> Note: If you want to look at Cargo in more detail, check out the official [Cargo\n+guide], which covers all of its features.\n+\n+[Cargo guide]: http://doc.crates.io/guide.html\n \n-[guide]: http://doc.crates.io/guide.html\n+# Closing Thoughts\n \n-Now that we\u2019ve got the tools down, let\u2019s actually learn more about the Rust\n-language itself. These are the basics that will serve us well through the rest\n-of our time with Rust.\n+This chapter covered the basics that will serve you well through the rest of\n+this book, and the rest of your time with Rust. Now that you\u2019ve got the tools\n+down, we'll cover more about the Rust language itself. \n \n You have two options: Dive into a project with \u2018[Learn Rust][learnrust]\u2019, or\n-start from the bottom and work your way up with\n-\u2018[Syntax and Semantics][syntax]\u2019. More experienced systems programmers will\n-probably prefer \u2018Learn Rust\u2019, while those from dynamic backgrounds may enjoy\n-either. Different people learn differently! Choose whatever\u2019s right for you.\n+start from the bottom and work your way up with \u2018[Syntax and\n+Semantics][syntax]\u2019. More experienced systems programmers will probably prefer\n+\u2018Learn Rust\u2019, while those from dynamic backgrounds may enjoy either. Different\n+people learn differently! Choose whatever\u2019s right for you.\n \n [learnrust]: learn-rust.html\n [syntax]: syntax-and-semantics.html"}, {"sha": "cb88b85b5c65f627d23651fd52d7519490136ece", "filename": "src/doc/trpl/hello-world.md", "status": "modified", "additions": 113, "deletions": 99, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/75a6d5175062bf799075a96e58dad79daa195520/src%2Fdoc%2Ftrpl%2Fhello-world.md", "raw_url": "https://github.com/rust-lang/rust/raw/75a6d5175062bf799075a96e58dad79daa195520/src%2Fdoc%2Ftrpl%2Fhello-world.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-world.md?ref=75a6d5175062bf799075a96e58dad79daa195520", "patch": "@@ -1,30 +1,33 @@\n % Hello, world!\n \n-Now that we have Rust installed, let\u2019s write our first Rust program. It\u2019s\n-traditional to make our first program in any new language one that prints the\n-text \u201cHello, world!\u201d to the screen. The nice thing about starting with such a\n-simple program is that we can verify that our compiler isn\u2019t just installed, but\n-also working properly. And printing information to the screen is a pretty common\n-thing to do.\n-\n-The first thing that we need to do is make a file to put our code in. I like to\n-make a `projects` directory in my home directory, and keep all my projects\n-there. Rust doesn't care where our code lives.\n-\n-This actually leads to one other concern we should address: this guide will\n-assume that we have basic familiarity with the command line. Rust itself makes\n-no specific demands on our editing tooling, or where our code lives. If we\n-prefer an IDE to the command line, we may want to check out\n-[SolidOak][solidoak], or wherever plugins are for our favorite IDE. There are a\n-number of extensions of varying quality in development by the community. The\n-Rust team also ships [plugins for various editors][plugins]. Configuring our\n-editor or IDE is out of the scope of this tutorial, so check the documentation\n-for our setup, specifically.\n-\n-[solidoak]: https://github.com/oakes/SolidOak\n-[plugins]: https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md\n-\n-With that said, let\u2019s make a directory in our projects directory.\n+Now that you have Rust installed, we'll help you write your first Rust program.\n+It's traditional when learning a new language to write a little program to\n+print the text \u201cHello, world!\u201d to the screen, and in this section, we'll follow\n+that tradition. \n+\n+The nice thing about starting with such a simple program is that you can\n+quickly verify that your compiler is installed, and that it's working properly.\n+Printing information to the screen is also just a pretty common thing to do, so\n+practicing it early on is good.\n+\n+> Note: This book assumes basic familiarity with the command line. Rust itself\n+> makes no specific demands about your editing, tooling, or where your code\n+> lives, so if you prefer an IDE to the command line, that's an option. You may\n+> want to check out [SolidOak], which was built specifically with Rust in mind.\n+> There are a number of extensions in development by the community, and the\n+> Rust team ships plugins for [various editors]. Configuring your editor or\n+> IDE is out of the scope of this tutorial, so check the documentation for your\n+> specific setup. \n+\n+[SolidOak]: https://github.com/oakes/SolidOak\n+[various editors]: https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md\n+\n+## Creating a Project File\n+\n+First, make a file to put your Rust code in. Rust doesn't care where your code\n+lives, but for this book, I suggest making a *projects* directory in your home\n+directory, and keeping all your projects there. Open a terminal and enter the\n+following commands to make a directory for this particular project:\n \n ```bash\n $ mkdir ~/projects\n@@ -33,139 +36,150 @@ $ mkdir hello_world\n $ cd hello_world\n ```\n \n-If we\u2019re on Windows and not using PowerShell, the `~` may not work. Consult the\n-documentation for our shell for more details.\n+> Note: If you\u2019re on Windows and not using PowerShell, the `~` may not work.\n+> Consult the documentation for your shell for more details.\n \n-Let\u2019s make a new source file next. We\u2019ll call our file `main.rs`. Rust files\n-always end in a `.rs` extension, and if we\u2019re using more than one word in a\n-Rust filename, we use an underscore: for example, `linked_list.rs`, not\n-`linkedlist.rs` or `LinkedList.rs`.\n+## Writing and Running a Rust Program\n \n-Now that we\u2019ve got our file open, type this in:\n+Next, make a new source file next and call it *main.rs*. Rust files always end\n+in a *.rs* extension. If you\u2019re using more than one word in your filename, use\n+an underscore to separate them; for example, you'd use *hello_world.rs* rather\n+than *helloworld.rs*.\n+\n+Now open the *main.rs* file you just created, and type the following code:\n \n ```rust\n fn main() {\n     println!(\"Hello, world!\");\n }\n ```\n \n-Save the file, and then type this into our terminal window:\n+Save the file, and go back to your terminal window. On Linux or OSX, enter the\n+following commands:\n \n ```bash\n $ rustc main.rs\n-$ ./main # or main.exe on Windows\n+$ ./main \n Hello, world!\n ```\n \n-Success! Let\u2019s go over what just happened in detail.\n+In Windows, just replace `main` with `main.exe`. Regardless of your operating\n+system, you should see the string `Hello, world!` print to the terminal. If you\n+did, then congratulations! You've officially written a Rust program. That makes\n+you a Rust programmer! Welcome. \n+\n+#Anatomy of a Rust Program\n+\n+Now, let\u2019s go over what just happened in your \"Hello, world!\" program in\n+detail. Here's the first piece of the puzzle:\n \n ```rust\n fn main() {\n \n }\n ```\n \n-These lines define a *function* in Rust. The `main` function is special:\n-it's the beginning of every Rust program. The first line says \"I\u2019m declaring a\n-function named `main` which takes no arguments and returns nothing.\" If there\n-were arguments, they would go inside the parentheses (`(` and `)`), and because\n-we aren\u2019t returning anything from this function, we can omit the return type\n-entirely. We\u2019ll get to it later.\n+These lines define a *function* in Rust. The `main` function is special: it's\n+the beginning of every Rust program. The first line says, \"I\u2019m declaring a\n+function named `main` that currently takes no arguments and returns nothing.\"\n+If there were arguments, they would go inside the parentheses (`(` and `)`),\n+and because we aren\u2019t returning anything from this function, we can omit the\n+return type entirely.\n \n-You\u2019ll also note that the function is wrapped in curly braces (`{` and `}`).\n-Rust requires these around all function bodies. It is also considered good style\n-to put the opening curly brace on the same line as the function declaration,\n-with one space in between.\n+Also note that the function body is wrapped in curly braces (`{` and `}`). Rust\n+requires these around all function bodies. It's considered good style to put\n+the opening curly brace on the same line as the function declaration, with one\n+line space in between.\n \n-Next up is this line:\n+Inside the `main()` function, is this line:\n \n ```rust\n     println!(\"Hello, world!\");\n ```\n \n-This line does all of the work in our little program. There are a number of\n-details that are important here. The first is that it\u2019s indented with four\n-spaces, not tabs. Please configure your editor of choice to insert four spaces\n-with the tab key. We provide some\n-[sample configurations for various editors][configs].\n-\n-[configs]: https://github.com/rust-lang/rust/tree/master/src/etc/CONFIGS.md\n-\n-The second point is the `println!()` part. This is calling a Rust\n-[macro][macro], which is how metaprogramming is done in Rust. If it were a\n-function instead, it would look like this: `println()`. For our purposes, we\n-don\u2019t need to worry about this difference. Just know that sometimes, we\u2019ll see a\n-`!`, and that means that we\u2019re calling a macro instead of a normal function.\n-Rust implements `println!` as a macro rather than a function for good reasons,\n-but that's an advanced topic. One last thing to mention: Rust\u2019s macros are\n-significantly different from C macros, if you\u2019ve used those. Don\u2019t be scared of\n-using macros. We\u2019ll get to the details eventually, you\u2019ll just have to take it\n-on trust for now.\n+This line does all of the work in this little program: it prints text to the\n+screen. There are a number of details that are important here. The first is\n+that it\u2019s indented with four spaces, not tabs. If you configure your editor of\n+choice to insert four spaces with the tab key, it will make your coding much\n+more efficient.\n+ \n+The second important part is the `println!()` line. This is calling a Rust\n+*[macro]*, which is how metaprogramming is done in Rust. If it were calling a\n+function instead, it would look like this: `println()` (without the !). We'll\n+discuss Rust macros in more detail in Chapter XX, but for now you just need to\n+know that when you see a `!` that means that you\u2019re calling a macro instead of\n+a normal function. \n+\n \n [macro]: macros.html\n \n-Next, `\"Hello, world!\"` is a \u2018string\u2019. Strings are a surprisingly complicated\n-topic in a systems programming language, and this is a \u2018statically allocated\u2019\n-string. If you want to read further about allocation, check out [the stack and\n-the heap][allocation], but you don\u2019t need to right now if you don\u2019t want to. We\n-pass this string as an argument to `println!`, which prints the string to the\n-screen. Easy enough!\n+Next is `\"Hello, world!\"` which is a *string*. Strings are a surprisingly\n+complicated topic in a systems programming language, and this is a *[statically\n+allocated]* string. We pass this string as an argument to `println!`, which\n+prints the string to the screen. Easy enough!\n \n [allocation]: the-stack-and-the-heap.html\n \n-Finally, the line ends with a semicolon (`;`). Rust is an [\u2018expression oriented\u2019\n-language][expression-oriented language], which means that most things are\n-expressions, rather than statements. The `;` is used to indicate that this\n-expression is over, and the next one is ready to begin. Most lines of Rust code\n-end with a `;`.\n+The line ends with a semicolon (`;`). Rust is an *[expression oriented]*\n+language, which means that most things are expressions, rather than statements.\n+The `;` indicates that this expression is over, and the next one is ready to\n+begin. Most lines of Rust code end with a `;`.\n \n [expression-oriented language]: glossary.html#expression-oriented-language\n \n-Finally, actually compiling and running our program. We can compile with our\n-compiler, `rustc`, by passing it the name of our source file:\n+# Compiling and Running Are Separate Steps\n+\n+In \"Writing and Running a Rust Program\", we showed you how to run a newly\n+created program. We'll break that process down and examine each step now. \n+\n+Before running a Rust program, you have to compile it. You can use the Rust\n+compiler by entering the `rustc` command and passing it the name of your source\n+file, like this:\n \n ```bash\n $ rustc main.rs\n ```\n \n-This is similar to `gcc` or `clang`, if you come from a C or C++ background.\n-Rust will output a binary executable. We can see it with `ls`:\n+If you come from a C or C++ background, you'll notice that this is similar to\n+`gcc` or `clang`. After compiling successfully, Rust should output a binary\n+executable, which you can see on Linux or OSX by entering the `ls` command in\n+your shell as follows:\n \n ```bash\n $ ls\n main  main.rs\n ```\n \n-Or on Windows:\n+On Windows, you'd enter:\n \n ```bash\n $ dir\n main.exe  main.rs\n ```\n \n-There are now two files: our source code, with the `.rs` extension, and the\n-executable (`main.exe` on Windows, `main` everywhere else).\n+This would create two files: the source code, with a `.rs` extension, and the\n+executable (`main.exe` on Windows, `main` everywhere else). All that's left to\n+do from here is run the `main` or `main.exe` file, like this:\n \n ```bash\n $ ./main  # or main.exe on Windows\n ```\n \n-This prints out our `Hello, world!` text to our terminal.\n+If *main.rs* were your \"Hello, world!\" program, this would print `Hello,\n+world!` to your terminal.\n \n If you come from a dynamic language like Ruby, Python, or JavaScript, you may\n-not be used to these two steps being separate. Rust is an \u2018ahead-of-time\n-compiled language\u2019, which means that we can compile a program, give it to\n-someone else, and they don't need to have Rust installed. If we give someone a\n-`.rb` or `.py` or `.js` file, they need to have a Ruby/Python/JavaScript\n-implementation installed, but we just need one command to both compile and run\n-our program. Everything is a tradeoff in language design, and Rust has made its\n-choice.\n-\n-Congratulations! You have officially written a Rust program. That makes you a\n-Rust programmer! Welcome. \ud83c\udf8a\ud83c\udf89\ud83d\udc4d\n-\n-Next, I'd like to introduce you to another tool, Cargo, which is used to write\n-real-world Rust programs. Just using `rustc` is nice for simple things, but as\n-our project grows, we'll want something to help us manage all of the options\n-that it has, and to make it easy to share our code with other people and\n-projects.\n+not be used to compiling and running a program being separate steps. Rust is an\n+*ahead-of-time compiled* language, which means that you can compile a program,\n+give it to someone else, and they can run it even without Rust installed. If\n+you give someone a `.rb` or `.py` or `.js` file, on the other hand, they need\n+to have a Ruby, Python, or JavaScript implementation installed (respectively),\n+but you only need one command to both compile and run your program. Everything\n+is a tradeoff in language design, and Rust has made its choice.\n+\n+Just compiling with `rustc` is fine for simple programs, but as your project\n+grows, you'll want to be able to manage all of the options your project has,\n+and make it easy to share your code with other people and projects. Next, I'll\n+introduce you to a tool called Cargo, which will help you write real-world Rust\n+programs.\n+"}, {"sha": "bf97436a1c5391f2869e2720933b4cfc2eba609c", "filename": "src/doc/trpl/installing-rust.md", "status": "modified", "additions": 66, "deletions": 71, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/75a6d5175062bf799075a96e58dad79daa195520/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/75a6d5175062bf799075a96e58dad79daa195520/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finstalling-rust.md?ref=75a6d5175062bf799075a96e58dad79daa195520", "patch": "@@ -1,67 +1,14 @@\n % Installing Rust\n \n-The first step to using Rust is to install it! There are a number of ways to\n-install Rust, but the easiest is to use the `rustup` script. If we're on Linux\n-or a Mac, all we need to do is this:\n+The first step to using Rust is to install it. Generally speaking, you\u2019ll need\n+an internet connection to run the commands in this chapter, as we\u2019ll be\n+downloading Rust from the internet.\n \n-> Note: we don't need to type in the `$`s, they are there to indicate the start of\n-> each command. We\u2019ll see many tutorials and examples around the web that\n-> follow this convention: `$` for commands run as our regular user, and `#` for\n-> commands we should be running as an administrator.\n-\n-```bash\n-$ curl -sf -L https://static.rust-lang.org/rustup.sh | sh\n-```\n-\n-If we're concerned about the [potential insecurity][insecurity] of using `curl |\n-sh`, please keep reading and see our disclaimer below. And feel free to use a\n-two-step version of the installation and examine our installation script:\n-\n-```bash\n-$ curl -f -L https://static.rust-lang.org/rustup.sh -O\n-$ sh rustup.sh\n-```\n-\n-[insecurity]: http://curlpipesh.tumblr.com\n-\n-If you're on Windows, please download the appropriate [installer][install-page].\n-\n-> Note: By default, the Windows installer won't add Rust to the %PATH% system\n-> variable. If this is the only version of Rust we are installing and we want to\n-> be able to run it from the command line, click on \"Advanced\" on the install\n-> dialog and on the \"Product Features\" page ensure \"Add to PATH\" is installed on\n-> the local hard drive.\n-\n-\n-[install-page]: https://www.rust-lang.org/install.html\n-\n-## Uninstalling\n-\n-If you decide you don't want Rust anymore, we'll be a bit sad, but that's okay.\n-Not every programming language is great for everyone. We can run the\n-uninstall script:\n-\n-```bash\n-$ sudo /usr/local/lib/rustlib/uninstall.sh\n-```\n-\n-If we used the Windows installer, we can re-run the `.msi` and it will give\n-us an uninstall option.\n-\n-## That disclaimer we promised\n-\n-Some people, and somewhat rightfully so, get very upset when we tell them to\n-`curl | sh`. Their concern is that `curl | sh` implicitly requires you to trust\n-that the good people who maintain Rust aren't going to hack your computer and\n-do bad things \u2014 and even having accepted that, there is still the possibility\n-that the Rust website has been hacked and the `rustup` script compromised.\n-\n-Being wary of such possibilities is a good instinct! If you're uncomfortable\n-using `curl | sh` for reasons like these, please check out the documentation on\n-[building Rust from Source][from-source], or\n-[the official binary downloads][install-page].\n-\n-[from-source]: https://github.com/rust-lang/rust#building-from-source\n+We\u2019ll be showing off a number of commands using a terminal, and those lines all\n+start with `$`. We don't need to type in the `$`s, they are there to indicate\n+the start of each command. We\u2019ll see many tutorials and examples around the web\n+that follow this convention: `$` for commands run as our regular user, and `#`\n+for commands we should be running as an administrator.\n \n ## Platform support\n \n@@ -96,10 +43,10 @@ Specifically they will each satisfy the following requirements:\n \n ### Tier 2\n \n-Tier 2 platforms can be thought of as \"guaranteed to build\". Automated tests are\n-not run so it's not guaranteed to produce a working build, but platforms often\n-work to quite a good degree and patches are always welcome! Specifically, these\n-platforms are required to have each of the following:\n+Tier 2 platforms can be thought of as \"guaranteed to build\". Automated tests\n+are not run so it's not guaranteed to produce a working build, but platforms\n+often work to quite a good degree and patches are always welcome! Specifically,\n+these platforms are required to have each of the following:\n \n * Automated building is set up, but may not be running tests.\n * Landing changes to the `rust-lang/rust` repository's master branch is gated on\n@@ -150,7 +97,55 @@ unofficial locations.\n Note that this table can be expanded over time, this isn't the exhaustive set of\n tier 3 platforms that will ever be!\n \n-## After installation\n+## Installing on Linux or Mac\n+\n+If we're on Linux or a Mac, all we need to do is open a terminal and type this:\n+\n+```bash\n+$ curl -sf -L https://static.rust-lang.org/rustup.sh | sh\n+```\n+\n+This will download a script, and stat the installation. If it all goes well,\n+you\u2019ll see this appear:\n+\n+```\n+Welcome to Rust.\n+\n+This script will download the Rust compiler and its package manager, Cargo, and\n+install them to /usr/local. You may install elsewhere by running this script\n+with the --prefix=<path> option.\n+\n+The installer will run under \u2018sudo\u2019 and may ask you for your password. If you do\n+not want the script to run \u2018sudo\u2019 then pass it the --disable-sudo flag.\n+\n+You may uninstall later by running /usr/local/lib/rustlib/uninstall.sh,\n+or by running this script again with the --uninstall flag.\n+\n+Continue? (y/N) \n+```\n+\n+From here, press `y` for \u2018yes\u2019, and then follow the rest of the prompts.\n+\n+## Installing on Windows\n+\n+If you're on Windows, please download the appropriate [installer][install-page].\n+\n+[install-page]: https://www.rust-lang.org/install.html\n+\n+## Uninstalling\n+\n+If you ever need to uninstall Rust for any reason, refer to this section to\n+find out how. It's actually as easy as installing. On Linux or Mac, just run\n+the uninstall script:\n+\n+```bash\n+$ sudo /usr/local/lib/rustlib/uninstall.sh\n+```\n+\n+If we used the Windows installer, we can re-run the `.msi` and it will give us\n+an uninstall option.\n+\n+## Troubleshooting\n \n If we've got Rust installed, we can open up a shell, and type this:\n \n@@ -162,16 +157,16 @@ You should see the version number, commit hash, and commit date.\n \n If you do, Rust has been installed successfully! Congrats!\n \n+This installer also installs a copy of the documentation locally, so we can\n+read it offline. On UNIX systems, `/usr/local/share/doc/rust` is the location.\n+On Windows, it's in a `share/doc` directory, inside the directory to which Rust\n+was installed.\n+\n If you don't and you're on Windows, check that Rust is in your %PATH% system\n variable. If it isn't, run the installer again, select \"Change\" on the \"Change,\n repair, or remove installation\" page and ensure \"Add to PATH\" is installed on\n the local hard drive.\n \n-This installer also installs a copy of the documentation locally, so we can read\n-it offline. On UNIX systems, `/usr/local/share/doc/rust` is the location. On\n-Windows, it's in a `share/doc` directory, inside the directory to which Rust was\n-installed.\n-\n If not, there are a number of places where we can get help. The easiest is\n [the #rust IRC channel on irc.mozilla.org][irc], which we can access through\n [Mibbit][mibbit]. Click that link, and we'll be chatting with other Rustaceans"}]}