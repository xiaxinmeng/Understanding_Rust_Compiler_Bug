{"sha": "0e77dd947304b892bf3277e0f4a75600737c6843", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNzdkZDk0NzMwNGI4OTJiZjMyNzdlMGY0YTc1NjAwNzM3YzY4NDM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-03T14:47:23Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-03T14:47:23Z"}, "message": "rustup", "tree": {"sha": "34dc79440163d71031e0db5d2d00d73e92b0ab12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34dc79440163d71031e0db5d2d00d73e92b0ab12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e77dd947304b892bf3277e0f4a75600737c6843", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e77dd947304b892bf3277e0f4a75600737c6843", "html_url": "https://github.com/rust-lang/rust/commit/0e77dd947304b892bf3277e0f4a75600737c6843", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e77dd947304b892bf3277e0f4a75600737c6843/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1752af689f57667173f844eafda93bfa86c98ba4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1752af689f57667173f844eafda93bfa86c98ba4", "html_url": "https://github.com/rust-lang/rust/commit/1752af689f57667173f844eafda93bfa86c98ba4"}], "stats": {"total": 170, "additions": 96, "deletions": 74}, "files": [{"sha": "8ff1b418b1a4743c2b8b49a0e3668dcb2391f22d", "filename": "src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e77dd947304b892bf3277e0f4a75600737c6843/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e77dd947304b892bf3277e0f4a75600737c6843/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=0e77dd947304b892bf3277e0f4a75600737c6843", "patch": "@@ -8,7 +8,7 @@ extern crate rustc_errors;\n extern crate env_logger;\n extern crate log_settings;\n extern crate syntax;\n-#[macro_use] extern crate log;\n+extern crate log;\n \n use rustc::session::Session;\n use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};"}, {"sha": "defb4e5c882e933f927a0b86c5daa07d0b7a587f", "filename": "src/eval_context.rs", "status": "modified", "additions": 90, "deletions": 69, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/0e77dd947304b892bf3277e0f4a75600737c6843/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e77dd947304b892bf3277e0f4a75600737c6843/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=0e77dd947304b892bf3277e0f4a75600737c6843", "patch": "@@ -643,9 +643,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n-            ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n-            ty::TyBox(ty) => !self.type_is_sized(ty),\n+            ty::TyRawPtr(ref tam) |\n+            ty::TyRef(_, ref tam) => !self.type_is_sized(tam.ty),\n+            ty::TyAdt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n             _ => false,\n         }\n     }\n@@ -686,26 +686,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         Ok((offset, ty))\n     }\n+    fn get_fat_field(&self, pointee_ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Ty<'tcx>> {\n+        match (field_index, &self.tcx.struct_tail(pointee_ty).sty) {\n+            (1, &ty::TyStr) |\n+            (1, &ty::TySlice(_)) => Ok(self.tcx.types.usize),\n+            (1, &ty::TyDynamic(..)) |\n+            (0, _) => Ok(self.tcx.mk_imm_ptr(self.tcx.types.u8)),\n+            _ => bug!(\"invalid fat pointee type: {}\", pointee_ty),\n+        }\n+    }\n \n     pub fn get_field_ty(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Ty<'tcx>> {\n         match ty.sty {\n+            ty::TyAdt(adt_def, _) if adt_def.is_box() => self.get_fat_field(ty.boxed_ty(), field_index),\n             ty::TyAdt(adt_def, substs) => {\n                 Ok(adt_def.struct_variant().fields[field_index].ty(self.tcx, substs))\n             }\n \n             ty::TyTuple(fields) => Ok(fields[field_index]),\n \n-            ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-            ty::TyBox(ty) => {\n-                match (field_index, &self.tcx.struct_tail(ty).sty) {\n-                    (1, &ty::TyStr) |\n-                    (1, &ty::TySlice(_)) => Ok(self.tcx.types.usize),\n-                    (1, &ty::TyDynamic(..)) |\n-                    (0, _) => Ok(self.tcx.mk_imm_ptr(self.tcx.types.u8)),\n-                    _ => bug!(\"invalid fat pointee type: {}\", ty),\n-                }\n-            }\n+            ty::TyRef(_, ref tam) |\n+            ty::TyRawPtr(ref tam) => self.get_fat_field(tam.ty, field_index),\n             _ => Err(EvalError::Unimplemented(format!(\"can't handle type: {:?}, {:?}\", ty, ty.sty))),\n         }\n     }\n@@ -1044,9 +1045,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             ty::TyFnPtr(_) => PrimValKind::FnPtr,\n \n-            ty::TyBox(ty) |\n-            ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) if self.type_is_sized(ty) => PrimValKind::Ptr,\n+            ty::TyRef(_, ref tam) |\n+            ty::TyRawPtr(ref tam) if self.type_is_sized(tam.ty) => PrimValKind::Ptr,\n+\n+            ty::TyAdt(ref def, _) if def.is_box() => PrimValKind::Ptr,\n \n             ty::TyAdt(..) => {\n                 use rustc::ty::layout::Layout::*;\n@@ -1100,6 +1102,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n+    fn read_ptr(&mut self, ptr: Pointer, pointee_ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+        let p = self.memory.read_ptr(ptr)?;\n+        if self.type_is_sized(pointee_ty) {\n+            Ok(Value::ByVal(PrimVal::Ptr(p)))\n+        } else {\n+            trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n+            let extra = ptr.offset(self.memory.pointer_size());\n+            let extra = match self.tcx.struct_tail(pointee_ty).sty {\n+                ty::TyDynamic(..) => PrimVal::Ptr(self.memory.read_ptr(extra)?),\n+                ty::TySlice(..) |\n+                ty::TyStr => PrimVal::from_u128(self.memory.read_usize(extra)? as u128),\n+                _ => bug!(\"unsized primval ptr read from {:?}\", pointee_ty),\n+            };\n+            Ok(Value::ByValPair(PrimVal::Ptr(p), extra))\n+        }\n+    }\n+\n     fn try_read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         use syntax::ast::FloatTy;\n \n@@ -1143,26 +1162,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr)?),\n \n             ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::Ptr)?,\n-            ty::TyBox(ty) |\n-            ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n-                let p = self.memory.read_ptr(ptr)?;\n-                if self.type_is_sized(ty) {\n-                    PrimVal::Ptr(p)\n-                } else {\n-                    trace!(\"reading fat pointer extra of type {}\", ty);\n-                    let extra = ptr.offset(self.memory.pointer_size());\n-                    let extra = match self.tcx.struct_tail(ty).sty {\n-                        ty::TyDynamic(..) => PrimVal::Ptr(self.memory.read_ptr(extra)?),\n-                        ty::TySlice(..) |\n-                        ty::TyStr => PrimVal::from_u128(self.memory.read_usize(extra)? as u128),\n-                        _ => bug!(\"unsized primval ptr read from {:?}\", ty),\n-                    };\n-                    return Ok(Some(Value::ByValPair(PrimVal::Ptr(p), extra)));\n-                }\n-            }\n+            ty::TyRef(_, ref tam) |\n+            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr, tam.ty).map(Some),\n \n-            ty::TyAdt(..) => {\n+            ty::TyAdt(def, _) => {\n+                if def.is_box() {\n+                    return self.read_ptr(ptr, ty.boxed_ty()).map(Some);\n+                }\n                 use rustc::ty::layout::Layout::*;\n                 if let CEnum { discr, signed, .. } = *self.type_layout(ty)? {\n                     let size = discr.size().bytes();\n@@ -1198,6 +1204,45 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.frame().substs\n     }\n \n+    fn unsize_into_ptr(\n+        &mut self,\n+        src: Value,\n+        src_ty: Ty<'tcx>,\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+        sty: Ty<'tcx>,\n+        dty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, ()> {\n+        // A<Struct> -> A<Trait> conversion\n+        let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n+\n+        match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n+            (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n+                let ptr = src.read_ptr(&self.memory)?;\n+                let len = PrimVal::from_u128(length as u128);\n+                let ptr = PrimVal::Ptr(ptr);\n+                self.write_value(Value::ByValPair(ptr, len), dest, dest_ty)\n+            }\n+            (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n+                // For now, upcasts are limited to changes in marker\n+                // traits, and hence never actually require an actual\n+                // change to the vtable.\n+                self.write_value(src, dest, dest_ty)\n+            },\n+            (_, &ty::TyDynamic(ref data, _)) => {\n+                let trait_ref = data.principal().unwrap().with_self_ty(self.tcx, src_pointee_ty);\n+                let trait_ref = self.tcx.erase_regions(&trait_ref);\n+                let vtable = self.get_vtable(trait_ref)?;\n+                let ptr = src.read_ptr(&self.memory)?;\n+                let ptr = PrimVal::Ptr(ptr);\n+                let extra = PrimVal::Ptr(vtable);\n+                self.write_value(Value::ByValPair(ptr, extra), dest, dest_ty)\n+            },\n+\n+            _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n+        }\n+    }\n+\n     fn unsize_into(\n         &mut self,\n         src: Value,\n@@ -1206,40 +1251,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, ()> {\n         match (&src_ty.sty, &dest_ty.sty) {\n-            (&ty::TyBox(sty), &ty::TyBox(dty)) |\n-            (&ty::TyRef(_, ty::TypeAndMut { ty: sty, .. }), &ty::TyRef(_, ty::TypeAndMut { ty: dty, .. })) |\n-            (&ty::TyRef(_, ty::TypeAndMut { ty: sty, .. }), &ty::TyRawPtr(ty::TypeAndMut { ty: dty, .. })) |\n-            (&ty::TyRawPtr(ty::TypeAndMut { ty: sty, .. }), &ty::TyRawPtr(ty::TypeAndMut { ty: dty, .. })) => {\n-                // A<Struct> -> A<Trait> conversion\n-                let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n-\n-                match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n-                    (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n-                        let ptr = src.read_ptr(&self.memory)?;\n-                        let len = PrimVal::from_u128(length as u128);\n-                        let ptr = PrimVal::Ptr(ptr);\n-                        self.write_value(Value::ByValPair(ptr, len), dest, dest_ty)?;\n+            (&ty::TyRef(_, ref s), &ty::TyRef(_, ref d)) |\n+            (&ty::TyRef(_, ref s), &ty::TyRawPtr(ref d)) |\n+            (&ty::TyRawPtr(ref s), &ty::TyRawPtr(ref d)) => self.unsize_into_ptr(src, src_ty, dest, dest_ty, s.ty, d.ty),\n+            (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) => {\n+                if def_a.is_box() || def_b.is_box() {\n+                    if !def_a.is_box() || !def_b.is_box() {\n+                        panic!(\"invalid unsizing between {:?} -> {:?}\", src_ty, dest_ty);\n                     }\n-                    (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n-                        // For now, upcasts are limited to changes in marker\n-                        // traits, and hence never actually require an actual\n-                        // change to the vtable.\n-                        self.write_value(src, dest, dest_ty)?;\n-                    },\n-                    (_, &ty::TyDynamic(ref data, _)) => {\n-                        let trait_ref = data.principal().unwrap().with_self_ty(self.tcx, src_pointee_ty);\n-                        let trait_ref = self.tcx.erase_regions(&trait_ref);\n-                        let vtable = self.get_vtable(trait_ref)?;\n-                        let ptr = src.read_ptr(&self.memory)?;\n-                        let ptr = PrimVal::Ptr(ptr);\n-                        let extra = PrimVal::Ptr(vtable);\n-                        self.write_value(Value::ByValPair(ptr, extra), dest, dest_ty)?;\n-                    },\n-\n-                    _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n+                    return self.unsize_into_ptr(src, src_ty, dest, dest_ty, src_ty.boxed_ty(), dest_ty.boxed_ty());\n                 }\n-            }\n-            (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) => {\n                 // FIXME(solson)\n                 let dest = self.force_allocation(dest)?.to_ptr();\n                 // unsizing of generic struct with pointer fields\n@@ -1275,10 +1296,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         self.unsize_into(Value::ByRef(src_f_ptr), src_fty, Lvalue::from_ptr(dst_f_ptr), dst_fty)?;\n                     }\n                 }\n+                Ok(())\n             }\n             _ => bug!(\"unsize_into: invalid conversion: {:?} -> {:?}\", src_ty, dest_ty),\n         }\n-        Ok(())\n     }\n \n     pub(super) fn dump_local(&self, lvalue: Lvalue<'tcx>) {"}, {"sha": "4a94abf0a569ad393da9b5f7d3967333bcd7c7f0", "filename": "src/lvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e77dd947304b892bf3277e0f4a75600737c6843/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e77dd947304b892bf3277e0f4a75600737c6843/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=0e77dd947304b892bf3277e0f4a75600737c6843", "patch": "@@ -241,9 +241,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let val = self.eval_and_read_lvalue(&proj.base)?;\n \n                 let pointee_type = match base_ty.sty {\n-                    ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n-                    ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n-                    ty::TyBox(ty) => ty,\n+                    ty::TyRawPtr(ref tam) |\n+                    ty::TyRef(_, ref tam) => tam.ty,\n+                    ty::TyAdt(ref def, _) if def.is_box() => base_ty.boxed_ty(),\n                     _ => bug!(\"can only deref pointer types\"),\n                 };\n "}, {"sha": "b7e4549f7d5d2bd8aeeb0c42802869b99bca02ee", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e77dd947304b892bf3277e0f4a75600737c6843/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e77dd947304b892bf3277e0f4a75600737c6843/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=0e77dd947304b892bf3277e0f4a75600737c6843", "patch": "@@ -626,7 +626,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         match ty.sty {\n             // special case `Box` to deallocate the inner allocation\n-            ty::TyBox(contents_ty) => {\n+            ty::TyAdt(ref def, _) if def.is_box() => {\n+                let contents_ty = ty.boxed_ty();\n                 let val = self.read_lvalue(lval);\n                 // we are going through the read_value path, because that already does all the\n                 // checks for the trait object types. We'd only be repeating ourselves here."}]}