{"sha": "74dc845c2de24924f143e345358103102c9f8ed5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZGM4NDVjMmRlMjQ5MjRmMTQzZTM0NTM1ODEwMzEwMmM5ZjhlZDU=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-03T14:52:48Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-03T14:52:48Z"}, "message": "Merge branch 'master' into redox", "tree": {"sha": "d6ce59e7b1dec09d462b9a215393ceeac7cf618e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6ce59e7b1dec09d462b9a215393ceeac7cf618e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74dc845c2de24924f143e345358103102c9f8ed5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74dc845c2de24924f143e345358103102c9f8ed5", "html_url": "https://github.com/rust-lang/rust/commit/74dc845c2de24924f143e345358103102c9f8ed5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74dc845c2de24924f143e345358103102c9f8ed5/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "123d08b3d3901d5725af8303c1329b007089cde5", "url": "https://api.github.com/repos/rust-lang/rust/commits/123d08b3d3901d5725af8303c1329b007089cde5", "html_url": "https://github.com/rust-lang/rust/commit/123d08b3d3901d5725af8303c1329b007089cde5"}, {"sha": "ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0", "html_url": "https://github.com/rust-lang/rust/commit/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0"}], "stats": {"total": 4248, "additions": 2972, "deletions": 1276}, "files": [{"sha": "0bc9a4ad4198c35f89d485b145764736a606aeaf", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -15,7 +15,7 @@ before_install:\n script:\n   - docker run -v `pwd`:/build rust\n     sh -c \"\n-      ./configure --enable-rustbuild --llvm-root=/usr/lib/llvm-3.7 &&\n+      ./configure --enable-rustbuild --llvm-root=/usr/lib/llvm-3.7 --enable-quiet-tests &&\n       make tidy &&\n       make check -j4\n     \""}, {"sha": "cd22229b7993aa71f559124f7dfe18cea998870e", "filename": "configure", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/configure", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -507,11 +507,16 @@ case $CFG_CPUTYPE in\n         CFG_CPUTYPE=arm\n         ;;\n \n-    armv7l)\n+    armv6l)\n         CFG_CPUTYPE=arm\n         CFG_OSTYPE=\"${CFG_OSTYPE}eabihf\"\n         ;;\n \n+    armv7l)\n+        CFG_CPUTYPE=armv7\n+        CFG_OSTYPE=\"${CFG_OSTYPE}eabihf\"\n+        ;;\n+\n     aarch64)\n         CFG_CPUTYPE=aarch64\n         ;;\n@@ -610,6 +615,7 @@ opt docs     1 \"build standard library documentation\"\n opt compiler-docs     0 \"build compiler documentation\"\n opt optimize-tests 1 \"build tests with optimizations\"\n opt debuginfo-tests 0 \"build tests with debugger metadata\"\n+opt quiet-tests 0 \"enable quieter output when running tests\"\n opt libcpp 1 \"build llvm with libc++ instead of libstdc++ when using clang\"\n opt llvm-assertions 0 \"build LLVM with assertions\"\n opt debug-assertions 0 \"build with debugging assertions\""}, {"sha": "0a281b89c571f0bcdbf166adf831906acc79f268", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -187,6 +187,10 @@ pub fn compiletest(build: &Build,\n         cmd.arg(\"--verbose\");\n     }\n \n+    if build.config.quiet_tests {\n+        cmd.arg(\"--quiet\");\n+    }\n+\n     // Only pass correct values for these flags for the `run-make` suite as it\n     // requires that a C++ compiler was configured which isn't always the case.\n     if suite == \"run-make\" {\n@@ -277,7 +281,13 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n     build.add_rustc_lib_path(compiler, &mut cmd);\n     cmd.arg(\"--test\");\n     cmd.arg(markdown);\n-    cmd.arg(\"--test-args\").arg(build.flags.args.join(\" \"));\n+\n+    let mut test_args = build.flags.args.join(\" \");\n+    if build.config.quiet_tests {\n+        test_args.push_str(\" --quiet\");\n+    }\n+    cmd.arg(\"--test-args\").arg(test_args);\n+\n     build.run(&mut cmd);\n }\n \n@@ -367,6 +377,11 @@ pub fn krate(build: &Build,\n     dylib_path.insert(0, build.sysroot_libdir(compiler, target));\n     cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n+    if build.config.quiet_tests {\n+        cargo.arg(\"--\");\n+        cargo.arg(\"--quiet\");\n+    }\n+\n     if target.contains(\"android\") {\n         build.run(cargo.arg(\"--no-run\"));\n         krate_android(build, compiler, target, mode);"}, {"sha": "abaa9389d809a90959edce68f4c6a50d154c1b46", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -77,6 +77,7 @@ pub struct Config {\n \n     // misc\n     pub channel: String,\n+    pub quiet_tests: bool,\n     // Fallback musl-root for all targets\n     pub musl_root: Option<PathBuf>,\n     pub prefix: Option<String>,\n@@ -338,6 +339,7 @@ impl Config {\n                 (\"RPATH\", self.rust_rpath),\n                 (\"OPTIMIZE_TESTS\", self.rust_optimize_tests),\n                 (\"DEBUGINFO_TESTS\", self.rust_debuginfo_tests),\n+                (\"QUIET_TESTS\", self.quiet_tests),\n                 (\"LOCAL_REBUILD\", self.local_rebuild),\n                 (\"NINJA\", self.ninja),\n                 (\"CODEGEN_TESTS\", self.codegen_tests),"}, {"sha": "b7b67a9f1d0988822646bde66c7e7850d1c9a767", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -510,12 +510,11 @@ fn factory() -> Box<Fn(i32) -> i32> {\n \n     Box::new(|x| x + num)\n }\n-# fn main() {\n+\n let f = factory();\n \n let answer = f(1);\n assert_eq!(6, answer);\n-# }\n ```\n \n There\u2019s just one last problem:\n@@ -540,12 +539,11 @@ fn factory() -> Box<Fn(i32) -> i32> {\n \n     Box::new(move |x| x + num)\n }\n-fn main() {\n+\n let f = factory();\n \n let answer = f(1);\n assert_eq!(6, answer);\n-}\n ```\n \n By making the inner closure a `move Fn`, we create a new stack frame for our"}, {"sha": "a3ab4803bc4d1d27bbd7eb53333aded8f27b0e28", "filename": "src/doc/book/guessing-game.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Fdoc%2Fbook%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Fdoc%2Fbook%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fguessing-game.md?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -362,7 +362,6 @@ numbers. A bare number like above is actually shorthand for `^0.3.0`,\n meaning \"anything compatible with 0.3.0\".\n If we wanted to use only `0.3.0` exactly, we could say `rand=\"=0.3.0\"`\n (note the two equal signs).\n-And if we wanted to use the latest version we could use `rand=\"*\"`.\n We could also use a range of versions.\n [Cargo\u2019s documentation][cargodoc] contains more details.\n "}, {"sha": "0e6cdb8f09ddcdcb6f752f03b5df555695f0d392", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -24,9 +24,11 @@ Cargo will automatically generate a simple test when you make a new project.\n Here's the contents of `src/lib.rs`:\n \n ```rust\n-# fn main() {}\n-#[test]\n-fn it_works() {\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn it_works() {\n+    }\n }\n ```\n \n@@ -36,11 +38,11 @@ currently has no body. That's good enough to pass! We can run the tests with\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n-test it_works ... ok\n+test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -56,7 +58,7 @@ for the test we wrote, and another for documentation tests. We'll talk about\n those later. For now, see this line:\n \n ```text\n-test it_works ... ok\n+test tests::it_works ... ok\n ```\n \n Note the `it_works`. This comes from the name of our function:\n@@ -89,31 +91,30 @@ run our tests again:\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n-test it_works ... FAILED\n+test tests::it_works ... FAILED\n \n failures:\n \n----- it_works stdout ----\n-        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3\n-\n+---- test::it_works stdout ----\n+        thread 'tests::it_works' panicked at 'assertion failed: false', src/lib.rs:5\n \n \n failures:\n-    it_works\n+    tests::it_works\n \n test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n \n-thread 'main' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247\n+error: test failed\n ```\n \n Rust indicates that our test failed:\n \n ```text\n-test it_works ... FAILED\n+test tests::it_works ... FAILED\n ```\n \n And that's reflected in the summary line:\n@@ -159,11 +160,11 @@ This test will now succeed if we `panic!` and fail if we complete. Let's try it:\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n-test it_works ... ok\n+test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -191,11 +192,11 @@ passes:\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n-test it_works ... ok\n+test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n@@ -262,8 +263,8 @@ not:\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 2 tests\n test expensive_test ... ignored\n@@ -282,7 +283,7 @@ The expensive tests can be run explicitly using `cargo test -- --ignored`:\n \n ```bash\n $ cargo test -- --ignored\n-     Running target/adder-91b3e234d4ed382a\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n test expensive_test ... ok\n@@ -302,8 +303,11 @@ which is why the command is `cargo test -- --ignored`.\n # The `tests` module\n \n There is one way in which our existing example is not idiomatic: it's\n-missing the `tests` module. The idiomatic way of writing our example\n-looks like this:\n+missing the `tests` module. You might have noticed this test module was\n+present in the code that was initially generated with `cargo new` but\n+was missing from our last example. Let's explain what this does.\n+\n+The idiomatic way of writing our example looks like this:\n \n ```rust,ignore\n # fn main() {}\n@@ -356,8 +360,8 @@ Note the different `use` line. Now we run our tests:\n ```bash\n $ cargo test\n     Updating registry `https://github.com/rust-lang/crates.io-index`\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n test tests::it_works ... ok\n@@ -404,15 +408,15 @@ Let's run them:\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0 (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n-     Running target/lib-c18e7d3494509e74\n+     Running target/debug/integration_test-68064b69521c828a\n \n running 1 test\n test it_works ... ok\n@@ -490,15 +494,15 @@ Let's run the tests again:\n \n ```bash\n $ cargo test\n-   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)\n-     Running target/adder-91b3e234d4ed382a\n+   Compiling adder v0.1.0. (file:///home/you/projects/adder)\n+     Running target/debug/deps/adder-91b3e234d4ed382a\n \n running 1 test\n test tests::it_works ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n \n-     Running target/lib-c18e7d3494509e74\n+     Running target/debug/integration_test-68064b69521c828a\n \n running 1 test\n test it_works ... ok"}, {"sha": "75796cf94bfc2bbc37a2915284dad4f040cb5e0c", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -1170,7 +1170,7 @@ impl<T> [T] {\n     /// let x = s.into_vec();\n     /// // `s` cannot be used anymore because it has been converted into `x`.\n     ///\n-    /// assert_eq!(x, vec!(10, 40, 30));\n+    /// assert_eq!(x, vec![10, 40, 30]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "d94a27917e869434d67fb5c320a07e574e17f3fe", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -148,15 +148,15 @@ use super::range::RangeArgument;\n /// [`Index`] trait. An example will be more explicit:\n ///\n /// ```\n-/// let v = vec!(0, 2, 4, 6);\n+/// let v = vec![0, 2, 4, 6];\n /// println!(\"{}\", v[1]); // it will display '2'\n /// ```\n ///\n /// However be careful: if you try to access an index which isn't in the `Vec`,\n /// your software will panic! You cannot do this:\n ///\n /// ```ignore\n-/// let v = vec!(0, 2, 4, 6);\n+/// let v = vec![0, 2, 4, 6];\n /// println!(\"{}\", v[6]); // it will panic!\n /// ```\n ///\n@@ -173,7 +173,7 @@ use super::range::RangeArgument;\n ///     // ...\n /// }\n ///\n-/// let v = vec!(0, 1);\n+/// let v = vec![0, 1];\n /// read_slice(&v);\n ///\n /// // ... and that's all!"}, {"sha": "0daf658a0f42da4e5736fb0cf29e1a7d8f1329a1", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -248,6 +248,80 @@ impl Ordering {\n             Greater => Less,\n         }\n     }\n+\n+    /// Chains two orderings.\n+    ///\n+    /// Returns `self` when it's not `Equal`. Otherwise returns `other`.\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ordering_chaining)]\n+    ///\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let result = Ordering::Equal.then(Ordering::Less);\n+    /// assert_eq!(result, Ordering::Less);\n+    ///\n+    /// let result = Ordering::Less.then(Ordering::Equal);\n+    /// assert_eq!(result, Ordering::Less);\n+    ///\n+    /// let result = Ordering::Less.then(Ordering::Greater);\n+    /// assert_eq!(result, Ordering::Less);\n+    ///\n+    /// let result = Ordering::Equal.then(Ordering::Equal);\n+    /// assert_eq!(result, Ordering::Equal);\n+    ///\n+    /// let x: (i64, i64, i64) = (1, 2, 7);\n+    /// let y: (i64, i64, i64) = (1, 5, 3);\n+    /// let result = x.0.cmp(&y.0).then(x.1.cmp(&y.1)).then(x.2.cmp(&y.2));\n+    ///\n+    /// assert_eq!(result, Ordering::Less);\n+    /// ```\n+    #[unstable(feature = \"ordering_chaining\", issue = \"37053\")]\n+    pub fn then(self, other: Ordering) -> Ordering {\n+        match self {\n+            Equal => other,\n+            _ => self,\n+        }\n+    }\n+\n+    /// Chains the ordering with the given function.\n+    ///\n+    /// Returns `self` when it's not `Equal`. Otherwise calls `f` and returns\n+    /// the result.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ordering_chaining)]\n+    ///\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let result = Ordering::Equal.then_with(|| Ordering::Less);\n+    /// assert_eq!(result, Ordering::Less);\n+    ///\n+    /// let result = Ordering::Less.then_with(|| Ordering::Equal);\n+    /// assert_eq!(result, Ordering::Less);\n+    ///\n+    /// let result = Ordering::Less.then_with(|| Ordering::Greater);\n+    /// assert_eq!(result, Ordering::Less);\n+    ///\n+    /// let result = Ordering::Equal.then_with(|| Ordering::Equal);\n+    /// assert_eq!(result, Ordering::Equal);\n+    ///\n+    /// let x: (i64, i64, i64) = (1, 2, 7);\n+    /// let y: (i64, i64, i64)  = (1, 5, 3);\n+    /// let result = x.0.cmp(&y.0).then_with(|| x.1.cmp(&y.1)).then_with(|| x.2.cmp(&y.2));\n+    ///\n+    /// assert_eq!(result, Ordering::Less);\n+    /// ```\n+    #[unstable(feature = \"ordering_chaining\", issue = \"37053\")]\n+    pub fn then_with<F: FnOnce() -> Ordering>(self, f: F) -> Ordering {\n+        match self {\n+            Equal => f(),\n+            _ => self,\n+        }\n+    }\n }\n \n /// Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order)."}, {"sha": "830bbc079ad1e81cc242c5dbf2f7771d16dc8f09", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -145,7 +145,7 @@ pub trait AsMut<T: ?Sized> {\n ///\n /// # Generic Impls\n ///\n-/// - `[From<T>][From] for U` implies `Into<U> for T`\n+/// - [`From<T>`][From]` for U` implies `Into<U> for T`\n /// - [`into()`] is reflexive, which means that `Into<T> for T` is implemented\n ///\n /// [`TryInto`]: trait.TryInto.html\n@@ -178,14 +178,14 @@ pub trait Into<T>: Sized {\n /// ```\n /// # Generic impls\n ///\n-/// - `From<T> for U` implies `[Into<U>] for T`\n+/// - `From<T> for U` implies [`Into<U>`]` for T`\n /// - [`from()`] is reflexive, which means that `From<T> for T` is implemented\n ///\n /// [`TryFrom`]: trait.TryFrom.html\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n /// [`String`]: ../../std/string/struct.String.html\n-/// [Into<U>]: trait.Into.html\n+/// [`Into<U>`]: trait.Into.html\n /// [`from()`]: trait.From.html#tymethod.from\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait From<T>: Sized {"}, {"sha": "cae46a0dd0feb0f1e8164a724c2df364a65348cd", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -42,12 +42,13 @@ macro_rules! panic {\n /// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n /// violated could lead to unsafety.\n ///\n-/// Other use-cases of `assert!` include\n-/// [testing](https://doc.rust-lang.org/book/testing.html) and enforcing\n-/// run-time invariants in safe code (whose violation cannot result in unsafety).\n+/// Other use-cases of `assert!` include [testing] and enforcing run-time\n+/// invariants in safe code (whose violation cannot result in unsafety).\n ///\n /// This macro has a second version, where a custom panic message can be provided.\n ///\n+/// [testing]: ../book/testing.html\n+///\n /// # Examples\n ///\n /// ```\n@@ -316,26 +317,27 @@ macro_rules! try {\n \n /// Write formatted data into a buffer\n ///\n-/// This macro accepts any value with `write_fmt` method as a writer, a format string, and a list\n-/// of arguments to format.\n+/// This macro accepts a 'writer' (any value with a `write_fmt` method), a format string, and a\n+/// list of arguments to format.\n ///\n-/// `write_fmt` method usually comes from an implementation of [`std::fmt::Write`][fmt_write] or\n-/// [`std::io::Write`][io_write] traits. These are sometimes called 'writers'.\n+/// The `write_fmt` method usually comes from an implementation of [`std::fmt::Write`][fmt_write]\n+/// or [`std::io::Write`][io_write] traits. The term 'writer' refers to an implementation of one of\n+/// these two traits.\n ///\n /// Passed arguments will be formatted according to the specified format string and the resulting\n /// string will be passed to the writer.\n ///\n /// See [`std::fmt`][fmt] for more information on format syntax.\n ///\n-/// Return value is completely dependent on the 'write_fmt' method.\n+/// `write!` returns whatever the 'write_fmt' method returns.\n ///\n-/// Common return values are: [`Result`][enum_result], [`io::Result`][type_result]\n+/// Common return values include: [`fmt::Result`][fmt_result], [`io::Result`][io_result]\n ///\n /// [fmt]: ../std/fmt/index.html\n /// [fmt_write]: ../std/fmt/trait.Write.html\n /// [io_write]: ../std/io/trait.Write.html\n-/// [enum_result]: ../std/result/enum.Result.html\n-/// [type_result]: ../std/io/type.Result.html\n+/// [fmt_result]: ../std/fmt/type.Result.html\n+/// [io_result]: ../std/io/type.Result.html\n ///\n /// # Examples\n ///\n@@ -354,31 +356,32 @@ macro_rules! write {\n     ($dst:expr, $($arg:tt)*) => ($dst.write_fmt(format_args!($($arg)*)))\n }\n \n-/// Write formatted data into a buffer, with appending a newline.\n+/// Write formatted data into a buffer, with a newline appended.\n ///\n /// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n /// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n ///\n-/// This macro accepts any value with `write_fmt` method as a writer, a format string, and a list\n-/// of arguments to format.\n+/// This macro accepts a 'writer' (any value with a `write_fmt` method), a format string, and a\n+/// list of arguments to format.\n ///\n-/// `write_fmt` method usually comes from an implementation of [`std::fmt::Write`][fmt_write] or\n-/// [`std::io::Write`][io_write] traits. These are sometimes called 'writers'.\n+/// The `write_fmt` method usually comes from an implementation of [`std::fmt::Write`][fmt_write]\n+/// or [`std::io::Write`][io_write] traits. The term 'writer' refers to an implementation of one of\n+/// these two traits.\n ///\n /// Passed arguments will be formatted according to the specified format string and the resulting\n-/// string will be passed to the writer.\n+/// string will be passed to the writer, along with the appended newline.\n ///\n /// See [`std::fmt`][fmt] for more information on format syntax.\n ///\n-/// Return value is completely dependent on the 'write_fmt' method.\n+/// `write!` returns whatever the 'write_fmt' method returns.\n ///\n-/// Common return values are: [`Result`][enum_result], [`io::Result`][type_result]\n+/// Common return values include: [`fmt::Result`][fmt_result], [`io::Result`][io_result]\n ///\n /// [fmt]: ../std/fmt/index.html\n /// [fmt_write]: ../std/fmt/trait.Write.html\n /// [io_write]: ../std/io/trait.Write.html\n-/// [enum_result]: ../std/result/enum.Result.html\n-/// [type_result]: ../std/io/type.Result.html\n+/// [fmt_result]: ../std/fmt/type.Result.html\n+/// [io_result]: ../std/io/type.Result.html\n ///\n /// # Examples\n ///"}, {"sha": "bdb0dd8e7d1a9e0a371164c582b2aaa4af9276fe", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -241,8 +241,8 @@ pub trait Unsize<T: ?Sized> {\n /// compile-time error. Specifically, with structs you'll get [E0204] and with enums you'll get\n /// [E0205].\n ///\n-/// [E0204]: https://doc.rust-lang.org/error-index.html#E0204\n-/// [E0205]: https://doc.rust-lang.org/error-index.html#E0205\n+/// [E0204]: ../../error-index.html#E0204\n+/// [E0205]: ../../error-index.html#E0205\n ///\n /// ## When *should* my type be `Copy`?\n ///"}, {"sha": "06838ee89bd37ca8f3b3f04ad5e33044f1c5e47a", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 73, "deletions": 24, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -182,11 +182,11 @@ pub trait Drop {\n     /// After this function is over, the memory of `self` will be deallocated.\n     ///\n     /// This function cannot be called explicitly. This is compiler error\n-    /// [0040]. However, the [`std::mem::drop`] function in the prelude can be\n+    /// [E0040]. However, the [`std::mem::drop`] function in the prelude can be\n     /// used to call the argument's `Drop` implementation.\n     ///\n-    /// [0040]: https://doc.rust-lang.org/error-index.html#E0040\n-    /// [`std::mem::drop`]: https://doc.rust-lang.org/std/mem/fn.drop.html\n+    /// [E0040]: ../../error-index.html#E0040\n+    /// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n     ///\n     /// # Panics\n     ///\n@@ -1645,7 +1645,7 @@ rem_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n #[lang = \"bitand_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n pub trait BitAndAssign<Rhs=Self> {\n-    /// The method for the `&` operator\n+    /// The method for the `&=` operator\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitand_assign(&mut self, Rhs);\n }\n@@ -1879,10 +1879,18 @@ shr_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// The `Index` trait is used to specify the functionality of indexing operations\n /// like `container[index]` when used in an immutable context.\n ///\n+/// `container[index]` is actually syntactic sugar for `*container.index(index)`,\n+/// but only when used as an immutable value. If a mutable value is requested,\n+/// [`IndexMut`] is used instead. This allows nice things such as\n+/// `let value = v[index]` if `value` implements [`Copy`].\n+///\n+/// [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n+///\n /// # Examples\n ///\n-/// This example implements `Index` on a read-only `NucleotideCount` container,\n-/// enabling individual counts to be retrieved with index syntax.\n+/// The following example implements `Index` on a read-only `NucleotideCount`\n+/// container, enabling individual counts to be retrieved with index syntax.\n ///\n /// ```\n /// use std::ops::Index;\n@@ -1934,37 +1942,78 @@ pub trait Index<Idx: ?Sized> {\n }\n \n /// The `IndexMut` trait is used to specify the functionality of indexing\n-/// operations like `container[index]`, when used in a mutable context.\n+/// operations like `container[index]` when used in a mutable context.\n+///\n+/// `container[index]` is actually syntactic sugar for\n+/// `*container.index_mut(index)`, but only when used as a mutable value. If\n+/// an immutable value is requested, the [`Index`] trait is used instead. This\n+/// allows nice things such as `v[index] = value` if `value` implements [`Copy`].\n+///\n+/// [`Index`]: ../../std/ops/trait.Index.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `IndexMut` for a type `Foo`. When `&mut Foo[2]`\n-/// happens, it ends up calling `index_mut`, and therefore, `main` prints\n-/// `Mutable indexing with 2!`.\n+/// A very simple implementation of a `Balance` struct that has two sides, where\n+/// each can be indexed mutably and immutably.\n ///\n /// ```\n-/// use std::ops::{Index, IndexMut};\n+/// use std::ops::{Index,IndexMut};\n ///\n-/// #[derive(Copy, Clone)]\n-/// struct Foo;\n+/// #[derive(Debug)]\n+/// enum Side {\n+///     Left,\n+///     Right,\n+/// }\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// enum Weight {\n+///     Kilogram(f32),\n+///     Pound(f32),\n+/// }\n ///\n-/// impl Index<usize> for Foo {\n-///     type Output = Foo;\n+/// struct Balance {\n+///     pub left: Weight,\n+///     pub right:Weight,\n+/// }\n ///\n-///     fn index(&self, _index: usize) -> &Foo {\n-///         self\n+/// impl Index<Side> for Balance {\n+///     type Output = Weight;\n+///\n+///     fn index<'a>(&'a self, index: Side) -> &'a Weight {\n+///         println!(\"Accessing {:?}-side of balance immutably\", index);\n+///         match index {\n+///             Side::Left => &self.left,\n+///             Side::Right => &self.right,\n+///         }\n ///     }\n /// }\n ///\n-/// impl IndexMut<usize> for Foo {\n-///     fn index_mut(&mut self, index: usize) -> &mut Foo {\n-///         println!(\"Mutable indexing with {}!\", index);\n-///         self\n+/// impl IndexMut<Side> for Balance {\n+///     fn index_mut<'a>(&'a mut self, index: Side) -> &'a mut Weight {\n+///         println!(\"Accessing {:?}-side of balance mutably\", index);\n+///         match index {\n+///             Side::Left => &mut self.left,\n+///             Side::Right => &mut self.right,\n+///         }\n ///     }\n /// }\n ///\n /// fn main() {\n-///     &mut Foo[2];\n+///     let mut balance = Balance {\n+///         right: Weight::Kilogram(2.5),\n+///         left: Weight::Pound(1.5),\n+///     };\n+///\n+///     // In this case balance[Side::Right] is sugar for\n+///     // *balance.index(Side::Right), since we are only reading\n+///     // balance[Side::Right], not writing it.\n+///     assert_eq!(balance[Side::Right],Weight::Kilogram(2.5));\n+///\n+///     // However in this case balance[Side::Left] is sugar for\n+///     // *balance.index_mut(Side::Left), since we are writing\n+///     // balance[Side::Left].\n+///     balance[Side::Left] = Weight::Kilogram(3.0);\n /// }\n /// ```\n #[lang = \"index_mut\"]\n@@ -2435,13 +2484,13 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n /// impl<T> Deref for DerefMutExample<T> {\n ///     type Target = T;\n ///\n-///     fn deref<'a>(&'a self) -> &'a T {\n+///     fn deref(&self) -> &T {\n ///         &self.value\n ///     }\n /// }\n ///\n /// impl<T> DerefMut for DerefMutExample<T> {\n-///     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+///     fn deref_mut(&mut self) -> &mut T {\n ///         &mut self.value\n ///     }\n /// }"}, {"sha": "a74979911d34d1edfdb2fc6dc07c6657afb24102", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -914,12 +914,12 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// ```\n     /// use std::u16;\n     ///\n-    /// let v = vec!(1, 2);\n+    /// let v = vec![1, 2];\n     /// let res: Option<Vec<u16>> = v.iter().map(|&x: &u16|\n     ///     if x == u16::MAX { None }\n     ///     else { Some(x + 1) }\n     /// ).collect();\n-    /// assert!(res == Some(vec!(2, 3)));\n+    /// assert!(res == Some(vec![2, 3]));\n     /// ```\n     #[inline]\n     fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> {"}, {"sha": "9ba5ff7c3a4620e719b52e39b4cac10895f3a140", "filename": "src/libcore/result.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -792,6 +792,44 @@ impl<T: fmt::Debug, E> Result<T, E> {\n     }\n }\n \n+impl<T: Default, E> Result<T, E> {\n+    /// Returns the contained value or a default\n+    ///\n+    /// Consumes the `self` argument then, if `Ok`, returns the contained\n+    /// value, otherwise if `Err`, returns the default value for that\n+    /// type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Convert a string to an integer, turning poorly-formed strings\n+    /// into 0 (the default value for integers). [`parse`] converts\n+    /// a string to any other type that implements [`FromStr`], returning an\n+    /// `Err` on error.\n+    ///\n+    /// ```\n+    /// #![feature(result_unwrap_or_default)]\n+    ///\n+    /// let good_year_from_input = \"1909\";\n+    /// let bad_year_from_input = \"190blarg\";\n+    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n+    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n+    ///\n+    /// assert_eq!(1909, good_year);\n+    /// assert_eq!(0, bad_year);\n+    ///\n+    /// [`parse`]: ../../std/primitive.str.html#method.parse\n+    /// [`FromStr`]: ../../std/str/trait.FromStr.html\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"result_unwrap_or_default\", issue = \"37516\")]\n+    pub fn unwrap_or_default(self) -> T {\n+        match self {\n+            Ok(x) => x,\n+            Err(_) => Default::default(),\n+        }\n+    }\n+}\n+\n // This is a separate function to reduce the code size of the methods\n #[inline(never)]\n #[cold]\n@@ -977,12 +1015,12 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// ```\n     /// use std::u32;\n     ///\n-    /// let v = vec!(1, 2);\n+    /// let v = vec![1, 2];\n     /// let res: Result<Vec<u32>, &'static str> = v.iter().map(|&x: &u32|\n     ///     if x == u32::MAX { Err(\"Overflow!\") }\n     ///     else { Ok(x + 1) }\n     /// ).collect();\n-    /// assert!(res == Ok(vec!(2, 3)));\n+    /// assert!(res == Ok(vec![2, 3]));\n     /// ```\n     #[inline]\n     fn from_iter<I: IntoIterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {"}, {"sha": "196750254af30eacadeb20f8594a0208dc319f92", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -132,7 +132,7 @@ impl Utf8Error {\n     /// verified.\n     ///\n     /// It is the maximum index such that `from_utf8(input[..index])`\n-    /// would return `Some(_)`.\n+    /// would return `Ok(_)`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "c10f7e39fc39da0e13f768f993b98c0e128e03e8", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -166,6 +166,10 @@ pub enum Ordering {\n     /// sequentially consistent operations in the same order.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     SeqCst,\n+    // Prevent exhaustive matching to allow for future extension\n+    #[doc(hidden)]\n+    #[unstable(feature = \"future_atomic_orderings\", issue = \"0\")]\n+    __Nonexhaustive,\n }\n \n /// An `AtomicBool` initialized to `false`.\n@@ -1277,6 +1281,7 @@ fn strongest_failure_ordering(order: Ordering) -> Ordering {\n         SeqCst => SeqCst,\n         Acquire => Acquire,\n         AcqRel => Acquire,\n+        __Nonexhaustive => __Nonexhaustive,\n     }\n }\n \n@@ -1288,6 +1293,7 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order: Ordering) {\n         SeqCst => intrinsics::atomic_store(dst, val),\n         Acquire => panic!(\"there is no such thing as an acquire store\"),\n         AcqRel => panic!(\"there is no such thing as an acquire/release store\"),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n     }\n }\n \n@@ -1299,6 +1305,7 @@ unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n         SeqCst => intrinsics::atomic_load(dst),\n         Release => panic!(\"there is no such thing as a release load\"),\n         AcqRel => panic!(\"there is no such thing as an acquire/release load\"),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n     }\n }\n \n@@ -1310,6 +1317,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n         AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n         SeqCst => intrinsics::atomic_xchg(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n     }\n }\n \n@@ -1322,6 +1330,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n         AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n         SeqCst => intrinsics::atomic_xadd(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n     }\n }\n \n@@ -1334,6 +1343,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n         AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n         SeqCst => intrinsics::atomic_xsub(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n     }\n }\n \n@@ -1354,6 +1364,8 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n         (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n         (SeqCst, Relaxed) => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n         (SeqCst, Acquire) => intrinsics::atomic_cxchg_failacq(dst, old, new),\n+        (__Nonexhaustive, _) => panic!(\"invalid memory ordering\"),\n+        (_, __Nonexhaustive) => panic!(\"invalid memory ordering\"),\n         (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n         (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n         _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n@@ -1378,6 +1390,8 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n         (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n         (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n         (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n+        (__Nonexhaustive, _) => panic!(\"invalid memory ordering\"),\n+        (_, __Nonexhaustive) => panic!(\"invalid memory ordering\"),\n         (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n         (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n         _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n@@ -1393,6 +1407,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n         AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n         SeqCst => intrinsics::atomic_and(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n     }\n }\n \n@@ -1404,6 +1419,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n         AcqRel => intrinsics::atomic_or_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n         SeqCst => intrinsics::atomic_or(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n     }\n }\n \n@@ -1415,6 +1431,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n         AcqRel => intrinsics::atomic_xor_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n         SeqCst => intrinsics::atomic_xor(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n     }\n }\n \n@@ -1448,6 +1465,7 @@ pub fn fence(order: Ordering) {\n             AcqRel => intrinsics::atomic_fence_acqrel(),\n             SeqCst => intrinsics::atomic_fence(),\n             Relaxed => panic!(\"there is no such thing as a relaxed fence\"),\n+            __Nonexhaustive => panic!(\"invalid memory ordering\"),\n         }\n     }\n }"}, {"sha": "e3c65ad8b33c019378ad6e53cbcbdb3295f0ec71", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -41,6 +41,32 @@ fn test_ordering_order() {\n     assert_eq!(Greater.cmp(&Less), Greater);\n }\n \n+#[test]\n+fn test_ordering_then() {\n+    assert_eq!(Equal.then(Less), Less);\n+    assert_eq!(Equal.then(Equal), Equal);\n+    assert_eq!(Equal.then(Greater), Greater);\n+    assert_eq!(Less.then(Less), Less);\n+    assert_eq!(Less.then(Equal), Less);\n+    assert_eq!(Less.then(Greater), Less);\n+    assert_eq!(Greater.then(Less), Greater);\n+    assert_eq!(Greater.then(Equal), Greater);\n+    assert_eq!(Greater.then(Greater), Greater);\n+}\n+\n+#[test]\n+fn test_ordering_then_with() {\n+    assert_eq!(Equal.then_with(|| Less), Less);\n+    assert_eq!(Equal.then_with(|| Equal), Equal);\n+    assert_eq!(Equal.then_with(|| Greater), Greater);\n+    assert_eq!(Less.then_with(|| Less), Less);\n+    assert_eq!(Less.then_with(|| Equal), Less);\n+    assert_eq!(Less.then_with(|| Greater), Less);\n+    assert_eq!(Greater.then_with(|| Less), Greater);\n+    assert_eq!(Greater.then_with(|| Equal), Greater);\n+    assert_eq!(Greater.then_with(|| Greater), Greater);\n+}\n+\n #[test]\n fn test_user_defined_eq() {\n     // Our type."}, {"sha": "b8c01e570f5091d26fc24a6da770e019524c2465", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -34,6 +34,8 @@\n #![feature(unique)]\n #![feature(iter_max_by)]\n #![feature(iter_min_by)]\n+#![feature(ordering_chaining)]\n+#![feature(result_unwrap_or_default)]\n \n extern crate core;\n extern crate test;"}, {"sha": "bc2cd8bbfc6512158415e957a23f408378b881c2", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -183,3 +183,9 @@ pub fn test_iter_mut() {\n     }\n     assert_eq!(err, Err(\"error\"));\n }\n+\n+#[test]\n+pub fn test_unwrap_or_default() {\n+    assert_eq!(op1().unwrap_or_default(), 666);\n+    assert_eq!(op2().unwrap_or_default(), 0);\n+}"}, {"sha": "4d2f1b999a2aec763b96be41930766f315cc0024", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -1610,8 +1610,8 @@ Options:\n \n     #[test]\n     fn test_args_with_equals() {\n-        let args = vec!(\"--one\".to_string(), \"A=B\".to_string(),\n-                        \"--two=C=D\".to_string());\n+        let args = vec![\"--one\".to_string(), \"A=B\".to_string(),\n+                        \"--two=C=D\".to_string()];\n         let opts = vec![optopt(\"o\", \"one\", \"One\", \"INFO\"),\n                         optopt(\"t\", \"two\", \"Two\", \"INFO\")];\n         let matches = &match getopts(&args, &opts) {"}, {"sha": "03057af4a843bf07a8de8dfadf4c064cdd72bade", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -58,7 +58,7 @@\n //! struct Edges(Vec<Ed>);\n //!\n //! pub fn render_to<W: Write>(output: &mut W) {\n-//!     let edges = Edges(vec!((0,1), (0,2), (1,3), (2,3), (3,4), (4,4)));\n+//!     let edges = Edges(vec![(0,1), (0,2), (1,3), (2,3), (3,4), (4,4)]);\n //!     dot::render(&edges, output).unwrap()\n //! }\n //!\n@@ -164,8 +164,8 @@\n //! struct Graph { nodes: Vec<&'static str>, edges: Vec<(usize,usize)> }\n //!\n //! pub fn render_to<W: Write>(output: &mut W) {\n-//!     let nodes = vec!(\"{x,y}\",\"{x}\",\"{y}\",\"{}\");\n-//!     let edges = vec!((0,1), (0,2), (1,3), (2,3));\n+//!     let nodes = vec![\"{x,y}\",\"{x}\",\"{y}\",\"{}\"];\n+//!     let edges = vec![(0,1), (0,2), (1,3), (2,3)];\n //!     let graph = Graph { nodes: nodes, edges: edges };\n //!\n //!     dot::render(&graph, output).unwrap()\n@@ -226,8 +226,8 @@\n //! struct Graph { nodes: Vec<&'static str>, edges: Vec<(usize,usize)> }\n //!\n //! pub fn render_to<W: Write>(output: &mut W) {\n-//!     let nodes = vec!(\"{x,y}\",\"{x}\",\"{y}\",\"{}\");\n-//!     let edges = vec!((0,1), (0,2), (1,3), (2,3));\n+//!     let nodes = vec![\"{x,y}\",\"{x}\",\"{y}\",\"{}\"];\n+//!     let edges = vec![(0,1), (0,2), (1,3), (2,3)];\n //!     let graph = Graph { nodes: nodes, edges: edges };\n //!\n //!     dot::render(&graph, output).unwrap()"}, {"sha": "7dc0d19e6a615cd32e04e869ff89a978d1fa2df1", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -253,17 +253,17 @@ mod tests {\n \n         let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n-                   vec!(0xade0b876, 0x903df1a0, 0xe56a5d40, 0x28bd8653,\n+                   vec![0xade0b876, 0x903df1a0, 0xe56a5d40, 0x28bd8653,\n                         0xb819d2bd, 0x1aed8da0, 0xccef36a8, 0xc70d778b,\n                         0x7c5941da, 0x8d485751, 0x3fe02477, 0x374ad8b8,\n-                        0xf4b8436a, 0x1ca11815, 0x69b687c3, 0x8665eeb2));\n+                        0xf4b8436a, 0x1ca11815, 0x69b687c3, 0x8665eeb2]);\n \n         let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n-                   vec!(0xbee7079f, 0x7a385155, 0x7c97ba98, 0x0d082d73,\n+                   vec![0xbee7079f, 0x7a385155, 0x7c97ba98, 0x0d082d73,\n                         0xa0290fcb, 0x6965e348, 0x3e53c612, 0xed7aee32,\n                         0x7621b729, 0x434ee69c, 0xb03371d5, 0xd539d874,\n-                        0x281fed31, 0x45fb0a51, 0x1f0ae1ac, 0x6f4d794b));\n+                        0x281fed31, 0x45fb0a51, 0x1f0ae1ac, 0x6f4d794b]);\n \n \n         let seed: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n@@ -280,10 +280,10 @@ mod tests {\n         }\n \n         assert_eq!(v,\n-                   vec!(0xf225c81a, 0x6ab1be57, 0x04d42951, 0x70858036,\n+                   vec![0xf225c81a, 0x6ab1be57, 0x04d42951, 0x70858036,\n                         0x49884684, 0x64efec72, 0x4be2d186, 0x3615b384,\n                         0x11cfa18e, 0xd3c50049, 0x75c775f6, 0x434c6530,\n-                        0x2c5bad8f, 0x898881dc, 0x5f1c86d9, 0xc1f8e7f4));\n+                        0x2c5bad8f, 0x898881dc, 0x5f1c86d9, 0xc1f8e7f4]);\n     }\n \n     #[test]"}, {"sha": "41175c81df8918bbd5302e8f816296ab150a01f9", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -312,37 +312,37 @@ mod tests {\n             }}\n         }\n \n-        t!(vec!(Weighted { weight: 1, item: 10 }),\n+        t!(vec![Weighted { weight: 1, item: 10 }],\n            [10]);\n \n         // skip some\n-        t!(vec!(Weighted { weight: 0, item: 20 },\n+        t!(vec![Weighted { weight: 0, item: 20 },\n                 Weighted { weight: 2, item: 21 },\n                 Weighted { weight: 0, item: 22 },\n-                Weighted { weight: 1, item: 23 }),\n+                Weighted { weight: 1, item: 23 }],\n            [21, 21, 23]);\n \n         // different weights\n-        t!(vec!(Weighted { weight: 4, item: 30 },\n-                Weighted { weight: 3, item: 31 }),\n+        t!(vec![Weighted { weight: 4, item: 30 },\n+                Weighted { weight: 3, item: 31 }],\n            [30, 30, 30, 30, 31, 31, 31]);\n \n         // check that we're binary searching\n         // correctly with some vectors of odd\n         // length.\n-        t!(vec!(Weighted { weight: 1, item: 40 },\n+        t!(vec![Weighted { weight: 1, item: 40 },\n                 Weighted { weight: 1, item: 41 },\n                 Weighted { weight: 1, item: 42 },\n                 Weighted { weight: 1, item: 43 },\n-                Weighted { weight: 1, item: 44 }),\n+                Weighted { weight: 1, item: 44 }],\n            [40, 41, 42, 43, 44]);\n-        t!(vec!(Weighted { weight: 1, item: 50 },\n+        t!(vec![Weighted { weight: 1, item: 50 },\n                 Weighted { weight: 1, item: 51 },\n                 Weighted { weight: 1, item: 52 },\n                 Weighted { weight: 1, item: 53 },\n                 Weighted { weight: 1, item: 54 },\n                 Weighted { weight: 1, item: 55 },\n-                Weighted { weight: 1, item: 56 }),\n+                Weighted { weight: 1, item: 56 }],\n            [50, 51, 52, 53, 54, 55, 56]);\n     }\n "}, {"sha": "69d5015f18140153a339df182a1789f66ada22c8", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -662,8 +662,8 @@ mod tests {\n         // Regression test that isaac is actually using the above vector\n         let v = (0..10).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n-                   vec!(2558573138, 873787463, 263499565, 2103644246, 3595684709,\n-                        4203127393, 264982119, 2765226902, 2737944514, 3900253796));\n+                   vec![2558573138, 873787463, 263499565, 2103644246, 3595684709,\n+                        4203127393, 264982119, 2765226902, 2737944514, 3900253796]);\n \n         let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n@@ -674,8 +674,8 @@ mod tests {\n \n         let v = (0..10).map(|_| rb.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n-                   vec!(3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n-                        1576568959, 3507990155, 179069555, 141456972, 2478885421));\n+                   vec![3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n+                        1576568959, 3507990155, 179069555, 141456972, 2478885421]);\n     }\n     #[test]\n     #[rustfmt_skip]\n@@ -685,10 +685,10 @@ mod tests {\n         // Regression test that isaac is actually using the above vector\n         let v = (0..10).map(|_| ra.next_u64()).collect::<Vec<_>>();\n         assert_eq!(v,\n-                   vec!(547121783600835980, 14377643087320773276, 17351601304698403469,\n+                   vec![547121783600835980, 14377643087320773276, 17351601304698403469,\n                         1238879483818134882, 11952566807690396487, 13970131091560099343,\n                         4469761996653280935, 15552757044682284409, 6860251611068737823,\n-                        13722198873481261842));\n+                        13722198873481261842]);\n \n         let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n@@ -699,10 +699,10 @@ mod tests {\n \n         let v = (0..10).map(|_| rb.next_u64()).collect::<Vec<_>>();\n         assert_eq!(v,\n-                   vec!(18143823860592706164, 8491801882678285927, 2699425367717515619,\n+                   vec![18143823860592706164, 8491801882678285927, 2699425367717515619,\n                         17196852593171130876, 2606123525235546165, 15790932315217671084,\n                         596345674630742204, 9947027391921273664, 11788097613744130851,\n-                        10391409374914919106));\n+                        10391409374914919106]);\n \n     }\n "}, {"sha": "1b2976b7435d8e38ed66dc9cf9d9d2921aaa6324", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -536,7 +536,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn add_contained_edge(&mut self,\n                           source: CFGIndex,\n                           target: CFGIndex) {\n-        let data = CFGEdgeData {exiting_scopes: vec!() };\n+        let data = CFGEdgeData {exiting_scopes: vec![] };\n         self.graph.add_edge(source, target, data);\n     }\n \n@@ -545,7 +545,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         from_index: CFGIndex,\n                         to_loop: LoopScope,\n                         to_index: CFGIndex) {\n-        let mut data = CFGEdgeData {exiting_scopes: vec!() };\n+        let mut data = CFGEdgeData {exiting_scopes: vec![] };\n         let mut scope = self.tcx.region_maps.node_extent(from_expr.id);\n         let target_scope = self.tcx.region_maps.node_extent(to_loop.loop_id);\n         while scope != target_scope {\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                           _from_expr: &hir::Expr,\n                           from_index: CFGIndex) {\n         let mut data = CFGEdgeData {\n-            exiting_scopes: vec!(),\n+            exiting_scopes: vec![],\n         };\n         for &LoopScope { loop_id: id, .. } in self.loop_scopes.iter().rev() {\n             data.exiting_scopes.push(id);"}, {"sha": "5e3925b0b3c98f00b00b67144dfdd92da9e5401b", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -457,7 +457,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n             same_regions.push(SameRegions {\n                 scope_id: scope_id,\n-                regions: vec!(sub_fr.bound_region, sup_fr.bound_region)\n+                regions: vec![sub_fr.bound_region, sup_fr.bound_region]\n             })\n         }\n     }\n@@ -1359,7 +1359,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                                 region_names: &HashSet<ast::Name>)\n                                 -> P<hir::Ty> {\n         let mut new_ty = P(ty.clone());\n-        let mut ty_queue = vec!(ty);\n+        let mut ty_queue = vec![ty];\n         while !ty_queue.is_empty() {\n             let cur_ty = ty_queue.remove(0);\n             match cur_ty.node {"}, {"sha": "4c097965bb06abe05852e93f437bbdf7f0a5a1a1", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -199,9 +199,6 @@ pub enum TypeOrigin {\n     // Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse(Span),\n \n-    // Computing common supertype in a range expression\n-    RangeExpression(Span),\n-\n     // `where a == b`\n     EquatePredicate(Span),\n \n@@ -231,7 +228,6 @@ impl TypeOrigin {\n             },\n             &TypeOrigin::IfExpression(_) => \"if and else have incompatible types\",\n             &TypeOrigin::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n-            &TypeOrigin::RangeExpression(_) => \"start and end of range have incompatible types\",\n             &TypeOrigin::EquatePredicate(_) => \"equality predicate not satisfied\",\n             &TypeOrigin::MainFunctionType(_) => \"main function has wrong type\",\n             &TypeOrigin::StartFunctionType(_) => \"start function has wrong type\",\n@@ -251,7 +247,6 @@ impl TypeOrigin {\n             &TypeOrigin::MatchExpressionArm(..) => \"match arms have compatible types\",\n             &TypeOrigin::IfExpression(_) => \"if and else have compatible types\",\n             &TypeOrigin::IfExpressionWithNoElse(_) => \"if missing an else returns ()\",\n-            &TypeOrigin::RangeExpression(_) => \"start and end of range have compatible types\",\n             &TypeOrigin::EquatePredicate(_) => \"equality where clause is satisfied\",\n             &TypeOrigin::MainFunctionType(_) => \"`main` function has the correct type\",\n             &TypeOrigin::StartFunctionType(_) => \"`start` function has the correct type\",\n@@ -1755,7 +1750,6 @@ impl TypeOrigin {\n             TypeOrigin::MatchExpressionArm(match_span, ..) => match_span,\n             TypeOrigin::IfExpression(span) => span,\n             TypeOrigin::IfExpressionWithNoElse(span) => span,\n-            TypeOrigin::RangeExpression(span) => span,\n             TypeOrigin::EquatePredicate(span) => span,\n             TypeOrigin::MainFunctionType(span) => span,\n             TypeOrigin::StartFunctionType(span) => span,"}, {"sha": "20463f42d3b1df95435bcc3704f9a980870f1317", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -127,9 +127,9 @@ impl LintStore {\n \n     pub fn new() -> LintStore {\n         LintStore {\n-            lints: vec!(),\n-            early_passes: Some(vec!()),\n-            late_passes: Some(vec!()),\n+            lints: vec![],\n+            early_passes: Some(vec![]),\n+            late_passes: Some(vec![]),\n             by_name: FnvHashMap(),\n             levels: FnvHashMap(),\n             future_incompatible: FnvHashMap(),\n@@ -345,7 +345,7 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $ps:ident, $($args:expr),*) => ({\n // See also the hir version just below.\n pub fn gather_attrs(attrs: &[ast::Attribute])\n                     -> Vec<Result<(InternedString, Level, Span), Span>> {\n-    let mut out = vec!();\n+    let mut out = vec![];\n     for attr in attrs {\n         let r = gather_attr(attr);\n         out.extend(r.into_iter());\n@@ -355,7 +355,7 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n \n pub fn gather_attr(attr: &ast::Attribute)\n                    -> Vec<Result<(InternedString, Level, Span), Span>> {\n-    let mut out = vec!();\n+    let mut out = vec![];\n \n     let level = match Level::from_str(&attr.name()) {\n         None => return out,\n@@ -452,8 +452,7 @@ pub fn raw_struct_lint<'a>(sess: &'a Session,\n     }\n \n     if let Some(span) = def {\n-        let explanation = \"lint level defined here\";\n-        err.span_note(span, &explanation);\n+        sess.diag_span_note_once(&mut err, lint, span, \"lint level defined here\");\n     }\n \n     err"}, {"sha": "3175230ab6a5e43694a9731ee2bbbdf0443546f3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -59,7 +59,7 @@ impl LanguageItems {\n         fn foo(_: LangItem) -> Option<DefId> { None }\n \n         LanguageItems {\n-            items: vec!($(foo($variant)),*),\n+            items: vec![$(foo($variant)),*],\n             missing: Vec::new(),\n         }\n     }"}, {"sha": "87a5c6410a8410e0b3daf242c93dbf8f70559418", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -715,7 +715,7 @@ macro_rules! options {\n                     true\n                 }\n                 v => {\n-                    let mut passes = vec!();\n+                    let mut passes = vec![];\n                     if parse_list(&mut passes, v) {\n                         *slot = SomePasses(passes);\n                         true\n@@ -1293,7 +1293,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n         .unwrap_or_else(|e| early_error(error_format, &e[..]));\n \n-    let mut lint_opts = vec!();\n+    let mut lint_opts = vec![];\n     let mut describe_lints = false;\n \n     for &level in &[lint::Allow, lint::Warn, lint::Deny, lint::Forbid] {"}, {"sha": "1ce5b223fbefe8cbc03b59ffb2a99d9c16792b4c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -17,7 +17,7 @@ use middle::dependency_format;\n use session::search_paths::PathKind;\n use session::config::DebugInfoLevel;\n use ty::tls;\n-use util::nodemap::{NodeMap, FnvHashMap};\n+use util::nodemap::{NodeMap, FnvHashMap, FnvHashSet};\n use util::common::duration_to_secs_str;\n use mir::transform as mir_pass;\n \n@@ -75,6 +75,10 @@ pub struct Session {\n     pub working_dir: PathBuf,\n     pub lint_store: RefCell<lint::LintStore>,\n     pub lints: RefCell<NodeMap<Vec<(lint::LintId, Span, String)>>>,\n+    /// Set of (LintId, span, message) tuples tracking lint (sub)diagnostics\n+    /// that have been set once, but should not be set again, in order to avoid\n+    /// redundantly verbose output (Issue #24690).\n+    pub one_time_diagnostics: RefCell<FnvHashSet<(lint::LintId, Span, String)>>,\n     pub plugin_llvm_passes: RefCell<Vec<String>>,\n     pub mir_passes: RefCell<mir_pass::Passes>,\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n@@ -268,7 +272,7 @@ impl Session {\n             }\n             return;\n         }\n-        lints.insert(id, vec!((lint_id, sp, msg)));\n+        lints.insert(id, vec![(lint_id, sp, msg)]);\n     }\n     pub fn reserve_node_ids(&self, count: usize) -> ast::NodeId {\n         let id = self.next_node_id.get();\n@@ -288,6 +292,35 @@ impl Session {\n     pub fn diagnostic<'a>(&'a self) -> &'a errors::Handler {\n         &self.parse_sess.span_diagnostic\n     }\n+\n+    /// Analogous to calling `.span_note` on the given DiagnosticBuilder, but\n+    /// deduplicates on lint ID, span, and message for this `Session` if we're\n+    /// not outputting in JSON mode.\n+    //\n+    // FIXME: if the need arises for one-time diagnostics other than\n+    // `span_note`, we almost certainly want to generalize this\n+    // \"check/insert-into the one-time diagnostics map, then set message if\n+    // it's not already there\" code to accomodate all of them\n+    pub fn diag_span_note_once<'a, 'b>(&'a self,\n+                                       diag_builder: &'b mut DiagnosticBuilder<'a>,\n+                                       lint: &'static lint::Lint, span: Span, message: &str) {\n+        match self.opts.error_format {\n+            // when outputting JSON for tool consumption, the tool might want\n+            // the duplicates\n+            config::ErrorOutputType::Json => {\n+                diag_builder.span_note(span, &message);\n+            },\n+            _ => {\n+                let lint_id = lint::LintId::of(lint);\n+                let id_span_message = (lint_id, span, message.to_owned());\n+                let fresh = self.one_time_diagnostics.borrow_mut().insert(id_span_message);\n+                if fresh {\n+                    diag_builder.span_note(span, &message);\n+                }\n+            }\n+        }\n+    }\n+\n     pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {\n         self.parse_sess.codemap()\n     }\n@@ -561,6 +594,7 @@ pub fn build_session_(sopts: config::Options,\n         working_dir: env::current_dir().unwrap(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap()),\n+        one_time_diagnostics: RefCell::new(FnvHashSet()),\n         plugin_llvm_passes: RefCell::new(Vec::new()),\n         mir_passes: RefCell::new(mir_pass::Passes::new()),\n         plugin_attributes: RefCell::new(Vec::new()),"}, {"sha": "ce882c48377f74f3bb37bbb948235d01ec1bcf25", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -275,7 +275,7 @@ impl<'a, 'b, 'gcx, 'tcx> AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n         AssociatedTypeNormalizer {\n             selcx: selcx,\n             cause: cause,\n-            obligations: vec!(),\n+            obligations: vec![],\n             depth: depth,\n         }\n     }\n@@ -396,7 +396,7 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 cause, depth + 1, projection.to_predicate());\n             Normalized {\n                 value: ty_var,\n-                obligations: vec!(obligation)\n+                obligations: vec![obligation]\n             }\n         })\n }\n@@ -545,7 +545,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                    projected_ty);\n             let result = Normalized {\n                 value: projected_ty,\n-                obligations: vec!()\n+                obligations: vec![]\n             };\n             infcx.projection_cache.borrow_mut()\n                                   .complete(projection_ty, &result, true);\n@@ -604,7 +604,7 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n     let new_value = selcx.infcx().next_ty_var();\n     Normalized {\n         value: new_value,\n-        obligations: vec!(trait_obligation)\n+        obligations: vec![trait_obligation]\n     }\n }\n "}, {"sha": "24cafa7f7253a494736da22cd3e4a94ad4f01913", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -25,7 +25,7 @@ use hir::def_id::DefId;\n use infer::{InferCtxt, TypeOrigin};\n use middle::region;\n use ty::subst::{Subst, Substs};\n-use traits::{self, Reveal, ObligationCause, Normalized};\n+use traits::{self, Reveal, ObligationCause};\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n \n@@ -148,6 +148,8 @@ pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              impl1_def_id: DefId,\n                              impl2_def_id: DefId) -> bool {\n+    debug!(\"specializes({:?}, {:?})\", impl1_def_id, impl2_def_id);\n+\n     if let Some(r) = tcx.specializes_cache.borrow().check(impl1_def_id, impl2_def_id) {\n         return r;\n     }\n@@ -177,31 +179,24 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n-    let mut penv = tcx.construct_parameter_environment(DUMMY_SP,\n-                                                       impl1_def_id,\n-                                                       region::DUMMY_CODE_EXTENT);\n+    let penv = tcx.construct_parameter_environment(DUMMY_SP,\n+                                                   impl1_def_id,\n+                                                   region::DUMMY_CODE_EXTENT);\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id)\n                              .unwrap()\n                              .subst(tcx, &penv.free_substs);\n \n-    let result = tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|mut infcx| {\n-        // Normalize the trait reference, adding any obligations\n-        // that arise into the impl1 assumptions.\n-        let Normalized { value: impl1_trait_ref, obligations: normalization_obligations } = {\n-            let selcx = &mut SelectionContext::new(&infcx);\n-            traits::normalize(selcx, ObligationCause::dummy(), &impl1_trait_ref)\n-        };\n-        penv.caller_bounds.extend(normalization_obligations.into_iter().map(|o| {\n-            match tcx.lift_to_global(&o.predicate) {\n-                Some(predicate) => predicate,\n-                None => {\n-                    bug!(\"specializes: obligation `{:?}` has inference types/regions\", o);\n+    // Create a infcx, taking the predicates of impl1 as assumptions:\n+    let result = tcx.infer_ctxt(None, Some(penv), Reveal::ExactMatch).enter(|infcx| {\n+        // Normalize the trait reference. The WF rules ought to ensure\n+        // that this always succeeds.\n+        let impl1_trait_ref =\n+            match traits::fully_normalize(&infcx, ObligationCause::dummy(), &impl1_trait_ref) {\n+                Ok(impl1_trait_ref) => impl1_trait_ref,\n+                Err(err) => {\n+                    bug!(\"failed to fully normalize {:?}: {:?}\", impl1_trait_ref, err);\n                 }\n-            }\n-        }));\n-\n-        // Install the parameter environment, taking the predicates of impl1 as assumptions:\n-        infcx.parameter_environment = penv;\n+            };\n \n         // Attempt to prove that impl2 applies, given all of the above.\n         fulfill_implication(&infcx, impl1_trait_ref, impl2_def_id).is_ok()"}, {"sha": "bebdebf127a54542ec4bdf8a066ce516edc6edc1", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -22,7 +22,7 @@ pub struct TypeWalker<'tcx> {\n \n impl<'tcx> TypeWalker<'tcx> {\n     pub fn new(ty: Ty<'tcx>) -> TypeWalker<'tcx> {\n-        TypeWalker { stack: vec!(ty), last_subtree: 1, }\n+        TypeWalker { stack: vec![ty], last_subtree: 1, }\n     }\n \n     /// Skips the subtree of types corresponding to the last type"}, {"sha": "1135199d2254a248a10092ee3c344390dc0adab9", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -201,11 +201,11 @@ fn implied_bounds_from_components<'tcx>(sub_region: &'tcx ty::Region,\n         .flat_map(|component| {\n             match component {\n                 Component::Region(r) =>\n-                    vec!(ImpliedBound::RegionSubRegion(sub_region, r)),\n+                    vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n                 Component::Param(p) =>\n-                    vec!(ImpliedBound::RegionSubParam(sub_region, p)),\n+                    vec![ImpliedBound::RegionSubParam(sub_region, p)],\n                 Component::Projection(p) =>\n-                    vec!(ImpliedBound::RegionSubProjection(sub_region, p)),\n+                    vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n                 Component::EscapingProjection(_) =>\n                     // If the projection has escaping regions, don't\n                     // try to infer any implied bounds even for its\n@@ -215,9 +215,9 @@ fn implied_bounds_from_components<'tcx>(sub_region: &'tcx ty::Region,\n                     // idea is that the WAY that the caller proves\n                     // that may change in the future and we want to\n                     // give ourselves room to get smarter here.\n-                    vec!(),\n+                    vec![],\n                 Component::UnresolvedInferenceVariable(..) =>\n-                    vec!(),\n+                    vec![],\n             }\n         })\n         .collect()"}, {"sha": "954e3b1fc13ce8821e4621d223ff3abc9a66ed61", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -59,15 +59,25 @@ fn fn_sig(f: &mut fmt::Formatter,\n \n pub fn parameterized(f: &mut fmt::Formatter,\n                      substs: &subst::Substs,\n-                     did: DefId,\n+                     mut did: DefId,\n                      projections: &[ty::ProjectionPredicate])\n                      -> fmt::Result {\n+    let key = ty::tls::with(|tcx| tcx.def_key(did));\n+    let mut item_name = if let Some(name) = key.disambiguated_data.data.get_opt_name() {\n+        Some(name)\n+    } else {\n+        did.index = key.parent.unwrap_or_else(\n+            || bug!(\"finding type for {:?}, encountered def-id {:?} with no parent\",\n+                    did, did));\n+        parameterized(f, substs, did, projections)?;\n+        return write!(f, \"::{}\", key.disambiguated_data.data.as_interned_str());\n+    };\n+\n     let mut verbose = false;\n     let mut num_supplied_defaults = 0;\n     let mut has_self = false;\n     let mut num_regions = 0;\n     let mut num_types = 0;\n-    let mut item_name = None;\n     let mut is_value_path = false;\n     let fn_trait_kind = ty::tls::with(|tcx| {\n         // Unfortunately, some kinds of items (e.g., closures) don't have\n@@ -113,9 +123,10 @@ pub fn parameterized(f: &mut fmt::Formatter,\n                 write!(f, \"<{} as \", substs.type_at(0))?;\n             }\n \n-            item_name = Some(tcx.item_name(did));\n             path_def_id = def_id;\n         } else {\n+            item_name = None;\n+\n             if is_value_path {\n                 // Functions.\n                 assert_eq!(has_self, false);"}, {"sha": "7555181a15cf20d5a5d3856401b10df91a5bfe10", "filename": "src/librustc_back/target/dragonfly_base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -17,7 +17,7 @@ pub fn opts() -> TargetOptions {\n         executables: true,\n         linker_is_gnu: true,\n         has_rpath: true,\n-        pre_link_args: vec!(\n+        pre_link_args: vec![\n             // GNU-style linkers will use this to omit linking to libraries\n             // which don't actually fulfill any relocations, but only for\n             // libraries which follow this flag.  Thus, use it before\n@@ -26,7 +26,7 @@ pub fn opts() -> TargetOptions {\n \n             // Always enable NX protection when it is available\n             \"-Wl,-z,noexecstack\".to_string(),\n-        ),\n+        ],\n         position_independent_executables: true,\n         exe_allocation_crate: super::maybe_jemalloc(),\n         .. Default::default()"}, {"sha": "7555181a15cf20d5a5d3856401b10df91a5bfe10", "filename": "src/librustc_back/target/freebsd_base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -17,7 +17,7 @@ pub fn opts() -> TargetOptions {\n         executables: true,\n         linker_is_gnu: true,\n         has_rpath: true,\n-        pre_link_args: vec!(\n+        pre_link_args: vec![\n             // GNU-style linkers will use this to omit linking to libraries\n             // which don't actually fulfill any relocations, but only for\n             // libraries which follow this flag.  Thus, use it before\n@@ -26,7 +26,7 @@ pub fn opts() -> TargetOptions {\n \n             // Always enable NX protection when it is available\n             \"-Wl,-z,noexecstack\".to_string(),\n-        ),\n+        ],\n         position_independent_executables: true,\n         exe_allocation_crate: super::maybe_jemalloc(),\n         .. Default::default()"}, {"sha": "891e7dda14a2a4d931e3171966e97d4e7a53fb1e", "filename": "src/librustc_back/target/le32_unknown_nacl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -15,10 +15,10 @@ pub fn target() -> TargetResult {\n         linker: \"pnacl-clang\".to_string(),\n         ar: \"pnacl-ar\".to_string(),\n \n-        pre_link_args: vec!(\"--pnacl-exceptions=sjlj\".to_string(),\n+        pre_link_args: vec![\"--pnacl-exceptions=sjlj\".to_string(),\n                             \"--target=le32-unknown-nacl\".to_string(),\n-                            \"-Wl,--start-group\".to_string()),\n-        post_link_args: vec!(\"-Wl,--end-group\".to_string()),\n+                            \"-Wl,--start-group\".to_string()],\n+        post_link_args: vec![\"-Wl,--end-group\".to_string()],\n         dynamic_linking: false,\n         executables: true,\n         exe_suffix: \".pexe\".to_string(),"}, {"sha": "6e038a7ed56ee2b9fae85974e934a5fda7c4b6ac", "filename": "src/librustc_back/target/netbsd_base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -17,7 +17,7 @@ pub fn opts() -> TargetOptions {\n         executables: true,\n         linker_is_gnu: true,\n         has_rpath: true,\n-        pre_link_args: vec!(\n+        pre_link_args: vec![\n             // GNU-style linkers will use this to omit linking to libraries\n             // which don't actually fulfill any relocations, but only for\n             // libraries which follow this flag.  Thus, use it before\n@@ -26,7 +26,7 @@ pub fn opts() -> TargetOptions {\n \n             // Always enable NX protection when it is available\n             \"-Wl,-z,noexecstack\".to_string(),\n-        ),\n+        ],\n         position_independent_executables: true,\n         .. Default::default()\n     }"}, {"sha": "90e6631841bef54600549e303001e091584ffadb", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -17,7 +17,7 @@ pub fn opts() -> TargetOptions {\n         executables: true,\n         linker_is_gnu: true,\n         has_rpath: true,\n-        pre_link_args: vec!(\n+        pre_link_args: vec![\n             // GNU-style linkers will use this to omit linking to libraries\n             // which don't actually fulfill any relocations, but only for\n             // libraries which follow this flag.  Thus, use it before\n@@ -26,7 +26,7 @@ pub fn opts() -> TargetOptions {\n \n             // Always enable NX protection when it is available\n             \"-Wl,-z,noexecstack\".to_string(),\n-        ),\n+        ],\n         position_independent_executables: true,\n         exe_allocation_crate: \"alloc_system\".to_string(),\n         .. Default::default()"}, {"sha": "19ca0df51b9dc331d36077ce481641078115d08f", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -26,7 +26,7 @@ pub fn opts() -> TargetOptions {\n         no_default_libraries: true,\n         is_like_windows: true,\n         allows_weak_linkage: false,\n-        pre_link_args: vec!(\n+        pre_link_args: vec![\n             // And here, we see obscure linker flags #45. On windows, it has been\n             // found to be necessary to have this flag to compile liblibc.\n             //\n@@ -63,26 +63,26 @@ pub fn opts() -> TargetOptions {\n \n             // Do not use the standard system startup files or libraries when linking\n             \"-nostdlib\".to_string(),\n-        ),\n-        pre_link_objects_exe: vec!(\n+        ],\n+        pre_link_objects_exe: vec![\n             \"crt2.o\".to_string(),    // mingw C runtime initialization for executables\n             \"rsbegin.o\".to_string(), // Rust compiler runtime initialization, see rsbegin.rs\n-        ),\n-        pre_link_objects_dll: vec!(\n+        ],\n+        pre_link_objects_dll: vec![\n             \"dllcrt2.o\".to_string(), // mingw C runtime initialization for dlls\n             \"rsbegin.o\".to_string(),\n-        ),\n-        late_link_args: vec!(\n+        ],\n+        late_link_args: vec![\n             \"-lmingwex\".to_string(),\n             \"-lmingw32\".to_string(),\n             \"-lgcc\".to_string(), // alas, mingw* libraries above depend on libgcc\n             \"-lmsvcrt\".to_string(),\n             \"-luser32\".to_string(),\n             \"-lkernel32\".to_string(),\n-        ),\n-        post_link_objects: vec!(\n+        ],\n+        post_link_objects: vec![\n             \"rsend.o\".to_string()\n-        ),\n+        ],\n         custom_unwind_resume: true,\n \n         .. Default::default()"}, {"sha": "47f8d978704f4710145305f1c40d9b74b4ea8b8b", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -92,7 +92,7 @@ fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n         let move_from_id = error.move_from.id;\n         debug!(\"append_to_grouped_errors(move_from_id={})\", move_from_id);\n         let move_to = if error.move_to.is_some() {\n-            vec!(error.move_to.clone().unwrap())\n+            vec![error.move_to.clone().unwrap()]\n         } else {\n             Vec::new()\n         };"}, {"sha": "5e61c2ec7a292b588a727f33d05c560b74339dcd", "filename": "src/librustc_borrowck/borrowck/mir/abs_domain.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -21,13 +21,11 @@\n //! `a[x]` would still overlap them both. But that is not this\n //! representation does today.)\n \n-use rustc::mir::{Lvalue, LvalueElem};\n-use rustc::mir::{Operand, Projection, ProjectionElem};\n+use rustc::mir::LvalueElem;\n+use rustc::mir::{Operand, ProjectionElem};\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct AbstractOperand;\n-pub type AbstractProjection<'tcx> =\n-    Projection<'tcx, Lvalue<'tcx>, AbstractOperand>;\n pub type AbstractElem<'tcx> =\n     ProjectionElem<'tcx, AbstractOperand>;\n "}, {"sha": "2f74ea3e475b5a9b4902e88620b2a2d373e6f20c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -300,8 +300,6 @@ struct BorrowStats {\n     guaranteed_paths: usize\n }\n \n-pub type BckResult<'tcx, T> = Result<T, BckError<'tcx>>;\n-\n ///////////////////////////////////////////////////////////////////////////\n // Loans and loan paths\n \n@@ -1064,6 +1062,19 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         db.note(\"values in a scope are dropped in the opposite order \\\n                                 they are created\");\n                     }\n+                    (Some(s1), Some(s2)) if !is_temporary && !is_closure => {\n+                        db.span = MultiSpan::from_span(s2);\n+                        db.span_label(error_span, &format!(\"borrow occurs here\"));\n+                        let msg = match opt_loan_path(&err.cmt) {\n+                            None => \"borrowed value\".to_string(),\n+                            Some(lp) => {\n+                                format!(\"`{}`\", self.loan_path_to_string(&lp))\n+                            }\n+                        };\n+                        db.span_label(s2,\n+                                      &format!(\"{} dropped here while still borrowed\", msg));\n+                        db.span_label(s1, &format!(\"{} needs to live until here\", value_kind));\n+                    }\n                     _ => {\n                         match sub_span {\n                             Some(s) => {"}, {"sha": "ba036f1a8b157a00ee3d7ff415e3338e7260dae9", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     fn existing_base_paths(&self, lp: &Rc<LoanPath<'tcx>>)\n                            -> Vec<MovePathIndex> {\n-        let mut result = vec!();\n+        let mut result = vec![];\n         self.add_existing_base_paths(lp, &mut result);\n         result\n     }"}, {"sha": "db72057636a8558a62dc13f0054cef38400f2cff", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -454,7 +454,7 @@ loop variable, consider using a `match` or `if let` inside the loop body. For\n instance:\n \n ```compile_fail,E0297\n-let xs : Vec<Option<i32>> = vec!(Some(1), None);\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n \n // This fails because `None` is not covered.\n for Some(x) in xs {\n@@ -465,7 +465,7 @@ for Some(x) in xs {\n Match inside the loop instead:\n \n ```\n-let xs : Vec<Option<i32>> = vec!(Some(1), None);\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n \n for item in xs {\n     match item {\n@@ -478,7 +478,7 @@ for item in xs {\n Or use `if let`:\n \n ```\n-let xs : Vec<Option<i32>> = vec!(Some(1), None);\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n \n for item in xs {\n     if let Some(x) = item {"}, {"sha": "a2bfa784e8aed0725ca6e50034fd096d3b2703a7", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -377,8 +377,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n     {\n         let mut stack = self.scratch.take().unwrap();\n \n-        for node in 0..self.nodes.len() {\n-            self.find_cycles_from_node(&mut stack, processor, node);\n+        for index in 0..self.nodes.len() {\n+            // For rustc-benchmarks/inflate-0.1.0 this state test is extremely\n+            // hot and the state is almost always `Pending` or `Waiting`. It's\n+            // a win to handle the no-op cases immediately to avoid the cost of\n+            // the function call.\n+            let state = self.nodes[index].state.get();\n+            match state {\n+                NodeState::Waiting | NodeState::Pending | NodeState::Done | NodeState::Error => {},\n+                _ => self.find_cycles_from_node(&mut stack, processor, index),\n+            }\n         }\n \n         self.scratch = Some(stack);\n@@ -476,7 +484,18 @@ impl<O: ForestObligation> ObligationForest<O> {\n         trace\n     }\n \n-    /// Marks all nodes that depend on a pending node as NodeState;:Waiting.\n+    #[inline]\n+    fn mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n+        if let Some(parent) = node.parent {\n+            self.mark_as_waiting_from(&self.nodes[parent.get()]);\n+        }\n+\n+        for dependent in &node.dependents {\n+            self.mark_as_waiting_from(&self.nodes[dependent.get()]);\n+        }\n+    }\n+\n+    /// Marks all nodes that depend on a pending node as NodeState::Waiting.\n     fn mark_as_waiting(&self) {\n         for node in &self.nodes {\n             if node.state.get() == NodeState::Waiting {\n@@ -486,27 +505,19 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         for node in &self.nodes {\n             if node.state.get() == NodeState::Pending {\n-                self.mark_as_waiting_from(node)\n+                self.mark_neighbors_as_waiting_from(node);\n             }\n         }\n     }\n \n     fn mark_as_waiting_from(&self, node: &Node<O>) {\n         match node.state.get() {\n-            NodeState::Pending | NodeState::Done => {},\n             NodeState::Waiting | NodeState::Error | NodeState::OnDfsStack => return,\n-            NodeState::Success => {\n-                node.state.set(NodeState::Waiting);\n-            }\n-        }\n-\n-        if let Some(parent) = node.parent {\n-            self.mark_as_waiting_from(&self.nodes[parent.get()]);\n+            NodeState::Success => node.state.set(NodeState::Waiting),\n+            NodeState::Pending | NodeState::Done => {},\n         }\n \n-        for dependent in &node.dependents {\n-            self.mark_as_waiting_from(&self.nodes[dependent.get()]);\n-        }\n+        self.mark_neighbors_as_waiting_from(node);\n     }\n \n     /// Compresses the vector, removing all popped nodes. This adjusts\n@@ -532,28 +543,28 @@ impl<O: ForestObligation> ObligationForest<O> {\n         //     self.nodes[i..] are unchanged\n         for i in 0..self.nodes.len() {\n             match self.nodes[i].state.get() {\n+                NodeState::Pending | NodeState::Waiting => {\n+                    if dead_nodes > 0 {\n+                        self.nodes.swap(i, i - dead_nodes);\n+                        node_rewrites[i] -= dead_nodes;\n+                    }\n+                }\n                 NodeState::Done => {\n                     self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n                     // FIXME(HashMap): why can't I get my key back?\n                     self.done_cache.insert(self.nodes[i].obligation.as_predicate().clone());\n+                    node_rewrites[i] = nodes_len;\n+                    dead_nodes += 1;\n                 }\n                 NodeState::Error => {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n                     self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n+                    node_rewrites[i] = nodes_len;\n+                    dead_nodes += 1;\n                 }\n-                _ => {}\n-            }\n-\n-            if self.nodes[i].is_popped() {\n-                node_rewrites[i] = nodes_len;\n-                dead_nodes += 1;\n-            } else {\n-                if dead_nodes > 0 {\n-                    self.nodes.swap(i, i - dead_nodes);\n-                    node_rewrites[i] -= dead_nodes;\n-                }\n+                NodeState::OnDfsStack | NodeState::Success => unreachable!()\n             }\n         }\n \n@@ -633,12 +644,4 @@ impl<O> Node<O> {\n             dependents: vec![],\n         }\n     }\n-\n-    fn is_popped(&self) -> bool {\n-        match self.state.get() {\n-            NodeState::Pending | NodeState::Waiting => false,\n-            NodeState::Error | NodeState::Done => true,\n-            NodeState::OnDfsStack | NodeState::Success => unreachable!()\n-        }\n-    }\n }"}, {"sha": "289a7348cc8dd6b525855fff5046d9e9f285d13e", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 145, "deletions": 133, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -101,8 +101,8 @@ impl PpMode {\n \n     pub fn needs_analysis(&self) -> bool {\n         match *self {\n-             PpmMir | PpmMirCFG | PpmFlowGraph(_) => true,\n-             _ => false,\n+            PpmMir | PpmMirCFG | PpmFlowGraph(_) => true,\n+            _ => false,\n         }\n     }\n }\n@@ -233,14 +233,11 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  |tcx, _, _, _| {\n-                    let annotation = TypedAnnotation {\n-                        tcx: tcx,\n-                    };\n+                    let annotation = TypedAnnotation { tcx: tcx };\n                     let _ignore = tcx.dep_graph.in_ignore();\n-                    f(&annotation,\n-                      payload,\n-                      ast_map.forest.krate())\n-                }), sess)\n+                    f(&annotation, payload, ast_map.forest.krate())\n+                }),\n+                             sess)\n             }\n             _ => panic!(\"Should use call_with_pp_support\"),\n         }\n@@ -281,9 +278,11 @@ trait HirPrinterSupport<'ast>: pprust_hir::PpAnn {\n     /// Computes an user-readable representation of a path, if possible.\n     fn node_path(&self, id: ast::NodeId) -> Option<String> {\n         self.ast_map().and_then(|map| map.def_path_from_id(id)).map(|path| {\n-            path.data.into_iter().map(|elem| {\n-                elem.data.to_string()\n-            }).collect::<Vec<_>>().join(\"::\")\n+            path.data\n+                .into_iter()\n+                .map(|elem| elem.data.to_string())\n+                .collect::<Vec<_>>()\n+                .join(\"::\")\n         })\n     }\n }\n@@ -352,7 +351,8 @@ impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n     }\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeIdent(_) | pprust::NodeName(_) => Ok(()),\n+            pprust::NodeIdent(_) |\n+            pprust::NodeName(_) => Ok(()),\n \n             pprust::NodeItem(item) => {\n                 pp::space(&mut s.s)?;\n@@ -617,15 +617,14 @@ impl ReplaceBodyWithLoop {\n impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_item_kind(&mut self, i: ast::ItemKind) -> ast::ItemKind {\n         match i {\n-            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => {\n+            ast::ItemKind::Static(..) |\n+            ast::ItemKind::Const(..) => {\n                 self.within_static_or_const = true;\n                 let ret = fold::noop_fold_item_kind(i, self);\n                 self.within_static_or_const = false;\n                 return ret;\n             }\n-            _ => {\n-                fold::noop_fold_item_kind(i, self)\n-            }\n+            _ => fold::noop_fold_item_kind(i, self),\n         }\n     }\n \n@@ -656,11 +655,15 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n         fn expr_to_block(rules: ast::BlockCheckMode, e: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n-                stmts: e.map(|e| ast::Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: e.span,\n-                    node: ast::StmtKind::Expr(e),\n-                }).into_iter().collect(),\n+                stmts: e.map(|e| {\n+                        ast::Stmt {\n+                            id: ast::DUMMY_NODE_ID,\n+                            span: e.span,\n+                            node: ast::StmtKind::Expr(e),\n+                        }\n+                    })\n+                    .into_iter()\n+                    .collect(),\n                 rules: rules,\n                 id: ast::DUMMY_NODE_ID,\n                 span: syntax_pos::DUMMY_SP,\n@@ -721,9 +724,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n         }\n         blocks::FnLikeCode(fn_like) => {\n             let (bccx, analysis_data) =\n-                borrowck::build_borrowck_dataflow_data_for_fn(tcx,\n-                                                              fn_like.to_fn_parts(),\n-                                                              &cfg);\n+                borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_like.to_fn_parts(), &cfg);\n \n             let lcfg = borrowck_dot::DataflowLabeller {\n                 inner: lcfg,\n@@ -756,13 +757,13 @@ pub fn fold_crate(krate: ast::Crate, ppm: PpMode) -> ast::Crate {\n fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, String) {\n     let src_name = driver::source_name(input);\n     let src = sess.codemap()\n-                  .get_filemap(&src_name)\n-                  .unwrap()\n-                  .src\n-                  .as_ref()\n-                  .unwrap()\n-                  .as_bytes()\n-                  .to_vec();\n+        .get_filemap(&src_name)\n+        .unwrap()\n+        .src\n+        .as_ref()\n+        .unwrap()\n+        .as_bytes()\n+        .to_vec();\n     (src, src_name)\n }\n \n@@ -795,17 +796,18 @@ pub fn print_after_parsing(sess: &Session,\n         // Silently ignores an identified node.\n         let out: &mut Write = &mut out;\n         s.call_with_pp_support(sess, None, box out, |annotation, out| {\n-            debug!(\"pretty printing source code {:?}\", s);\n-            let sess = annotation.sess();\n-            pprust::print_crate(sess.codemap(),\n-                                sess.diagnostic(),\n-                                krate,\n-                                src_name.to_string(),\n-                                &mut rdr,\n-                                out,\n-                                annotation.pp_ann(),\n-                                false)\n-        }).unwrap()\n+                debug!(\"pretty printing source code {:?}\", s);\n+                let sess = annotation.sess();\n+                pprust::print_crate(sess.codemap(),\n+                                    sess.diagnostic(),\n+                                    krate,\n+                                    src_name.to_string(),\n+                                    &mut rdr,\n+                                    out,\n+                                    annotation.pp_ann(),\n+                                    false)\n+            })\n+            .unwrap()\n     } else {\n         unreachable!();\n     };\n@@ -828,8 +830,15 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let _ignore = dep_graph.in_ignore();\n \n     if ppm.needs_analysis() {\n-        print_with_analysis(sess, ast_map, analysis, resolutions,\n-                            crate_name, arenas, ppm, opt_uii, ofile);\n+        print_with_analysis(sess,\n+                            ast_map,\n+                            analysis,\n+                            resolutions,\n+                            crate_name,\n+                            arenas,\n+                            ppm,\n+                            opt_uii,\n+                            ofile);\n         return;\n     }\n \n@@ -839,82 +848,82 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n     let mut out = Vec::new();\n \n     match (ppm, opt_uii) {\n-        (PpmSource(s), _) => {\n-            // Silently ignores an identified node.\n-            let out: &mut Write = &mut out;\n-            s.call_with_pp_support(sess, Some(ast_map), box out, |annotation, out| {\n-                debug!(\"pretty printing source code {:?}\", s);\n-                let sess = annotation.sess();\n-                pprust::print_crate(sess.codemap(),\n-                                    sess.diagnostic(),\n-                                    krate,\n-                                    src_name.to_string(),\n-                                    &mut rdr,\n-                                    out,\n-                                    annotation.pp_ann(),\n-                                    true)\n-            })\n-        }\n+            (PpmSource(s), _) => {\n+                // Silently ignores an identified node.\n+                let out: &mut Write = &mut out;\n+                s.call_with_pp_support(sess, Some(ast_map), box out, |annotation, out| {\n+                    debug!(\"pretty printing source code {:?}\", s);\n+                    let sess = annotation.sess();\n+                    pprust::print_crate(sess.codemap(),\n+                                        sess.diagnostic(),\n+                                        krate,\n+                                        src_name.to_string(),\n+                                        &mut rdr,\n+                                        out,\n+                                        annotation.pp_ann(),\n+                                        true)\n+                })\n+            }\n \n-        (PpmHir(s), None) => {\n-            let out: &mut Write = &mut out;\n-            s.call_with_pp_support_hir(sess,\n-                                       ast_map,\n-                                       analysis,\n-                                       resolutions,\n-                                       arenas,\n-                                       crate_name,\n-                                       box out,\n-                                       |annotation, out, krate| {\n-                                           debug!(\"pretty printing source code {:?}\", s);\n-                                           let sess = annotation.sess();\n-                                           pprust_hir::print_crate(sess.codemap(),\n-                                                                   sess.diagnostic(),\n-                                                                   krate,\n-                                                                   src_name.to_string(),\n-                                                                   &mut rdr,\n-                                                                   out,\n-                                                                   annotation.pp_ann(),\n-                                                                   true)\n-                                       })\n-        }\n+            (PpmHir(s), None) => {\n+                let out: &mut Write = &mut out;\n+                s.call_with_pp_support_hir(sess,\n+                                           ast_map,\n+                                           analysis,\n+                                           resolutions,\n+                                           arenas,\n+                                           crate_name,\n+                                           box out,\n+                                           |annotation, out, krate| {\n+                    debug!(\"pretty printing source code {:?}\", s);\n+                    let sess = annotation.sess();\n+                    pprust_hir::print_crate(sess.codemap(),\n+                                            sess.diagnostic(),\n+                                            krate,\n+                                            src_name.to_string(),\n+                                            &mut rdr,\n+                                            out,\n+                                            annotation.pp_ann(),\n+                                            true)\n+                })\n+            }\n \n-        (PpmHir(s), Some(uii)) => {\n-            let out: &mut Write = &mut out;\n-            s.call_with_pp_support_hir(sess,\n-                                       ast_map,\n-                                       analysis,\n-                                       resolutions,\n-                                       arenas,\n-                                       crate_name,\n-                                       (out,uii),\n-                                       |annotation, (out,uii), _| {\n-                debug!(\"pretty printing source code {:?}\", s);\n-                let sess = annotation.sess();\n-                let ast_map = annotation.ast_map().expect(\"--unpretty missing HIR map\");\n-                let mut pp_state =\n-                    pprust_hir::State::new_from_input(sess.codemap(),\n-                                                      sess.diagnostic(),\n-                                                      src_name.to_string(),\n-                                                      &mut rdr,\n-                                                      box out,\n-                                                      annotation.pp_ann(),\n-                                                      true,\n-                                                      Some(ast_map.krate()));\n-                for node_id in uii.all_matching_node_ids(ast_map) {\n-                    let node = ast_map.get(node_id);\n-                    pp_state.print_node(&node)?;\n-                    pp::space(&mut pp_state.s)?;\n-                    let path = annotation.node_path(node_id)\n-                                         .expect(\"--unpretty missing node paths\");\n-                    pp_state.synth_comment(path)?;\n-                    pp::hardbreak(&mut pp_state.s)?;\n-                }\n-                pp::eof(&mut pp_state.s)\n-            })\n-       }\n-       _ => unreachable!(),\n-    }.unwrap();\n+            (PpmHir(s), Some(uii)) => {\n+                let out: &mut Write = &mut out;\n+                s.call_with_pp_support_hir(sess,\n+                                           ast_map,\n+                                           analysis,\n+                                           resolutions,\n+                                           arenas,\n+                                           crate_name,\n+                                           (out, uii),\n+                                           |annotation, (out, uii), _| {\n+                    debug!(\"pretty printing source code {:?}\", s);\n+                    let sess = annotation.sess();\n+                    let ast_map = annotation.ast_map().expect(\"--unpretty missing HIR map\");\n+                    let mut pp_state = pprust_hir::State::new_from_input(sess.codemap(),\n+                                                                         sess.diagnostic(),\n+                                                                         src_name.to_string(),\n+                                                                         &mut rdr,\n+                                                                         box out,\n+                                                                         annotation.pp_ann(),\n+                                                                         true,\n+                                                                         Some(ast_map.krate()));\n+                    for node_id in uii.all_matching_node_ids(ast_map) {\n+                        let node = ast_map.get(node_id);\n+                        pp_state.print_node(&node)?;\n+                        pp::space(&mut pp_state.s)?;\n+                        let path = annotation.node_path(node_id)\n+                            .expect(\"--unpretty missing node paths\");\n+                        pp_state.synth_comment(path)?;\n+                        pp::hardbreak(&mut pp_state.s)?;\n+                    }\n+                    pp::eof(&mut pp_state.s)\n+                })\n+            }\n+            _ => unreachable!(),\n+        }\n+        .unwrap();\n \n     write_output(out, ofile);\n }\n@@ -955,27 +964,28 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     let def_id = tcx.map.local_def_id(nodeid);\n                     match ppm {\n                         PpmMir => write_mir_pretty(tcx, iter::once(def_id), &mut out),\n-                        PpmMirCFG => {\n-                            write_mir_graphviz(tcx, iter::once(def_id), &mut out)\n-                        }\n+                        PpmMirCFG => write_mir_graphviz(tcx, iter::once(def_id), &mut out),\n                         _ => unreachable!(),\n                     }?;\n                 } else {\n                     match ppm {\n-                        PpmMir => write_mir_pretty(tcx,\n-                                                   tcx.mir_map.borrow().keys().into_iter(),\n-                                                   &mut out),\n-                        PpmMirCFG => write_mir_graphviz(tcx,\n-                                                        tcx.mir_map.borrow().keys().into_iter(),\n-                                                        &mut out),\n+                        PpmMir => {\n+                            write_mir_pretty(tcx, tcx.mir_map.borrow().keys().into_iter(), &mut out)\n+                        }\n+                        PpmMirCFG => {\n+                            write_mir_graphviz(tcx,\n+                                               tcx.mir_map.borrow().keys().into_iter(),\n+                                               &mut out)\n+                        }\n                         _ => unreachable!(),\n                     }?;\n                 }\n                 Ok(())\n             }\n             PpmFlowGraph(mode) => {\n-                let nodeid = nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or \\\n-                                            unique path suffix (b::c::d)\");\n+                let nodeid =\n+                    nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or unique path \\\n+                                   suffix (b::c::d)\");\n                 let node = tcx.map.find(nodeid).unwrap_or_else(|| {\n                     tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n                 });\n@@ -990,8 +1000,8 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                         print_flowgraph(variants, tcx, code, mode, out)\n                     }\n                     None => {\n-                        let message = format!(\"--pretty=flowgraph needs block, fn, or method; got \\\n-                                               {:?}\",\n+                        let message = format!(\"--pretty=flowgraph needs block, fn, or method; \\\n+                                               got {:?}\",\n                                               node);\n \n                         // Point to what was found, if there's an accessible span.\n@@ -1004,7 +1014,9 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n             }\n             _ => unreachable!(),\n         }\n-    }), sess).unwrap();\n+    }),\n+                 sess)\n+        .unwrap();\n \n     write_output(out, ofile);\n }"}, {"sha": "ba51947a3330177b6385d8fb11d5e8e32395fbf0", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -20,26 +20,11 @@ use libc::c_char;\n // detection code will walk past the end of the feature array,\n // leading to crashes.\n \n-const ARM_WHITELIST: &'static [&'static str] = &[\n-    \"neon\\0\",\n-    \"vfp2\\0\",\n-    \"vfp3\\0\",\n-    \"vfp4\\0\",\n-];\n+const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"vfp2\\0\", \"vfp3\\0\", \"vfp4\\0\"];\n \n-const X86_WHITELIST: &'static [&'static str] = &[\n-    \"avx\\0\",\n-    \"avx2\\0\",\n-    \"bmi\\0\",\n-    \"bmi2\\0\",\n-    \"sse\\0\",\n-    \"sse2\\0\",\n-    \"sse3\\0\",\n-    \"sse4.1\\0\",\n-    \"sse4.2\\0\",\n-    \"ssse3\\0\",\n-    \"tbm\\0\",\n-];\n+const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n+                                                 \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n+                                                 \"ssse3\\0\", \"tbm\\0\"];\n \n /// Add `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.).\n@@ -59,7 +44,7 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n     for feat in whitelist {\n         assert_eq!(feat.chars().last(), Some('\\0'));\n         if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n-            cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(&feat[..feat.len()-1])))\n+            cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(&feat[..feat.len() - 1])))\n         }\n     }\n }"}, {"sha": "8dc21550148c0d9a54c8955c0c68e8187e564029", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -40,7 +40,7 @@ use syntax_pos::DUMMY_SP;\n \n use rustc::hir;\n \n-struct Env<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n@@ -86,8 +86,7 @@ impl Emitter for ExpectErrorEmitter {\n \n fn errors(msgs: &[&str]) -> (Box<Emitter + Send>, usize) {\n     let v = msgs.iter().map(|m| m.to_string()).collect();\n-    (box ExpectErrorEmitter { messages: v } as Box<Emitter + Send>,\n-     msgs.len())\n+    (box ExpectErrorEmitter { messages: v } as Box<Emitter + Send>, msgs.len())\n }\n \n fn test_env<F>(source_string: &str,\n@@ -103,18 +102,28 @@ fn test_env<F>(source_string: &str,\n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n     let cstore = Rc::new(CStore::new(&dep_graph));\n-    let sess = session::build_session_(options, &dep_graph, None, diagnostic_handler,\n-                                       Rc::new(CodeMap::new()), cstore.clone());\n+    let sess = session::build_session_(options,\n+                                       &dep_graph,\n+                                       None,\n+                                       diagnostic_handler,\n+                                       Rc::new(CodeMap::new()),\n+                                       cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n         name: driver::anon_src(),\n         input: source_string.to_string(),\n     };\n     let krate = driver::phase_1_parse_input(&sess, &input).unwrap();\n     let driver::ExpansionResult { defs, resolutions, mut hir_forest, .. } = {\n-        driver::phase_2_configure_and_expand(\n-            &sess, &cstore, krate, None, \"test\", None, MakeGlobMap::No, |_| Ok(()),\n-        ).expect(\"phase 2 aborted\")\n+        driver::phase_2_configure_and_expand(&sess,\n+                                             &cstore,\n+                                             krate,\n+                                             None,\n+                                             \"test\",\n+                                             None,\n+                                             MakeGlobMap::No,\n+                                             |_| Ok(()))\n+            .expect(\"phase 2 aborted\")\n     };\n     let _ignore = dep_graph.in_ignore();\n \n@@ -167,14 +176,22 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n         let node = ast::NodeId::from_u32;\n         let dscope = self.infcx\n-                         .tcx\n-                         .region_maps\n-                         .intern_code_extent(CodeExtentData::DestructionScope(node(1)),\n-                                             region::ROOT_CODE_EXTENT);\n+            .tcx\n+            .region_maps\n+            .intern_code_extent(CodeExtentData::DestructionScope(node(1)),\n+                                region::ROOT_CODE_EXTENT);\n         self.create_region_hierarchy(&RH {\n-            id: node(1),\n-            sub: &[RH { id: node(10), sub: &[] }, RH { id: node(11), sub: &[] }],\n-        }, dscope);\n+                                         id: node(1),\n+                                         sub: &[RH {\n+                                                    id: node(10),\n+                                                    sub: &[],\n+                                                },\n+                                                RH {\n+                                                    id: node(11),\n+                                                    sub: &[],\n+                                                }],\n+                                     },\n+                                     dscope);\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -213,22 +230,16 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n                 hir::ItemStatic(..) |\n                 hir::ItemFn(..) |\n                 hir::ItemForeignMod(..) |\n-                hir::ItemTy(..) => {\n-                    None\n-                }\n+                hir::ItemTy(..) => None,\n \n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n                 hir::ItemTrait(..) |\n                 hir::ItemImpl(..) |\n-                hir::ItemDefaultImpl(..) => {\n-                    None\n-                }\n+                hir::ItemDefaultImpl(..) => None,\n \n-                hir::ItemMod(ref m) => {\n-                    search_mod(this, m, idx, names)\n-                }\n+                hir::ItemMod(ref m) => search_mod(this, m, idx, names),\n             };\n         }\n     }\n@@ -281,18 +292,17 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_param(index, token::intern(&name[..]))\n     }\n \n-    pub fn re_early_bound(&self,\n-                          index: u32,\n-                          name: &'static str)\n-                          -> &'tcx ty::Region {\n+    pub fn re_early_bound(&self, index: u32, name: &'static str) -> &'tcx ty::Region {\n         let name = token::intern(name);\n         self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: index,\n             name: name,\n         }))\n     }\n \n-    pub fn re_late_bound_with_debruijn(&self, id: u32, debruijn: ty::DebruijnIndex)\n+    pub fn re_late_bound_with_debruijn(&self,\n+                                       id: u32,\n+                                       debruijn: ty::DebruijnIndex)\n                                        -> &'tcx ty::Region {\n         self.infcx.tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n     }\n@@ -394,19 +404,15 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n                 self.assert_eq(t, t_lub);\n             }\n-            Err(ref e) => {\n-                panic!(\"unexpected error in LUB: {}\", e)\n-            }\n+            Err(ref e) => panic!(\"unexpected error in LUB: {}\", e),\n         }\n     }\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n         debug!(\"check_glb(t1={}, t2={}, t_glb={})\", t1, t2, t_glb);\n         match self.glb(t1, t2) {\n-            Err(e) => {\n-                panic!(\"unexpected error computing LUB: {:?}\", e)\n-            }\n+            Err(e) => panic!(\"unexpected error computing LUB: {:?}\", e),\n             Ok(InferOk { obligations, value: t }) => {\n                 // FIXME(#32730) once obligations are being propagated, assert the right thing.\n                 assert!(obligations.is_empty());"}, {"sha": "80c41f855ba5c95508e60369a9020879bc650e77", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 103, "deletions": 35, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -21,6 +21,7 @@ use self::SawTyComponent::*;\n use self::SawTraitOrImplItemComponent::*;\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId};\n+use syntax::attr;\n use syntax::parse::token;\n use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use rustc::hir;\n@@ -53,6 +54,7 @@ pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n     def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n     hash_spans: bool,\n     codemap: &'a mut CachingCodemapView<'tcx>,\n+    overflow_checks_enabled: bool,\n }\n \n impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n@@ -62,12 +64,16 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n                codemap: &'a mut CachingCodemapView<'tcx>,\n                hash_spans: bool)\n                -> Self {\n+        let check_overflow = tcx.sess.opts.debugging_opts.force_overflow_checks\n+            .unwrap_or(tcx.sess.opts.debug_assertions);\n+\n         StrictVersionHashVisitor {\n             st: st,\n             tcx: tcx,\n             def_path_hashes: def_path_hashes,\n             hash_spans: hash_spans,\n             codemap: codemap,\n+            overflow_checks_enabled: check_overflow,\n         }\n     }\n \n@@ -83,7 +89,6 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     // Also note that we are hashing byte offsets for the column, not unicode\n     // codepoint offsets. For the purpose of the hash that's sufficient.\n     fn hash_span(&mut self, span: Span) {\n-        debug_assert!(self.hash_spans);\n         debug!(\"hash_span: st={:?}\", self.st);\n \n         // If this is not an empty or invalid span, we want to hash the last\n@@ -241,37 +246,80 @@ enum SawExprComponent<'a> {\n     SawExprRepeat,\n }\n \n-fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n+// The boolean returned indicates whether the span of this expression is always\n+// significant, regardless of debuginfo.\n+fn saw_expr<'a>(node: &'a Expr_,\n+                overflow_checks_enabled: bool)\n+                -> (SawExprComponent<'a>, bool) {\n+    let binop_can_panic_at_runtime = |binop| {\n+        match binop {\n+            BiAdd |\n+            BiSub |\n+            BiMul => overflow_checks_enabled,\n+\n+            BiDiv |\n+            BiRem => true,\n+\n+            BiAnd |\n+            BiOr |\n+            BiBitXor |\n+            BiBitAnd |\n+            BiBitOr |\n+            BiShl |\n+            BiShr |\n+            BiEq |\n+            BiLt |\n+            BiLe |\n+            BiNe |\n+            BiGe |\n+            BiGt => false\n+        }\n+    };\n+\n+    let unop_can_panic_at_runtime = |unop| {\n+        match unop {\n+            UnDeref |\n+            UnNot => false,\n+            UnNeg => overflow_checks_enabled,\n+        }\n+    };\n+\n     match *node {\n-        ExprBox(..)              => SawExprBox,\n-        ExprArray(..)            => SawExprArray,\n-        ExprCall(..)             => SawExprCall,\n-        ExprMethodCall(..)       => SawExprMethodCall,\n-        ExprTup(..)              => SawExprTup,\n-        ExprBinary(op, ..)       => SawExprBinary(op.node),\n-        ExprUnary(op, _)         => SawExprUnary(op),\n-        ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n-        ExprCast(..)             => SawExprCast,\n-        ExprType(..)             => SawExprType,\n-        ExprIf(..)               => SawExprIf,\n-        ExprWhile(..)            => SawExprWhile,\n-        ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.node.as_str())),\n-        ExprMatch(..)            => SawExprMatch,\n-        ExprClosure(cc, _, _, _) => SawExprClosure(cc),\n-        ExprBlock(..)            => SawExprBlock,\n-        ExprAssign(..)           => SawExprAssign,\n-        ExprAssignOp(op, ..)     => SawExprAssignOp(op.node),\n-        ExprField(_, name)       => SawExprField(name.node.as_str()),\n-        ExprTupField(_, id)      => SawExprTupField(id.node),\n-        ExprIndex(..)            => SawExprIndex,\n-        ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n-        ExprAddrOf(m, _)         => SawExprAddrOf(m),\n-        ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.as_str())),\n-        ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.as_str())),\n-        ExprRet(..)              => SawExprRet,\n-        ExprInlineAsm(ref a,..)  => SawExprInlineAsm(a),\n-        ExprStruct(..)           => SawExprStruct,\n-        ExprRepeat(..)           => SawExprRepeat,\n+        ExprBox(..)              => (SawExprBox, false),\n+        ExprArray(..)            => (SawExprArray, false),\n+        ExprCall(..)             => (SawExprCall, false),\n+        ExprMethodCall(..)       => (SawExprMethodCall, false),\n+        ExprTup(..)              => (SawExprTup, false),\n+        ExprBinary(op, ..)       => {\n+            (SawExprBinary(op.node), binop_can_panic_at_runtime(op.node))\n+        }\n+        ExprUnary(op, _)         => {\n+            (SawExprUnary(op), unop_can_panic_at_runtime(op))\n+        }\n+        ExprLit(ref lit)         => (SawExprLit(lit.node.clone()), false),\n+        ExprCast(..)             => (SawExprCast, false),\n+        ExprType(..)             => (SawExprType, false),\n+        ExprIf(..)               => (SawExprIf, false),\n+        ExprWhile(..)            => (SawExprWhile, false),\n+        ExprLoop(_, id)          => (SawExprLoop(id.map(|id| id.node.as_str())), false),\n+        ExprMatch(..)            => (SawExprMatch, false),\n+        ExprClosure(cc, _, _, _) => (SawExprClosure(cc), false),\n+        ExprBlock(..)            => (SawExprBlock, false),\n+        ExprAssign(..)           => (SawExprAssign, false),\n+        ExprAssignOp(op, ..)     => {\n+            (SawExprAssignOp(op.node), binop_can_panic_at_runtime(op.node))\n+        }\n+        ExprField(_, name)       => (SawExprField(name.node.as_str()), false),\n+        ExprTupField(_, id)      => (SawExprTupField(id.node), false),\n+        ExprIndex(..)            => (SawExprIndex, true),\n+        ExprPath(ref qself, _)   => (SawExprPath(qself.as_ref().map(|q| q.position)), false),\n+        ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n+        ExprBreak(id)            => (SawExprBreak(id.map(|id| id.node.as_str())), false),\n+        ExprAgain(id)            => (SawExprAgain(id.map(|id| id.node.as_str())), false),\n+        ExprRet(..)              => (SawExprRet, false),\n+        ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(a), false),\n+        ExprStruct(..)           => (SawExprStruct, false),\n+        ExprRepeat(..)           => (SawExprRepeat, false),\n     }\n }\n \n@@ -421,10 +469,13 @@ macro_rules! hash_attrs {\n \n macro_rules! hash_span {\n     ($visitor:expr, $span:expr) => ({\n-        if $visitor.hash_spans {\n+        hash_span!($visitor, $span, false)\n+    });\n+    ($visitor:expr, $span:expr, $force:expr) => ({\n+        if $force || $visitor.hash_spans {\n             $visitor.hash_span($span);\n         }\n-    })\n+    });\n }\n \n impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n@@ -474,10 +525,12 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_expr(&mut self, ex: &'tcx Expr) {\n         debug!(\"visit_expr: st={:?}\", self.st);\n-        SawExpr(saw_expr(&ex.node)).hash(self.st);\n+        let (saw_expr, force_span) = saw_expr(&ex.node,\n+                                              self.overflow_checks_enabled);\n+        SawExpr(saw_expr).hash(self.st);\n         // No need to explicitly hash the discriminant here, since we are\n         // implicitly hashing the discriminant of SawExprComponent.\n-        hash_span!(self, ex.span);\n+        hash_span!(self, ex.span, force_span);\n         hash_attrs!(self, &ex.attrs);\n         visit::walk_expr(self, ex)\n     }\n@@ -519,6 +572,9 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n         debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n+\n+        self.maybe_enable_overflow_checks(&i.attrs);\n+\n         SawItem(saw_item(&i.node)).hash(self.st);\n         hash_span!(self, i.span);\n         hash_attrs!(self, &i.attrs);\n@@ -545,6 +601,9 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_trait_item(&mut self, ti: &'tcx TraitItem) {\n         debug!(\"visit_trait_item: st={:?}\", self.st);\n+\n+        self.maybe_enable_overflow_checks(&ti.attrs);\n+\n         SawTraitItem(saw_trait_item(&ti.node)).hash(self.st);\n         hash_span!(self, ti.span);\n         hash_attrs!(self, &ti.attrs);\n@@ -553,6 +612,9 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n \n     fn visit_impl_item(&mut self, ii: &'tcx ImplItem) {\n         debug!(\"visit_impl_item: st={:?}\", self.st);\n+\n+        self.maybe_enable_overflow_checks(&ii.attrs);\n+\n         SawImplItem(saw_impl_item(&ii.node)).hash(self.st);\n         hash_span!(self, ii.span);\n         hash_attrs!(self, &ii.attrs);\n@@ -842,4 +904,10 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         indices.sort_by_key(|index| get_key(&items[*index]));\n         indices\n     }\n+\n+    fn maybe_enable_overflow_checks(&mut self, item_attrs: &[ast::Attribute]) {\n+        if attr::contains_name(item_attrs, \"rustc_inherit_overflow_checks\") {\n+            self.overflow_checks_enabled = true;\n+        }\n+    }\n }"}, {"sha": "7cef246b6cb2c5b6dc18c3abda5f0109a4694a70", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -32,8 +32,6 @@ use super::file_format;\n \n pub type DirtyNodes = FnvHashSet<DepNode<DefPathIndex>>;\n \n-type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n-\n /// If we are in incremental mode, and a previous dep-graph exists,\n /// then load up those nodes/edges that are still valid into the\n /// dep-graph for this session. (This is assumed to be running very"}, {"sha": "a28109c1471914d9a7ade462ebb979f8a9315f01", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -1189,7 +1189,7 @@ impl LateLintPass for MutableTransmutes {\n     fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n         use syntax::abi::Abi::RustIntrinsic;\n \n-        let msg = \"mutating transmuted &mut T from &T may cause undefined behavior,\\\n+        let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr) {\n             Some((&ty::TyRef(_, from_mt), &ty::TyRef(_, to_mt))) => {"}, {"sha": "e72ac8419941c12234cae3fe01a60775b1c2a6b4", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -340,10 +340,10 @@ impl<'a> CrateLoader<'a> {\n                     target: &self.sess.target.target,\n                     triple: &self.sess.opts.target_triple,\n                     root: root,\n-                    rejected_via_hash: vec!(),\n-                    rejected_via_triple: vec!(),\n-                    rejected_via_kind: vec!(),\n-                    rejected_via_version: vec!(),\n+                    rejected_via_hash: vec![],\n+                    rejected_via_triple: vec![],\n+                    rejected_via_kind: vec![],\n+                    rejected_via_version: vec![],\n                     should_match_name: true,\n                 };\n                 match self.load(&mut locate_ctxt) {\n@@ -481,10 +481,10 @@ impl<'a> CrateLoader<'a> {\n             target: &self.sess.host,\n             triple: config::host_triple(),\n             root: &None,\n-            rejected_via_hash: vec!(),\n-            rejected_via_triple: vec!(),\n-            rejected_via_kind: vec!(),\n-            rejected_via_version: vec!(),\n+            rejected_via_hash: vec![],\n+            rejected_via_triple: vec![],\n+            rejected_via_kind: vec![],\n+            rejected_via_version: vec![],\n             should_match_name: true,\n         };\n         let library = self.load(&mut locate_ctxt).or_else(|| {"}, {"sha": "88e248e2efa3878eb90eefbd90cc2f68ae7ac227", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -73,12 +73,12 @@ impl<'a> Registry<'a> {\n             sess: sess,\n             args_hidden: None,\n             krate_span: krate_span,\n-            syntax_exts: vec!(),\n-            early_lint_passes: vec!(),\n-            late_lint_passes: vec!(),\n+            syntax_exts: vec![],\n+            early_lint_passes: vec![],\n+            late_lint_passes: vec![],\n             lint_groups: HashMap::new(),\n-            llvm_passes: vec!(),\n-            attributes: vec!(),\n+            llvm_passes: vec![],\n+            attributes: vec![],\n             mir_passes: Vec::new(),\n         }\n     }"}, {"sha": "77b3e76fc541fd2da706a3c13f745bf41648da47", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -859,9 +859,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n     // expression/block context can't possibly contain exported things.\n     // (Making them no-ops stops us from traversing the whole AST without\n     // having to be super careful about our `walk_...` calls above.)\n-    // FIXME(#29524): Unfortunately this ^^^ is not true, blocks can contain\n-    // exported items (e.g. impls) and actual code in rustc itself breaks\n-    // if we don't traverse blocks in `EmbargoVisitor`\n     fn visit_block(&mut self, _: &hir::Block) {}\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n }"}, {"sha": "5eb269030a004fa2b1ce8b2d43ee9809cf027321", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -1461,6 +1461,47 @@ match r {\n ```\n \"##,\n \n+E0532: r##\"\n+Pattern arm did not match expected kind.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0532\n+enum State {\n+    Succeeded,\n+    Failed(String),\n+}\n+\n+fn print_on_failure(state: &State) {\n+    match *state {\n+        // error: expected unit struct/variant or constant, found tuple\n+        //        variant `State::Failed`\n+        State::Failed => println!(\"Failed\"),\n+        _ => ()\n+    }\n+}\n+```\n+\n+To fix this error, ensure the match arm kind is the same as the expression\n+matched.\n+\n+Fixed example:\n+\n+```\n+enum State {\n+    Succeeded,\n+    Failed(String),\n+}\n+\n+fn print_on_failure(state: &State) {\n+    match *state {\n+        State::Failed(ref msg) => println!(\"Failed with {}\", msg),\n+        _ => ()\n+    }\n+}\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {\n@@ -1480,6 +1521,5 @@ register_diagnostics! {\n //  E0421, merged into 531\n //  E0422, merged into 531/532\n     E0531, // unresolved pattern path kind `name`\n-    E0532, // expected pattern path kind, found another pattern path kind\n //  E0427, merged into 530\n }"}, {"sha": "ed46c1d96ad1705261918b3602cff02b859a4f6c", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -12,7 +12,6 @@ use {Module, Resolver};\n use build_reduced_graph::BuildReducedGraphVisitor;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n use rustc::hir::map::{self, DefCollector};\n-use rustc::util::nodemap::FnvHashMap;\n use std::cell::Cell;\n use std::rc::Rc;\n use syntax::ast;\n@@ -80,8 +79,6 @@ pub struct LegacyBinding<'a> {\n     span: Span,\n }\n \n-pub type LegacyImports = FnvHashMap<ast::Name, (Rc<SyntaxExtension>, Span)>;\n-\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()"}, {"sha": "8a628289b7f9421681df00473f559c9360938e32", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -153,7 +153,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         // What could go wrong...?\n         if spans.len() < path.segments.len() {\n             if generated_code(path.span) {\n-                return vec!();\n+                return vec![];\n             }\n             error!(\"Mis-calculated spans for path '{}'. Found {} spans, expected {}. Found spans:\",\n                    path_to_string(path),\n@@ -167,12 +167,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                        loc.line);\n             }\n             error!(\"    master span: {:?}: `{}`\", path.span, self.span.snippet(path.span));\n-            return vec!();\n+            return vec![];\n         }\n \n-        let mut result: Vec<(Span, String)> = vec!();\n+        let mut result: Vec<(Span, String)> = vec![];\n \n-        let mut segs = vec!();\n+        let mut segs = vec![];\n         for (i, (seg, span)) in path.segments.iter().zip(&spans).enumerate() {\n             segs.push(seg.clone());\n             let sub_path = ast::Path {"}, {"sha": "031b9a6a5aa516049aa70b379719457ef222f507", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -225,7 +225,7 @@ impl<'a> SpanUtils<'a> {\n     // Nesting = 0: all idents outside of brackets: [Foo]\n     // Nesting = 1: idents within one level of brackets: [Bar, Bar]\n     pub fn spans_with_brackets(&self, span: Span, nesting: isize, limit: isize) -> Vec<Span> {\n-        let mut result: Vec<Span> = vec!();\n+        let mut result: Vec<Span> = vec![];\n \n         let mut toks = self.retokenise_span(span);\n         // We keep track of how many brackets we're nested in\n@@ -236,7 +236,7 @@ impl<'a> SpanUtils<'a> {\n             if ts.tok == token::Eof {\n                 if bracket_count != 0 {\n                     if generated_code(span) {\n-                        return vec!();\n+                        return vec![];\n                     }\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n                     span_bug!(span,"}, {"sha": "4d3361c1873f032b33fd490f76a2e31409098fd1", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -48,7 +48,6 @@ use std;\n use llvm::{ValueRef, True, IntEQ, IntNE};\n use rustc::ty::layout;\n use rustc::ty::{self, Ty, AdtKind};\n-use syntax::attr;\n use build::*;\n use common::*;\n use debuginfo::DebugLoc;\n@@ -66,8 +65,6 @@ pub enum BranchKind {\n     Single\n }\n \n-type Hint = attr::ReprAttr;\n-\n #[derive(Copy, Clone)]\n pub struct MaybeSizedValue {\n     pub value: ValueRef,\n@@ -119,9 +116,6 @@ fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n     }\n }\n \n-/// This represents the (GEP) indices to follow to get to the discriminant field\n-pub type DiscrField = Vec<usize>;\n-\n /// LLVM-level types are a little complicated.\n ///\n /// C-like enums need to be actual ints, not wrapped in a struct,"}, {"sha": "8c704cc32993c4e170c5c4c0664cfdb93ee88363", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -61,7 +61,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Default per-arch clobbers\n     // Basically what clang does\n     let arch_clobbers = match &bcx.sess().target.target.arch[..] {\n-        \"x86\" | \"x86_64\" => vec!(\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"),\n+        \"x86\" | \"x86_64\" => vec![\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"],\n         _                => Vec::new()\n     };\n "}, {"sha": "8758cdcf9d0ab63928ef1100381060561773bb1f", "filename": "src/librustc_trans/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_trans%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_trans%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Frpath.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -68,7 +68,7 @@ fn get_rpaths(config: &mut RPathConfig, libs: &[PathBuf]) -> Vec<String> {\n     let rel_rpaths = get_rpaths_relative_to_output(config, libs);\n \n     // And a final backup rpath to the global library location.\n-    let fallback_rpaths = vec!(get_install_prefix_rpath(config));\n+    let fallback_rpaths = vec![get_install_prefix_rpath(config)];\n \n     fn log_rpaths(desc: &str, rpaths: &[String]) {\n         debug!(\"{} rpaths:\", desc);"}, {"sha": "9012914deeb091f5b51c7bceae2bd987b6e64b39", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -665,7 +665,7 @@ pub fn run_passes(sess: &Session,\n     // Figure out what we actually need to build.\n \n     let mut modules_config = ModuleConfig::new(tm, sess.opts.cg.passes.clone());\n-    let mut metadata_config = ModuleConfig::new(tm, vec!());\n+    let mut metadata_config = ModuleConfig::new(tm, vec![]);\n \n     modules_config.opt_level = Some(get_llvm_opt_level(sess.opts.optimize));\n     modules_config.opt_size = Some(get_llvm_opt_size(sess.opts.optimize));"}, {"sha": "b9f24eba9dc1e31b120d759d0102563c2b063be1", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -305,7 +305,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         assert!(orig_scopes_len > 0);\n \n         // Remove any scopes that do not have cleanups on panic:\n-        let mut popped_scopes = vec!();\n+        let mut popped_scopes = vec![];\n         while !self.top_scope(|s| s.needs_invoke()) {\n             debug!(\"top scope does not need invoke\");\n             popped_scopes.push(self.pop_scope());\n@@ -402,7 +402,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n \n         let orig_scopes_len = self.scopes_len();\n         let mut prev_llbb;\n-        let mut popped_scopes = vec!();\n+        let mut popped_scopes = vec![];\n         let mut skip = 0;\n \n         // First we pop off all the cleanup stacks that are\n@@ -585,8 +585,8 @@ impl<'tcx> CleanupScope<'tcx> {\n     fn new(debug_loc: DebugLoc) -> CleanupScope<'tcx> {\n         CleanupScope {\n             debug_loc: debug_loc,\n-            cleanups: vec!(),\n-            cached_early_exits: vec!(),\n+            cleanups: vec![],\n+            cached_early_exits: vec![],\n             cached_landing_pad: None,\n         }\n     }"}, {"sha": "1aa502fc443ec7bcb8d176ffdfada8b46c26be28", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -171,8 +171,6 @@ struct ConvertedBinding<'tcx> {\n     span: Span,\n }\n \n-type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n-\n /// Dummy type used for the `Self` of a `TraitRef` created for converting\n /// a trait object, and which gets removed in `ExistentialTraitRef`.\n /// This type must not appear anywhere in other converted types."}, {"sha": "7d2547ec17f3a5b91f8e70c42aacf401a378a425", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -86,18 +86,18 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n \n         //We only care about the operation here\n         let (n_tps, inputs, output) = match split[1] {\n-            \"cxchg\" | \"cxchgweak\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)),\n+            \"cxchg\" | \"cxchgweak\" => (1, vec![tcx.mk_mut_ptr(param(ccx, 0)),\n                                               param(ccx, 0),\n-                                              param(ccx, 0)),\n+                                              param(ccx, 0)],\n                                       tcx.intern_tup(&[param(ccx, 0), tcx.types.bool])),\n-            \"load\" => (1, vec!(tcx.mk_imm_ptr(param(ccx, 0))),\n+            \"load\" => (1, vec![tcx.mk_imm_ptr(param(ccx, 0))],\n                        param(ccx, 0)),\n-            \"store\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n+            \"store\" => (1, vec![tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)],\n                         tcx.mk_nil()),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n             \"min\"  | \"umax\" | \"umin\" => {\n-                (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n+                (1, vec![tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)],\n                  param(ccx, 0))\n             }\n             \"fence\" | \"singlethreadfence\" => {\n@@ -129,14 +129,14 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n             \"rustc_peek\" => (1, vec![param(ccx, 0)], param(ccx, 0)),\n             \"init\" => (1, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n-            \"forget\" => (1, vec!( param(ccx, 0) ), tcx.mk_nil()),\n-            \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n+            \"forget\" => (1, vec![ param(ccx, 0) ], tcx.mk_nil()),\n+            \"transmute\" => (2, vec![ param(ccx, 0) ], param(ccx, 1)),\n             \"move_val_init\" => {\n                 (1,\n-                 vec!(\n+                 vec![\n                     tcx.mk_mut_ptr(param(ccx, 0)),\n                     param(ccx, 0)\n-                  ),\n+                  ],\n                tcx.mk_nil())\n             }\n             \"drop_in_place\" => {\n@@ -148,21 +148,21 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n             \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n             \"offset\" | \"arith_offset\" => {\n               (1,\n-               vec!(\n+               vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(ccx, 0),\n                       mutbl: hir::MutImmutable\n                   }),\n                   ccx.tcx.types.isize\n-               ),\n+               ],\n                tcx.mk_ptr(ty::TypeAndMut {\n                    ty: param(ccx, 0),\n                    mutbl: hir::MutImmutable\n                }))\n             }\n             \"copy\" | \"copy_nonoverlapping\" => {\n               (1,\n-               vec!(\n+               vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(ccx, 0),\n                       mutbl: hir::MutImmutable\n@@ -172,12 +172,12 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                       mutbl: hir::MutMutable\n                   }),\n                   tcx.types.usize,\n-               ),\n+               ],\n                tcx.mk_nil())\n             }\n             \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => {\n               (1,\n-               vec!(\n+               vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(ccx, 0),\n                       mutbl: hir::MutMutable\n@@ -187,93 +187,93 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                       mutbl: hir::MutImmutable\n                   }),\n                   tcx.types.usize,\n-               ),\n+               ],\n                tcx.mk_nil())\n             }\n             \"write_bytes\" | \"volatile_set_memory\" => {\n               (1,\n-               vec!(\n+               vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(ccx, 0),\n                       mutbl: hir::MutMutable\n                   }),\n                   tcx.types.u8,\n                   tcx.types.usize,\n-               ),\n+               ],\n                tcx.mk_nil())\n             }\n-            \"sqrtf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"sqrtf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"sqrtf32\" => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"sqrtf64\" => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n             \"powif32\" => {\n                (0,\n-                vec!( tcx.types.f32, tcx.types.i32 ),\n+                vec![ tcx.types.f32, tcx.types.i32 ],\n                 tcx.types.f32)\n             }\n             \"powif64\" => {\n                (0,\n-                vec!( tcx.types.f64, tcx.types.i32 ),\n+                vec![ tcx.types.f64, tcx.types.i32 ],\n                 tcx.types.f64)\n             }\n-            \"sinf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"sinf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"cosf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"cosf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"sinf32\" => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"sinf64\" => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n+            \"cosf32\" => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"cosf64\" => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n             \"powf32\" => {\n                (0,\n-                vec!( tcx.types.f32, tcx.types.f32 ),\n+                vec![ tcx.types.f32, tcx.types.f32 ],\n                 tcx.types.f32)\n             }\n             \"powf64\" => {\n                (0,\n-                vec!( tcx.types.f64, tcx.types.f64 ),\n+                vec![ tcx.types.f64, tcx.types.f64 ],\n                 tcx.types.f64)\n             }\n-            \"expf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"expf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"exp2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"exp2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"logf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"logf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"log10f32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"log10f64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"log2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"log2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"expf32\"   => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"expf64\"   => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n+            \"exp2f32\"  => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"exp2f64\"  => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n+            \"logf32\"   => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"logf64\"   => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n+            \"log10f32\" => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"log10f64\" => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n+            \"log2f32\"  => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"log2f64\"  => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n             \"fmaf32\" => {\n                 (0,\n-                 vec!( tcx.types.f32, tcx.types.f32, tcx.types.f32 ),\n+                 vec![ tcx.types.f32, tcx.types.f32, tcx.types.f32 ],\n                  tcx.types.f32)\n             }\n             \"fmaf64\" => {\n                 (0,\n-                 vec!( tcx.types.f64, tcx.types.f64, tcx.types.f64 ),\n+                 vec![ tcx.types.f64, tcx.types.f64, tcx.types.f64 ],\n                  tcx.types.f64)\n             }\n-            \"fabsf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"fabsf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"copysignf32\"  => (0, vec!( tcx.types.f32, tcx.types.f32 ), tcx.types.f32),\n-            \"copysignf64\"  => (0, vec!( tcx.types.f64, tcx.types.f64 ), tcx.types.f64),\n-            \"floorf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"floorf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"ceilf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"ceilf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"truncf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"truncf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"rintf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"rintf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"nearbyintf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"nearbyintf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"roundf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"roundf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"fabsf32\"      => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"fabsf64\"      => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n+            \"copysignf32\"  => (0, vec![ tcx.types.f32, tcx.types.f32 ], tcx.types.f32),\n+            \"copysignf64\"  => (0, vec![ tcx.types.f64, tcx.types.f64 ], tcx.types.f64),\n+            \"floorf32\"     => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"floorf64\"     => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n+            \"ceilf32\"      => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"ceilf64\"      => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n+            \"truncf32\"     => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"truncf64\"     => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n+            \"rintf32\"      => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"rintf64\"      => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n+            \"nearbyintf32\" => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"nearbyintf64\" => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n+            \"roundf32\"     => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n+            \"roundf64\"     => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n \n             \"volatile_load\" =>\n-                (1, vec!( tcx.mk_imm_ptr(param(ccx, 0)) ), param(ccx, 0)),\n+                (1, vec![ tcx.mk_imm_ptr(param(ccx, 0)) ], param(ccx, 0)),\n             \"volatile_store\" =>\n-                (1, vec!( tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0) ), tcx.mk_nil()),\n+                (1, vec![ tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0) ], tcx.mk_nil()),\n \n-            \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" => (1, vec!(param(ccx, 0)), param(ccx, 0)),\n+            \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" => (1, vec![param(ccx, 0)], param(ccx, 0)),\n \n             \"add_with_overflow\" | \"sub_with_overflow\"  | \"mul_with_overflow\" =>\n-                (1, vec!(param(ccx, 0), param(ccx, 0)),\n+                (1, vec![param(ccx, 0), param(ccx, 0)],\n                 tcx.intern_tup(&[param(ccx, 0), tcx.types.bool])),\n \n             \"unchecked_div\" | \"unchecked_rem\" =>"}, {"sha": "202e176df0dbc576b4bdeff4520b179b9a5c846a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -1387,7 +1387,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n             let bounds = match trait_item.node {\n                 hir::TypeTraitItem(ref bounds, _) => bounds,\n                 _ => {\n-                    return vec!().into_iter();\n+                    return vec![].into_iter();\n                 }\n             };\n "}, {"sha": "d636baca248df5b99a10faf1b91a5ffcd6c67be3", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -194,12 +194,12 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n \n fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 origin: TypeOrigin,\n-                                t1: Ty<'tcx>,\n-                                t2: Ty<'tcx>)\n+                                expected: Ty<'tcx>,\n+                                actual: Ty<'tcx>)\n                                 -> bool {\n     ccx.tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n-        if let Err(err) = infcx.eq_types(false, origin.clone(), t1, t2) {\n-            infcx.report_mismatched_types(origin, t1, t2, err);\n+        if let Err(err) = infcx.eq_types(false, origin.clone(), expected, actual) {\n+            infcx.report_mismatched_types(origin, expected, actual, err);\n             false\n         } else {\n             true\n@@ -248,8 +248,8 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             require_same_types(\n                 ccx,\n                 TypeOrigin::MainFunctionType(main_span),\n-                main_t,\n-                se_ty);\n+                se_ty,\n+                main_t);\n         }\n         _ => {\n             span_bug!(main_span,\n@@ -291,10 +291,10 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n-                    inputs: vec!(\n+                    inputs: vec![\n                         tcx.types.isize,\n                         tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))\n-                    ),\n+                    ],\n                     output: tcx.types.isize,\n                     variadic: false,\n                 }),\n@@ -303,8 +303,8 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             require_same_types(\n                 ccx,\n                 TypeOrigin::StartFunctionType(start_span),\n-                start_t,\n-                se_ty);\n+                se_ty,\n+                start_t);\n         }\n         _ => {\n             span_bug!(start_span,"}, {"sha": "f03b6a5ab3f1f200490dd370653e783c562c092c", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -143,8 +143,8 @@ pub fn run_core(search_paths: SearchPaths,\n     let sessopts = config::Options {\n         maybe_sysroot: maybe_sysroot,\n         search_paths: search_paths,\n-        crate_types: vec!(config::CrateTypeRlib),\n-        lint_opts: vec!((warning_lint, lint::Allow)),\n+        crate_types: vec![config::CrateTypeRlib],\n+        lint_opts: vec![(warning_lint, lint::Allow)],\n         lint_cap: Some(lint::Allow),\n         externs: externs,\n         target_triple: triple.unwrap_or(config::host_triple().to_string()),"}, {"sha": "67cf12f4f4a6ed3982cc0c984a339d69c6ef7444", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -644,7 +644,7 @@ mod tests {\n         t(\"test_harness\",          false,        false,  false,  true,  true,  false, Vec::new());\n         t(\"compile_fail\",          false,        true,   false,  true,  false, true,  Vec::new());\n         t(\"E0450\",                 false,        false,  false,  true,  false, false,\n-                                   vec!(\"E0450\".to_owned()));\n+                                   vec![\"E0450\".to_owned()]);\n         t(\"{.no_run .example}\",    false,        true,   false,  true,  false, false, Vec::new());\n         t(\"{.sh .should_panic}\",   true,         false,  false,  true,  false, false, Vec::new());\n         t(\"{.example .rust}\",      false,        false,  false,  true,  false, false, Vec::new());"}, {"sha": "a848a011f88dbfe6be21cb82c7d1bbe5ca333400", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -1260,7 +1260,7 @@ impl Context {\n         item.name = Some(krate.name);\n \n         // render the crate documentation\n-        let mut work = vec!((self, item));\n+        let mut work = vec![(self, item)];\n \n         while let Some((mut cx, item)) = work.pop() {\n             cx.item(item, |cx, item| {"}, {"sha": "a7da1c5cca48ce04f0b34976a9b34b299759da31", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -247,7 +247,7 @@ mod tests {\n         macro_rules! toc {\n             ($(($level: expr, $name: expr, $(($sub: tt))* )),*) => {\n                 Toc {\n-                    entries: vec!(\n+                    entries: vec![\n                         $(\n                             TocEntry {\n                                 level: $level,\n@@ -257,7 +257,7 @@ mod tests {\n                                 children: toc!($($sub),*)\n                             }\n                             ),*\n-                        )\n+                        ]\n                 }\n             }\n         }"}, {"sha": "cf5e8e5e34a3c7e9b7e65537ba7cc130143d3449", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -111,7 +111,7 @@ fn unstable(g: getopts::OptGroup) -> RustcOptGroup { RustcOptGroup::unstable(g)\n \n pub fn opts() -> Vec<RustcOptGroup> {\n     use getopts::*;\n-    vec!(\n+    vec![\n         stable(optflag(\"h\", \"help\", \"show this help message\")),\n         stable(optflag(\"V\", \"version\", \"print rustdoc's version\")),\n         stable(optflag(\"v\", \"verbose\", \"use verbose output\")),\n@@ -162,7 +162,7 @@ pub fn opts() -> Vec<RustcOptGroup> {\n         unstable(optmulti(\"Z\", \"\",\n                           \"internal and debugging options (only on nightly build)\", \"FLAG\")),\n         stable(optopt(\"\", \"sysroot\", \"Override the system root\", \"PATH\")),\n-    )\n+    ]\n }\n \n pub fn usage(argv0: &str) {"}, {"sha": "1bbd67fb9be3ab019709f47c3f99cf3fa37e2bf3", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -66,7 +66,7 @@ pub fn run(input: &str,\n         maybe_sysroot: Some(env::current_exe().unwrap().parent().unwrap()\n                                               .parent().unwrap().to_path_buf()),\n         search_paths: libs.clone(),\n-        crate_types: vec!(config::CrateTypeDylib),\n+        crate_types: vec![config::CrateTypeDylib],\n         externs: externs.clone(),\n         unstable_features: UnstableFeatures::from_environment(),\n         ..config::basic_options().clone()\n@@ -185,7 +185,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n         maybe_sysroot: Some(env::current_exe().unwrap().parent().unwrap()\n                                               .parent().unwrap().to_path_buf()),\n         search_paths: libs,\n-        crate_types: vec!(config::CrateTypeExecutable),\n+        crate_types: vec![config::CrateTypeExecutable],\n         output_types: outputs,\n         externs: externs,\n         cg: config::CodegenOptions {"}, {"sha": "239d32c8fc8ddc82c6d0549cd2bb6a6c152b0af6", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -3880,8 +3880,8 @@ mod tests {\n         use std::collections::{HashMap,BTreeMap};\n         use super::ToJson;\n \n-        let array2 = Array(vec!(U64(1), U64(2)));\n-        let array3 = Array(vec!(U64(1), U64(2), U64(3)));\n+        let array2 = Array(vec![U64(1), U64(2)]);\n+        let array3 = Array(vec![U64(1), U64(2), U64(3)]);\n         let object = {\n             let mut tree_map = BTreeMap::new();\n             tree_map.insert(\"a\".to_string(), U64(1));\n@@ -3915,7 +3915,7 @@ mod tests {\n         assert_eq!([1_usize, 2_usize].to_json(), array2);\n         assert_eq!((&[1_usize, 2_usize, 3_usize]).to_json(), array3);\n         assert_eq!((vec![1_usize, 2_usize]).to_json(), array2);\n-        assert_eq!(vec!(1_usize, 2_usize, 3_usize).to_json(), array3);\n+        assert_eq!(vec![1_usize, 2_usize, 3_usize].to_json(), array3);\n         let mut tree_map = BTreeMap::new();\n         tree_map.insert(\"a\".to_string(), 1 as usize);\n         tree_map.insert(\"b\".to_string(), 2);"}, {"sha": "a784d8e50f9d0d197af856ebd6bf09e68bc79770", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -21,7 +21,18 @@ use ptr::{self, Unique, Shared};\n \n use self::BucketState::*;\n \n-const EMPTY_BUCKET: u64 = 0;\n+/// Integer type used for stored hash values.\n+///\n+/// No more than bit_width(usize) bits are needed to select a bucket.\n+///\n+/// The most significant bit is ours to use for tagging `SafeHash`.\n+///\n+/// (Even if we could have usize::MAX bytes allocated for buckets,\n+/// each bucket stores at least a `HashUint`, so there can be no more than\n+/// usize::MAX / size_of(usize) buckets.)\n+type HashUint = usize;\n+\n+const EMPTY_BUCKET: HashUint = 0;\n \n /// The raw hashtable, providing safe-ish access to the unzipped and highly\n /// optimized arrays of hashes, and key-value pairs.\n@@ -64,7 +75,7 @@ const EMPTY_BUCKET: u64 = 0;\n pub struct RawTable<K, V> {\n     capacity: usize,\n     size: usize,\n-    hashes: Unique<u64>,\n+    hashes: Unique<HashUint>,\n \n     // Because K/V do not appear directly in any of the types in the struct,\n     // inform rustc that in fact instances of K and V are reachable from here.\n@@ -75,7 +86,7 @@ unsafe impl<K: Send, V: Send> Send for RawTable<K, V> {}\n unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}\n \n struct RawBucket<K, V> {\n-    hash: *mut u64,\n+    hash: *mut HashUint,\n     // We use *const to ensure covariance with respect to K and V\n     pair: *const (K, V),\n     _marker: marker::PhantomData<(K, V)>,\n@@ -113,10 +124,6 @@ pub struct FullBucket<K, V, M> {\n     table: M,\n }\n \n-pub type EmptyBucketImm<'table, K, V> = EmptyBucket<K, V, &'table RawTable<K, V>>;\n-pub type FullBucketImm<'table, K, V> = FullBucket<K, V, &'table RawTable<K, V>>;\n-\n-pub type EmptyBucketMut<'table, K, V> = EmptyBucket<K, V, &'table mut RawTable<K, V>>;\n pub type FullBucketMut<'table, K, V> = FullBucket<K, V, &'table mut RawTable<K, V>>;\n \n pub enum BucketState<K, V, M> {\n@@ -136,15 +143,27 @@ pub struct GapThenFull<K, V, M> {\n /// buckets.\n #[derive(PartialEq, Copy, Clone)]\n pub struct SafeHash {\n-    hash: u64,\n+    hash: HashUint,\n }\n \n impl SafeHash {\n     /// Peek at the hash value, which is guaranteed to be non-zero.\n     #[inline(always)]\n-    pub fn inspect(&self) -> u64 {\n+    pub fn inspect(&self) -> HashUint {\n         self.hash\n     }\n+\n+    #[inline(always)]\n+    pub fn new(hash: u64) -> Self {\n+        // We need to avoid 0 in order to prevent collisions with\n+        // EMPTY_HASH. We can maintain our precious uniform distribution\n+        // of initial indexes by unconditionally setting the MSB,\n+        // effectively reducing the hashes by one bit.\n+        //\n+        // Truncate hash to fit in `HashUint`.\n+        let hash_bits = size_of::<HashUint>() * 8;\n+        SafeHash { hash: (1 << (hash_bits - 1)) | (hash as HashUint) }\n+    }\n }\n \n /// We need to remove hashes of 0. That's reserved for empty buckets.\n@@ -156,25 +175,21 @@ pub fn make_hash<T: ?Sized, S>(hash_state: &S, t: &T) -> SafeHash\n {\n     let mut state = hash_state.build_hasher();\n     t.hash(&mut state);\n-    // We need to avoid 0 in order to prevent collisions with\n-    // EMPTY_HASH. We can maintain our precious uniform distribution\n-    // of initial indexes by unconditionally setting the MSB,\n-    // effectively reducing 64-bits hashes to 63 bits.\n-    SafeHash { hash: 0x8000_0000_0000_0000 | state.finish() }\n+    SafeHash::new(state.finish())\n }\n \n-// `replace` casts a `*u64` to a `*SafeHash`. Since we statically\n+// `replace` casts a `*HashUint` to a `*SafeHash`. Since we statically\n // ensure that a `FullBucket` points to an index with a non-zero hash,\n-// and a `SafeHash` is just a `u64` with a different name, this is\n+// and a `SafeHash` is just a `HashUint` with a different name, this is\n // safe.\n //\n // This test ensures that a `SafeHash` really IS the same size as a\n-// `u64`. If you need to change the size of `SafeHash` (and\n+// `HashUint`. If you need to change the size of `SafeHash` (and\n // consequently made this test fail), `replace` needs to be\n // modified to no longer assume this.\n #[test]\n-fn can_alias_safehash_as_u64() {\n-    assert_eq!(size_of::<SafeHash>(), size_of::<u64>())\n+fn can_alias_safehash_as_hash() {\n+    assert_eq!(size_of::<SafeHash>(), size_of::<HashUint>())\n }\n \n impl<K, V> RawBucket<K, V> {\n@@ -605,14 +620,14 @@ impl<K, V> RawTable<K, V> {\n             return RawTable {\n                 size: 0,\n                 capacity: 0,\n-                hashes: Unique::new(EMPTY as *mut u64),\n+                hashes: Unique::new(EMPTY as *mut HashUint),\n                 marker: marker::PhantomData,\n             };\n         }\n \n         // No need for `checked_mul` before a more restrictive check performed\n         // later in this method.\n-        let hashes_size = capacity.wrapping_mul(size_of::<u64>());\n+        let hashes_size = capacity.wrapping_mul(size_of::<HashUint>());\n         let pairs_size = capacity.wrapping_mul(size_of::<(K, V)>());\n \n         // Allocating hashmaps is a little tricky. We need to allocate two\n@@ -624,13 +639,13 @@ impl<K, V> RawTable<K, V> {\n         // right is a little subtle. Therefore, calculating offsets has been\n         // factored out into a different function.\n         let (alignment, hash_offset, size, oflo) = calculate_allocation(hashes_size,\n-                                                                        align_of::<u64>(),\n+                                                                        align_of::<HashUint>(),\n                                                                         pairs_size,\n                                                                         align_of::<(K, V)>());\n         assert!(!oflo, \"capacity overflow\");\n \n         // One check for overflow that covers calculation and rounding of size.\n-        let size_of_bucket = size_of::<u64>().checked_add(size_of::<(K, V)>()).unwrap();\n+        let size_of_bucket = size_of::<HashUint>().checked_add(size_of::<(K, V)>()).unwrap();\n         assert!(size >=\n                 capacity.checked_mul(size_of_bucket)\n                     .expect(\"capacity overflow\"),\n@@ -641,7 +656,7 @@ impl<K, V> RawTable<K, V> {\n             ::alloc::oom()\n         }\n \n-        let hashes = buffer.offset(hash_offset as isize) as *mut u64;\n+        let hashes = buffer.offset(hash_offset as isize) as *mut HashUint;\n \n         RawTable {\n             capacity: capacity,\n@@ -652,7 +667,7 @@ impl<K, V> RawTable<K, V> {\n     }\n \n     fn first_bucket_raw(&self) -> RawBucket<K, V> {\n-        let hashes_size = self.capacity * size_of::<u64>();\n+        let hashes_size = self.capacity * size_of::<HashUint>();\n         let pairs_size = self.capacity * size_of::<(K, V)>();\n \n         let buffer = *self.hashes as *mut u8;\n@@ -756,7 +771,7 @@ impl<K, V> RawTable<K, V> {\n /// this interface is safe, it's not used outside this module.\n struct RawBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n-    hashes_end: *mut u64,\n+    hashes_end: *mut HashUint,\n \n     // Strictly speaking, this should be &'a (K,V), but that would\n     // require that K:'a, and we often use RawBuckets<'static...> for\n@@ -802,7 +817,7 @@ impl<'a, K, V> Iterator for RawBuckets<'a, K, V> {\n /// the table's remaining entries. It's used in the implementation of Drop.\n struct RevMoveBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n-    hashes_end: *mut u64,\n+    hashes_end: *mut HashUint,\n     elems_left: usize,\n \n     // As above, `&'a (K,V)` would seem better, but we often use\n@@ -1036,10 +1051,10 @@ impl<K, V> Drop for RawTable<K, V> {\n             }\n         }\n \n-        let hashes_size = self.capacity * size_of::<u64>();\n+        let hashes_size = self.capacity * size_of::<HashUint>();\n         let pairs_size = self.capacity * size_of::<(K, V)>();\n         let (align, _, size, oflo) = calculate_allocation(hashes_size,\n-                                                          align_of::<u64>(),\n+                                                          align_of::<HashUint>(),\n                                                           pairs_size,\n                                                           align_of::<(K, V)>());\n "}, {"sha": "454fa47cfbc99f4277cfab407759e5d18ad0c132", "filename": "src/libstd/error.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -69,7 +69,9 @@ pub trait Error: Debug + Display {\n     /// It should not contain newlines or sentence-ending punctuation,\n     /// to facilitate embedding in larger user-facing strings.\n     /// For showing formatted error messages with more information see\n-    /// [Display](https://doc.rust-lang.org/std/fmt/trait.Display.html).\n+    /// [`Display`].\n+    ///\n+    /// [`Display`]: ../fmt/trait.Display.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "7a676c041ad89084e72b2ea5325923f0e0fabf4b", "filename": "src/libstd/f32.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/num/f32.rs"}, {"sha": "67a1c302483d20644bdd157def4bed445c47e6fa", "filename": "src/libstd/f64.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/num/f64.rs"}, {"sha": "1b5023380a7833c9adc13422817cb75d2b0098fb", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -23,7 +23,7 @@ use io::{self, SeekFrom, Error, ErrorKind};\n ///\n /// The standard library implements some I/O traits on various types which\n /// are commonly used as a buffer, like `Cursor<`[`Vec`]`<u8>>` and\n-/// `Cursor<`[`&[u8]`]`>`.\n+/// `Cursor<`[`&[u8]`][bytes]`>`.\n ///\n /// # Examples\n ///\n@@ -35,7 +35,7 @@ use io::{self, SeekFrom, Error, ErrorKind};\n /// [`Read`]: ../../std/io/trait.Read.html\n /// [`Write`]: ../../std/io/trait.Write.html\n /// [`Vec`]: ../../std/vec/struct.Vec.html\n-/// [`&[u8]`]: ../../std/primitive.slice.html\n+/// [bytes]: ../../std/primitive.slice.html\n /// [`File`]: ../fs/struct.File.html\n ///\n /// ```no_run\n@@ -392,7 +392,7 @@ mod tests {\n \n     #[test]\n     fn test_mem_reader() {\n-        let mut reader = Cursor::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n+        let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n         let mut buf = [];\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n         assert_eq!(reader.position(), 0);\n@@ -414,7 +414,7 @@ mod tests {\n \n     #[test]\n     fn test_boxed_slice_reader() {\n-        let mut reader = Cursor::new(vec!(0, 1, 2, 3, 4, 5, 6, 7).into_boxed_slice());\n+        let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n         let mut buf = [];\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n         assert_eq!(reader.position(), 0);\n@@ -436,7 +436,7 @@ mod tests {\n \n     #[test]\n     fn read_to_end() {\n-        let mut reader = Cursor::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n+        let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n         let mut v = Vec::new();\n         reader.read_to_end(&mut v).unwrap();\n         assert_eq!(v, [0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -512,7 +512,7 @@ mod tests {\n         assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n         assert_eq!(r.read(&mut [0]).unwrap(), 0);\n \n-        let mut r = Cursor::new(vec!(10));\n+        let mut r = Cursor::new(vec![10]);\n         assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n         assert_eq!(r.read(&mut [0]).unwrap(), 0);\n \n@@ -532,14 +532,14 @@ mod tests {\n         let mut r = Cursor::new(&buf[..]);\n         assert!(r.seek(SeekFrom::End(-2)).is_err());\n \n-        let mut r = Cursor::new(vec!(10));\n+        let mut r = Cursor::new(vec![10]);\n         assert!(r.seek(SeekFrom::End(-2)).is_err());\n \n         let mut buf = [0];\n         let mut r = Cursor::new(&mut buf[..]);\n         assert!(r.seek(SeekFrom::End(-2)).is_err());\n \n-        let mut r = Cursor::new(vec!(10).into_boxed_slice());\n+        let mut r = Cursor::new(vec![10].into_boxed_slice());\n         assert!(r.seek(SeekFrom::End(-2)).is_err());\n     }\n "}, {"sha": "193f396c0d4ab3a3d6a0fb0bbab3401effba48a9", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -289,7 +289,7 @@ mod lazy;\n mod util;\n mod stdio;\n \n-const DEFAULT_BUF_SIZE: usize = 8 * 1024;\n+const DEFAULT_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;\n \n // A few methods below (read_to_string, read_line) will append data into a\n // `String` buffer, but we need to be pretty careful when doing this. The"}, {"sha": "1777b79ea1b59b422ed23c5f35e3ac0db1c7d241", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -214,15 +214,7 @@ pub fn stdin() -> Stdin {\n             _ => Maybe::Fake\n         };\n \n-        // The default buffer capacity is 64k, but apparently windows\n-        // doesn't like 64k reads on stdin. See #13304 for details, but the\n-        // idea is that on windows we use a slightly smaller buffer that's\n-        // been seen to be acceptable.\n-        Arc::new(Mutex::new(if cfg!(windows) {\n-            BufReader::with_capacity(8 * 1024, stdin)\n-        } else {\n-            BufReader::new(stdin)\n-        }))\n+        Arc::new(Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin)))\n     }\n }\n "}, {"sha": "8d973fc1ade472924bc1eba43b09545558d24d3c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 72, "deletions": 78, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -210,14 +210,34 @@\n        test(no_crate_inject, attr(deny(warnings))),\n        test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n+// Don't link to std. We are std.\n+#![no_std]\n+\n+#![deny(missing_docs)]\n+\n+// Tell the compiler to link to either panic_abort or panic_unwind\n #![needs_panic_runtime]\n \n+// Always use alloc_system during stage0 since jemalloc might be unavailable or\n+// disabled (Issue #30592)\n+#![cfg_attr(stage0, feature(alloc_system))]\n+\n+// Turn warnings into errors, but only after stage0, where it can be useful for\n+// code to emit warnings during language transitions\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+// std may use features in a platform-specific way\n+#![allow(unused_features)]\n+\n+// std is implemented with unstable features, many of which are internal\n+// compiler details that will never be stable\n #![feature(alloc)]\n #![feature(allow_internal_unstable)]\n #![feature(asm)]\n #![feature(associated_consts)]\n #![feature(borrow_state)]\n #![feature(box_syntax)]\n+#![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n #![feature(cfg_target_vendor)]\n #![feature(char_escape_debug)]\n@@ -240,13 +260,13 @@\n #![feature(heap_api)]\n #![feature(inclusive_range)]\n #![feature(int_error_internals)]\n+#![feature(integer_atomics)]\n #![feature(into_cow)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(linkage)]\n #![feature(macro_reexport)]\n-#![cfg_attr(test, feature(map_values_mut))]\n #![feature(needs_panic_runtime)]\n #![feature(num_bits_bytes)]\n #![feature(old_wrapping)]\n@@ -282,21 +302,13 @@\n #![feature(zero_one)]\n #![cfg_attr(test, feature(update_panic_count))]\n \n-// Issue# 30592: Systematically use alloc_system during stage0 since jemalloc\n-// might be unavailable or disabled\n-#![cfg_attr(stage0, feature(alloc_system))]\n-\n-// Don't link to std. We are std.\n-#![no_std]\n-\n-#![deny(missing_docs)]\n-#![allow(unused_features)] // std may use features in a platform-specific way\n-#![cfg_attr(not(stage0), deny(warnings))]\n-\n+// Explicitly import the prelude. The compiler uses this same unstable attribute\n+// to import the prelude implicitly when building crates that depend on std.\n #[prelude_import]\n #[allow(unused)]\n use prelude::v1::*;\n \n+// Access to Bencher, etc.\n #[cfg(test)] extern crate test;\n \n // We want to reexport a few macros from core but libcore has already been\n@@ -324,11 +336,22 @@ extern crate alloc_system;\n // compiler-rt intrinsics\n extern crate compiler_builtins;\n \n-// Make std testable by not duplicating lang items and other globals. See #2912\n+// During testing, this crate is not actually the \"real\" std library, but rather\n+// it links to the real std library, which was compiled from this same source\n+// code. So any lang items std defines are conditionally excluded (or else they\n+// wolud generate duplicate lang item errors), and any globals it defines are\n+// _not_ the globals used by \"real\" std. So this import, defined only during\n+// testing gives test-std access to real-std lang items and globals. See #2912\n #[cfg(test)] extern crate std as realstd;\n \n-// NB: These reexports are in the order they should be listed in rustdoc\n+// The standard macros that are not built-in to the compiler.\n+#[macro_use]\n+mod macros;\n+\n+// The Rust prelude\n+pub mod prelude;\n \n+// Public module declarations and reexports\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::any;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -361,48 +384,6 @@ pub use core::raw;\n pub use core::result;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::option;\n-\n-pub mod error;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::boxed;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::rc;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::borrow;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::fmt;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::slice;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::str;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::string;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core_collections::vec;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use rustc_unicode::char;\n-\n-/* Exported macros */\n-\n-#[macro_use]\n-mod macros;\n-\n-mod rtdeps;\n-\n-/* The Prelude. */\n-\n-pub mod prelude;\n-\n-\n-/* Primitive types */\n-\n-// NB: slice and str are primitive types too, but their module docs + primitive\n-// doc pages are inlined from the public re-exports of core_collections::{slice,\n-// str} above.\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::isize;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -413,7 +394,6 @@ pub use core::i16;\n pub use core::i32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::i64;\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::usize;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -424,48 +404,62 @@ pub use core::u16;\n pub use core::u32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::u64;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use alloc::boxed;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use alloc::rc;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::borrow;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::fmt;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::slice;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::str;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::string;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core_collections::vec;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use rustc_unicode::char;\n \n-#[path = \"num/f32.rs\"]   pub mod f32;\n-#[path = \"num/f64.rs\"]   pub mod f64;\n-\n-pub mod ascii;\n-\n-/* Common traits */\n-\n-pub mod num;\n-\n-/* Runtime and platform support */\n+pub mod f32;\n+pub mod f64;\n \n #[macro_use]\n pub mod thread;\n-\n+pub mod ascii;\n pub mod collections;\n pub mod env;\n+pub mod error;\n pub mod ffi;\n pub mod fs;\n pub mod io;\n pub mod net;\n+pub mod num;\n pub mod os;\n pub mod panic;\n pub mod path;\n pub mod process;\n pub mod sync;\n pub mod time;\n-mod memchr;\n \n+// Platform-abstraction modules\n #[macro_use]\n-#[path = \"sys/common/mod.rs\"] mod sys_common;\n-\n-#[cfg(redox)]\n-#[path = \"sys/redox/mod.rs\"] mod sys;\n-#[cfg(unix)]\n-#[path = \"sys/unix/mod.rs\"] mod sys;\n-#[cfg(windows)]\n-#[path = \"sys/windows/mod.rs\"] mod sys;\n+mod sys_common;\n+mod sys;\n \n-pub mod rt;\n+// Private support modules\n mod panicking;\n mod rand;\n+mod memchr;\n+\n+// This module just defines per-platform native library dependencies\n+mod rtdeps;\n+\n+// The runtime entry point and a few unstable public functions used by the\n+// compiler\n+pub mod rt;\n \n // Some external utilities of the standard library rely on randomness (aka\n // rustc_back::TempDir and tests) and need a way to get at the OS rng we've got"}, {"sha": "d1c2fc3d3fce9371a3584bf88f07f120834f139c", "filename": "src/libstd/num.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/num/mod.rs"}, {"sha": "a7e8c4fab3735031cab62da9896c41949a309a38", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -18,7 +18,7 @@ use ops::{Deref, DerefMut};\n use panicking;\n use ptr::{Unique, Shared};\n use rc::Rc;\n-use sync::{Arc, Mutex, RwLock};\n+use sync::{Arc, Mutex, RwLock, atomic};\n use thread::Result;\n \n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n@@ -231,6 +231,46 @@ impl<T: ?Sized> RefUnwindSafe for Mutex<T> {}\n #[stable(feature = \"unwind_safe_lock_refs\", since = \"1.12.0\")]\n impl<T: ?Sized> RefUnwindSafe for RwLock<T> {}\n \n+#[cfg(target_has_atomic = \"ptr\")]\n+#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+impl RefUnwindSafe for atomic::AtomicIsize {}\n+#[cfg(target_has_atomic = \"8\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+impl RefUnwindSafe for atomic::AtomicI8 {}\n+#[cfg(target_has_atomic = \"16\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+impl RefUnwindSafe for atomic::AtomicI16 {}\n+#[cfg(target_has_atomic = \"32\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+impl RefUnwindSafe for atomic::AtomicI32 {}\n+#[cfg(target_has_atomic = \"64\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+impl RefUnwindSafe for atomic::AtomicI64 {}\n+\n+#[cfg(target_has_atomic = \"ptr\")]\n+#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+impl RefUnwindSafe for atomic::AtomicUsize {}\n+#[cfg(target_has_atomic = \"8\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+impl RefUnwindSafe for atomic::AtomicU8 {}\n+#[cfg(target_has_atomic = \"16\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+impl RefUnwindSafe for atomic::AtomicU16 {}\n+#[cfg(target_has_atomic = \"32\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+impl RefUnwindSafe for atomic::AtomicU32 {}\n+#[cfg(target_has_atomic = \"64\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+impl RefUnwindSafe for atomic::AtomicU64 {}\n+\n+#[cfg(target_has_atomic = \"8\")]\n+#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+impl RefUnwindSafe for atomic::AtomicBool {}\n+\n+#[cfg(target_has_atomic = \"ptr\")]\n+#[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+impl<T> RefUnwindSafe for atomic::AtomicPtr<T> {}\n+\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T> Deref for AssertUnwindSafe<T> {\n     type Target = T;"}, {"sha": "9b7f9980cc0af5873664bd5d43f5d6aa716bbd65", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -914,6 +914,7 @@ impl<'a> cmp::Ord for Components<'a> {\n /// [`Path`]: struct.Path.html\n /// [`push`]: struct.PathBuf.html#method.push\n /// [`set_extension`]: struct.PathBuf.html#method.set_extension\n+/// [`Deref`]: ../ops/trait.Deref.html\n ///\n /// More details about the overall approach can be found in\n /// the module documentation."}, {"sha": "f48325218fb4908ecc36c8fc8212d067fd1b7727", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -245,7 +245,7 @@ mod tests {\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_os_rng_tasks() {\n \n-        let mut txs = vec!();\n+        let mut txs = vec![];\n         for _ in 0..20 {\n             let (tx, rx) = channel();\n             txs.push(tx);"}, {"sha": "c196bf39432cf3ee7a6203d5a764a93986bad062", "filename": "src/libstd/sys/mod.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Platform-dependent platform abstraction\n+//!\n+//! The `std::sys` module is the abstracted interface through which\n+//! `std` talks to the underlying operating system. It has different\n+//! implementations for different operating system families, today\n+//! just Unix and Windows.\n+//!\n+//! The centralization of platform-specific code in this module is\n+//! enforced by the \"platform abstraction layer\" tidy script in\n+//! `tools/tidy/pal.rs`.\n+//!\n+//! This module is closely related to the platform-independent system\n+//! integration code in `std::sys_common`. See that module's\n+//! documentation for details.\n+//!\n+//! In the future it would be desirable for the indepedent\n+//! implementations of this module to be extracted to their own crates\n+//! that `std` can link to, thus enabling their implementation\n+//! out-of-tree via crate replacement. Though due to the complex\n+//! inter-dependencies within `std` that will be a challenging goal to\n+//! achieve.\n+\n+pub use self::imp::*;\n+\n+#[cfg(redox)]\n+#[path = \"redox/mod.rs\"]\n+mod imp;\n+\n+#[cfg(unix)]\n+#[path = \"unix/mod.rs\"]\n+mod imp;\n+\n+#[cfg(windows)]\n+#[path = \"windows/mod.rs\"]\n+mod imp;"}, {"sha": "0c625e7add9d0eb81b3efa976a3374eaf929c8d4", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg(target_thread_local)]\n+#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n+\n+use cell::{Cell, UnsafeCell};\n+use intrinsics;\n+use ptr;\n+\n+pub struct Key<T> {\n+    inner: UnsafeCell<Option<T>>,\n+\n+    // Metadata to keep track of the state of the destructor. Remember that\n+    // these variables are thread-local, not global.\n+    dtor_registered: Cell<bool>,\n+    dtor_running: Cell<bool>,\n+}\n+\n+unsafe impl<T> ::marker::Sync for Key<T> { }\n+\n+impl<T> Key<T> {\n+    pub const fn new() -> Key<T> {\n+        Key {\n+            inner: UnsafeCell::new(None),\n+            dtor_registered: Cell::new(false),\n+            dtor_running: Cell::new(false)\n+        }\n+    }\n+\n+    pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n+        unsafe {\n+            if intrinsics::needs_drop::<T>() && self.dtor_running.get() {\n+                return None\n+            }\n+            self.register_dtor();\n+        }\n+        Some(&self.inner)\n+    }\n+\n+    unsafe fn register_dtor(&self) {\n+        if !intrinsics::needs_drop::<T>() || self.dtor_registered.get() {\n+            return\n+        }\n+\n+        register_dtor(self as *const _ as *mut u8,\n+                      destroy_value::<T>);\n+        self.dtor_registered.set(true);\n+    }\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\"))]\n+unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    // The fallback implementation uses a vanilla OS-based TLS key to track\n+    // the list of destructors that need to be run for this thread. The key\n+    // then has its own destructor which runs all the other destructors.\n+    //\n+    // The destructor for DTORS is a little special in that it has a `while`\n+    // loop to continuously drain the list of registered destructors. It\n+    // *should* be the case that this loop always terminates because we\n+    // provide the guarantee that a TLS key cannot be set after it is\n+    // flagged for destruction.\n+    use sys_common::thread_local as os;\n+\n+    static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n+    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n+    if DTORS.get().is_null() {\n+        let v: Box<List> = box Vec::new();\n+        DTORS.set(Box::into_raw(v) as *mut u8);\n+    }\n+    let list: &mut List = &mut *(DTORS.get() as *mut List);\n+    list.push((t, dtor));\n+\n+    unsafe extern fn run_dtors(mut ptr: *mut u8) {\n+        while !ptr.is_null() {\n+            let list: Box<List> = Box::from_raw(ptr as *mut List);\n+            for &(ptr, dtor) in list.iter() {\n+                dtor(ptr);\n+            }\n+            ptr = DTORS.get();\n+            DTORS.set(ptr::null_mut());\n+        }\n+    }\n+}\n+\n+// Since what appears to be glibc 2.18 this symbol has been shipped which\n+// GCC and clang both use to invoke destructors in thread_local globals, so\n+// let's do the same!\n+//\n+// Note, however, that we run on lots older linuxes, as well as cross\n+// compiling from a newer linux to an older linux, so we also have a\n+// fallback implementation to use as well.\n+//\n+// Due to rust-lang/rust#18804, make sure this is not generic!\n+#[cfg(target_os = \"linux\")]\n+unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    use mem;\n+    use libc;\n+\n+    extern {\n+        #[linkage = \"extern_weak\"]\n+        static __dso_handle: *mut u8;\n+        #[linkage = \"extern_weak\"]\n+        static __cxa_thread_atexit_impl: *const libc::c_void;\n+    }\n+    if !__cxa_thread_atexit_impl.is_null() {\n+        type F = unsafe extern fn(dtor: unsafe extern fn(*mut u8),\n+                                  arg: *mut u8,\n+                                  dso_handle: *mut u8) -> libc::c_int;\n+        mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)\n+            (dtor, t, &__dso_handle as *const _ as *mut _);\n+        return\n+    }\n+    register_dtor_fallback(t, dtor);\n+}\n+\n+// OSX's analog of the above linux function is this _tlv_atexit function.\n+// The disassembly of thread_local globals in C++ (at least produced by\n+// clang) will have this show up in the output.\n+#[cfg(target_os = \"macos\")]\n+unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    extern {\n+        fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),\n+                       arg: *mut u8);\n+    }\n+    _tlv_atexit(dtor, t);\n+}\n+\n+// Just use the thread_local fallback implementation, at least until there's\n+// a more direct implementation.\n+#[cfg(target_os = \"fuchsia\")]\n+unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    register_dtor_fallback(t, dtor);\n+}\n+\n+pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n+    let ptr = ptr as *mut Key<T>;\n+    // Right before we run the user destructor be sure to flag the\n+    // destructor as running for this thread so calls to `get` will return\n+    // `None`.\n+    (*ptr).dtor_running.set(true);\n+\n+    // The OSX implementation of TLS apparently had an odd aspect to it\n+    // where the pointer we have may be overwritten while this destructor\n+    // is running. Specifically if a TLS destructor re-accesses TLS it may\n+    // trigger a re-initialization of all TLS variables, paving over at\n+    // least some destroyed ones with initial values.\n+    //\n+    // This means that if we drop a TLS value in place on OSX that we could\n+    // revert the value to its original state halfway through the\n+    // destructor, which would be bad!\n+    //\n+    // Hence, we use `ptr::read` on OSX (to move to a \"safe\" location)\n+    // instead of drop_in_place.\n+    if cfg!(target_os = \"macos\") {\n+        ptr::read((*ptr).inner.get());\n+    } else {\n+        ptr::drop_in_place((*ptr).inner.get());\n+    }\n+}"}, {"sha": "fd7dc17cccd8cbf36d3a24684215adebeb41326f", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -38,6 +38,7 @@ pub mod backtrace;\n pub mod condvar;\n pub mod env;\n pub mod ext;\n+pub mod fast_thread_local;\n pub mod fd;\n pub mod fs;\n pub mod memchr;\n@@ -162,3 +163,14 @@ pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n         }\n     }\n }\n+\n+// On Unix-like platforms, libc::abort will unregister signal handlers\n+// including the SIGABRT handler, preventing the abort from being blocked, and\n+// fclose streams, with the side effect of flushing them so libc bufferred\n+// output will be printed.  Additionally the shell will generally print a more\n+// understandable error message like \"Abort trap\" rather than \"Illegal\n+// instruction\" that intrinsics::abort would cause, as intrinsics::abort is\n+// implemented as an illegal instruction.\n+pub unsafe fn abort_internal() -> ! {\n+    ::libc::abort()\n+}"}, {"sha": "273341b1918d1c0e6c42200b0b97b238fd9ff3d1", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -67,3 +67,4 @@ impl io::Write for Stderr {\n }\n \n pub const EBADF_ERR: i32 = ::libc::EBADF as i32;\n+pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;"}, {"sha": "defc41c5f46a38ccc33954d99bf265a6b111e635", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -179,7 +179,7 @@ pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     }\n }\n \n-trait IsZero {\n+pub trait IsZero {\n     fn is_zero(&self) -> bool;\n }\n \n@@ -193,15 +193,15 @@ macro_rules! impl_is_zero {\n \n impl_is_zero! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n \n-fn cvt<I: IsZero>(i: I) -> io::Result<I> {\n+pub fn cvt<I: IsZero>(i: I) -> io::Result<I> {\n     if i.is_zero() {\n         Err(io::Error::last_os_error())\n     } else {\n         Ok(i)\n     }\n }\n \n-fn dur2timeout(dur: Duration) -> c::DWORD {\n+pub fn dur2timeout(dur: Duration) -> c::DWORD {\n     // Note that a duration is a (u64, u32) (seconds, nanoseconds) pair, and the\n     // timeouts in windows APIs are typically u32 milliseconds. To translate, we\n     // have two pieces to take care of:\n@@ -221,3 +221,17 @@ fn dur2timeout(dur: Duration) -> c::DWORD {\n         }\n     }).unwrap_or(c::INFINITE)\n }\n+\n+// On Windows, use the processor-specific __fastfail mechanism.  In Windows 8\n+// and later, this will terminate the process immediately without running any\n+// in-process exception handlers.  In earlier versions of Windows, this\n+// sequence of instructions will be treated as an access violation,\n+// terminating the process but without necessarily bypassing all exception\n+// handlers.\n+//\n+// https://msdn.microsoft.com/en-us/library/dn774154.aspx\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+pub unsafe fn abort_internal() -> ! {\n+    asm!(\"int $$0x29\" :: \"{ecx}\"(7) ::: volatile); // 7 is FAST_FAIL_FATAL_APP_EXIT\n+    ::intrinsics::unreachable();\n+}"}, {"sha": "72788776dedd6ebdf4f60143e9774334c6860cc1", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -207,3 +207,8 @@ fn invalid_encoding() -> io::Error {\n }\n \n pub const EBADF_ERR: i32 = ::sys::c::ERROR_INVALID_HANDLE as i32;\n+// The default buffer capacity is 64k, but apparently windows\n+// doesn't like 64k reads on stdin. See #13304 for details, but the\n+// idea is that on windows we use a slightly smaller buffer that's\n+// been seen to be acceptable.\n+pub const STDIN_BUF_SIZE: usize = 8 * 1024;"}, {"sha": "ce6fd4cb0754b1cc9297b4a97394b08aebc1356c", "filename": "src/libstd/sys_common/at_exit_imp.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/at_exit_imp.rs"}, {"sha": "a8540fed9286f1aaae8f9843c25ec5f293d301e7", "filename": "src/libstd/sys_common/backtrace.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/backtrace.rs"}, {"sha": "b6f29dd5fc3d3184f6a528fcb36f70b64b3f1051", "filename": "src/libstd/sys_common/condvar.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fcondvar.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/condvar.rs"}, {"sha": "b5802afc109435ec1e5e2cf8dd1b71951780c592", "filename": "src/libstd/sys_common/gnu/libbacktrace.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/gnu/libbacktrace.rs"}, {"sha": "3a8cf2d84259173af8317ef21e96261c437cfec4", "filename": "src/libstd/sys_common/gnu/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fgnu%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fgnu%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fgnu%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/gnu/mod.rs"}, {"sha": "23daeeb5187b7f75551ed3ea4612cdf194c715a4", "filename": "src/libstd/sys_common/io.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fio.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -12,6 +12,8 @@ use io::ErrorKind;\n use io::Read;\n use slice::from_raw_parts_mut;\n \n+pub const DEFAULT_BUF_SIZE: usize = 8 * 1024;\n+\n // Provides read_to_end functionality over an uninitialized buffer.\n // This function is unsafe because it calls the underlying\n // read function with a slice into uninitialized memory. The default", "previous_filename": "src/libstd/sys/common/io.rs"}, {"sha": "3824a5fb5284c85c430f148704c8a5516ddb44f1", "filename": "src/libstd/sys_common/memchr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmemchr.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/memchr.rs"}, {"sha": "bbd2f679bcaf4cf7da0b6436ad3326afdc860778", "filename": "src/libstd/sys_common/mod.rs", "status": "renamed", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -8,23 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Platform-independent platform abstraction\n+//!\n+//! This is the platform-independent portion of the standard libraries\n+//! platform abstraction layer, whereas `std::sys` is the\n+//! platform-specific portion.\n+//!\n+//! The relationship between `std::sys_common`, `std::sys` and the\n+//! rest of `std` is complex, with dependencies going in all\n+//! directions: `std` depending on `sys_common`, `sys_common`\n+//! depending on `sys`, and `sys` depending on `sys_common` and `std`.\n+//! Ideally `sys_common` would be split into two and the dependencies\n+//! between them all would form a dag, facilitating the extraction of\n+//! `std::sys` from the standard library.\n+\n #![allow(missing_docs)]\n \n use sync::Once;\n use sys;\n \n-macro_rules! rtabort {\n-    ($($t:tt)*) => (::sys_common::util::abort(format_args!($($t)*)))\n-}\n-\n-macro_rules! rtassert {\n-    ($e:expr) => ({\n-        if !$e {\n-            rtabort!(concat!(\"assertion failed: \", stringify!($e)))\n-        }\n-    })\n-}\n-\n pub mod at_exit_imp;\n #[cfg(any(not(cargobuild), feature = \"backtrace\"))]\n pub mod backtrace;\n@@ -92,6 +94,10 @@ pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n     if at_exit_imp::push(Box::new(f)) {Ok(())} else {Err(())}\n }\n \n+macro_rules! rtabort {\n+    ($($t:tt)*) => (::sys_common::util::abort(format_args!($($t)*)))\n+}\n+\n /// One-time runtime cleanup.\n pub fn cleanup() {\n     static CLEANUP: Once = Once::new();", "previous_filename": "src/libstd/sys/common/mod.rs"}, {"sha": "d1a738770d3893fb66189c036009fd62375984db", "filename": "src/libstd/sys_common/mutex.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmutex.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/mutex.rs"}, {"sha": "10ad61f4c800c26b9593a7979edbf2f5cac55ce1", "filename": "src/libstd/sys_common/net.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/net.rs"}, {"sha": "bdc727f1dfcfe0f20536ce50054f7ec5e6cff3e7", "filename": "src/libstd/sys_common/poison.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fpoison.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/poison.rs"}, {"sha": "4d0407ccf6c8903bb20eee0059b492319a94d81f", "filename": "src/libstd/sys_common/remutex.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fremutex.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/remutex.rs"}, {"sha": "71a4f01ec4cab9f2d3edcee78af3373f2484e24f", "filename": "src/libstd/sys_common/rwlock.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Frwlock.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/rwlock.rs"}, {"sha": "3ee160da5fa5b7876ab1a2c957b77c9cc3aa75f8", "filename": "src/libstd/sys_common/thread.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/thread.rs"}, {"sha": "95d8b6cc9516d2e3e5573863d9287ed65d70e105", "filename": "src/libstd/sys_common/thread_info.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_info.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/thread_info.rs"}, {"sha": "25a9d5720d9338bfb14ed8dba43bd03edaf36362", "filename": "src/libstd/sys_common/thread_local.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_local.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/thread_local.rs"}, {"sha": "daa0c15920b666703f323463a8952a5e753d937e", "filename": "src/libstd/sys_common/util.rs", "status": "renamed", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Futil.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -33,46 +33,14 @@ pub fn dumb_print(args: fmt::Arguments) {\n     let _ = Stderr::new().map(|mut stderr| stderr.write_fmt(args));\n }\n \n-// On Redox, use an illegal instruction\n-#[cfg(redox)]\n-unsafe fn abort_internal() -> ! {\n-    ::intrinsics::abort()\n-}\n-\n-// On Unix-like platforms, libc::abort will unregister signal handlers\n-// including the SIGABRT handler, preventing the abort from being blocked, and\n-// fclose streams, with the side effect of flushing them so libc bufferred\n-// output will be printed.  Additionally the shell will generally print a more\n-// understandable error message like \"Abort trap\" rather than \"Illegal\n-// instruction\" that intrinsics::abort would cause, as intrinsics::abort is\n-// implemented as an illegal instruction.\n-#[cfg(unix)]\n-unsafe fn abort_internal() -> ! {\n-    ::libc::abort()\n-}\n-\n-// On Windows, use the processor-specific __fastfail mechanism.  In Windows 8\n-// and later, this will terminate the process immediately without running any\n-// in-process exception handlers.  In earlier versions of Windows, this\n-// sequence of instructions will be treated as an access violation,\n-// terminating the process but without necessarily bypassing all exception\n-// handlers.\n-//\n-// https://msdn.microsoft.com/en-us/library/dn774154.aspx\n-#[cfg(all(windows, any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-unsafe fn abort_internal() -> ! {\n-    asm!(\"int $$0x29\" :: \"{ecx}\"(7) ::: volatile); // 7 is FAST_FAIL_FATAL_APP_EXIT\n-    ::intrinsics::unreachable();\n-}\n-\n // Other platforms should use the appropriate platform-specific mechanism for\n // aborting the process.  If no platform-specific mechanism is available,\n // ::intrinsics::abort() may be used instead.  The above implementations cover\n // all targets currently supported by libstd.\n \n pub fn abort(args: fmt::Arguments) -> ! {\n     dumb_print(format_args!(\"fatal runtime error: {}\\n\", args));\n-    unsafe { abort_internal(); }\n+    unsafe { ::sys::abort_internal(); }\n }\n \n #[allow(dead_code)] // stack overflow detection not enabled on all platforms", "previous_filename": "src/libstd/sys/common/util.rs"}, {"sha": "0a94ff1e958236e6337d8700ab4bb9f36bfff905", "filename": "src/libstd/sys_common/wtf8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/libstd/sys/common/wtf8.rs"}, {"sha": "f74dd5924951c1f02daaa2d6835e91ac919bbcba", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 2, "deletions": 161, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -166,8 +166,8 @@ macro_rules! __thread_local_inner {\n         {\n             #[thread_local]\n             #[cfg(target_thread_local)]\n-            static __KEY: $crate::thread::__ElfLocalKeyInner<$t> =\n-                $crate::thread::__ElfLocalKeyInner::new();\n+            static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n+                $crate::thread::__FastLocalKeyInner::new();\n \n             #[cfg(not(target_thread_local))]\n             static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n@@ -310,165 +310,6 @@ impl<T: 'static> LocalKey<T> {\n     }\n }\n \n-#[cfg(target_thread_local)]\n-#[doc(hidden)]\n-pub mod elf {\n-    use cell::{Cell, UnsafeCell};\n-    use intrinsics;\n-    use ptr;\n-\n-    pub struct Key<T> {\n-        inner: UnsafeCell<Option<T>>,\n-\n-        // Metadata to keep track of the state of the destructor. Remember that\n-        // these variables are thread-local, not global.\n-        dtor_registered: Cell<bool>,\n-        dtor_running: Cell<bool>,\n-    }\n-\n-    unsafe impl<T> ::marker::Sync for Key<T> { }\n-\n-    impl<T> Key<T> {\n-        pub const fn new() -> Key<T> {\n-            Key {\n-                inner: UnsafeCell::new(None),\n-                dtor_registered: Cell::new(false),\n-                dtor_running: Cell::new(false)\n-            }\n-        }\n-\n-        pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n-            unsafe {\n-                if intrinsics::needs_drop::<T>() && self.dtor_running.get() {\n-                    return None\n-                }\n-                self.register_dtor();\n-            }\n-            Some(&self.inner)\n-        }\n-\n-        unsafe fn register_dtor(&self) {\n-            if !intrinsics::needs_drop::<T>() || self.dtor_registered.get() {\n-                return\n-            }\n-\n-            register_dtor(self as *const _ as *mut u8,\n-                          destroy_value::<T>);\n-            self.dtor_registered.set(true);\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"fuchsia\", target_os = \"redox\"))]\n-    unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        // The fallback implementation uses a vanilla OS-based TLS key to track\n-        // the list of destructors that need to be run for this thread. The key\n-        // then has its own destructor which runs all the other destructors.\n-        //\n-        // The destructor for DTORS is a little special in that it has a `while`\n-        // loop to continuously drain the list of registered destructors. It\n-        // *should* be the case that this loop always terminates because we\n-        // provide the guarantee that a TLS key cannot be set after it is\n-        // flagged for destruction.\n-        use sys_common::thread_local as os;\n-\n-        static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n-        type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n-        if DTORS.get().is_null() {\n-            let v: Box<List> = box Vec::new();\n-            DTORS.set(Box::into_raw(v) as *mut u8);\n-        }\n-        let list: &mut List = &mut *(DTORS.get() as *mut List);\n-        list.push((t, dtor));\n-\n-        unsafe extern fn run_dtors(mut ptr: *mut u8) {\n-            while !ptr.is_null() {\n-                let list: Box<List> = Box::from_raw(ptr as *mut List);\n-                for &(ptr, dtor) in list.iter() {\n-                    dtor(ptr);\n-                }\n-                ptr = DTORS.get();\n-                DTORS.set(ptr::null_mut());\n-            }\n-        }\n-    }\n-\n-    // Since what appears to be glibc 2.18 this symbol has been shipped which\n-    // GCC and clang both use to invoke destructors in thread_local globals, so\n-    // let's do the same!\n-    //\n-    // Note, however, that we run on lots older linuxes, as well as cross\n-    // compiling from a newer linux to an older linux, so we also have a\n-    // fallback implementation to use as well.\n-    //\n-    // Due to rust-lang/rust#18804, make sure this is not generic!\n-    #[cfg(target_os = \"linux\")]\n-    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        use mem;\n-        use libc;\n-\n-        extern {\n-            #[linkage = \"extern_weak\"]\n-            static __dso_handle: *mut u8;\n-            #[linkage = \"extern_weak\"]\n-            static __cxa_thread_atexit_impl: *const libc::c_void;\n-        }\n-        if !__cxa_thread_atexit_impl.is_null() {\n-            type F = unsafe extern fn(dtor: unsafe extern fn(*mut u8),\n-                                      arg: *mut u8,\n-                                      dso_handle: *mut u8) -> libc::c_int;\n-            mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)\n-            (dtor, t, &__dso_handle as *const _ as *mut _);\n-            return\n-        }\n-        register_dtor_fallback(t, dtor);\n-    }\n-\n-    // OSX's analog of the above linux function is this _tlv_atexit function.\n-    // The disassembly of thread_local globals in C++ (at least produced by\n-    // clang) will have this show up in the output.\n-    #[cfg(target_os = \"macos\")]\n-    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        extern {\n-            fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),\n-                           arg: *mut u8);\n-        }\n-        _tlv_atexit(dtor, t);\n-    }\n-\n-    // Just use the thread_local fallback implementation, at least until there's\n-    // a more direct implementation.\n-    #[cfg(any(target_os = \"fuchsia\", target_os = \"redox\"))]\n-    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        register_dtor_fallback(t, dtor);\n-    }\n-\n-    pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n-        let ptr = ptr as *mut Key<T>;\n-        // Right before we run the user destructor be sure to flag the\n-        // destructor as running for this thread so calls to `get` will return\n-        // `None`.\n-        (*ptr).dtor_running.set(true);\n-\n-        // The OSX implementation of TLS apparently had an odd aspect to it\n-        // where the pointer we have may be overwritten while this destructor\n-        // is running. Specifically if a TLS destructor re-accesses TLS it may\n-        // trigger a re-initialization of all TLS variables, paving over at\n-        // least some destroyed ones with initial values.\n-        //\n-        // This means that if we drop a TLS value in place on OSX that we could\n-        // revert the value to its original state halfway through the\n-        // destructor, which would be bad!\n-        //\n-        // Hence, we use `ptr::read` on OSX (to move to a \"safe\" location)\n-        // instead of drop_in_place.\n-        if cfg!(target_os = \"macos\") {\n-            ptr::read((*ptr).inner.get());\n-        } else {\n-            ptr::drop_in_place((*ptr).inner.get());\n-        }\n-    }\n-}\n-\n #[doc(hidden)]\n pub mod os {\n     use cell::{Cell, UnsafeCell};"}, {"sha": "255cd2a9bc0f19cf73af3676d50a2c6e40db1cb3", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -181,9 +181,18 @@ use time::Duration;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::local::{LocalKey, LocalKeyState};\n \n+// The types used by the thread_local! macro to access TLS keys. Note that there\n+// are two types, the \"OS\" type and the \"fast\" type. The OS thread local key\n+// type is accessed via platform-specific API calls and is slow, while the fast\n+// key type is accessed via code generated via LLVM, where TLS keys are set up\n+// by the elf linker. Note that the OS TLS type is always available: on macOS\n+// the standard library is compiled with support for older platform versions\n+// where fast TLS was not available; end-user code is compiled with fast TLS\n+// where available, but both are needed.\n+\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[cfg(target_thread_local)]\n-#[doc(hidden)] pub use self::local::elf::Key as __ElfLocalKeyInner;\n+#[doc(hidden)] pub use sys::fast_thread_local::Key as __FastLocalKeyInner;\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[doc(hidden)] pub use self::local::os::Key as __OsLocalKeyInner;\n "}, {"sha": "f077ead1f8e07b6d58e7f5616bb6d66a86a594d2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -161,12 +161,12 @@ impl Path {\n         Path {\n             span: s,\n             global: false,\n-            segments: vec!(\n+            segments: vec![\n                 PathSegment {\n                     identifier: identifier,\n                     parameters: PathParameters::none()\n                 }\n-            ),\n+            ],\n         }\n     }\n }"}, {"sha": "37bd83be7b4d4e0d8b1e71e91681b99b06f471b0", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -312,7 +312,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.path_all(span, false, strs, Vec::new(), Vec::new(), Vec::new())\n     }\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n-        self.path(span, vec!(id))\n+        self.path(span, vec![id])\n     }\n     fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n         self.path_all(span, true, strs, Vec::new(), Vec::new(), Vec::new())\n@@ -443,7 +443,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                           true,\n                           self.std_path(&[\"option\", \"Option\"]),\n                           Vec::new(),\n-                          vec!( ty ),\n+                          vec![ ty ],\n                           Vec::new()))\n     }\n \n@@ -477,7 +477,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn ty_vars_global(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> {\n         ty_params\n             .iter()\n-            .map(|p| self.ty_path(self.path_global(DUMMY_SP, vec!(p.ident))))\n+            .map(|p| self.ty_path(self.path_global(DUMMY_SP, vec![p.ident])))\n             .collect()\n     }\n \n@@ -770,7 +770,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let some = self.std_path(&[\"option\", \"Option\", \"Some\"]);\n-        self.expr_call_global(sp, some, vec!(expr))\n+        self.expr_call_global(sp, some, vec![expr])\n     }\n \n     fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n@@ -794,14 +794,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let expr_file = self.expr_str(span,\n                                       token::intern_and_get_ident(&loc.file.name));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n-        let expr_file_line_tuple = self.expr_tuple(span, vec!(expr_file, expr_line));\n+        let expr_file_line_tuple = self.expr_tuple(span, vec![expr_file, expr_line]);\n         let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);\n         self.expr_call_global(\n             span,\n             self.std_path(&[\"rt\", \"begin_panic\"]),\n-            vec!(\n+            vec![\n                 self.expr_str(span, msg),\n-                expr_file_line_ptr))\n+                expr_file_line_ptr])\n     }\n \n     fn expr_unreachable(&self, span: Span) -> P<ast::Expr> {\n@@ -812,12 +812,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = self.std_path(&[\"result\", \"Result\", \"Ok\"]);\n-        self.expr_call_global(sp, ok, vec!(expr))\n+        self.expr_call_global(sp, ok, vec![expr])\n     }\n \n     fn expr_err(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let err = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n-        self.expr_call_global(sp, err, vec!(expr))\n+        self.expr_call_global(sp, err, vec![expr])\n     }\n \n     fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> {\n@@ -836,17 +836,17 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         // Err(__try_var)  (pattern and expression resp.)\n         let err_pat = self.pat_tuple_struct(sp, err_path.clone(), vec![binding_pat]);\n         let err_inner_expr = self.expr_call(sp, self.expr_path(err_path),\n-                                            vec!(binding_expr.clone()));\n+                                            vec![binding_expr.clone()]);\n         // return Err(__try_var)\n         let err_expr = self.expr(sp, ast::ExprKind::Ret(Some(err_inner_expr)));\n \n         // Ok(__try_var) => __try_var\n-        let ok_arm = self.arm(sp, vec!(ok_pat), binding_expr);\n+        let ok_arm = self.arm(sp, vec![ok_pat], binding_expr);\n         // Err(__try_var) => return Err(__try_var)\n-        let err_arm = self.arm(sp, vec!(err_pat), err_expr);\n+        let err_arm = self.arm(sp, vec![err_pat], err_expr);\n \n         // match head { Ok() => ..., Err() => ... }\n-        self.expr_match(sp, head, vec!(ok_arm, err_arm))\n+        self.expr_match(sp, head, vec![ok_arm, err_arm])\n     }\n \n \n@@ -912,15 +912,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn arm(&self, _span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n-            attrs: vec!(),\n+            attrs: vec![],\n             pats: pats,\n             guard: None,\n             body: expr\n         }\n     }\n \n     fn arm_unreachable(&self, span: Span) -> ast::Arm {\n-        self.arm(span, vec!(self.pat_wild(span)), self.expr_unreachable(span))\n+        self.arm(span, vec![self.pat_wild(span)], self.expr_unreachable(span))\n     }\n \n     fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {\n@@ -970,7 +970,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn lambda1(&self, span: Span, blk: P<ast::Block>, ident: ast::Ident) -> P<ast::Expr> {\n-        self.lambda(span, vec!(ident), blk)\n+        self.lambda(span, vec![ident], blk)\n     }\n \n     fn lambda_expr(&self, span: Span, ids: Vec<ast::Ident>,"}, {"sha": "f21360755bc2603745d66ecbfc0d793f316ce3be", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -46,7 +46,7 @@ pub mod rt {\n \n     impl ToTokens for TokenTree {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec!(self.clone())\n+            vec![self.clone()]\n         }\n     }\n \n@@ -416,47 +416,47 @@ pub fn expand_quote_expr<'cx>(cx: &'cx mut ExtCtxt,\n                               sp: Span,\n                               tts: &[TokenTree])\n                               -> Box<base::MacResult+'cx> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_expr_panic\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_expr_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_item<'cx>(cx: &'cx mut ExtCtxt,\n                               sp: Span,\n                               tts: &[TokenTree])\n                               -> Box<base::MacResult+'cx> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_item_panic\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_item_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_pat<'cx>(cx: &'cx mut ExtCtxt,\n                              sp: Span,\n                              tts: &[TokenTree])\n                              -> Box<base::MacResult+'cx> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_pat_panic\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_pat_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_arm(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n                         -> Box<base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_arm_panic\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_arm_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        sp: Span,\n                        tts: &[TokenTree])\n                        -> Box<base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_ty_panic\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_ty_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[TokenTree])\n                          -> Box<base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_stmt_panic\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_stmt_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n@@ -465,7 +465,7 @@ pub fn expand_quote_attr(cx: &mut ExtCtxt,\n                          tts: &[TokenTree])\n                          -> Box<base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_attribute_panic\",\n-                                    vec!(cx.expr_bool(sp, true)), tts);\n+                                    vec![cx.expr_bool(sp, true)], tts);\n \n     base::MacEager::expr(expanded)\n }\n@@ -474,23 +474,23 @@ pub fn expand_quote_arg(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n                         -> Box<base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_arg_panic\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_arg_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_block(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n                         -> Box<base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_block_panic\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_block_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_meta_item(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n                         -> Box<base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_meta_item_panic\", vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_meta_item_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n@@ -499,7 +499,7 @@ pub fn expand_quote_path(cx: &mut ExtCtxt,\n                         tts: &[TokenTree])\n                         -> Box<base::MacResult+'static> {\n     let mode = mk_parser_path(cx, sp, &[\"PathStyle\", \"Type\"]);\n-    let expanded = expand_parse_call(cx, sp, \"parse_path_panic\", vec!(mode), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_path_panic\", vec![mode], tts);\n     base::MacEager::expr(expanded)\n }\n \n@@ -531,7 +531,7 @@ fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),\n-                        vec!(e_str))\n+                        vec![e_str])\n }\n \n // Lift a name to the expr that evaluates to that name\n@@ -540,16 +540,16 @@ fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"name_of\"),\n-                        vec!(e_str))\n+                        vec![e_str])\n }\n \n fn mk_tt_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n-    let idents = vec!(id_ext(\"syntax\"), id_ext(\"tokenstream\"), id_ext(\"TokenTree\"), id_ext(name));\n+    let idents = vec![id_ext(\"syntax\"), id_ext(\"tokenstream\"), id_ext(\"TokenTree\"), id_ext(name)];\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n-    let idents = vec!(id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"token\"), id_ext(name));\n+    let idents = vec![id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"token\"), id_ext(name)];\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n@@ -599,11 +599,11 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n     }\n     match *tok {\n         token::BinOp(binop) => {\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"BinOp\"), vec!(mk_binop(cx, sp, binop)));\n+            return cx.expr_call(sp, mk_token_path(cx, sp, \"BinOp\"), vec![mk_binop(cx, sp, binop)]);\n         }\n         token::BinOpEq(binop) => {\n             return cx.expr_call(sp, mk_token_path(cx, sp, \"BinOpEq\"),\n-                                vec!(mk_binop(cx, sp, binop)));\n+                                vec![mk_binop(cx, sp, binop)]);\n         }\n \n         token::OpenDelim(delim) => {\n@@ -653,13 +653,13 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::Lifetime(ident) => {\n             return cx.expr_call(sp,\n                                 mk_token_path(cx, sp, \"Lifetime\"),\n-                                vec!(mk_ident(cx, sp, ident)));\n+                                vec![mk_ident(cx, sp, ident)]);\n         }\n \n         token::DocComment(ident) => {\n             return cx.expr_call(sp,\n                                 mk_token_path(cx, sp, \"DocComment\"),\n-                                vec!(mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident))));\n+                                vec![mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident))]);\n         }\n \n         token::MatchNt(name, kind) => {\n@@ -714,17 +714,17 @@ fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, matcher: bool) -> Vec<ast::Stm\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, ident),\n                                     id_ext(\"to_tokens\"),\n-                                    vec!(cx.expr_ident(sp, id_ext(\"ext_cx\"))));\n+                                    vec![cx.expr_ident(sp, id_ext(\"ext_cx\"))]);\n             let e_to_toks =\n                 cx.expr_method_call(sp, e_to_toks, id_ext(\"into_iter\"), vec![]);\n \n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),\n                                     id_ext(\"extend\"),\n-                                    vec!(e_to_toks));\n+                                    vec![e_to_toks]);\n \n-            vec!(cx.stmt_expr(e_push))\n+            vec![cx.stmt_expr(e_push)]\n         }\n         ref tt @ TokenTree::Token(_, MatchNt(..)) if !matcher => {\n             let mut seq = vec![];\n@@ -737,13 +737,13 @@ fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, matcher: bool) -> Vec<ast::Stm\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n             let e_tok = cx.expr_call(sp,\n                                      mk_tt_path(cx, sp, \"Token\"),\n-                                     vec!(e_sp, expr_mk_token(cx, sp, tok)));\n+                                     vec![e_sp, expr_mk_token(cx, sp, tok)]);\n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),\n                                     id_ext(\"push\"),\n-                                    vec!(e_tok));\n-            vec!(cx.stmt_expr(e_push))\n+                                    vec![e_tok]);\n+            vec![cx.stmt_expr(e_push)]\n         },\n         TokenTree::Delimited(_, ref delimed) => {\n             statements_mk_tt(cx, &delimed.open_tt(), matcher).into_iter()\n@@ -796,13 +796,13 @@ fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, matcher: bool) -> Vec<ast::Stm\n                                                    vec![e_seq_struct]);\n             let e_tok = cx.expr_call(sp,\n                                      mk_tt_path(cx, sp, \"Sequence\"),\n-                                     vec!(e_sp, e_rc_new));\n+                                     vec![e_sp, e_rc_new]);\n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),\n                                     id_ext(\"push\"),\n-                                    vec!(e_tok));\n-            vec!(cx.stmt_expr(e_push))\n+                                    vec![e_tok]);\n+            vec![cx.stmt_expr(e_push)]\n         }\n     }\n }\n@@ -867,7 +867,7 @@ fn mk_stmts_let(cx: &ExtCtxt, sp: Span) -> Vec<ast::Stmt> {\n \n     let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n \n-    vec!(stmt_let_sp, stmt_let_tt)\n+    vec![stmt_let_sp, stmt_let_tt]\n }\n \n fn statements_mk_tts(cx: &ExtCtxt, tts: &[TokenTree], matcher: bool) -> Vec<ast::Stmt> {\n@@ -923,7 +923,7 @@ fn expand_parse_call(cx: &ExtCtxt,\n     let new_parser_call =\n         cx.expr_call(sp,\n                      cx.expr_ident(sp, id_ext(\"new_parser_from_tts\")),\n-                     vec!(parse_sess_call(), tts_expr));\n+                     vec![parse_sess_call(), tts_expr]);\n \n     let path = vec![id_ext(\"syntax\"), id_ext(\"ext\"), id_ext(\"quote\"), id_ext(parse_method)];\n     let mut args = vec![cx.expr_mut_addr_of(sp, new_parser_call)];"}, {"sha": "12408c7d3c95bdcb063132cb131a860607880c6b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -624,12 +624,12 @@ mod tests {\n                     node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 1),\n                         global: false,\n-                        segments: vec!(\n+                        segments: vec![\n                             ast::PathSegment {\n                                 identifier: str_to_ident(\"a\"),\n                                 parameters: ast::PathParameters::none(),\n                             }\n-                        ),\n+                        ],\n                     }),\n                     span: sp(0, 1),\n                     attrs: ThinVec::new(),\n@@ -643,7 +643,7 @@ mod tests {\n                     node: ast::ExprKind::Path(None, ast::Path {\n                             span: sp(0, 6),\n                             global: true,\n-                            segments: vec!(\n+                            segments: vec![\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"a\"),\n                                     parameters: ast::PathParameters::none(),\n@@ -652,7 +652,7 @@ mod tests {\n                                     identifier: str_to_ident(\"b\"),\n                                     parameters: ast::PathParameters::none(),\n                                 }\n-                            )\n+                            ]\n                         }),\n                     span: sp(0, 6),\n                     attrs: ThinVec::new(),\n@@ -763,12 +763,12 @@ mod tests {\n                         node:ast::ExprKind::Path(None, ast::Path{\n                             span: sp(7, 8),\n                             global: false,\n-                            segments: vec!(\n+                            segments: vec![\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"d\"),\n                                     parameters: ast::PathParameters::none(),\n                                 }\n-                            ),\n+                            ],\n                         }),\n                         span:sp(7,8),\n                         attrs: ThinVec::new(),\n@@ -786,12 +786,12 @@ mod tests {\n                            node: ast::ExprKind::Path(None, ast::Path {\n                                span:sp(0,1),\n                                global:false,\n-                               segments: vec!(\n+                               segments: vec![\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n                                     parameters: ast::PathParameters::none(),\n                                 }\n-                               ),\n+                               ],\n                             }),\n                            span: sp(0,1),\n                            attrs: ThinVec::new()})),\n@@ -828,18 +828,18 @@ mod tests {\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n                             node: ast::ItemKind::Fn(P(ast::FnDecl {\n-                                inputs: vec!(ast::Arg{\n+                                inputs: vec![ast::Arg{\n                                     ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                   node: ast::TyKind::Path(None, ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        segments: vec!(\n+                                        segments: vec![\n                                             ast::PathSegment {\n                                                 identifier:\n                                                     str_to_ident(\"i32\"),\n                                                 parameters: ast::PathParameters::none(),\n                                             }\n-                                        ),\n+                                        ],\n                                         }),\n                                         span:sp(10,13)\n                                     }),\n@@ -855,7 +855,7 @@ mod tests {\n                                             span: sp(6,7)\n                                     }),\n                                         id: ast::DUMMY_NODE_ID\n-                                    }),\n+                                    }],\n                                 output: ast::FunctionRetTy::Default(sp(15, 15)),\n                                 variadic: false\n                             }),\n@@ -875,27 +875,27 @@ mod tests {\n                                         span: syntax_pos::DUMMY_SP,\n                                     },\n                                     P(ast::Block {\n-                                        stmts: vec!(ast::Stmt {\n+                                        stmts: vec![ast::Stmt {\n                                             node: ast::StmtKind::Semi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ExprKind::Path(None,\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,\n-                                                        segments: vec!(\n+                                                        segments: vec![\n                                                             ast::PathSegment {\n                                                                 identifier:\n                                                                 str_to_ident(\n                                                                     \"b\"),\n                                                                 parameters:\n                                                                 ast::PathParameters::none(),\n                                                             }\n-                                                        ),\n+                                                        ],\n                                                       }),\n                                                 span: sp(17,18),\n                                                 attrs: ThinVec::new()})),\n                                             id: ast::DUMMY_NODE_ID,\n-                                            span: sp(17,19)}),\n+                                            span: sp(17,19)}],\n                                         id: ast::DUMMY_NODE_ID,\n                                         rules: ast::BlockCheckMode::Default, // no idea\n                                         span: sp(15,21),"}, {"sha": "b80aa667be6a190064f4b2aa3c2a8bda4b97fa59", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -848,7 +848,7 @@ impl<'a> Parser<'a> {\n               Fe: FnMut(DiagnosticBuilder)\n     {\n         let mut first: bool = true;\n-        let mut v = vec!();\n+        let mut v = vec![];\n         while !kets.contains(&&self.token) {\n             match sep.sep {\n                 Some(ref t) => {\n@@ -2224,13 +2224,13 @@ impl<'a> Parser<'a> {\n                             SeqSep::trailing_allowed(token::Comma),\n                             |p| Ok(p.parse_expr()?)\n                         )?;\n-                        let mut exprs = vec!(first_expr);\n+                        let mut exprs = vec![first_expr];\n                         exprs.extend(remaining_exprs);\n                         ex = ExprKind::Vec(exprs);\n                     } else {\n                         // Vector with one element.\n                         self.expect(&token::CloseDelim(token::Bracket))?;\n-                        ex = ExprKind::Vec(vec!(first_expr));\n+                        ex = ExprKind::Vec(vec![first_expr]);\n                     }\n                 }\n                 hi = self.prev_span.hi;\n@@ -4224,7 +4224,7 @@ impl<'a> Parser<'a> {\n                              mode: BoundParsingMode)\n                              -> PResult<'a, TyParamBounds>\n     {\n-        let mut result = vec!();\n+        let mut result = vec![];\n         loop {\n             let question_span = self.span;\n             let ate_question = self.eat(&token::Question);"}, {"sha": "b0bd64467430098bfd1b6497b1374e39b2730094", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -2277,7 +2277,7 @@ impl<'a> State<'a> {\n                     Ok(())\n                 }));\n \n-                let mut options = vec!();\n+                let mut options = vec![];\n                 if a.volatile {\n                     options.push(\"volatile\");\n                 }"}, {"sha": "618878c1f7980c9fe829534c1af3889888df546e", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -430,7 +430,7 @@ fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n     let (vi, vis, ident) = if cx.is_test_crate {\n         (ast::ItemKind::Use(\n             P(nospan(ast::ViewPathSimple(id_test,\n-                                         path_node(vec!(id_test)))))),\n+                                         path_node(vec![id_test]))))),\n          ast::Visibility::Public, keywords::Invalid.ident())\n     } else {\n         (ast::ItemKind::ExternCrate(None), ast::Visibility::Inherited, id_test)"}, {"sha": "9be7dbd68174edf8cece539df886b435f1c52146", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -105,7 +105,7 @@ impl<T> SmallVector<T> {\n             One(..) => {\n                 let one = mem::replace(&mut self.repr, Zero);\n                 match one {\n-                    One(v1) => mem::replace(&mut self.repr, Many(vec!(v1, v))),\n+                    One(v1) => mem::replace(&mut self.repr, Many(vec![v1, v])),\n                     _ => unreachable!()\n                 };\n             }\n@@ -314,12 +314,12 @@ mod tests {\n     #[test]\n     #[should_panic]\n     fn test_expect_one_many() {\n-        SmallVector::many(vec!(1, 2)).expect_one(\"\");\n+        SmallVector::many(vec![1, 2]).expect_one(\"\");\n     }\n \n     #[test]\n     fn test_expect_one_one() {\n         assert_eq!(1, SmallVector::one(1).expect_one(\"\"));\n-        assert_eq!(1, SmallVector::many(vec!(1)).expect_one(\"\"));\n+        assert_eq!(1, SmallVector::many(vec![1]).expect_one(\"\"));\n     }\n }"}, {"sha": "c46d4b34173f65fb48acefd057fc044264985ba5", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -65,12 +65,12 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n     macro_rules! md {\n         ($name:expr, $f:ident) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-            let attrs = vec!(cx.attribute(span, inline));\n+            let attrs = vec![cx.attribute(span, inline)];\n             MethodDef {\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(borrowed_self()),\n+                args: vec![borrowed_self()],\n                 ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 is_unsafe: false,"}, {"sha": "597ff306b3dd8edf4c7cb08d145cdd0a25f73be2", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -28,12 +28,12 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n     macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-            let attrs = vec!(cx.attribute(span, inline));\n+            let attrs = vec![cx.attribute(span, inline)];\n             MethodDef {\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(borrowed_self()),\n+                args: vec![borrowed_self()],\n                 ret_ty: Literal(path_local!(bool)),\n                 attributes: attrs,\n                 is_unsafe: false,"}, {"sha": "10db56d46f6dfcaf1091b965aa95cd0c0ede0c04", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -79,9 +79,9 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n                           ret_ty:\n                               Literal(Path::new_(pathvec_std!(cx, core::result::Result),\n                                                  None,\n-                                                 vec!(Box::new(Self_), Box::new(Literal(Path::new_(\n+                                                 vec![Box::new(Self_), Box::new(Literal(Path::new_(\n                         vec![typaram, \"Error\"], None, vec![], false\n-                    )))),\n+                    )))],\n                                                  true)),\n                           attributes: Vec::new(),\n                           is_unsafe: false,"}, {"sha": "640296d7f06fc866e22c7f7fd2612604bcfe492b", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -139,23 +139,23 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n-        methods: vec!(\n+        methods: vec![\n             MethodDef {\n                 name: \"encode\",\n                 generics: LifetimeBounds {\n                     lifetimes: Vec::new(),\n                     bounds: vec![(typaram,\n-                                  vec![Path::new_(vec![krate, \"Encoder\"], None, vec!(), true)])]\n+                                  vec![Path::new_(vec![krate, \"Encoder\"], None, vec![], true)])]\n                 },\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(Box::new(Literal(Path::new_local(typaram))),\n-                           Borrowed(None, Mutability::Mutable))),\n+                args: vec![Ptr(Box::new(Literal(Path::new_local(typaram))),\n+                           Borrowed(None, Mutability::Mutable))],\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, core::result::Result),\n                     None,\n-                    vec!(Box::new(Tuple(Vec::new())), Box::new(Literal(Path::new_(\n+                    vec![Box::new(Tuple(Vec::new())), Box::new(Literal(Path::new_(\n                         vec![typaram, \"Error\"], None, vec![], false\n-                    )))),\n+                    )))],\n                     true\n                 )),\n                 attributes: Vec::new(),\n@@ -165,7 +165,7 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n                     encodable_substructure(a, b, c, krate)\n                 })),\n             }\n-        ),\n+        ],\n         associated_types: Vec::new(),\n     };\n "}, {"sha": "e6b63be3efc0d963f063d7b665c56966f38bf8b3", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -1546,7 +1546,7 @@ impl<'a> TraitDef<'a> {\n                             cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n                         }\n                         codemap::Spanned {\n-                            span: pat.span,\n+                            span: Span { expn_id: self.span.expn_id, ..pat.span },\n                             node: ast::FieldPat {\n                                 ident: ident.unwrap(),\n                                 pat: pat,\n@@ -1577,7 +1577,8 @@ impl<'a> TraitDef<'a> {\n          mutbl: ast::Mutability)\n          -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n         let variant_ident = variant.node.name;\n-        let variant_path = cx.path(variant.span, vec![enum_ident, variant_ident]);\n+        let sp = Span { expn_id: self.span.expn_id, ..variant.span };\n+        let variant_path = cx.path(sp, vec![enum_ident, variant_ident]);\n         self.create_struct_pattern(cx, variant_path, &variant.node.data, prefix, mutbl)\n     }\n }"}, {"sha": "c2bfead568612b0eb34131b88d3f0d236868fe37", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -28,7 +28,7 @@ macro_rules! pathvec {\n \n macro_rules! path {\n     ($($x:tt)*) => (\n-        ::ext::deriving::generic::ty::Path::new( pathvec!( $($x)* ) )\n+        ::ext::deriving::generic::ty::Path::new( pathvec![ $($x)* ] )\n     )\n }\n \n@@ -40,7 +40,7 @@ macro_rules! path_local {\n \n macro_rules! pathvec_std {\n     ($cx:expr, $first:ident :: $($rest:ident)::+) => ({\n-        let mut v = pathvec!($($rest)::+);\n+        let mut v = pathvec![$($rest)::+];\n         if let Some(s) = $cx.crate_root {\n             v.insert(0, s);\n         }"}, {"sha": "95ae6eb2efe8e5704d85e69b0fc6e9025c1d1271", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -336,7 +336,7 @@ pub type OptRes = Result<TestOpts, String>;\n \n #[cfg_attr(rustfmt, rustfmt_skip)]\n fn optgroups() -> Vec<getopts::OptGroup> {\n-    vec!(getopts::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n+    vec![getopts::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n       getopts::optflag(\"\", \"test\", \"Run tests and not benchmarks\"),\n       getopts::optflag(\"\", \"bench\", \"Run benchmarks instead of tests\"),\n       getopts::optflag(\"h\", \"help\", \"Display this message (longer with --help)\"),\n@@ -352,7 +352,7 @@ fn optgroups() -> Vec<getopts::OptGroup> {\n       getopts::optopt(\"\", \"color\", \"Configure coloring of output:\n             auto   = colorize if stdout is a tty and tests are run on serially (default);\n             always = always colorize output;\n-            never  = never colorize output;\", \"auto|always|never\"))\n+            never  = never colorize output;\", \"auto|always|never\")]\n }\n \n fn usage(binary: &str) {"}, {"sha": "5792ba06eb0ce3d0c0ac18869c51ec4a943734f1", "filename": "src/test/compile-fail/E0297.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2FE0297.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2FE0297.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0297.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let xs : Vec<Option<i32>> = vec!(Some(1), None);\n+    let xs : Vec<Option<i32>> = vec![Some(1), None];\n \n     for Some(x) in xs {}\n     //~^ ERROR E0297"}, {"sha": "324e9259647792ab335bf654bcecb7f803f13d39", "filename": "src/test/compile-fail/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     // Testing that method lookup does not automatically borrow\n     // vectors to slices then automatically create a self reference.\n \n-    let mut a = vec!(0);\n+    let mut a = vec![0];\n     a.test_mut(); //~ ERROR no method named `test_mut` found\n     a.test(); //~ ERROR no method named `test` found\n "}, {"sha": "1e665a12a195b14df42dd3a8cfc30af166dc4e92", "filename": "src/test/compile-fail/borrowck/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-comp-idx.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -14,7 +14,7 @@ struct Point {\n }\n \n fn a() {\n-    let mut p = vec!(1);\n+    let mut p = vec![1];\n \n     // Create an immutable pointer into p's contents:\n     let q: &isize = &p[0];\n@@ -30,7 +30,7 @@ fn b() {\n     // here we alias the mutable vector into an imm slice and try to\n     // modify the original:\n \n-    let mut p = vec!(1);\n+    let mut p = vec![1];\n \n     borrow(\n         &p,\n@@ -40,7 +40,7 @@ fn b() {\n fn c() {\n     // Legal because the scope of the borrow does not include the\n     // modification:\n-    let mut p = vec!(1);\n+    let mut p = vec![1];\n     borrow(&p, ||{});\n     p[0] = 5;\n }"}, {"sha": "9178aadeeebe11d9628928465ac0a93d0b8ba1e9", "filename": "src/test/compile-fail/borrowck/borrowck-borrowed-uniq-rvalue-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue-2.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -29,6 +29,6 @@ fn defer<'r>(x: &'r [&'r str]) -> defer<'r> {\n }\n \n fn main() {\n-    let x = defer(&vec!(\"Goodbye\", \"world!\"));\n+    let x = defer(&vec![\"Goodbye\", \"world!\"]);\n     x.x[0];\n }"}, {"sha": "c5de95f8fc04270320749bb7889aef09885960c3", "filename": "src/test/compile-fail/borrowck/borrowck-loan-vec-content.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-loan-vec-content.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -17,12 +17,12 @@ fn takes_imm_elt<F>(_v: &isize, f: F) where F: FnOnce() {\n }\n \n fn has_mut_vec_and_does_not_try_to_change_it() {\n-    let mut v: Vec<isize> = vec!(1, 2, 3);\n+    let mut v: Vec<isize> = vec![1, 2, 3];\n     takes_imm_elt(&v[0], || {})\n }\n \n fn has_mut_vec_but_tries_to_change_it() {\n-    let mut v: Vec<isize> = vec!(1, 2, 3);\n+    let mut v: Vec<isize> = vec![1, 2, 3];\n     takes_imm_elt(\n         &v[0],\n         || { //~ ERROR cannot borrow `v` as mutable"}, {"sha": "bf4c74741368c458f4d25ce54bea0ebb6c7b0e9c", "filename": "src/test/compile-fail/borrowck/borrowck-move-out-of-overloaded-auto-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-overloaded-auto-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-overloaded-auto-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-overloaded-auto-deref.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -11,6 +11,6 @@\n use std::rc::Rc;\n \n pub fn main() {\n-    let _x = Rc::new(vec!(1, 2)).into_iter();\n+    let _x = Rc::new(vec![1, 2]).into_iter();\n     //~^ ERROR cannot move out of borrowed content\n }"}, {"sha": "311208f07b88de8904d215c7a09f6cbee92d07ae", "filename": "src/test/compile-fail/borrowck/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -18,11 +18,11 @@ struct Foo {\n }\n \n pub fn main() {\n-    let x = vec!(\n+    let x = vec![\n         Foo { string: \"foo\".to_string() },\n         Foo { string: \"bar\".to_string() },\n         Foo { string: \"baz\".to_string() }\n-    );\n+    ];\n     let x: &[Foo] = &x;\n     match *x {\n         [_, ref tail..] => {"}, {"sha": "4e0304e20c00d576d9a489145b6e3f448a57501d", "filename": "src/test/compile-fail/borrowck/borrowck-mut-slice-of-imm-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-slice-of-imm-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-slice-of-imm-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-slice-of-imm-vec.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -13,6 +13,6 @@ fn write(v: &mut [isize]) {\n }\n \n fn main() {\n-    let v = vec!(1, 2, 3);\n+    let v = vec![1, 2, 3];\n     write(&mut v); //~ ERROR cannot borrow\n }"}, {"sha": "df72c2b0af72a7396c10fe5b77be11402730748c", "filename": "src/test/compile-fail/borrowck/borrowck-overloaded-index-move-from-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-move-from-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-move-from-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-move-from-vec.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -25,7 +25,7 @@ impl<T> Index<usize> for MyVec<T> {\n }\n \n fn main() {\n-    let v = MyVec::<Box<_>> { data: vec!(box 1, box 2, box 3) };\n+    let v = MyVec::<Box<_>> { data: vec![box 1, box 2, box 3] };\n     let good = &v[0]; // Shouldn't fail here\n     let bad = v[0];\n     //~^ ERROR cannot move out of indexed content"}, {"sha": "eb5d69d49bd6aad72ef826606ed5bda7327f2972", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -12,7 +12,7 @@\n #![feature(slice_patterns)]\n \n fn a<'a>() -> &'a [isize] {\n-    let vec = vec!(1, 2, 3, 4);\n+    let vec = vec![1, 2, 3, 4];\n     let vec: &[isize] = &vec; //~ ERROR does not live long enough\n     let tail = match vec {\n         &[_, ref tail..] => tail,\n@@ -22,7 +22,7 @@ fn a<'a>() -> &'a [isize] {\n }\n \n fn b<'a>() -> &'a [isize] {\n-    let vec = vec!(1, 2, 3, 4);\n+    let vec = vec![1, 2, 3, 4];\n     let vec: &[isize] = &vec; //~ ERROR does not live long enough\n     let init = match vec {\n         &[ref init.., _] => init,\n@@ -32,7 +32,7 @@ fn b<'a>() -> &'a [isize] {\n }\n \n fn c<'a>() -> &'a [isize] {\n-    let vec = vec!(1, 2, 3, 4);\n+    let vec = vec![1, 2, 3, 4];\n     let vec: &[isize] = &vec; //~ ERROR does not live long enough\n     let slice = match vec {\n         &[_, ref slice.., _] => slice,"}, {"sha": "505c8c6d535819443ad27588983c69e9d58db425", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-loan-from-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -11,7 +11,7 @@\n #![feature(slice_patterns)]\n \n fn a() {\n-    let mut v = vec!(1, 2, 3);\n+    let mut v = vec![1, 2, 3];\n     let vb: &mut [isize] = &mut v;\n     match vb {\n         &mut [_a, ref tail..] => {"}, {"sha": "d26364efdbc5d153bdb7d0455b62e2b2dbb5093b", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -25,7 +25,7 @@ fn a() {\n }\n \n fn b() {\n-    let mut vec = vec!(box 1, box 2, box 3);\n+    let mut vec = vec![box 1, box 2, box 3];\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n         &mut [ref _b..] => {\n@@ -37,7 +37,7 @@ fn b() {\n }\n \n fn c() {\n-    let mut vec = vec!(box 1, box 2, box 3);\n+    let mut vec = vec![box 1, box 2, box 3];\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n         &mut [_a, //~ ERROR cannot move out\n@@ -59,7 +59,7 @@ fn c() {\n }\n \n fn d() {\n-    let mut vec = vec!(box 1, box 2, box 3);\n+    let mut vec = vec![box 1, box 2, box 3];\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n         &mut [ //~ ERROR cannot move out\n@@ -73,7 +73,7 @@ fn d() {\n }\n \n fn e() {\n-    let mut vec = vec!(box 1, box 2, box 3);\n+    let mut vec = vec![box 1, box 2, box 3];\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n         &mut [_a, _b, _c] => {}  //~ ERROR cannot move out"}, {"sha": "cd8f3ebefe6287272c014f000a3f0208fa32c5b7", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -11,7 +11,7 @@\n #![feature(slice_patterns)]\n \n fn a<'a>() -> &'a isize {\n-    let vec = vec!(1, 2, 3, 4);\n+    let vec = vec![1, 2, 3, 4];\n     let vec: &[isize] = &vec; //~ ERROR `vec` does not live long enough\n     let tail = match vec {\n         &[_a, ref tail..] => &tail[0],"}, {"sha": "33e4d3e62c418aa6b3eb90138b0c2849c43c00ee", "filename": "src/test/compile-fail/drop-with-active-borrows-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fdrop-with-active-borrows-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fdrop-with-active-borrows-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdrop-with-active-borrows-2.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn read_lines_borrowed<'a>() -> Vec<&'a str> {\n-    let raw_lines: Vec<String> = vec!(\"foo  \".to_string(), \"  bar\".to_string());\n+    let raw_lines: Vec<String> = vec![\"foo  \".to_string(), \"  bar\".to_string()];\n     raw_lines.iter().map(|l| l.trim()).collect()\n     //~^ ERROR `raw_lines` does not live long enough\n }"}, {"sha": "c8f33c3caf8d393963716d57799b2b52258b9946", "filename": "src/test/compile-fail/integral-indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let v: Vec<isize> = vec!(0, 1, 2, 3, 4, 5);\n+    let v: Vec<isize> = vec![0, 1, 2, 3, 4, 5];\n     let s: String = \"abcdef\".to_string();\n     v[3_usize];\n     v[3];"}, {"sha": "4618851529a15b2aa8db1180e0ff783393bcc67e", "filename": "src/test/compile-fail/issue-11873.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fissue-11873.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fissue-11873.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11873.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let mut v = vec!(1);\n+    let mut v = vec![1];\n     let mut f = || v.push(2);\n     let _w = v; //~ ERROR: cannot move out of `v`\n "}, {"sha": "6ad3ec67b29642bb251aef0cae43a3c216b2fe1f", "filename": "src/test/compile-fail/issue-13446.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -13,6 +13,6 @@\n \n // error-pattern: mismatched types\n \n-static VEC: [u32; 256] = vec!();\n+static VEC: [u32; 256] = vec![];\n \n fn main() {}"}, {"sha": "c7b276da5737666cb6e49b2a4df3537252b96b59", "filename": "src/test/compile-fail/issue-3044.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -10,7 +10,7 @@\n \n \n fn main() {\n-    let needlesArr: Vec<char> = vec!('a', 'f');\n+    let needlesArr: Vec<char> = vec!['a', 'f'];\n     needlesArr.iter().fold(|x, y| {\n     });\n     //~^^ ERROR this function takes 2 parameters but 1 parameter was supplied"}, {"sha": "1c543a5fdacbba3deac22b7a66372fdb67fc4059", "filename": "src/test/compile-fail/issue-5067.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fissue-5067.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fissue-5067.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5067.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -48,7 +48,7 @@ macro_rules! make_vec {\n }\n \n fn main() {\n-    let _ = make_vec!(a 1, a 2, a 3);\n+    let _ = make_vec![a 1, a 2, a 3];\n }\n \n "}, {"sha": "21cfadb9c79925c96e9ddeb278a0f3d90174a41a", "filename": "src/test/compile-fail/lint-unused-mut-variables.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -21,7 +21,7 @@ fn main() {\n     let mut a = 3; //~ ERROR: variable does not need to be mutable\n     let mut a = 2; //~ ERROR: variable does not need to be mutable\n     let mut b = 3; //~ ERROR: variable does not need to be mutable\n-    let mut a = vec!(3); //~ ERROR: variable does not need to be mutable\n+    let mut a = vec![3]; //~ ERROR: variable does not need to be mutable\n     let (mut a, b) = (1, 2); //~ ERROR: variable does not need to be mutable\n     let mut a; //~ ERROR: variable does not need to be mutable\n     a = 3;\n@@ -88,5 +88,5 @@ fn callback<F>(f: F) where F: FnOnce() {}\n #[allow(unused_mut)]\n fn foo(mut a: isize) {\n     let mut a = 3;\n-    let mut b = vec!(2);\n+    let mut b = vec![2];\n }"}, {"sha": "4d9b3aea1124bbb2c84c22408c7c7e1d6d20d80a", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -29,7 +29,7 @@ fn main() {\n         _ => { }\n     }\n \n-    let x: Vec<char> = vec!('a', 'b', 'c');\n+    let x: Vec<char> = vec!['a', 'b', 'c'];\n     let x: &[char] = &x;\n     match *x {\n         ['a', 'b', 'c', ref _tail..] => {}"}, {"sha": "63fb4ff02a4ea6d3740f250ea016b848920b5f24", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -16,7 +16,7 @@ fn consume(_s: String) {}\n fn touch<A>(_a: &A) {}\n \n fn f20() {\n-    let x = vec!(\"hi\".to_string());\n+    let x = vec![\"hi\".to_string()];\n     consume(x.into_iter().next().unwrap());\n     touch(&x[0]); //~ ERROR use of moved value: `x`\n }"}, {"sha": "194f278259b6b08e70b9f414ccc7283351284288", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -29,7 +29,7 @@ fn f20() {\n }\n \n fn f21() {\n-    let x = vec!(1, 2, 3);\n+    let x = vec![1, 2, 3];\n     let _y = (x[0], 3);\n     touch(&x);\n }\n@@ -77,24 +77,24 @@ fn f70() {\n \n fn f80() {\n     let x = \"hi\".to_string();\n-    let _y = vec!(x);\n+    let _y = vec![x];\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f100() {\n-    let x = vec!(\"hi\".to_string());\n+    let x = vec![\"hi\".to_string()];\n     let _y = x.into_iter().next().unwrap();\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f110() {\n-    let x = vec!(\"hi\".to_string());\n+    let x = vec![\"hi\".to_string()];\n     let _y = [x.into_iter().next().unwrap(); 1];\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n \n fn f120() {\n-    let mut x = vec!(\"hi\".to_string(), \"ho\".to_string());\n+    let mut x = vec![\"hi\".to_string(), \"ho\".to_string()];\n     x.swap(0, 1);\n     touch(&x[0]);\n     touch(&x[1]);"}, {"sha": "5e1d22bf63b89c2e62aa1759c51a3327bc6bf815", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -14,7 +14,7 @@ use std::sync::Arc;\n use std::thread;\n \n fn main() {\n-    let v = vec!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+    let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = Arc::new(v);\n \n     thread::spawn(move|| {"}, {"sha": "76c8a444320d3d3ddbd6a27c84154b9f34a62f97", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -12,7 +12,7 @@ use std::sync::Arc;\n use std::thread;\n \n fn main() {\n-    let v = vec!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+    let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = Arc::new(v);\n \n     thread::spawn(move|| {"}, {"sha": "6067b71280cefa69ca28477a119718ee24ab07eb", "filename": "src/test/compile-fail/non-copyable-void.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -11,7 +11,7 @@\n extern crate libc;\n \n fn main() {\n-    let x : *const Vec<isize> = &vec!(1,2,3);\n+    let x : *const Vec<isize> = &vec![1,2,3];\n     let y : *const libc::c_void = x as *const libc::c_void;\n     unsafe {\n         let _z = (*y).clone();"}, {"sha": "74e728d713b1d27e8aa00899b3aa981ad332615e", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -37,28 +37,28 @@ fn main() {\n       (_, t::a) => {}\n       (t::b, t::b) => {}\n     }\n-    let vec = vec!(Some(42), None, Some(21));\n+    let vec = vec![Some(42), None, Some(21)];\n     let vec: &[Option<isize>] = &vec;\n     match *vec { //~ ERROR non-exhaustive patterns: `[]` not covered\n         [Some(..), None, ref tail..] => {}\n         [Some(..), Some(..), ref tail..] => {}\n         [None] => {}\n     }\n-    let vec = vec!(1);\n+    let vec = vec![1];\n     let vec: &[isize] = &vec;\n     match *vec {\n         [_, ref tail..] => (),\n         [] => ()\n     }\n-    let vec = vec!(0.5f32);\n+    let vec = vec![0.5f32];\n     let vec: &[f32] = &vec;\n     match *vec { //~ ERROR non-exhaustive patterns: `[_, _, _, _]` not covered\n         [0.1, 0.2, 0.3] => (),\n         [0.1, 0.2] => (),\n         [0.1] => (),\n         [] => ()\n     }\n-    let vec = vec!(Some(42), None, Some(21));\n+    let vec = vec![Some(42), None, Some(21)];\n     let vec: &[Option<isize>] = &vec;\n     match *vec {\n         [Some(..), None, ref tail..] => {}"}, {"sha": "3a789f3faeb2ab2611fe4f510bef5ce303c9409e", "filename": "src/test/compile-fail/on-unimplemented/on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -30,7 +30,7 @@ fn collect<A, I: Iterator<Item=A>, B: MyFromIterator<A>>(it: I) -> B {\n }\n \n pub fn main() {\n-    let x = vec!(1u8, 2, 3, 4);\n+    let x = vec![1u8, 2, 3, 4];\n     let y: Option<Vec<u8>> = collect(x.iter()); // this should give approximately the same error for x.iter().collect()\n     //~^ ERROR\n     //~^^ NOTE a collection of type `std::option::Option<std::vec::Vec<u8>>` cannot be built from an iterator over elements of type `&u8`"}, {"sha": "12b48b2a6c8aaa8462c293a4a41114a107924663", "filename": "src/test/compile-fail/unboxed-closures-failed-recursive-fn-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-2.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -16,7 +16,7 @@\n \n fn a() {\n     let mut closure0 = None;\n-    let vec = vec!(1, 2, 3);\n+    let vec = vec![1, 2, 3];\n \n     loop {\n         {"}, {"sha": "cd9f1636c3f4dbe9a065d7f36f8d6266014df6d3", "filename": "src/test/compile-fail/unboxed-closures-move-upvar-from-non-once-ref-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Funboxed-closures-move-upvar-from-non-once-ref-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Funboxed-closures-move-upvar-from-non-once-ref-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-move-upvar-from-non-once-ref-closure.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -16,7 +16,7 @@ fn call<F>(f: F) where F : Fn() {\n }\n \n fn main() {\n-    let y = vec!(format!(\"World\"));\n+    let y = vec![format!(\"World\")];\n     call(|| {\n         y.into_iter();\n         //~^ ERROR cannot move out of captured outer variable in an `Fn` closure"}, {"sha": "96f58666fdff33122f93e8951c5b06a888a6faa2", "filename": "src/test/compile-fail/vec-macro-with-comma-only.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fvec-macro-with-comma-only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fvec-macro-with-comma-only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-macro-with-comma-only.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub fn main() {\n-    vec!(,); //~ ERROR expected expression, found `,`\n+    vec![,]; //~ ERROR expected expression, found `,`\n }"}, {"sha": "571634e3992619074b1060170c4fc4a1d2c37025", "filename": "src/test/compile-fail/vec-mut-iter-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let mut xs: Vec<isize> = vec!();\n+    let mut xs: Vec<isize> = vec![];\n \n     for x in &mut xs {\n         xs.push(1) //~ ERROR cannot borrow `xs`"}, {"sha": "27f6fc51164ad2b6833f504ce801ccca5ccafa40", "filename": "src/test/compile-fail/vec-res-add.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -21,8 +21,8 @@ impl Drop for r {\n \n fn main() {\n     // This can't make sense as it would copy the classes\n-    let i = vec!(r(0));\n-    let j = vec!(r(1));\n+    let i = vec![r(0)];\n+    let j = vec![r(1)];\n     let k = i + j;\n     //~^ ERROR binary operation `+` cannot be applied to type\n     println!(\"{:?}\", j);"}, {"sha": "f289b85992ee80b34ac847c005aea2dd67432962", "filename": "src/test/compile-fail/writing-to-immutable-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -10,6 +10,6 @@\n \n \n fn main() {\n-    let v: Vec<isize> = vec!(1, 2, 3);\n+    let v: Vec<isize> = vec![1, 2, 3];\n     v[1] = 4; //~ ERROR cannot borrow immutable local variable `v` as mutable\n }"}, {"sha": "d334e33f887b8e17dbcb3baee48749246dbfa120", "filename": "src/test/debuginfo/issue14411.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fdebuginfo%2Fissue14411.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fdebuginfo%2Fissue14411.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue14411.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -20,6 +20,6 @@ fn test(a: &Vec<u8>) {\n }\n \n pub fn main() {\n-  let data = vec!();\n+  let data = vec![];\n   test(&data);\n }"}, {"sha": "678bc10f1e56fbbde675611240e95c72b26f0bed", "filename": "src/test/incremental/change_private_fn/struct_point.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn%2Fstruct_point.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test where we change the body of a private method in an impl.\n+// We then test what sort of functions must be rebuilt as a result.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+#![allow(dead_code)]\n+\n+#![rustc_partition_translated(module=\"struct_point-point\", cfg=\"rpass2\")]\n+\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n+\n+mod point {\n+    pub struct Point {\n+        pub x: f32,\n+        pub y: f32,\n+    }\n+\n+    fn distance_squared(this: &Point) -> f32 {\n+        #[cfg(rpass1)]\n+        return this.x + this.y;\n+\n+        #[cfg(rpass2)]\n+        return this.x * this.x + this.y * this.y;\n+    }\n+\n+    impl Point {\n+        pub fn distance_from_origin(&self) -> f32 {\n+            distance_squared(self).sqrt()\n+        }\n+    }\n+\n+    impl Point {\n+        pub fn translate(&mut self, x: f32, y: f32) {\n+            self.x += x;\n+            self.y += y;\n+        }\n+    }\n+\n+}\n+\n+/// A fn item that calls (public) methods on `Point` from the same impl which changed\n+mod fn_calls_methods_in_same_impl {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let x = Point { x: 2.0, y: 2.0 };\n+        x.distance_from_origin();\n+    }\n+}\n+\n+/// A fn item that calls (public) methods on `Point` from another impl\n+mod fn_calls_methods_in_another_impl {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let mut x = Point { x: 2.0, y: 2.0 };\n+        x.translate(3.0, 3.0);\n+    }\n+}\n+\n+/// A fn item that makes an instance of `Point` but does not invoke methods\n+mod fn_make_struct {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn make_origin() -> Point {\n+        Point { x: 2.0, y: 2.0 }\n+    }\n+}\n+\n+/// A fn item that reads fields from `Point` but does not invoke methods\n+mod fn_read_field {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn get_x(p: Point) -> f32 {\n+        p.x\n+    }\n+}\n+\n+/// A fn item that writes to a field of `Point` but does not invoke methods\n+mod fn_write_field {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn inc_x(p: &mut Point) {\n+        p.x += 1.0;\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "dcc1ced635fbf8b6a08a7c03410ef7eff95f2867", "filename": "src/test/incremental/change_private_fn_cc/auxiliary/point.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fauxiliary%2Fpoint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fauxiliary%2Fpoint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fauxiliary%2Fpoint.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Point {\n+    pub x: f32,\n+    pub y: f32,\n+}\n+\n+fn distance_squared(this: &Point) -> f32 {\n+    #[cfg(rpass1)]\n+    return this.x + this.y;\n+\n+    #[cfg(rpass2)]\n+    return this.x * this.x + this.y * this.y;\n+}\n+\n+impl Point {\n+    pub fn distance_from_origin(&self) -> f32 {\n+        distance_squared(self).sqrt()\n+    }\n+}\n+\n+impl Point {\n+    pub fn translate(&mut self, x: f32, y: f32) {\n+        self.x += x;\n+        self.y += y;\n+    }\n+}"}, {"sha": "d6d2b5436ff30afeb98845c611e1841a6c68454e", "filename": "src/test/incremental/change_private_fn_cc/struct_point.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,86 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test where we change the body of a private method in an impl.\n+// We then test what sort of functions must be rebuilt as a result.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+// aux-build:point.rs\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+#![allow(dead_code)]\n+\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n+\n+// FIXME(#37335) -- should be reused, but an errant Krate edge causes\n+// it to get translated (at least I *think* this is that same problem)\n+#![rustc_partition_translated(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n+\n+extern crate point;\n+\n+/// A fn item that calls (public) methods on `Point` from the same impl which changed\n+mod fn_calls_methods_in_same_impl {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let x = Point { x: 2.0, y: 2.0 };\n+        x.distance_from_origin();\n+    }\n+}\n+\n+/// A fn item that calls (public) methods on `Point` from another impl\n+mod fn_calls_methods_in_another_impl {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let mut x = Point { x: 2.0, y: 2.0 };\n+        x.translate(3.0, 3.0);\n+    }\n+}\n+\n+/// A fn item that makes an instance of `Point` but does not invoke methods\n+mod fn_make_struct {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn make_origin() -> Point {\n+        Point { x: 2.0, y: 2.0 }\n+    }\n+}\n+\n+/// A fn item that reads fields from `Point` but does not invoke methods\n+mod fn_read_field {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn get_x(p: Point) -> f32 {\n+        p.x\n+    }\n+}\n+\n+/// A fn item that writes to a field of `Point` but does not invoke methods\n+mod fn_write_field {\n+    use point::Point;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn inc_x(p: &mut Point) {\n+        p.x += 1.0;\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "8df1cf54da2b97c3e34abb97abcba9b802f2b239", "filename": "src/test/incremental/change_private_impl_method_cc/auxiliary/point.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fauxiliary%2Fpoint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fauxiliary%2Fpoint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fauxiliary%2Fpoint.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Point {\n+    pub x: f32,\n+    pub y: f32,\n+}\n+\n+impl Point {\n+    fn distance_squared(&self) -> f32 {\n+        #[cfg(rpass1)]\n+        return self.x + self.y;\n+\n+        #[cfg(rpass2)]\n+        return self.x * self.x + self.y * self.y;\n+    }\n+\n+    pub fn distance_from_origin(&self) -> f32 {\n+        self.distance_squared().sqrt()\n+    }\n+}\n+\n+impl Point {\n+    pub fn translate(&mut self, x: f32, y: f32) {\n+        self.x += x;\n+        self.y += y;\n+    }\n+}"}, {"sha": "d8e5fbadad8bfad67179d51c47a20794091e9344", "filename": "src/test/incremental/change_private_impl_method_cc/struct_point.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test where we change the body of a private method in an impl.\n+// We then test what sort of functions must be rebuilt as a result.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+// aux-build:point.rs\n+\n+#![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n+#![allow(dead_code)]\n+\n+// FIXME(#37333) -- the following modules *should* be reused but are not\n+#![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n+\n+extern crate point;\n+\n+/// A fn item that calls (public) methods on `Point` from the same impl which changed\n+mod fn_calls_methods_in_same_impl {\n+    use point::Point;\n+\n+    // FIXME(#37333) -- we should not need to typeck this again\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let x = Point { x: 2.0, y: 2.0 };\n+        x.distance_from_origin();\n+    }\n+}\n+\n+/// A fn item that calls (public) methods on `Point` from another impl\n+mod fn_calls_methods_in_another_impl {\n+    use point::Point;\n+\n+    // FIXME(#37333) -- we should not need to typeck this again\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn check() {\n+        let mut x = Point { x: 2.0, y: 2.0 };\n+        x.translate(3.0, 3.0);\n+    }\n+}\n+\n+/// A fn item that makes an instance of `Point` but does not invoke methods\n+mod fn_make_struct {\n+    use point::Point;\n+\n+    // FIXME(#37333) -- we should not need to typeck this again\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn make_origin() -> Point {\n+        Point { x: 2.0, y: 2.0 }\n+    }\n+}\n+\n+/// A fn item that reads fields from `Point` but does not invoke methods\n+mod fn_read_field {\n+    use point::Point;\n+\n+    // FIXME(#37333) -- we should not need to typeck this again\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn get_x(p: Point) -> f32 {\n+        p.x\n+    }\n+}\n+\n+/// A fn item that writes to a field of `Point` but does not invoke methods\n+mod fn_write_field {\n+    use point::Point;\n+\n+    // FIXME(#37333) -- we should not need to typeck this again\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn inc_x(p: &mut Point) {\n+        p.x += 1.0;\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "f5f4c0042b4328cd1363b03be64e46208ebee180", "filename": "src/test/incremental/hashes/panic_exprs.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for exprs that can panic at runtime (e.g. because of bounds checking). For\n+// these expressions an error message containing their source location is\n+// generated, so their hash must always depend on their location in the source\n+// code, not just when debuginfo is enabled.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph -C debug-assertions\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Indexing expression ---------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn indexing(slice: &[u8]) -> u8 {\n+    slice[100]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn indexing(slice: &[u8]) -> u8 {\n+    slice[100]\n+}\n+\n+\n+// Arithmetic overflow plus ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n+    val + 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n+    val + 1\n+}\n+\n+\n+// Arithmetic overflow minus ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n+    val - 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n+    val - 1\n+}\n+\n+\n+// Arithmetic overflow mult ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n+    val * 2\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n+    val * 2\n+}\n+\n+\n+// Arithmetic overflow negation ------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n+    -val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n+    -val\n+}\n+\n+\n+// Division by zero ------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn division_by_zero(val: i32) -> i32 {\n+    2 / val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn division_by_zero(val: i32) -> i32 {\n+    2 / val\n+}\n+\n+// Division by zero ------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn mod_by_zero(val: i32) -> i32 {\n+    2 % val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn mod_by_zero(val: i32) -> i32 {\n+    2 % val\n+}\n+\n+\n+\n+// THE FOLLOWING ITEMS SHOULD NOT BE INFLUENCED BY THEIR SOURCE LOCATION\n+\n+// bitwise ---------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn bitwise(val: i32) -> i32 {\n+    !val & 0x101010101 | 0x45689 ^ 0x2372382 << 1 >> 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn bitwise(val: i32) -> i32 {\n+    !val & 0x101010101 | 0x45689 ^ 0x2372382 << 1 >> 1\n+}\n+\n+\n+// logical ---------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n+    val1 && val2 || val3\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n+    val1 && val2 || val3\n+}"}, {"sha": "b84b7f5f378aad93d89386c88b1293c15ada10b2", "filename": "src/test/incremental/hashes/panic_exprs_no_overflow_checks.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs_no_overflow_checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs_no_overflow_checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs_no_overflow_checks.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,251 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for exprs that can panic at runtime (e.g. because of bounds checking). For\n+// these expressions an error message containing their source location is\n+// generated, so their hash must always depend on their location in the source\n+// code, not just when debuginfo is enabled.\n+\n+// As opposed to the panic_exprs.rs test case, this test case checks that things\n+// behave as expected when overflow checks are off:\n+//\n+// - Addition, subtraction, and multiplication do not change the ICH, unless\n+//   the function containing them is marked with rustc_inherit_overflow_checks.\n+// - Division by zero and bounds checks always influence the ICH\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph -Z force-overflow-checks=off\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Indexing expression ---------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn indexing(slice: &[u8]) -> u8 {\n+    slice[100]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn indexing(slice: &[u8]) -> u8 {\n+    slice[100]\n+}\n+\n+\n+// Arithmetic overflow plus ----------------------------------------------------\n+#[cfg(cfail1)]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_plus_inherit(val: i32) -> i32 {\n+    val + 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_plus_inherit(val: i32) -> i32 {\n+    val + 1\n+}\n+\n+\n+// Arithmetic overflow minus ----------------------------------------------------\n+#[cfg(cfail1)]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_minus_inherit(val: i32) -> i32 {\n+    val - 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_minus_inherit(val: i32) -> i32 {\n+    val - 1\n+}\n+\n+\n+// Arithmetic overflow mult ----------------------------------------------------\n+#[cfg(cfail1)]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_mult_inherit(val: i32) -> i32 {\n+    val * 2\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_mult_inherit(val: i32) -> i32 {\n+    val * 2\n+}\n+\n+\n+// Arithmetic overflow negation ------------------------------------------------\n+#[cfg(cfail1)]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_negation_inherit(val: i32) -> i32 {\n+    -val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_inherit_overflow_checks]\n+pub fn arithmetic_overflow_negation_inherit(val: i32) -> i32 {\n+    -val\n+}\n+\n+\n+// Division by zero ------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn division_by_zero(val: i32) -> i32 {\n+    2 / val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn division_by_zero(val: i32) -> i32 {\n+    2 / val\n+}\n+\n+// Division by zero ------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn mod_by_zero(val: i32) -> i32 {\n+    2 % val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn mod_by_zero(val: i32) -> i32 {\n+    2 % val\n+}\n+\n+\n+\n+// THE FOLLOWING ITEMS SHOULD NOT BE INFLUENCED BY THEIR SOURCE LOCATION\n+\n+// bitwise ---------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn bitwise(val: i32) -> i32 {\n+    !val & 0x101010101 | 0x45689 ^ 0x2372382 << 1 >> 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn bitwise(val: i32) -> i32 {\n+    !val & 0x101010101 | 0x45689 ^ 0x2372382 << 1 >> 1\n+}\n+\n+\n+// logical ---------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n+    val1 && val2 || val3\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn logical(val1: bool, val2: bool, val3: bool) -> bool {\n+    val1 && val2 || val3\n+}\n+\n+// Arithmetic overflow plus ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n+    val + 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n+    val + 1\n+}\n+\n+\n+// Arithmetic overflow minus ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n+    val - 1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n+    val - 1\n+}\n+\n+\n+// Arithmetic overflow mult ----------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n+    val * 2\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n+    val * 2\n+}\n+\n+\n+// Arithmetic overflow negation ------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n+    -val\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n+    -val\n+}"}, {"sha": "d723d94c02cc33a872d2efb23fdd4de80e226ae1", "filename": "src/test/parse-fail/issue-10412.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fparse-fail%2Fissue-10412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fparse-fail%2Fissue-10412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-10412.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -19,7 +19,7 @@ trait Serializable<'self, T> { //~ ERROR lifetimes cannot use keyword names\n impl<'self> Serializable<str> for &'self str { //~ ERROR lifetimes cannot use keyword names\n     //~^ ERROR lifetimes cannot use keyword names\n     fn serialize(val : &'self str) -> Vec<u8> { //~ ERROR lifetimes cannot use keyword names\n-        vec!(1)\n+        vec![1]\n     }\n     fn deserialize(repr: &[u8]) -> &'self str { //~ ERROR lifetimes cannot use keyword names\n         \"hi\""}, {"sha": "c645a66b70efcb26370bd3058d9479fec3fe154b", "filename": "src/test/pretty/block-disambig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -61,9 +61,9 @@ fn test9() {\n }\n \n fn test10() -> isize {\n-    let regs = vec!(0);\n+    let regs = vec![0];\n     match true { true => { } _ => { } }\n     regs[0]\n }\n \n-fn test11() -> Vec<isize> { if true { } vec!(1, 2) }\n+fn test11() -> Vec<isize> { if true { } vec![1, 2] }"}, {"sha": "e750d1fb1e3e6364dba8cf64655988c0a5a4bec5", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -53,12 +53,12 @@ fn expand_deriving_partial_eq(cx: &mut ExtCtxt, span: Span, mitem: &MetaItem, it\n     }\n \n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let attrs = vec!(cx.attribute(span, inline));\n+    let attrs = vec![cx.attribute(span, inline)];\n     let methods = vec![MethodDef {\n         name: \"eq\",\n         generics: LifetimeBounds::empty(),\n         explicit_self: borrowed_explicit_self(),\n-        args: vec!(borrowed_self()),\n+        args: vec![borrowed_self()],\n         ret_ty: Literal(deriving::generic::ty::Path::new_local(\"bool\")),\n         attributes: attrs,\n         is_unsafe: false,"}, {"sha": "bc95d96a8cc9d1e63baa58f3f2aa28ceca67b7a2", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -38,7 +38,7 @@ fn length<A, T: iterable<A>>(x: T) -> usize {\n }\n \n pub fn main() {\n-    let x: Vec<isize> = vec!(0,1,2,3);\n+    let x: Vec<isize> = vec![0,1,2,3];\n     // Call a method\n     x.iterate(|y| { assert_eq!(x[*y as usize], *y); true });\n     // Call a parameterized function"}, {"sha": "dd194447740b7cf7ce92a7de9bc8d35d548a429d", "filename": "src/test/run-pass/associated-types-doubleendediterator-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fassociated-types-doubleendediterator-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fassociated-types-doubleendediterator-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-doubleendediterator-object.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -25,7 +25,7 @@ fn pairwise_sub(mut t: Box<DoubleEndedIterator<Item=isize>>) -> isize {\n }\n \n fn main() {\n-    let v = vec!(1, 2, 3, 4, 5, 6);\n+    let v = vec![1, 2, 3, 4, 5, 6];\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let r = pairwise_sub(Box::new(v.into_iter()));\n     assert_eq!(r, 9);"}, {"sha": "abd4917cae87fcd0e93434ee7d463f6ef49b6cab", "filename": "src/test/run-pass/associated-types-iterator-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fassociated-types-iterator-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fassociated-types-iterator-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-iterator-binding.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -22,7 +22,7 @@ fn pairwise_sub<T:DoubleEndedIterator<Item=isize>>(mut t: T) -> isize {\n }\n \n fn main() {\n-    let v = vec!(1, 2, 3, 4, 5, 6);\n+    let v = vec![1, 2, 3, 4, 5, 6];\n     let r = pairwise_sub(v.into_iter());\n     assert_eq!(r, 9);\n }"}, {"sha": "b0afae79c3696d89f372a1095a73f238e813df35", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -11,7 +11,7 @@\n \n pub fn main() {\n     let mut sum = 0;\n-    let xs = vec!(1, 2, 3, 4, 5);\n+    let xs = vec![1, 2, 3, 4, 5];\n     for x in &xs {\n         sum += *x;\n     }"}, {"sha": "f6cb314d06e2d8e5a395e6fcda84d4a60637a4e6", "filename": "src/test/run-pass/auto-ref-sliceable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -21,7 +21,7 @@ impl<T> Pushable<T> for Vec<T> {\n }\n \n pub fn main() {\n-    let mut v = vec!(1);\n+    let mut v = vec![1];\n     v.push_val(2);\n     v.push_val(3);\n     assert_eq!(v, [1, 2, 3]);"}, {"sha": "ed0b9eca0e058274a98944e877201003bbdf21f0", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -12,7 +12,7 @@\n \n fn f<T>(x: Vec<T>) -> T { return x.into_iter().next().unwrap(); }\n \n-fn g<F>(act: F) -> isize where F: FnOnce(Vec<isize>) -> isize { return act(vec!(1, 2, 3)); }\n+fn g<F>(act: F) -> isize where F: FnOnce(Vec<isize>) -> isize { return act(vec![1, 2, 3]); }\n \n pub fn main() {\n     assert_eq!(g(f), 1);"}, {"sha": "7fca4bccab3ff5b25d3cee9c4d7b688ba6574148", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -10,7 +10,7 @@\n \n // Check usage and precedence of block arguments in expressions:\n pub fn main() {\n-    let v = vec!(-1.0f64, 0.0, 1.0, 2.0, 3.0);\n+    let v = vec![-1.0f64, 0.0, 1.0, 2.0, 3.0];\n \n     // Statement form does not require parentheses:\n     for i in &v {"}, {"sha": "44f4a54610a9bda3b59ceff3d8e7b78ba2597027", "filename": "src/test/run-pass/borrow-by-val-method-receiver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fborrow-by-val-method-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fborrow-by-val-method-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrow-by-val-method-receiver.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -17,6 +17,6 @@ impl<'a> Foo for &'a [isize] {\n }\n \n pub fn main() {\n-    let items = vec!( 3, 5, 1, 2, 4 );\n+    let items = vec![ 3, 5, 1, 2, 4 ];\n     items.foo();\n }"}, {"sha": "b6c2a3a61ea4fa2449db090716b3b4fe44a47ec1", "filename": "src/test/run-pass/borrowck/borrowck-binding-mutbl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-binding-mutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-binding-mutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-binding-mutbl.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -14,7 +14,7 @@ fn impure(_v: &[isize]) {\n }\n \n pub fn main() {\n-    let mut x = F {f: vec!(3)};\n+    let mut x = F {f: vec![3]};\n \n     match x {\n       F {f: ref mut v} => {"}, {"sha": "4699f376313ba8fab9b5ae4da1214a6769d1388a", "filename": "src/test/run-pass/borrowck/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-mut-vec-as-imm-slice.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -21,5 +21,5 @@ fn has_mut_vec(v: Vec<isize> ) -> isize {\n }\n \n pub fn main() {\n-    assert_eq!(has_mut_vec(vec!(1, 2, 3)), 6);\n+    assert_eq!(has_mut_vec(vec![1, 2, 3]), 6);\n }"}, {"sha": "9a32fbc103147ee92412bc778fda57fd7ca62865", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -26,7 +26,7 @@ pub fn main() {\n         i += 1; if i % 2 == 0 { continue; } assert!((i % 2 != 0));\n         if i >= 10 { break; }\n     }\n-    let ys = vec!(1, 2, 3, 4, 5, 6);\n+    let ys = vec![1, 2, 3, 4, 5, 6];\n     for x in &ys {\n         if *x % 2 == 0 { continue; }\n         assert!((*x % 2 != 0));"}, {"sha": "ad779d26f9e463d77fdffa6bcad1fc8aaca0fd32", "filename": "src/test/run-pass/byte-literals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbyte-literals.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -57,7 +57,7 @@ pub fn main() {\n         _ => panic!(),\n     }\n \n-    let buf = vec!(97u8, 98, 99, 100);\n+    let buf = vec![97u8, 98, 99, 100];\n     assert_eq!(match &buf[0..3] {\n          b\"def\" => 1,\n          b\"abc\" => 2,"}, {"sha": "b105411c284a7bdbdae98e69881f572929f62fa4", "filename": "src/test/run-pass/cci_no_inline_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -21,7 +21,7 @@ pub fn main() {\n     // actually working.\n     //let bt0 = sys::frame_address();\n     //println!(\"%?\", bt0);\n-    iter(vec!(1, 2, 3), |i| {\n+    iter(vec![1, 2, 3], |i| {\n         println!(\"{}\", i);\n \n         //let bt1 = sys::frame_address();"}, {"sha": "7d266181c9eb12236ab7a374e51f8976bf57ee61", "filename": "src/test/run-pass/class-poly-methods-cross-crate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -14,12 +14,12 @@ extern crate cci_class_6;\n use cci_class_6::kitties::cat;\n \n pub fn main() {\n-  let mut nyan : cat<char> = cat::<char>(52_usize, 99, vec!('p'));\n-  let mut kitty = cat(1000_usize, 2, vec!(\"tabby\".to_string()));\n+  let mut nyan : cat<char> = cat::<char>(52_usize, 99, vec!['p']);\n+  let mut kitty = cat(1000_usize, 2, vec![\"tabby\".to_string()]);\n   assert_eq!(nyan.how_hungry, 99);\n   assert_eq!(kitty.how_hungry, 2);\n-  nyan.speak(vec!(1_usize,2_usize,3_usize));\n+  nyan.speak(vec![1_usize,2_usize,3_usize]);\n   assert_eq!(nyan.meow_count(), 55_usize);\n-  kitty.speak(vec!(\"meow\".to_string(), \"mew\".to_string(), \"purr\".to_string(), \"chirp\".to_string()));\n+  kitty.speak(vec![\"meow\".to_string(), \"mew\".to_string(), \"purr\".to_string(), \"chirp\".to_string()]);\n   assert_eq!(kitty.meow_count(), 1004_usize);\n }"}, {"sha": "5da858e3c40972756184cf72dcabf41c9fd0a282", "filename": "src/test/run-pass/class-poly-methods.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -33,12 +33,12 @@ fn cat<U>(in_x : usize, in_y : isize, in_info: Vec<U> ) -> cat<U> {\n }\n \n pub fn main() {\n-  let mut nyan : cat<isize> = cat::<isize>(52, 99, vec!(9));\n-  let mut kitty = cat(1000, 2, vec!(\"tabby\".to_string()));\n+  let mut nyan : cat<isize> = cat::<isize>(52, 99, vec![9]);\n+  let mut kitty = cat(1000, 2, vec![\"tabby\".to_string()]);\n   assert_eq!(nyan.how_hungry, 99);\n   assert_eq!(kitty.how_hungry, 2);\n-  nyan.speak(vec!(1,2,3));\n+  nyan.speak(vec![1,2,3]);\n   assert_eq!(nyan.meow_count(), 55);\n-  kitty.speak(vec!(\"meow\".to_string(), \"mew\".to_string(), \"purr\".to_string(), \"chirp\".to_string()));\n+  kitty.speak(vec![\"meow\".to_string(), \"mew\".to_string(), \"purr\".to_string(), \"chirp\".to_string()]);\n   assert_eq!(kitty.meow_count(), 1004);\n }"}, {"sha": "c401b529c30d9e54794635931d1d8ae360cc3401", "filename": "src/test/run-pass/cleanup-rvalue-temp-during-incomplete-alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-temp-during-incomplete-alloc.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -41,7 +41,7 @@ fn do_it(x: &[usize]) -> Foo {\n     panic!()\n }\n \n-fn get_bar(x: usize) -> Vec<usize> { vec!(x * 2) }\n+fn get_bar(x: usize) -> Vec<usize> { vec![x * 2] }\n \n pub fn fails() {\n     let x = 2;"}, {"sha": "e86f20694e103f76b9aa70c09aa00f584647deb4", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -19,7 +19,7 @@ fn bip(v: &[usize]) -> Vec<usize> {\n }\n \n pub fn main() {\n-    let mut the_vec = vec!(1, 2, 3, 100);\n+    let mut the_vec = vec![1, 2, 3, 100];\n     assert_eq!(the_vec.clone(), bar(&mut the_vec));\n     assert_eq!(the_vec.clone(), bip(&the_vec));\n }"}, {"sha": "ca4ee4a97d524756615bb581d1409cf96c87f527", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -21,7 +21,7 @@ fn bar(v: &mut [usize]) {\n }\n \n pub fn main() {\n-    let mut the_vec = vec!(1, 2, 3, 100);\n+    let mut the_vec = vec![1, 2, 3, 100];\n     bar(&mut the_vec);\n     assert_eq!(the_vec, [100, 3, 2, 1]);\n }"}, {"sha": "f35735adbcfe2ca194e81484bf3d7882bdb8bd35", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -17,7 +17,7 @@ fn bar(v: &mut [usize]) {\n }\n \n pub fn main() {\n-    let mut the_vec = vec!(1, 2, 3, 100);\n+    let mut the_vec = vec![1, 2, 3, 100];\n     bar(&mut the_vec);\n     assert_eq!(the_vec, [100, 3, 2, 1]);\n }"}, {"sha": "adc3e3efd70dfcc0ed8aa04b6318be4267e70f3c", "filename": "src/test/run-pass/deriving-in-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -19,6 +19,6 @@ macro_rules! define_vec {\n     )\n }\n \n-define_vec!();\n+define_vec![];\n \n pub fn main() {}"}, {"sha": "53005ea5291fd471fa4e720bb0690089756062e8", "filename": "src/test/run-pass/drop-with-type-ascription-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -12,7 +12,7 @@\n #![feature(collections)]\n \n fn main() {\n-    let args = vec!(\"foobie\", \"asdf::asdf\");\n+    let args = vec![\"foobie\", \"asdf::asdf\"];\n     let arr: Vec<&str> = args[1].split(\"::\").collect();\n     assert_eq!(arr[0], \"asdf\");\n     assert_eq!(arr[0], \"asdf\");"}, {"sha": "cc9a2e60decee4f7c9601adc3c6b5e4ef96d5ce6", "filename": "src/test/run-pass/expr-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-fn.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -16,7 +16,7 @@ fn test_int() {\n }\n \n fn test_vec() {\n-    fn f() -> Vec<isize> { vec!(10, 11) }\n+    fn f() -> Vec<isize> { vec![10, 11] }\n     let vect = f();\n     assert_eq!(vect[1], 11);\n }"}, {"sha": "1a6466048d90d80810aaf78888e3bffc0c777af6", "filename": "src/test/run-pass/expr-match-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fexpr-match-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fexpr-match-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-panic.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -16,7 +16,7 @@ fn test_simple() {\n }\n \n fn test_box() {\n-    let r = match true { true => { vec!(10) } false => { panic!() } };\n+    let r = match true { true => { vec![10] } false => { panic!() } };\n     assert_eq!(r[0], 10);\n }\n "}, {"sha": "ba78ff4d53937f0070cd6185778331e860e7c09d", "filename": "src/test/run-pass/for-destruct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Ffor-destruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Ffor-destruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-destruct.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -12,7 +12,7 @@\n struct Pair { x: isize, y: isize }\n \n pub fn main() {\n-    for elt in &(vec!(Pair {x: 10, y: 20}, Pair {x: 30, y: 0})) {\n+    for elt in &(vec![Pair {x: 10, y: 20}, Pair {x: 30, y: 0}]) {\n         assert_eq!(elt.x + elt.y, 30);\n     }\n }"}, {"sha": "2c4d0cc7648ceeaf81226a2342f1baa8ccd75182", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -13,7 +13,7 @@\n fn two<F>(mut it: F) where F: FnMut(isize) { it(0); it(1); }\n \n pub fn main() {\n-    let mut a: Vec<isize> = vec!(-1, -1, -1, -1);\n+    let mut a: Vec<isize> = vec![-1, -1, -1, -1];\n     let mut p: isize = 0;\n     two(|i| {\n         two(|j| { a[p as usize] = 10 * i + j; p += 1; })"}, {"sha": "d439c623801854cbe15c5da6ab7a073b7acfb5af", "filename": "src/test/run-pass/generic-ivec-leak.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fgeneric-ivec-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fgeneric-ivec-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-ivec-leak.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -10,4 +10,4 @@\n \n enum wrapper<T> { wrapped(T), }\n \n-pub fn main() { let _w = wrapper::wrapped(vec!(1, 2, 3, 4, 5)); }\n+pub fn main() { let _w = wrapper::wrapped(vec![1, 2, 3, 4, 5]); }"}, {"sha": "ad501ec7e9ba115221a7d73efedad8c6ec00cbbb", "filename": "src/test/run-pass/generic-static-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -25,5 +25,5 @@ impl<T> vec_utils<T> for Vec<T> {\n }\n \n pub fn main() {\n-    assert_eq!(vec_utils::map_(&vec!(1,2,3), |&x| x+1), [2,3,4]);\n+    assert_eq!(vec_utils::map_(&vec![1,2,3], |&x| x+1), [2,3,4]);\n }"}, {"sha": "90726c21fac472db923f21dfc92c42f93ad175e9", "filename": "src/test/run-pass/getopts_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -17,7 +17,7 @@ use getopts::{optopt, getopts};\n \n pub fn main() {\n     let args = Vec::new();\n-    let opts = vec!(optopt(\"b\", \"\", \"something\", \"SMTHNG\"));\n+    let opts = vec![optopt(\"b\", \"\", \"something\", \"SMTHNG\")];\n \n     match getopts(&args, &opts) {\n         Ok(ref m)  =>"}, {"sha": "2306fa9afa2ef419d98d7664276dc2ef6f2faa65", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -99,5 +99,5 @@ mod map_reduce {\n \n pub fn main() {\n     map_reduce::map_reduce(\n-        vec!(\"../src/test/run-pass/hashmap-memory.rs\".to_string()));\n+        vec![\"../src/test/run-pass/hashmap-memory.rs\".to_string()]);\n }"}, {"sha": "1e1fde4d1e2be75c8db4970620d7a76c6d36979b", "filename": "src/test/run-pass/html-literals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhtml-literals.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -40,7 +40,7 @@ macro_rules! parse_node {\n         parse_node!(\n             [$(: $tags ($(:$tag_nodes),*))*];\n             [$(:$head_nodes,)* :tag(stringify!($head).to_string(),\n-                                    vec!($($nodes),*))];\n+                                    vec![$($nodes),*])];\n             $($rest)*\n         )\n     );"}, {"sha": "2a7a593d26800fd322d77a2ede4ba29960089d44", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -237,7 +237,7 @@ fn test_write() {\n // can do with them just yet (to test the output)\n fn test_print() {\n     print!(\"hi\");\n-    print!(\"{:?}\", vec!(0u8));\n+    print!(\"{:?}\", vec![0u8]);\n     println!(\"hello\");\n     println!(\"this is a {}\", \"test\");\n     println!(\"{foo}\", foo=\"bar\");"}, {"sha": "13e8fe0e964c43d2854c4e1e16be8ac3733a3314", "filename": "src/test/run-pass/issue-13204.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-13204.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-13204.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13204.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -28,6 +28,6 @@ impl Foo for Baz {\n \n fn main() {\n     let x = Baz;\n-    let y = vec!((), (), ());\n+    let y = vec![(), (), ()];\n     assert_eq!(x.bar(y.iter()), 3);\n }"}, {"sha": "8a628b73c0067899499dee6e10774b52d044c205", "filename": "src/test/run-pass/issue-14936.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14936.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -24,7 +24,7 @@ macro_rules! demo {\n             let mut x: isize = 0;\n             let y: isize = 1;\n \n-            let mut history: History = vec!();\n+            let mut history: History = vec![];\n             unsafe {\n                 asm!(\"mov ($1), $0\"\n                      : $output_constraint (*wrap(&mut x, \"out\", &mut history))"}, {"sha": "14e003788469860bee538052bca30a52c53cc016", "filename": "src/test/run-pass/issue-15080.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15080.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -14,7 +14,7 @@\n fn main() {\n     let mut x: &[_] = &[1, 2, 3, 4];\n \n-    let mut result = vec!();\n+    let mut result = vec![];\n     loop {\n         x = match *x {\n             [1, n, 3, ref rest..] => {"}, {"sha": "54b96d66307493bd06965f0d86f4b74eb81436f6", "filename": "src/test/run-pass/issue-15189.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-15189.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-15189.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15189.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -13,7 +13,7 @@ macro_rules! third {\n }\n \n fn main() {\n-    let x = vec!(10_usize,11_usize,12_usize,13_usize);\n+    let x = vec![10_usize,11_usize,12_usize,13_usize];\n     let t = third!(x);\n     assert_eq!(t,12_usize);\n }"}, {"sha": "daf14b4c2ffc4e0c33ba335c092ef7c3d869e4f7", "filename": "src/test/run-pass/issue-15734.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-15734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-15734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15734.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -54,7 +54,7 @@ impl<T, M: Index<(usize, usize), Output=T>> Index<usize> for Row<M> {\n }\n \n fn main() {\n-    let m = Mat::new(vec!(1, 2, 3, 4, 5, 6), 3);\n+    let m = Mat::new(vec![1, 2, 3, 4, 5, 6], 3);\n     let r = m.row(1);\n \n     assert_eq!(r.index(2), &6);"}, {"sha": "913b07613e0308094ef61b4ee012c6d53d774881", "filename": "src/test/run-pass/issue-2631-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -19,7 +19,7 @@ use std::collections::HashMap;\n use std::rc::Rc;\n \n pub fn main() {\n-  let v = vec!(Rc::new(\"hi\".to_string()));\n+  let v = vec![Rc::new(\"hi\".to_string())];\n   let mut m: req::header_map = HashMap::new();\n   m.insert(\"METHOD\".to_string(), Rc::new(RefCell::new(v)));\n   request::<isize>(&m);"}, {"sha": "a6ba957a1b110069f084edd38815fa3458220045", "filename": "src/test/run-pass/issue-2723-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-2723-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-2723-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2723-b.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -15,6 +15,6 @@ use issue_2723_a::f;\n \n pub fn main() {\n     unsafe {\n-        f(vec!(2));\n+        f(vec![2]);\n     }\n }"}, {"sha": "992fbdce268988bafc0625cec7d4540ecf07752c", "filename": "src/test/run-pass/issue-28936.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-28936.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-28936.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28936.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -23,7 +23,7 @@ pub fn parse_stream<T: Iterator<Item=i32>, U, F>(\n     where F: Fn(&mut StreamParser<T>) -> U { panic!(); }\n \n pub fn thing(session: &mut Session) {\n-    let mut stream = vec!(1, 2, 3).into_iter();\n+    let mut stream = vec![1, 2, 3].into_iter();\n \n     let _b = parse_stream(session,\n                           stream.by_ref(),"}, {"sha": "a4342f33402d323e92c6bae38d10a16eafab7a55", "filename": "src/test/run-pass/issue-2989.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-2989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-2989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2989.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -32,8 +32,8 @@ fn to_bools(bitv: Storage) -> Vec<bool> {\n struct Storage { storage: Vec<u64> }\n \n pub fn main() {\n-    let bools = vec!(false, false, true, false, false, true, true, false);\n-    let bools2 = to_bools(Storage{storage: vec!(0b01100100)});\n+    let bools = vec![false, false, true, false, false, true, true, false];\n+    let bools2 = to_bools(Storage{storage: vec![0b01100100]});\n \n     for i in 0..8 {\n         println!(\"{} => {} vs {}\", i, bools[i], bools2[i]);"}, {"sha": "70e3484a0c57aa2c4f65fede7f2cf596aff8f14f", "filename": "src/test/run-pass/issue-3389.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-3389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3389.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -25,8 +25,8 @@ pub fn main() {\n         content: Vec::new(),\n         children: Vec::new()\n     };\n-    let v = vec!(\"123\".to_string(), \"abc\".to_string());\n-    node.content = vec!(\"123\".to_string(), \"abc\".to_string());\n+    let v = vec![\"123\".to_string(), \"abc\".to_string()];\n+    node.content = vec![\"123\".to_string(), \"abc\".to_string()];\n     print_str_vector(v);\n     print_str_vector(node.content.clone());\n "}, {"sha": "67cdea807beebd65ed5e133cc6fea5b68fa0b6da", "filename": "src/test/run-pass/issue-37291/auxiliary/lib.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-37291%2Fauxiliary%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-37291%2Fauxiliary%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37291%2Fauxiliary%2Flib.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+use std::ops::Mul;\n+\n+pub trait A {}\n+pub trait B {\n+    type AT: A;\n+}\n+pub trait C {\n+    type BT: B;\n+}\n+\n+pub struct AV;\n+impl A for AV {}\n+\n+pub struct BV;\n+impl B for BV {\n+    type AT = AV;\n+}\n+\n+pub struct CV;\n+impl C for CV {\n+    type BT = BV;\n+}\n+\n+pub struct WrapperB<T>(pub T);\n+pub struct WrapperC<T>(pub T);\n+\n+impl<C1> Mul<WrapperB<<C1::BT as B>::AT>> for WrapperC<C1>\n+    where C1: C\n+{\n+    type Output = u8;\n+    fn mul(self, _: WrapperB<<C1::BT as B>::AT>) -> Self::Output {\n+        loop {}\n+    }\n+}\n+impl<C1> Mul<WrapperC<C1>> for WrapperC<C1> {\n+    type Output = u8;\n+    fn mul(self, _: WrapperC<C1>) -> Self::Output {\n+        loop {}\n+    }\n+}"}, {"sha": "2461f7485f26feb93dfc5528779ed16ffd6a9b97", "filename": "src/test/run-pass/issue-37291/main.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-37291%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-37291%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37291%2Fmain.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lib.rs\n+\n+// Regression test for #37291. The problem was that the starting\n+// environment for a specialization check was not including the\n+// where-clauses from the impl when attempting to normalize the impl's\n+// trait-ref, so things like `<C as Foo>::Item` could not resolve,\n+// since the `C: Foo` trait bound was not included in the environment.\n+\n+extern crate lib;\n+\n+use lib::{CV, WrapperB, WrapperC};\n+\n+fn main() {\n+    let a = WrapperC(CV);\n+    let b = WrapperC(CV);\n+    if false {\n+        let _ = a * b;\n+    }\n+}"}, {"sha": "1b16418ac425961c0f9798e0ec96c5fc9163861b", "filename": "src/test/run-pass/issue-6153.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-6153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fissue-6153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6153.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -11,7 +11,7 @@\n \n \n fn swap<F>(f: F) -> Vec<isize> where F: FnOnce(Vec<isize>) -> Vec<isize> {\n-    let x = vec!(1, 2, 3);\n+    let x = vec![1, 2, 3];\n     f(x)\n }\n "}, {"sha": "e3b42e60645a31f583b1e41b009ac3dc4a6ae5e2", "filename": "src/test/run-pass/ivec-pass-by-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fivec-pass-by-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fivec-pass-by-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-pass-by-value.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n fn f(_a: Vec<isize> ) { }\n-pub fn main() { f(vec!(1, 2, 3, 4, 5)); }\n+pub fn main() { f(vec![1, 2, 3, 4, 5]); }"}, {"sha": "a511db8e9397dc718a9aa55934f0c088a642b29b", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -17,8 +17,8 @@ use std::sync::mpsc::{channel, Sender};\n \n fn producer(tx: &Sender<Vec<u8>>) {\n     tx.send(\n-         vec!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n-          13)).unwrap();\n+         vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n+          13]).unwrap();\n }\n \n pub fn main() {"}, {"sha": "5109c6fc77726d31ee0d620dfacaced9a300d7fd", "filename": "src/test/run-pass/lambda-infer-unresolved.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -15,7 +15,7 @@\n struct Refs { refs: Vec<isize> , n: isize }\n \n pub fn main() {\n-    let mut e = Refs{refs: vec!(), n: 0};\n+    let mut e = Refs{refs: vec![], n: 0};\n     let _f = || println!(\"{}\", e.n);\n     let x: &[isize] = &e.refs;\n     assert_eq!(x.len(), 0);"}, {"sha": "fc6d435b034be5aeb3563ad0562fe0f40d160ec2", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let x = vec!(1, 2, 3);\n+    let x = vec![1, 2, 3];\n     let mut y = 0;\n     for i in &x { println!(\"{}\", *i); y += *i; }\n     println!(\"{}\", y);"}, {"sha": "b54b4692a41bf9362bf08bf69d6b4750513a7392", "filename": "src/test/run-pass/log-poly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Flog-poly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Flog-poly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-poly.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -17,5 +17,5 @@ pub fn main() {\n     println!(\"{:?}\", 1);\n     println!(\"{:?}\", 2.0f64);\n     println!(\"{:?}\", Numbers::Three);\n-    println!(\"{:?}\", vec!(4));\n+    println!(\"{:?}\", vec![4]);\n }"}, {"sha": "6916bfb8c616a90c53353f827bc1f9e5ca8731e3", "filename": "src/test/run-pass/loop-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Floop-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Floop-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-scope.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -10,7 +10,7 @@\n \n \n pub fn main() {\n-    let x = vec!(10, 20, 30);\n+    let x = vec![10, 20, 30];\n     let mut sum = 0;\n     for x in &x { sum += *x; }\n     assert_eq!(sum, 60);"}, {"sha": "3d221927b96e18d7b83bb87c6f559f8d74708708", "filename": "src/test/run-pass/match-vec-rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fmatch-vec-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fmatch-vec-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-vec-rvalue.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -13,7 +13,7 @@\n \n \n pub fn main() {\n-    match vec!(1, 2, 3) {\n+    match vec![1, 2, 3] {\n         x => {\n             assert_eq!(x.len(), 3);\n             assert_eq!(x[0], 1);"}, {"sha": "211827f92222ca0ca02f501a9cc28908e3d3b942", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -45,9 +45,9 @@ fn transform(x: Option<isize>) -> Option<String> {\n pub fn main() {\n     assert_eq!(transform(Some(10)), Some(\"11\".to_string()));\n     assert_eq!(transform(None), None);\n-    assert_eq!((vec!(\"hi\".to_string()))\n-        .bind(|x| vec!(x.clone(), format!(\"{}!\", x)) )\n-        .bind(|x| vec!(x.clone(), format!(\"{}?\", x)) ),\n+    assert_eq!((vec![\"hi\".to_string()])\n+        .bind(|x| vec![x.clone(), format!(\"{}!\", x)] )\n+        .bind(|x| vec![x.clone(), format!(\"{}?\", x)] ),\n         [\"hi\".to_string(),\n          \"hi?\".to_string(),\n          \"hi!\".to_string(),"}, {"sha": "0ff5a66adc269c4efc80977afedd111e5b141ef1", "filename": "src/test/run-pass/move-arg-2-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fmove-arg-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fmove-arg-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg-2-unique.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -15,10 +15,10 @@\n fn test(foo: Box<Vec<isize>> ) { assert_eq!((*foo)[0], 10); }\n \n pub fn main() {\n-    let x = box vec!(10);\n+    let x = box vec![10];\n     // Test forgetting a local by move-in\n     test(x);\n \n     // Test forgetting a temporary by move-in.\n-    test(box vec!(10));\n+    test(box vec![10]);\n }"}, {"sha": "8de487bc3631ce105dea5f93ec7ced741a72c108", "filename": "src/test/run-pass/move-arg-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -15,10 +15,10 @@\n fn test(foo: Box<Vec<isize>>) { assert_eq!((*foo)[0], 10); }\n \n pub fn main() {\n-    let x = box vec!(10);\n+    let x = box vec![10];\n     // Test forgetting a local by move-in\n     test(x);\n \n     // Test forgetting a temporary by move-in.\n-    test(box vec!(10));\n+    test(box vec![10]);\n }"}, {"sha": "e7da8d7bf93c7b1705f52c286e163b27793a3132", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -24,7 +24,7 @@ fn myvec_elt<X>(mv: myvec<X>) -> X {\n }\n \n pub fn main() {\n-    let mv = myvec(vec!(1, 2, 3));\n+    let mv = myvec(vec![1, 2, 3]);\n     let mv_clone = mv.clone();\n     let mv_clone = myvec_deref(mv_clone);\n     assert_eq!(mv_clone[1], 2);"}, {"sha": "7e8d082a286a8991bfcc9c7b32916b27486875b9", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -76,7 +76,7 @@ pub fn main() {\n     check_type!(&17, &isize);\n     check_type!(box 18, Box<isize>);\n     check_type!(\"foo\".to_string(), String);\n-    check_type!(vec!(20, 22), Vec<isize>);\n+    check_type!(vec![20, 22], Vec<isize>);\n     check_type!(main, fn(), |pthing| {\n         assert_eq!(main as fn(), *pthing as fn())\n     });"}, {"sha": "768f126e4edfe2d1b102c99b6ec8e4d5767c225a", "filename": "src/test/run-pass/objects-owned-object-borrowed-method-headerless.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-headerless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-headerless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-headerless.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -32,11 +32,11 @@ impl FooTrait for BarStruct {\n }\n \n pub fn main() {\n-    let foos: Vec<Box<FooTrait>> = vec!(\n+    let foos: Vec<Box<FooTrait>> = vec![\n         box BarStruct{ x: 0 } as Box<FooTrait>,\n         box BarStruct{ x: 1 } as Box<FooTrait>,\n         box BarStruct{ x: 2 } as Box<FooTrait>\n-    );\n+    ];\n \n     for i in 0..foos.len() {\n         assert_eq!(i, foos[i].foo());"}, {"sha": "e2ca880719a8ecce4efac61b7ed27f13040211d8", "filename": "src/test/run-pass/overloaded-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -45,7 +45,7 @@ pub fn main() {\n     (*(*p).borrow_mut()).y += 3;\n     assert_eq!(*(*p).borrow(), Point {x: 3, y: 5});\n \n-    let v = Rc::new(RefCell::new(vec!(1, 2, 3)));\n+    let v = Rc::new(RefCell::new(vec![1, 2, 3]));\n     (*(*v).borrow_mut())[0] = 3;\n     (*(*v).borrow_mut())[1] += 3;\n     assert_eq!(((*(*v).borrow())[0],"}, {"sha": "efa73ad92ce836d14d554cbd1428570590300d5f", "filename": "src/test/run-pass/rcvr-borrowed-to-slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -23,17 +23,17 @@ impl<'a> sum for &'a [isize] {\n fn call_sum(x: &[isize]) -> isize { x.sum_() }\n \n pub fn main() {\n-    let x = vec!(1, 2, 3);\n+    let x = vec![1, 2, 3];\n     let y = call_sum(&x);\n     println!(\"y=={}\", y);\n     assert_eq!(y, 6);\n \n-    let x = vec!(1, 2, 3);\n+    let x = vec![1, 2, 3];\n     let y = x.sum_();\n     println!(\"y=={}\", y);\n     assert_eq!(y, 6);\n \n-    let x = vec!(1, 2, 3);\n+    let x = vec![1, 2, 3];\n     let y = x.sum_();\n     println!(\"y=={}\", y);\n     assert_eq!(y, 6);"}, {"sha": "e61a8d147757ce59c73d5c7c95bf78647d021403", "filename": "src/test/run-pass/regions-borrow-evec-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-uniq.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -15,11 +15,11 @@ fn foo(x: &[isize]) -> isize {\n }\n \n pub fn main() {\n-    let p = vec!(1,2,3,4,5);\n+    let p = vec![1,2,3,4,5];\n     let r = foo(&p);\n     assert_eq!(r, 1);\n \n-    let p = vec!(5,4,3,2,1);\n+    let p = vec![5,4,3,2,1];\n     let r = foo(&p);\n     assert_eq!(r, 5);\n }"}, {"sha": "e9a3e16438f818feca218f9a7b5ee0542ad985e1", "filename": "src/test/run-pass/regions-dependent-addr-of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -90,7 +90,7 @@ fn get_v5_ref(a: &A, _i: usize) -> &isize {\n pub fn main() {\n     let a = A {value: B {v1: 22,\n                          v2: [23, 24, 25],\n-                         v3: vec!(26, 27, 28),\n+                         v3: vec![26, 27, 28],\n                          v4: C { f: 29 },\n                          v5: box C { f: 30 },\n                          v6: Some(C { f: 31 })}};"}, {"sha": "cd140f7aa599b267f34ee054edefc7ccf4012883", "filename": "src/test/run-pass/regions-dependent-autoslice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fregions-dependent-autoslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fregions-dependent-autoslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-dependent-autoslice.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -18,6 +18,6 @@ fn both<'r>(v: &'r [usize]) -> &'r [usize] {\n }\n \n pub fn main() {\n-    let v = vec!(1,2,3);\n+    let v = vec![1,2,3];\n     both(&v);\n }"}, {"sha": "262e936826e51fd39f78086e4adf6c1eb014b808", "filename": "src/test/run-pass/regions-infer-borrow-scope-view.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-view.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -13,7 +13,7 @@\n fn view<T>(x: &[T]) -> &[T] {x}\n \n pub fn main() {\n-    let v = vec!(1, 2, 3);\n+    let v = vec![1, 2, 3];\n     let x = view(&v);\n     let y = view(x);\n     assert!((v[0] == x[0]) && (v[0] == y[0]));"}, {"sha": "8eee54b3fec6642288d5ab45729949aac0699610", "filename": "src/test/run-pass/regions-relate-bound-regions-on-closures-to-inference-variables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -63,7 +63,7 @@ impl<'a,'tcx> Foo<'a,'tcx> {\n }\n \n fn main() {\n-    let v = vec!();\n+    let v = vec![];\n     let cx = Ctxt { x: &v };\n     let mut foo = Foo { cx: &cx };\n     assert_eq!(foo.bother(), 22); // just so the code is not dead, basically"}, {"sha": "43612f529772a0a12eedf7a00edfc6d24482637c", "filename": "src/test/run-pass/seq-compare.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fseq-compare.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -14,13 +14,13 @@ pub fn main() {\n     assert!((\"hello\".to_string() < \"hellr\".to_string()));\n     assert!((\"hello \".to_string() > \"hello\".to_string()));\n     assert!((\"hello\".to_string() != \"there\".to_string()));\n-    assert!((vec!(1, 2, 3, 4) > vec!(1, 2, 3)));\n-    assert!((vec!(1, 2, 3) < vec!(1, 2, 3, 4)));\n-    assert!((vec!(1, 2, 4, 4) > vec!(1, 2, 3, 4)));\n-    assert!((vec!(1, 2, 3, 4) < vec!(1, 2, 4, 4)));\n-    assert!((vec!(1, 2, 3) <= vec!(1, 2, 3)));\n-    assert!((vec!(1, 2, 3) <= vec!(1, 2, 3, 3)));\n-    assert!((vec!(1, 2, 3, 4) > vec!(1, 2, 3)));\n-    assert_eq!(vec!(1, 2, 3), vec!(1, 2, 3));\n-    assert!((vec!(1, 2, 3) != vec!(1, 1, 3)));\n+    assert!((vec![1, 2, 3, 4] > vec![1, 2, 3]));\n+    assert!((vec![1, 2, 3] < vec![1, 2, 3, 4]));\n+    assert!((vec![1, 2, 4, 4] > vec![1, 2, 3, 4]));\n+    assert!((vec![1, 2, 3, 4] < vec![1, 2, 4, 4]));\n+    assert!((vec![1, 2, 3] <= vec![1, 2, 3]));\n+    assert!((vec![1, 2, 3] <= vec![1, 2, 3, 3]));\n+    assert!((vec![1, 2, 3, 4] > vec![1, 2, 3]));\n+    assert_eq!(vec![1, 2, 3], vec![1, 2, 3]);\n+    assert!((vec![1, 2, 3] != vec![1, 1, 3]));\n }"}, {"sha": "13d55e0172e71f41f80c2ee28d46106927af0711", "filename": "src/test/run-pass/size-and-align.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fsize-and-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fsize-and-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsize-and-align.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -22,6 +22,6 @@ fn uhoh<T>(v: Vec<clam<T>> ) {\n }\n \n pub fn main() {\n-    let v: Vec<clam<isize>> = vec!(clam::b::<isize>, clam::b::<isize>, clam::a::<isize>(42, 17));\n+    let v: Vec<clam<isize>> = vec![clam::b::<isize>, clam::b::<isize>, clam::a::<isize>(42, 17)];\n     uhoh::<isize>(v);\n }"}, {"sha": "89fd83ced4c8c3ed4519cbfc5dd914b676897b39", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -62,10 +62,10 @@ pub fn main() {\n     assert_eq!(10_usize.plus(), 30);\n     assert_eq!((\"hi\".to_string()).plus(), 200);\n \n-    assert_eq!((vec!(1)).length_().str(), \"1\".to_string());\n-    let vect = vec!(3, 4).map_(|a| *a + 4);\n+    assert_eq!((vec![1]).length_().str(), \"1\".to_string());\n+    let vect = vec![3, 4].map_(|a| *a + 4);\n     assert_eq!(vect[0], 7);\n-    let vect = (vec!(3, 4)).map_::<usize, _>(|a| *a as usize + 4_usize);\n+    let vect = (vec![3, 4]).map_::<usize, _>(|a| *a as usize + 4_usize);\n     assert_eq!(vect[0], 7_usize);\n     let mut x = 0_usize;\n     10_usize.multi(|_n| x += 2_usize );"}, {"sha": "4601b7d7cf56791ce1931ba983ea17d6192dc6bd", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -12,7 +12,7 @@\n use std::mem::swap;\n \n pub fn main() {\n-    let mut a: Vec<isize> = vec!(0, 1, 2, 3, 4, 5, 6);\n+    let mut a: Vec<isize> = vec![0, 1, 2, 3, 4, 5, 6];\n     a.swap(2, 4);\n     assert_eq!(a[2], 4);\n     assert_eq!(a[4], 2);"}, {"sha": "0caf21ead3969b80e47d7f8105834ef85f01bf8e", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -27,7 +27,7 @@ fn test_rec() {\n \n fn test_vec() {\n     let (tx, rx) = channel();\n-    let v0: Vec<isize> = vec!(0, 1, 2);\n+    let v0: Vec<isize> = vec![0, 1, 2];\n     tx.send(v0).unwrap();\n     let v1 = rx.recv().unwrap();\n     assert_eq!(v1[0], 0);"}, {"sha": "9877dffe9df02f7cec3ee450fd2f4a68f3e37d7f", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -75,10 +75,10 @@ pub fn main() {\n         swim_speed: 998,\n         name: \"alec_guinness\".to_string(),\n     };\n-    let arc = Arc::new(vec!(box catte  as Box<Pet+Sync+Send>,\n+    let arc = Arc::new(vec![box catte  as Box<Pet+Sync+Send>,\n                             box dogge1 as Box<Pet+Sync+Send>,\n                             box fishe  as Box<Pet+Sync+Send>,\n-                            box dogge2 as Box<Pet+Sync+Send>));\n+                            box dogge2 as Box<Pet+Sync+Send>]);\n     let (tx1, rx1) = channel();\n     let arc1 = arc.clone();\n     let t1 = thread::spawn(move|| { check_legs(arc1); tx1.send(()); });"}, {"sha": "eadda5dfe299ccc885dd36102d808aabdee84801", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -45,9 +45,9 @@ fn bar<U:to_str,T:map<U>>(x: T) -> Vec<String> {\n }\n \n pub fn main() {\n-    assert_eq!(foo(vec!(1)), [\"hi\".to_string()]);\n-    assert_eq!(bar::<isize, Vec<isize> >(vec!(4, 5)), [\"4\".to_string(), \"5\".to_string()]);\n-    assert_eq!(bar::<String, Vec<String> >(vec!(\"x\".to_string(), \"y\".to_string())),\n+    assert_eq!(foo(vec![1]), [\"hi\".to_string()]);\n+    assert_eq!(bar::<isize, Vec<isize> >(vec![4, 5]), [\"4\".to_string(), \"5\".to_string()]);\n+    assert_eq!(bar::<String, Vec<String> >(vec![\"x\".to_string(), \"y\".to_string()]),\n                [\"x\".to_string(), \"y\".to_string()]);\n-    assert_eq!(bar::<(), Vec<()>>(vec!(())), [\"()\".to_string()]);\n+    assert_eq!(bar::<(), Vec<()>>(vec![()]), [\"()\".to_string()]);\n }"}, {"sha": "9671e31d7e48c0107b3a16a592b10a8b36b3a3ef", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -30,15 +30,15 @@ impl<T:to_str> to_str for Vec<T> {\n \n pub fn main() {\n     assert_eq!(1.to_string_(), \"1\".to_string());\n-    assert_eq!((vec!(2, 3, 4)).to_string_(), \"[2, 3, 4]\".to_string());\n+    assert_eq!((vec![2, 3, 4]).to_string_(), \"[2, 3, 4]\".to_string());\n \n     fn indirect<T:to_str>(x: T) -> String {\n         format!(\"{}!\", x.to_string_())\n     }\n-    assert_eq!(indirect(vec!(10, 20)), \"[10, 20]!\".to_string());\n+    assert_eq!(indirect(vec![10, 20]), \"[10, 20]!\".to_string());\n \n     fn indirect2<T:to_str>(x: T) -> String {\n         indirect(x)\n     }\n-    assert_eq!(indirect2(vec!(1)), \"[1]!\".to_string());\n+    assert_eq!(indirect2(vec![1]), \"[1]!\".to_string());\n }"}, {"sha": "300a0ee63f817c67fd3717ecd044ee8f7b88b9cb", "filename": "src/test/run-pass/unboxed-closures-counter-not-moved.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funboxed-closures-counter-not-moved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funboxed-closures-counter-not-moved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-counter-not-moved.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -15,7 +15,7 @@ fn call<F>(f: F) where F : FnOnce() {\n }\n \n fn main() {\n-    let y = vec!(format!(\"Hello\"), format!(\"World\"));\n+    let y = vec![format!(\"Hello\"), format!(\"World\")];\n     let mut counter = 22_u32;\n \n     call(|| {"}, {"sha": "b9a16535c420a9e82c322bbe663dec0991ca8c4a", "filename": "src/test/run-pass/unboxed-closures-move-some-upvars-in-by-ref-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funboxed-closures-move-some-upvars-in-by-ref-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funboxed-closures-move-some-upvars-in-by-ref-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-move-some-upvars-in-by-ref-closure.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -16,8 +16,8 @@ fn call<F>(f: F) where F : FnOnce() {\n }\n \n fn main() {\n-    let mut x = vec!(format!(\"Hello\"));\n-    let y = vec!(format!(\"World\"));\n+    let mut x = vec![format!(\"Hello\")];\n+    let y = vec![format!(\"World\")];\n     call(|| {\n         // Here: `x` must be captured with a mutable reference in\n         // order for us to append on it, and `y` must be captured by"}, {"sha": "1ef61008b3c2b056d88b3b07c45fbdf48678c222", "filename": "src/test/run-pass/unique-autoderef-index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funique-autoderef-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funique-autoderef-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-autoderef-index.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -13,6 +13,6 @@\n #![feature(box_syntax)]\n \n pub fn main() {\n-    let i: Box<_> = box vec!(100);\n+    let i: Box<_> = box vec![100];\n     assert_eq!((*i)[0], 100);\n }"}, {"sha": "6d638bbf562c7cfcdbc7501d03428c276057886e", "filename": "src/test/run-pass/unique-create.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funique-create.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funique-create.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-create.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -18,5 +18,5 @@ pub fn main() {\n }\n \n fn vec() {\n-    vec!(0);\n+    vec![0];\n }"}, {"sha": "1910d51bd0bcbfe4bbffe7f9d60fd89713a1679d", "filename": "src/test/run-pass/unique-drop-complex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funique-drop-complex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funique-drop-complex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-drop-complex.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -14,5 +14,5 @@\n #![feature(box_syntax)]\n \n pub fn main() {\n-    let _x: Box<_> = box vec!(0,0,0,0,0);\n+    let _x: Box<_> = box vec![0,0,0,0,0];\n }"}, {"sha": "ece206caa02e51cf26e2549f0ccd418090d1b71e", "filename": "src/test/run-pass/unique-in-vec-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -13,7 +13,7 @@\n #![feature(box_syntax)]\n \n pub fn main() {\n-    let mut a: Vec<Box<_>> = vec!(box 10);\n+    let mut a: Vec<Box<_>> = vec![box 10];\n     let b = a.clone();\n \n     assert_eq!(*a[0], 10);"}, {"sha": "bd965d41eea2c946708a79e660886fb9eb8e939b", "filename": "src/test/run-pass/unique-in-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funique-in-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Funique-in-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-in-vec.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -13,6 +13,6 @@\n #![feature(box_syntax)]\n \n pub fn main() {\n-    let vect : Vec<Box<_>> = vec!(box 100);\n+    let vect : Vec<Box<_>> = vec![box 100];\n     assert_eq!(vect[0], box 100);\n }"}, {"sha": "0a984429fabbf92ab1841d62f08b1952ba07c82a", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -15,7 +15,7 @@ use std::str;\n \n pub fn main() {\n     // Chars of 1, 2, 3, and 4 bytes\n-    let chs: Vec<char> = vec!('e', '\u00e9', '\u20ac', '\\u{10000}');\n+    let chs: Vec<char> = vec!['e', '\u00e9', '\u20ac', '\\u{10000}'];\n     let s: String = chs.iter().cloned().collect();\n     let schs: Vec<char> = s.chars().collect();\n "}, {"sha": "8ba8df57e542c59a09eb887bf221f14c6b9a1d30", "filename": "src/test/run-pass/vec-concat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-concat.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -11,8 +11,8 @@\n use std::vec;\n \n pub fn main() {\n-    let a: Vec<isize> = vec!(1, 2, 3, 4, 5);\n-    let b: Vec<isize> = vec!(6, 7, 8, 9, 0);\n+    let a: Vec<isize> = vec![1, 2, 3, 4, 5];\n+    let b: Vec<isize> = vec![6, 7, 8, 9, 0];\n     let mut v: Vec<isize> = a;\n     v.extend_from_slice(&b);\n     println!(\"{}\", v[9]);"}, {"sha": "5bf6a457df9b3f9578a3196286374cae2bd52d4b", "filename": "src/test/run-pass/vec-growth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec-growth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec-growth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-growth.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -11,7 +11,7 @@\n \n \n pub fn main() {\n-    let mut v = vec!(1);\n+    let mut v = vec![1];\n     v.push(2);\n     v.push(3);\n     v.push(4);"}, {"sha": "420f6a429f1f85da203816cd118dc3e3de102adc", "filename": "src/test/run-pass/vec-late-init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec-late-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec-late-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-late-init.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -11,6 +11,6 @@\n \n pub fn main() {\n     let mut later: Vec<isize> ;\n-    if true { later = vec!(1); } else { later = vec!(2); }\n+    if true { later = vec![1]; } else { later = vec![2]; }\n     println!(\"{}\", later[0]);\n }"}, {"sha": "135ecb474984594a8d44219f86c074865c5baa3d", "filename": "src/test/run-pass/vec-macro-with-trailing-comma.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec-macro-with-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec-macro-with-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-macro-with-trailing-comma.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -11,6 +11,6 @@\n \n \n pub fn main() {\n-    assert_eq!(vec!(1), vec!(1,));\n-    assert_eq!(vec!(1, 2, 3), vec!(1, 2, 3,));\n+    assert_eq!(vec![1], vec![1,]);\n+    assert_eq!(vec![1, 2, 3], vec![1, 2, 3,]);\n }"}, {"sha": "14a52cc4b5c55bbcc35aa870296a3b6ac21a15a3", "filename": "src/test/run-pass/vec-push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-push.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn main() { let mut v = vec!(1, 2, 3); v.push(1); }\n+pub fn main() { let mut v = vec![1, 2, 3]; v.push(1); }"}, {"sha": "1fed6a0be486c6786b085119a9ea9a9ae82cb9a2", "filename": "src/test/run-pass/vec-to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-to_str.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -10,9 +10,9 @@\n \n \n pub fn main() {\n-    assert_eq!(format!(\"{:?}\", vec!(0, 1)), \"[0, 1]\".to_string());\n+    assert_eq!(format!(\"{:?}\", vec![0, 1]), \"[0, 1]\".to_string());\n \n-    let foo = vec!(3, 4);\n+    let foo = vec![3, 4];\n     let bar: &[isize] = &[4, 5];\n \n     assert_eq!(format!(\"{:?}\", foo), \"[3, 4]\");"}, {"sha": "9cacb9db20ea9ab2274f793d89d282e725576d24", "filename": "src/test/run-pass/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -11,7 +11,7 @@\n \n \n pub fn main() {\n-    let v: Vec<isize> = vec!(10, 20);\n+    let v: Vec<isize> = vec![10, 20];\n     assert_eq!(v[0], 10);\n     assert_eq!(v[1], 20);\n     let mut x: usize = 0;"}, {"sha": "4c599e9c4289860b653e0df2aa5a706714021b59", "filename": "src/test/run-pass/while-with-break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n         i = i + 1;\n         if i == 95 {\n             let _v: Vec<isize> =\n-                vec!(1, 2, 3, 4, 5); // we check that it is freed by break\n+                vec![1, 2, 3, 4, 5]; // we check that it is freed by break\n \n             println!(\"breaking\");\n             break;"}, {"sha": "726d4bcdf1d083a222c2680b15e8a1dc49f6fc00", "filename": "src/test/ui/span/borrowck-ref-into-rvalue.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/test/compile-fail/borrowck/borrowck-ref-into-rvalue.rs"}, {"sha": "adbf39b3f7580f9d65b27ab52a2f1e18b93f32c5", "filename": "src/test/ui/span/borrowck-ref-into-rvalue.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,16 @@\n+error: borrowed value does not live long enough\n+  --> $DIR/borrowck-ref-into-rvalue.rs:18:5\n+   |\n+14 |         Some(ref m) => { //~ ERROR borrowed value does not live long enough\n+   |              ----- borrow occurs here\n+...\n+18 |     }\n+   |     ^ borrowed value dropped here while still borrowed\n+19 |     println!(\"{}\", *msg);\n+20 | }\n+   | - borrowed value needs to live until here\n+   |\n+   = note: consider using a `let` binding to increase its lifetime\n+\n+error: aborting due to previous error\n+"}, {"sha": "22f615cafd71eec06ce67f396d45542e0e1eb466", "filename": "src/test/ui/span/destructor-restrictions.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fdestructor-restrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fdestructor-restrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdestructor-restrictions.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/test/compile-fail/destructor-restrictions.rs"}, {"sha": "3253212c5b87ba389f519a689cc83de4256da09b", "filename": "src/test/ui/span/destructor-restrictions.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fdestructor-restrictions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fdestructor-restrictions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdestructor-restrictions.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,12 @@\n+error: `*a` does not live long enough\n+  --> $DIR/destructor-restrictions.rs:19:5\n+   |\n+18 |         *a.borrow() + 1    //~ ERROR `*a` does not live long enough\n+   |          - borrow occurs here\n+19 |     };\n+   |     ^- borrowed value needs to live until here\n+   |     |\n+   |     `*a` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+"}, {"sha": "6ad9c27b8b9101418959815e2a929c52f5ed2538", "filename": "src/test/ui/span/issue-11925.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fissue-11925.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fissue-11925.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-11925.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -4,8 +4,8 @@ error: `x` does not live long enough\n 18 |         let f = to_fn_once(move|| &x);\n    |                                    ^\n    |                                    |\n-   |                                    does not live long enough\n-   |                                    borrowed value only lives until here\n+   |                                    borrow occurs here\n+   |                                    `x` dropped here while still borrowed\n ...\n 23 | }\n    | - borrowed value needs to live until here"}, {"sha": "85a0002f2418081f2d43b4c12082fab811fcf94b", "filename": "src/test/ui/span/issue-23338-locals-die-before-temps-of-body.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fissue-23338-locals-die-before-temps-of-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fissue-23338-locals-die-before-temps-of-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23338-locals-die-before-temps-of-body.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -9,14 +9,14 @@ error: `y` does not live long enough\n    = note: values in a scope are dropped in the opposite order they are created\n \n error: `y` does not live long enough\n-  --> $DIR/issue-23338-locals-die-before-temps-of-body.rs:27:9\n+  --> $DIR/issue-23338-locals-die-before-temps-of-body.rs:28:5\n    |\n 27 |         y.borrow().clone() //~ ERROR `y` does not live long enough\n-   |         ^ does not live long enough\n+   |         - borrow occurs here\n 28 |     };\n-   |     -- borrowed value needs to live until here\n+   |     ^- borrowed value needs to live until here\n    |     |\n-   |     borrowed value only lives until here\n+   |     `y` dropped here while still borrowed\n \n error: aborting due to 2 previous errors\n "}, {"sha": "def0d9aced3c3e664447329d9bd52a898aa2ef7c", "filename": "src/test/ui/span/issue-24690.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fissue-24690.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fissue-24690.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24690.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A test to ensure that helpful `note` messages aren't emitted more often\n+//! than necessary.\n+\n+// Although there are three errors, we should only get two \"lint level defined\n+// here\" notes pointing at the `warnings` span, one for each error type.\n+#![deny(warnings)]\n+\n+fn main() {\n+    let theTwo = 2;\n+    let theOtherTwo = 2;\n+    println!(\"{}\", theTwo);\n+}"}, {"sha": "0d2a2ef751666adbd5ad98171f5b55994bef5227", "filename": "src/test/ui/span/issue-24690.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,32 @@\n+error: unused variable: `theOtherTwo`\n+  --> $DIR/issue-24690.rs:20:9\n+   |\n+20 |     let theOtherTwo = 2;\n+   |         ^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-24690.rs:16:9\n+   |\n+16 | #![deny(warnings)]\n+   |         ^^^^^^^^\n+\n+error: variable `theTwo` should have a snake case name such as `the_two`\n+  --> $DIR/issue-24690.rs:19:9\n+   |\n+19 |     let theTwo = 2;\n+   |         ^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-24690.rs:16:9\n+   |\n+16 | #![deny(warnings)]\n+   |         ^^^^^^^^\n+\n+error: variable `theOtherTwo` should have a snake case name such as `the_other_two`\n+  --> $DIR/issue-24690.rs:20:9\n+   |\n+20 |     let theOtherTwo = 2;\n+   |         ^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "8e968d90a2f65750aeb87e9a8551653334cf630f", "filename": "src/test/ui/span/mut-ptr-cant-outlive-ref.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fmut-ptr-cant-outlive-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fmut-ptr-cant-outlive-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmut-ptr-cant-outlive-ref.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/test/compile-fail/mut-ptr-cant-outlive-ref.rs"}, {"sha": "0417eb075af85ab15a799543f41784b07eb82fbd", "filename": "src/test/ui/span/mut-ptr-cant-outlive-ref.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fmut-ptr-cant-outlive-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fmut-ptr-cant-outlive-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmut-ptr-cant-outlive-ref.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,12 @@\n+error: `b` does not live long enough\n+  --> $DIR/mut-ptr-cant-outlive-ref.rs:19:5\n+   |\n+18 |         p = &*b; //~ ERROR `b` does not live long enough\n+   |               - borrow occurs here\n+19 |     }\n+   |     ^ `b` dropped here while still borrowed\n+20 | }\n+   | - borrowed value needs to live until here\n+\n+error: aborting due to previous error\n+"}, {"sha": "94967693ecf912d65d9c9db1b00b83bf83202d4c", "filename": "src/test/ui/span/range-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Frange-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Frange-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frange-2.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/test/compile-fail/range-2.rs"}, {"sha": "9f11de77be7e73dd9789ed987ff3c2fc8c99a50d", "filename": "src/test/ui/span/range-2.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Frange-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Frange-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frange-2.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,24 @@\n+error: `a` does not live long enough\n+  --> $DIR/range-2.rs:20:5\n+   |\n+17 |         &a..&b\n+   |          - borrow occurs here\n+...\n+20 |     };\n+   |     ^ `a` dropped here while still borrowed\n+21 | }\n+   | - borrowed value needs to live until here\n+\n+error: `b` does not live long enough\n+  --> $DIR/range-2.rs:20:5\n+   |\n+17 |         &a..&b\n+   |              - borrow occurs here\n+...\n+20 |     };\n+   |     ^ `b` dropped here while still borrowed\n+21 | }\n+   | - borrowed value needs to live until here\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "8ec6036762f4886b74a90adfac129eb7ec35e533", "filename": "src/test/ui/span/regionck-unboxed-closure-lifetimes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregionck-unboxed-closure-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregionck-unboxed-closure-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregionck-unboxed-closure-lifetimes.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/test/compile-fail/regionck-unboxed-closure-lifetimes.rs"}, {"sha": "9c369e03e33ab8fdeee92b50327180907be3fb02", "filename": "src/test/ui/span/regionck-unboxed-closure-lifetimes.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregionck-unboxed-closure-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregionck-unboxed-closure-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregionck-unboxed-closure-lifetimes.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,13 @@\n+error: `c` does not live long enough\n+  --> $DIR/regionck-unboxed-closure-lifetimes.rs:19:5\n+   |\n+17 |         let c_ref = &c; //~ ERROR `c` does not live long enough\n+   |                      - borrow occurs here\n+18 |         f = move |a: isize, b: isize| { a + b + *c_ref };\n+19 |     }\n+   |     ^ `c` dropped here while still borrowed\n+20 | }\n+   | - borrowed value needs to live until here\n+\n+error: aborting due to previous error\n+"}, {"sha": "053af49e0684b8b938d2d58a24d09f8b41dd2a38", "filename": "src/test/ui/span/regions-close-over-type-parameter-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-close-over-type-parameter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-close-over-type-parameter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-close-over-type-parameter-2.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/test/compile-fail/regions-close-over-type-parameter-2.rs"}, {"sha": "ea652da7da46f57b6bd68e52bffc284ed9e426f9", "filename": "src/test/ui/span/regions-close-over-type-parameter-2.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-close-over-type-parameter-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-close-over-type-parameter-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-close-over-type-parameter-2.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,13 @@\n+error: `tmp0` does not live long enough\n+  --> $DIR/regions-close-over-type-parameter-2.rs:35:5\n+   |\n+33 |         let tmp1 = &tmp0; //~ ERROR `tmp0` does not live long enough\n+   |                     ---- borrow occurs here\n+34 |         repeater3(tmp1)\n+35 |     };\n+   |     ^- borrowed value needs to live until here\n+   |     |\n+   |     `tmp0` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+"}, {"sha": "f588655d1afa85af5b19e7fc1af8c8a46594d233", "filename": "src/test/ui/span/regions-escape-loop-via-variable.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/test/compile-fail/regions-escape-loop-via-variable.rs"}, {"sha": "09f2154905f38d7f536c43e7c5db0a500e232e0b", "filename": "src/test/ui/span/regions-escape-loop-via-variable.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,12 @@\n+error: `x` does not live long enough\n+  --> $DIR/regions-escape-loop-via-variable.rs:22:5\n+   |\n+21 |         p = &x; //~ ERROR `x` does not live long enough\n+   |              - borrow occurs here\n+22 |     }\n+   |     ^ `x` dropped here while still borrowed\n+23 | }\n+   | - borrowed value needs to live until here\n+\n+error: aborting due to previous error\n+"}, {"sha": "8982b5cd98de49a9ed40dfae2311c5785eef60d7", "filename": "src/test/ui/span/regions-escape-loop-via-vec.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -11,7 +11,7 @@\n // The type of `y` ends up getting inferred to the type of the block.\n fn broken() {\n     let mut x = 3;\n-    let mut _y = vec!(&mut x);\n+    let mut _y = vec![&mut x];\n     //~^ NOTE borrow of `x` occurs here\n     //~| NOTE borrow of `x` occurs here\n     //~| NOTE borrow of `x` occurs here", "previous_filename": "src/test/compile-fail/regions-escape-loop-via-vec.rs"}, {"sha": "58f7849e443f5a52b8e07ac0f10b39adb826ef17", "filename": "src/test/ui/span/regions-escape-loop-via-vec.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,41 @@\n+error: `z` does not live long enough\n+  --> $DIR/regions-escape-loop-via-vec.rs:26:5\n+   |\n+22 |         _y.push(&mut z); //~ ERROR `z` does not live long enough\n+   |                      - borrow occurs here\n+...\n+26 |     }\n+   |     ^ `z` dropped here while still borrowed\n+27 |     //~^ NOTE borrowed value only lives until here\n+28 | }\n+   | - borrowed value needs to live until here\n+\n+error[E0503]: cannot use `x` because it was mutably borrowed\n+  --> $DIR/regions-escape-loop-via-vec.rs:18:11\n+   |\n+14 |     let mut _y = vec![&mut x];\n+   |                            - borrow of `x` occurs here\n+...\n+18 |     while x < 10 { //~ ERROR cannot use `x` because it was mutably borrowed\n+   |           ^ use of borrowed `x`\n+\n+error[E0503]: cannot use `x` because it was mutably borrowed\n+  --> $DIR/regions-escape-loop-via-vec.rs:20:13\n+   |\n+14 |     let mut _y = vec![&mut x];\n+   |                            - borrow of `x` occurs here\n+...\n+20 |         let mut z = x; //~ ERROR cannot use `x` because it was mutably borrowed\n+   |             ^^^^^ use of borrowed `x`\n+\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/regions-escape-loop-via-vec.rs:24:9\n+   |\n+14 |     let mut _y = vec![&mut x];\n+   |                            - borrow of `x` occurs here\n+...\n+24 |         x += 1; //~ ERROR cannot assign\n+   |         ^^^^^^ assignment to borrowed `x` occurs here\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "a05658e9e581db90f01f45d2f4ffbd5c5baa5142", "filename": "src/test/ui/span/regions-infer-borrow-scope-within-loop.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-infer-borrow-scope-within-loop.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs"}, {"sha": "0e7b64ec2b36c08db9dca69805871f504a025146", "filename": "src/test/ui/span/regions-infer-borrow-scope-within-loop.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-infer-borrow-scope-within-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fregions-infer-borrow-scope-within-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-infer-borrow-scope-within-loop.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,14 @@\n+error: `*x` does not live long enough\n+  --> $DIR/regions-infer-borrow-scope-within-loop.rs:28:5\n+   |\n+24 |         y = borrow(&*x); //~ ERROR `*x` does not live long enough\n+   |                     -- borrow occurs here\n+...\n+28 |     }\n+   |     ^ `*x` dropped here while still borrowed\n+29 |     assert!(*y != 0);\n+30 | }\n+   | - borrowed value needs to live until here\n+\n+error: aborting due to previous error\n+"}, {"sha": "1b7718d2283a7bfd6a617c112f8a5d19bdd209a6", "filename": "src/test/ui/span/send-is-not-static-ensures-scoping.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-ensures-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-ensures-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-ensures-scoping.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/test/compile-fail/send-is-not-static-ensures-scoping.rs"}, {"sha": "5897921476d3ffde2d44dbc33e856264923c1148", "filename": "src/test/ui/span/send-is-not-static-ensures-scoping.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-ensures-scoping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-ensures-scoping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-ensures-scoping.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,28 @@\n+error: `x` does not live long enough\n+  --> $DIR/send-is-not-static-ensures-scoping.rs:32:5\n+   |\n+26 |         let y = &x; //~ ERROR `x` does not live long enough\n+   |                  - borrow occurs here\n+...\n+32 |     };\n+   |     ^ `x` dropped here while still borrowed\n+...\n+35 | }\n+   | - borrowed value needs to live until here\n+\n+error: `y` does not live long enough\n+  --> $DIR/send-is-not-static-ensures-scoping.rs:29:22\n+   |\n+28 |         scoped(|| {\n+   |                -- capture occurs here\n+29 |             let _z = y;\n+   |                      ^ does not live long enough\n+...\n+32 |     };\n+   |     - borrowed value only lives until here\n+...\n+35 | }\n+   | - borrowed value needs to live until here\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "d9d3706586ba9e3c17615b0bc141140b8ed54043", "filename": "src/test/ui/span/send-is-not-static-std-sync-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync-2.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/test/compile-fail/send-is-not-static-std-sync-2.rs"}, {"sha": "08f85f17bf8adaa861f8e4d47e8cdf00e826f66a", "filename": "src/test/ui/span/send-is-not-static-std-sync-2.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync-2.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,36 @@\n+error: `x` does not live long enough\n+  --> $DIR/send-is-not-static-std-sync-2.rs:22:5\n+   |\n+21 |         Mutex::new(&x) //~ ERROR does not live long enough\n+   |                     - borrow occurs here\n+22 |     };\n+   |     ^ `x` dropped here while still borrowed\n+...\n+25 | }\n+   | - borrowed value needs to live until here\n+\n+error: `x` does not live long enough\n+  --> $DIR/send-is-not-static-std-sync-2.rs:31:5\n+   |\n+30 |         RwLock::new(&x) //~ ERROR does not live long enough\n+   |                      - borrow occurs here\n+31 |     };\n+   |     ^ `x` dropped here while still borrowed\n+32 |     let _dangling = *lock.read().unwrap();\n+33 | }\n+   | - borrowed value needs to live until here\n+\n+error: `x` does not live long enough\n+  --> $DIR/send-is-not-static-std-sync-2.rs:41:5\n+   |\n+39 |         let _ = tx.send(&x); //~ ERROR does not live long enough\n+   |                          - borrow occurs here\n+40 |         (tx, rx)\n+41 |     };\n+   |     ^ `x` dropped here while still borrowed\n+...\n+44 | }\n+   | - borrowed value needs to live until here\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "8ec2fe8a1ec897492a55a85a76e08a80609428e6", "filename": "src/test/ui/span/send-is-not-static-std-sync.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/test/compile-fail/send-is-not-static-std-sync.rs"}, {"sha": "a86cf1e58846dbafb935fed38393a402f52f75d2", "filename": "src/test/ui/span/send-is-not-static-std-sync.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,56 @@\n+error: `z` does not live long enough\n+  --> $DIR/send-is-not-static-std-sync.rs:27:5\n+   |\n+26 |         *lock.lock().unwrap() = &z; //~ ERROR does not live long enough\n+   |                                  - borrow occurs here\n+27 |     }\n+   |     ^ `z` dropped here while still borrowed\n+28 | }\n+   | - borrowed value needs to live until here\n+\n+error[E0505]: cannot move out of `y` because it is borrowed\n+  --> $DIR/send-is-not-static-std-sync.rs:23:10\n+   |\n+22 |     *lock.lock().unwrap() = &*y;\n+   |                              -- borrow of `*y` occurs here\n+23 |     drop(y); //~ ERROR cannot move out\n+   |          ^ move out of `y` occurs here\n+\n+error: `z` does not live long enough\n+  --> $DIR/send-is-not-static-std-sync.rs:39:5\n+   |\n+38 |         *lock.write().unwrap() = &z; //~ ERROR does not live long enough\n+   |                                   - borrow occurs here\n+39 |     }\n+   |     ^ `z` dropped here while still borrowed\n+40 | }\n+   | - borrowed value needs to live until here\n+\n+error[E0505]: cannot move out of `y` because it is borrowed\n+  --> $DIR/send-is-not-static-std-sync.rs:35:10\n+   |\n+34 |     *lock.write().unwrap() = &*y;\n+   |                               -- borrow of `*y` occurs here\n+35 |     drop(y); //~ ERROR cannot move out\n+   |          ^ move out of `y` occurs here\n+\n+error: `z` does not live long enough\n+  --> $DIR/send-is-not-static-std-sync.rs:53:5\n+   |\n+52 |         tx.send(&z).unwrap(); //~ ERROR does not live long enough\n+   |                  - borrow occurs here\n+53 |     }\n+   |     ^ `z` dropped here while still borrowed\n+54 | }\n+   | - borrowed value needs to live until here\n+\n+error[E0505]: cannot move out of `y` because it is borrowed\n+  --> $DIR/send-is-not-static-std-sync.rs:49:10\n+   |\n+48 |     tx.send(&*y);\n+   |              -- borrow of `*y` occurs here\n+49 |     drop(y); //~ ERROR cannot move out\n+   |          ^ move out of `y` occurs here\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "b9d292fd1568552dcea5450360e00cbc213283c7", "filename": "src/test/ui/span/wf-method-late-bound-regions.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fwf-method-late-bound-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fwf-method-late-bound-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fwf-method-late-bound-regions.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "previous_filename": "src/test/compile-fail/wf-method-late-bound-regions.rs"}, {"sha": "aeac3102fbf3a94bb989bb332c55b538b111a8bf", "filename": "src/test/ui/span/wf-method-late-bound-regions.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fwf-method-late-bound-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftest%2Fui%2Fspan%2Fwf-method-late-bound-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fwf-method-late-bound-regions.stderr?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -0,0 +1,13 @@\n+error: `pointer` does not live long enough\n+  --> $DIR/wf-method-late-bound-regions.rs:31:5\n+   |\n+30 |         f2.xmute(&pointer) //~ ERROR `pointer` does not live long enough\n+   |                   ------- borrow occurs here\n+31 |     };\n+   |     ^ `pointer` dropped here while still borrowed\n+32 |     println!(\"{}\", dangling);\n+33 | }\n+   | - borrowed value needs to live until here\n+\n+error: aborting due to previous error\n+"}, {"sha": "2dc7cdbf935025c1b9e592c00f051e1ed86db958", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -73,7 +73,7 @@ fn main() {\n pub fn parse_config(args: Vec<String> ) -> Config {\n \n     let groups : Vec<getopts::OptGroup> =\n-        vec!(reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\"),\n+        vec![reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\"),\n           reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\"),\n           reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\"),\n           reqopt(\"\", \"rustdoc-path\", \"path to rustdoc to use for compiling\", \"PATH\"),\n@@ -111,7 +111,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           reqopt(\"\", \"llvm-components\", \"list of LLVM components built in\", \"LIST\"),\n           reqopt(\"\", \"llvm-cxxflags\", \"C++ flags for LLVM\", \"FLAGS\"),\n           optopt(\"\", \"nodejs\", \"the name of nodejs\", \"PATH\"),\n-          optflag(\"h\", \"help\", \"show this message\"));\n+          optflag(\"h\", \"help\", \"show this message\")];\n \n     let (argv0, args_) = args.split_first().unwrap();\n     if args.len() == 1 || args[1] == \"-h\" || args[1] == \"--help\" {"}, {"sha": "03c05f919b79e95454c189b726c10ae7370ec2c7", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -253,7 +253,7 @@ impl<'test> TestCx<'test> {\n \n         let mut src = String::new();\n         File::open(&self.testpaths.file).unwrap().read_to_string(&mut src).unwrap();\n-        let mut srcs = vec!(src);\n+        let mut srcs = vec![src];\n \n         let mut round = 0;\n         while round < rounds {\n@@ -335,13 +335,13 @@ impl<'test> TestCx<'test> {\n                     -> ProcArgs {\n         let aux_dir = self.aux_output_dir_name();\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec!(\"-\".to_owned(),\n+        let mut args = vec![\"-\".to_owned(),\n                             \"-Zunstable-options\".to_owned(),\n                             \"--unpretty\".to_owned(),\n                             pretty_type,\n                             format!(\"--target={}\", self.config.target),\n                             \"-L\".to_owned(),\n-                            aux_dir.to_str().unwrap().to_owned());\n+                            aux_dir.to_str().unwrap().to_owned()];\n         args.extend(self.split_maybe_args(&self.config.target_rustcflags));\n         args.extend(self.props.compile_flags.iter().cloned());\n         return ProcArgs {\n@@ -388,15 +388,15 @@ actual:\\n\\\n         self.create_dir_racy(&out_dir);\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec!(\"-\".to_owned(),\n+        let mut args = vec![\"-\".to_owned(),\n                             \"-Zno-trans\".to_owned(),\n                             \"--out-dir\".to_owned(),\n                             out_dir.to_str().unwrap().to_owned(),\n                             format!(\"--target={}\", target),\n                             \"-L\".to_owned(),\n                             self.config.build_base.to_str().unwrap().to_owned(),\n                             \"-L\".to_owned(),\n-                            aux_dir.to_str().unwrap().to_owned());\n+                            aux_dir.to_str().unwrap().to_owned()];\n         if let Some(revision) = self.revision {\n             args.extend(vec![\n                 format!(\"--cfg\"),\n@@ -487,7 +487,7 @@ actual:\\n\\\n                                  exe_file.to_str().unwrap().to_owned(),\n                                  self.config.adb_test_dir.clone()\n                              ],\n-                             vec!((\"\".to_owned(), \"\".to_owned())),\n+                             vec![(\"\".to_owned(), \"\".to_owned())],\n                              Some(\"\".to_owned()))\n                     .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n \n@@ -499,7 +499,7 @@ actual:\\n\\\n                                  \"tcp:5039\".to_owned(),\n                                  \"tcp:5039\".to_owned()\n                              ],\n-                             vec!((\"\".to_owned(), \"\".to_owned())),\n+                             vec![(\"\".to_owned(), \"\".to_owned())],\n                              Some(\"\".to_owned()))\n                     .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n \n@@ -520,8 +520,8 @@ actual:\\n\\\n                                                               \"shell\".to_owned(),\n                                                               adb_arg.clone()\n                                                           ],\n-                                                          vec!((\"\".to_owned(),\n-                                                                \"\".to_owned())),\n+                                                          vec![(\"\".to_owned(),\n+                                                                \"\".to_owned())],\n                                                           Some(\"\".to_owned()))\n                     .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n                 loop {\n@@ -535,10 +535,10 @@ actual:\\n\\\n                 let debugger_script = self.make_out_name(\"debugger.script\");\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 let debugger_opts =\n-                    vec!(\"-quiet\".to_owned(),\n+                    vec![\"-quiet\".to_owned(),\n                          \"-batch\".to_owned(),\n                          \"-nx\".to_owned(),\n-                         format!(\"-command={}\", debugger_script.to_str().unwrap()));\n+                         format!(\"-command={}\", debugger_script.to_str().unwrap())];\n \n                 let mut gdb_path = tool_path;\n                 gdb_path.push_str(&format!(\"/bin/{}-gdb\", self.config.target));\n@@ -550,7 +550,7 @@ actual:\\n\\\n                                  &gdb_path,\n                                  None,\n                                  &debugger_opts,\n-                                 vec!((\"\".to_owned(), \"\".to_owned())),\n+                                 vec![(\"\".to_owned(), \"\".to_owned())],\n                                  None)\n                     .expect(&format!(\"failed to exec `{:?}`\", gdb_path));\n                 let cmdline = {\n@@ -642,10 +642,10 @@ actual:\\n\\\n \n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 let debugger_opts =\n-                    vec!(\"-quiet\".to_owned(),\n+                    vec![\"-quiet\".to_owned(),\n                          \"-batch\".to_owned(),\n                          \"-nx\".to_owned(),\n-                         format!(\"-command={}\", debugger_script.to_str().unwrap()));\n+                         format!(\"-command={}\", debugger_script.to_str().unwrap())];\n \n                 let proc_args = ProcArgs {\n                     prog: debugger().to_owned(),\n@@ -830,9 +830,9 @@ actual:\\n\\\n         let command_directive = format!(\"{}-command\", debugger_prefix);\n         let check_directive = format!(\"{}-check\", debugger_prefix);\n \n-        let mut breakpoint_lines = vec!();\n-        let mut commands = vec!();\n-        let mut check_lines = vec!();\n+        let mut breakpoint_lines = vec![];\n+        let mut commands = vec![];\n+        let mut check_lines = vec![];\n         let mut counter = 1;\n         let reader = BufReader::new(File::open(&self.testpaths.file).unwrap());\n         for line in reader.lines() {\n@@ -1120,8 +1120,8 @@ actual:\\n\\\n     fn compile_test(&self) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let link_args = vec!(\"-L\".to_owned(),\n-                             aux_dir.to_str().unwrap().to_owned());\n+        let link_args = vec![\"-L\".to_owned(),\n+                             aux_dir.to_str().unwrap().to_owned()];\n         let args = self.make_compile_args(link_args,\n                                           &self.testpaths.file,\n                                           TargetLocation::ThisFile(self.make_exe_name()));\n@@ -1231,9 +1231,9 @@ actual:\\n\\\n                 if (self.config.target.contains(\"musl\") && !aux_props.force_host) ||\n                     self.config.target.contains(\"emscripten\")\n                 {\n-                    vec!(\"--crate-type=lib\".to_owned())\n+                    vec![\"--crate-type=lib\".to_owned()]\n                 } else {\n-                    vec!(\"--crate-type=dylib\".to_owned())\n+                    vec![\"--crate-type=dylib\".to_owned()]\n                 }\n             };\n             crate_type.extend(extra_link_args.clone());\n@@ -1315,10 +1315,10 @@ actual:\\n\\\n         };\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec!(input_file.to_str().unwrap().to_owned(),\n+        let mut args = vec![input_file.to_str().unwrap().to_owned(),\n                             \"-L\".to_owned(),\n                             self.config.build_base.to_str().unwrap().to_owned(),\n-                            format!(\"--target={}\", target));\n+                            format!(\"--target={}\", target)];\n \n         if let Some(revision) = self.revision {\n             args.extend(vec![\n@@ -1613,7 +1613,7 @@ actual:\\n\\\n                                            args.prog.clone(),\n                                            self.config.adb_test_dir.clone()\n                                        ],\n-                                       vec!((\"\".to_owned(), \"\".to_owned())),\n+                                       vec![(\"\".to_owned(), \"\".to_owned())],\n                                        Some(\"\".to_owned()))\n             .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n \n@@ -1645,7 +1645,7 @@ actual:\\n\\\n                      &self.config.adb_path,\n                      None,\n                      &runargs,\n-                     vec!((\"\".to_owned(), \"\".to_owned())), Some(\"\".to_owned()))\n+                     vec![(\"\".to_owned(), \"\".to_owned())], Some(\"\".to_owned()))\n             .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n \n         // get exitcode of result\n@@ -1659,7 +1659,7 @@ actual:\\n\\\n                          &self.config.adb_path,\n                          None,\n                          &runargs,\n-                         vec!((\"\".to_owned(), \"\".to_owned())),\n+                         vec![(\"\".to_owned(), \"\".to_owned())],\n                          Some(\"\".to_owned()))\n             .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n \n@@ -1683,7 +1683,7 @@ actual:\\n\\\n                          &self.config.adb_path,\n                          None,\n                          &runargs,\n-                         vec!((\"\".to_owned(), \"\".to_owned())),\n+                         vec![(\"\".to_owned(), \"\".to_owned())],\n                          Some(\"\".to_owned()))\n             .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n \n@@ -1698,7 +1698,7 @@ actual:\\n\\\n                          &self.config.adb_path,\n                          None,\n                          &runargs,\n-                         vec!((\"\".to_owned(), \"\".to_owned())),\n+                         vec![(\"\".to_owned(), \"\".to_owned())],\n                          Some(\"\".to_owned()))\n             .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n \n@@ -1730,8 +1730,8 @@ actual:\\n\\\n                                                        .to_owned(),\n                                                    self.config.adb_test_dir.to_owned(),\n                                                ],\n-                                               vec!((\"\".to_owned(),\n-                                                     \"\".to_owned())),\n+                                               vec![(\"\".to_owned(),\n+                                                     \"\".to_owned())],\n                                                Some(\"\".to_owned()))\n                     .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n \n@@ -1749,9 +1749,9 @@ actual:\\n\\\n     fn compile_test_and_save_ir(&self) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut link_args = vec!(\"-L\".to_owned(),\n-                                 aux_dir.to_str().unwrap().to_owned());\n-        let llvm_args = vec!(\"--emit=llvm-ir\".to_owned(),);\n+        let mut link_args = vec![\"-L\".to_owned(),\n+                                 aux_dir.to_str().unwrap().to_owned()];\n+        let llvm_args = vec![\"--emit=llvm-ir\".to_owned(),];\n         link_args.extend(llvm_args);\n         let args = self.make_compile_args(link_args,\n                                           &self.testpaths.file,\n@@ -1768,8 +1768,8 @@ actual:\\n\\\n         let proc_args = ProcArgs {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             prog: prog.to_str().unwrap().to_owned(),\n-            args: vec!(format!(\"-input-file={}\", irfile.to_str().unwrap()),\n-                       self.testpaths.file.to_str().unwrap().to_owned())\n+            args: vec![format!(\"-input-file={}\", irfile.to_str().unwrap()),\n+                       self.testpaths.file.to_str().unwrap().to_owned()]\n         };\n         self.compose_and_run(proc_args, Vec::new(), \"\", None, None)\n     }"}, {"sha": "c5f72127a9c805230704ed088eee5d2d61b0f9e8", "filename": "src/tools/rustbook/book.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftools%2Frustbook%2Fbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftools%2Frustbook%2Fbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fbook.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -94,16 +94,16 @@ pub fn parse_summary(input: &mut Read, src: &Path) -> Result<Book, Vec<String>>\n         }\n     }\n \n-    let mut top_items = vec!();\n-    let mut stack = vec!();\n-    let mut errors = vec!();\n+    let mut top_items = vec![];\n+    let mut stack = vec![];\n+    let mut errors = vec![];\n \n     // always include the introduction\n     top_items.push(BookItem {\n         title: \"Introduction\".to_string(),\n         path: PathBuf::from(\"README.md\"),\n         path_to_root: PathBuf::from(\"\"),\n-        children: vec!(),\n+        children: vec![],\n     });\n \n     for line_result in BufReader::new(input).lines() {\n@@ -142,7 +142,7 @@ pub fn parse_summary(input: &mut Read, src: &Path) -> Result<Book, Vec<String>>\n             title: title,\n             path: path_from_root,\n             path_to_root: path_to_root,\n-            children: vec!(),\n+            children: vec![],\n         };\n         let level = indent.chars().map(|c| -> usize {\n             match c {"}, {"sha": "a5e4e5a4c2672bf6bf585e2e259fbf91e9087e19", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74dc845c2de24924f143e345358103102c9f8ed5/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=74dc845c2de24924f143e345358103102c9f8ed5", "patch": "@@ -57,22 +57,18 @@ const EXCEPTION_PATHS: &'static [&'static str] = &[\n     \"src/libpanic_abort\",\n     \"src/libpanic_unwind\",\n     \"src/libunwind\",\n-    \"src/libstd/sys/unix\", // This is where platform-specific code for std should live\n-    \"src/libstd/sys/windows\", // Ditto\n+    \"src/libstd/sys/\", // Platform-specific code for std lives here.\n+                       // This has the trailing slash so that sys_common is not excepted.\n     \"src/libstd/os\", // Platform-specific public interfaces\n     \"src/rtstartup\", // Not sure what to do about this. magic stuff for mingw\n \n     // temporary exceptions\n-    \"src/libstd/lib.rs\", // This could probably be done within the sys directory\n     \"src/libstd/rtdeps.rs\", // Until rustbuild replaces make\n     \"src/libstd/path.rs\",\n-    \"src/libstd/io/stdio.rs\",\n-    \"src/libstd/num/f32.rs\",\n-    \"src/libstd/num/f64.rs\",\n-    \"src/libstd/thread/local.rs\",\n-    \"src/libstd/sys/common/mod.rs\",\n-    \"src/libstd/sys/common/net.rs\",\n-    \"src/libstd/sys/common/util.rs\",\n+    \"src/libstd/f32.rs\",\n+    \"src/libstd/f64.rs\",\n+    \"src/libstd/sys_common/mod.rs\",\n+    \"src/libstd/sys_common/net.rs\",\n     \"src/libterm\", // Not sure how to make this crate portable, but test needs it\n     \"src/libtest\", // Probably should defer to unstable std::sys APIs\n "}]}