{"sha": "81fc2d8728b622275d55243cbacbc7834641503f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZmMyZDg3MjhiNjIyMjc1ZDU1MjQzY2JhY2JjNzgzNDY0MTUwM2Y=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-31T04:39:19Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-31T05:23:53Z"}, "message": "rustc: Remove unneeded type params from alt patterns", "tree": {"sha": "9fd6257c998f76d41dcf91cdc746a1d426a57a6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fd6257c998f76d41dcf91cdc746a1d426a57a6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81fc2d8728b622275d55243cbacbc7834641503f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81fc2d8728b622275d55243cbacbc7834641503f", "html_url": "https://github.com/rust-lang/rust/commit/81fc2d8728b622275d55243cbacbc7834641503f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81fc2d8728b622275d55243cbacbc7834641503f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1", "html_url": "https://github.com/rust-lang/rust/commit/ed0eb8f45ab979f866208a0c06179bd2f73a2ec1"}], "stats": {"total": 542, "additions": 271, "deletions": 271}, "files": [{"sha": "fe5c992d53122de856ed162367e2c21a31f4d81c", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -272,8 +272,8 @@ fn build_session_options(str binary, getopts::match match)\n     };\n \n     auto sysroot = alt (sysroot_opt) {\n-        case (none[str]) { get_default_sysroot(binary) }\n-        case (some[str](?s)) { s }\n+        case (none) { get_default_sysroot(binary) }\n+        case (some(?s)) { s }\n     };\n \n     let @session::options sopts =\n@@ -376,7 +376,7 @@ fn main(vec[str] args) {\n         ret;\n     } else {\n         alt (output_file) {\n-            case (none[str]) {\n+            case (none) {\n                 let vec[str] parts = str::split(ifile, '.' as u8);\n                 vec::pop[str](parts);\n                 saved_out_filename = parts.(0);\n@@ -392,7 +392,7 @@ fn main(vec[str] args) {\n                 auto ofile = str::connect(parts, \".\");\n                 compile_input(sess, env, ifile, ofile);\n             }\n-            case (some[str](?ofile)) {\n+            case (some(?ofile)) {\n                 saved_out_filename = ofile;\n                 compile_input(sess, env, ifile, ofile);\n             }"}, {"sha": "442d6177fa3f36c5987b279be242da3748516e6c", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -182,8 +182,8 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n             auto len = parse_hex(st);\n             assert (next(st) as char == '#');\n             alt (st.tcx.rcache.find(tup(st.crate,pos,len))) {\n-                case (some[ty::t](?tt)) { ret tt; }\n-                case (none[ty::t]) {\n+                case (some(?tt)) { ret tt; }\n+                case (none) {\n                     auto ps = @rec(pos=pos, len=len with *st);\n                     auto tt = parse_ty(ps, sd);\n                     st.tcx.rcache.insert(tup(st.crate,pos,len), tt);\n@@ -262,10 +262,10 @@ fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty::arg], ty::t,\n     st.pos = st.pos + 1u;\n     auto res = parse_ty_or_bang(st, sd);\n     alt (res) {\n-        case (a_bang[ty::t]) {\n+        case (a_bang) {\n             ret tup(inputs, ty::mk_bot(st.tcx), ast::noreturn);\n         }\n-        case (a_ty[ty::t](?t)) {\n+        case (a_ty(?t)) {\n             ret tup(inputs, t, ast::return);\n         }\n     }\n@@ -434,7 +434,7 @@ fn load_crate(session::session sess,\n     for (str library_search_path in library_search_paths) {\n         auto path = fs::connect(library_search_path, filename);\n         alt (get_metadata_section(path)) {\n-            case (option::some[vec[u8]](?cvec)) {\n+            case (option::some(?cvec)) {\n                 sess.set_external_crate(cnum, rec(name=ident, data=cvec));\n                 ret;\n             }\n@@ -594,10 +594,10 @@ fn get_tag_variants(ty::ctxt tcx, ast::def_id def)\n \n fn list_file_metadata(str path, io::writer out) {\n     alt (get_metadata_section(path)) {\n-        case (option::some[vec[u8]](?bytes)) {\n+        case (option::some(?bytes)) {\n             list_crate_metadata(bytes, out);\n         }\n-        case (option::none[vec[u8]]) {\n+        case (option::none) {\n             out.write_str(\"Could not find metadata in \" + path + \".\\n\");\n         }\n     }"}, {"sha": "d5a76372846d6d880297b2b4335d6eb69ae37699", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -300,7 +300,7 @@ fn eval_crate_directive_expr(ctx cx,\n             }\n \n             alt (elopt) {\n-                case (some[@ast::expr](?els)) {\n+                case (some(?els)) {\n                     ret eval_crate_directive_expr(cx, e, els, prefix,\n                                                   view_items, items);\n                 }\n@@ -370,10 +370,10 @@ fn eval_crate_directive(ctx cx,\n \n             auto file_path = id + \".rs\";\n             alt (file_opt) {\n-                case (some[filename](?f)) {\n+                case (some(?f)) {\n                     file_path = f;\n                 }\n-                case (none[filename]) {}\n+                case (none) {}\n             }\n \n             auto full_path = prefix + std::fs::path_sep() + file_path;\n@@ -401,10 +401,10 @@ fn eval_crate_directive(ctx cx,\n \n             auto path = id;\n             alt (dir_opt) {\n-                case (some[filename](?d)) {\n+                case (some(?d)) {\n                     path = d;\n                 }\n-                case (none[filename]) {}\n+                case (none) {}\n             }\n \n             auto full_path = prefix + std::fs::path_sep() + path;"}, {"sha": "858f9f9f5689a1de829c5bc28b6d938f60ac4ca1", "filename": "src/comp/front/extenv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Ffront%2Fextenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Ffront%2Fextenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextenv.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -28,10 +28,10 @@ fn expand_syntax_ext(parser::parser p,\n \n     auto var = expr_to_str(p, args.(0));\n     alt (generic_os::getenv(var)) {\n-        case (option::none[str]) {\n+        case (option::none) {\n             ret make_new_str(p, sp, \"\");\n         }\n-        case (option::some[str](?s)) {\n+        case (option::some(?s)) {\n             ret make_new_str(p, sp, s);\n         }\n     }"}, {"sha": "cb8ca4f6ce0cc17450ce9dd65d74c0ef9f31edfa", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -313,7 +313,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n         auto unsupported = \"conversion not supported in #fmt string\";\n \n         alt (cnv.param) {\n-            case (option::none[int]) {\n+            case (option::none) {\n             }\n             case (_) {\n                 log_err unsupported;\n@@ -407,7 +407,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n \n     fn log_conv(conv c) {\n         alt (c.param) {\n-            case (some[int](?p)) {\n+            case (some(?p)) {\n                 log \"param: \" + std::int::to_str(p, 10u);\n             }\n             case (_) {"}, {"sha": "ef70688010ee444c86a1cf3a205f20140a5314b3", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -367,10 +367,10 @@ fn scan_number(char c, &reader rdr) -> token::token {\n         c = rdr.curr();\n         auto exponent_str = scan_exponent(rdr);\n         alt (exponent_str) {\n-            case (some[str](?s)) {\n+            case (some(?s)) {\n                 float_str += s;\n             }\n-            case (none[str]) {\n+            case (none) {\n             }\n         }\n \n@@ -400,11 +400,11 @@ fn scan_number(char c, &reader rdr) -> token::token {\n \n     auto maybe_exponent = scan_exponent(rdr);\n     alt(maybe_exponent) {\n-        case(some[str](?s)) {\n+        case(some(?s)) {\n             ret token::LIT_FLOAT(interner::intern[str](*rdr.get_interner(),\n                                                        dec_str + s));\n         }\n-        case(none[str]) {\n+        case(none) {\n             ret token::LIT_INT(accum_int);\n         }\n     }"}, {"sha": "e48b1f4c52e6b32aa1552be4be17f3373717e5c3", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -352,10 +352,10 @@ fn parse_ty_fn(ast::proto proto, &parser p, uint lo)\n         p.bump();\n         auto tmp = parse_ty_or_bang(p);\n         alt (tmp) {\n-            case (a_ty[@ast::ty](?t)) {\n+            case (a_ty(?t)) {\n                 output = t;\n             }\n-            case (a_bang[@ast::ty]) {\n+            case (a_bang) {\n                 output = @spanned(lo, inputs.span.hi, ast::ty_bot);\n                 cf = ast::noreturn;\n             }\n@@ -602,7 +602,7 @@ fn parse_seq_to_end[T](token::token ket,\n     let vec[T] v = [];\n     while (p.peek() != ket) {\n         alt(sep) {\n-            case (some[token::token](?t)) {\n+            case (some(?t)) {\n                 if (first) {\n                     first = false;\n                 } else {\n@@ -1666,7 +1666,7 @@ fn parse_block(&parser p) -> ast::block {\n             case (_) {\n                 auto stmt = parse_stmt(p);\n                 alt (stmt_to_expr(stmt)) {\n-                    case (some[@ast::expr](?e)) {\n+                    case (some(?e)) {\n                         alt (p.peek()) {\n                             case (token::SEMI) {\n                                 p.bump();\n@@ -1684,7 +1684,7 @@ fn parse_block(&parser p) -> ast::block {\n                             }\n                         }\n                     }\n-                    case (none[@ast::expr]) {\n+                    case (none) {\n                         // Not an expression statement.\n                         stmts += [stmt];\n                         // FIXME: crazy differentiation between conditions\n@@ -1748,11 +1748,11 @@ fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n     }\n \n     alt (res) {\n-        case (a_ty[@ast::ty](?t)) {\n+        case (a_ty(?t)) {\n             ret rec(inputs=inputs.node, output=t,\n               purity=purity, cf=ast::return);\n         }\n-        case (a_bang[@ast::ty]) {\n+        case (a_bang) {\n             ret rec(inputs=inputs.node,\n                     output=@spanned(p.get_lo_pos(),\n                                     p.get_hi_pos(), ast::ty_bot),\n@@ -2218,7 +2218,7 @@ fn parse_rest_import_name(&parser p, ast::ident first,\n     auto hi = p.get_hi_pos();\n     auto import_decl;\n     alt (def_ident) {\n-        case(some[ast::ident](?i)) {\n+        case(some(?i)) {\n             if (glob) {\n                 p.err(\"globbed imports can't be renamed\");\n             }"}, {"sha": "c7e4151dbe7accefcc9f804a74a8fad2912e24f3", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -83,8 +83,8 @@ mod Encode {\n             case (ac_no_abbrevs) {\n                 auto result_str;\n                 alt (cx.tcx.short_names_cache.find(t)) {\n-                    case (some[str](?s)) { result_str = s; }\n-                    case (none[str]) {\n+                    case (some(?s)) { result_str = s; }\n+                    case (none) {\n                         auto sw = io::string_writer();\n                         enc_sty(sw.get_writer(), cx, ty::struct(cx.tcx, t));\n                         result_str = sw.get_str();\n@@ -95,11 +95,11 @@ mod Encode {\n             }\n             case (ac_use_abbrevs(?abbrevs)) {\n                 alt (abbrevs.find(t)) {\n-                    case (some[ty_abbrev](?a)) {\n+                    case (some(?a)) {\n                         w.write_str(a.s);\n                         ret;\n                     }\n-                    case (none[ty_abbrev]) {\n+                    case (none) {\n                         auto pos = w.get_buf_writer().tell();\n                         auto ss = enc_sty(w, cx, ty::struct(cx.tcx, t));\n                         auto end = w.get_buf_writer().tell();"}, {"sha": "f7ff7fdde7b2e7ecb29b185d88dc3fcdb77af912", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -208,7 +208,7 @@ fn map_crate(&@env e, &ast::crate c) {\n     fn link_glob(@env e, @mutable list[scope] sc, &@ast::view_item vi) {\n         fn find_mod(@env e, list[scope] sc) -> @indexed_mod {\n             alt (sc) {\n-                case (cons[scope](scope_item(?i), ?tl)) {\n+                case (cons(scope_item(?i), ?tl)) {\n                     alt(i.node) {\n                         case (ast::item_mod(_, _, ?defid)) {\n                             ret e.mod_map.get(defid._1);\n@@ -506,11 +506,11 @@ fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n fn lookup_in_scope_strict(&env e, list[scope] sc, &span sp, &ident id,\n                         namespace ns) -> def {\n     alt (lookup_in_scope(e, sc, sp, id, ns)) {\n-        case (none[def]) {\n+        case (none) {\n             unresolved(e, sp, id, ns_name(ns));\n             fail;\n         }\n-        case (some[def](?d)) {\n+        case (some(?d)) {\n             ret d;\n         }\n     }\n@@ -617,10 +617,10 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n     auto left_fn_level2 = false;\n     while (true) {\n         alt (sc) {\n-            case (nil[scope]) {\n+            case (nil) {\n                 ret none[def];\n             }\n-            case (cons[scope](?hd, ?tl)) {\n+            case (cons(?hd, ?tl)) {\n                 auto fnd = in_scope(e, sp, id, hd, ns);\n                 if (!option::is_none(fnd)) {\n                     auto df = option::get(fnd);\n@@ -788,11 +788,11 @@ fn found_def_item(&@ast::item i, namespace ns) -> option::t[def] {\n fn lookup_in_mod_strict(&env e, def m, &span sp, &ident id,\n                         namespace ns, dir dr) -> def {\n     alt (lookup_in_mod(e, m, sp, id, ns, dr)) {\n-        case (none[def]) {\n+        case (none) {\n             unresolved(e, sp, id, ns_name(ns));\n             fail;\n         }\n-        case (some[def](?d)) {\n+        case (some(?d)) {\n             ret d;\n         }\n     }\n@@ -872,12 +872,12 @@ fn lookup_in_local_mod(&env e, def_id defid, &span sp,\n          ret none[def]; // name is not visible\n      }\n     alt(info.index.find(id)) {\n-        case (none[list[mod_index_entry]]) { }\n-        case (some[list[mod_index_entry]](?lst)) {\n+        case (none) { }\n+        case (some(?lst)) {\n             while (true) {\n                 alt (lst) {\n-                    case (nil[mod_index_entry]) { break; }\n-                    case (cons[mod_index_entry](?hd, ?tl)) {\n+                    case (nil) { break; }\n+                    case (cons(?hd, ?tl)) {\n                         auto found = lookup_in_mie(e, hd, ns);\n                         if (!option::is_none(found)) { ret found; }\n                         lst = *tl;\n@@ -987,10 +987,10 @@ fn lookup_in_mie(&env e, &mod_index_entry mie, namespace ns)\n fn add_to_index(&hashmap[ident,list[mod_index_entry]] index, &ident id, \n                 &mod_index_entry ent) {\n     alt (index.find(id)) {\n-        case (none[list[mod_index_entry]]) {\n+        case (none) {\n             index.insert(id, cons(ent, @nil[mod_index_entry]));\n         }\n-        case (some[list[mod_index_entry]](?prev)) {\n+        case (some(?prev)) {\n             index.insert(id, cons(ent, @prev));\n         }\n     }\n@@ -1134,7 +1134,7 @@ fn check_mod_name(&env e, &ident name, &list[mod_index_entry] entries) {\n \n     while (true) {\n         alt (entries) {\n-            case (cons[mod_index_entry](?entry, ?rest)) {\n+            case (cons(?entry, ?rest)) {\n                 if (!option::is_none(lookup_in_mie(e, entry, ns_value))) {\n                     if (saw_value) { dup(e, mie_span(entry), \"\", name); }\n                     else { saw_value = true; }\n@@ -1149,7 +1149,7 @@ fn check_mod_name(&env e, &ident name, &list[mod_index_entry] entries) {\n                 }\n                 entries = *rest;\n             }\n-            case (nil[mod_index_entry]) { break; }\n+            case (nil) { break; }\n         }\n     }\n }"}, {"sha": "54da4733cc1c87bc73b0ad123aaedb22cfa7b559", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -307,8 +307,8 @@ fn path_name(&vec[str] path) -> str {\n fn get_type_sha1(&@crate_ctxt ccx, &ty::t t) -> str {\n     auto hash = \"\";\n     alt (ccx.type_sha1s.find(t)) {\n-        case (some[str](?h)) { hash = h; }\n-        case (none[str]) {\n+        case (some(?h)) { hash = h; }\n+        case (none) {\n             ccx.sha.reset();\n             auto f = metadata::def_to_str;\n             // NB: do *not* use abbrevs here as we want the symbol names\n@@ -755,7 +755,7 @@ fn type_of_fn_full(&@crate_ctxt cx,\n \n     // Arg 2: Env (closure-bindings / self-obj)\n     alt (obj_self) {\n-        case (some[TypeRef](?t)) {\n+        case (some(?t)) {\n             assert (t as int != 0);\n             atys += [t];\n         }\n@@ -1710,12 +1710,12 @@ fn trans_stack_local_derived_tydesc(&@block_ctxt cx, ValueRef llsz,\n fn get_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n                       &mutable option::t[@tydesc_info] static_ti) -> result {\n     alt (cx.fcx.derived_tydescs.find(t)) {\n-        case (some[derived_tydesc_info](?info)) {\n+        case (some(?info)) {\n             // If the tydesc escapes in this context, the cached derived\n             // tydesc also has to be one that was marked as escaping.\n             if (!(escapes && !info.escapes)) { ret res(cx, info.lltydesc); }\n         }\n-        case (none[derived_tydesc_info]) { /* fall through */ }\n+        case (none) { /* fall through */ }\n     }\n \n     cx.fcx.lcx.ccx.stats.n_derived_tydescs += 1u;\n@@ -1789,8 +1789,8 @@ fn get_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n               &mutable option::t[@tydesc_info] static_ti) -> result {\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt (ty::type_param(cx.fcx.lcx.ccx.tcx, t)) {\n-        case (some[uint](?id)) { ret res(cx, cx.fcx.lltydescs.(id)); }\n-        case (none[uint])      { /* fall through */ }\n+        case (some(?id)) { ret res(cx, cx.fcx.lltydescs.(id)); }\n+        case (none)      { /* fall through */ }\n     }\n \n     // Does it contain a type param? If so, generate a derived tydesc.\n@@ -1809,10 +1809,10 @@ fn get_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n fn get_static_tydesc(&@block_ctxt cx,\n                      &ty::t t, &vec[uint] ty_params) -> @tydesc_info {\n     alt (cx.fcx.lcx.ccx.tydescs.find(t)) {\n-        case (some[@tydesc_info](?info)) {\n+        case (some(?info)) {\n             ret info;\n         }\n-        case (none[@tydesc_info]) {\n+        case (none) {\n             cx.fcx.lcx.ccx.stats.n_static_tydescs += 1u;\n             auto info = declare_tydesc(cx.fcx.lcx, cx.sp, t, ty_params);\n             cx.fcx.lcx.ccx.tydescs.insert(t, info);\n@@ -1981,44 +1981,44 @@ fn emit_tydescs(&@crate_ctxt ccx) {\n         auto ti = pair._1;\n \n         auto take_glue = alt (ti.take_glue) {\n-            case (none[ValueRef]) {\n+            case (none) {\n                 ccx.stats.n_null_glues += 1u;\n                 C_null(glue_fn_ty)\n             }\n-            case (some[ValueRef](?v)) {\n+            case (some(?v)) {\n                 ccx.stats.n_real_glues += 1u;\n                 v\n             }\n         };\n \n         auto drop_glue = alt (ti.drop_glue) {\n-            case (none[ValueRef]) {\n+            case (none) {\n                 ccx.stats.n_null_glues += 1u;\n                 C_null(glue_fn_ty)\n             }\n-            case (some[ValueRef](?v)) {\n+            case (some(?v)) {\n                 ccx.stats.n_real_glues += 1u;\n                 v\n             }\n         };\n \n         auto free_glue = alt (ti.free_glue) {\n-            case (none[ValueRef]) {\n+            case (none) {\n                 ccx.stats.n_null_glues += 1u;\n                 C_null(glue_fn_ty)\n             }\n-            case (some[ValueRef](?v)) {\n+            case (some(?v)) {\n                 ccx.stats.n_real_glues += 1u;\n                 v\n             }\n         };\n \n         auto cmp_glue = alt (ti.cmp_glue) {\n-            case (none[ValueRef]) {\n+            case (none) {\n                 ccx.stats.n_null_glues += 1u;\n                 C_null(cmp_fn_ty)\n             }\n-            case (some[ValueRef](?v)) {\n+            case (some(?v)) {\n                 ccx.stats.n_real_glues += 1u;\n                 v\n             }\n@@ -2934,13 +2934,13 @@ fn lazily_emit_all_generic_info_tydesc_glues(&@block_ctxt cx,\n fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                            &option::t[@tydesc_info] static_ti) {\n     alt (static_ti) {\n-        case (none[@tydesc_info]) { }\n-        case (some[@tydesc_info](?ti)) {\n+        case (none) { }\n+        case (some(?ti)) {\n \n             if(field == abi::tydesc_field_take_glue) {\n                 alt (ti.take_glue) {\n-                    case (some[ValueRef](_)) {}\n-                    case (none[ValueRef]) {\n+                    case (some(_)) {}\n+                    case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n                                  ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n \n@@ -2960,8 +2960,8 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                 }\n             } else if (field == abi::tydesc_field_drop_glue)  {\n                 alt (ti.drop_glue) {\n-                    case (some[ValueRef](_)) { }\n-                    case (none[ValueRef]) {\n+                    case (some(_)) { }\n+                    case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue DROP %s\",\n                                  ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n                         auto lcx = cx.fcx.lcx;\n@@ -2980,8 +2980,8 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n \n             } else if (field == abi::tydesc_field_free_glue)  {\n                 alt (ti.free_glue) {\n-                    case (some[ValueRef](_)) { }\n-                    case (none[ValueRef]) {\n+                    case (some(_)) { }\n+                    case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue FREE %s\",\n                                  ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n                         auto lcx = cx.fcx.lcx;\n@@ -3001,8 +3001,8 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n \n             } else if (field == abi::tydesc_field_cmp_glue) {\n                 alt (ti.cmp_glue) {\n-                    case (some[ValueRef](_)) { }\n-                    case (none[ValueRef]) {\n+                    case (some(_)) { }\n+                    case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue CMP %s\",\n                                  ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n                         auto lcx = cx.fcx.lcx;\n@@ -3726,7 +3726,7 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond,\n     auto else_res;\n     auto expr_llty;\n     alt (els) {\n-        case (some[@ast::expr](?elexpr)) {\n+        case (some(?elexpr)) {\n             alt (elexpr.node) {\n                 case (ast::expr_if(_, _, _, ?ann)) {\n                     // Synthesize a block here to act as the else block\n@@ -3931,15 +3931,15 @@ fn trans_for_each(&@block_ctxt cx,\n         for (ast::def_id did in upvars) {\n             auto llbinding;\n             alt (cx.fcx.lllocals.find(did)) {\n-                case (none[ValueRef]) {\n+                case (none) {\n                     alt (cx.fcx.llupvars.find(did)) {\n                         case (none[ValueRef]) {\n                             llbinding = cx.fcx.llargs.get(did);\n                         }\n                         case (some[ValueRef](?llval)) { llbinding = llval; }\n                     }\n                 }\n-                case (some[ValueRef](?llval)) { llbinding = llval; }\n+                case (some(?llval)) { llbinding = llval; }\n             }\n             llbindings += [llbinding];\n             llbindingtys += [val_ty(llbinding)];\n@@ -4379,7 +4379,7 @@ fn lval_generic_fn(&@block_ctxt cx,\n fn lookup_discriminant(&@local_ctxt lcx, &ast::def_id tid, &ast::def_id vid)\n         -> ValueRef {\n     alt (lcx.ccx.discrims.find(vid)) {\n-        case (none[ValueRef]) {\n+        case (none) {\n             // It's an external discriminant that we haven't seen yet.\n             assert (lcx.ccx.sess.get_targ_crate_num() != vid._0);\n             auto sym = creader::get_symbol(lcx.ccx.sess, vid);\n@@ -4391,30 +4391,30 @@ fn lookup_discriminant(&@local_ctxt lcx, &ast::def_id tid, &ast::def_id vid)\n             lcx.ccx.discrims.insert(vid, gvar);\n             ret gvar;\n         }\n-        case (some[ValueRef](?llval)) { ret llval; }\n+        case (some(?llval)) { ret llval; }\n     }\n }\n \n fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n     alt (cx.fcx.lcx.ccx.tcx.def_map.get(ann.id)) {\n         case (ast::def_arg(?did)) {\n             alt (cx.fcx.llargs.find(did)) {\n-                case (none[ValueRef]) {\n+                case (none) {\n                     assert (cx.fcx.llupvars.contains_key(did));\n                     ret lval_mem(cx, cx.fcx.llupvars.get(did));\n                 }\n-                case (some[ValueRef](?llval)) {\n+                case (some(?llval)) {\n                     ret lval_mem(cx, llval);\n                 }\n             }\n         }\n         case (ast::def_local(?did)) {\n             alt (cx.fcx.lllocals.find(did)) {\n-                case (none[ValueRef]) {\n+                case (none) {\n                     assert (cx.fcx.llupvars.contains_key(did));\n                     ret lval_mem(cx, cx.fcx.llupvars.get(did));\n                 }\n-                case (some[ValueRef](?llval)) {\n+                case (some(?llval)) {\n                     ret lval_mem(cx, llval);\n                 }\n             }\n@@ -4614,7 +4614,7 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n         }\n         case (ast::expr_self_method(?ident, ?ann)) {\n             alt (cx.fcx.llself) {\n-                case (some[self_vt](?s_vt)) {\n+                case (some(?s_vt)) {\n                     auto r =  s_vt.v;\n                     auto t =  s_vt.t;\n                     ret trans_field(cx, e.span, r, t, ident, ann);\n@@ -4750,7 +4750,7 @@ fn trans_bind_thunk(&@local_ctxt cx,\n         alt (arg) {\n \n             // Arg provided at binding time; thunk copies it from closure.\n-            case (some[@ast::expr](?e)) {\n+            case (some(?e)) {\n                 auto e_ty = ty::expr_ty(cx.ccx.tcx, e);\n                 auto bound_arg =\n                     GEP_tup_like(bcx, closure_ty, llclosure,\n@@ -4781,7 +4781,7 @@ fn trans_bind_thunk(&@local_ctxt cx,\n             }\n \n             // Arg will be provided when the thunk is invoked.\n-            case (none[@ast::expr]) {\n+            case (none) {\n                 let ValueRef passed_arg = llvm::LLVMGetParam(llthunk, a);\n \n                 if (ty::type_contains_params(cx.ccx.tcx, out_arg.ty)) {\n@@ -4834,9 +4834,9 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n \n         for (option::t[@ast::expr] argopt in args) {\n             alt (argopt) {\n-                case (none[@ast::expr]) {\n+                case (none) {\n                 }\n-                case (some[@ast::expr](?e)) {\n+                case (some(?e)) {\n                     vec::push[@ast::expr](bound, e);\n                 }\n             }\n@@ -4846,11 +4846,11 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n         let ty::t outgoing_fty;\n         let vec[ValueRef] lltydescs;\n         alt (f_res.generic) {\n-            case (none[generic_info]) {\n+            case (none) {\n                 outgoing_fty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, f);\n                 lltydescs = [];\n             }\n-            case (some[generic_info](?ginfo)) {\n+            case (some(?ginfo)) {\n                 lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n                 outgoing_fty = ginfo.item_type;\n                 lltydescs = ginfo.tydescs;\n@@ -4965,8 +4965,8 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             // appropriate slot in the closure.\n \n             alt (f_res.generic) {\n-                case (none[generic_info]) { /* nothing to do */ }\n-                case (some[generic_info](?ginfo)) {\n+                case (none) { /* nothing to do */ }\n+                case (some(?ginfo)) {\n                     lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n                     auto ty_params_slot =\n                         bcx.build.GEP(closure,\n@@ -5114,7 +5114,7 @@ fn trans_args(&@block_ctxt cx,\n     auto llretslot = llretslot_res.val;\n \n     alt (gen) {\n-        case (some[generic_info](?g)) {\n+        case (some(?g)) {\n             lazily_emit_all_generic_info_tydesc_glues(cx, g);\n             lltydescs = g.tydescs;\n             args = ty::ty_fn_args(cx.fcx.lcx.ccx.tcx, g.item_type);\n@@ -5145,7 +5145,7 @@ fn trans_args(&@block_ctxt cx,\n \n     // Arg 2: Env (closure-bindings / self-obj)\n     alt (llobj) {\n-        case (some[ValueRef](?ob)) {\n+        case (some(?ob)) {\n             // Every object is always found in memory,\n             // and not-yet-loaded (as part of an lval x.y\n             // doted method-call).\n@@ -5161,8 +5161,8 @@ fn trans_args(&@block_ctxt cx,\n \n     // ... then possibly an lliterbody argument.\n     alt (lliterbody) {\n-        case (none[ValueRef]) {}\n-        case (some[ValueRef](?lli)) {\n+        case (none) {}\n+        case (some(?lli)) {\n             llargs += [lli];\n         }\n     }\n@@ -5199,11 +5199,11 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f,\n     auto llenv = C_null(T_opaque_closure_ptr(cx.fcx.lcx.ccx.tn));\n \n     alt (f_res.llobj) {\n-        case (some[ValueRef](_)) {\n+        case (some(_)) {\n             // It's a vtbl entry.\n             faddr = f_res.res.bcx.build.Load(faddr);\n         }\n-        case (none[ValueRef]) {\n+        case (none) {\n             // It's a closure.\n             auto bcx = f_res.res.bcx;\n             auto pair = faddr;\n@@ -5220,7 +5220,7 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f,\n \n     let ty::t fn_ty;\n     alt (f_res.method_ty) {\n-        case (some[ty::t](?meth)) {\n+        case (some(?meth)) {\n             // self-call\n             fn_ty = meth;\n         }\n@@ -5254,7 +5254,7 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f,\n     auto retval = C_nil();\n \n     alt (lliterbody) {\n-        case (none[ValueRef]) {\n+        case (none) {\n             if (!ty::type_is_nil(cx.fcx.lcx.ccx.tcx, ret_ty)) {\n                 retval = load_if_immediate(bcx, llretslot, ret_ty);\n                 // Retval doesn't correspond to anything really tangible in\n@@ -5264,7 +5264,7 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f,\n                     [clean(bind drop_ty(_, retval, ret_ty))];\n             }\n         }\n-        case (some[ValueRef](_)) {\n+        case (some(_)) {\n             // If there was an lliterbody, it means we were calling an\n             // iter, and we are *not* the party using its 'output' value,\n             // we should ignore llretslot.\n@@ -5387,8 +5387,8 @@ fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n     auto base_val = C_nil();\n \n     alt (base) {\n-        case (none[@ast::expr]) { }\n-        case (some[@ast::expr](?bexp)) {\n+        case (none) { }\n+        case (some(?bexp)) {\n             auto base_res = trans_expr(bcx, bexp);\n             bcx = base_res.bcx;\n             base_val = base_res.val;\n@@ -5753,12 +5753,12 @@ fn trans_fail(&@block_ctxt cx, &option::t[common::span] sp_opt, &str fail_str)\n \n     auto V_filename; auto V_line;\n     alt (sp_opt) {\n-        case (some[common::span](?sp)) {\n+        case (some(?sp)) {\n             auto loc = cx.fcx.lcx.ccx.sess.lookup_pos(sp.lo);\n             V_filename = C_cstr(cx.fcx.lcx.ccx, loc.filename);\n             V_line = loc.line as int;\n         }\n-        case (none[common::span]) {\n+        case (none) {\n             V_filename = C_cstr(cx.fcx.lcx.ccx, \"<runtime>\");\n             V_line = 0;\n         }\n@@ -5779,7 +5779,7 @@ fn trans_put(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n     auto llenv = C_nil();\n \n     alt (cx.fcx.lliterbody) {\n-        case (some[ValueRef](?lli)) {\n+        case (some(?lli)) {\n             auto slot = alloca(cx, val_ty(lli));\n             cx.build.Store(lli, slot);\n \n@@ -5796,8 +5796,8 @@ fn trans_put(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n     auto dummy_retslot = alloca(bcx, T_nil());\n     let vec[ValueRef] llargs = [dummy_retslot, cx.fcx.lltaskptr, llenv];\n     alt (e) {\n-        case (none[@ast::expr]) { }\n-        case (some[@ast::expr](?x)) {\n+        case (none) { }\n+        case (some(?x)) {\n             auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, x);\n             auto arg = rec(mode=ty::mo_alias, ty=e_ty);\n             auto arg_tys = type_of_explicit_args(cx.fcx.lcx.ccx,\n@@ -5823,7 +5823,7 @@ fn trans_break_cont(&@block_ctxt cx, bool to_end) -> result {\n                     bcx.build.Br(_break.llbb);\n                 } else {\n                     alt (_cont) {\n-                        case (option::some[@block_ctxt](?_cont)) {\n+                        case (option::some(?_cont)) {\n                             bcx.build.Br(_cont.llbb);\n                         }\n                         case (_) {\n@@ -5858,7 +5858,7 @@ fn trans_ret(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n     auto val = C_nil();\n \n     alt (e) {\n-        case (some[@ast::expr](?x)) {\n+        case (some(?x)) {\n             auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, x);\n             auto r = trans_expr(cx, x);\n             bcx = r.bcx;\n@@ -5961,7 +5961,7 @@ fn trans_spawn(&@block_ctxt cx,\n                  common::expr_to_str(func),\n                  str::connect(argss, \", \"))\n         }\n-        case(some[str](?n)) {\n+        case(some(?n)) {\n             n\n         }\n     };\n@@ -6228,8 +6228,8 @@ fn trans_anon_obj(&@block_ctxt cx, &ast::span sp,\n \n     let option::t[result] with_obj_val = none[result];\n     alt (anon_obj.with_obj) {\n-        case (none[@ast::expr]) { }\n-        case (some[@ast::expr](?e)) {\n+        case (none) { }\n+        case (some(?e)) {\n             // Translating with_obj returns a ValueRef (pointer to a 2-word\n             // value) wrapped in a result.  We want to allocate space for this\n             // value in our outer object, then copy it into the outer object.\n@@ -6244,8 +6244,8 @@ fn trans_anon_obj(&@block_ctxt cx, &ast::span sp,\n     let vec[ast::arg] addtl_fn_args = [];\n \n     alt (anon_obj.fields) {\n-        case (none[vec[ast::obj_field]]) { }\n-        case (some[vec[ast::obj_field]](?fields)) {\n+        case (none) { }\n+        case (some(?fields)) {\n             for (ast::obj_field f in fields) {\n                 addtl_fn_args += [rec(mode=ast::alias, ty=f.ty, \n                                       ident=f.ident, id=f.id)];\n@@ -6271,7 +6271,7 @@ fn init_local(&@block_ctxt cx, &@ast::local local) -> result {\n         [clean(bind drop_slot(_, llptr, ty))];\n \n     alt (local.init) {\n-        case (some[ast::initializer](?init)) {\n+        case (some(?init)) {\n             alt (init.op) {\n                 case (ast::init_assign) {\n                     auto sub = trans_expr(bcx, init.expr);\n@@ -6492,7 +6492,7 @@ fn trans_block(&@block_ctxt cx, &ast::block b) -> result {\n     }\n \n     alt (b.node.expr) {\n-        case (some[@ast::expr](?e)) {\n+        case (some(?e)) {\n             // Hold onto the context for this scope since we'll need it to\n             // find the outer scope\n             auto scope_bcx = bcx;\n@@ -6546,7 +6546,7 @@ fn trans_block(&@block_ctxt cx, &ast::block b) -> result {\n                 }\n             }\n         }\n-        case (none[@ast::expr]) {\n+        case (none) {\n             r = res(bcx, C_nil());\n         }\n     }\n@@ -6635,10 +6635,10 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n     auto arg_n = 3u;\n \n     alt (ty_self) {\n-        case (some[tup(TypeRef, ty::t)](?tt)) {\n+        case (some(?tt)) {\n             cx.llself = some[self_vt](rec(v = cx.llenv, t = tt._1));\n         }\n-        case (none[tup(TypeRef, ty::t)]) {\n+        case (none) {\n             auto i = 0u;\n             for (ast::ty_param tp in ty_params) {\n                 auto llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n@@ -6675,7 +6675,7 @@ fn copy_any_self_to_alloca(@fn_ctxt fcx,\n     auto bcx = llallocas_block_ctxt(fcx);\n \n     alt (fcx.llself) {\n-        case (some[self_vt](?s_vt)) {\n+        case (some(?s_vt)) {\n             alt (ty_self) {\n                 case (some[tup(TypeRef, ty::t)](?tt)) {\n                     auto a = alloca(bcx, tt._0);\n@@ -6845,7 +6845,7 @@ fn trans_fn(@local_ctxt cx, &ast::span sp, &ast::_fn f, ast::def_id fid,\n     copy_any_self_to_alloca(fcx, ty_self);\n \n     alt (fcx.llself) {\n-        case (some[self_vt](?llself)) {\n+        case (some(?llself)) {\n             populate_fn_ctxt_from_llself(fcx, llself);\n         }\n         case (_) {\n@@ -6877,11 +6877,11 @@ fn create_vtbl(@local_ctxt cx,\n               &vec[ast::ty_param] ty_params) -> ValueRef {\n     auto dtor = C_null(T_ptr(T_i8()));\n     alt (ob.dtor) {\n-        case (some[@ast::method](?d)) {\n+        case (some(?d)) {\n             auto dtor_1 = trans_dtor(cx, llself_ty, self_ty, ty_params, d);\n             dtor = llvm::LLVMConstBitCast(dtor_1, val_ty(dtor));\n         }\n-        case (none[@ast::method]) {}\n+        case (none) {}\n     }\n     let vec[ValueRef] methods = [dtor];\n \n@@ -7065,10 +7065,10 @@ fn trans_obj(@local_ctxt cx, &ast::span sp, &ast::_obj ob, ast::def_id oid,\n \n         auto dtor = C_null(T_ptr(T_glue_fn(ccx.tn)));\n         alt (ob.dtor) {\n-            case (some[@ast::method](?d)) {\n+            case (some(?d)) {\n                 dtor = trans_dtor(cx, llself_ty, self_ty, ty_params, d);\n             }\n-            case (none[@ast::method]) {}\n+            case (none) {}\n         }\n \n         bcx = body_td.bcx;"}, {"sha": "9f78504b737a83a07b4097f96359c3321aa3f8c9", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -232,12 +232,12 @@ fn get_ts_ann(&crate_ctxt ccx, uint i) -> option::t[ts_ann] {\n \n fn ann_to_ts_ann(&crate_ctxt ccx, &ann a) -> ts_ann {\n     alt (get_ts_ann(ccx, a.id)) {\n-        case (none[ts_ann])         { \n+        case (none)         { \n             log_err (\"ann_to_ts_ann: no ts_ann for node_id \"\n                      + uistr(a.id));\n             fail;\n         }\n-        case (some[ts_ann](?t))     { ret t; }\n+        case (some(?t))     { ret t; }\n     }\n }\n \n@@ -429,8 +429,8 @@ fn new_crate_ctxt(ty::ctxt cx) -> crate_ctxt {\n \n fn controlflow_def_id(&crate_ctxt ccx, &def_id d) -> controlflow {\n     alt (ccx.fm.find(d)) {\n-        case (some[fn_info](?fi)) { ret fi.cf; }\n-        case (none[fn_info])      { ret return; } \n+        case (some(?fi)) { ret fi.cf; }\n+        case (none)      { ret return; } \n     }\n }\n \n@@ -451,11 +451,11 @@ fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n \n fn ann_to_def_strict(&crate_ctxt ccx, &ann a) -> def {\n     alt (ccx.tcx.def_map.find(a.id)) {\n-        case (none[def]) { \n+        case (none) { \n             log_err(\"ann_to_def: node_id \" + uistr(a.id) + \" has no def\");\n             fail;\n         }\n-        case (some[def](?d)) { ret d; }\n+        case (some(?d)) { ret d; }\n     }\n }\n "}, {"sha": "d78e03eac14c5e16627683d53a927f2a09ce4861", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -262,7 +262,7 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@decl d, &@expr index,\n fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs,\n                 &ann larger_ann, &ann new_var) -> () {\n   alt (ann_to_def(fcx.ccx, new_var)) {\n-      case (some[def](?d)) {\n+      case (some(?d)) {\n           alt (d) {\n               case (def_local(?d_id)) {\n                   find_pre_post_expr(fcx, rhs);\n@@ -341,11 +341,11 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n         }\n         case(expr_put(?opt, ?a)) {\n             alt (opt) {\n-                case (some[@expr](?arg)) {\n+                case (some(?arg)) {\n                     find_pre_post_expr(fcx, arg);\n                     copy_pre_post(fcx.ccx, a, arg);\n                 }\n-                case (none[@expr]) {\n+                case (none) {\n                     clear_pp(expr_pp(fcx.ccx, e));\n                 }\n             }\n@@ -392,11 +392,11 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n         }\n         case (expr_ret(?maybe_val, ?a)) {\n             alt (maybe_val) {\n-                case (none[@expr]) {\n+                case (none) {\n                     clear_precond(fcx.ccx, a);\n                     set_postcond_false(fcx.ccx, a);\n                 }\n-                case (some[@expr](?ret_val)) {\n+                case (some(?ret_val)) {\n                     find_pre_post_expr(fcx, ret_val);\n                     set_precondition(ann_to_ts_ann(fcx.ccx, a),\n                                      expr_precond(fcx.ccx, ret_val));\n@@ -414,15 +414,15 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             find_pre_post_expr(fcx, antec);\n             find_pre_post_block(fcx, conseq);\n             alt (maybe_alt) {\n-                case (none[@expr]) {\n+                case (none) {\n                     log \"333\";\n                     auto precond_res = seq_preconds(fcx,\n                                          [expr_pp(fcx.ccx, antec),\n                                           block_pp(fcx.ccx, conseq)]);\n                     set_pre_and_post(fcx.ccx, a, precond_res,\n                                      expr_poststate(fcx.ccx, antec));\n                 }\n-                case (some[@expr](?altern)) {\n+                case (some(?altern)) {\n                     find_pre_post_expr(fcx, altern);\n                     log \"444\";\n                     auto precond_true_case =\n@@ -570,11 +570,11 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n         }\n         case (expr_anon_obj(?anon_obj, _, _, ?a)) {\n             alt (anon_obj.with_obj) {\n-                case (some[@expr](?ex)) {\n+                case (some(?ex)) {\n                     find_pre_post_expr(fcx, ex);\n                     copy_pre_post(fcx.ccx, a, ex);\n                 }\n-                case (none[@expr]) {\n+                case (none) {\n                     clear_pp(expr_pp(fcx.ccx, e));\n                 }\n             }\n@@ -595,7 +595,7 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s)\n             alt(adecl.node) {\n                 case(decl_local(?alocal)) {\n                     alt(alocal.init) {\n-                        case(some[initializer](?an_init)) {\n+                        case(some(?an_init)) {\n                             find_pre_post_expr(fcx, an_init.expr);\n                             copy_pre_post(fcx.ccx, alocal.ann, an_init.expr);\n \n@@ -610,7 +610,7 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s)\n                                                    log_err(\"pp = \");\n                                                    log_pp(stmt_pp(s)); */\n                         }\n-                        case(none[initializer]) {\n+                        case(none) {\n                             clear_pp(ann_to_ts_ann(fcx.ccx,\n                                                    alocal.ann).conditions);\n                             clear_pp(ann_to_ts_ann(fcx.ccx, a).conditions);"}, {"sha": "9d688e16d52186b19b84a5dba343e378b6ee5898", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -204,7 +204,7 @@ fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@decl d,\n \n fn gen_if_local(&fn_ctxt fcx, &ann a_new_var, &ann a) -> bool {\n   alt (ann_to_def(fcx.ccx, a_new_var)) {\n-      case (some[def](def_local(?loc))) {\n+      case (some(def_local(?loc))) {\n           ret gen_poststate(fcx, a, loc);\n       }\n       case (_) { ret false; }\n@@ -287,14 +287,14 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n     }\n     case (expr_put(?maybe_e, ?a)) {\n         alt (maybe_e) {\n-            case (some[@expr](?arg)) {\n+            case (some(?arg)) {\n                 changed = find_pre_post_state_expr(fcx, pres, arg);\n                 changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n                 changed = extend_poststate_ann(fcx.ccx, a,\n                             expr_poststate(fcx.ccx, arg)) || changed;\n                 ret changed;\n             }\n-            case (none[@expr]) {\n+            case (none) {\n                 ret pure_exp(fcx.ccx, a, pres);\n             }\n         }\n@@ -314,8 +314,8 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         changed = find_pre_post_state_exprs(fcx, pres, a,\n                                             field_exprs(fields)) || changed;\n         alt (maybe_base) {\n-            case (none[@expr]) { /* do nothing */ }\n-            case (some[@expr](?base)) {\n+            case (none) { /* do nothing */ }\n+            case (some(?base)) {\n                 changed = find_pre_post_state_expr(fcx, pres, base)\n                     || changed;\n                 changed = extend_poststate_ann(fcx.ccx, a,\n@@ -386,8 +386,8 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             case (_) {}\n         }\n         alt(maybe_ret_val) {\n-            case (none[@expr]) { /* do nothing */ }\n-            case (some[@expr](?ret_val)) {\n+            case (none) { /* do nothing */ }\n+            case (some(?ret_val)) {\n                 changed = find_pre_post_state_expr(fcx,\n                              pres, ret_val) || changed;\n             }\n@@ -407,11 +407,11 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         changed = find_pre_post_state_block(fcx,\n           expr_poststate(fcx.ccx, antec), conseq) || changed;\n         alt (maybe_alt) {\n-            case (none[@expr]) {\n+            case (none) {\n                 changed = extend_poststate_ann(fcx.ccx, a,\n                             expr_poststate(fcx.ccx, antec)) || changed;\n             }\n-            case (some[@expr](?altern)) {\n+            case (some(?altern)) {\n                 changed = find_pre_post_state_expr(fcx,\n                    expr_poststate(fcx.ccx, antec), altern) || changed;\n                 auto poststate_res = intersect_postconds\n@@ -594,14 +594,14 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n     }\n     case (expr_anon_obj(?anon_obj, _, _,?a)) {\n         alt (anon_obj.with_obj) {\n-            case (some[@expr](?e)) {\n+            case (some(?e)) {\n                 changed = find_pre_post_state_expr(fcx, pres, e);\n                 changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n                 changed = extend_poststate_ann(fcx.ccx, a,\n                             expr_poststate(fcx.ccx, e)) || changed;\n                 ret changed;\n             }\n-            case (none[@expr]) {\n+            case (none) {\n                 ret pure_exp(fcx.ccx, a, pres);\n             }\n         }\n@@ -627,7 +627,7 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n             alt (adecl.node) {\n                 case (decl_local(?alocal)) {\n                     alt (alocal.init) {\n-                        case (some[initializer](?an_init)) {\n+                        case (some(?an_init)) {\n                             changed = extend_prestate\n                                 (stmt_ann.states.prestate, pres) || changed;\n                             changed = find_pre_post_state_expr\n@@ -650,7 +650,7 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n   \n                             ret changed;\n                         }\n-                        case (none[initializer]) {\n+                        case (none) {\n                             changed = extend_prestate\n                                 (stmt_ann.states.prestate, pres) || changed;\n                             changed = extend_poststate\n@@ -716,8 +716,8 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b)\n   auto post = pres;\n \n   alt (b.node.expr) {\n-    case (none[@expr]) {}\n-    case (some[@expr](?e)) {\n+    case (none) {}\n+    case (some(?e)) {\n       changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n       post = expr_poststate(fcx.ccx, e);\n     }"}, {"sha": "892d444c7b42c8882632f003c3a00dc023a0eafa", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -551,7 +551,7 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n             }\n \n             alt (ident) {\n-                case (some[ast::ident](?i)) {\n+                case (some(?i)) {\n                     s += \" \";\n                     s += i;\n                 }\n@@ -589,7 +589,7 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n     }\n \n     alt (cname(cx, typ)) {\n-        case (some[str](?cs)) {\n+        case (some(?cs)) {\n             ret cs;\n         }\n         case (_) { }\n@@ -1232,8 +1232,8 @@ fn hash_type_structure(&sty st) -> uint {\n fn hash_type_info(&sty st, &option::t[str] cname_opt) -> uint {\n     auto h = hash_type_structure(st);\n     alt (cname_opt) {\n-        case (none[str]) { /* no-op */ }\n-        case (some[str](?s)) { h += h << 5u + str::hash(s); }\n+        case (none) { /* no-op */ }\n+        case (some(?s)) { h += h << 5u + str::hash(s); }\n     }\n     ret h;\n }\n@@ -1500,15 +1500,15 @@ fn eq_raw_ty(&raw_t a, &raw_t b) -> bool {\n \n     // Check canonical names.\n     alt (a.cname) {\n-        case (none[str]) {\n+        case (none) {\n             alt (b.cname) {\n                 case (none[str]) { /* ok */ }\n                 case (_) { ret false; }\n             }\n         }\n-        case (some[str](?s_a)) {\n+        case (some(?s_a)) {\n             alt (b.cname) {\n-                case (some[str](?s_b)) {\n+                case (some(?s_b)) {\n                     if (!str::eq(s_a, s_b)) { ret false; }\n                 }\n                 case (_) { ret false; }\n@@ -1530,12 +1530,12 @@ fn eq_ty(&t a, &t b) -> bool { ret a == b; }\n fn ann_to_ty_param_substs_opt_and_ty(&node_type_table ntt, &ast::ann ann)\n         -> ty_param_substs_opt_and_ty {\n     alt (ntt.(ann.id)) {\n-        case (none[ty::ty_param_substs_opt_and_ty]) {\n+        case (none) {\n             log_err \"ann_to_ty_param_substs_opt_and_ty() called on an \" +\n                 \"untyped node\";\n             fail;\n         }\n-        case (some[ty::ty_param_substs_opt_and_ty](?tpot)) { ret tpot; }\n+        case (some(?tpot)) { ret tpot; }\n     }\n }\n \n@@ -1545,11 +1545,11 @@ fn ann_to_type(&node_type_table ntt, &ast::ann ann) -> t {\n \n fn ann_to_type_params(&node_type_table ntt, &ast::ann ann) -> vec[t] {\n     alt (ann_to_ty_param_substs_opt_and_ty(ntt, ann)._0) {\n-        case (none[vec[t]]) {\n+        case (none) {\n             let vec[t] result = [];\n             ret result;\n         }\n-        case (some[vec[t]](?tps)) { ret tps; }\n+        case (some(?tps)) { ret tps; }\n     }\n }\n \n@@ -1564,8 +1564,8 @@ fn ann_has_type_params(&node_type_table ntt, &ast::ann ann) -> bool {\n fn ann_to_monotype(&ctxt cx, ast::ann a) -> t {\n     auto tpot = ann_to_ty_param_substs_opt_and_ty(cx.node_types, a);\n     alt (tpot._0) {\n-        case (none[vec[t]]) { ret tpot._1; }\n-        case (some[vec[t]](?tps)) {\n+        case (none) { ret tpot._1; }\n+        case (some(?tps)) {\n             ret substitute_type_params(cx, tps, tpot._1);\n         }\n     }\n@@ -1953,15 +1953,15 @@ mod unify {\n         auto result_type = typ;\n         if (n < vec::len[option::t[t]](bindings.types)) {\n             alt (bindings.types.(n)) {\n-                case (some[t](?old_type)) {\n+                case (some(?old_type)) {\n                     alt (unify_step(cx, old_type, typ)) {\n                         case (ures_ok(?unified_type)) {\n                             result_type = unified_type;\n                         }\n                         case (?res) { ret res; }\n                     }\n                 }\n-                case (none[t]) { /* fall through */ }\n+                case (none) { /* fall through */ }\n             }\n         }\n \n@@ -2198,11 +2198,11 @@ mod unify {\n     fn get_or_create_set[T](&@bindings[T] bindings, &T key) -> uint {\n         auto set_num;\n         alt (bindings.ids.find(key)) {\n-            case (none[uint]) {\n+            case (none) {\n                 set_num = ufind::make_set(bindings.sets);\n                 bindings.ids.insert(key, set_num);\n             }\n-            case (some[uint](?n)) { set_num = n; }\n+            case (some(?n)) { set_num = n; }\n         }\n         ret set_num;\n     }\n@@ -2250,8 +2250,8 @@ mod unify {\n             case (ty::ty_local(?actual_id)) {\n                 auto result_ty;\n                 alt (cx.handler.resolve_local(actual_id)) {\n-                    case (none[t]) { result_ty = expected; }\n-                    case (some[t](?actual_ty)) {\n+                    case (none) { result_ty = expected; }\n+                    case (some(?actual_ty)) {\n                         auto result = unify_step(cx, expected, actual_ty);\n                         alt (result) {\n                             case (ures_ok(?rty)) { result_ty = rty; }\n@@ -2339,11 +2339,11 @@ mod unify {\n                     case (ty::ty_box(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n-                            case (none[ast::mutability]) {\n+                            case (none) {\n                                 ret ures_err(terr_box_mutability, expected,\n                                              actual);\n                             }\n-                            case (some[ast::mutability](?m)) { mut = m; }\n+                            case (some(?m)) { mut = m; }\n                         }\n \n                         auto result = unify_step(cx,\n@@ -2371,11 +2371,11 @@ mod unify {\n                     case (ty::ty_vec(?actual_mt)) {\n                         auto mut;\n                         alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n-                            case (none[ast::mutability]) {\n+                            case (none) {\n                                 ret ures_err(terr_vec_mutability, expected,\n                                              actual);\n                             }\n-                            case (some[ast::mutability](?m)) { mut = m; }\n+                            case (some(?m)) { mut = m; }\n                         }\n \n                         auto result = unify_step(cx,\n@@ -2464,11 +2464,11 @@ mod unify {\n                             auto mut;\n                             alt (unify_mut(expected_elem.mut,\n                                            actual_elem.mut)) {\n-                                case (none[ast::mutability]) {\n+                                case (none) {\n                                     auto err = terr_tuple_mutability;\n                                     ret ures_err(err, expected, actual);\n                                 }\n-                                case (some[ast::mutability](?m)) { mut = m; }\n+                                case (some(?m)) { mut = m; }\n                             }\n \n                             auto result = unify_step(cx,\n@@ -2518,11 +2518,11 @@ mod unify {\n                             auto mut;\n                             alt (unify_mut(expected_field.mt.mut,\n                                            actual_field.mt.mut)) {\n-                                case (none[ast::mutability]) {\n+                                case (none) {\n                                     ret ures_err(terr_record_mutability,\n                                                  expected, actual);\n                                 }\n-                                case (some[ast::mutability](?m)) { mut = m; }\n+                                case (some(?m)) { mut = m; }\n                             }\n \n                             if (!str::eq(expected_field.ident,\n@@ -2619,8 +2619,8 @@ mod unify {\n             case (ty::ty_local(?expected_id)) {\n                 auto result_ty;\n                 alt (cx.handler.resolve_local(expected_id)) {\n-                    case (none[t]) { result_ty = actual; }\n-                    case (some[t](?expected_ty)) {\n+                    case (none) { result_ty = actual; }\n+                    case (some(?expected_ty)) {\n                         auto result = unify_step(cx, expected_ty, actual);\n                         alt (result) {\n                             case (ures_ok(?rty)) { result_ty = rty; }\n@@ -2658,11 +2658,11 @@ mod unify {\n             alt (struct(tcx, typ)) {\n                 case (ty_var(?id)) {\n                     alt (bindings.ids.find(id)) {\n-                        case (some[uint](?n)) {\n+                        case (some(?n)) {\n                             auto root = ufind::find(bindings.sets, n);\n                             ret types.(root);\n                         }\n-                        case (none[uint]) { ret typ; }\n+                        case (none) { ret typ; }\n                     }\n                 }\n                 case (_) { ret typ; }\n@@ -2698,11 +2698,11 @@ mod unify {\n         while (i < node_count) {\n             auto root = ufind::find(bindings.sets, i);\n             alt (bindings.types.(i)) {\n-                case (none[t]) { /* nothing to do */ }\n-                case (some[t](?actual)) {\n+                case (none) { /* nothing to do */ }\n+                case (some(?actual)) {\n                     alt (results.(root)) {\n-                        case (none[t]) { results.(root) = some[t](actual); }\n-                        case (some[t](?expected)) {\n+                        case (none) { results.(root) = some[t](actual); }\n+                        case (some(?expected)) {\n                             // FIXME: Is this right?\n                             auto bindings = mk_bindings[int](int::hash,\n                                                              int::eq_alias);\n@@ -2928,8 +2928,8 @@ fn lookup_item_type(ctxt cx, ast::def_id did) -> ty_param_count_and_ty {\n     }\n \n     alt (cx.tcache.find(did)) {\n-        case (some[ty_param_count_and_ty](?tpt)) { ret tpt; }\n-        case (none[ty_param_count_and_ty]) {\n+        case (some(?tpt)) { ret tpt; }\n+        case (none) {\n             auto tyt = creader::get_type(cx, did);\n             cx.tcache.insert(did, tyt);\n             ret tyt;"}, {"sha": "bc29ac8e2db63114707ab3f6a469f58e573dd4ad", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -125,8 +125,8 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &ast::span sp, &ast::def defn)\n         case (ast::def_local(?id)) {\n             auto t;\n             alt (fcx.locals.find(id)) {\n-                case (some[ty::t](?t1)) { t = t1; }\n-                case (none[ty::t]) { t = ty::mk_local(fcx.ccx.tcx, id); }\n+                case (some(?t1)) { t = t1; }\n+                case (none) { t = ty::mk_local(fcx.ccx.tcx, id); }\n             }\n             ret tup(0u, t);\n         }\n@@ -355,8 +355,8 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n     }\n \n     alt (cname) {\n-        case (none[str]) { /* no-op */ }\n-        case (some[str](?cname_str)) {\n+        case (none) { /* no-op */ }\n+        case (some(?cname_str)) {\n             typ = ty::rename(tcx, typ, cname_str);\n         }\n     }\n@@ -574,10 +574,10 @@ mod collect {\n \n             case (ast::item_ty(?ident, ?t, ?tps, ?def_id, _)) {\n                 alt (cx.tcx.tcache.find(def_id)) {\n-                    case (some[ty::ty_param_count_and_ty](?tpt)) {\n+                    case (some(?tpt)) {\n                         ret tpt;\n                     }\n-                    case (none[ty::ty_param_count_and_ty]) {}\n+                    case (none) {}\n                 }\n \n                 // Tell ast_ty_to_ty() that we want to perform a recursive\n@@ -625,10 +625,10 @@ mod collect {\n             }\n             case (ast::native_item_ty(_, ?def_id)) {\n                 alt (cx.tcx.tcache.find(def_id)) {\n-                    case (some[ty::ty_param_count_and_ty](?tpt)) {\n+                    case (some(?tpt)) {\n                         ret tpt;\n                     }\n-                    case (none[ty::ty_param_count_and_ty]) {}\n+                    case (none) {}\n                 }\n \n                 auto t = ty::mk_native(cx.tcx);\n@@ -766,8 +766,8 @@ mod collect {\n \n                 // Finally, write in the type of the destructor.\n                 alt (object.dtor) {\n-                    case (none[@ast::method]) { /* nothing to do */ }\n-                    case (some[@ast::method](?m)) {\n+                    case (none) { /* nothing to do */ }\n+                    case (some(?m)) {\n                         // TODO: typechecker botch\n                         let vec[arg] no_args = [];\n                         auto t = ty::mk_fn(cx.tcx, ast::proto_fn, no_args,\n@@ -848,20 +848,20 @@ mod unify {\n                    &vec[mutable ty::t] param_substs) -> ty::unify::result {\n         auto cache_key = tup(expected, actual, param_substs);\n         alt (scx.fcx.ccx.unify_cache.find(cache_key)) {\n-            case (some[ty::unify::result](?r)) {\n+            case (some(?r)) {\n                 scx.fcx.ccx.cache_hits += 1u;\n                 ret r;\n             }\n-            case (none[ty::unify::result]) {\n+            case (none) {\n                 scx.fcx.ccx.cache_misses += 1u;\n             }\n         }\n \n         obj unify_handler(@stmt_ctxt scx, vec[mutable ty::t] param_substs) {\n             fn resolve_local(ast::def_id id) -> option::t[ty::t] {\n                 alt (scx.fcx.locals.find(id)) {\n-                    case (none[ty::t]) { ret none[ty::t]; }\n-                    case (some[ty::t](?existing_type)) {\n+                    case (none) { ret none[ty::t]; }\n+                    case (some(?existing_type)) {\n                         if (ty::type_contains_vars(scx.fcx.ccx.tcx,\n                                                    existing_type)) {\n                             // Not fully resolved yet. The writeback phase\n@@ -875,8 +875,8 @@ mod unify {\n             fn record_local(ast::def_id id, ty::t new_type) {\n                 auto unified_type;\n                 alt (scx.fcx.locals.find(id)) {\n-                    case (none[ty::t]) { unified_type = new_type; }\n-                    case (some[ty::t](?old_type)) {\n+                    case (none) { unified_type = new_type; }\n+                    case (some(?old_type)) {\n                         alt (with_params(scx, old_type, new_type,\n                                          param_substs)) {\n                             case (ures_ok(?ut)) { unified_type = ut; }\n@@ -1176,10 +1176,10 @@ mod pushdown {\n \n                 auto ty_params_opt;\n                 alt (ty_params_subst._0) {\n-                    case (none[vec[ty::t]]) {\n+                    case (none) {\n                         ty_params_opt = none[vec[ty::t]];\n                     }\n-                    case (some[vec[ty::t]](?tps)) {\n+                    case (some(?tps)) {\n                         ty_params_opt = some[vec[ty::t]](tag_tps);\n                     }\n                 }\n@@ -1245,7 +1245,7 @@ mod pushdown {\n                 alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_rec(?field_mts)) {\n                         alt (base_0) {\n-                            case (none[@ast::expr]) {\n+                            case (none) {\n                                 auto i = 0u;\n                                 for (ast::field field_0 in fields_0) {\n                                     assert (str::eq(field_0.ident,\n@@ -1256,7 +1256,7 @@ mod pushdown {\n                                     i += 1u;\n                                 }\n                             }\n-                            case (some[@ast::expr](?bx)) {\n+                            case (some(?bx)) {\n \n                                 let vec[field] base_fields = [];\n \n@@ -1354,8 +1354,8 @@ mod pushdown {\n                 pushdown_block(scx, expected, then_0);\n \n                 alt (else_0) {\n-                    case (none[@ast::expr]) { /* no-op */ }\n-                    case (some[@ast::expr](?e_0)) {\n+                    case (none) { /* no-op */ }\n+                    case (some(?e_0)) {\n                         auto else_t = ty::expr_ty(scx.fcx.ccx.tcx, e_0);\n                         pushdown_expr(scx, expected, e_0);\n                     }\n@@ -1426,10 +1426,10 @@ mod pushdown {\n                 auto ty_params_opt;\n                 alt (ty::ann_to_ty_param_substs_opt_and_ty\n                         (scx.fcx.ccx.tcx.node_types, ann)._0) {\n-                    case (none[vec[ty::t]]) {\n+                    case (none) {\n                         ty_params_opt = none[vec[ty::t]];\n                     }\n-                    case (some[vec[ty::t]](?tps)) {\n+                    case (some(?tps)) {\n                         ty_params_opt = some[vec[ty::t]](tps);\n                     }\n                 }\n@@ -1526,10 +1526,10 @@ mod pushdown {\n     // Push-down over typed blocks.\n     fn pushdown_block(&@stmt_ctxt scx, &ty::t expected, &ast::block bloc) {\n         alt (bloc.node.expr) {\n-            case (some[@ast::expr](?e_0)) {\n+            case (some(?e_0)) {\n                 pushdown_expr(scx, expected, e_0);\n             }\n-            case (none[@ast::expr]) {\n+            case (none) {\n                 /* empty */\n             }\n         }\n@@ -1546,12 +1546,12 @@ mod writeback {\n     fn wb_local(&@fn_ctxt fcx, &span sp, &@ast::local local) {\n         auto local_ty;\n         alt (fcx.locals.find(local.id)) {\n-            case (none[ty::t]) {\n+            case (none) {\n                 fcx.ccx.tcx.sess.span_err(sp,\n                     \"unable to determine type of local: \" + local.ident);\n                 fail;\n             }\n-            case (some[ty::t](?lt)) {\n+            case (some(?lt)) {\n                 local_ty = lt;\n             }\n         }\n@@ -1817,12 +1817,12 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         let vec[arg] arg_tys_0 = [];\n         for (option::t[@ast::expr] a_opt in args) {\n             alt (a_opt) {\n-                case (some[@ast::expr](?a)) {\n+                case (some(?a)) {\n                     check_expr(scx, a);\n                     auto typ = expr_ty(scx.fcx.ccx.tcx, a);\n                     vec::push[arg](arg_tys_0, rec(mode=mo_either, ty=typ));\n                 }\n-                case (none[@ast::expr]) {\n+                case (none) {\n                     auto typ = next_ty_var(scx);\n                     vec::push[arg](arg_tys_0, rec(mode=mo_either, ty=typ));\n                 }\n@@ -1999,7 +1999,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n         case (ast::expr_ret(?expr_opt, ?a)) {\n             alt (expr_opt) {\n-                case (none[@ast::expr]) {\n+                case (none) {\n                     auto nil = ty::mk_nil(scx.fcx.ccx.tcx);\n                     if (!are_compatible(scx, scx.fcx.ret_ty, nil)) {\n                         // TODO: span_err\n@@ -2010,7 +2010,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     write::bot_ty(scx.fcx.ccx.tcx, a.id);\n                 }\n \n-                case (some[@ast::expr](?e)) {\n+                case (some(?e)) {\n                     check_expr(scx, e);\n                     pushdown::pushdown_expr(scx, scx.fcx.ret_ty, e);\n \n@@ -2023,7 +2023,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             require_impure(scx.fcx.ccx.tcx.sess, scx.fcx.purity, expr.span);\n \n             alt (expr_opt) {\n-                case (none[@ast::expr]) {\n+                case (none) {\n                     auto nil = ty::mk_nil(scx.fcx.ccx.tcx);\n                     if (!are_compatible(scx, scx.fcx.ret_ty, nil)) {\n                          scx.fcx.ccx.tcx.sess.span_err(expr.span,\n@@ -2033,7 +2033,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     write::nil_ty(scx.fcx.ccx.tcx, a.id);\n                 }\n \n-                case (some[@ast::expr](?e)) {\n+                case (some(?e)) {\n                     check_expr(scx, e);\n                     pushdown::pushdown_expr(scx, scx.fcx.ret_ty, e);\n \n@@ -2164,7 +2164,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             check_block(scx, thn);\n \n             auto if_t = alt (elsopt) {\n-                case (some[@ast::expr](?els)) {\n+                case (some(?els)) {\n                     check_expr(scx, els);\n \n                     auto thn_t = block_ty(scx.fcx.ccx.tcx, thn);\n@@ -2175,7 +2175,7 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                         thn_t\n                     }\n                 }\n-                case (none[@ast::expr]) {\n+                case (none) {\n                     ty::mk_nil(scx.fcx.ccx.tcx)\n                 }\n             };\n@@ -2278,11 +2278,11 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         case (ast::expr_block(?b, ?a)) {\n             check_block(scx, b);\n             alt (b.node.expr) {\n-                case (some[@ast::expr](?expr)) {\n+                case (some(?expr)) {\n                     auto typ = expr_ty(scx.fcx.ccx.tcx, expr);\n                     write::ty_only_fixup(scx, a.id, typ);\n                 }\n-                case (none[@ast::expr]) {\n+                case (none) {\n                     auto typ = ty::mk_nil(scx.fcx.ccx.tcx);\n                     write::ty_only_fixup(scx, a.id, typ);\n                 }\n@@ -2309,8 +2309,8 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     auto i = 0u;\n                     while (i < vec::len[option::t[@ast::expr]](args)) {\n                         alt (args.(i)) {\n-                            case (some[@ast::expr](_)) { /* no-op */ }\n-                            case (none[@ast::expr]) {\n+                            case (some(_)) { /* no-op */ }\n+                            case (none) {\n                                 arg_tys_1 += [arg_tys.(i)];\n                             }\n                         }\n@@ -2359,15 +2359,15 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n \n             alt (this_obj_info) {\n                 // If we're inside a current object, grab its type.\n-                case (some[obj_info](?obj_info)) {\n+                case (some(?obj_info)) {\n                     // FIXME: In the case of anonymous objects with methods\n                     // containing self-calls, this lookup fails because\n                     // obj_info.this_obj is not in the type cache\n                     this_obj_ty = ty::lookup_item_type(scx.fcx.ccx.tcx, \n                                                        obj_info.this_obj)._1;\n                 }\n \n-                case (none[obj_info]) { fail; }\n+                case (none) { fail; }\n             }\n \n             // Grab this method's type out of the current object type.\n@@ -2454,8 +2454,8 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n         case (ast::expr_rec(?fields, ?base, ?a)) {\n \n             alt (base) {\n-                case (none[@ast::expr]) { /* no-op */}\n-                case (some[@ast::expr](?b_0)) { check_expr(scx, b_0); }\n+                case (none) { /* no-op */}\n+                case (some(?b_0)) { check_expr(scx, b_0); }\n             }\n \n             let vec[field] fields_t = [];\n@@ -2469,12 +2469,12 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             }\n \n             alt (base) {\n-                case (none[@ast::expr]) {\n+                case (none) {\n                     auto typ = ty::mk_rec(scx.fcx.ccx.tcx, fields_t);\n                     write::ty_only_fixup(scx, a.id, typ);\n                 }\n \n-                case (some[@ast::expr](?bexpr)) {\n+                case (some(?bexpr)) {\n                     check_expr(scx, bexpr);\n                     auto bexpr_t = expr_ty(scx.fcx.ccx.tcx, bexpr);\n \n@@ -2623,8 +2623,8 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             // We're entering an object, so gather up the info we need.\n             let vec[ast::obj_field] fields = [];\n             alt (anon_obj.fields) {\n-                case (none[vec[ast::obj_field]]) { }\n-                case (some[vec[ast::obj_field]](?v)) { fields = v; }\n+                case (none) { }\n+                case (some(?v)) { fields = v; }\n             }\n             let ast::def_id di = obj_def_ids.ty;\n \n@@ -2634,8 +2634,8 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             // Typecheck 'with_obj', if it exists.\n             let option::t[@ast::expr] with_obj = none[@ast::expr];\n             alt (anon_obj.with_obj) {\n-                case (none[@ast::expr]) { }\n-                case (some[@ast::expr](?e)) {\n+                case (none) { }\n+                case (some(?e)) {\n                     // This had better have object type.  TOOD: report an\n                     // error if the user is trying to extend a non-object\n                     // with_obj.\n@@ -2723,11 +2723,11 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n             auto t = ty::mk_nil(fcx.ccx.tcx);\n \n             alt (local.ty) {\n-                case (none[@ast::ty]) {\n+                case (none) {\n                     // Auto slot. Do nothing for now.\n                 }\n \n-                case (some[@ast::ty](?ast_ty)) {\n+                case (some(?ast_ty)) {\n                     auto local_ty = ast_ty_to_ty_crate(fcx.ccx, ast_ty);\n                     fcx.locals.insert(local.id, local_ty);\n                     t = local_ty;\n@@ -2739,7 +2739,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n \n             auto initopt = local.init;\n             alt (local.init) {\n-                case (some[ast::initializer](?init)) {\n+                case (some(?init)) {\n                     with_stmt_ctxt(fcx,\n                         bind check_decl_initializer(_, local.id, init));\n                 }\n@@ -2780,10 +2780,10 @@ fn check_block(&@stmt_ctxt scx, &ast::block block) {\n     for (@ast::stmt s in block.node.stmts) { check_stmt(scx.fcx, s); }\n \n     alt (block.node.expr) {\n-        case (none[@ast::expr]) {\n+        case (none) {\n             write::nil_ty(scx.fcx.ccx.tcx, block.node.a.id);\n         }\n-        case (some[@ast::expr](?e)) {\n+        case (some(?e)) {\n             check_expr(scx, e);\n             auto ety = expr_ty(scx.fcx.ccx.tcx, e);\n             pushdown::pushdown_expr(scx, ety, e);\n@@ -2814,13 +2814,13 @@ fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n     // again here, we can extract them.\n \n     alt (get_obj_info(ccx)) {\n-        case (option::some[obj_info](?oinfo)) {\n+        case (option::some(?oinfo)) {\n             for (ast::obj_field f in oinfo.obj_fields) {\n                 auto field_ty = ty::ann_to_type(ccx.tcx.node_types, f.ann);\n                 local_ty_table.insert(f.id, field_ty);\n             }\n         }\n-        case (option::none[obj_info]) { /* no fields */ }\n+        case (option::none) { /* no fields */ }\n     }\n \n     // Store the type of each argument in the table."}, {"sha": "3d50c2ddfbcbb6533c54a45727c7ee0094cfd260", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -127,8 +127,8 @@ fn walk_item(&ast_visitor v, @ast::item i) {\n                 v.visit_method_post(m);\n             }\n             alt (ob.dtor) {\n-                case (none[@ast::method]) {}\n-                case (some[@ast::method](?m)) {\n+                case (none) {}\n+                case (some(?m)) {\n                     walk_fn(v, m.node.meth, m.span, m.node.ident, m.node.id,\n                             m.node.ann);\n                 }\n@@ -277,12 +277,12 @@ fn walk_decl(&ast_visitor v, @ast::decl d) {\n     alt (d.node) {\n         case (ast::decl_local(?loc)) {\n             alt (loc.ty) {\n-                case (none[@ast::ty]) {}\n-                case (some[@ast::ty](?t)) { walk_ty(v, t); }\n+                case (none) {}\n+                case (some(?t)) { walk_ty(v, t); }\n             }\n             alt (loc.init) {\n-                case (none[ast::initializer]) {}\n-                case (some[ast::initializer](?i)) {\n+                case (none) {}\n+                case (some(?i)) {\n                     walk_expr(v, i.expr);\n                 }\n             }\n@@ -296,8 +296,8 @@ fn walk_decl(&ast_visitor v, @ast::decl d) {\n \n fn walk_expr_opt(&ast_visitor v, option::t[@ast::expr] eo) {\n     alt (eo) {\n-        case (none[@ast::expr]) {}\n-        case (some[@ast::expr](?e)) {\n+        case (none) {}\n+        case (some(?e)) {\n             walk_expr(v, e);\n         }\n     }\n@@ -454,8 +454,8 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n                 = none[vec[ast::obj_field]];\n \n             alt (anon_obj.fields) {\n-                case (none[vec[ast::obj_field]]) { }\n-                case (some[vec[ast::obj_field]](?fields)) {\n+                case (none) { }\n+                case (some(?fields)) {\n                     for (ast::obj_field f in fields) {\n                         walk_ty(v, f.ty);\n                     }\n@@ -465,8 +465,8 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n             // with_obj\n             let option::t[@ast::expr] with_obj = none[@ast::expr];\n             alt (anon_obj.with_obj) {\n-                case (none[@ast::expr]) { }\n-                case (some[@ast::expr](?e)) {\n+                case (none) { }\n+                case (some(?e)) {\n                     walk_expr(v, e);\n                 }\n             }"}, {"sha": "070324dd9e83cfb842a8c30c16b8e76f2137dcf2", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -297,7 +297,7 @@ fn has_nonlocal_exits(&ast::block b) -> bool {\n \n fn local_rhs_span(&@ast::local l, &ast::span def) -> ast::span {\n     alt (l.init) {\n-        case (some[ast::initializer](?i)) { ret i.expr.span; }\n+        case (some(?i)) { ret i.expr.span; }\n         case (_) { ret def; }\n     }\n }"}, {"sha": "cdc41b6c869d0a6712be04110749b6126b0dd834", "filename": "src/comp/util/data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Futil%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc2d8728b622275d55243cbacbc7834641503f/src%2Fcomp%2Futil%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fdata.rs?ref=81fc2d8728b622275d55243cbacbc7834641503f", "patch": "@@ -27,8 +27,8 @@ mod interner {\n \n     fn intern[T](&interner[T] itr, &T val) -> uint {\n         alt (itr.map.find(val)) {\n-            case (some[uint](?idx)) { ret idx; }\n-            case (none[uint]) {\n+            case (some(?idx)) { ret idx; }\n+            case (none) {\n                 auto new_idx = vec::len[T](itr.vect);\n                 itr.map.insert(val, new_idx);\n                 itr.vect += [val];"}]}