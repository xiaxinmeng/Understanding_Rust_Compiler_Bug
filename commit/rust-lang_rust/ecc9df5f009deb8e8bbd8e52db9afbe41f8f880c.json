{"sha": "ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYzlkZjVmMDA5ZGViOGU4YmJkOGU1MmRiOWFmYmU0MWY4Zjg4MGM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-21T19:24:59Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-21T19:24:59Z"}, "message": "simpler update", "tree": {"sha": "562598b1215fd67dc93860acca66852c114bc5c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/562598b1215fd67dc93860acca66852c114bc5c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c", "html_url": "https://github.com/rust-lang/rust/commit/ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b937262c9b75a361b95a6a27260a71c737e035bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b937262c9b75a361b95a6a27260a71c737e035bf", "html_url": "https://github.com/rust-lang/rust/commit/b937262c9b75a361b95a6a27260a71c737e035bf"}], "stats": {"total": 222, "additions": 149, "deletions": 73}, "files": [{"sha": "fee0d10d6c44ef543f31a03b52608c1e8d941ca9", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c", "patch": "@@ -17,7 +17,6 @@ use rayon::prelude::*;\n \n use std::{\n     fmt,\n-    mem,\n     path::{Path},\n     sync::{\n         Arc,\n@@ -36,18 +35,16 @@ use libeditor::{LineIndex, FileSymbol, find_node};\n \n use self::{\n     symbol_index::FileSymbols,\n-    module_map::ModuleMap,\n+    module_map::{ModuleMap, ChangeKind},\n };\n pub use self::symbol_index::Query;\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n-const INDEXING_THRESHOLD: usize = 128;\n \n pub type FileResolver = dyn Fn(FileId, &Path) -> Option<FileId> + Send + Sync;\n \n #[derive(Debug)]\n pub struct WorldState {\n-    updates: Vec<FileId>,\n     data: Arc<WorldData>\n }\n \n@@ -79,32 +76,16 @@ pub struct FileId(pub u32);\n impl WorldState {\n     pub fn new() -> WorldState {\n         WorldState {\n-            updates: Vec::new(),\n             data: Arc::new(WorldData::default()),\n         }\n     }\n \n     pub fn snapshot(\n-        &mut self,\n+        &self,\n         file_resolver: impl Fn(FileId, &Path) -> Option<FileId> + 'static + Send + Sync,\n     ) -> World {\n-        let needs_reindex = self.updates.len() >= INDEXING_THRESHOLD;\n-        if !self.updates.is_empty() {\n-            let updates = mem::replace(&mut self.updates, Vec::new());\n-            let data = self.data_mut();\n-            for file_id in updates {\n-                let syntax = data.file_map\n-                    .get(&file_id)\n-                    .map(|it| it.syntax());\n-                data.module_map.update_file(\n-                    file_id,\n-                    syntax,\n-                    &file_resolver,\n-                );\n-            }\n-        }\n         World {\n-            needs_reindex: AtomicBool::new(needs_reindex),\n+            needs_reindex: AtomicBool::new(false),\n             file_resolver: Arc::new(file_resolver),\n             data: self.data.clone()\n         }\n@@ -115,21 +96,26 @@ impl WorldState {\n     }\n \n     pub fn change_files(&mut self, changes: impl Iterator<Item=(FileId, Option<String>)>) {\n-        let mut updates = Vec::new();\n-        {\n-            let data = self.data_mut();\n-            for (file_id, text) in changes {\n-                data.file_map.remove(&file_id);\n-                if let Some(text) = text {\n-                    let file_data = FileData::new(text);\n-                    data.file_map.insert(file_id, Arc::new(file_data));\n+        let data = self.data_mut();\n+        for (file_id, text) in changes {\n+            let change_kind = if data.file_map.remove(&file_id).is_some() {\n+                if text.is_some() {\n+                    ChangeKind::Update\n                 } else {\n-                    data.file_map.remove(&file_id);\n+                    ChangeKind::Delete\n                 }\n-                updates.push(file_id);\n+            } else {\n+                ChangeKind::Insert\n+            };\n+            data.module_map.update_file(file_id, change_kind);\n+            data.file_map.remove(&file_id);\n+            if let Some(text) = text {\n+                let file_data = FileData::new(text);\n+                data.file_map.insert(file_id, Arc::new(file_data));\n+            } else {\n+                data.file_map.remove(&file_id);\n             }\n         }\n-        self.updates.extend(updates)\n     }\n \n     fn data_mut(&mut self) -> &mut WorldData {\n@@ -171,13 +157,17 @@ impl World {\n         let module_map = &self.data.module_map;\n         let id = module_map.file2module(id);\n         module_map\n-            .parent_modules(id)\n+            .parent_modules(\n+                id,\n+                &*self.file_resolver,\n+                &|file_id| self.file_syntax(file_id).unwrap(),\n+            )\n             .into_iter()\n-            .map(|(id, m)| {\n+            .map(|(id, name, node)| {\n                 let id = module_map.module2file(id);\n                 let sym = FileSymbol {\n-                    name: m.name().unwrap().text(),\n-                    node_range: m.syntax().range(),\n+                    name,\n+                    node_range: node.range(),\n                     kind: MODULE,\n                 };\n                 (id, sym)\n@@ -235,7 +225,11 @@ impl World {\n         let module_map = &self.data.module_map;\n         let id = module_map.file2module(id);\n         module_map\n-            .child_module_by_name(id, name.as_str())\n+            .child_module_by_name(\n+                id, name.as_str(),\n+                &*self.file_resolver,\n+                &|file_id| self.file_syntax(file_id).unwrap(),\n+            )\n             .into_iter()\n             .map(|id| module_map.module2file(id))\n             .collect()"}, {"sha": "83e6e57f71fad429b8f34480230b3154605c6cd1", "filename": "crates/libanalysis/src/module_map.rs", "status": "modified", "additions": 115, "deletions": 33, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs?ref=ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c", "patch": "@@ -2,17 +2,38 @@ use std::{\n     path::{PathBuf},\n };\n \n+use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};\n use libsyntax2::{\n-    ast::{self, AstNode, NameOwner},\n-    SyntaxNode, ParsedFile, SmolStr,\n+    ast::{self, AstNode, NameOwner, ParsedFile},\n+    SyntaxNode, SmolStr,\n };\n use {FileId, FileResolver};\n \n+type SyntaxProvider<'a> = dyn Fn(FileId) -> ParsedFile + 'a;\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct ModuleId(FileId);\n \n-#[derive(Clone, Debug, Default)]\n+#[derive(Debug, Default)]\n pub struct ModuleMap {\n+    state: RwLock<State>,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ChangeKind {\n+    Delete, Insert, Update\n+}\n+\n+impl Clone for ModuleMap {\n+    fn clone(&self) -> ModuleMap {\n+        let state = self.state.read().clone();\n+        ModuleMap { state: RwLock::new(state) }\n+    }\n+}\n+\n+#[derive(Clone, Debug, Default)]\n+struct State {\n+    changes: Vec<(FileId, ChangeKind)>,\n     links: Vec<Link>,\n }\n \n@@ -24,31 +45,8 @@ struct Link {\n }\n \n impl ModuleMap {\n-    pub fn update_file(\n-        &mut self,\n-        file_id: FileId,\n-        syntax: Option<&ParsedFile>,\n-        file_resolver: &FileResolver,\n-    ) {\n-        let mod_id = ModuleId(file_id);\n-        self.links.retain(|link| link.owner != mod_id);\n-        match syntax {\n-            None => {\n-                for link in self.links.iter_mut() {\n-                    link.points_to.retain(|&x| x != mod_id);\n-                }\n-            }\n-            Some(syntax) => {\n-                self.links.extend(\n-                    syntax.ast().modules().filter_map(|it| {\n-                        Link::new(mod_id, it)\n-                    })\n-                )\n-            }\n-        }\n-        self.links.iter_mut().for_each(|link| {\n-            link.resolve(file_resolver)\n-        })\n+    pub fn update_file(&mut self, file: FileId, change_kind: ChangeKind) {\n+        self.state.get_mut().changes.push((file, change_kind));\n     }\n \n     pub fn module2file(&self, m: ModuleId) -> FileId {\n@@ -59,8 +57,15 @@ impl ModuleMap {\n         ModuleId(file_id)\n     }\n \n-    pub fn child_module_by_name(&self, parent_mod: ModuleId, child_mod: &str) -> Vec<ModuleId> {\n-        self.links\n+    pub fn child_module_by_name<'a>(\n+        &self,\n+        parent_mod: ModuleId,\n+        child_mod: &str,\n+        file_resolver: &FileResolver,\n+        syntax_provider: &SyntaxProvider,\n+    ) -> Vec<ModuleId> {\n+        self.links(file_resolver, syntax_provider)\n+            .links\n             .iter()\n             .filter(|link| link.owner == parent_mod)\n             .filter(|link| link.name() == child_mod)\n@@ -69,13 +74,90 @@ impl ModuleMap {\n             .collect()\n     }\n \n-    pub fn parent_modules<'a>(&'a self, m: ModuleId) -> impl Iterator<Item=(ModuleId, ast::Module<'a>)> + 'a {\n-        self.links\n+    pub fn parent_modules(\n+        &self,\n+        m: ModuleId,\n+        file_resolver: &FileResolver,\n+        syntax_provider: &SyntaxProvider,\n+    ) -> Vec<(ModuleId, SmolStr, SyntaxNode)> {\n+        let links = self.links(file_resolver, syntax_provider);\n+        let res = links\n+            .links\n             .iter()\n             .filter(move |link| link.points_to.iter().any(|&it| it == m))\n             .map(|link| {\n-                (link.owner, link.ast())\n+                (link.owner, link.name().clone(), link.syntax.clone())\n             })\n+            .collect();\n+        res\n+    }\n+\n+    fn links(\n+        &self,\n+        file_resolver: &FileResolver,\n+        syntax_provider: &SyntaxProvider,\n+    ) -> RwLockReadGuard<State> {\n+        {\n+            let guard = self.state.read();\n+            if guard.changes.is_empty() {\n+                return guard;\n+            }\n+        }\n+        let mut guard = self.state.write();\n+        if !guard.changes.is_empty() {\n+            guard.apply_changes(file_resolver, syntax_provider);\n+        }\n+        assert!(guard.changes.is_empty());\n+        RwLockWriteGuard::downgrade(guard)\n+    }\n+}\n+\n+impl State {\n+    pub fn apply_changes(\n+        &mut self,\n+        file_resolver: &FileResolver,\n+        syntax_provider: &SyntaxProvider,\n+    ) {\n+        let mut reresolve = false;\n+        for (file_id, kind) in self.changes.drain(..) {\n+            let mod_id = ModuleId(file_id);\n+            self.links.retain(|link| link.owner != mod_id);\n+            match kind {\n+                ChangeKind::Delete => {\n+                    for link in self.links.iter_mut() {\n+                        link.points_to.retain(|&x| x != mod_id);\n+                    }\n+                }\n+                ChangeKind::Insert => {\n+                    let file = syntax_provider(file_id);\n+                    self.links.extend(\n+                        file\n+                            .ast()\n+                            .modules()\n+                            .filter_map(|it| Link::new(mod_id, it))\n+                    );\n+                    reresolve = true;\n+                }\n+                ChangeKind::Update => {\n+                    let file = syntax_provider(file_id);\n+                    self.links.extend(\n+                        file\n+                            .ast()\n+                            .modules()\n+                            .filter_map(|it| Link::new(mod_id, it))\n+                            .map(|mut link| {\n+                                link.resolve(file_resolver);\n+                                link\n+                            })\n+                    );\n+                }\n+            }\n+        }\n+        if reresolve {\n+            for link in self.links.iter_mut() {\n+                link.resolve(file_resolver)\n+            }\n+        }\n     }\n }\n "}, {"sha": "752d6ddb21edc314ee9b31830fac2be5762161ea", "filename": "crates/server/src/main_loop/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs?ref=ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c", "patch": "@@ -252,7 +252,7 @@ fn on_notification(\n fn handle_request_on_threadpool<R: req::ClientRequest>(\n     req: &mut Option<RawRequest>,\n     pool: &ThreadPool,\n-    world: &mut ServerWorldState,\n+    world: &ServerWorldState,\n     sender: &Sender<Task>,\n     f: fn(ServerWorld, R::Params) -> Result<R::Result>,\n ) -> Result<()>"}, {"sha": "c0d2efb8638790243abcb335573438ee7f7e08c2", "filename": "crates/server/src/server_world.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c/crates%2Fserver%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c/crates%2Fserver%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fserver_world.rs?ref=ecc9df5f009deb8e8bbd8e52db9afbe41f8f880c", "patch": "@@ -86,7 +86,7 @@ impl ServerWorldState {\n         Ok(())\n     }\n \n-    pub fn snapshot(&mut self) -> ServerWorld {\n+    pub fn snapshot(&self) -> ServerWorld {\n         let pm = self.path_map.clone();\n         ServerWorld {\n             analysis: self.analysis.snapshot(move |id, path| {"}]}