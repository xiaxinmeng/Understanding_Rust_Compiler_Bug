{"sha": "df487317d08eb1bf194e87aa7c193bb738ed7546", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNDg3MzE3ZDA4ZWIxYmYxOTRlODdhYTdjMTkzYmI3MzhlZDc1NDY=", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2021-09-17T21:52:40Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2021-09-17T21:52:40Z"}, "message": "Merge commit '48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267' into libgccjit-codegen", "tree": {"sha": "55809bfa285895a267b36eb05873008679c50bb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55809bfa285895a267b36eb05873008679c50bb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df487317d08eb1bf194e87aa7c193bb738ed7546", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df487317d08eb1bf194e87aa7c193bb738ed7546", "html_url": "https://github.com/rust-lang/rust/commit/df487317d08eb1bf194e87aa7c193bb738ed7546", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df487317d08eb1bf194e87aa7c193bb738ed7546/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87f8525faacba5299577db41371185c186def330", "url": "https://api.github.com/repos/rust-lang/rust/commits/87f8525faacba5299577db41371185c186def330", "html_url": "https://github.com/rust-lang/rust/commit/87f8525faacba5299577db41371185c186def330"}, {"sha": "48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "url": "https://api.github.com/repos/rust-lang/rust/commits/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267", "html_url": "https://github.com/rust-lang/rust/commit/48d60ab7c505c6c1ebb042eacaafd8dc9f7a9267"}], "stats": {"total": 1083, "additions": 735, "deletions": 348}, "files": [{"sha": "cf2dcd4d099c2f6f412b53796be986484838ee41", "filename": "compiler/rustc_codegen_gcc/.github/FUNDING.yml", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87f8525faacba5299577db41371185c186def330/compiler%2Frustc_codegen_gcc%2F.github%2FFUNDING.yml", "raw_url": "https://github.com/rust-lang/rust/raw/87f8525faacba5299577db41371185c186def330/compiler%2Frustc_codegen_gcc%2F.github%2FFUNDING.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2FFUNDING.yml?ref=87f8525faacba5299577db41371185c186def330", "patch": "@@ -1,2 +0,0 @@\n-github: antoyo\n-patreon: antoyo"}, {"sha": "98bed8ef387ff4fee2f2c513f89f4db1655eeec3", "filename": "compiler/rustc_codegen_gcc/.github/workflows/main.yml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fmain.yml?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -31,7 +31,9 @@ jobs:\n           ln gcc-build/libgccjit.so gcc-build/libgccjit.so.0\n \n     - name: Set LIBRARY_PATH\n-      run: echo \"LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+      run: |\n+        echo \"LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"LD_LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n \n     # https://github.com/actions/cache/issues/133\n     - name: Fixup owner of ~/.cargo/\n@@ -66,6 +68,7 @@ jobs:\n       run: |\n         ./prepare_build.sh\n         ./build.sh\n+        cargo test\n         ./clean_all.sh\n \n     - name: Prepare dependencies"}, {"sha": "1e2f9e3aebb2cd83b6ae296b833efc75c3e10f92", "filename": "compiler/rustc_codegen_gcc/.gitignore", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.gitignore?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -7,11 +7,14 @@ perf.data.old\n *.events\n *.string*\n /build_sysroot/sysroot\n+/build_sysroot/sysroot_src\n /build_sysroot/Cargo.lock\n /build_sysroot/test_target/Cargo.lock\n /rust\n+/simple-raytracer\n /regex\n gimple*\n *asm\n res\n test-backend\n+gcc_path"}, {"sha": "f3e07fd08ee8e278975c98c59e3f0a03e4198d0d", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -56,15 +56,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#0572117c7ffdfcb0e6c6526d45266c3f34796bea\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#54be27e41fff7b6ab532e2e21a82df50a12b9ad3\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#0572117c7ffdfcb0e6c6526d45266c3f34796bea\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#54be27e41fff7b6ab532e2e21a82df50a12b9ad3\"\n dependencies = [\n  \"libc 0.1.12\",\n ]"}, {"sha": "1f27d721fabbb4c52ffbb87ff17881a0c4c1e46d", "filename": "compiler/rustc_codegen_gcc/Readme.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FReadme.md?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -19,7 +19,7 @@ You can also use my [fork of gcc](https://github.com/antoyo/gcc) which already i\n **Put the path to your custom build of libgccjit in the file `gcc_path`.**\n \n ```bash\n-$ git clone https://github.com/antoyo/rustc_codegen_gcc.git\n+$ git clone https://github.com/rust-lang/rustc_codegen_gcc.git\n $ cd rustc_codegen_gcc\n $ ./prepare_build.sh # download and patch sysroot src\n $ ./build.sh --release\n@@ -113,6 +113,5 @@ p loc->m_line\n \n ### How to use a custom-build rustc\n \n- * Build the stage1 compiler (`rustup toolchain link debug-current stage2 build/x86_64-unknown-linux-gnu/stage1`).\n+ * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`).\n  * Clean and rebuild the codegen with `debug-current` in the file `rust-toolchain`.\n- * Add `~/.rustup/toolchains/debug-current/lib/rustlib/x86_64-unknown-linux-gnu/lib` to `LD_LIBRARY_PATH`."}, {"sha": "17a0d2ab3f0601f92b56bccff8b7ba0adde227d5", "filename": "compiler/rustc_codegen_gcc/build.sh", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild.sh?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -3,7 +3,12 @@\n #set -x\n set -e\n \n-export GCC_PATH=$(cat gcc_path)\n+if [ -f ./gcc_path ]; then \n+    export GCC_PATH=$(cat gcc_path)\n+else\n+    echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n+    exit 1\n+fi\n \n export LD_LIBRARY_PATH=\"$GCC_PATH\"\n export LIBRARY_PATH=\"$GCC_PATH\""}, {"sha": "1001c522052c800b15d170971d187b6987092288", "filename": "compiler/rustc_codegen_gcc/cargo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fcargo.sh?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -20,4 +20,4 @@ fi\n cmd=$1\n shift\n \n-RUSTDOCFLAGS=$RUSTFLAGS cargo +${TOOLCHAIN} $cmd --target $TARGET_TRIPLE $@\n+RUSTDOCFLAGS=\"$RUSTFLAGS\" cargo +${TOOLCHAIN} $cmd --target $TARGET_TRIPLE $@"}, {"sha": "98caeb7407e084fc585bd49733b3882a0b6ec104", "filename": "compiler/rustc_codegen_gcc/config.sh", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fconfig.sh?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -2,7 +2,12 @@ set -e\n \n export CARGO_INCREMENTAL=0\n \n-export GCC_PATH=$(cat gcc_path)\n+if [ -f ./gcc_path ]; then \n+    export GCC_PATH=$(cat gcc_path)\n+else\n+    echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n+    exit 1\n+fi\n \n unamestr=`uname`\n if [[ \"$unamestr\" == 'Linux' ]]; then\n@@ -30,7 +35,7 @@ if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n    fi\n fi\n \n-export RUSTFLAGS=$linker' -Cpanic=abort -Cdebuginfo=2 -Zpanic-abort-tests -Zcodegen-backend='$(pwd)'/target/'$CHANNEL'/librustc_codegen_gcc.'$dylib_ext' --sysroot '$(pwd)'/build_sysroot/sysroot'\n+export RUSTFLAGS=\"$linker -Cpanic=abort -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n \n # FIXME(antoyo): remove once the atomic shim is gone\n if [[ `uname` == 'Darwin' ]]; then"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "compiler/rustc_codegen_gcc/gcc_path", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/87f8525faacba5299577db41371185c186def330/compiler%2Frustc_codegen_gcc%2Fgcc_path", "raw_url": "https://github.com/rust-lang/rust/raw/87f8525faacba5299577db41371185c186def330/compiler%2Frustc_codegen_gcc%2Fgcc_path", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fgcc_path?ref=87f8525faacba5299577db41371185c186def330"}, {"sha": "a03d26c0467e18aadccbc22c1ba417012ca15538", "filename": "compiler/rustc_codegen_gcc/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frust-toolchain?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -1 +1 @@\n-nightly-2021-08-12\n+nightly-2021-09-17"}, {"sha": "6378a31202c1b88b1e2d213b5518e28c422b52a8", "filename": "compiler/rustc_codegen_gcc/src/allocator.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -6,7 +6,7 @@ use rustc_span::symbol::sym;\n \n use crate::GccContext;\n \n-pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, kind: AllocatorKind, has_alloc_error_handler: bool) {\n+pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n     let context = &mods.context;\n     let usize =\n         match tcx.sess.target.pointer_width {\n@@ -77,6 +77,9 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, kind: Alloc\n         else {\n             block.end_with_void_return(None);\n         }\n+\n+        // TODO(@Commeownist): Check if we need to emit some extra debugging info in certain circumstances\n+        // as described in https://github.com/rust-lang/rust/commit/77a96ed5646f7c3ee8897693decc4626fe380643\n     }\n \n     let types = [usize, usize];"}, {"sha": "d749d763402b810ebd35508cbb5ec1b33ea2dfba", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 21, "deletions": 73, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -2,16 +2,15 @@ use std::fs::File;\n use std::path::{Path, PathBuf};\n \n use rustc_session::Session;\n-use rustc_codegen_ssa::back::archive::{find_library, ArchiveBuilder};\n-use rustc_codegen_ssa::METADATA_FILENAME;\n+use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n+\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_middle::middle::cstore::DllImport;\n-use rustc_span::symbol::Symbol;\n+\n \n struct ArchiveConfig<'a> {\n     sess: &'a Session,\n     dst: PathBuf,\n-    lib_search_paths: Vec<PathBuf>,\n     use_native_ar: bool,\n     use_gnu_style_archive: bool,\n }\n@@ -35,11 +34,9 @@ pub struct ArArchiveBuilder<'a> {\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> Self {\n-        use rustc_codegen_ssa::back::link::archive_search_paths;\n         let config = ArchiveConfig {\n             sess,\n             dst: output.to_path_buf(),\n-            lib_search_paths: archive_search_paths(sess),\n             use_native_ar: false,\n             // FIXME test for linux and System V derivatives instead\n             use_gnu_style_archive: sess.target.options.archive_format == \"gnu\",\n@@ -94,47 +91,27 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         ));\n     }\n \n-    fn add_native_library(&mut self, name: Symbol, verbatim: bool) {\n-        let location = find_library(name, verbatim, &self.config.lib_search_paths, self.config.sess);\n-        self.add_archive(location.clone(), |_| false)\n-            .unwrap_or_else(|e| {\n-                panic!(\n-                    \"failed to add native library {}: {}\",\n-                    location.to_string_lossy(),\n-                    e\n-                );\n-            });\n-    }\n-\n-    fn add_rlib(\n-        &mut self,\n-        rlib: &Path,\n-        name: &str,\n-        lto: bool,\n-        skip_objects: bool,\n-    ) -> std::io::Result<()> {\n-        let obj_start = name.to_owned();\n-\n-        self.add_archive(rlib.to_owned(), move |fname: &str| {\n-            // Ignore metadata files, no matter the name.\n-            if fname == METADATA_FILENAME {\n-                return true;\n-            }\n-\n-            // Don't include Rust objects if LTO is enabled\n-            if lto && fname.starts_with(&obj_start) && fname.ends_with(\".o\") {\n-                return true;\n-            }\n+    fn add_archive<F>(&mut self, archive_path: &Path, mut skip: F) -> std::io::Result<()>\n+    where\n+        F: FnMut(&str) -> bool + 'static,\n+    {\n+        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n+        let archive_index = self.src_archives.len();\n \n-            // Otherwise if this is *not* a rust object and we're skipping\n-            // objects then skip this file\n-            if skip_objects && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n-                return true;\n+        let mut i = 0;\n+        while let Some(entry) = archive.next_entry() {\n+            let entry = entry?;\n+            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n+                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n+            if !skip(&file_name) {\n+                self.entries\n+                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n             }\n+            i += 1;\n+        }\n \n-            // ok, don't skip this\n-            return false;\n-        })\n+        self.src_archives.push((archive_path.to_owned(), archive));\n+        Ok(())\n     }\n \n     fn update_symbols(&mut self) {\n@@ -239,32 +216,3 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         unimplemented!();\n     }\n }\n-\n-impl<'a> ArArchiveBuilder<'a> {\n-    fn add_archive<F>(&mut self, archive_path: PathBuf, mut skip: F) -> std::io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n-        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n-        let archive_index = self.src_archives.len();\n-\n-        let mut i = 0;\n-        while let Some(entry) = archive.next_entry() {\n-            let entry = entry.unwrap();\n-            let file_name = String::from_utf8(entry.header().identifier().to_vec()).unwrap();\n-            if !skip(&file_name) {\n-                self.entries.push((\n-                    file_name,\n-                    ArchiveEntry::FromArchive {\n-                        archive_index,\n-                        entry_index: i,\n-                    },\n-                ));\n-            }\n-            i += 1;\n-        }\n-\n-        self.src_archives.push((archive_path, archive));\n-        Ok(())\n-    }\n-}"}, {"sha": "a684c34b644101d6ba1a31f25f4ab869063e4ecd", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 517, "deletions": 205, "changes": 722, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -1,254 +1,542 @@\n-use gccjit::{RValue, ToRValue, Type};\n+use gccjit::{LValue, RValue, ToRValue, Type};\n use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_codegen_ssa::mir::operand::OperandValue;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{AsmBuilderMethods, AsmMethods, BaseTypeMethods, BuilderMethods, GlobalAsmOperandRef, InlineAsmOperandRef};\n-use rustc_data_structures::fx::FxHashMap;\n+\n use rustc_hir::LlvmInlineAsmInner;\n-use rustc_middle::bug;\n+use rustc_middle::{bug, ty::Instance};\n use rustc_span::Span;\n use rustc_target::asm::*;\n \n+use std::borrow::Cow;\n+\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n \n+\n+// Rust asm! and GCC Extended Asm semantics differ substantially.\n+//\n+// 1. Rust asm operands go along as one list of operands. Operands themselves indicate \n+//    if they're \"in\" or \"out\". \"In\" and \"out\" operands can interleave. One operand can be \n+//    both \"in\" and \"out\" (`inout(reg)`).\n+//\n+//    GCC asm has two different lists for \"in\" and \"out\" operands. In terms of gccjit, \n+//    this means that all \"out\" operands must go before \"in\" operands. \"In\" and \"out\" operands \n+//    cannot interleave.\n+//\n+// 2. Operand lists in both Rust and GCC are indexed. Index starts from 0. Indexes are important \n+//    because the asm template refers to operands by index.\n+//\n+//    Mapping from Rust to GCC index would be 1-1 if it wasn't for...\n+//\n+// 3. Clobbers. GCC has a separate list of clobbers, and clobbers don't have indexes. \n+//    Contrary, Rust expresses clobbers through \"out\" operands that aren't tied to \n+//    a variable (`_`),  and such \"clobbers\" do have index.\n+//\n+// 4. Furthermore, GCC Extended Asm does not support explicit register constraints \n+//    (like `out(\"eax\")`) directly, offering so-called \"local register variables\" \n+//    as a workaround. These variables need to be declared and initialized *before* \n+//    the Extended Asm block but *after* normal local variables \n+//    (see comment in `codegen_inline_asm` for explanation).\n+//\n+// With that in mind, let's see how we translate Rust syntax to GCC \n+// (from now on, `CC` stands for \"constraint code\"):\n+//\n+// * `out(reg_class) var`   -> translated to output operand: `\"=CC\"(var)`\n+// * `inout(reg_class) var` -> translated to output operand: `\"+CC\"(var)`\n+// * `in(reg_class) var`    -> translated to input operand: `\"CC\"(var)`\n+//\n+// * `out(reg_class) _` -> translated to one `=r(tmp)`, where \"tmp\" is a temporary unused variable\n+//\n+// * `out(\"explicit register\") _` -> not translated to any operands, register is simply added to clobbers list\n+//\n+// * `inout(reg_class) in_var => out_var` -> translated to two operands: \n+//                              output: `\"=CC\"(in_var)`\n+//                              input:  `\"num\"(out_var)` where num is the GCC index \n+//                                       of the corresponding output operand\n+//\n+// * `inout(reg_class) in_var => _` -> same as `inout(reg_class) in_var => tmp`, \n+//                                      where \"tmp\" is a temporary unused variable\n+//\n+// * `out/in/inout(\"explicit register\") var` -> translated to one or two operands as described above \n+//                                              with `\"r\"(var)` constraint, \n+//                                              and one register variable assigned to the desired register.\n+// \n+\n+const ATT_SYNTAX_INS: &str = \".att_syntax noprefix\\n\\t\";\n+const INTEL_SYNTAX_INS: &str = \"\\n\\t.intel_syntax noprefix\";\n+\n+\n+struct AsmOutOperand<'a, 'tcx, 'gcc> {\n+    rust_idx: usize,\n+    constraint: &'a str,\n+    late: bool,\n+    readwrite: bool,\n+\n+    tmp_var: LValue<'gcc>,\n+    out_place: Option<PlaceRef<'tcx, RValue<'gcc>>>\n+}\n+\n+struct AsmInOperand<'a, 'tcx> {\n+    rust_idx: usize,\n+    constraint: Cow<'a, str>,\n+    val: RValue<'tcx>\n+}\n+\n+impl AsmOutOperand<'_, '_, '_> {\n+    fn to_constraint(&self) -> String {\n+        let mut res = String::with_capacity(self.constraint.len() + self.late as usize + 1);\n+\n+        let sign = if self.readwrite { '+' } else { '=' };\n+        res.push(sign);\n+        if !self.late {\n+            res.push('&');\n+        }\n+\n+        res.push_str(&self.constraint);\n+        res\n+    }\n+}\n+\n+enum ConstraintOrRegister {\n+    Constraint(&'static str),\n+    Register(&'static str)\n+}\n+\n+\n impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn codegen_llvm_inline_asm(&mut self, _ia: &LlvmInlineAsmInner, _outputs: Vec<PlaceRef<'tcx, RValue<'gcc>>>, mut _inputs: Vec<RValue<'gcc>>, _span: Span) -> bool {\n-        // TODO(antoyo)\n-        return true;\n+    fn codegen_llvm_inline_asm(&mut self, _ia: &LlvmInlineAsmInner, _outputs: Vec<PlaceRef<'tcx, RValue<'gcc>>>, _inputs: Vec<RValue<'gcc>>, span: Span) -> bool {\n+        self.sess().struct_span_err(span, \"GCC backend does not support `llvm_asm!`\")\n+            .help(\"consider using the `asm!` macro instead\")\n+            .emit();\n+\n+        // We return `true` even if we've failed to generate the asm\n+        // because we want to suppress the \"malformed inline assembly\" error\n+        // generated by the frontend.\n+        true\n     }\n \n-    fn codegen_inline_asm(&mut self, template: &[InlineAsmTemplatePiece], operands: &[InlineAsmOperandRef<'tcx, Self>], options: InlineAsmOptions, _span: &[Span]) {\n+    fn codegen_inline_asm(&mut self, template: &[InlineAsmTemplatePiece], rust_operands: &[InlineAsmOperandRef<'tcx, Self>], options: InlineAsmOptions, _span: &[Span]) {\n         let asm_arch = self.tcx.sess.asm_arch.unwrap();\n+        let is_x86 = matches!(asm_arch, InlineAsmArch::X86 | InlineAsmArch::X86_64);\n+        let att_dialect = is_x86 && options.contains(InlineAsmOptions::ATT_SYNTAX);\n+        let intel_dialect = is_x86 && !options.contains(InlineAsmOptions::ATT_SYNTAX);\n \n-        let intel_dialect =\n-            match asm_arch {\n-                InlineAsmArch::X86 | InlineAsmArch::X86_64 if !options.contains(InlineAsmOptions::ATT_SYNTAX) => true,\n-                _ => false,\n-            };\n+        // GCC index of an output operand equals its position in the array \n+        let mut outputs = vec![];\n+\n+        // GCC index of an input operand equals its position in the array\n+        // added to `outputs.len()`\n+        let mut inputs = vec![];\n+\n+        // Clobbers collected from `out(\"explicit register\") _` and `inout(\"expl_reg\") var => _`\n+        let mut clobbers = vec![];\n+\n+        // We're trying to preallocate space for the template\n+        let mut constants_len = 0;\n \n-        // Collect the types of output operands\n-        // FIXME(antoyo): we do this here instead of later because of a bug in libgccjit where creating the\n-        // variable after the extended asm expression causes a segfault:\n-        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100380\n-        let mut output_vars = FxHashMap::default();\n-        let mut operand_numbers = FxHashMap::default();\n-        let mut current_number = 0;\n-        for (idx, op) in operands.iter().enumerate() {\n+        // There are rules we must adhere to if we want GCC to do the right thing:\n+        // \n+        // * Every local variable that the asm block uses as an output must be declared *before*\n+        //   the asm block. \n+        // * There must be no instructions whatsoever between the register variables and the asm.\n+        //\n+        // Therefore, the backend must generate the instructions strictly in this order:\n+        //\n+        // 1. Output variables.\n+        // 2. Register variables.\n+        // 3. The asm block.\n+        //\n+        // We also must make sure that no input operands are emitted before output operands.\n+        //\n+        // This is why we work in passes, first emitting local vars, then local register vars.\n+        // Also, we don't emit any asm operands immediately; we save them to \n+        // the one of the buffers to be emitted later.\n+\n+        // 1. Normal variables (and saving operands to buffers).\n+        for (rust_idx, op) in rust_operands.iter().enumerate() {\n             match *op {\n-                InlineAsmOperandRef::Out { place, .. } => {\n-                    let ty =\n-                        match place {\n-                            Some(place) => place.layout.gcc_type(self.cx, false),\n-                            None => {\n-                                // If the output is discarded, we don't really care what\n-                                // type is used. We're just using this to tell GCC to\n-                                // reserve the register.\n-                                //dummy_output_type(self.cx, reg.reg_class())\n-\n-                                // NOTE: if no output value, we should not create one (it will be a\n-                                // clobber).\n-                                continue;\n-                            },\n-                        };\n-                    let var = self.current_func().new_local(None, ty, \"output_register\");\n-                    operand_numbers.insert(idx, current_number);\n-                    current_number += 1;\n-                    output_vars.insert(idx, var);\n+                InlineAsmOperandRef::Out { reg, late, place } => {\n+                    use ConstraintOrRegister::*;\n+\n+                    let (constraint, ty) = match (reg_to_gcc(reg), place) {\n+                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx, false)),\n+                        // When `reg` is a class and not an explicit register but the out place is not specified,\n+                        // we need to create an unused output variable to assign the output to. This var\n+                        // needs to be of a type that's \"compatible\" with the register class, but specific type \n+                        // doesn't matter.\n+                        (Constraint(constraint), None) => (constraint, dummy_output_type(self.cx, reg.reg_class())),\n+                        (Register(_), Some(_)) => {\n+                            // left for the next pass\n+                            continue\n+                        },\n+                        (Register(reg_name), None) => {\n+                            clobbers.push(reg_name);\n+                            continue\n+                        }\n+                    };\n+\n+                    let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n+                    outputs.push(AsmOutOperand {\n+                        constraint, \n+                        rust_idx,\n+                        late,\n+                        readwrite: false,\n+                        tmp_var,\n+                        out_place: place\n+                    });\n                 }\n-                InlineAsmOperandRef::InOut { out_place, .. } => {\n-                    let ty =\n-                        match out_place {\n-                            Some(place) => place.layout.gcc_type(self.cx, false),\n-                            None => {\n-                                // NOTE: if no output value, we should not create one.\n-                                continue;\n-                            },\n-                        };\n-                    operand_numbers.insert(idx, current_number);\n-                    current_number += 1;\n-                    let var = self.current_func().new_local(None, ty, \"output_register\");\n-                    output_vars.insert(idx, var);\n+\n+                InlineAsmOperandRef::In { reg, value } => {\n+                    if let ConstraintOrRegister::Constraint(constraint) = reg_to_gcc(reg) {\n+                        inputs.push(AsmInOperand { \n+                            constraint: Cow::Borrowed(constraint), \n+                            rust_idx, \n+                            val: value.immediate()\n+                        });\n+                    } \n+                    else {\n+                        // left for the next pass\n+                        continue\n+                    }\n+                }\n+\n+                InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n+                    let constraint = if let ConstraintOrRegister::Constraint(constraint) = reg_to_gcc(reg) {\n+                        constraint\n+                    } \n+                    else {\n+                        // left for the next pass\n+                        continue\n+                    };\n+\n+                    // Rustc frontend guarantees that input and output types are \"compatible\",\n+                    // so we can just use input var's type for the output variable.\n+                    //\n+                    // This decision is also backed by the fact that LLVM needs in and out \n+                    // values to be of *exactly the same type*, not just \"compatible\". \n+                    // I'm not sure if GCC is so picky too, but better safe than sorry.\n+                    let ty = in_value.layout.gcc_type(self.cx, false);\n+                    let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n+\n+                    // If the out_place is None (i.e `inout(reg) _` syntax was used), we translate\n+                    // it to one \"readwrite (+) output variable\", otherwise we translate it to two \n+                    // \"out and tied in\" vars as described above.\n+                    let readwrite = out_place.is_none();\n+                    outputs.push(AsmOutOperand {\n+                        constraint, \n+                        rust_idx,\n+                        late,\n+                        readwrite,\n+                        tmp_var, \n+                        out_place,\n+                    });\n+\n+                    if !readwrite {\n+                        let out_gcc_idx = outputs.len() - 1;\n+                        let constraint = Cow::Owned(out_gcc_idx.to_string());\n+\n+                        inputs.push(AsmInOperand {\n+                            constraint, \n+                            rust_idx, \n+                            val: in_value.immediate()\n+                        });\n+                    }\n+                }\n+\n+                InlineAsmOperandRef::Const { ref string } => {\n+                    constants_len += string.len() + att_dialect as usize;\n+                }\n+\n+                InlineAsmOperandRef::SymFn { instance } => {\n+                    constants_len += self.tcx.symbol_name(instance).name.len();\n+                }\n+                InlineAsmOperandRef::SymStatic { def_id } => {\n+                    constants_len += self.tcx.symbol_name(Instance::mono(self.tcx, def_id)).name.len();\n                 }\n-                _ => {}\n             }\n         }\n \n-        // All output operands must come before the input operands, hence the 2 loops.\n-        for (idx, op) in operands.iter().enumerate() {\n+        // 2. Register variables.\n+        for (rust_idx, op) in rust_operands.iter().enumerate() {\n             match *op {\n-                InlineAsmOperandRef::In { .. } | InlineAsmOperandRef::InOut { .. } => {\n-                    operand_numbers.insert(idx, current_number);\n-                    current_number += 1;\n-                },\n-                _ => (),\n+                // `out(\"explicit register\") var`\n+                InlineAsmOperandRef::Out { reg, late, place } => {\n+                    if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n+                        let out_place = if let Some(place) = place {\n+                            place\n+                        } \n+                        else {\n+                            // processed in the previous pass\n+                            continue\n+                        };\n+\n+                        let ty = out_place.layout.gcc_type(self.cx, false);\n+                        let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n+                        tmp_var.set_register_name(reg_name);\n+\n+                        outputs.push(AsmOutOperand {\n+                            constraint: \"r\".into(), \n+                            rust_idx,\n+                            late,\n+                            readwrite: false,\n+                            tmp_var,\n+                            out_place: Some(out_place)\n+                        });\n+                    }\n+\n+                    // processed in the previous pass\n+                }\n+\n+                // `in(\"explicit register\") var`\n+                InlineAsmOperandRef::In { reg, value } => {\n+                    if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n+                        let ty = value.layout.gcc_type(self.cx, false);\n+                        let reg_var = self.current_func().new_local(None, ty, \"input_register\");\n+                        reg_var.set_register_name(reg_name);\n+                        self.llbb().add_assignment(None, reg_var, value.immediate());\n+\n+                        inputs.push(AsmInOperand { \n+                            constraint: \"r\".into(), \n+                            rust_idx, \n+                            val: reg_var.to_rvalue()\n+                        });\n+                    }\n+\n+                    // processed in the previous pass\n+                }\n+\n+                // `inout(\"explicit register\") in_var => out_var`\n+                InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n+                    if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n+                        let out_place = if let Some(place) = out_place {\n+                            place\n+                        } \n+                        else {\n+                            // processed in the previous pass\n+                            continue\n+                        };\n+\n+                        // See explanation in the first pass.\n+                        let ty = in_value.layout.gcc_type(self.cx, false);\n+                        let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n+                        tmp_var.set_register_name(reg_name);\n+\n+                        outputs.push(AsmOutOperand {\n+                            constraint: \"r\".into(), \n+                            rust_idx,\n+                            late,\n+                            readwrite: false,\n+                            tmp_var,\n+                            out_place: Some(out_place)\n+                        });\n+\n+                        let constraint = Cow::Owned((outputs.len() - 1).to_string());\n+                        inputs.push(AsmInOperand { \n+                            constraint, \n+                            rust_idx,\n+                            val: in_value.immediate()\n+                        });\n+                    }\n+\n+                    // processed in the previous pass\n+                }\n+\n+                InlineAsmOperandRef::Const { .. } \n+                | InlineAsmOperandRef::SymFn { .. } \n+                | InlineAsmOperandRef::SymStatic { .. } => {\n+                    // processed in the previous pass\n+                }\n             }\n         }\n \n-        // Build the template string\n-        let mut template_str = String::new();\n+        // 3. Build the template string\n+\n+        let mut template_str = String::with_capacity(estimate_template_length(template, constants_len, att_dialect));\n+        if !intel_dialect {\n+            template_str.push_str(ATT_SYNTAX_INS);\n+        }\n+\n         for piece in template {\n             match *piece {\n                 InlineAsmTemplatePiece::String(ref string) => {\n-                    if string.contains('%') {\n-                        for c in string.chars() {\n-                            if c == '%' {\n-                                template_str.push_str(\"%%\");\n-                            }\n-                            else {\n-                                template_str.push(c);\n-                            }\n-                        }\n+                    // TODO(@Commeownist): switch to `Iterator::intersperse` once it's stable\n+                    let mut iter = string.split('%');\n+                    if let Some(s) = iter.next() {\n+                        template_str.push_str(s);\n                     }\n-                    else {\n-                        template_str.push_str(string)\n+\n+                    for s in iter {\n+                        template_str.push_str(\"%%\");\n+                        template_str.push_str(s);\n                     }\n                 }\n                 InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n-                    match operands[operand_idx] {\n-                        InlineAsmOperandRef::Out { reg, place: Some(_), ..  } => {\n+                    let mut push_to_template = |modifier, gcc_idx| {\n+                        use std::fmt::Write;\n+\n+                        template_str.push('%');\n+                        if let Some(modifier) = modifier {\n+                            template_str.push(modifier);\n+                        }\n+                        write!(template_str, \"{}\", gcc_idx).expect(\"pushing to string failed\");\n+                    };\n+\n+                    match rust_operands[operand_idx] {\n+                        InlineAsmOperandRef::Out { reg, ..  } => {\n                             let modifier = modifier_to_gcc(asm_arch, reg.reg_class(), modifier);\n-                            if let Some(modifier) = modifier {\n-                                template_str.push_str(&format!(\"%{}{}\", modifier, operand_numbers[&operand_idx]));\n-                            } else {\n-                                template_str.push_str(&format!(\"%{}\", operand_numbers[&operand_idx]));\n-                            }\n-                        },\n-                        InlineAsmOperandRef::Out { place: None, .. } => {\n-                            unimplemented!(\"Out None\");\n-                        },\n-                        InlineAsmOperandRef::In { reg, .. }\n-                        | InlineAsmOperandRef::InOut { reg, .. } => {\n+                            let gcc_index = outputs.iter()\n+                                .position(|op| operand_idx == op.rust_idx)\n+                                .expect(\"wrong rust index\");\n+                            push_to_template(modifier, gcc_index);\n+                        }\n+\n+                        InlineAsmOperandRef::In { reg, .. } => {\n                             let modifier = modifier_to_gcc(asm_arch, reg.reg_class(), modifier);\n-                            if let Some(modifier) = modifier {\n-                                template_str.push_str(&format!(\"%{}{}\", modifier, operand_numbers[&operand_idx]));\n-                            } else {\n-                                template_str.push_str(&format!(\"%{}\", operand_numbers[&operand_idx]));\n-                            }\n+                            let in_gcc_index = inputs.iter()\n+                                .position(|op| operand_idx == op.rust_idx)\n+                                .expect(\"wrong rust index\");\n+                            let gcc_index = in_gcc_index + outputs.len();\n+                            push_to_template(modifier, gcc_index);\n                         }\n+\n+                        InlineAsmOperandRef::InOut { reg, .. } => {\n+                            let modifier = modifier_to_gcc(asm_arch, reg.reg_class(), modifier);\n+\n+                            // The input register is tied to the output, so we can just use the index of the output register\n+                            let gcc_index = outputs.iter()\n+                                .position(|op| operand_idx == op.rust_idx)\n+                                .expect(\"wrong rust index\");\n+                            push_to_template(modifier, gcc_index);\n+                        }\n+\n+                        InlineAsmOperandRef::SymFn { instance } => {\n+                            let name = self.tcx.symbol_name(instance).name;\n+                            template_str.push_str(name);\n+                        }\n+\n+                        InlineAsmOperandRef::SymStatic { def_id } => {\n+                            // TODO(@Commeownist): This may not be sufficient for all kinds of statics.\n+                            // Some statics may need the `@plt` suffix, like thread-local vars.\n+                            let instance = Instance::mono(self.tcx, def_id);\n+                            let name = self.tcx.symbol_name(instance).name;\n+                            template_str.push_str(name);\n+                        }\n+\n                         InlineAsmOperandRef::Const { ref string } => {\n                             // Const operands get injected directly into the template\n+                            if att_dialect {\n+                                template_str.push('$');\n+                            }\n                             template_str.push_str(string);\n                         }\n-                        InlineAsmOperandRef::SymFn { .. }\n-                        | InlineAsmOperandRef::SymStatic { .. } => {\n-                            unimplemented!();\n-                            // Only emit the raw symbol name\n-                            //template_str.push_str(&format!(\"${{{}:c}}\", op_idx[&operand_idx]));\n-                        }\n                     }\n                 }\n             }\n         }\n \n+        if !intel_dialect {\n+            template_str.push_str(INTEL_SYNTAX_INS);\n+        }\n+        \n+        // 4. Generate Extended Asm block\n+\n         let block = self.llbb();\n-        let template_str =\n-            if intel_dialect {\n-                template_str\n-            }\n-            else {\n-                // FIXME(antoyo): this might break the \"m\" memory constraint:\n-                // https://stackoverflow.com/a/9347957/389119\n-                // TODO(antoyo): only set on x86 platforms.\n-                format!(\".att_syntax noprefix\\n\\t{}\\n\\t.intel_syntax noprefix\", template_str)\n-            };\n         let extended_asm = block.add_extended_asm(None, &template_str);\n \n-        // Collect the types of output operands\n-        let mut output_types = vec![];\n-        for (idx, op) in operands.iter().enumerate() {\n-            match *op {\n-                InlineAsmOperandRef::Out { reg, late, place } => {\n-                    let ty =\n-                        match place {\n-                            Some(place) => place.layout.gcc_type(self.cx, false),\n-                            None => {\n-                                // If the output is discarded, we don't really care what\n-                                // type is used. We're just using this to tell GCC to\n-                                // reserve the register.\n-                                dummy_output_type(self.cx, reg.reg_class())\n-                            },\n-                        };\n-                    output_types.push(ty);\n-                    let prefix = if late { \"=\" } else { \"=&\" };\n-                    let constraint = format!(\"{}{}\", prefix, reg_to_gcc(reg));\n+        for op in &outputs {\n+            extended_asm.add_output_operand(None, &op.to_constraint(), op.tmp_var);\n+        }\n \n-                    if place.is_some() {\n-                        let var = output_vars[&idx];\n-                        extended_asm.add_output_operand(None, &constraint, var);\n-                    }\n-                    else {\n-                        // NOTE: reg.to_string() returns the register name with quotes around it so\n-                        // remove them.\n-                        extended_asm.add_clobber(reg.to_string().trim_matches('\"'));\n-                    }\n-                }\n-                InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n-                    let ty =\n-                        match out_place {\n-                            Some(out_place) => out_place.layout.gcc_type(self.cx, false),\n-                            None => dummy_output_type(self.cx, reg.reg_class())\n-                        };\n-                    output_types.push(ty);\n-                    // TODO(antoyo): prefix of \"+\" for reading and writing?\n-                    let prefix = if late { \"=\" } else { \"=&\" };\n-                    let constraint = format!(\"{}{}\", prefix, reg_to_gcc(reg));\n-\n-                    if out_place.is_some() {\n-                        let var = output_vars[&idx];\n-                        // TODO(antoyo): also specify an output operand when out_place is none: that would\n-                        // be the clobber but clobbers do not support general constraint like reg;\n-                        // they only support named registers.\n-                        // Not sure how we can do this. And the LLVM backend does not seem to add a\n-                        // clobber.\n-                        extended_asm.add_output_operand(None, &constraint, var);\n-                    }\n+        for op in &inputs {\n+            extended_asm.add_input_operand(None, &op.constraint, op.val);\n+        }\n \n-                    let constraint = reg_to_gcc(reg);\n-                    extended_asm.add_input_operand(None, &constraint, in_value.immediate());\n-                }\n-                InlineAsmOperandRef::In { reg, value } => {\n-                    let constraint = reg_to_gcc(reg);\n-                    extended_asm.add_input_operand(None, &constraint, value.immediate());\n-                }\n-                _ => {}\n+        for clobber in clobbers.iter() {\n+            extended_asm.add_clobber(clobber);\n+        }\n+\n+        if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n+            // TODO(@Commeownist): I'm not 100% sure this one clobber is sufficient \n+            // on all architectures. For instance, what about FP stack?\n+            extended_asm.add_clobber(\"cc\");\n+        }\n+        if !options.contains(InlineAsmOptions::NOMEM) {\n+            extended_asm.add_clobber(\"memory\");\n+        }\n+        if !options.contains(InlineAsmOptions::PURE) {\n+            extended_asm.set_volatile_flag(true);\n+        }\n+        if !options.contains(InlineAsmOptions::NOSTACK) {\n+            // TODO(@Commeownist): figure out how to align stack\n+        }\n+        if options.contains(InlineAsmOptions::NORETURN) {\n+            let builtin_unreachable = self.context.get_builtin_function(\"__builtin_unreachable\");\n+            let builtin_unreachable: RValue<'gcc> = unsafe { std::mem::transmute(builtin_unreachable) };\n+            self.call(self.type_void(), builtin_unreachable, &[], None);\n+        }\n+\n+        // Write results to outputs. \n+        //\n+        // We need to do this because:\n+        //  1. Turning `PlaceRef` into `RValue` is error-prone and has nasty edge cases \n+        //     (especially with current `rustc_backend_ssa` API).\n+        //  2. Not every output operand has an `out_place`, and it's required by `add_output_operand`.\n+        //\n+        // Instead, we generate a temporary output variable for each output operand, and then this loop,\n+        // generates `out_place = tmp_var;` assignments if out_place exists.\n+        for op in &outputs {\n+            if let Some(place) = op.out_place {\n+                OperandValue::Immediate(op.tmp_var.to_rvalue()).store(self, place);                \n             }\n         }\n \n-        // Write results to outputs\n-        for (idx, op) in operands.iter().enumerate() {\n-            if let InlineAsmOperandRef::Out { place: Some(place), .. }\n-            | InlineAsmOperandRef::InOut { out_place: Some(place), .. } = *op\n-            {\n-                OperandValue::Immediate(output_vars[&idx].to_rvalue()).store(self, place);\n+    }\n+}\n+\n+fn estimate_template_length(template: &[InlineAsmTemplatePiece], constants_len: usize, att_dialect: bool) -> usize {\n+    let len: usize = template.iter().map(|piece| {\n+        match *piece {\n+            InlineAsmTemplatePiece::String(ref string) => {\n+                string.len()\n+            }\n+            InlineAsmTemplatePiece::Placeholder { .. } => {\n+                // '%' + 1 char modifier + 1 char index\n+                3\n             }\n         }\n+    })\n+    .sum();\n+\n+    // increase it by 5% to account for possible '%' signs that'll be duplicated\n+    // I pulled the number out of blue, but should be fair enough\n+    // as the upper bound\n+    let mut res = (len as f32 * 1.05) as usize + constants_len;\n+\n+    if att_dialect {\n+        res += INTEL_SYNTAX_INS.len() + ATT_SYNTAX_INS.len();\n     }\n+    res\n }\n \n /// Converts a register class to a GCC constraint code.\n-// TODO(antoyo): return &'static str instead?\n-fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> String {\n-    match reg {\n+fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n+    let constraint = match reg {\n         // For vector registers LLVM wants the register name to match the type size.\n         InlineAsmRegOrRegClass::Reg(reg) => {\n             // TODO(antoyo): add support for vector register.\n-            let constraint =\n-                match reg.name() {\n-                    \"ax\" => \"a\",\n-                    \"bx\" => \"b\",\n-                    \"cx\" => \"c\",\n-                    \"dx\" => \"d\",\n-                    \"si\" => \"S\",\n-                    \"di\" => \"D\",\n-                    // TODO(antoyo): for registers like r11, we have to create a register variable: https://stackoverflow.com/a/31774784/389119\n-                    // TODO(antoyo): in this case though, it's a clobber, so it should work as r11.\n-                    // Recent nightly supports clobber() syntax, so update to it. It does not seem\n-                    // like it's implemented yet.\n-                    name => name, // FIXME(antoyo): probably wrong.\n-                };\n-            constraint.to_string()\n+            match reg.name() {\n+                \"ax\" => \"a\",\n+                \"bx\" => \"b\",\n+                \"cx\" => \"c\",\n+                \"dx\" => \"d\",\n+                \"si\" => \"S\",\n+                \"di\" => \"D\",\n+                // For registers like r11, we have to create a register variable: https://stackoverflow.com/a/31774784/389119\n+                name => return ConstraintOrRegister::Register(name), \n+            }\n         },\n         InlineAsmRegOrRegClass::RegClass(reg) => match reg {\n             InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => unimplemented!(),\n@@ -275,26 +563,34 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> String {\n             InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => unimplemented!(),\n             InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => unimplemented!(),\n             InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => unimplemented!(),\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::cr)\n+            | InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::xer) => {\n+                unreachable!(\"clobber-only\")\n+            },\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => unimplemented!(),\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => unimplemented!(),\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::mmx_reg) => unimplemented!(),\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => unimplemented!(),\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => unimplemented!(),\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => \"Q\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => \"q\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n-            | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => unimplemented!(),\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg) => unimplemented!(),\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => unimplemented!(),\n+            | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => unimplemented!(),\n             InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n+            InlineAsmRegClass::X86(\n+                X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg,\n+            ) => unreachable!(\"clobber-only\"),\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"GCC backend does not support SPIR-V\")\n             }\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => unimplemented!(),\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => unimplemented!(),\n             InlineAsmRegClass::Err => unreachable!(),\n         }\n-        .to_string(),\n-    }\n+    };\n+\n+    ConstraintOrRegister::Constraint(constraint)\n }\n \n /// Type to use for outputs that are discarded. It doesn't really matter what\n@@ -329,6 +625,10 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => cx.type_i32(),\n         InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => cx.type_f64(),\n+        InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::cr)\n+        | InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::xer) => {\n+            unreachable!(\"clobber-only\")\n+        },\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => cx.type_f32(),\n@@ -345,6 +645,8 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         },\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => cx.type_f64(),\n         InlineAsmRegClass::Err => unreachable!(),\n     }\n }\n@@ -379,7 +681,7 @@ impl<'gcc, 'tcx> AsmMethods for CodegenCx<'gcc, 'tcx> {\n                     match operands[operand_idx] {\n                         GlobalAsmOperandRef::Const { ref string } => {\n                             // Const operands get injected directly into the\n-                            // template. Note that we don't need to escape $\n+                            // template. Note that we don't need to escape %\n                             // here unlike normal inline assembly.\n                             template_str.push_str(string);\n                         }\n@@ -431,26 +733,36 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => match modifier {\n-            None if arch == InlineAsmArch::X86_64 => Some('q'),\n-            None => Some('k'),\n+            None => if arch == InlineAsmArch::X86_64 { Some('q') } else { Some('k') },\n             Some('l') => Some('b'),\n             Some('h') => Some('h'),\n             Some('x') => Some('w'),\n             Some('e') => Some('k'),\n             Some('r') => Some('q'),\n             _ => unreachable!(),\n         },\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::mmx_reg) => unimplemented!(),\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => unimplemented!(),\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n-        | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg)\n-        | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => unimplemented!(),\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg) => unimplemented!(),\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => unimplemented!(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => None,\n+        InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::xmm_reg)\n+        | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::ymm_reg)\n+        | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::zmm_reg) => match (reg, modifier) {\n+            (X86InlineAsmRegClass::xmm_reg, None) => Some('x'),\n+            (X86InlineAsmRegClass::ymm_reg, None) => Some('t'),\n+            (X86InlineAsmRegClass::zmm_reg, None) => Some('g'),\n+            (_, Some('x')) => Some('x'),\n+            (_, Some('y')) => Some('t'),\n+            (_, Some('z')) => Some('g'),\n+            _ => unreachable!(),\n+        },\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg) => {\n+            unreachable!(\"clobber-only\")\n+        }\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         },\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => unimplemented!(),\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => unimplemented!(),\n         InlineAsmRegClass::Err => unreachable!(),\n     }\n }"}, {"sha": "5d06d71953c6675408de6caed1b5bd7fe52e4c65", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -1,7 +1,7 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::convert::TryFrom;\n-use std::ops::{Deref, Range};\n+use std::ops::Deref;\n \n use gccjit::FunctionType;\n use gccjit::{\n@@ -31,16 +31,16 @@ use rustc_codegen_ssa::traits::{\n     StaticBuilderMethods,\n };\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n-use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, TyAndLayout};\n+use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_span::Span;\n use rustc_span::def_id::DefId;\n use rustc_target::abi::{\n     self,\n     Align,\n     HasDataLayout,\n-    LayoutOf,\n     Size,\n     TargetDataLayout,\n+    WrappingRange,\n };\n use rustc_target::spec::{HasTargetSpec, Target};\n \n@@ -338,12 +338,12 @@ impl HasDataLayout for Builder<'_, '_, '_> {\n     }\n }\n \n-impl<'tcx> LayoutOf for Builder<'_, '_, 'tcx> {\n-    type Ty = Ty<'tcx>;\n-    type TyAndLayout = TyAndLayout<'tcx>;\n+impl<'tcx> LayoutOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n+    type LayoutOfResult = TyAndLayout<'tcx>;\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n-        self.cx.layout_of(ty)\n+    #[inline]\n+    fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n+        self.cx.handle_layout_err(err, span, ty)\n     }\n }\n \n@@ -818,12 +818,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             let vr = scalar.valid_range.clone();\n             match scalar.value {\n                 abi::Int(..) => {\n-                    let range = scalar.valid_range_exclusive(bx);\n-                    if range.start != range.end {\n-                        bx.range_metadata(load, range);\n+                    if !scalar.is_always_valid(bx) {\n+                        bx.range_metadata(load, scalar.valid_range);\n                     }\n                 }\n-                abi::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n+                abi::Pointer if vr.start < vr.end && !vr.contains(0) => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}\n@@ -894,7 +893,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         next_bx\n     }\n \n-    fn range_metadata(&mut self, _load: RValue<'gcc>, _range: Range<u128>) {\n+    fn range_metadata(&mut self, _load: RValue<'gcc>, _range: WrappingRange) {\n         // TODO(antoyo)\n     }\n \n@@ -1378,7 +1377,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         }\n     }\n \n-    fn to_immediate_scalar(&mut self, val: Self::Value, scalar: &abi::Scalar) -> Self::Value {\n+    fn to_immediate_scalar(&mut self, val: Self::Value, scalar: abi::Scalar) -> Self::Value {\n         if scalar.is_bool() {\n             return self.trunc(val, self.cx().type_i1());\n         }"}, {"sha": "e402e0e91f13359b73edac08a6853f0083555d8b", "filename": "compiler/rustc_codegen_gcc/src/callee.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -19,7 +19,6 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n \n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n-    assert!(!instance.substs.has_param_types_or_consts());\n \n     if let Some(&func) = cx.instances.borrow().get(&instance) {\n         return func;"}, {"sha": "a24fe0df911a6db3344d0d256c8e05d7f3b4cc05", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -12,10 +12,11 @@ use rustc_codegen_ssa::traits::{\n };\n use rustc_middle::bug;\n use rustc_middle::mir::Mutability;\n-use rustc_middle::ty::{layout::TyAndLayout, ScalarInt};\n-use rustc_mir::interpret::{Allocation, GlobalAlloc, Scalar};\n+use rustc_middle::ty::ScalarInt;\n+use rustc_middle::ty::layout::{TyAndLayout, LayoutOf};\n+use rustc_middle::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n use rustc_span::Symbol;\n-use rustc_target::abi::{self, HasDataLayout, LayoutOf, Pointer, Size};\n+use rustc_target::abi::{self, HasDataLayout, Pointer, Size};\n \n use crate::consts::const_alloc_to_gcc;\n use crate::context::CodegenCx;\n@@ -212,7 +213,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         None\n     }\n \n-    fn scalar_to_backend(&self, cv: Scalar, layout: &abi::Scalar, ty: Type<'gcc>) -> RValue<'gcc> {\n+    fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, ty: Type<'gcc>) -> RValue<'gcc> {\n         let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n         match cv {\n             Scalar::Int(ScalarInt::ZST) => {"}, {"sha": "df13fa79f0696dd1e52ccbeec77adfb9971c7e54", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -6,10 +6,11 @@ use rustc_middle::{bug, span_bug};\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n-use rustc_mir::interpret::{self, Allocation, ErrorHandled, Scalar as InterpScalar, read_target_uint};\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_middle::mir::interpret::{self, Allocation, ErrorHandled, Scalar as InterpScalar, read_target_uint};\n use rustc_span::Span;\n use rustc_span::def_id::DefId;\n-use rustc_target::abi::{self, Align, HasDataLayout, LayoutOf, Primitive, Size};\n+use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRange};\n \n use crate::base;\n use crate::context::CodegenCx;\n@@ -182,6 +183,10 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n     fn add_used_global(&self, _global: RValue<'gcc>) {\n         // TODO(antoyo)\n     }\n+\n+    fn add_compiler_used_global(&self, _global: RValue<'gcc>) {\n+        // TODO(antoyo)\n+    }\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -350,7 +355,7 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: &Alloca\n                 interpret::Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n-            &abi::Scalar { value: Primitive::Pointer, valid_range: 0..=!0 },\n+            abi::Scalar { value: Primitive::Pointer, valid_range: WrappingRange { start: 0, end: !0 } },\n             cx.type_i8p(),\n         ));\n         next_offset = offset + pointer_size;"}, {"sha": "ef687dd22c6da2c7fd6462dd45021bf2853a7ffd", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -18,13 +18,13 @@ use rustc_codegen_ssa::traits::{\n };\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_middle::bug;\n+use rustc_middle::span_bug;\n use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n-use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout};\n+use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n use rustc_session::Session;\n-use rustc_span::{Span, Symbol, DUMMY_SP};\n-use rustc_target::abi::{HasDataLayout, LayoutOf, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n+use rustc_span::{Span, Symbol};\n+use rustc_target::abi::{HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n use rustc_target::spec::{HasTargetSpec, Target, TlsModel};\n \n use crate::callee::get_fn;\n@@ -395,6 +395,14 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             None\n         }\n     }\n+\n+    fn compiler_used_statics(&self) -> &RefCell<Vec<RValue<'gcc>>> {\n+        unimplemented!()\n+    }\n+\n+    fn create_compiler_used_variable(&self) {\n+        unimplemented!()\n+    }\n }\n \n impl<'gcc, 'tcx> HasTyCtxt<'tcx> for CodegenCx<'gcc, 'tcx> {\n@@ -415,22 +423,16 @@ impl<'gcc, 'tcx> HasTargetSpec for CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n-impl<'gcc, 'tcx> LayoutOf for CodegenCx<'gcc, 'tcx> {\n-    type Ty = Ty<'tcx>;\n-    type TyAndLayout = TyAndLayout<'tcx>;\n+impl<'gcc, 'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    type LayoutOfResult = TyAndLayout<'tcx>;\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n-        self.spanned_layout_of(ty, DUMMY_SP)\n-    }\n-\n-    fn spanned_layout_of(&self, ty: Ty<'tcx>, span: Span) -> Self::TyAndLayout {\n-        self.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap_or_else(|e| {\n-            if let LayoutError::SizeOverflow(_) = e {\n-                self.sess().span_fatal(span, &e.to_string())\n-            } else {\n-                bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-            }\n-        })\n+    #[inline]\n+    fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n+        if let LayoutError::SizeOverflow(_) = err {\n+            self.sess().span_fatal(span, &err.to_string())\n+        } else {\n+            span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n+        }\n     }\n }\n "}, {"sha": "3dc4f61a7ac3cd819f62cfb7300940e6f384e2b0", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -10,8 +10,9 @@ use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n use rustc_middle::bug;\n use rustc_middle::ty::{self, Instance, Ty};\n+use rustc_middle::ty::layout::LayoutOf;\n use rustc_span::{Span, Symbol, symbol::kw, sym};\n-use rustc_target::abi::{HasDataLayout, LayoutOf};\n+use rustc_target::abi::HasDataLayout;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::spec::PanicStrategy;\n \n@@ -176,7 +177,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                     let result = func.new_local(None, arg.get_type(), \"zeros\");\n                                     let zero = self.cx.context.new_rvalue_zero(arg.get_type());\n                                     let cond = self.cx.context.new_comparison(None, ComparisonOp::Equals, arg, zero);\n-                                    self.block.expect(\"block\").end_with_conditional(None, cond, then_block, else_block);\n+                                    self.llbb().end_with_conditional(None, cond, then_block, else_block);\n \n                                     let zero_result = self.cx.context.new_rvalue_from_long(arg.get_type(), width as i64);\n                                     then_block.add_assignment(None, result, zero_result);\n@@ -307,6 +308,19 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     }\n                 }\n \n+                sym::black_box => {\n+                    args[0].val.store(self, result);\n+\n+                    let block = self.llbb();\n+                    let extended_asm = block.add_extended_asm(None, \"\");\n+                    extended_asm.add_input_operand(None, \"r\", result.llval);\n+                    extended_asm.add_clobber(\"memory\");\n+                    extended_asm.set_volatile_flag(true);\n+                    \n+                    // We have copied the value to `result` already.\n+                    return;\n+                }\n+\n                 _ if name_str.starts_with(\"simd_\") => {\n                     match generic_simd_intrinsic(self, name, callee_ty, args, ret_ty, llret_ty, span) {\n                         Ok(llval) => llval,\n@@ -935,7 +949,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             then_block.add_assignment(None, res, self.context.new_cast(None, shifted + int_max, result_type));\n             then_block.end_with_jump(None, after_block);\n \n-            self.block.expect(\"block\").end_with_conditional(None, overflow, then_block, after_block);\n+            self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n \n             // NOTE: since jumps were added in a place rustc does not\n             // expect, the current blocks in the state need to be updated.\n@@ -985,7 +999,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             then_block.add_assignment(None, res, self.context.new_cast(None, shifted + int_max, result_type));\n             then_block.end_with_jump(None, after_block);\n \n-            self.block.expect(\"block\").end_with_conditional(None, overflow, then_block, after_block);\n+            self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n \n             // NOTE: since jumps were added in a place rustc does not\n             // expect, the current blocks in the state need to be updated."}, {"sha": "793e5c48d0a365abe81b907585621c553b93a6dd", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -18,7 +18,6 @@ extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_metadata;\n extern crate rustc_middle;\n-extern crate rustc_mir;\n extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_symbol_mangling;\n@@ -144,8 +143,8 @@ impl ExtraBackendMethods for GccCodegenBackend {\n         base::write_compressed_metadata(tcx, metadata, gcc_module)\n     }\n \n-    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, mods: &mut Self::Module, kind: AllocatorKind, has_alloc_error_handler: bool) {\n-        unsafe { allocator::codegen(tcx, mods, kind, has_alloc_error_handler) }\n+    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, mods: &mut Self::Module, module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n+        unsafe { allocator::codegen(tcx, mods, module_name, kind, has_alloc_error_handler) }\n     }\n \n     fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (ModuleCodegen<Self::Module>, u64) {"}, {"sha": "cedeb54f60bf2e0ffa307676cc29ab4799d21fbd", "filename": "compiler/rustc_codegen_gcc/src/mono_item.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -2,9 +2,8 @@ use rustc_codegen_ssa::traits::PreDefineMethods;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n-use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_middle::ty::layout::{FnAbiExt, LayoutOf};\n use rustc_span::def_id::DefId;\n-use rustc_target::abi::LayoutOf;\n use rustc_target::abi::call::FnAbi;\n \n use crate::base;\n@@ -31,7 +30,7 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n-        assert!(!instance.substs.needs_infer() && !instance.substs.has_param_types_or_consts());\n+        assert!(!instance.substs.needs_infer());\n \n         let fn_abi = FnAbi::of_instance(self, instance, &[]);\n         self.linkage.set(base::linkage_to_gcc(linkage));"}, {"sha": "2ff2ee7b8522651b28b851a90c15cdb84686ce04", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -4,9 +4,9 @@ use gccjit::{Struct, Type};\n use crate::rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods};\n use rustc_middle::bug;\n use rustc_middle::ty::{self, Ty, TypeFoldable};\n-use rustc_middle::ty::layout::{FnAbiExt, TyAndLayout};\n+use rustc_middle::ty::layout::{FnAbiExt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_target::abi::{self, Abi, F32, F64, FieldsShape, Int, Integer, LayoutOf, Pointer, PointeeInfo, Size, TyAndLayoutMethods, Variants};\n+use rustc_target::abi::{self, Abi, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};\n use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n \n use crate::abi::{FnAbiGccExt, GccType};\n@@ -308,7 +308,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             return pointee;\n         }\n \n-        let result = Ty::pointee_info_at(*self, cx, offset);\n+        let result = Ty::ty_and_layout_pointee_info_at(*self, cx, offset);\n \n         cx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n         result"}, {"sha": "12df1f8af2f0b2be40d274c4e44809fe8365b4fb", "filename": "compiler/rustc_codegen_gcc/test.sh", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftest.sh?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -4,7 +4,12 @@\n \n set -e\n \n-export GCC_PATH=$(cat gcc_path)\n+if [ -f ./gcc_path ]; then \n+    export GCC_PATH=$(cat gcc_path)\n+else\n+    echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n+    exit 1\n+fi\n \n export LD_LIBRARY_PATH=\"$GCC_PATH\"\n export LIBRARY_PATH=\"$GCC_PATH\"\n@@ -141,6 +146,7 @@ rm config.toml || true\n cat > config.toml <<EOF\n [rust]\n codegen-backends = []\n+deny-warnings = false\n \n [build]\n cargo = \"$(which cargo)\"\n@@ -157,7 +163,7 @@ done\n \n git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n \n-rm -r src/test/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,simd*,borrowck/,test*,*lto*.rs} || true\n+rm -r src/test/ui/{abi*,extern/,llvm-asm/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,simd*,borrowck/,test*,*lto*.rs} || true\n for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" src/test/ui); do\n   rm $test\n done"}, {"sha": "9c0055b0b6b5ec36fdbbcfc2d7eda5645a3a7b63", "filename": "compiler/rustc_codegen_gcc/tests/run/asm.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -62,5 +62,92 @@ fn main() {\n     }\n     assert_eq!(x, 43);\n \n+    // check inout(reg_class) x \n+    let mut x: u64 = 42;\n+    unsafe {\n+        asm!(\"add {0}, {0}\",\n+            inout(reg) x \n+        );\n+    }\n+    assert_eq!(x, 84);\n+\n+    // check inout(\"reg\") x\n+    let mut x: u64 = 42;\n+    unsafe {\n+        asm!(\"add r11, r11\",\n+            inout(\"r11\") x \n+        );\n+    }\n+    assert_eq!(x, 84);\n+\n+    // check a mix of\n+    // in(\"reg\")\n+    // inout(class) x => y\n+    // inout (class) x\n+    let x: u64 = 702;\n+    let y: u64 = 100;\n+    let res: u64;\n+    let mut rem: u64 = 0;\n+    unsafe {\n+        asm!(\"div r11\",\n+            in(\"r11\") y,\n+            inout(\"eax\") x => res,\n+            inout(\"edx\") rem,\n+        );\n+    }\n+    assert_eq!(res, 7);\n+    assert_eq!(rem, 2);\n+\n+    // check const \n+    let mut x: u64 = 42;\n+    unsafe {\n+        asm!(\"add {}, {}\",\n+            inout(reg) x,\n+            const 1 \n+        );\n+    }\n+    assert_eq!(x, 43);\n+\n+    // check const (ATT syntax)\n+    let mut x: u64 = 42;\n+    unsafe {\n+        asm!(\"add {}, {}\",\n+            const 1,\n+            inout(reg) x,\n+            options(att_syntax)\n+        );\n+    }\n+    assert_eq!(x, 43);\n+\n+    // check sym fn\n+    extern \"C\" fn foo() -> u64 { 42 }\n+    let x: u64;\n+    unsafe {\n+        asm!(\"call {}\", sym foo, lateout(\"rax\") x);\n+    }\n+    assert_eq!(x, 42);\n+\n+    // check sym fn (ATT syntax)\n+    let x: u64;\n+    unsafe {\n+        asm!(\"call {}\", sym foo, lateout(\"rax\") x, options(att_syntax));\n+    }\n+    assert_eq!(x, 42);\n+\n+    // check sym static\n+    static FOO: u64 = 42;\n+    let x: u64;\n+    unsafe {\n+        asm!(\"mov {1}, qword ptr [rip + {0}]\", sym FOO, lateout(reg) x);\n+    }\n+    assert_eq!(x, 42);\n+\n+    // check sym static (ATT syntax)\n+    let x: u64;\n+    unsafe {\n+        asm!(\"movq {0}(%rip), {1}\", sym FOO, lateout(reg) x, options(att_syntax));\n+    }\n+    assert_eq!(x, 42);\n+\n     assert_eq!(unsafe { add_asm(40, 2) }, 42);\n }"}]}