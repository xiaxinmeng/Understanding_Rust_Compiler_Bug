{"sha": "6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "node_id": "C_kwDOAAsO6NoAKDZmNTNkZGZhNzRhYzNjMTBjZWI2M2FkNGE3YTljOTVlNTU4NTNjODc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-17T12:33:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-17T12:33:12Z"}, "message": "Auto merge of #89514 - davidtwco:polymorphize-shims-and-predicates, r=lcnr\n\npolymorphization: shims and predicates\n\nSupersedes #75737 and #75414. This pull request includes up some changes to polymorphization which hadn't landed previously and gets stage2 bootstrapping and the test suite passing when polymorphization is enabled. There are still issues with `type_id` and polymorphization to investigate but this should get polymorphization in a reasonable state to work on.\n\n- #75737 and #75414 both worked but were blocked on having the rest of the test suite pass (with polymorphization enabled) with and without the PRs. It makes more sense to just land these so that the changes are in.\n- #75737's changes remove the restriction of `InstanceDef::Item` on polymorphization, so that shims can now be polymorphized. This won't have much of an effect until polymorphization's analysis is more advanced, but it doesn't hurt.\n- #75414's changes remove all logic which marks parameters as used based on their presence in predicates - given #75675, this will enable more polymorphization and avoid the symbol clashes that predicate logic previously sidestepped.\n- Polymorphization now explicitly checks (and skips) foreign items, this is necessary for stage2 bootstrapping to work when polymorphization is enabled.\n- The conditional determining the emission of a note adding context to a post-monomorphization error has been modified. Polymorphization results in `optimized_mir` running for shims during collection where that wouldn't happen previously, some errors are emitted during `optimized_mir` and these were considered post-monomorphization errors with the existing logic (more errors and shims have a `DefId` coming from the std crate, not the local crate), adding a note that resulted in tests failing. It isn't particularly feasible to change where polymorphization runs or prevent it from using `optimized_mir`, so it seemed more reasonable to not change the conditional.\n- `characteristic_def_id_of_type` was being invoked during partitioning for self types of impl blocks which had projections that depended on the value of unused generic parameters of a function - this caused a ICE in a debuginfo test. If partitioning is enabled and the instance needs substitution then this is skipped. That test still fails for me locally, but not with an ICE, but it fails in a fresh checkout too, so \ud83e\udd37\u200d\u2642\ufe0f.\n\nr? `@lcnr`", "tree": {"sha": "36083478c7109854fa324093166dd9d0f59fe4cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36083478c7109854fa324093166dd9d0f59fe4cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "html_url": "https://github.com/rust-lang/rust/commit/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d6f24210c4a8f46f9781a56f819a383e590cccf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6f24210c4a8f46f9781a56f819a383e590cccf", "html_url": "https://github.com/rust-lang/rust/commit/1d6f24210c4a8f46f9781a56f819a383e590cccf"}, {"sha": "b39e915981a59fed6fba7bee727e603ddc1be4c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b39e915981a59fed6fba7bee727e603ddc1be4c4", "html_url": "https://github.com/rust-lang/rust/commit/b39e915981a59fed6fba7bee727e603ddc1be4c4"}], "stats": {"total": 290, "additions": 182, "deletions": 108}, "files": [{"sha": "a16388d5de21928f7d9bf4df269c7d9a0b9122a0", "filename": "compiler/rustc_const_eval/src/interpret/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs?ref=6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "patch": "@@ -35,7 +35,8 @@ where\n                 ty::Closure(def_id, substs)\n                 | ty::Generator(def_id, substs, ..)\n                 | ty::FnDef(def_id, substs) => {\n-                    let unused_params = self.tcx.unused_generic_params(def_id);\n+                    let instance = ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id));\n+                    let unused_params = self.tcx.unused_generic_params(instance);\n                     for (index, subst) in substs.into_iter().enumerate() {\n                         let index = index\n                             .try_into()"}, {"sha": "e12f049a90bdf54cee9d9e2cc62470fc7490bc60", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "patch": "@@ -83,6 +83,12 @@ impl IntoArgs for (CrateNum, DefId) {\n     }\n }\n \n+impl IntoArgs for ty::InstanceDef<'tcx> {\n+    fn into_args(self) -> (DefId, DefId) {\n+        (self.def_id(), self.def_id())\n+    }\n+}\n+\n provide! { <'tcx> tcx, def_id, other, cdata,\n     type_of => { cdata.get_type(def_id.index, tcx) }\n     generics_of => { cdata.get_generics(def_id.index, tcx.sess) }"}, {"sha": "20f7b059b56008c77c22a456a188efebdb8c7cf4", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "patch": "@@ -1319,7 +1319,9 @@ impl EncodeContext<'a, 'tcx> {\n             }\n             record!(self.tables.promoted_mir[def_id.to_def_id()] <- self.tcx.promoted_mir(def_id));\n \n-            let unused = self.tcx.unused_generic_params(def_id);\n+            let instance =\n+                ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id.to_def_id()));\n+            let unused = self.tcx.unused_generic_params(instance);\n             if !unused.is_empty() {\n                 record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n             }"}, {"sha": "06b42320049f015267c1cd030242d60407eec94f", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "patch": "@@ -47,6 +47,14 @@ pub enum MonoItem<'tcx> {\n }\n \n impl<'tcx> MonoItem<'tcx> {\n+    /// Returns `true` if the mono item is user-defined (i.e. not compiler-generated, like shims).\n+    pub fn is_user_defined(&self) -> bool {\n+        match *self {\n+            MonoItem::Fn(instance) => matches!(instance.def, InstanceDef::Item(..)),\n+            MonoItem::Static(..) | MonoItem::GlobalAsm(..) => true,\n+        }\n+    }\n+\n     pub fn size_estimate(&self, tcx: TyCtxt<'tcx>) -> usize {\n         match *self {\n             MonoItem::Fn(instance) => {"}, {"sha": "4145cbd42495ce33b8ace3d4a496434ee59b5fd7", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "patch": "@@ -1558,11 +1558,11 @@ rustc_queries! {\n     query codegen_unit(_: Symbol) -> &'tcx CodegenUnit<'tcx> {\n         desc { \"codegen_unit\" }\n     }\n-    query unused_generic_params(key: DefId) -> FiniteBitSet<u32> {\n-        cache_on_disk_if { key.is_local() }\n+    query unused_generic_params(key: ty::InstanceDef<'tcx>) -> FiniteBitSet<u32> {\n+        cache_on_disk_if { key.def_id().is_local() }\n         desc {\n             |tcx| \"determining which generic parameters are unused by `{}`\",\n-                tcx.def_path_str(key)\n+                tcx.def_path_str(key.def_id())\n         }\n     }\n     query backend_optimization_level(_: ()) -> OptLevel {"}, {"sha": "4b38105e44717e52300e5b6f9e789e58f8093d12", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "patch": "@@ -152,6 +152,22 @@ impl<'tcx> InstanceDef<'tcx> {\n         }\n     }\n \n+    /// Returns the `DefId` of instances which might not require codegen locally.\n+    pub fn def_id_if_not_guaranteed_local_codegen(self) -> Option<DefId> {\n+        match self {\n+            ty::InstanceDef::Item(def) => Some(def.did),\n+            ty::InstanceDef::DropGlue(def_id, Some(_)) => Some(def_id),\n+            InstanceDef::VtableShim(..)\n+            | InstanceDef::ReifyShim(..)\n+            | InstanceDef::FnPtrShim(..)\n+            | InstanceDef::Virtual(..)\n+            | InstanceDef::Intrinsic(..)\n+            | InstanceDef::ClosureOnceShim { .. }\n+            | InstanceDef::DropGlue(..)\n+            | InstanceDef::CloneShim(..) => None,\n+        }\n+    }\n+\n     #[inline]\n     pub fn with_opt_param(self) -> ty::WithOptConstParam<DefId> {\n         match self {\n@@ -567,29 +583,26 @@ impl<'tcx> Instance<'tcx> {\n             return self;\n         }\n \n-        if let InstanceDef::Item(def) = self.def {\n-            let polymorphized_substs = polymorphize(tcx, def.did, self.substs);\n-            debug!(\"polymorphize: self={:?} polymorphized_substs={:?}\", self, polymorphized_substs);\n-            Self { def: self.def, substs: polymorphized_substs }\n-        } else {\n-            self\n-        }\n+        let polymorphized_substs = polymorphize(tcx, self.def, self.substs);\n+        debug!(\"polymorphize: self={:?} polymorphized_substs={:?}\", self, polymorphized_substs);\n+        Self { def: self.def, substs: polymorphized_substs }\n     }\n }\n \n fn polymorphize<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    instance: ty::InstanceDef<'tcx>,\n     substs: SubstsRef<'tcx>,\n ) -> SubstsRef<'tcx> {\n-    debug!(\"polymorphize({:?}, {:?})\", def_id, substs);\n-    let unused = tcx.unused_generic_params(def_id);\n+    debug!(\"polymorphize({:?}, {:?})\", instance, substs);\n+    let unused = tcx.unused_generic_params(instance);\n     debug!(\"polymorphize: unused={:?}\", unused);\n \n     // If this is a closure or generator then we need to handle the case where another closure\n     // from the function is captured as an upvar and hasn't been polymorphized. In this case,\n     // the unpolymorphized upvar closure would result in a polymorphized closure producing\n     // multiple mono items (and eventually symbol clashes).\n+    let def_id = instance.def_id();\n     let upvars_ty = if tcx.is_closure(def_id) {\n         Some(substs.as_closure().tupled_upvars_ty())\n     } else if tcx.type_of(def_id).is_generator() {\n@@ -613,15 +626,23 @@ fn polymorphize<'tcx>(\n             debug!(\"fold_ty: ty={:?}\", ty);\n             match ty.kind {\n                 ty::Closure(def_id, substs) => {\n-                    let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n+                    let polymorphized_substs = polymorphize(\n+                        self.tcx,\n+                        ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n+                        substs,\n+                    );\n                     if substs == polymorphized_substs {\n                         ty\n                     } else {\n                         self.tcx.mk_closure(def_id, polymorphized_substs)\n                     }\n                 }\n                 ty::Generator(def_id, substs, movability) => {\n-                    let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n+                    let polymorphized_substs = polymorphize(\n+                        self.tcx,\n+                        ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n+                        substs,\n+                    );\n                     if substs == polymorphized_substs {\n                         ty\n                     } else {"}, {"sha": "5147408210ef538ef24b1166b3c759b3dc5edb93", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "patch": "@@ -450,7 +450,9 @@ fn collect_items_rec<'tcx>(\n     // involving a dependency, and the lack of context is confusing) in this MVP, we focus on\n     // diagnostics on edges crossing a crate boundary: the collected mono items which are not\n     // defined in the local crate.\n-    if tcx.sess.diagnostic().err_count() > error_count && starting_point.node.krate() != LOCAL_CRATE\n+    if tcx.sess.diagnostic().err_count() > error_count\n+        && starting_point.node.krate() != LOCAL_CRATE\n+        && starting_point.node.is_user_defined()\n     {\n         let formatted_item = with_no_trimmed_paths(|| starting_point.node.to_string());\n         tcx.sess.span_note_without_error(\n@@ -934,21 +936,13 @@ fn visit_instance_use<'tcx>(\n     }\n }\n \n-// Returns `true` if we should codegen an instance in the local crate.\n-// Returns `false` if we can just link to the upstream crate and therefore don't\n-// need a mono item.\n+/// Returns `true` if we should codegen an instance in the local crate, or returns `false` if we\n+/// can just link to the upstream crate and therefore don't need a mono item.\n fn should_codegen_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx>) -> bool {\n-    let def_id = match instance.def {\n-        ty::InstanceDef::Item(def) => def.did,\n-        ty::InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n-        ty::InstanceDef::VtableShim(..)\n-        | ty::InstanceDef::ReifyShim(..)\n-        | ty::InstanceDef::ClosureOnceShim { .. }\n-        | ty::InstanceDef::Virtual(..)\n-        | ty::InstanceDef::FnPtrShim(..)\n-        | ty::InstanceDef::DropGlue(..)\n-        | ty::InstanceDef::Intrinsic(_)\n-        | ty::InstanceDef::CloneShim(..) => return true,\n+    let def_id = if let Some(def_id) = instance.def.def_id_if_not_guaranteed_local_codegen() {\n+        def_id\n+    } else {\n+        return true;\n     };\n \n     if tcx.is_foreign_item(def_id) {"}, {"sha": "be6820822586d82dc04be49b08c09ce80edbc7ea", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, Linkage, Visibility};\n use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n use rustc_middle::ty::print::characteristic_def_id_of_type;\n-use rustc_middle::ty::{self, DefIdTree, InstanceDef, TyCtxt};\n+use rustc_middle::ty::{self, fold::TypeFoldable, DefIdTree, InstanceDef, TyCtxt};\n use rustc_span::symbol::Symbol;\n \n use super::PartitioningCx;\n@@ -300,14 +300,21 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n                     // call it.\n                     return None;\n                 }\n-                // This is a method within an impl, find out what the self-type is:\n-                let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n-                    instance.substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    tcx.type_of(impl_def_id),\n-                );\n-                if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n-                    return Some(def_id);\n+\n+                // When polymorphization is enabled, methods which do not depend on their generic\n+                // parameters, but the self-type of their impl block do will fail to normalize.\n+                if !tcx.sess.opts.debugging_opts.polymorphize\n+                    || !instance.definitely_needs_subst(tcx)\n+                {\n+                    // This is a method within an impl, find out what the self-type is:\n+                    let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n+                        instance.substs,\n+                        ty::ParamEnv::reveal_all(),\n+                        tcx.type_of(impl_def_id),\n+                    );\n+                    if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n+                        return Some(def_id);\n+                    }\n                 }\n             }\n "}, {"sha": "e6e4438b6d41afa63bb448bbc1db8b81cfd51e17", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 59, "deletions": 66, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "patch": "@@ -27,20 +27,23 @@ pub fn provide(providers: &mut Providers) {\n     providers.unused_generic_params = unused_generic_params;\n }\n \n-/// Determine which generic parameters are used by the function/method/closure represented by\n-/// `def_id`. Returns a bitset where bits representing unused parameters are set (`is_empty`\n-/// indicates all parameters are used).\n+/// Determine which generic parameters are used by the instance.\n+///\n+/// Returns a bitset where bits representing unused parameters are set (`is_empty` indicates all\n+/// parameters are used).\n #[instrument(level = \"debug\", skip(tcx))]\n-fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u32> {\n+fn unused_generic_params<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance: ty::InstanceDef<'tcx>,\n+) -> FiniteBitSet<u32> {\n     if !tcx.sess.opts.debugging_opts.polymorphize {\n         // If polymorphization disabled, then all parameters are used.\n         return FiniteBitSet::new_empty();\n     }\n \n-    // Polymorphization results are stored in cross-crate metadata only when there are unused\n-    // parameters, so assume that non-local items must have only used parameters (else this query\n-    // would not be invoked, and the cross-crate metadata used instead).\n-    if !def_id.is_local() {\n+    let def_id = instance.def_id();\n+    // Exit early if this instance should not be polymorphized.\n+    if !should_polymorphize(tcx, def_id, instance) {\n         return FiniteBitSet::new_empty();\n     }\n \n@@ -52,41 +55,25 @@ fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u32> {\n         return FiniteBitSet::new_empty();\n     }\n \n-    // Exit early when there is no MIR available.\n-    let context = tcx.hir().body_const_context(def_id.expect_local());\n-    match context {\n-        Some(ConstContext::ConstFn) | None if !tcx.is_mir_available(def_id) => {\n-            debug!(\"no mir available\");\n-            return FiniteBitSet::new_empty();\n-        }\n-        Some(_) if !tcx.is_ctfe_mir_available(def_id) => {\n-            debug!(\"no ctfe mir available\");\n-            return FiniteBitSet::new_empty();\n-        }\n-        _ => {}\n-    }\n-\n     // Create a bitset with N rightmost ones for each parameter.\n     let generics_count: u32 =\n         generics.count().try_into().expect(\"more generic parameters than can fit into a `u32`\");\n     let mut unused_parameters = FiniteBitSet::<u32>::new_empty();\n     unused_parameters.set_range(0..generics_count);\n     debug!(?unused_parameters, \"(start)\");\n+\n     mark_used_by_default_parameters(tcx, def_id, generics, &mut unused_parameters);\n     debug!(?unused_parameters, \"(after default)\");\n \n     // Visit MIR and accumululate used generic parameters.\n-    let body = match context {\n+    let body = match tcx.hir().body_const_context(def_id.expect_local()) {\n         // Const functions are actually called and should thus be considered for polymorphization\n-        // via their runtime MIR\n+        // via their runtime MIR.\n         Some(ConstContext::ConstFn) | None => tcx.optimized_mir(def_id),\n         Some(_) => tcx.mir_for_ctfe(def_id),\n     };\n     let mut vis = MarkUsedGenericParams { tcx, def_id, unused_parameters: &mut unused_parameters };\n     vis.visit_body(body);\n-    debug!(?unused_parameters, \"(after visitor)\");\n-\n-    mark_used_by_predicates(tcx, def_id, &mut unused_parameters);\n     debug!(?unused_parameters, \"(end)\");\n \n     // Emit errors for debugging and testing if enabled.\n@@ -97,6 +84,49 @@ fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u32> {\n     unused_parameters\n }\n \n+/// Returns `true` if the instance should be polymorphized.\n+fn should_polymorphize<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    instance: ty::InstanceDef<'tcx>,\n+) -> bool {\n+    // If an instance's MIR body is not polymorphic then the modified substitutions that are\n+    // derived from polymorphization's result won't make any difference.\n+    if !instance.has_polymorphic_mir_body() {\n+        return false;\n+    }\n+\n+    // Don't polymorphize intrinsics or virtual calls - calling `instance_mir` will panic.\n+    if matches!(instance, ty::InstanceDef::Intrinsic(..) | ty::InstanceDef::Virtual(..)) {\n+        return false;\n+    }\n+\n+    // Polymorphization results are stored in cross-crate metadata only when there are unused\n+    // parameters, so assume that non-local items must have only used parameters (else this query\n+    // would not be invoked, and the cross-crate metadata used instead).\n+    if !def_id.is_local() {\n+        return false;\n+    }\n+\n+    // Foreign items have no bodies to analyze.\n+    if tcx.is_foreign_item(def_id) {\n+        return false;\n+    }\n+\n+    // Make sure there is MIR available.\n+    match tcx.hir().body_const_context(def_id.expect_local()) {\n+        Some(ConstContext::ConstFn) | None if !tcx.is_mir_available(def_id) => {\n+            debug!(\"no mir available\");\n+            return false;\n+        }\n+        Some(_) if !tcx.is_ctfe_mir_available(def_id) => {\n+            debug!(\"no ctfe mir available\");\n+            return false;\n+        }\n+        _ => true,\n+    }\n+}\n+\n /// Some parameters are considered used-by-default, such as non-generic parameters and the dummy\n /// generic parameters from closures, this function marks them as used. `leaf_is_closure` should\n /// be `true` if the item that `unused_generic_params` was invoked on is a closure.\n@@ -156,44 +186,6 @@ fn mark_used_by_default_parameters<'tcx>(\n     }\n }\n \n-/// Search the predicates on used generic parameters for any unused generic parameters, and mark\n-/// those as used.\n-#[instrument(level = \"debug\", skip(tcx, def_id))]\n-fn mark_used_by_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    unused_parameters: &mut FiniteBitSet<u32>,\n-) {\n-    let def_id = tcx.closure_base_def_id(def_id);\n-    let predicates = tcx.explicit_predicates_of(def_id);\n-\n-    let mut current_unused_parameters = FiniteBitSet::new_empty();\n-    // Run to a fixed point to support `where T: Trait<U>, U: Trait<V>`, starting with an empty\n-    // bit set so that this is skipped if all parameters are already used.\n-    while current_unused_parameters != *unused_parameters {\n-        debug!(?current_unused_parameters, ?unused_parameters);\n-        current_unused_parameters = *unused_parameters;\n-\n-        for (predicate, _) in predicates.predicates {\n-            // Consider all generic params in a predicate as used if any other parameter in the\n-            // predicate is used.\n-            let any_param_used = {\n-                let mut vis = HasUsedGenericParams { tcx, unused_parameters };\n-                predicate.visit_with(&mut vis).is_break()\n-            };\n-\n-            if any_param_used {\n-                let mut vis = MarkUsedGenericParams { tcx, def_id, unused_parameters };\n-                predicate.visit_with(&mut vis);\n-            }\n-        }\n-    }\n-\n-    if let Some(parent) = predicates.parent {\n-        mark_used_by_predicates(tcx, parent, unused_parameters);\n-    }\n-}\n-\n /// Emit errors for the function annotated by `#[rustc_polymorphize_error]`, labelling each generic\n /// parameter which was unused.\n #[instrument(level = \"debug\", skip(tcx, generics))]\n@@ -243,7 +235,8 @@ impl<'a, 'tcx> MarkUsedGenericParams<'a, 'tcx> {\n     /// a closure, generator or constant).\n     #[instrument(level = \"debug\", skip(self, def_id, substs))]\n     fn visit_child_body(&mut self, def_id: DefId, substs: SubstsRef<'tcx>) {\n-        let unused = self.tcx.unused_generic_params(def_id);\n+        let instance = ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id));\n+        let unused = self.tcx.unused_generic_params(instance);\n         debug!(?self.unused_parameters, ?unused);\n         for (i, arg) in substs.iter().enumerate() {\n             let i = i.try_into().unwrap();"}, {"sha": "dea1e21e77fe359e30662c39c9291d4ed53cc4e0", "filename": "src/test/ui/polymorphization/predicates.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/src%2Ftest%2Fui%2Fpolymorphization%2Fpredicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/src%2Ftest%2Fui%2Fpolymorphization%2Fpredicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fpredicates.rs?ref=6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "patch": "@@ -12,6 +12,7 @@ fn bar<I>() {\n \n #[rustc_polymorphize_error]\n fn foo<I, T>(_: I)\n+//~^ ERROR item has unused generic parameters\n where\n     I: Iterator<Item = T>,\n {\n@@ -20,6 +21,7 @@ where\n \n #[rustc_polymorphize_error]\n fn baz<I, T>(_: I)\n+//~^ ERROR item has unused generic parameters\n where\n     std::iter::Repeat<I>: Iterator<Item = T>,\n {\n@@ -40,6 +42,7 @@ where\n     #[rustc_polymorphize_error]\n     fn next(&mut self) -> Option<Self::Item> {\n         self.find(|_| true)\n+        //~^ ERROR item has unused generic parameters\n     }\n }\n \n@@ -53,6 +56,7 @@ impl Baz<u32> for u16 {}\n \n #[rustc_polymorphize_error]\n fn quux<A, B, C: Default>() -> usize\n+//~^ ERROR item has unused generic parameters\n where\n     A: Baz<B>,\n     B: Baz<C>,\n@@ -69,6 +73,7 @@ impl Foobar<u32, u32> for () {}\n \n #[rustc_polymorphize_error]\n fn foobar<F, G>() -> usize\n+//~^ ERROR item has unused generic parameters\n where\n     (): Foobar<F, G>,\n {"}, {"sha": "5fc51e58d728a3ec3d5a191ef65abd0a4c956bb1", "filename": "src/test/ui/polymorphization/predicates.stderr", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/src%2Ftest%2Fui%2Fpolymorphization%2Fpredicates.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87/src%2Ftest%2Fui%2Fpolymorphization%2Fpredicates.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fpredicates.stderr?ref=6f53ddfa74ac3c10ceb63ad4a7a9c95e55853c87", "patch": "@@ -1,8 +1,45 @@\n+error: item has unused generic parameters\n+  --> $DIR/predicates.rs:14:4\n+   |\n+LL | fn foo<I, T>(_: I)\n+   |    ^^^    - generic parameter `T` is unused\n+\n+error: item has unused generic parameters\n+  --> $DIR/predicates.rs:23:4\n+   |\n+LL | fn baz<I, T>(_: I)\n+   |    ^^^    - generic parameter `T` is unused\n+\n+error: item has unused generic parameters\n+  --> $DIR/predicates.rs:44:19\n+   |\n+LL | impl<'a, I, T: 'a, E> Iterator for Foo<'a, I, E>\n+   |          -         - generic parameter `E` is unused\n+   |          |\n+   |          generic parameter `I` is unused\n+...\n+LL |         self.find(|_| true)\n+   |                   ^^^^^^^^\n+\n+error: item has unused generic parameters\n+  --> $DIR/predicates.rs:58:4\n+   |\n+LL | fn quux<A, B, C: Default>() -> usize\n+   |    ^^^^ -  - generic parameter `B` is unused\n+   |         |\n+   |         generic parameter `A` is unused\n+\n+error: item has unused generic parameters\n+  --> $DIR/predicates.rs:75:4\n+   |\n+LL | fn foobar<F, G>() -> usize\n+   |    ^^^^^^ - generic parameter `F` is unused\n+\n error: item has unused generic parameters\n   --> $DIR/predicates.rs:9:4\n    |\n LL | fn bar<I>() {\n    |    ^^^ - generic parameter `I` is unused\n \n-error: aborting due to previous error\n+error: aborting due to 6 previous errors\n "}]}