{"sha": "98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "node_id": "C_kwDOAAsO6NoAKDk4YTVhOThmNDQxMzBiNWJhZmI0ZjJiMmYzMTI2ZmIyMmE1YTMyMjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-05T22:28:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-05T22:28:40Z"}, "message": "Auto merge of #89572 - Manishearth:rollup-obz5ycp, r=Manishearth\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #88706 (Normalize associated type projections when checking return type of main)\n - #88828 (Use `libc::sigaction()` instead of `sys::signal()` to prevent a deadlock)\n - #88871 (Fix suggestion for nested struct patterns)\n - #89317 (Move generic error message to separate branches)\n - #89351 (for signed wrapping remainder, do not compare lhs with MIN)\n - #89442 (Add check for duplicated doc aliases)\n - #89502 (Fix Lower/UpperExp formatting for integers and precision zero)\n - #89523 (Make `proc_macro_derive_resolution_fallback` a future-breakage lint)\n - #89532 (Document behavior of  `MaybeLiveLocals` regarding enums and field-senstivity)\n - #89546 (Make an initial guess for metadata size to reduce buffer resizes)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "411ef5015faad89dc56928c2040b47fd2cff070f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/411ef5015faad89dc56928c2040b47fd2cff070f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "html_url": "https://github.com/rust-lang/rust/commit/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25ec8273855fde2d72ae877b397e054de5300e10", "url": "https://api.github.com/repos/rust-lang/rust/commits/25ec8273855fde2d72ae877b397e054de5300e10", "html_url": "https://github.com/rust-lang/rust/commit/25ec8273855fde2d72ae877b397e054de5300e10"}, {"sha": "5f8b1614d110fc3f0cd8536e08822a8cead32172", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f8b1614d110fc3f0cd8536e08822a8cead32172", "html_url": "https://github.com/rust-lang/rust/commit/5f8b1614d110fc3f0cd8536e08822a8cead32172"}], "stats": {"total": 535, "additions": 455, "deletions": 80}, "files": [{"sha": "9d56bc193fb2958c6531583d51578fed3970b5d3", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -1960,6 +1960,7 @@ declare_lint! {\n     \"detects proc macro derives using inaccessible names from parent modules\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #83583 <https://github.com/rust-lang/rust/issues/83583>\",\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n     };\n }\n "}, {"sha": "9b1ea3b4c4cf503d4b3d691eb2a6a4773aee09e8", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -740,7 +740,9 @@ fn get_metadata_section(\n             // Header is okay -> inflate the actual metadata\n             let compressed_bytes = &buf[header_len..];\n             debug!(\"inflating {} bytes of compressed metadata\", compressed_bytes.len());\n-            let mut inflated = Vec::new();\n+            // Assume the decompressed data will be at least the size of the compressed data, so we\n+            // don't have to grow the buffer as much.\n+            let mut inflated = Vec::with_capacity(compressed_bytes.len());\n             match FrameDecoder::new(compressed_bytes).read_to_end(&mut inflated) {\n                 Ok(_) => rustc_erase_owner!(OwningRef::new(inflated).map_owner_box()),\n                 Err(_) => {"}, {"sha": "3e2548845e20f693f9d4bd6031dcf2c68abdc570", "filename": "compiler/rustc_mir_dataflow/src/impls/liveness.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -11,6 +11,37 @@ use crate::{AnalysisDomain, Backward, GenKill, GenKillAnalysis};\n /// exist. See [this `mir-dataflow` test][flow-test] for an example. You almost never want to use\n /// this analysis without also looking at the results of [`MaybeBorrowedLocals`].\n ///\n+/// ## Field-(in)sensitivity\n+///\n+/// As the name suggests, this analysis is field insensitive. If a projection of a variable `x` is\n+/// assigned to (e.g. `x.0 = 42`), it does not \"define\" `x` as far as liveness is concerned. In fact,\n+/// such an assignment is currently marked as a \"use\" of `x` in an attempt to be maximally\n+/// conservative.\n+///\n+/// ## Enums and `SetDiscriminant`\n+///\n+/// Assigning a literal value to an `enum` (e.g. `Option<i32>`), does not result in a simple\n+/// assignment of the form `_1 = /*...*/` in the MIR. For example, the following assignment to `x`:\n+///\n+/// ```\n+/// x = Some(4);\n+/// ```\n+///\n+/// compiles to this MIR\n+///\n+/// ```\n+/// ((_1 as Some).0: i32) = const 4_i32;\n+/// discriminant(_1) = 1;\n+/// ```\n+///\n+/// However, `MaybeLiveLocals` **does** mark `x` (`_1`) as \"killed\" after a statement like this.\n+/// That's because it treats the `SetDiscriminant` operation as a definition of `x`, even though\n+/// the writes that actually initialized the locals happened earlier.\n+///\n+/// This makes `MaybeLiveLocals` unsuitable for certain classes of optimization normally associated\n+/// with a live variables analysis, notably dead-store elimination. It's a dirty hack, but it works\n+/// okay for the generator state transform (currently the main consumuer of this analysis).\n+///\n /// [`MaybeBorrowedLocals`]: super::MaybeBorrowedLocals\n /// [flow-test]: https://github.com/rust-lang/rust/blob/a08c47310c7d49cbdc5d7afb38408ba519967ecd/src/test/ui/mir-dataflow/liveness-ptr.rs\n /// [liveness]: https://en.wikipedia.org/wiki/Live_variable_analysis"}, {"sha": "e7b2a018680ad4f39969e4cbf8a6eb989b3d6a0f", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n \n use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, NestedMetaItem};\n-use rustc_data_structures::stable_set::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability};\n use rustc_feature::{AttributeType, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n@@ -66,6 +66,7 @@ impl CheckAttrVisitor<'tcx> {\n         target: Target,\n         item: Option<ItemLike<'_>>,\n     ) {\n+        let mut doc_aliases = FxHashMap::default();\n         let mut is_valid = true;\n         let mut specified_inline = None;\n         let mut seen = FxHashSet::default();\n@@ -79,7 +80,13 @@ impl CheckAttrVisitor<'tcx> {\n                 sym::track_caller => {\n                     self.check_track_caller(hir_id, &attr.span, attrs, span, target)\n                 }\n-                sym::doc => self.check_doc_attrs(attr, hir_id, target, &mut specified_inline),\n+                sym::doc => self.check_doc_attrs(\n+                    attr,\n+                    hir_id,\n+                    target,\n+                    &mut specified_inline,\n+                    &mut doc_aliases,\n+                ),\n                 sym::no_link => self.check_no_link(hir_id, &attr, span, target),\n                 sym::export_name => self.check_export_name(hir_id, &attr, span, target),\n                 sym::rustc_layout_scalar_valid_range_start\n@@ -512,6 +519,7 @@ impl CheckAttrVisitor<'tcx> {\n         hir_id: HirId,\n         target: Target,\n         is_list: bool,\n+        aliases: &mut FxHashMap<String, Span>,\n     ) -> bool {\n         let tcx = self.tcx;\n         let err_fn = move |span: Span, msg: &str| {\n@@ -582,17 +590,38 @@ impl CheckAttrVisitor<'tcx> {\n         if &*item_name.as_str() == doc_alias {\n             return err_fn(meta.span(), \"is the same as the item's name\");\n         }\n+        let span = meta.span();\n+        if let Err(entry) = aliases.try_insert(doc_alias.to_owned(), span) {\n+            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, span, |lint| {\n+                lint.build(\"doc alias is duplicated\")\n+                    .span_label(*entry.entry.get(), \"first defined here\")\n+                    .emit();\n+            });\n+        }\n         true\n     }\n \n-    fn check_doc_alias(&self, meta: &NestedMetaItem, hir_id: HirId, target: Target) -> bool {\n+    fn check_doc_alias(\n+        &self,\n+        meta: &NestedMetaItem,\n+        hir_id: HirId,\n+        target: Target,\n+        aliases: &mut FxHashMap<String, Span>,\n+    ) -> bool {\n         if let Some(values) = meta.meta_item_list() {\n             let mut errors = 0;\n             for v in values {\n                 match v.literal() {\n                     Some(l) => match l.kind {\n                         LitKind::Str(s, _) => {\n-                            if !self.check_doc_alias_value(v, &s.as_str(), hir_id, target, true) {\n+                            if !self.check_doc_alias_value(\n+                                v,\n+                                &s.as_str(),\n+                                hir_id,\n+                                target,\n+                                true,\n+                                aliases,\n+                            ) {\n                                 errors += 1;\n                             }\n                         }\n@@ -621,7 +650,7 @@ impl CheckAttrVisitor<'tcx> {\n             }\n             errors == 0\n         } else if let Some(doc_alias) = meta.value_str().map(|s| s.to_string()) {\n-            self.check_doc_alias_value(meta, &doc_alias, hir_id, target, false)\n+            self.check_doc_alias_value(meta, &doc_alias, hir_id, target, false, aliases)\n         } else {\n             self.tcx\n                 .sess\n@@ -858,6 +887,7 @@ impl CheckAttrVisitor<'tcx> {\n         hir_id: HirId,\n         target: Target,\n         specified_inline: &mut Option<(bool, Span)>,\n+        aliases: &mut FxHashMap<String, Span>,\n     ) -> bool {\n         let mut is_valid = true;\n \n@@ -867,7 +897,7 @@ impl CheckAttrVisitor<'tcx> {\n                     match i_meta.name_or_empty() {\n                         sym::alias\n                             if !self.check_attr_not_crate_level(&meta, hir_id, \"alias\")\n-                                || !self.check_doc_alias(&meta, hir_id, target) =>\n+                                || !self.check_doc_alias(&meta, hir_id, target, aliases) =>\n                         {\n                             is_valid = false\n                         }"}, {"sha": "4adec3c4f608d78e93c412ccb6a5476a370fad7d", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -9,8 +9,9 @@\n #![feature(in_band_lifetimes)]\n #![feature(format_args_capture)]\n #![feature(iter_zip)]\n-#![feature(nll)]\n+#![feature(map_try_insert)]\n #![feature(min_specialization)]\n+#![feature(nll)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "3d7a215754acaf63e0aaed41c3deda44cc715744", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -265,21 +265,24 @@ impl IrMaps<'tcx> {\n         self.capture_info_map.insert(hir_id, Rc::new(cs));\n     }\n \n-    fn add_from_pat(&mut self, pat: &hir::Pat<'tcx>) {\n+    fn collect_shorthand_field_ids(&self, pat: &hir::Pat<'tcx>) -> HirIdSet {\n         // For struct patterns, take note of which fields used shorthand\n         // (`x` rather than `x: x`).\n         let mut shorthand_field_ids = HirIdSet::default();\n         let mut pats = VecDeque::new();\n         pats.push_back(pat);\n+\n         while let Some(pat) = pats.pop_front() {\n             use rustc_hir::PatKind::*;\n             match &pat.kind {\n                 Binding(.., inner_pat) => {\n                     pats.extend(inner_pat.iter());\n                 }\n                 Struct(_, fields, _) => {\n-                    let ids = fields.iter().filter(|f| f.is_shorthand).map(|f| f.pat.hir_id);\n-                    shorthand_field_ids.extend(ids);\n+                    let (short, not_short): (Vec<&_>, Vec<&_>) =\n+                        fields.iter().partition(|f| f.is_shorthand);\n+                    shorthand_field_ids.extend(short.iter().map(|f| f.pat.hir_id));\n+                    pats.extend(not_short.iter().map(|f| f.pat));\n                 }\n                 Ref(inner_pat, _) | Box(inner_pat) => {\n                     pats.push_back(inner_pat);\n@@ -296,6 +299,12 @@ impl IrMaps<'tcx> {\n             }\n         }\n \n+        return shorthand_field_ids;\n+    }\n+\n+    fn add_from_pat(&mut self, pat: &hir::Pat<'tcx>) {\n+        let shorthand_field_ids = self.collect_shorthand_field_ids(pat);\n+\n         pat.each_binding(|_, hir_id, _, ident| {\n             self.add_live_node_for_node(hir_id, VarDefNode(ident.span, hir_id));\n             self.add_variable(Local(LocalInfo {\n@@ -373,15 +382,13 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        let shorthand_field_ids = self.collect_shorthand_field_ids(param.pat);\n         param.pat.each_binding(|_bm, hir_id, _x, ident| {\n             let var = match param.pat.kind {\n-                rustc_hir::PatKind::Struct(_, fields, _) => Local(LocalInfo {\n+                rustc_hir::PatKind::Struct(..) => Local(LocalInfo {\n                     id: hir_id,\n                     name: ident.name,\n-                    is_shorthand: fields\n-                        .iter()\n-                        .find(|f| f.ident == ident)\n-                        .map_or(false, |f| f.is_shorthand),\n+                    is_shorthand: shorthand_field_ids.contains(&hir_id),\n                 }),\n                 _ => Param(hir_id, ident.name),\n             };"}, {"sha": "25ec9682d84070f2ce4255ce051ba5df9ecf4c58", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 94, "deletions": 43, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -236,16 +236,27 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         self.body.exprs[self.body_id].span\n     }\n \n-    fn error(&mut self, span: Option<Span>, msg: &str) -> Result<!, ErrorReported> {\n+    fn error(&mut self, span: Span, msg: &str) -> Result<!, ErrorReported> {\n         self.tcx\n             .sess\n             .struct_span_err(self.root_span(), \"overly complex generic constant\")\n-            .span_label(span.unwrap_or(self.root_span()), msg)\n+            .span_label(span, msg)\n             .help(\"consider moving this anonymous constant into a `const` function\")\n             .emit();\n \n         Err(ErrorReported)\n     }\n+    fn maybe_supported_error(&mut self, span: Span, msg: &str) -> Result<!, ErrorReported> {\n+        self.tcx\n+            .sess\n+            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n+            .span_label(span, msg)\n+            .help(\"consider moving this anonymous constant into a `const` function\")\n+            .note(\"this operation may be supported in the future\")\n+            .emit();\n+\n+        Err(ErrorReported)\n+    }\n \n     fn new(\n         tcx: TyCtxt<'tcx>,\n@@ -337,14 +348,14 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         Ok(match &node.kind {\n             // I dont know if handling of these 3 is correct\n             &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n-            &ExprKind::PlaceTypeAscription { source, .. } |\n-            &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n+            &ExprKind::PlaceTypeAscription { source, .. }\n+            | &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n \n             // subtle: associated consts are literals this arm handles\n             // `<T as Trait>::ASSOC` as well as `12`\n             &ExprKind::Literal { literal, .. } => self.nodes.push(Node::Leaf(literal)),\n \n-            ExprKind::Call { fun, args,  .. } => {\n+            ExprKind::Call { fun, args, .. } => {\n                 let fun = self.recurse_build(*fun)?;\n \n                 let mut new_args = Vec::<NodeId>::with_capacity(args.len());\n@@ -353,7 +364,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 }\n                 let new_args = self.tcx.arena.alloc_slice(&new_args);\n                 self.nodes.push(Node::FunctionCall(fun, new_args))\n-            },\n+            }\n             &ExprKind::Binary { op, lhs, rhs } if Self::check_binop(op) => {\n                 let lhs = self.recurse_build(lhs)?;\n                 let rhs = self.recurse_build(rhs)?;\n@@ -362,68 +373,108 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             &ExprKind::Unary { op, arg } if Self::check_unop(op) => {\n                 let arg = self.recurse_build(arg)?;\n                 self.nodes.push(Node::UnaryOp(op, arg))\n-            },\n+            }\n             // This is necessary so that the following compiles:\n             //\n             // ```\n             // fn foo<const N: usize>(a: [(); N + 1]) {\n             //     bar::<{ N + 1 }>();\n             // }\n             // ```\n-            ExprKind::Block { body: thir::Block { stmts: box [], expr: Some(e), .. }} => self.recurse_build(*e)?,\n+            ExprKind::Block { body: thir::Block { stmts: box [], expr: Some(e), .. } } => {\n+                self.recurse_build(*e)?\n+            }\n             // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n             // \"coercion cast\" i.e. using a coercion or is a no-op.\n             // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n             &ExprKind::Use { source } => {\n                 let arg = self.recurse_build(source)?;\n                 self.nodes.push(Node::Cast(abstract_const::CastKind::Use, arg, node.ty))\n-            },\n+            }\n             &ExprKind::Cast { source } => {\n                 let arg = self.recurse_build(source)?;\n                 self.nodes.push(Node::Cast(abstract_const::CastKind::As, arg, node.ty))\n-            },\n+            }\n \n             // FIXME(generic_const_exprs): We may want to support these.\n             ExprKind::AddressOf { .. }\n             | ExprKind::Borrow { .. }\n-            | ExprKind::Deref { .. }\n-            | ExprKind::Repeat { .. }\n-            | ExprKind::Array { .. }\n-            | ExprKind::Block { .. }\n-            | ExprKind::NeverToAny { .. }\n-            | ExprKind::Tuple { .. }\n-            | ExprKind::Index { .. }\n-            | ExprKind::Field { .. }\n-            | ExprKind::ConstBlock { .. }\n-            | ExprKind::Adt(_) => self.error(\n-                    Some(node.span),\n-                    \"unsupported operation in generic constant, this may be supported in the future\",\n+            | ExprKind::Deref { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"dereferencing is not supported in generic constants\",\n+            )?,\n+            ExprKind::Repeat { .. } | ExprKind::Array { .. } =>  self.maybe_supported_error(\n+                node.span,\n+                \"array construction is not supported in generic constants\",\n+            )?,\n+            ExprKind::Block { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"blocks are not supported in generic constant\",\n+            )?,\n+            ExprKind::NeverToAny { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"converting nevers to any is not supported in generic constant\",\n+            )?,\n+            ExprKind::Tuple { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"tuple construction is not supported in generic constants\",\n+            )?,\n+            ExprKind::Index { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"indexing is not supported in generic constant\",\n+            )?,\n+            ExprKind::Field { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"field access is not supported in generic constant\",\n+            )?,\n+            ExprKind::ConstBlock { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"const blocks are not supported in generic constant\",\n+            )?,\n+            ExprKind::Adt(_) => self.maybe_supported_error(\n+                node.span,\n+                \"struct/enum construction is not supported in generic constants\",\n+            )?,\n+            // dont know if this is correct\n+            ExprKind::Pointer { .. } =>\n+                self.error(node.span, \"pointer casts are not allowed in generic constants\")?,\n+            ExprKind::Yield { .. } =>\n+                self.error(node.span, \"generator control flow is not allowed in generic constants\")?,\n+            ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Loop { .. } => self\n+                .error(\n+                    node.span,\n+                    \"loops and loop control flow are not supported in generic constants\",\n                 )?,\n+            ExprKind::Box { .. } =>\n+                self.error(node.span, \"allocations are not allowed in generic constants\")?,\n+\n+            ExprKind::Unary { .. } => unreachable!(),\n+            // we handle valid unary/binary ops above\n+            ExprKind::Binary { .. } =>\n+                self.error(node.span, \"unsupported binary operation in generic constants\")?,\n+            ExprKind::LogicalOp { .. } =>\n+                self.error(node.span, \"unsupported operation in generic constants, short-circuiting operations would imply control flow\")?,\n+            ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n+                self.error(node.span, \"assignment is not supported in generic constants\")?\n+            }\n+            ExprKind::Closure { .. } | ExprKind::Return { .. } => self.error(\n+                node.span,\n+                \"closures and function keywords are not supported in generic constants\",\n+            )?,\n+            // let expressions imply control flow\n+            ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } =>\n+                self.error(node.span, \"control flow is not supported in generic constants\")?,\n+            ExprKind::LlvmInlineAsm { .. } | ExprKind::InlineAsm { .. } => {\n+                self.error(node.span, \"assembly is not supported in generic constants\")?\n+            }\n \n-            ExprKind::Match { .. }\n             // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n-            | ExprKind::VarRef { .. }\n+            ExprKind::VarRef { .. }\n             | ExprKind::UpvarRef { .. }\n-            | ExprKind::Closure { .. }\n-            | ExprKind::Let { .. } // let expressions imply control flow\n-            | ExprKind::Loop { .. }\n-            | ExprKind::Assign { .. }\n             | ExprKind::StaticRef { .. }\n-            | ExprKind::LogicalOp { .. }\n-            // we handle valid unary/binary ops above\n-            | ExprKind::Unary { .. }\n-            | ExprKind::Binary { .. }\n-            | ExprKind::Break { .. }\n-            | ExprKind::Continue { .. }\n-            | ExprKind::If { .. }\n-            | ExprKind::Pointer { .. } // dont know if this is correct\n-            | ExprKind::ThreadLocalRef(_)\n-            | ExprKind::LlvmInlineAsm { .. }\n-            | ExprKind::Return { .. }\n-            | ExprKind::Box { .. } // allocations not allowed in constants\n-            | ExprKind::AssignOp { .. }\n-            | ExprKind::InlineAsm { .. }\n-            | ExprKind::Yield { .. } => self.error(Some(node.span), \"unsupported operation in generic constant\")?,\n+            | ExprKind::ThreadLocalRef(_) => {\n+                self.error(node.span, \"unsupported operation in generic constant\")?\n+            }\n         })\n     }\n }"}, {"sha": "65eedd2daafa8ebf50232b309b4e25394d375482", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -107,6 +107,7 @@ use rustc_middle::util;\n use rustc_session::config::EntryFnType;\n use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt as _,\n@@ -328,7 +329,26 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n                 ObligationCauseCode::MainFunctionType,\n             );\n             let mut fulfillment_cx = traits::FulfillmentContext::new();\n-            fulfillment_cx.register_bound(&infcx, ty::ParamEnv::empty(), return_ty, term_id, cause);\n+            // normalize any potential projections in the return type, then add\n+            // any possible obligations to the fulfillment context.\n+            // HACK(ThePuzzlemaker) this feels symptomatic of a problem within\n+            // checking trait fulfillment, not this here. I'm not sure why it\n+            // works in the example in `fn test()` given in #88609? This also\n+            // probably isn't the best way to do this.\n+            let InferOk { value: norm_return_ty, obligations } = infcx\n+                .partially_normalize_associated_types_in(\n+                    cause.clone(),\n+                    ty::ParamEnv::empty(),\n+                    return_ty,\n+                );\n+            fulfillment_cx.register_predicate_obligations(&infcx, obligations);\n+            fulfillment_cx.register_bound(\n+                &infcx,\n+                ty::ParamEnv::empty(),\n+                norm_return_ty,\n+                term_id,\n+                cause,\n+            );\n             if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n                 infcx.report_fulfillment_errors(&err, None, false);\n                 error = true;"}, {"sha": "05ca50a97a644e8661bce742e7b4a757824da861", "filename": "library/core/src/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -305,7 +305,6 @@ macro_rules! impl_Exp {\n                     n /= 10;\n                     exponent += 1;\n                 }\n-                let trailing_zeros = exponent;\n \n                 let (added_precision, subtracted_precision) = match f.precision() {\n                     Some(fmt_prec) => {\n@@ -333,7 +332,7 @@ macro_rules! impl_Exp {\n                         n += 1;\n                     }\n                 }\n-                (n, exponent, trailing_zeros, added_precision)\n+                (n, exponent, exponent, added_precision)\n             };\n \n             // 39 digits (worst case u128) + . = 40"}, {"sha": "9d46948ce02af8fdcbec47d90c949ebcbfdbff4c", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -1533,9 +1533,8 @@ macro_rules! int_impl {\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n-            // Using `&` helps LLVM see that it is the same check made in division.\n-            if unlikely!((self == Self::MIN) & (rhs == -1)) {\n-                (0, true)\n+            if unlikely!(rhs == -1) {\n+                (0, self == Self::MIN)\n             } else {\n                 (self % rhs, false)\n             }\n@@ -1565,9 +1564,8 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[inline]\n         pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n-            // Using `&` helps LLVM see that it is the same check made in division.\n-            if unlikely!((self == Self::MIN) & (rhs == -1)) {\n-                (0, true)\n+            if unlikely!(rhs == -1) {\n+                (0, self == Self::MIN)\n             } else {\n                 (self.rem_euclid(rhs), false)\n             }"}, {"sha": "b958422d14f84b6e7c39543e7857e56e34a300ee", "filename": "library/core/tests/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/library%2Fcore%2Ftests%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/library%2Fcore%2Ftests%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ffmt%2Fnum.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -146,6 +146,7 @@ fn test_format_int_exp_precision() {\n     assert_eq!(format!(\"{:.1000e}\", 1), format!(\"1.{}e0\", \"0\".repeat(1000)));\n     //test zero precision\n     assert_eq!(format!(\"{:.0e}\", 1), format!(\"1e0\",));\n+    assert_eq!(format!(\"{:.0e}\", 35), format!(\"4e1\",));\n \n     //test padding with precision (and sign)\n     assert_eq!(format!(\"{:+10.3e}\", 1), \"  +1.000e0\");"}, {"sha": "99013efb495d095d681d1f60fbeb1762e11074e6", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -333,9 +333,19 @@ impl Command {\n             let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n             cvt(sigemptyset(set.as_mut_ptr()))?;\n             cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), ptr::null_mut()))?;\n-            let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n-            if ret == libc::SIG_ERR {\n-                return Err(io::Error::last_os_error());\n+\n+            #[cfg(target_os = \"android\")] // see issue #88585\n+            {\n+                let mut action: libc::sigaction = mem::zeroed();\n+                action.sa_sigaction = libc::SIG_DFL;\n+                cvt(libc::sigaction(libc::SIGPIPE, &action, ptr::null_mut()))?;\n+            }\n+            #[cfg(not(target_os = \"android\"))]\n+            {\n+                let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n+                if ret == libc::SIG_ERR {\n+                    return Err(io::Error::last_os_error());\n+                }\n             }\n         }\n "}, {"sha": "041232e86907954a2e70142110fd1070dad440ca", "filename": "src/test/ui/const-generics/generic_const_exprs/array-size-in-generic-struct-param.full.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Farray-size-in-generic-struct-param.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Farray-size-in-generic-struct-param.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Farray-size-in-generic-struct-param.full.stderr?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -10,9 +10,10 @@ error: overly complex generic constant\n   --> $DIR/array-size-in-generic-struct-param.rs:19:15\n    |\n LL |     arr: [u8; CFG.arr_size],\n-   |               ^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n+   |               ^^^^^^^^^^^^ field access is not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0dfd804be41b48a0c44c0cae1a396c1d0c9b249f", "filename": "src/test/ui/const-generics/generic_const_exprs/closures.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -4,9 +4,10 @@ error: overly complex generic constant\n LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n    |                                   ^^^^-------^^\n    |                                       |\n-   |                                       unsupported operation in generic constant, this may be supported in the future\n+   |                                       dereferencing is not supported in generic constants\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: aborting due to previous error\n "}, {"sha": "5ebb4c3999c365478c09af2842e91a67e7650ac0", "filename": "src/test/ui/const-generics/generic_const_exprs/let-bindings.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Flet-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Flet-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Flet-bindings.stderr?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -2,17 +2,19 @@ error: overly complex generic constant\n   --> $DIR/let-bindings.rs:6:68\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                                                                    ^^^^^^^^^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n+   |                                                                    ^^^^^^^^^^^^^^^^^^^^ blocks are not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: overly complex generic constant\n   --> $DIR/let-bindings.rs:6:35\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                                   ^^^^^^^^^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n+   |                                   ^^^^^^^^^^^^^^^^^^^^ blocks are not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: aborting due to 2 previous errors\n "}, {"sha": "df73acf53de65f27be074845c9c0684c74628d06", "filename": "src/test/ui/const-generics/generic_const_exprs/unused_expr.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funused_expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funused_expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Funused_expr.stderr?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -2,25 +2,28 @@ error: overly complex generic constant\n   --> $DIR/unused_expr.rs:4:34\n    |\n LL | fn add<const N: usize>() -> [u8; { N + 1; 5 }] {\n-   |                                  ^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n+   |                                  ^^^^^^^^^^^^ blocks are not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: overly complex generic constant\n   --> $DIR/unused_expr.rs:9:34\n    |\n LL | fn div<const N: usize>() -> [u8; { N / 1; 5 }] {\n-   |                                  ^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n+   |                                  ^^^^^^^^^^^^ blocks are not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: overly complex generic constant\n   --> $DIR/unused_expr.rs:16:38\n    |\n LL | fn fn_call<const N: usize>() -> [u8; { foo(N); 5 }] {\n-   |                                      ^^^^^^^^^^^^^ unsupported operation in generic constant, this may be supported in the future\n+   |                                      ^^^^^^^^^^^^^ blocks are not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: aborting due to 3 previous errors\n "}, {"sha": "0f0e339655bcaaa9790502bfe00b52def331a4bf", "filename": "src/test/ui/const-generics/issues/issue-67375.full.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67375.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67375.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67375.full.stderr?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -4,7 +4,7 @@ error: overly complex generic constant\n LL |     inner: [(); { [|_: &T| {}; 0].len() }],\n    |                 ^^---------------------^^\n    |                   |\n-   |                   unsupported operation in generic constant\n+   |                   pointer casts are not allowed in generic constants\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}, {"sha": "cce85772aa4daab36009c35920a5a90c32bfbdc7", "filename": "src/test/ui/const-generics/issues/issue-67945-2.full.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67945-2.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67945-2.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67945-2.full.stderr?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -8,9 +8,10 @@ LL | |         let x: Option<Box<Self>> = None;\n LL | |\n LL | |         0\n LL | |     }],\n-   | |_____^ unsupported operation in generic constant, this may be supported in the future\n+   | |_____^ blocks are not supported in generic constant\n    |\n    = help: consider moving this anonymous constant into a `const` function\n+   = note: this operation may be supported in the future\n \n error: aborting due to previous error\n "}, {"sha": "a564ab64532b70e18e83cba1cd61e701409bcb21", "filename": "src/test/ui/duplicate_doc_alias.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fduplicate_doc_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fduplicate_doc_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fduplicate_doc_alias.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -0,0 +1,9 @@\n+#![deny(unused_attributes)]\n+\n+#[doc(alias = \"A\")]\n+#[doc(alias = \"A\")] //~ ERROR\n+#[doc(alias = \"B\")]\n+#[doc(alias(\"B\"))] //~ ERROR\n+pub struct Foo;\n+\n+fn main() {}"}, {"sha": "4b2dd1f8eb68e1b66a7b3814e9716af51afaa3de", "filename": "src/test/ui/duplicate_doc_alias.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fduplicate_doc_alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fduplicate_doc_alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fduplicate_doc_alias.stderr?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -0,0 +1,24 @@\n+error: doc alias is duplicated\n+  --> $DIR/duplicate_doc_alias.rs:4:7\n+   |\n+LL | #[doc(alias = \"A\")]\n+   |       ----------- first defined here\n+LL | #[doc(alias = \"A\")]\n+   |       ^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/duplicate_doc_alias.rs:1:9\n+   |\n+LL | #![deny(unused_attributes)]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: doc alias is duplicated\n+  --> $DIR/duplicate_doc_alias.rs:6:13\n+   |\n+LL | #[doc(alias = \"B\")]\n+   |       ----------- first defined here\n+LL | #[doc(alias(\"B\"))]\n+   |             ^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "5eb04ae8c8d37a1315c3caf0946bef0a7185866a", "filename": "src/test/ui/mir-dataflow/liveness-enum.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-enum.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -0,0 +1,22 @@\n+#![feature(core_intrinsics, rustc_attrs)]\n+\n+use std::intrinsics::rustc_peek;\n+\n+#[rustc_mir(rustc_peek_liveness, stop_after_dataflow)]\n+fn foo() -> Option<i32> {\n+    let mut x = None;\n+\n+    // `x` is live here since it is used in the next statement...\n+    rustc_peek(x);\n+\n+    dbg!(x);\n+\n+    // But not here, since it is overwritten below\n+    rustc_peek(x); //~ ERROR rustc_peek: bit not set\n+\n+    x = Some(4);\n+\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "483944d731aed0bd9aa4ed7d65c84d2f7976424a", "filename": "src/test/ui/mir-dataflow/liveness-enum.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-enum.stderr?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -0,0 +1,10 @@\n+error: rustc_peek: bit not set\n+  --> $DIR/liveness-enum.rs:15:5\n+   |\n+LL |     rustc_peek(x);\n+   |     ^^^^^^^^^^^^^\n+\n+error: stop_after_dataflow ended compilation\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "d6fd4baeb5ece7de355a3627c32bb13024ef8a58", "filename": "src/test/ui/proc-macro/generate-mod.stderr", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -82,3 +82,75 @@ LL |     #[derive(generate_mod::CheckDerive)]\n error: aborting due to 4 previous errors; 4 warnings emitted\n \n For more information about this error, try `rustc --explain E0412`.\n+Future incompatibility report: Future breakage diagnostic:\n+warning: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:16:10\n+   |\n+LL | #[derive(generate_mod::CheckDerive)]\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |\n+   = note: `#[warn(proc_macro_derive_resolution_fallback)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n+   = note: this warning originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+warning: cannot find type `OuterDerive` in this scope\n+  --> $DIR/generate-mod.rs:16:10\n+   |\n+LL | #[derive(generate_mod::CheckDerive)]\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n+   = note: this warning originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+warning: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:23:14\n+   |\n+LL |     #[derive(generate_mod::CheckDerive)]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n+   = note: this warning originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+warning: cannot find type `OuterDerive` in this scope\n+  --> $DIR/generate-mod.rs:23:14\n+   |\n+LL |     #[derive(generate_mod::CheckDerive)]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n+   = note: this warning originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+warning: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:30:10\n+   |\n+LL | #[derive(generate_mod::CheckDeriveLint)] // OK, lint is suppressed\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |\n+note: the lint level is defined here\n+  --> $DIR/generate-mod.rs:30:10\n+   |\n+LL | #[derive(generate_mod::CheckDeriveLint)] // OK, lint is suppressed\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n+   = note: this warning originates in the derive macro `generate_mod::CheckDeriveLint` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage diagnostic:\n+warning: cannot find type `OuterDeriveLint` in this scope\n+  --> $DIR/generate-mod.rs:30:10\n+   |\n+LL | #[derive(generate_mod::CheckDeriveLint)] // OK, lint is suppressed\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n+   = note: this warning originates in the derive macro `generate_mod::CheckDeriveLint` (in Nightly builds, run with -Z macro-backtrace for more info)\n+"}, {"sha": "1dc44838e8bb0d76c2e151bc7d4fa6e2eb9dfcfb", "filename": "src/test/ui/suggestions/ignore-nested-field-binding.fixed", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fsuggestions%2Fignore-nested-field-binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fsuggestions%2Fignore-nested-field-binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fignore-nested-field-binding.fixed?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for #88403, where prefixing with an underscore was\n+// erroneously suggested for a nested shorthand struct field binding.\n+\n+// run-rustfix\n+#![allow(unused)]\n+#![forbid(unused_variables)]\n+\n+struct Inner { i: i32 }\n+struct Outer { o: Inner }\n+\n+fn foo(Outer { o: Inner { i: _ } }: Outer) {}\n+//~^ ERROR: unused variable: `i`\n+//~| HELP: try ignoring the field\n+\n+fn main() {\n+    let s = Outer { o: Inner { i: 42 } };\n+    let Outer { o: Inner { i: _ } } = s;\n+    //~^ ERROR: unused variable: `i`\n+    //~| HELP: try ignoring the field\n+}"}, {"sha": "6dc0263ec9f2bac02a308585c9c444618ebbe21b", "filename": "src/test/ui/suggestions/ignore-nested-field-binding.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fsuggestions%2Fignore-nested-field-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fsuggestions%2Fignore-nested-field-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fignore-nested-field-binding.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for #88403, where prefixing with an underscore was\n+// erroneously suggested for a nested shorthand struct field binding.\n+\n+// run-rustfix\n+#![allow(unused)]\n+#![forbid(unused_variables)]\n+\n+struct Inner { i: i32 }\n+struct Outer { o: Inner }\n+\n+fn foo(Outer { o: Inner { i } }: Outer) {}\n+//~^ ERROR: unused variable: `i`\n+//~| HELP: try ignoring the field\n+\n+fn main() {\n+    let s = Outer { o: Inner { i: 42 } };\n+    let Outer { o: Inner { i } } = s;\n+    //~^ ERROR: unused variable: `i`\n+    //~| HELP: try ignoring the field\n+}"}, {"sha": "b2936a22a22f1a9970d329a78ed3b752aa2142c2", "filename": "src/test/ui/suggestions/ignore-nested-field-binding.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fsuggestions%2Fignore-nested-field-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Fsuggestions%2Fignore-nested-field-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fignore-nested-field-binding.stderr?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -0,0 +1,20 @@\n+error: unused variable: `i`\n+  --> $DIR/ignore-nested-field-binding.rs:11:27\n+   |\n+LL | fn foo(Outer { o: Inner { i } }: Outer) {}\n+   |                           ^ help: try ignoring the field: `i: _`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/ignore-nested-field-binding.rs:6:11\n+   |\n+LL | #![forbid(unused_variables)]\n+   |           ^^^^^^^^^^^^^^^^\n+\n+error: unused variable: `i`\n+  --> $DIR/ignore-nested-field-binding.rs:17:28\n+   |\n+LL |     let Outer { o: Inner { i } } = s;\n+   |                            ^ help: try ignoring the field: `i: _`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "dc459c885fa70fd56a9b1fd5516f9e570594beef", "filename": "src/test/ui/typeck/issue-88609.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Ftypeck%2Fissue-88609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/src%2Ftest%2Fui%2Ftypeck%2Fissue-88609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-88609.rs?ref=98a5a98f44130b5bafb4f2b2f3126fb22a5a3228", "patch": "@@ -0,0 +1,19 @@\n+// Regression test for #88609:\n+// The return type for `main` is not normalized while checking if it implements\n+// the trait `std::process::Termination`.\n+\n+// build-pass\n+\n+trait Same {\n+    type Output;\n+}\n+\n+impl<T> Same for T {\n+    type Output = T;\n+}\n+\n+type Unit = <() as Same>::Output;\n+\n+fn main() -> Result<Unit, std::io::Error> {\n+    unimplemented!()\n+}"}]}