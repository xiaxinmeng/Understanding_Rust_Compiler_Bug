{"sha": "399da7bc351714a0bc829bbbf2ab1f0b3e4f60f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5OWRhN2JjMzUxNzE0YTBiYzgyOWJiYmYyYWIxZjBiM2U0ZjYwZjg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-22T22:05:07Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-23T17:09:21Z"}, "message": "expansion: Improve searchability for `AstFragments` methods", "tree": {"sha": "b243cbcd0ca5935cf429a72efd3f459238eed18b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b243cbcd0ca5935cf429a72efd3f459238eed18b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/399da7bc351714a0bc829bbbf2ab1f0b3e4f60f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/399da7bc351714a0bc829bbbf2ab1f0b3e4f60f8", "html_url": "https://github.com/rust-lang/rust/commit/399da7bc351714a0bc829bbbf2ab1f0b3e4f60f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/399da7bc351714a0bc829bbbf2ab1f0b3e4f60f8/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a12726460ee2b36fe97ed5751c0d93758ed7cee5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a12726460ee2b36fe97ed5751c0d93758ed7cee5", "html_url": "https://github.com/rust-lang/rust/commit/a12726460ee2b36fe97ed5751c0d93758ed7cee5"}], "stats": {"total": 113, "additions": 65, "deletions": 48}, "files": [{"sha": "f7fc5bd57981f017a89ee3a3ab074bb08ead5b17", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 60, "deletions": 44, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/399da7bc351714a0bc829bbbf2ab1f0b3e4f60f8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399da7bc351714a0bc829bbbf2ab1f0b3e4f60f8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=399da7bc351714a0bc829bbbf2ab1f0b3e4f60f8", "patch": "@@ -41,30 +41,41 @@ use std::rc::Rc;\n use std::path::PathBuf;\n \n macro_rules! ast_fragments {\n-    ($($kind:ident: $ty:ty [$($vec:ident, $ty_elt:ty)*], $kind_name:expr, .$make:ident,\n-            $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n-            $(.$visit:ident)*  $(lift .$visit_elt:ident)*;)*) => {\n+    (\n+        $($Kind:ident($AstTy:ty) {\n+            $kind_name:expr;\n+            $(one fn $fold_ast:ident; fn $visit_ast:ident;)?\n+            $(many fn $fold_ast_elt:ident; fn $visit_ast_elt:ident;)?\n+            fn $make_ast:ident;\n+        })*\n+    ) => {\n         /// A fragment of AST that can be produced by a single macro expansion.\n         /// Can also serve as an input and intermediate result for macro expansion operations.\n-        pub enum AstFragment { OptExpr(Option<P<ast::Expr>>), $( $kind($ty), )* }\n+        pub enum AstFragment {\n+            OptExpr(Option<P<ast::Expr>>),\n+            $($Kind($AstTy),)*\n+        }\n \n         /// \"Discriminant\" of an AST fragment.\n         #[derive(Copy, Clone, PartialEq, Eq)]\n-        pub enum AstFragmentKind { OptExpr, $( $kind, )*  }\n+        pub enum AstFragmentKind {\n+            OptExpr,\n+            $($Kind,)*\n+        }\n \n         impl AstFragmentKind {\n             pub fn name(self) -> &'static str {\n                 match self {\n                     AstFragmentKind::OptExpr => \"expression\",\n-                    $( AstFragmentKind::$kind => $kind_name, )*\n+                    $(AstFragmentKind::$Kind => $kind_name,)*\n                 }\n             }\n \n             fn make_from<'a>(self, result: Box<MacResult + 'a>) -> Option<AstFragment> {\n                 match self {\n                     AstFragmentKind::OptExpr =>\n                         result.make_expr().map(Some).map(AstFragment::OptExpr),\n-                    $( AstFragmentKind::$kind => result.$make().map(AstFragment::$kind), )*\n+                    $(AstFragmentKind::$Kind => result.$make_ast().map(AstFragment::$Kind),)*\n                 }\n             }\n         }\n@@ -76,70 +87,75 @@ macro_rules! ast_fragments {\n                     _ => panic!(\"AstFragment::make_* called on the wrong kind of fragment\"),\n                 }\n             }\n-            $( pub fn $make(self) -> $ty {\n+\n+            $(pub fn $make_ast(self) -> $AstTy {\n                 match self {\n-                    AstFragment::$kind(ast) => ast,\n+                    AstFragment::$Kind(ast) => ast,\n                     _ => panic!(\"AstFragment::make_* called on the wrong kind of fragment\"),\n                 }\n-            } )*\n+            })*\n \n             pub fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n-                use self::AstFragment::*;\n                 match self {\n-                    OptExpr(expr) => OptExpr(expr.and_then(|expr| folder.fold_opt_expr(expr))),\n-                    $($( $kind(ast) => $kind(folder.$fold(ast)), )*)*\n-                    $($( $kind(ast) => {\n-                        $kind(ast.into_iter().flat_map(|ast| folder.$fold_elt(ast)).collect())\n-                    }, )*)*\n+                    AstFragment::OptExpr(expr) =>\n+                        AstFragment::OptExpr(expr.and_then(|expr| folder.fold_opt_expr(expr))),\n+                    $($(AstFragment::$Kind(ast) =>\n+                        AstFragment::$Kind(folder.$fold_ast(ast)),)?)*\n+                    $($(AstFragment::$Kind(ast) =>\n+                        AstFragment::$Kind(ast.into_iter()\n+                                              .flat_map(|ast| folder.$fold_ast_elt(ast))\n+                                              .collect()),)?)*\n                 }\n             }\n \n             pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n                 match *self {\n                     AstFragment::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n                     AstFragment::OptExpr(None) => {}\n-                    $($( AstFragment::$kind(ref ast) => visitor.$visit(ast), )*)*\n-                    $($( AstFragment::$kind(ref ast) => for ast in &ast[..] {\n-                        visitor.$visit_elt(ast);\n-                    }, )*)*\n+                    $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)?)*\n+                    $($(AstFragment::$Kind(ref ast) => for ast_elt in &ast[..] {\n+                        visitor.$visit_ast_elt(ast_elt);\n+                    })?)*\n                 }\n             }\n         }\n \n         impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n             fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-                self.expand(AstFragment::OptExpr(Some(expr))).make_opt_expr()\n+                self.expand_fragment(AstFragment::OptExpr(Some(expr))).make_opt_expr()\n             }\n-            $($(fn $fold(&mut self, node: $ty) -> $ty {\n-                self.expand(AstFragment::$kind(node)).$make()\n-            })*)*\n-            $($(fn $fold_elt(&mut self, node: $ty_elt) -> $ty {\n-                self.expand(AstFragment::$kind(SmallVector::one(node))).$make()\n-            })*)*\n+            $($(fn $fold_ast(&mut self, ast: $AstTy) -> $AstTy {\n+                self.expand_fragment(AstFragment::$Kind(ast)).$make_ast()\n+            })?)*\n+            $($(fn $fold_ast_elt(&mut self, ast_elt: <$AstTy as IntoIterator>::Item) -> $AstTy {\n+                self.expand_fragment(AstFragment::$Kind(SmallVector::one(ast_elt))).$make_ast()\n+            })?)*\n         }\n \n         impl<'a> MacResult for ::ext::tt::macro_rules::ParserAnyMacro<'a> {\n-            $(fn $make(self: Box<::ext::tt::macro_rules::ParserAnyMacro<'a>>) -> Option<$ty> {\n-                Some(self.make(AstFragmentKind::$kind).$make())\n+            $(fn $make_ast(self: Box<::ext::tt::macro_rules::ParserAnyMacro<'a>>)\n+                           -> Option<$AstTy> {\n+                Some(self.make(AstFragmentKind::$Kind).$make_ast())\n             })*\n         }\n     }\n }\n \n ast_fragments! {\n-    Expr: P<ast::Expr> [], \"expression\", .make_expr, .fold_expr, .visit_expr;\n-    Pat: P<ast::Pat>   [], \"pattern\",    .make_pat,  .fold_pat,  .visit_pat;\n-    Ty: P<ast::Ty>     [], \"type\",       .make_ty,   .fold_ty,   .visit_ty;\n-    Stmts: SmallVector<ast::Stmt> [SmallVector, ast::Stmt],\n-        \"statement\",  .make_stmts,       lift .fold_stmt, lift .visit_stmt;\n-    Items: SmallVector<P<ast::Item>> [SmallVector, P<ast::Item>],\n-        \"item\",       .make_items,       lift .fold_item, lift .visit_item;\n-    TraitItems: SmallVector<ast::TraitItem> [SmallVector, ast::TraitItem],\n-        \"trait item\", .make_trait_items, lift .fold_trait_item, lift .visit_trait_item;\n-    ImplItems: SmallVector<ast::ImplItem> [SmallVector, ast::ImplItem],\n-        \"impl item\",  .make_impl_items,  lift .fold_impl_item,  lift .visit_impl_item;\n-    ForeignItems: SmallVector<ast::ForeignItem> [SmallVector, ast::ForeignItem],\n-        \"foreign item\", .make_foreign_items, lift .fold_foreign_item, lift .visit_foreign_item;\n+    Expr(P<ast::Expr>) { \"expression\"; one fn fold_expr; fn visit_expr; fn make_expr; }\n+    Pat(P<ast::Pat>) { \"pattern\"; one fn fold_pat; fn visit_pat; fn make_pat; }\n+    Ty(P<ast::Ty>) { \"type\"; one fn fold_ty; fn visit_ty; fn make_ty; }\n+    Stmts(SmallVector<ast::Stmt>) { \"statement\"; many fn fold_stmt; fn visit_stmt; fn make_stmts; }\n+    Items(SmallVector<P<ast::Item>>) { \"item\"; many fn fold_item; fn visit_item; fn make_items; }\n+    TraitItems(SmallVector<ast::TraitItem>) {\n+        \"trait item\"; many fn fold_trait_item; fn visit_trait_item; fn make_trait_items;\n+    }\n+    ImplItems(SmallVector<ast::ImplItem>) {\n+        \"impl item\"; many fn fold_impl_item; fn visit_impl_item; fn make_impl_items;\n+    }\n+    ForeignItems(SmallVector<ast::ForeignItem>) {\n+        \"foreign item\"; many fn fold_foreign_item; fn visit_foreign_item; fn make_foreign_items;\n+    }\n }\n \n impl AstFragmentKind {\n@@ -261,7 +277,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             tokens: None,\n         })));\n \n-        match self.expand(krate_item).make_items().pop().map(P::into_inner) {\n+        match self.expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n             Some(ast::Item { attrs, node: ast::ItemKind::Mod(module), .. }) => {\n                 krate.attrs = attrs;\n                 krate.module = module;\n@@ -281,7 +297,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     // Fully expand all macro invocations in this AST fragment.\n-    fn expand(&mut self, input_fragment: AstFragment) -> AstFragment {\n+    fn expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n         self.cx.current_expansion.depth = 0;\n "}, {"sha": "1ace9193dc69dafaf675a0fb9e9c270d6d77a039", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/399da7bc351714a0bc829bbbf2ab1f0b3e4f60f8/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/399da7bc351714a0bc829bbbf2ab1f0b3e4f60f8/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=399da7bc351714a0bc829bbbf2ab1f0b3e4f60f8", "patch": "@@ -19,13 +19,14 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(attr(deny(warnings))))]\n \n-#![feature(unicode_internals)]\n-#![feature(rustc_diagnostic_macros)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(const_atomic_usize_new)]\n+#![feature(crate_visibility_modifier)]\n+#![feature(macro_at_most_once_rep)]\n #![feature(rustc_attrs)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(slice_sort_by_cached_key)]\n #![feature(str_escape)]\n-#![feature(crate_visibility_modifier)]\n+#![feature(unicode_internals)]\n \n #![recursion_limit=\"256\"]\n "}]}