{"sha": "dc1f442634c2e37a8b80d59e27edcc24b5614d4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMWY0NDI2MzRjMmUzN2E4YjgwZDU5ZTI3ZWRjYzI0YjU2MTRkNGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-06T01:55:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-06T01:55:45Z"}, "message": "Auto merge of #30492 - wesleywiser:fix_extra_drops, r=pnkfelix\n\nFixes #28159", "tree": {"sha": "b6b173f8da1d781b3025871e4ba7096465429c6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6b173f8da1d781b3025871e4ba7096465429c6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc1f442634c2e37a8b80d59e27edcc24b5614d4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc1f442634c2e37a8b80d59e27edcc24b5614d4e", "html_url": "https://github.com/rust-lang/rust/commit/dc1f442634c2e37a8b80d59e27edcc24b5614d4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc1f442634c2e37a8b80d59e27edcc24b5614d4e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd58fd8438bd906c8e87b98218a605db84d42c68", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd58fd8438bd906c8e87b98218a605db84d42c68", "html_url": "https://github.com/rust-lang/rust/commit/bd58fd8438bd906c8e87b98218a605db84d42c68"}, {"sha": "8c897ee0ab1250c306f815f469015b04115fa6c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c897ee0ab1250c306f815f469015b04115fa6c9", "html_url": "https://github.com/rust-lang/rust/commit/8c897ee0ab1250c306f815f469015b04115fa6c9"}], "stats": {"total": 99, "additions": 44, "deletions": 55}, "files": [{"sha": "47e7eee46966076830eb4e2d2d18a02826cc2142", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dc1f442634c2e37a8b80d59e27edcc24b5614d4e/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1f442634c2e37a8b80d59e27edcc24b5614d4e/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=dc1f442634c2e37a8b80d59e27edcc24b5614d4e", "patch": "@@ -46,7 +46,7 @@ use std::vec::IntoIter;\n use std::collections::{HashMap, HashSet};\n use syntax::ast::{self, CrateNum, Name, NodeId};\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::codemap::Span;\n+use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::{InternedString, special_idents};\n \n use rustc_front::hir;\n@@ -2394,6 +2394,39 @@ impl<'tcx> ctxt<'tcx> {\n             || self.sess.cstore.item_super_predicates(self, did))\n     }\n \n+    /// If `type_needs_drop` returns true, then `ty` is definitely\n+    /// non-copy and *might* have a destructor attached; if it returns\n+    /// false, then `ty` definitely has no destructor (i.e. no drop glue).\n+    ///\n+    /// (Note that this implies that if `ty` has a destructor attached,\n+    /// then `type_needs_drop` will definitely return `true` for `ty`.)\n+    pub fn type_needs_drop_given_env<'a>(&self,\n+                                         ty: Ty<'tcx>,\n+                                         param_env: &ty::ParameterEnvironment<'a,'tcx>) -> bool {\n+        // Issue #22536: We first query type_moves_by_default.  It sees a\n+        // normalized version of the type, and therefore will definitely\n+        // know whether the type implements Copy (and thus needs no\n+        // cleanup/drop/zeroing) ...\n+        let implements_copy = !ty.moves_by_default(param_env, DUMMY_SP);\n+\n+        if implements_copy { return false; }\n+\n+        // ... (issue #22536 continued) but as an optimization, still use\n+        // prior logic of asking if the `needs_drop` bit is set; we need\n+        // not zero non-Copy types if they have no destructor.\n+\n+        // FIXME(#22815): Note that calling `ty::type_contents` is a\n+        // conservative heuristic; it may report that `needs_drop` is set\n+        // when actual type does not actually have a destructor associated\n+        // with it. But since `ty` absolutely did not have the `Copy`\n+        // bound attached (see above), it is sound to treat it as having a\n+        // destructor (e.g. zero its memory on move).\n+\n+        let contents = ty.type_contents(self);\n+        debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents);\n+        contents.needs_drop(self)\n+    }\n+\n     /// Get the attributes of a definition.\n     pub fn get_attrs(&self, did: DefId) -> Cow<'tcx, [ast::Attribute]> {\n         if let Some(id) = self.map.as_local_node_id(did) {"}, {"sha": "b5e029ed94bd12f1defb33a2b8e897e576e26f11", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc1f442634c2e37a8b80d59e27edcc24b5614d4e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1f442634c2e37a8b80d59e27edcc24b5614d4e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=dc1f442634c2e37a8b80d59e27edcc24b5614d4e", "patch": "@@ -248,7 +248,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                          kind: DropKind,\n                          lvalue: &Lvalue<'tcx>,\n                          lvalue_ty: Ty<'tcx>) {\n-        if self.hir.needs_drop(lvalue_ty, span) {\n+        if self.hir.needs_drop(lvalue_ty) {\n             match self.scopes.iter_mut().rev().find(|s| s.extent == extent) {\n                 Some(scope) => {\n                     scope.drops.push((kind, span, lvalue.clone()));"}, {"sha": "07d32240d433023836e72ad7ec01ac327eb33d2e", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dc1f442634c2e37a8b80d59e27edcc24b5614d4e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1f442634c2e37a8b80d59e27edcc24b5614d4e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=dc1f442634c2e37a8b80d59e27edcc24b5614d4e", "patch": "@@ -90,17 +90,8 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n             .collect()\n     }\n \n-    pub fn needs_drop(&mut self, ty: Ty<'tcx>, span: Span) -> bool {\n-        if self.infcx.type_moves_by_default(ty, span) {\n-            // FIXME(#21859) we should do an add'l check here to determine if\n-            // any dtor will execute, but the relevant fn\n-            // (`type_needs_drop`) is currently factored into\n-            // `librustc_trans`, so we can't easily do so.\n-            true\n-        } else {\n-            // if type implements Copy, cannot require drop\n-            false\n-        }\n+    pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n+        self.tcx.type_needs_drop_given_env(ty, &self.infcx.parameter_environment)\n     }\n \n     pub fn span_bug(&mut self, span: Span, message: &str) -> ! {"}, {"sha": "964e981aec0930d8c11f325ed650da8b0171e3ee", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/dc1f442634c2e37a8b80d59e27edcc24b5614d4e/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1f442634c2e37a8b80d59e27edcc24b5614d4e/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=dc1f442634c2e37a8b80d59e27edcc24b5614d4e", "patch": "@@ -73,45 +73,6 @@ pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-/// If `type_needs_drop` returns true, then `ty` is definitely\n-/// non-copy and *might* have a destructor attached; if it returns\n-/// false, then `ty` definitely has no destructor (i.e. no drop glue).\n-///\n-/// (Note that this implies that if `ty` has a destructor attached,\n-/// then `type_needs_drop` will definitely return `true` for `ty`.)\n-pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    type_needs_drop_given_env(cx, ty, &cx.empty_parameter_environment())\n-}\n-\n-/// Core implementation of type_needs_drop, potentially making use of\n-/// and/or updating caches held in the `param_env`.\n-fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n-                                      ty: Ty<'tcx>,\n-                                      param_env: &ty::ParameterEnvironment<'a,'tcx>) -> bool {\n-    // Issue #22536: We first query type_moves_by_default.  It sees a\n-    // normalized version of the type, and therefore will definitely\n-    // know whether the type implements Copy (and thus needs no\n-    // cleanup/drop/zeroing) ...\n-    let implements_copy = !ty.moves_by_default(param_env, DUMMY_SP);\n-\n-    if implements_copy { return false; }\n-\n-    // ... (issue #22536 continued) but as an optimization, still use\n-    // prior logic of asking if the `needs_drop` bit is set; we need\n-    // not zero non-Copy types if they have no destructor.\n-\n-    // FIXME(#22815): Note that calling `ty::type_contents` is a\n-    // conservative heuristic; it may report that `needs_drop` is set\n-    // when actual type does not actually have a destructor associated\n-    // with it. But since `ty` absolutely did not have the `Copy`\n-    // bound attached (see above), it is sound to treat it as having a\n-    // destructor (e.g. zero its memory on move).\n-\n-    let contents = ty.type_contents(cx);\n-    debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents);\n-    contents.needs_drop(cx)\n-}\n-\n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyStruct(def, substs) => {\n@@ -518,7 +479,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     /// This is the same as `common::type_needs_drop`, except that it\n     /// may use or update caches within this `FunctionContext`.\n     pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        type_needs_drop_given_env(self.ccx.tcx(), ty, &self.param_env)\n+        self.ccx.tcx().type_needs_drop_given_env(ty, &self.param_env)\n     }\n \n     pub fn eh_personality(&self) -> ValueRef {"}, {"sha": "a1165ffe171d06673d736b518e57b8a557774469", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc1f442634c2e37a8b80d59e27edcc24b5614d4e/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1f442634c2e37a8b80d59e27edcc24b5614d4e/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=dc1f442634c2e37a8b80d59e27edcc24b5614d4e", "patch": "@@ -88,6 +88,10 @@ pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n+fn type_needs_drop<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    tcx.type_needs_drop_given_env(ty, &tcx.empty_parameter_environment())\n+}\n+\n pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     t: Ty<'tcx>) -> Ty<'tcx> {\n     let tcx = ccx.tcx();\n@@ -106,11 +110,11 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // returned `tcx.types.i8` does not appear unsound. The impact on\n     // code quality is unknown at this time.)\n \n-    if !type_needs_drop(tcx, t) {\n+    if !type_needs_drop(&tcx, t) {\n         return tcx.types.i8;\n     }\n     match t.sty {\n-        ty::TyBox(typ) if !type_needs_drop(tcx, typ)\n+        ty::TyBox(typ) if !type_needs_drop(&tcx, typ)\n                          && type_is_sized(tcx, typ) => {\n             let llty = sizing_type_of(ccx, typ);\n             // `Box<ZeroSizeType>` does not allocate."}]}