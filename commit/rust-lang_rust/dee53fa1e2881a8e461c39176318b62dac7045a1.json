{"sha": "dee53fa1e2881a8e461c39176318b62dac7045a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZTUzZmExZTI4ODFhOGU0NjFjMzkxNzYzMThiNjJkYWM3MDQ1YTE=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-05-09T13:26:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-09T13:26:01Z"}, "message": "Merge pull request #1728 from Manishearth/inspector\n\nPrint type adjustments in the inspector", "tree": {"sha": "3bef37b7356e47993e48d19f5aacadfbc08e82d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bef37b7356e47993e48d19f5aacadfbc08e82d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dee53fa1e2881a8e461c39176318b62dac7045a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dee53fa1e2881a8e461c39176318b62dac7045a1", "html_url": "https://github.com/rust-lang/rust/commit/dee53fa1e2881a8e461c39176318b62dac7045a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dee53fa1e2881a8e461c39176318b62dac7045a1/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc4a55ed6f5eb12efdb3a88837fb8019493576e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4a55ed6f5eb12efdb3a88837fb8019493576e5", "html_url": "https://github.com/rust-lang/rust/commit/dc4a55ed6f5eb12efdb3a88837fb8019493576e5"}, {"sha": "866239b1a8828f6f4e1401d0951299234751498a", "url": "https://api.github.com/repos/rust-lang/rust/commits/866239b1a8828f6f4e1401d0951299234751498a", "html_url": "https://github.com/rust-lang/rust/commit/866239b1a8828f6f4e1401d0951299234751498a"}], "stats": {"total": 82, "additions": 50, "deletions": 32}, "files": [{"sha": "19e205c9920e7c315645175343120e22c14f1611", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/dee53fa1e2881a8e461c39176318b62dac7045a1/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee53fa1e2881a8e461c39176318b62dac7045a1/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=dee53fa1e2881a8e461c39176318b62dac7045a1", "patch": "@@ -152,21 +152,22 @@ fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n \n fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n     let ind = \"  \".repeat(indent);\n-    let ty = cx.tables.node_id_to_type(expr.id);\n     println!(\"{}+\", ind);\n+    println!(\"{}ty: {}\", ind, cx.tables.expr_ty(expr));\n+    println!(\"{}adjustments: {:?}\", ind, cx.tables.adjustments.get(&expr.id));\n     match expr.node {\n         hir::ExprBox(ref e) => {\n-            println!(\"{}Box, {}\", ind, ty);\n+            println!(\"{}Box\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n         hir::ExprArray(ref v) => {\n-            println!(\"{}Array, {}\", ind, ty);\n+            println!(\"{}Array\", ind);\n             for e in v {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n         hir::ExprCall(ref func, ref args) => {\n-            println!(\"{}Call, {}\", ind, ty);\n+            println!(\"{}Call\", ind);\n             println!(\"{}function:\", ind);\n             print_expr(cx, func, indent + 1);\n             println!(\"{}arguments:\", ind);\n@@ -175,47 +176,47 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n             }\n         },\n         hir::ExprMethodCall(ref name, _, ref args) => {\n-            println!(\"{}MethodCall, {}\", ind, ty);\n+            println!(\"{}MethodCall\", ind);\n             println!(\"{}method name: {}\", ind, name.node);\n             for arg in args {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n         hir::ExprTup(ref v) => {\n-            println!(\"{}Tup, {}\", ind, ty);\n+            println!(\"{}Tup\", ind);\n             for e in v {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            println!(\"{}Binary, {}\", ind, ty);\n+            println!(\"{}Binary\", ind);\n             println!(\"{}op: {:?}\", ind, op.node);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n         hir::ExprUnary(op, ref inner) => {\n-            println!(\"{}Unary, {}\", ind, ty);\n+            println!(\"{}Unary\", ind);\n             println!(\"{}op: {:?}\", ind, op);\n             print_expr(cx, inner, indent + 1);\n         },\n         hir::ExprLit(ref lit) => {\n-            println!(\"{}Lit, {}\", ind, ty);\n+            println!(\"{}Lit\", ind);\n             println!(\"{}{:?}\", ind, lit);\n         },\n         hir::ExprCast(ref e, ref target) => {\n-            println!(\"{}Cast, {}\", ind, ty);\n+            println!(\"{}Cast\", ind);\n             print_expr(cx, e, indent + 1);\n             println!(\"{}target type: {:?}\", ind, target);\n         },\n         hir::ExprType(ref e, ref target) => {\n-            println!(\"{}Type, {}\", ind, ty);\n+            println!(\"{}Type\", ind);\n             print_expr(cx, e, indent + 1);\n             println!(\"{}target type: {:?}\", ind, target);\n         },\n         hir::ExprIf(ref e, _, ref els) => {\n-            println!(\"{}If, {}\", ind, ty);\n+            println!(\"{}If\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, e, indent + 1);\n             if let Some(ref els) = *els {\n@@ -224,55 +225,55 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n             }\n         },\n         hir::ExprWhile(ref cond, _, _) => {\n-            println!(\"{}While, {}\", ind, ty);\n+            println!(\"{}While\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, cond, indent + 1);\n         },\n         hir::ExprLoop(..) => {\n-            println!(\"{}Loop, {}\", ind, ty);\n+            println!(\"{}Loop\", ind);\n         },\n         hir::ExprMatch(ref cond, _, ref source) => {\n-            println!(\"{}Match, {}\", ind, ty);\n+            println!(\"{}Match\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, cond, indent + 1);\n             println!(\"{}source: {:?}\", ind, source);\n         },\n         hir::ExprClosure(ref clause, _, _, _) => {\n-            println!(\"{}Closure, {}\", ind, ty);\n+            println!(\"{}Closure\", ind);\n             println!(\"{}clause: {:?}\", ind, clause);\n         },\n         hir::ExprBlock(_) => {\n-            println!(\"{}Block, {}\", ind, ty);\n+            println!(\"{}Block\", ind);\n         },\n         hir::ExprAssign(ref lhs, ref rhs) => {\n-            println!(\"{}Assign, {}\", ind, ty);\n+            println!(\"{}Assign\", ind);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n         hir::ExprAssignOp(ref binop, ref lhs, ref rhs) => {\n-            println!(\"{}AssignOp, {}\", ind, ty);\n+            println!(\"{}AssignOp\", ind);\n             println!(\"{}op: {:?}\", ind, binop.node);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n         hir::ExprField(ref e, ref name) => {\n-            println!(\"{}Field, {}\", ind, ty);\n+            println!(\"{}Field\", ind);\n             println!(\"{}field name: {}\", ind, name.node);\n             println!(\"{}struct expr:\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n         hir::ExprTupField(ref e, ref idx) => {\n-            println!(\"{}TupField, {}\", ind, ty);\n+            println!(\"{}TupField\", ind);\n             println!(\"{}field index: {}\", ind, idx.node);\n             println!(\"{}tuple expr:\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n         hir::ExprIndex(ref arr, ref idx) => {\n-            println!(\"{}Index, {}\", ind, ty);\n+            println!(\"{}Index\", ind);\n             println!(\"{}array expr:\", ind);\n             print_expr(cx, arr, indent + 1);\n             println!(\"{}index expr:\", ind);\n@@ -287,25 +288,25 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n         hir::ExprAddrOf(ref muta, ref e) => {\n-            println!(\"{}AddrOf, {}\", ind, ty);\n+            println!(\"{}AddrOf\", ind);\n             println!(\"mutability: {:?}\", muta);\n             print_expr(cx, e, indent + 1);\n         },\n         hir::ExprBreak(_, ref e) => {\n-            println!(\"{}Break, {}\", ind, ty);\n+            println!(\"{}Break\", ind);\n             if let Some(ref e) = *e {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprAgain(_) => println!(\"{}Again, {}\", ind, ty),\n+        hir::ExprAgain(_) => println!(\"{}Again\", ind),\n         hir::ExprRet(ref e) => {\n-            println!(\"{}Ret, {}\", ind, ty);\n+            println!(\"{}Ret\", ind);\n             if let Some(ref e) = *e {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n         hir::ExprInlineAsm(_, ref input, ref output) => {\n-            println!(\"{}InlineAsm, {}\", ind, ty);\n+            println!(\"{}InlineAsm\", ind);\n             println!(\"{}inputs:\", ind);\n             for e in input {\n                 print_expr(cx, e, indent + 1);\n@@ -316,7 +317,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n             }\n         },\n         hir::ExprStruct(ref path, ref fields, ref base) => {\n-            println!(\"{}Struct, {}\", ind, ty);\n+            println!(\"{}Struct\", ind);\n             println!(\"{}path: {:?}\", ind, path);\n             for field in fields {\n                 println!(\"{}field \\\"{}\\\":\", ind, field.name.node);\n@@ -328,7 +329,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n             }\n         },\n         hir::ExprRepeat(ref val, body_id) => {\n-            println!(\"{}Repeat, {}\", ind, ty);\n+            println!(\"{}Repeat\", ind);\n             println!(\"{}value:\", ind);\n             print_expr(cx, val, indent + 1);\n             println!(\"{}repeat count:\", ind);"}, {"sha": "27ee4d1f696d0dc0d43ab9d70664596fbd5e7385", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dee53fa1e2881a8e461c39176318b62dac7045a1/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee53fa1e2881a8e461c39176318b62dac7045a1/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=dee53fa1e2881a8e461c39176318b62dac7045a1", "patch": "@@ -18,6 +18,15 @@ fn main() {\n     let vec_val = g(&vec); // should not error, because `&Vec<T>` derefs to `&[T]`\n     h(&\"foo\"); // should not error, because the `&&str` is required, due to `&Trait`\n     if let Some(ref cake) = Some(&5) {}\n+    let garbl = match 42 {\n+        44 => &a,\n+        45 => {\n+            println!(\"foo\");\n+            &&a // FIXME: this should lint, too\n+        },\n+        46 => &&a,\n+        _ => panic!(),\n+    };\n }\n \n fn f<T:Copy>(y: &T) -> T {"}, {"sha": "eab79e63bc4b540424e09e6ef505bd2e06fab27c", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dee53fa1e2881a8e461c39176318b62dac7045a1/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee53fa1e2881a8e461c39176318b62dac7045a1/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=dee53fa1e2881a8e461c39176318b62dac7045a1", "patch": "@@ -19,13 +19,21 @@ error: this pattern creates a reference to a reference\n    |\n    = note: #[deny(needless_borrow)] implied by #[deny(clippy)]\n \n+error: this expression borrows a reference that is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:27:15\n+   |\n+27 |         46 => &&a,\n+   |               ^^^\n+   |\n+   = note: #[deny(needless_borrow)] implied by #[deny(clippy)]\n+\n warning: this pattern creates a reference to a reference\n-  --> $DIR/needless_borrow.rs:41:31\n+  --> $DIR/needless_borrow.rs:50:31\n    |\n-41 |     let _ = v.iter().filter(|&ref a| a.is_empty());\n+50 |     let _ = v.iter().filter(|&ref a| a.is_empty());\n    |                               ^^^^^\n    |\n    = note: #[warn(needless_borrow)] on by default\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n "}]}