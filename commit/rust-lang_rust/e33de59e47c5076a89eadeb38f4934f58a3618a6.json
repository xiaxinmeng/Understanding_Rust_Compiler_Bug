{"sha": "e33de59e47c5076a89eadeb38f4934f58a3618a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzM2RlNTllNDdjNTA3NmE4OWVhZGViMzhmNDkzNGY1OGEzNjE4YTY=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-03T20:11:02Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-03T21:24:41Z"}, "message": "Clean up how we deal with dynamic size function arguments/returns.", "tree": {"sha": "6663c57c05cd080ac867bb1f573f4a96f9d8d74c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6663c57c05cd080ac867bb1f573f4a96f9d8d74c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e33de59e47c5076a89eadeb38f4934f58a3618a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e33de59e47c5076a89eadeb38f4934f58a3618a6", "html_url": "https://github.com/rust-lang/rust/commit/e33de59e47c5076a89eadeb38f4934f58a3618a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e33de59e47c5076a89eadeb38f4934f58a3618a6/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bcde7270d594d5a28a19105b754c0c450791799", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bcde7270d594d5a28a19105b754c0c450791799", "html_url": "https://github.com/rust-lang/rust/commit/7bcde7270d594d5a28a19105b754c0c450791799"}], "stats": {"total": 81, "additions": 24, "deletions": 57}, "files": [{"sha": "2bbd9a77270a6cbd8ef4199e04c7faf88e7cbcb1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 24, "deletions": 57, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/e33de59e47c5076a89eadeb38f4934f58a3618a6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33de59e47c5076a89eadeb38f4934f58a3618a6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e33de59e47c5076a89eadeb38f4934f58a3618a6", "patch": "@@ -92,17 +92,12 @@ fn type_of_explicit_args(cx: &@crate_ctxt, sp: &span, inputs: &ty::arg[]) ->\n    TypeRef[] {\n     let atys: TypeRef[] = ~[];\n     for arg: ty::arg  in inputs {\n-        if ty::type_has_dynamic_size(cx.tcx, arg.ty) {\n-            assert (arg.mode != ty::mo_val);\n-            atys += ~[T_typaram_ptr(cx.tn)];\n-        } else {\n-            let t: TypeRef;\n-            alt arg.mode {\n-              ty::mo_alias(_) { t = T_ptr(type_of_inner(cx, sp, arg.ty)); }\n-              _ { t = type_of_inner(cx, sp, arg.ty); }\n-            }\n-            atys += ~[t];\n-        }\n+        let t: TypeRef = type_of_inner(cx, sp, arg.ty);\n+        t = alt arg.mode {\n+          ty::mo_alias(_) { T_ptr(t) }\n+          _ { t }\n+        };\n+        atys += ~[t];\n     }\n     ret atys;\n }\n@@ -120,9 +115,7 @@ fn type_of_fn_full(cx: &@crate_ctxt, sp: &span, proto: ast::proto,\n     let atys: TypeRef[] = ~[];\n \n     // Arg 0: Output pointer.\n-    if ty::type_has_dynamic_size(cx.tcx, output) {\n-        atys += ~[T_typaram_ptr(cx.tn)];\n-    } else { atys += ~[T_ptr(type_of_inner(cx, sp, output))]; }\n+    atys += ~[T_ptr(type_of_inner(cx, sp, output))];\n \n     // Arg 1: task pointer.\n     atys += ~[T_taskptr(*cx)];\n@@ -252,7 +245,7 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n       ty::ty_var(_) {\n         cx.tcx.sess.span_fatal(sp, \"trans::type_of called on ty_var\");\n       }\n-      ty::ty_param(_, _) { llty = T_i8(); }\n+      ty::ty_param(_, _) { llty = T_typaram(cx.tn); }\n       ty::ty_type. { llty = T_ptr(cx.tydesc_type); }\n     }\n     assert (llty as int != 0);\n@@ -274,23 +267,6 @@ fn type_of_tag(cx: &@crate_ctxt, sp: &span, did: &ast::def_id, t: &ty::t) ->\n     }\n }\n \n-\n-fn type_of_arg(cx: @local_ctxt, sp: &span, arg: &ty::arg) -> TypeRef {\n-    alt ty::struct(cx.ccx.tcx, arg.ty) {\n-      ty::ty_param(_, _) {\n-        if arg.mode != ty::mo_val { ret T_typaram_ptr(cx.ccx.tn); }\n-      }\n-      _ {\n-        // fall through\n-      }\n-    }\n-    let typ;\n-    if arg.mode != ty::mo_val {\n-        typ = T_ptr(type_of_inner(cx.ccx, sp, arg.ty));\n-    } else { typ = type_of_inner(cx.ccx, sp, arg.ty); }\n-    ret typ;\n-}\n-\n fn type_of_ty_param_kinds_and_ty(lcx: @local_ctxt, sp: &span,\n                                  tpt: &ty::ty_param_kinds_and_ty) -> TypeRef {\n     alt ty::struct(lcx.ccx.tcx, tpt.ty) {\n@@ -4492,13 +4468,10 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n     let outgoing_args = ty::ty_fn_args(cx.ccx.tcx, outgoing_fty);\n \n     // The 'llretptr' that will arrive in the thunk we're creating also needs\n-    // to be the correct size.  Cast it to the size of f's return type, if\n-    // necessary.\n+    // to be the correct type.  Cast it to f's return type, if necessary.\n     let llretptr = fcx.llretptr;\n-    if ty::type_has_dynamic_size(cx.ccx.tcx, outgoing_ret_ty) {\n-        llretptr = bcx.build.PointerCast(llretptr, T_typaram_ptr(cx.ccx.tn));\n-    } else if ty::type_contains_params(cx.ccx.tcx, outgoing_ret_ty) {\n-        let llretty = type_of(cx.ccx, sp, outgoing_ret_ty);\n+    if ty::type_contains_params(cx.ccx.tcx, outgoing_ret_ty) {\n+        let llretty = type_of_inner(cx.ccx, sp, outgoing_ret_ty);\n         llretptr = bcx.build.PointerCast(llretptr, T_ptr(llretty));\n     }\n \n@@ -4765,27 +4738,20 @@ fn trans_args(cx: &@block_ctxt, llenv: ValueRef, llobj: &option::t[ValueRef],\n       }\n       _ { }\n     }\n-    if ty::type_has_dynamic_size(bcx_tcx(cx), retty) {\n-        llargs +=\n-            ~[bcx.build.PointerCast(llretslot,\n-                                    T_typaram_ptr(bcx_ccx(cx).tn))];\n-    } else if (ty::type_contains_params(bcx_tcx(cx), retty)) {\n+    if (ty::type_contains_params(bcx_tcx(cx), retty)) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n         // type deep in a structure -- which the caller has a concrete view\n         // of. If so, cast the caller's view of the restlot to the callee's\n         // view, for the sake of making a type-compatible call.\n-\n-        llargs +=\n-            ~[cx.build.PointerCast(llretslot,\n-                                   T_ptr(type_of(bcx_ccx(bcx), bcx.sp,\n-                                                 retty)))];\n+        let llretty = T_ptr(type_of_inner(bcx_ccx(bcx), bcx.sp, retty));\n+        llargs += ~[cx.build.PointerCast(llretslot, llretty)];\n     } else { llargs += ~[llretslot]; }\n-    // Arg 1: task pointer.\n \n+    // Arg 1: task pointer.\n     llargs += ~[bcx.fcx.lltaskptr];\n-    // Arg 2: Env (closure-bindings / self-obj)\n \n+    // Arg 2: Env (closure-bindings / self-obj)\n     alt llobj {\n       some(ob) {\n         // Every object is always found in memory,\n@@ -4796,18 +4762,18 @@ fn trans_args(cx: &@block_ctxt, llenv: ValueRef, llobj: &option::t[ValueRef],\n       }\n       _ { llargs += ~[llenv]; }\n     }\n-    // Args >3: ty_params ...\n \n+    // Args >3: ty_params ...\n     llargs += lltydescs;\n-    // ... then possibly an lliterbody argument.\n \n+    // ... then possibly an lliterbody argument.\n     alt lliterbody { none. { } some(lli) { llargs += ~[lli]; } }\n+\n     // ... then explicit args.\n \n     // First we figure out the caller's view of the types of the arguments.\n     // This will be needed if this is a generic call, because the callee has\n     // to cast her view of the arguments to the caller's view.\n-\n     let arg_tys = type_of_explicit_args(bcx_ccx(cx), cx.sp, args);\n     let i = 0u;\n     for e: @ast::expr  in es {\n@@ -6605,11 +6571,12 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     let llself_obj = bcx.build.Load(llself_obj_ptr);\n \n     // The 'llretptr' that will arrive in the forwarding function we're\n-    // creating also needs to be the correct size.  Cast it to the size of the\n-    // method's return type, if necessary.\n+    // creating also needs to be the correct type.  Cast it to the method's\n+    // return type, if necessary.\n     let llretptr = fcx.llretptr;\n-    if ty::type_has_dynamic_size(cx.ccx.tcx, m.output) {\n-        llretptr = bcx.build.PointerCast(llretptr, T_typaram_ptr(cx.ccx.tn));\n+    if ty::type_contains_params(cx.ccx.tcx, m.output) {\n+        let llretty = type_of_inner(cx.ccx, sp, m.output);\n+        llretptr = bcx.build.PointerCast(llretptr, T_ptr(llretty));\n     }\n \n     // Now, we have to get the the inner_obj's vtbl out of the self_obj.  This"}]}