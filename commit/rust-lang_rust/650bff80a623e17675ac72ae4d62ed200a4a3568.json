{"sha": "650bff80a623e17675ac72ae4d62ed200a4a3568", "node_id": "C_kwDOAAsO6NoAKDY1MGJmZjgwYTYyM2UxNzY3NWFjNzJhZTRkNjJlZDIwMGE0YTM1Njg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-21T16:40:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-21T16:40:26Z"}, "message": "Auto merge of #100645 - notriddle:notriddle/rustdoc-diet-plan, r=GuillaumeGomez\n\nrustdoc: strategic boxing to reduce the size of ItemKind and Type\n\nThe `Type` change redesigns `QPath` to box the entire data structure instead of boxing `self_type` and the `trait_`.\n\nThis reduces the size of several `ItemKind` variants, leaving `Impl` as the biggest variant. The `ItemKind` change boxes that variant's payload.", "tree": {"sha": "7730749cbfc569a1cdbfb1301fffab2678087063", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7730749cbfc569a1cdbfb1301fffab2678087063"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/650bff80a623e17675ac72ae4d62ed200a4a3568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/650bff80a623e17675ac72ae4d62ed200a4a3568", "html_url": "https://github.com/rust-lang/rust/commit/650bff80a623e17675ac72ae4d62ed200a4a3568", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/650bff80a623e17675ac72ae4d62ed200a4a3568/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31302033095dc75608675cd6f9b884d1692054f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/31302033095dc75608675cd6f9b884d1692054f0", "html_url": "https://github.com/rust-lang/rust/commit/31302033095dc75608675cd6f9b884d1692054f0"}, {"sha": "238bcc940fecd89f69a305b271d06bcd9bc2ed2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/238bcc940fecd89f69a305b271d06bcd9bc2ed2f", "html_url": "https://github.com/rust-lang/rust/commit/238bcc940fecd89f69a305b271d06bcd9bc2ed2f"}], "stats": {"total": 101, "additions": 54, "deletions": 47}, "files": [{"sha": "5441a7bd29ec00624512afd0681506dedc4a8e74", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=650bff80a623e17675ac72ae4d62ed200a4a3568", "patch": "@@ -551,13 +551,15 @@ where\n                 }\n                 WherePredicate::EqPredicate { lhs, rhs } => {\n                     match lhs {\n-                        Type::QPath { ref assoc, ref self_type, ref trait_, .. } => {\n+                        Type::QPath(box QPathData {\n+                            ref assoc, ref self_type, ref trait_, ..\n+                        }) => {\n                             let ty = &*self_type;\n                             let mut new_trait = trait_.clone();\n \n                             if self.is_fn_trait(trait_) && assoc.name == sym::Output {\n                                 ty_to_fn\n-                                    .entry(*ty.clone())\n+                                    .entry(ty.clone())\n                                     .and_modify(|e| {\n                                         *e = (e.0.clone(), Some(rhs.ty().unwrap().clone()))\n                                     })\n@@ -582,7 +584,7 @@ where\n                                 // to 'T: Iterator<Item=u8>'\n                                 GenericArgs::AngleBracketed { ref mut bindings, .. } => {\n                                     bindings.push(TypeBinding {\n-                                        assoc: *assoc.clone(),\n+                                        assoc: assoc.clone(),\n                                         kind: TypeBindingKind::Equality { term: rhs },\n                                     });\n                                 }\n@@ -596,7 +598,7 @@ where\n                                 }\n                             }\n \n-                            let bounds = ty_to_bounds.entry(*ty.clone()).or_default();\n+                            let bounds = ty_to_bounds.entry(ty.clone()).or_default();\n \n                             bounds.insert(GenericBound::TraitBound(\n                                 PolyTrait { trait_: new_trait, generic_params: Vec::new() },\n@@ -613,7 +615,7 @@ where\n                             ));\n                             // Avoid creating any new duplicate bounds later in the outer\n                             // loop\n-                            ty_to_traits.entry(*ty.clone()).or_default().insert(trait_.clone());\n+                            ty_to_traits.entry(ty.clone()).or_default().insert(trait_.clone());\n                         }\n                         _ => panic!(\"Unexpected LHS {:?} for {:?}\", lhs, item_def_id),\n                     }"}, {"sha": "a7048e788b65abb5aa9e939167439208c077cf1a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=650bff80a623e17675ac72ae4d62ed200a4a3568", "patch": "@@ -62,7 +62,7 @@ pub(crate) fn try_inline(\n         Res::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, ItemType::Trait);\n             build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n-            clean::TraitItem(build_external_trait(cx, did))\n+            clean::TraitItem(Box::new(build_external_trait(cx, did)))\n         }\n         Res::Def(DefKind::Fn, did) => {\n             record_extern_fqn(cx, did, ItemType::Function);\n@@ -672,7 +672,7 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n \n     g.where_predicates.retain(|pred| match pred {\n         clean::WherePredicate::BoundPredicate {\n-            ty: clean::QPath { self_type: box clean::Generic(ref s), trait_, .. },\n+            ty: clean::QPath(box clean::QPathData { self_type: clean::Generic(ref s), trait_, .. }),\n             bounds,\n             ..\n         } => !(bounds.is_empty() || *s == kw::SelfUpper && trait_.def_id() == trait_did),"}, {"sha": "5507ffb871b6ea25818b11098fb0648867aeb313", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=650bff80a623e17675ac72ae4d62ed200a4a3568", "patch": "@@ -410,12 +410,12 @@ fn clean_projection<'tcx>(\n         self_type.def_id(&cx.cache)\n     };\n     let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n-    Type::QPath {\n-        assoc: Box::new(projection_to_path_segment(ty, cx)),\n+    Type::QPath(Box::new(QPathData {\n+        assoc: projection_to_path_segment(ty, cx),\n         should_show_cast,\n-        self_type: Box::new(self_type),\n+        self_type,\n         trait_,\n-    }\n+    }))\n }\n \n fn compute_should_show_cast(self_def_id: Option<DefId>, trait_: &Path, self_type: &Type) -> bool {\n@@ -1182,7 +1182,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                     .where_predicates\n                     .drain_filter(|pred| match *pred {\n                         WherePredicate::BoundPredicate {\n-                            ty: QPath { ref assoc, ref self_type, ref trait_, .. },\n+                            ty: QPath(box QPathData { ref assoc, ref self_type, ref trait_, .. }),\n                             ..\n                         } => {\n                             if assoc.name != my_name {\n@@ -1191,7 +1191,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                             if trait_.def_id() != assoc_item.container_id(tcx) {\n                                 return false;\n                             }\n-                            match **self_type {\n+                            match *self_type {\n                                 Generic(ref s) if *s == kw::SelfUpper => {}\n                                 _ => return false,\n                             }\n@@ -1324,15 +1324,12 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             let self_def_id = DefId::local(qself.hir_id.owner.local_def_index);\n             let self_type = clean_ty(qself, cx);\n             let should_show_cast = compute_should_show_cast(Some(self_def_id), &trait_, &self_type);\n-            Type::QPath {\n-                assoc: Box::new(clean_path_segment(\n-                    p.segments.last().expect(\"segments were empty\"),\n-                    cx,\n-                )),\n+            Type::QPath(Box::new(QPathData {\n+                assoc: clean_path_segment(p.segments.last().expect(\"segments were empty\"), cx),\n                 should_show_cast,\n-                self_type: Box::new(self_type),\n+                self_type,\n                 trait_,\n-            }\n+            }))\n         }\n         hir::QPath::TypeRelative(qself, segment) => {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n@@ -1347,12 +1344,12 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             let self_def_id = res.opt_def_id();\n             let self_type = clean_ty(qself, cx);\n             let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n-            Type::QPath {\n-                assoc: Box::new(clean_path_segment(segment, cx)),\n+            Type::QPath(Box::new(QPathData {\n+                assoc: clean_path_segment(segment, cx),\n                 should_show_cast,\n-                self_type: Box::new(self_type),\n+                self_type,\n                 trait_,\n-            }\n+            }))\n         }\n         hir::QPath::LangItem(..) => bug!(\"clean: requiring documentation of lang item\"),\n     }\n@@ -1954,12 +1951,12 @@ fn clean_maybe_renamed_item<'tcx>(\n                     .map(|ti| clean_trait_item(cx.tcx.hir().trait_item(ti.id), cx))\n                     .collect();\n \n-                TraitItem(Trait {\n+                TraitItem(Box::new(Trait {\n                     def_id,\n                     items,\n                     generics: clean_generics(generics, cx),\n                     bounds: bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n-                })\n+                }))\n             }\n             ItemKind::ExternCrate(orig_name) => {\n                 return clean_extern_crate(item, name, orig_name, cx);"}, {"sha": "51976a91cea9ca4efba0713a086bae2090684abd", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=650bff80a623e17675ac72ae4d62ed200a4a3568", "patch": "@@ -727,7 +727,7 @@ pub(crate) enum ItemKind {\n     OpaqueTyItem(OpaqueTy),\n     StaticItem(Static),\n     ConstantItem(Constant),\n-    TraitItem(Trait),\n+    TraitItem(Box<Trait>),\n     TraitAliasItem(TraitAlias),\n     ImplItem(Box<Impl>),\n     /// A required method in a trait declaration meaning it's only a function signature.\n@@ -1550,13 +1550,7 @@ pub(crate) enum Type {\n     BorrowedRef { lifetime: Option<Lifetime>, mutability: Mutability, type_: Box<Type> },\n \n     /// A qualified path to an associated item: `<Type as Trait>::Name`\n-    QPath {\n-        assoc: Box<PathSegment>,\n-        self_type: Box<Type>,\n-        /// FIXME: compute this field on demand.\n-        should_show_cast: bool,\n-        trait_: Path,\n-    },\n+    QPath(Box<QPathData>),\n \n     /// A type that is inferred: `_`\n     Infer,\n@@ -1654,8 +1648,8 @@ impl Type {\n     }\n \n     pub(crate) fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n-        if let QPath { self_type, trait_, assoc, .. } = self {\n-            Some((self_type, trait_.def_id(), *assoc.clone()))\n+        if let QPath(box QPathData { self_type, trait_, assoc, .. }) = self {\n+            Some((self_type, trait_.def_id(), assoc.clone()))\n         } else {\n             None\n         }\n@@ -1679,7 +1673,7 @@ impl Type {\n             Slice(..) => PrimitiveType::Slice,\n             Array(..) => PrimitiveType::Array,\n             RawPointer(..) => PrimitiveType::RawPointer,\n-            QPath { ref self_type, .. } => return self_type.inner_def_id(cache),\n+            QPath(box QPathData { ref self_type, .. }) => return self_type.inner_def_id(cache),\n             Generic(_) | Infer | ImplTrait(_) => return None,\n         };\n         cache.and_then(|c| Primitive(t).def_id(c))\n@@ -1693,6 +1687,15 @@ impl Type {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub(crate) struct QPathData {\n+    pub assoc: PathSegment,\n+    pub self_type: Type,\n+    /// FIXME: compute this field on demand.\n+    pub should_show_cast: bool,\n+    pub trait_: Path,\n+}\n+\n /// A primitive (aka, builtin) type.\n ///\n /// This represents things like `i32`, `str`, etc.\n@@ -2484,11 +2487,11 @@ mod size_asserts {\n     // These are in alphabetical order, which is easy to maintain.\n     static_assert_size!(Crate, 72); // frequently moved by-value\n     static_assert_size!(DocFragment, 32);\n-    static_assert_size!(GenericArg, 80);\n+    static_assert_size!(GenericArg, 64);\n     static_assert_size!(GenericArgs, 32);\n     static_assert_size!(GenericParamDef, 56);\n     static_assert_size!(Item, 56);\n-    static_assert_size!(ItemKind, 112);\n+    static_assert_size!(ItemKind, 96);\n     static_assert_size!(PathSegment, 40);\n-    static_assert_size!(Type, 72);\n+    static_assert_size!(Type, 56);\n }"}, {"sha": "86392610d2c28cb36fbb0608d1fd325443791f20", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=650bff80a623e17675ac72ae4d62ed200a4a3568", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         if let clean::TraitItem(ref t) = *item.kind {\n             self.cache.traits.entry(item.item_id.expect_def_id()).or_insert_with(|| {\n                 clean::TraitWithExtraInfo {\n-                    trait_: t.clone(),\n+                    trait_: *t.clone(),\n                     is_notable: item.attrs.has_doc_flag(sym::notable_trait),\n                 }\n             });"}, {"sha": "b023792e95a58e4292478c2db0eab95a010eec27", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=650bff80a623e17675ac72ae4d62ed200a4a3568", "patch": "@@ -1079,7 +1079,12 @@ fn fmt_type<'cx>(\n                 write!(f, \"impl {}\", print_generic_bounds(bounds, cx))\n             }\n         }\n-        clean::QPath { ref assoc, ref self_type, ref trait_, should_show_cast } => {\n+        clean::QPath(box clean::QPathData {\n+            ref assoc,\n+            ref self_type,\n+            ref trait_,\n+            should_show_cast,\n+        }) => {\n             if f.alternate() {\n                 if should_show_cast {\n                     write!(f, \"<{:#} as {:#}>::\", self_type.print(cx), trait_.print(cx))?"}, {"sha": "f9d6b4619cc77999e44c7151aa410464cf6ff2c3", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=650bff80a623e17675ac72ae4d62ed200a4a3568", "patch": "@@ -2632,8 +2632,8 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n             clean::Type::BorrowedRef { type_, .. } => {\n                 work.push_back(*type_);\n             }\n-            clean::Type::QPath { self_type, trait_, .. } => {\n-                work.push_back(*self_type);\n+            clean::Type::QPath(box clean::QPathData { self_type, trait_, .. }) => {\n+                work.push_back(self_type);\n                 process_path(trait_.def_id());\n             }\n             _ => {}"}, {"sha": "c4e8b6f5f8449d103513ac647a2ba0aae06883df", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/650bff80a623e17675ac72ae4d62ed200a4a3568/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=650bff80a623e17675ac72ae4d62ed200a4a3568", "patch": "@@ -248,7 +248,7 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n         VariantItem(v) => ItemEnum::Variant(v.into_tcx(tcx)),\n         FunctionItem(f) => ItemEnum::Function(from_function(f, header.unwrap(), tcx)),\n         ForeignFunctionItem(f) => ItemEnum::Function(from_function(f, header.unwrap(), tcx)),\n-        TraitItem(t) => ItemEnum::Trait(t.into_tcx(tcx)),\n+        TraitItem(t) => ItemEnum::Trait((*t).into_tcx(tcx)),\n         TraitAliasItem(t) => ItemEnum::TraitAlias(t.into_tcx(tcx)),\n         MethodItem(m, _) => ItemEnum::Method(from_function_method(m, true, header.unwrap(), tcx)),\n         TyMethodItem(m) => ItemEnum::Method(from_function_method(m, false, header.unwrap(), tcx)),\n@@ -480,10 +480,10 @@ impl FromWithTcx<clean::Type> for Type {\n                 mutable: mutability == ast::Mutability::Mut,\n                 type_: Box::new((*type_).into_tcx(tcx)),\n             },\n-            QPath { assoc, self_type, trait_, .. } => Type::QualifiedPath {\n+            QPath(box clean::QPathData { assoc, self_type, trait_, .. }) => Type::QualifiedPath {\n                 name: assoc.name.to_string(),\n                 args: Box::new(assoc.args.clone().into_tcx(tcx)),\n-                self_type: Box::new((*self_type).into_tcx(tcx)),\n+                self_type: Box::new(self_type.into_tcx(tcx)),\n                 trait_: trait_.into_tcx(tcx),\n             },\n         }"}]}