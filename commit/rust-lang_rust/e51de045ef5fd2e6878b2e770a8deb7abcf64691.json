{"sha": "e51de045ef5fd2e6878b2e770a8deb7abcf64691", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MWRlMDQ1ZWY1ZmQyZTY4NzhiMmU3NzBhOGRlYjdhYmNmNjQ2OTE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-13T22:52:20Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-14T05:34:43Z"}, "message": "Rollup merge of #30851 - jonas-schievink:unneeded-dropflags, r=pnkfelix\n\nApparently we allocate and maintain non-working dropflag hints since June... In anticipation of a working implementation of on-stack drop flag hints, let's not spend even more time on types that don't even need to be dropped.\n\n```rust\nfn main() {\n    let (i,j,k,l) = (0,0,0,0);\n}\n```\nused to translate to (unoptimized only, of course):\n```llvm\ndefine internal void @_ZN4main20ha8deb085c47920d8eaaE() unnamed_addr #0 {\nentry-block:\n  %dropflag_hint_10 = alloca i8\n  %dropflag_hint_11 = alloca i8\n  %dropflag_hint_12 = alloca i8\n  %dropflag_hint_13 = alloca i8\n  %const = alloca { i32, i32, i32, i32 }\n  %i = alloca i32\n  %j = alloca i32\n  %k = alloca i32\n  %l = alloca i32\n  store i8 61, i8* %dropflag_hint_10\n  store i8 61, i8* %dropflag_hint_11\n  store i8 61, i8* %dropflag_hint_12\n  store i8 61, i8* %dropflag_hint_13\n  %0 = bitcast { i32, i32, i32, i32 }* %const to i8*\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast ({ i32, i32, i32, i32 }* @const2752 to i8*), i64 16, i32 4, i1 false)\n  %1 = getelementptr inbounds { i32, i32, i32, i32 }, { i32, i32, i32, i32 }* %const, i32 0, i32 0\n  %2 = load i32, i32* %1, align 4\n  store i32 %2, i32* %i, align 4\n  %3 = getelementptr inbounds { i32, i32, i32, i32 }, { i32, i32, i32, i32 }* %const, i32 0, i32 1\n  %4 = load i32, i32* %3, align 4\n  store i32 %4, i32* %j, align 4\n  %5 = getelementptr inbounds { i32, i32, i32, i32 }, { i32, i32, i32, i32 }* %const, i32 0, i32 2\n  %6 = load i32, i32* %5, align 4\n  store i32 %6, i32* %k, align 4\n  %7 = getelementptr inbounds { i32, i32, i32, i32 }, { i32, i32, i32, i32 }* %const, i32 0, i32 3\n  %8 = load i32, i32* %7, align 4\n  store i32 %8, i32* %l, align 4\n  ret void\n}\n```\n\nNow it gives:\n```llvm\ndefine internal void @_ZN4main20ha8deb085c47920d8eaaE() unnamed_addr #0 {\nentry-block:\n  %const = alloca { i32, i32, i32, i32 }\n  %i = alloca i32\n  %j = alloca i32\n  %k = alloca i32\n  %l = alloca i32\n  %0 = bitcast { i32, i32, i32, i32 }* %const to i8*\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast ({ i32, i32, i32, i32 }* @const2748 to i8*), i64 16, i32 4, i1 false)\n  %1 = getelementptr inbounds { i32, i32, i32, i32 }, { i32, i32, i32, i32 }* %const, i32 0, i32 0\n  %2 = load i32, i32* %1, align 4\n  store i32 %2, i32* %i, align 4\n  %3 = getelementptr inbounds { i32, i32, i32, i32 }, { i32, i32, i32, i32 }* %const, i32 0, i32 1\n  %4 = load i32, i32* %3, align 4\n  store i32 %4, i32* %j, align 4\n  %5 = getelementptr inbounds { i32, i32, i32, i32 }, { i32, i32, i32, i32 }* %const, i32 0, i32 2\n  %6 = load i32, i32* %5, align 4\n  store i32 %6, i32* %k, align 4\n  %7 = getelementptr inbounds { i32, i32, i32, i32 }, { i32, i32, i32, i32 }* %const, i32 0, i32 3\n  %8 = load i32, i32* %7, align 4\n  store i32 %8, i32* %l, align 4\n  ret void\n}\n```\n\nLet's hope I didn't break anything!", "tree": {"sha": "4bedd2756923c3ab4165ace8d5051210cfeef694", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bedd2756923c3ab4165ace8d5051210cfeef694"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e51de045ef5fd2e6878b2e770a8deb7abcf64691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e51de045ef5fd2e6878b2e770a8deb7abcf64691", "html_url": "https://github.com/rust-lang/rust/commit/e51de045ef5fd2e6878b2e770a8deb7abcf64691", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e51de045ef5fd2e6878b2e770a8deb7abcf64691/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ceaa2f77a2d217fd05fa2029c2724564cf43a09", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ceaa2f77a2d217fd05fa2029c2724564cf43a09", "html_url": "https://github.com/rust-lang/rust/commit/6ceaa2f77a2d217fd05fa2029c2724564cf43a09"}, {"sha": "e3abc3cfe746c0ab078f33bc4566f6fb9773f489", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3abc3cfe746c0ab078f33bc4566f6fb9773f489", "html_url": "https://github.com/rust-lang/rust/commit/e3abc3cfe746c0ab078f33bc4566f6fb9773f489"}], "stats": {"total": 21, "additions": 16, "deletions": 5}, "files": [{"sha": "f8b5f8e48f49930e92c303d91771ff3940212b4b", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e51de045ef5fd2e6878b2e770a8deb7abcf64691/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51de045ef5fd2e6878b2e770a8deb7abcf64691/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e51de045ef5fd2e6878b2e770a8deb7abcf64691", "patch": "@@ -1649,6 +1649,7 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n     // Create the drop-flag hints for every unfragmented path in the function.\n     let tcx = fcx.ccx.tcx();\n     let fn_did = tcx.map.local_def_id(fcx.id);\n+    let tables = tcx.tables.borrow();\n     let mut hints = fcx.lldropflag_hints.borrow_mut();\n     let fragment_infos = tcx.fragment_infos.borrow();\n \n@@ -1672,12 +1673,22 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n             let (var, datum) = match info {\n                 ty::FragmentInfo::Moved { var, .. } |\n                 ty::FragmentInfo::Assigned { var, .. } => {\n-                    let datum = seen.get(&var).cloned().unwrap_or_else(|| {\n-                        let datum = make_datum(var);\n-                        seen.insert(var, datum.clone());\n-                        datum\n+                    let opt_datum = seen.get(&var).cloned().unwrap_or_else(|| {\n+                        let ty = tables.node_types[&var];\n+                        if fcx.type_needs_drop(ty) {\n+                            let datum = make_datum(var);\n+                            seen.insert(var, Some(datum.clone()));\n+                            Some(datum)\n+                        } else {\n+                            // No drop call needed, so we don't need a dropflag hint\n+                            None\n+                        }\n                     });\n-                    (var, datum)\n+                    if let Some(datum) = opt_datum {\n+                        (var, datum)\n+                    } else {\n+                        continue\n+                    }\n                 }\n             };\n             match info {"}]}