{"sha": "8dd46d4384faa257f940e3f3d51f70f6655b3b4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkZDQ2ZDQzODRmYWEyNTdmOTQwZTNmM2Q1MWY3MGY2NjU1YjNiNGI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T11:13:20Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T11:13:20Z"}, "message": "Properly implement copy expressions\n\n(And use them in some places that were doing {expr} before.)", "tree": {"sha": "a77b945c322d2f7815ce8826a6fe3e64fb86eea9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a77b945c322d2f7815ce8826a6fe3e64fb86eea9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dd46d4384faa257f940e3f3d51f70f6655b3b4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dd46d4384faa257f940e3f3d51f70f6655b3b4b", "html_url": "https://github.com/rust-lang/rust/commit/8dd46d4384faa257f940e3f3d51f70f6655b3b4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dd46d4384faa257f940e3f3d51f70f6655b3b4b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4b6264f8c43a8964ee7596c25e5d09819028b24", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4b6264f8c43a8964ee7596c25e5d09819028b24", "html_url": "https://github.com/rust-lang/rust/commit/f4b6264f8c43a8964ee7596c25e5d09819028b24"}], "stats": {"total": 62, "additions": 42, "deletions": 20}, "files": [{"sha": "7ccb3fc47020fb150192a0704c142dd47d2d2116", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8dd46d4384faa257f940e3f3d51f70f6655b3b4b/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd46d4384faa257f940e3f3d51f70f6655b3b4b/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=8dd46d4384faa257f940e3f3d51f70f6655b3b4b", "patch": "@@ -53,7 +53,7 @@ fn collect_freevars(def_map: resolve::def_map, walker: fn(visit::vt<int>)) ->\n               ast::expr_path(path) {\n                 let def = def_map.get(expr.id), i = 0;\n                 while i < depth {\n-                    alt { def } {\n+                    alt copy def {\n                       ast::def_upvar(_, inner, _) { def = *inner; }\n                       _ { break; }\n                     }"}, {"sha": "b6a866537022252b371d7da77b5f591a7e0e4e5d", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8dd46d4384faa257f940e3f3d51f70f6655b3b4b/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd46d4384faa257f940e3f3d51f70f6655b3b4b/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=8dd46d4384faa257f940e3f3d51f70f6655b3b4b", "patch": "@@ -45,7 +45,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n     }\n     let ds: [deref] = [];\n     while true {\n-        alt { ex.node } {\n+        alt copy ex.node {\n           expr_field(base, ident) {\n             let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n             let mut = false;"}, {"sha": "a768253eabfc17d770587ae267f8436235bcdc8c", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8dd46d4384faa257f940e3f3d51f70f6655b3b4b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd46d4384faa257f940e3f3d51f70f6655b3b4b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=8dd46d4384faa257f940e3f3d51f70f6655b3b4b", "patch": "@@ -707,7 +707,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n     // Used to determine whether obj fields are in scope\n     let left_fn_level2 = false;\n     while true {\n-        alt { sc } {\n+        alt copy sc {\n           nil. { ret none::<def>; }\n           cons(hd, tl) {\n             let fnd = in_scope(e, sp, name, hd, ns);"}, {"sha": "e3062bf8aa2524000c0b9d5fd24e12adc5e42256", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8dd46d4384faa257f940e3f3d51f70f6655b3b4b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd46d4384faa257f940e3f3d51f70f6655b3b4b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8dd46d4384faa257f940e3f3d51f70f6655b3b4b", "patch": "@@ -1234,22 +1234,22 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n         let cmp_fn_ty = T_ptr(T_cmp_glue_fn(*ccx));\n         let ti = pair.val;\n         let take_glue =\n-            alt { ti.take_glue } {\n+            alt copy ti.take_glue {\n               none. { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n         let drop_glue =\n-            alt { ti.drop_glue } {\n+            alt copy ti.drop_glue {\n               none. { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n         let free_glue =\n-            alt { ti.free_glue } {\n+            alt copy ti.free_glue {\n               none. { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n         let cmp_glue =\n-            alt { ti.cmp_glue } {\n+            alt copy ti.cmp_glue {\n               none. { ccx.stats.n_null_glues += 1u; C_null(cmp_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n@@ -1742,7 +1742,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n       none. { }\n       some(ti) {\n         if field == abi::tydesc_field_take_glue {\n-            alt { ti.take_glue } {\n+            alt copy ti.take_glue {\n               some(_) { }\n               none. {\n                 log #fmt[\"+++ lazily_emit_tydesc_glue TAKE %s\",\n@@ -1760,7 +1760,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n               }\n             }\n         } else if field == abi::tydesc_field_drop_glue {\n-            alt { ti.drop_glue } {\n+            alt copy ti.drop_glue {\n               some(_) { }\n               none. {\n                 log #fmt[\"+++ lazily_emit_tydesc_glue DROP %s\",\n@@ -1778,7 +1778,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n               }\n             }\n         } else if field == abi::tydesc_field_free_glue {\n-            alt { ti.free_glue } {\n+            alt copy ti.free_glue {\n               some(_) { }\n               none. {\n                 log #fmt[\"+++ lazily_emit_tydesc_glue FREE %s\",\n@@ -1796,7 +1796,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n               }\n             }\n         } else if field == abi::tydesc_field_cmp_glue {\n-            alt { ti.cmp_glue } {\n+            alt copy ti.cmp_glue {\n               some(_) { }\n               none. {\n                 log #fmt[\"+++ lazily_emit_tydesc_glue CMP %s\",\n@@ -3110,7 +3110,7 @@ fn trans_lval_gen(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n       }\n       ast::expr_uniq(contents) { ret trans_uniq(cx, contents); }\n       ast::expr_self_method(ident) {\n-        alt { cx.fcx.llself } {\n+        alt copy cx.fcx.llself {\n           some(pair) {\n             let r = pair.v;\n             let t = pair.t;\n@@ -3879,8 +3879,19 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n         ret rslt(next_cx, sub.val);\n       }\n       ast::expr_copy(a) {\n-        // FIXME: this has more-subtle semantics than just \"fall through\".\n-        ret trans_expr_out(cx, a, output);\n+        let e_ty = ty::expr_ty(bcx_tcx(cx), a);\n+        let lv = trans_lval(cx, a);\n+        let bcx = lv.res.bcx;\n+        if !lv.is_mem { ret lv.res; }\n+        let r = if type_is_immediate(bcx_ccx(cx), e_ty) {\n+            rslt(bcx, Load(bcx, lv.res.val))\n+        } else {\n+            let {bcx, val: dest} = alloc_ty(bcx, e_ty);\n+            bcx = copy_val(bcx, INIT, dest, lv.res.val, e_ty);\n+            rslt(bcx, dest)\n+        };\n+        add_clean_temp(bcx, r.val, e_ty);\n+        ret r;\n       }\n       ast::expr_move(dst, src) {\n         let lhs_res = trans_lval(cx, dst);\n@@ -4210,7 +4221,7 @@ fn trans_put(in_cx: @block_ctxt, e: option::t<@ast::expr>) -> result {\n     Br(in_cx, cx.llbb);\n     let llcallee = C_nil();\n     let llenv = C_nil();\n-    alt { cx.fcx.lliterbody } {\n+    alt copy cx.fcx.lliterbody {\n       some(lli) {\n         let slot = alloca(cx, val_ty(lli));\n         Store(cx, lli, slot);\n@@ -4269,7 +4280,7 @@ fn trans_break_cont(sp: span, cx: @block_ctxt, to_end: bool) -> result {\n     let cleanup_cx = cx;\n     while true {\n         bcx = trans_block_cleanups(bcx, cleanup_cx);\n-        alt { cleanup_cx.kind } {\n+        alt copy cleanup_cx.kind {\n           LOOP_SCOPE_BLOCK(_cont, _break) {\n             if to_end {\n                 Br(bcx, _break.llbb);\n@@ -4283,7 +4294,7 @@ fn trans_break_cont(sp: span, cx: @block_ctxt, to_end: bool) -> result {\n                      C_nil());\n           }\n           _ {\n-            alt { cleanup_cx.parent } {\n+            alt copy cleanup_cx.parent {\n               parent_some(cx) { cleanup_cx = cx; }\n               parent_none. {\n                 bcx_ccx(cx).sess.span_fatal(sp,\n@@ -4341,7 +4352,7 @@ fn trans_ret(cx: @block_ctxt, e: option::t<@ast::expr>) -> result {\n     let cleanup_cx = cx;\n     while more_cleanups {\n         bcx = trans_block_cleanups(bcx, cleanup_cx);\n-        alt { cleanup_cx.parent } {\n+        alt copy cleanup_cx.parent {\n           parent_some(b) { cleanup_cx = b; }\n           parent_none. { more_cleanups = false; }\n         }\n@@ -4960,7 +4971,7 @@ fn trans_closure(bcx_maybe: option::t<@block_ctxt>,\n     create_llargs_for_fn_args(fcx, f.proto, ty_self,\n                               ty::ret_ty_of_fn(cx.ccx.tcx, id), f.decl.inputs,\n                               ty_params);\n-    alt { fcx.llself } {\n+    alt copy fcx.llself {\n       some(llself) { populate_fn_ctxt_from_llself(fcx, llself); }\n       _ { }\n     }"}, {"sha": "f0b214695287724bb260b00f538fa169e11c9811", "filename": "src/test/run-pass/expr-copy.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8dd46d4384faa257f940e3f3d51f70f6655b3b4b/src%2Ftest%2Frun-pass%2Fexpr-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd46d4384faa257f940e3f3d51f70f6655b3b4b/src%2Ftest%2Frun-pass%2Fexpr-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-copy.rs?ref=8dd46d4384faa257f940e3f3d51f70f6655b3b4b", "patch": "@@ -1 +1,12 @@\n-fn main() { let x = 10; let y = copy x; log y; }\n+fn f(arg: {mutable a: int}) {\n+    arg.a = 100;\n+}\n+\n+fn main() {\n+    let x = {mutable a: 10};\n+    f(x);\n+    assert x.a == 100;\n+    x.a = 20;\n+    f(copy x);\n+    assert x.a == 20;\n+}"}]}