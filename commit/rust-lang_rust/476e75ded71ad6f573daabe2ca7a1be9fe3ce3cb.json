{"sha": "476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NmU3NWRlZDcxYWQ2ZjU3M2RhYWJlMmNhN2ExYmU5ZmUzY2UzY2I=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-17T02:08:24Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-17T05:32:29Z"}, "message": "Move a `Node`'s parent into the descendents list.\n\n`Node` has an optional parent and a list of other descendents. Most of\nthe time the parent is treated the same as the other descendents --\nerror-handling is the exception -- and chaining them together for\niteration has a non-trivial cost.\n\nThis commit changes the representation. There is now a single list of\ndescendants, and a boolean flag that indicates if there is a parent (in\nwhich case it is first descendent). This representation encodes the same\ninformation, in a way that is less idiomatic but cheaper to iterate over\nfor the common case where the parent doesn't need special treatment.\n\nAs a result, some benchmark workloads are up to 2% faster.", "tree": {"sha": "94837a6293297f33ef727e4bd263bc4407504aca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94837a6293297f33ef727e4bd263bc4407504aca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb", "html_url": "https://github.com/rust-lang/rust/commit/476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5670d048c0f88af9976b5505c7853b23dd06770d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5670d048c0f88af9976b5505c7853b23dd06770d", "html_url": "https://github.com/rust-lang/rust/commit/5670d048c0f88af9976b5505c7853b23dd06770d"}], "stats": {"total": 79, "additions": 36, "deletions": 43}, "files": [{"sha": "fe0a3cb0500c59858576ae0ac75a601d0ff48868", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb", "patch": "@@ -74,9 +74,7 @@ impl<'a, O: ForestObligation + 'a> dot::GraphWalk<'a> for &'a ObligationForest<O\n             .flat_map(|i| {\n                 let node = &self.nodes[i];\n \n-                node.parent.iter()\n-                    .chain(node.dependents.iter())\n-                    .map(move |p| (p.index(), i))\n+                node.dependents.iter().map(move |p| (p.index(), i))\n             })\n             .collect()\n     }"}, {"sha": "0ae4a04eb50f502476e991f3cb06a46b41d30b45", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb", "patch": "@@ -177,21 +177,17 @@ struct Node<O> {\n     obligation: O,\n     state: Cell<NodeState>,\n \n-    /// The parent of a node - the original obligation of which it is a\n-    /// subobligation. Except for error reporting, it is just like any member\n-    /// of `dependents`.\n-    ///\n-    /// Unlike `ObligationForest::nodes`, this uses `NodeIndex` rather than\n-    /// `usize` for the index, because keeping the size down is more important\n-    /// than the cost of converting to a `usize` for indexing.\n-    parent: Option<NodeIndex>,\n-\n     /// Obligations that depend on this obligation for their completion. They\n     /// must all be in a non-pending state.\n-    ///\n-    /// This uses `NodeIndex` for the same reason as `parent`.\n     dependents: Vec<NodeIndex>,\n \n+    /// If true, dependents[0] points to a \"parent\" node, which requires\n+    /// special treatment upon error but is otherwise treated the same.\n+    /// (It would be more idiomatic to store the parent node in a separate\n+    /// `Option<NodeIndex>` field, but that slows down the common case of\n+    /// iterating over the parent and other descendants together.)\n+    has_parent: bool,\n+\n     /// Identifier of the obligation tree to which this node belongs.\n     obligation_tree_id: ObligationTreeId,\n }\n@@ -205,8 +201,13 @@ impl<O> Node<O> {\n         Node {\n             obligation,\n             state: Cell::new(NodeState::Pending),\n-            parent,\n-            dependents: vec![],\n+            dependents:\n+                if let Some(parent_index) = parent {\n+                    vec![parent_index]\n+                } else {\n+                    vec![]\n+                },\n+            has_parent: parent.is_some(),\n             obligation_tree_id,\n         }\n     }\n@@ -315,13 +316,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n                        obligation, parent, o.get());\n                 let node = &mut self.nodes[o.get().index()];\n                 if let Some(parent_index) = parent {\n-                    // If the node is already in `waiting_cache`, it's already\n-                    // been marked with a parent. (It's possible that parent\n-                    // has been cleared by `apply_rewrites`, though.) So just\n-                    // dump `parent` into `node.dependents`... unless it's\n-                    // already in `node.dependents` or `node.parent`.\n-                    if !node.dependents.contains(&parent_index) &&\n-                       Some(parent_index) != node.parent {\n+                    // If the node is already in `waiting_cache`, it has\n+                    // already had its chance to be marked with a parent. So if\n+                    // it's not already present, just dump `parent` into the\n+                    // dependents as a non-parent.\n+                    if !node.dependents.contains(&parent_index) {\n                         node.dependents.push(parent_index);\n                     }\n                 }\n@@ -523,7 +522,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             NodeState::Success => {\n                 node.state.set(NodeState::OnDfsStack);\n                 stack.push(i);\n-                for index in node.parent.iter().chain(node.dependents.iter()) {\n+                for index in node.dependents.iter() {\n                     self.find_cycles_from_node(stack, processor, index.index());\n                 }\n                 stack.pop();\n@@ -549,12 +548,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n             let node = &self.nodes[i];\n             node.state.set(NodeState::Error);\n             trace.push(node.obligation.clone());\n-            error_stack.extend(node.dependents.iter().map(|index| index.index()));\n-\n-            // Loop to the parent.\n-            match node.parent {\n-                Some(parent_index) => i = parent_index.index(),\n-                None => break\n+            if node.has_parent {\n+                // The first dependent is the parent, which is treated\n+                // specially.\n+                error_stack.extend(node.dependents.iter().skip(1).map(|index| index.index()));\n+                i = node.dependents[0].index();\n+            } else {\n+                // No parent; treat all dependents non-specially.\n+                error_stack.extend(node.dependents.iter().map(|index| index.index()));\n+                break;\n             }\n         }\n \n@@ -565,9 +567,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 _ => node.state.set(NodeState::Error),\n             }\n \n-            error_stack.extend(\n-                node.parent.iter().chain(node.dependents.iter()).map(|index| index.index())\n-            );\n+            error_stack.extend(node.dependents.iter().map(|index| index.index()));\n         }\n \n         self.scratch.replace(error_stack);\n@@ -577,7 +577,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n     fn inlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n-        for dependent in node.parent.iter().chain(node.dependents.iter()) {\n+        for dependent in node.dependents.iter() {\n             self.mark_as_waiting_from(&self.nodes[dependent.index()]);\n         }\n     }\n@@ -706,20 +706,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let nodes_len = node_rewrites.len();\n \n         for node in &mut self.nodes {\n-            if let Some(index) = node.parent {\n-                let new_i = node_rewrites[index.index()];\n-                if new_i >= nodes_len {\n-                    node.parent = None;\n-                } else {\n-                    node.parent = Some(NodeIndex::new(new_i));\n-                }\n-            }\n-\n             let mut i = 0;\n             while i < node.dependents.len() {\n                 let new_i = node_rewrites[node.dependents[i].index()];\n                 if new_i >= nodes_len {\n                     node.dependents.swap_remove(i);\n+                    if i == 0 && node.has_parent {\n+                        // We just removed the parent.\n+                        node.has_parent = false;\n+                    }\n                 } else {\n                     node.dependents[i] = NodeIndex::new(new_i);\n                     i += 1;"}]}