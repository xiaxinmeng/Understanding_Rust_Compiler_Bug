{"sha": "7faebe57b27f3005b5da8666bf02660b21fef4e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmYWViZTU3YjI3ZjMwMDViNWRhODY2NmJmMDI2NjBiMjFmZWY0ZTI=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-17T06:52:14Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-17T22:49:42Z"}, "message": "Move capture lowering from THIR to MIR\n\nThis allows us to:\n- Handle precise Places captured by a closure directly in MIR. Handling\ncaptures in MIR is easier since we can rely on/ tweak PlaceBuilder to\ngenerate `mir::Place`s that resemble how we store captures (`hir::Place`).\n- Allows us to handle `let _ = x` case when feature `capture_disjoint_fields`\nis enabled directly in MIR. This is required to be done in MIR since\npatterns are desugared in MIR.", "tree": {"sha": "54d288e05869115de61664585a14de3b970cbf8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54d288e05869115de61664585a14de3b970cbf8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7faebe57b27f3005b5da8666bf02660b21fef4e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7faebe57b27f3005b5da8666bf02660b21fef4e2", "html_url": "https://github.com/rust-lang/rust/commit/7faebe57b27f3005b5da8666bf02660b21fef4e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7faebe57b27f3005b5da8666bf02660b21fef4e2/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5c37e86ff1782923e3abfbf5491dd383fcf827d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5c37e86ff1782923e3abfbf5491dd383fcf827d", "html_url": "https://github.com/rust-lang/rust/commit/b5c37e86ff1782923e3abfbf5491dd383fcf827d"}], "stats": {"total": 226, "additions": 108, "deletions": 118}, "files": [{"sha": "3f06aa1b131156e83d4bdd335f46753479b733fb", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=7faebe57b27f3005b5da8666bf02660b21fef4e2", "patch": "@@ -160,6 +160,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 expr_span,\n                 source_info,\n             ),\n+            ExprKind::UpvarRef { closure_def_id, var_hir_id } => {\n+                let capture = this\n+                    .hir\n+                    .typeck_results\n+                    .closure_captures\n+                    .get(&closure_def_id)\n+                    .and_then(|captures| captures.get_full(&var_hir_id));\n+\n+                if capture.is_none() {\n+                    if !this.hir.tcx().features().capture_disjoint_fields {\n+                        bug!(\n+                            \"No associated capture found for {:?} even though \\\n+                            capture_disjoint_fields isn't enabled\",\n+                            expr.kind\n+                        )\n+                    }\n+                    // FIXME(project-rfc-2229#24): Handle this case properly\n+                }\n+\n+                // Unwrap until the FIXME has been resolved\n+                let (capture_index, _, upvar_id) = capture.unwrap();\n+                this.lower_closure_capture(block, capture_index, *upvar_id)\n+            }\n+\n             ExprKind::SelfRef => block.and(PlaceBuilder::from(Local::new(1))),\n             ExprKind::VarRef { id } => {\n                 let place_builder = if this.is_bound_var_in_guard(id) {\n@@ -270,6 +294,61 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    /// Lower a closure/generator capture by representing it as a field\n+    /// access within the desugared closure/generator.\n+    ///\n+    /// `capture_index` is the index of the capture within the desugared\n+    /// closure/generator.\n+    fn lower_closure_capture(\n+        &mut self,\n+        block: BasicBlock,\n+        capture_index: usize,\n+        upvar_id: ty::UpvarId,\n+    )  -> BlockAnd<PlaceBuilder<'tcx>> {\n+        let closure_ty = self\n+            .hir\n+            .typeck_results()\n+            .node_type(self.hir.tcx().hir().local_def_id_to_hir_id(upvar_id.closure_expr_id));\n+\n+        // Captures are represented using fields inside a structure.\n+        // This represents accessing self in the closure structure\n+        let mut place_builder = PlaceBuilder::from(Local::new(1));\n+\n+        // In case of Fn/FnMut closures we must deref to access the fields\n+        // Generators are considered FnOnce, so we ignore this step for them.\n+        if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n+            match self.hir.infcx().closure_kind(closure_substs).unwrap() {\n+                ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n+                    place_builder = place_builder.deref();\n+                }\n+                ty::ClosureKind::FnOnce => {}\n+            }\n+        }\n+\n+        let substs = match closure_ty.kind() {\n+            ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n+            ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n+            _ => bug!(\"Lowering capture for non-closure type {:?}\", closure_ty)\n+        };\n+\n+        // Access the capture by accessing the field within the Closure struct.\n+        //\n+        // We must have inferred the capture types since we are building MIR, therefore\n+        // it's safe to call `upvar_tys` and we can unwrap here because\n+        // we know that the capture exists and is the `capture_index`-th capture.\n+        let var_ty = substs.upvar_tys().nth(capture_index).unwrap();\n+        place_builder = place_builder.field(Field::new(capture_index), var_ty);\n+\n+        // If the variable is captured via ByRef(Immutable/Mutable) Borrow,\n+        // we need to deref it\n+        match self.hir.typeck_results.upvar_capture(upvar_id) {\n+            ty::UpvarCapture::ByRef(_) => {\n+                block.and(place_builder.deref())\n+            }\n+            ty::UpvarCapture::ByValue(_) => block.and(place_builder),\n+        }\n+    }\n+\n     /// Lower an index expression\n     ///\n     /// This has two complications;"}, {"sha": "106ec1631e108c508feedfcbd6d529cc3b3bf049", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=7faebe57b27f3005b5da8666bf02660b21fef4e2", "patch": "@@ -251,6 +251,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Index { .. }\n             | ExprKind::VarRef { .. }\n             | ExprKind::SelfRef\n+            | ExprKind::UpvarRef { .. }\n             | ExprKind::Break { .. }\n             | ExprKind::Continue { .. }\n             | ExprKind::Return { .. }"}, {"sha": "925c698111d8b8e2c4eb11669992ee34fbddd419", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=7faebe57b27f3005b5da8666bf02660b21fef4e2", "patch": "@@ -39,6 +39,7 @@ impl Category {\n             | ExprKind::Deref { .. }\n             | ExprKind::Index { .. }\n             | ExprKind::SelfRef\n+            | ExprKind::UpvarRef { .. }\n             | ExprKind::VarRef { .. }\n             | ExprKind::PlaceTypeAscription { .. }\n             | ExprKind::ValueTypeAscription { .. } => Some(Category::Place),"}, {"sha": "9ff1134e67585f310484223ef07e546a64c410b6", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=7faebe57b27f3005b5da8666bf02660b21fef4e2", "patch": "@@ -401,6 +401,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Avoid creating a temporary\n             ExprKind::VarRef { .. }\n             | ExprKind::SelfRef\n+            | ExprKind::UpvarRef { .. }\n             | ExprKind::PlaceTypeAscription { .. }\n             | ExprKind::ValueTypeAscription { .. } => {\n                 debug_assert!(Category::of(&expr.kind) == Some(Category::Place));"}, {"sha": "e404afeb698a6809cf9209eb9a7ad51b7b7eb78c", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 14, "deletions": 118, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=7faebe57b27f3005b5da8666bf02660b21fef4e2", "patch": "@@ -880,130 +880,26 @@ fn convert_path_expr<'a, 'tcx>(\n             ExprKind::Deref { arg: Expr { ty, temp_lifetime, span: expr.span, kind }.to_ref() }\n         }\n \n-        Res::Local(var_hir_id) => convert_var(cx, expr, var_hir_id),\n+        Res::Local(var_hir_id) => convert_var(cx, var_hir_id),\n \n         _ => span_bug!(expr.span, \"res `{:?}` not yet implemented\", res),\n     }\n }\n \n-fn convert_var<'tcx>(\n-    cx: &mut Cx<'_, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    var_hir_id: hir::HirId,\n-) -> ExprKind<'tcx> {\n-    let upvar_index = cx\n-        .typeck_results()\n-        .closure_captures\n-        .get(&cx.body_owner)\n-        .and_then(|upvars| upvars.get_full(&var_hir_id).map(|(i, _, _)| i));\n-\n-    debug!(\n-        \"convert_var({:?}): upvar_index={:?}, body_owner={:?}\",\n-        var_hir_id, upvar_index, cx.body_owner\n-    );\n-\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-\n-    match upvar_index {\n-        None => ExprKind::VarRef { id: var_hir_id },\n+fn convert_var<'tcx>(cx: &mut Cx<'_, 'tcx>, var_hir_id: hir::HirId) -> ExprKind<'tcx> {\n+    // We want upvars here not captures.\n+    // Captures will be handled in MIR.\n+    let is_upvar = cx\n+        .tcx\n+        .upvars_mentioned(cx.body_owner)\n+        .map_or(false, |upvars| upvars.contains_key(&var_hir_id));\n \n-        Some(upvar_index) => {\n-            let closure_def_id = cx.body_owner;\n-            let upvar_id = ty::UpvarId {\n-                var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                closure_expr_id: closure_def_id.expect_local(),\n-            };\n-            let var_ty = cx.typeck_results().node_type(var_hir_id);\n+    debug!(\"convert_var({:?}): is_upvar={}, body_owner={:?}\", var_hir_id, is_upvar, cx.body_owner);\n \n-            // FIXME free regions in closures are not right\n-            let closure_ty = cx\n-                .typeck_results()\n-                .node_type(cx.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id));\n-\n-            // FIXME we're just hard-coding the idea that the\n-            // signature will be &self or &mut self and hence will\n-            // have a bound region with number 0\n-            let region = ty::ReFree(ty::FreeRegion {\n-                scope: closure_def_id,\n-                bound_region: ty::BoundRegion::BrAnon(0),\n-            });\n-            let region = cx.tcx.mk_region(region);\n-\n-            let self_expr = if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n-                match cx.infcx.closure_kind(closure_substs).unwrap() {\n-                    ty::ClosureKind::Fn => {\n-                        let ref_closure_ty = cx.tcx.mk_ref(\n-                            region,\n-                            ty::TypeAndMut { ty: closure_ty, mutbl: hir::Mutability::Not },\n-                        );\n-                        Expr {\n-                            ty: closure_ty,\n-                            temp_lifetime,\n-                            span: expr.span,\n-                            kind: ExprKind::Deref {\n-                                arg: Expr {\n-                                    ty: ref_closure_ty,\n-                                    temp_lifetime,\n-                                    span: expr.span,\n-                                    kind: ExprKind::SelfRef,\n-                                }\n-                                .to_ref(),\n-                            },\n-                        }\n-                    }\n-                    ty::ClosureKind::FnMut => {\n-                        let ref_closure_ty = cx.tcx.mk_ref(\n-                            region,\n-                            ty::TypeAndMut { ty: closure_ty, mutbl: hir::Mutability::Mut },\n-                        );\n-                        Expr {\n-                            ty: closure_ty,\n-                            temp_lifetime,\n-                            span: expr.span,\n-                            kind: ExprKind::Deref {\n-                                arg: Expr {\n-                                    ty: ref_closure_ty,\n-                                    temp_lifetime,\n-                                    span: expr.span,\n-                                    kind: ExprKind::SelfRef,\n-                                }\n-                                .to_ref(),\n-                            },\n-                        }\n-                    }\n-                    ty::ClosureKind::FnOnce => Expr {\n-                        ty: closure_ty,\n-                        temp_lifetime,\n-                        span: expr.span,\n-                        kind: ExprKind::SelfRef,\n-                    },\n-                }\n-            } else {\n-                Expr { ty: closure_ty, temp_lifetime, span: expr.span, kind: ExprKind::SelfRef }\n-            };\n-\n-            // at this point we have `self.n`, which loads up the upvar\n-            let field_kind =\n-                ExprKind::Field { lhs: self_expr.to_ref(), name: Field::new(upvar_index) };\n-\n-            // ...but the upvar might be an `&T` or `&mut T` capture, at which\n-            // point we need an implicit deref\n-            match cx.typeck_results().upvar_capture(upvar_id) {\n-                ty::UpvarCapture::ByValue(_) => field_kind,\n-                ty::UpvarCapture::ByRef(borrow) => ExprKind::Deref {\n-                    arg: Expr {\n-                        temp_lifetime,\n-                        ty: cx.tcx.mk_ref(\n-                            borrow.region,\n-                            ty::TypeAndMut { ty: var_ty, mutbl: borrow.kind.to_mutbl_lossy() },\n-                        ),\n-                        span: expr.span,\n-                        kind: field_kind,\n-                    }\n-                    .to_ref(),\n-                },\n-            }\n-        }\n+    if is_upvar {\n+        ExprKind::UpvarRef { closure_def_id: cx.body_owner, var_hir_id }\n+    } else {\n+        ExprKind::VarRef { id: var_hir_id }\n     }\n }\n \n@@ -1102,7 +998,7 @@ fn capture_upvar<'tcx>(\n         temp_lifetime,\n         ty: var_ty,\n         span: closure_expr.span,\n-        kind: convert_var(cx, closure_expr, var_hir_id),\n+        kind: convert_var(cx, var_hir_id),\n     };\n     match upvar_capture {\n         ty::UpvarCapture::ByValue(_) => captured_var.to_ref(),"}, {"sha": "465808cea9dd50cc9c1e03d9e99f2dcfb71e85bd", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=7faebe57b27f3005b5da8666bf02660b21fef4e2", "patch": "@@ -186,6 +186,10 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         ty.needs_drop(self.tcx, self.param_env)\n     }\n \n+    crate fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> {\n+        self.infcx\n+    }\n+\n     crate fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }"}, {"sha": "d577ec6734fae55954842db3621e2f3cd8562207", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7faebe57b27f3005b5da8666bf02660b21fef4e2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=7faebe57b27f3005b5da8666bf02660b21fef4e2", "patch": "@@ -211,6 +211,14 @@ crate enum ExprKind<'tcx> {\n     VarRef {\n         id: hir::HirId,\n     },\n+    /// Used to represent upvars mentioned in a closure/generator\n+    UpvarRef {\n+        /// DefId of the closure/generator\n+        closure_def_id: DefId,\n+\n+        /// HirId of the root variable\n+        var_hir_id: hir::HirId,\n+    },\n     /// first argument, used for self in a closure\n     SelfRef,\n     Borrow {"}]}