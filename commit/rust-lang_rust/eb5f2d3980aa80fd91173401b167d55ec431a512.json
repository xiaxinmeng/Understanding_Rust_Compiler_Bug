{"sha": "eb5f2d3980aa80fd91173401b167d55ec431a512", "node_id": "C_kwDOAAsO6NoAKGViNWYyZDM5ODBhYTgwZmQ5MTE3MzQwMWIxNjdkNTVlYzQzMWE1MTI", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-01-27T19:28:33Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-02-05T14:19:52Z"}, "message": "rustc_metadata: Support encoding/decoding `LazyArray` without an `Option`", "tree": {"sha": "361349bee663ef3ac105720d576c474bbb49f5e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/361349bee663ef3ac105720d576c474bbb49f5e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb5f2d3980aa80fd91173401b167d55ec431a512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb5f2d3980aa80fd91173401b167d55ec431a512", "html_url": "https://github.com/rust-lang/rust/commit/eb5f2d3980aa80fd91173401b167d55ec431a512", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb5f2d3980aa80fd91173401b167d55ec431a512/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cc5aa561cea5242fbf5834acf11e1e6e8f379fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cc5aa561cea5242fbf5834acf11e1e6e8f379fc", "html_url": "https://github.com/rust-lang/rust/commit/8cc5aa561cea5242fbf5834acf11e1e6e8f379fc"}], "stats": {"total": 96, "additions": 66, "deletions": 30}, "files": [{"sha": "3125111b2bd061366ebffc01cb57b14db1ddbc31", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb5f2d3980aa80fd91173401b167d55ec431a512/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5f2d3980aa80fd91173401b167d55ec431a512/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=eb5f2d3980aa80fd91173401b167d55ec431a512", "patch": "@@ -654,7 +654,7 @@ impl<'a, 'tcx, T> Decodable<DecodeContext<'a, 'tcx>> for LazyValue<T> {\n impl<'a, 'tcx, T> Decodable<DecodeContext<'a, 'tcx>> for LazyArray<T> {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Self {\n         let len = decoder.read_usize();\n-        if len == 0 { LazyArray::empty() } else { decoder.read_lazy_array(len) }\n+        if len == 0 { LazyArray::default() } else { decoder.read_lazy_array(len) }\n     }\n }\n \n@@ -864,7 +864,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .children\n                 .get(self, index)\n-                .unwrap_or_else(LazyArray::empty)\n+                .unwrap_or_else(LazyArray::default)\n                 .decode(self)\n                 .map(|index| ty::FieldDef {\n                     did: self.local_def_id(index),\n@@ -896,7 +896,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .children\n                 .get(self, item_id)\n-                .unwrap_or_else(LazyArray::empty)\n+                .unwrap_or_else(LazyArray::default)\n                 .decode(self)\n                 .filter_map(|index| {\n                     let kind = self.def_kind(index);\n@@ -1045,7 +1045,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .fn_arg_names\n             .get(self, id)\n-            .unwrap_or_else(LazyArray::empty)\n+            .unwrap_or_else(LazyArray::default)\n             .decode((self, sess))\n             .nth(0)\n             .map_or(false, |ident| ident.name == kw::SelfLower)\n@@ -1060,7 +1060,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .children\n             .get(self, id)\n-            .unwrap_or_else(LazyArray::empty)\n+            .unwrap_or_else(LazyArray::default)\n             .decode((self, sess))\n             .map(move |child_index| self.local_def_id(child_index))\n     }\n@@ -1131,7 +1131,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .children\n             .get(self, id)\n-            .unwrap_or_else(LazyArray::empty)\n+            .unwrap_or_else(LazyArray::default)\n             .decode(self)\n             .map(move |index| respan(self.get_span(index, sess), self.item_name(index)))\n     }\n@@ -1144,7 +1144,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .children\n             .get(self, id)\n-            .unwrap_or_else(LazyArray::empty)\n+            .unwrap_or_else(LazyArray::default)\n             .decode(self)\n             .map(move |field_index| self.get_visibility(field_index))\n     }\n@@ -1159,7 +1159,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .inherent_impls\n                 .get(self, id)\n-                .unwrap_or_else(LazyArray::empty)\n+                .unwrap_or_else(LazyArray::default)\n                 .decode(self)\n                 .map(|index| self.local_def_id(index)),\n         )\n@@ -1174,7 +1174,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .inherent_impls\n                 .get(self, ty_index)\n-                .unwrap_or_else(LazyArray::empty)\n+                .unwrap_or_else(LazyArray::default)\n                 .decode(self)\n                 .map(move |impl_index| (ty_def_id, self.local_def_id(impl_index)))\n         })"}, {"sha": "ed63e94096517ca4daa8fef531181958cdf3d861", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb5f2d3980aa80fd91173401b167d55ec431a512/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5f2d3980aa80fd91173401b167d55ec431a512/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=eb5f2d3980aa80fd91173401b167d55ec431a512", "patch": "@@ -76,13 +76,13 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n     symbol_table: FxHashMap<Symbol, usize>,\n }\n \n-/// If the current crate is a proc-macro, returns early with `LazyArray::empty()`.\n+/// If the current crate is a proc-macro, returns early with `LazyArray::default()`.\n /// This is useful for skipping the encoding of things that aren't needed\n /// for proc-macro crates.\n macro_rules! empty_proc_macro {\n     ($self:ident) => {\n         if $self.is_proc_macro {\n-            return LazyArray::empty();\n+            return LazyArray::default();\n         }\n     };\n }\n@@ -1961,7 +1961,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 Linkage::Static => Some(LinkagePreference::RequireStatic),\n             }));\n         }\n-        LazyArray::empty()\n+        LazyArray::default()\n     }\n \n     fn encode_info_for_foreign_item(&mut self, def_id: DefId, nitem: &hir::ForeignItem<'_>) {"}, {"sha": "d8c778b935ed6074a96ab97161a7c82cdee3d1d4", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb5f2d3980aa80fd91173401b167d55ec431a512/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5f2d3980aa80fd91173401b167d55ec431a512/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=eb5f2d3980aa80fd91173401b167d55ec431a512", "patch": "@@ -115,14 +115,16 @@ impl<T: ParameterizedOverTcx> ParameterizedOverTcx for LazyArray<T> {\n     type Value<'tcx> = LazyArray<T::Value<'tcx>>;\n }\n \n+impl<T> Default for LazyArray<T> {\n+    fn default() -> LazyArray<T> {\n+        LazyArray::from_position_and_num_elems(NonZeroUsize::new(1).unwrap(), 0)\n+    }\n+}\n+\n impl<T> LazyArray<T> {\n     fn from_position_and_num_elems(position: NonZeroUsize, num_elems: usize) -> LazyArray<T> {\n         LazyArray { position, num_elems, _marker: PhantomData }\n     }\n-\n-    fn empty() -> LazyArray<T> {\n-        LazyArray::from_position_and_num_elems(NonZeroUsize::new(1).unwrap(), 0)\n-    }\n }\n \n /// A list of lazily-decoded values, with the added capability of random access."}, {"sha": "11916553db5141465846e9ca511ca1a16c791b69", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/eb5f2d3980aa80fd91173401b167d55ec431a512/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5f2d3980aa80fd91173401b167d55ec431a512/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=eb5f2d3980aa80fd91173401b167d55ec431a512", "patch": "@@ -38,6 +38,12 @@ impl IsDefault for u32 {\n     }\n }\n \n+impl<T> IsDefault for LazyArray<T> {\n+    fn is_default(&self) -> bool {\n+        self.num_elems == 0\n+    }\n+}\n+\n /// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n /// Used mainly for Lazy positions and lengths.\n /// Unchecked invariant: `Self::default()` should encode as `[0; BYTE_LEN]`,\n@@ -286,32 +292,60 @@ impl<T> FixedSizeEncoding for Option<LazyValue<T>> {\n     }\n }\n \n+impl<T> LazyArray<T> {\n+    #[inline]\n+    fn write_to_bytes_impl(self, b: &mut [u8; 8]) {\n+        let ([position_bytes, meta_bytes],[])= b.as_chunks_mut::<4>() else { panic!() };\n+\n+        let position = self.position.get();\n+        let position: u32 = position.try_into().unwrap();\n+        position.write_to_bytes(position_bytes);\n+\n+        let len = self.num_elems;\n+        let len: u32 = len.try_into().unwrap();\n+        len.write_to_bytes(meta_bytes);\n+    }\n+\n+    fn from_bytes_impl(position_bytes: &[u8; 4], meta_bytes: &[u8; 4]) -> Option<LazyArray<T>> {\n+        let position = NonZeroUsize::new(u32::from_bytes(position_bytes) as usize)?;\n+        let len = u32::from_bytes(meta_bytes) as usize;\n+        Some(LazyArray::from_position_and_num_elems(position, len))\n+    }\n+}\n+\n+impl<T> FixedSizeEncoding for LazyArray<T> {\n+    type ByteArray = [u8; 8];\n+\n+    #[inline]\n+    fn from_bytes(b: &[u8; 8]) -> Self {\n+        let ([position_bytes, meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n+        if *meta_bytes == [0; 4] {\n+            return Default::default();\n+        }\n+        LazyArray::from_bytes_impl(position_bytes, meta_bytes).unwrap()\n+    }\n+\n+    #[inline]\n+    fn write_to_bytes(self, b: &mut [u8; 8]) {\n+        assert!(!self.is_default());\n+        self.write_to_bytes_impl(b)\n+    }\n+}\n+\n impl<T> FixedSizeEncoding for Option<LazyArray<T>> {\n     type ByteArray = [u8; 8];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 8]) -> Self {\n         let ([position_bytes, meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n-        let position = NonZeroUsize::new(u32::from_bytes(position_bytes) as usize)?;\n-        let len = u32::from_bytes(meta_bytes) as usize;\n-        Some(LazyArray::from_position_and_num_elems(position, len))\n+        LazyArray::from_bytes_impl(position_bytes, meta_bytes)\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 8]) {\n         match self {\n             None => unreachable!(),\n-            Some(lazy) => {\n-                let ([position_bytes, meta_bytes],[])= b.as_chunks_mut::<4>() else { panic!() };\n-\n-                let position = lazy.position.get();\n-                let position: u32 = position.try_into().unwrap();\n-                position.write_to_bytes(position_bytes);\n-\n-                let len = lazy.num_elems;\n-                let len: u32 = len.try_into().unwrap();\n-                len.write_to_bytes(meta_bytes);\n-            }\n+            Some(lazy) => lazy.write_to_bytes_impl(b),\n         }\n     }\n }"}]}