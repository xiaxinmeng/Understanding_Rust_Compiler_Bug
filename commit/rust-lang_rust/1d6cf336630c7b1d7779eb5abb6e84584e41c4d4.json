{"sha": "1d6cf336630c7b1d7779eb5abb6e84584e41c4d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNmNmMzM2NjMwYzdiMWQ3Nzc5ZWI1YWJiNmU4NDU4NGU0MWM0ZDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-16T09:36:52Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-16T09:37:26Z"}, "message": "Simplify", "tree": {"sha": "b84ea78d9945e4cd4f0b38d337c39af68c769fe5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b84ea78d9945e4cd4f0b38d337c39af68c769fe5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d6cf336630c7b1d7779eb5abb6e84584e41c4d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6cf336630c7b1d7779eb5abb6e84584e41c4d4", "html_url": "https://github.com/rust-lang/rust/commit/1d6cf336630c7b1d7779eb5abb6e84584e41c4d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d6cf336630c7b1d7779eb5abb6e84584e41c4d4/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb2613ed4d23f6104d0a2648352bff111292373a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb2613ed4d23f6104d0a2648352bff111292373a", "html_url": "https://github.com/rust-lang/rust/commit/bb2613ed4d23f6104d0a2648352bff111292373a"}], "stats": {"total": 66, "additions": 19, "deletions": 47}, "files": [{"sha": "0ef92ed4bf8b61b5b8b6e42e76ebee1ab67624d6", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 19, "deletions": 47, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1d6cf336630c7b1d7779eb5abb6e84584e41c4d4/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6cf336630c7b1d7779eb5abb6e84584e41c4d4/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=1d6cf336630c7b1d7779eb5abb6e84584e41c4d4", "patch": "@@ -48,43 +48,40 @@ fn call_info_for_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Op\n     // Find the calling expression and it's NameRef\n     let calling_node = FnCallNode::with_node(&token.parent())?;\n \n-    let (mut call_info, has_self) = match &calling_node {\n+    let signature = match &calling_node {\n         FnCallNode::CallExpr(call) => {\n             //FIXME: Type::as_callable is broken\n             let callable_def = sema.type_of_expr(&call.expr()?)?.as_callable()?;\n             match callable_def {\n                 hir::CallableDef::FunctionId(it) => {\n                     let fn_def = it.into();\n-                    (CallInfo::with_fn(sema.db, fn_def), fn_def.has_self_param(sema.db))\n+                    FunctionSignature::from_hir(sema.db, fn_def)\n                 }\n                 hir::CallableDef::StructId(it) => {\n-                    (CallInfo::with_struct(sema.db, it.into())?, false)\n+                    FunctionSignature::from_struct(sema.db, it.into())?\n                 }\n                 hir::CallableDef::EnumVariantId(it) => {\n-                    (CallInfo::with_enum_variant(sema.db, it.into())?, false)\n+                    FunctionSignature::from_enum_variant(sema.db, it.into())?\n                 }\n             }\n         }\n         FnCallNode::MethodCallExpr(method_call) => {\n             let function = sema.resolve_method_call(&method_call)?;\n-            (CallInfo::with_fn(sema.db, function), function.has_self_param(sema.db))\n+            FunctionSignature::from_hir(sema.db, function)\n         }\n         FnCallNode::MacroCallExpr(macro_call) => {\n             let macro_def = sema.resolve_macro_call(&macro_call)?;\n-            (CallInfo::with_macro(sema.db, macro_def)?, false)\n+            FunctionSignature::from_macro(sema.db, macro_def)?\n         }\n     };\n \n     // If we have a calling expression let's find which argument we are on\n-    let num_params = call_info.parameters().len();\n+    let num_params = signature.parameters.len();\n \n-    match num_params {\n-        0 => (),\n-        1 => {\n-            if !has_self {\n-                call_info.active_parameter = Some(0);\n-            }\n-        }\n+    let active_parameter = match num_params {\n+        0 => None,\n+        1 if signature.has_self_param => None,\n+        1 => Some(0),\n         _ => {\n             if let Some(arg_list) = calling_node.arg_list() {\n                 // Number of arguments specified at the call site\n@@ -107,16 +104,18 @@ fn call_info_for_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Op\n                 );\n \n                 // If we are in a method account for `self`\n-                if has_self {\n+                if signature.has_self_param {\n                     param += 1;\n                 }\n \n-                call_info.active_parameter = Some(param);\n+                Some(param)\n+            } else {\n+                None\n             }\n         }\n-    }\n+    };\n \n-    Some(call_info)\n+    Some(CallInfo { signature, active_parameter })\n }\n \n #[derive(Debug)]\n@@ -189,34 +188,6 @@ impl CallInfo {\n         let res = ActiveParameter { ty, name };\n         Some(res)\n     }\n-\n-    fn with_fn(db: &RootDatabase, function: hir::Function) -> Self {\n-        let signature = FunctionSignature::from_hir(db, function);\n-\n-        CallInfo { signature, active_parameter: None }\n-    }\n-\n-    fn with_struct(db: &RootDatabase, st: hir::Struct) -> Option<Self> {\n-        let signature = FunctionSignature::from_struct(db, st)?;\n-\n-        Some(CallInfo { signature, active_parameter: None })\n-    }\n-\n-    fn with_enum_variant(db: &RootDatabase, variant: hir::EnumVariant) -> Option<Self> {\n-        let signature = FunctionSignature::from_enum_variant(db, variant)?;\n-\n-        Some(CallInfo { signature, active_parameter: None })\n-    }\n-\n-    fn with_macro(db: &RootDatabase, macro_def: hir::MacroDef) -> Option<Self> {\n-        let signature = FunctionSignature::from_macro(db, macro_def)?;\n-\n-        Some(CallInfo { signature, active_parameter: None })\n-    }\n-\n-    fn parameters(&self) -> &[String] {\n-        &self.signature.parameters\n-    }\n }\n \n #[cfg(test)]\n@@ -236,7 +207,8 @@ mod tests {\n                     Some(docs) => format!(\"{}\\n------\\n\", docs.as_str()),\n                 };\n                 let params = call_info\n-                    .parameters()\n+                    .signature\n+                    .parameters\n                     .iter()\n                     .enumerate()\n                     .map(|(i, param)| {"}]}