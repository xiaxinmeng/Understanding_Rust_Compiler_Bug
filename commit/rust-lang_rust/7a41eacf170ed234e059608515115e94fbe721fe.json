{"sha": "7a41eacf170ed234e059608515115e94fbe721fe", "node_id": "C_kwDOAAsO6NoAKDdhNDFlYWNmMTcwZWQyMzRlMDU5NjA4NTE1MTE1ZTk0ZmJlNzIxZmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-10T07:39:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-10T07:39:31Z"}, "message": "Auto merge of #2885 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "bba0f53fa3cae672594193a410b19c864c12cc5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bba0f53fa3cae672594193a410b19c864c12cc5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a41eacf170ed234e059608515115e94fbe721fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a41eacf170ed234e059608515115e94fbe721fe", "html_url": "https://github.com/rust-lang/rust/commit/7a41eacf170ed234e059608515115e94fbe721fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a41eacf170ed234e059608515115e94fbe721fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fb4332ce452875b0f86dd62be0b1356e6d9537d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fb4332ce452875b0f86dd62be0b1356e6d9537d", "html_url": "https://github.com/rust-lang/rust/commit/7fb4332ce452875b0f86dd62be0b1356e6d9537d"}, {"sha": "68c7d2083f315a349caf3202a5495b1c99a38461", "url": "https://api.github.com/repos/rust-lang/rust/commits/68c7d2083f315a349caf3202a5495b1c99a38461", "html_url": "https://github.com/rust-lang/rust/commit/68c7d2083f315a349caf3202a5495b1c99a38461"}], "stats": {"total": 22987, "additions": 16522, "deletions": 6465}, "files": [{"sha": "6539bd393fb9a3c25ebf5347a6b73a8c1b06a381", "filename": "Cargo.lock", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1443,6 +1443,13 @@ dependencies = [\n  \"serde_json\",\n ]\n \n+[[package]]\n+name = \"generate-windows-sys\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"windows-bindgen\",\n+]\n+\n [[package]]\n name = \"generic-array\"\n version = \"0.14.4\"\n@@ -1546,9 +1553,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n dependencies = [\n  \"ahash 0.7.4\",\n- \"compiler_builtins\",\n- \"rustc-std-workspace-alloc\",\n- \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n@@ -1558,6 +1562,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"33ff8ae62cd3a9102e5637afc8452c55acf3844001bd5374e0b0bd7b6616c038\"\n dependencies = [\n  \"ahash 0.8.2\",\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n@@ -1938,9 +1945,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.142\"\n+version = \"0.2.143\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6a987beff54b60ffa6d51982e1aa1146bc42f19bd26be28b0586f252fccf5317\"\n+checksum = \"edc207893e85c5d6be840e969b496b53d94cec8be2d501b214f50daa97fa8024\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -3353,6 +3360,7 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_mir_build\",\n  \"rustc_mir_dataflow\",\n+ \"rustc_mir_transform\",\n  \"rustc_monomorphize\",\n  \"rustc_parse\",\n  \"rustc_passes\",\n@@ -3861,8 +3869,10 @@ dependencies = [\n  \"rustc_const_eval\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_fluent_macro\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_mir_dataflow\",\n  \"rustc_serialize\",\n@@ -4607,7 +4617,7 @@ dependencies = [\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n- \"hashbrown 0.12.3\",\n+ \"hashbrown 0.13.1\",\n  \"hermit-abi 0.3.0\",\n  \"libc\",\n  \"miniz_oxide\",\n@@ -5506,6 +5516,22 @@ dependencies = [\n  \"windows-targets 0.48.0\",\n ]\n \n+[[package]]\n+name = \"windows-bindgen\"\n+version = \"0.49.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b6935fb09b84ee57929ae92518b475f5dfdfbeb87c5334756acc28ee8e202b60\"\n+dependencies = [\n+ \"windows-metadata\",\n+ \"windows-tokens\",\n+]\n+\n+[[package]]\n+name = \"windows-metadata\"\n+version = \"0.49.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2f5bca94a32bf1e6a376522b6601275a3b611ee885ec0f1b6a05f17e8cfd3385\"\n+\n [[package]]\n name = \"windows-sys\"\n version = \"0.42.0\"\n@@ -5569,6 +5595,12 @@ dependencies = [\n  \"windows_x86_64_msvc 0.48.0\",\n ]\n \n+[[package]]\n+name = \"windows-tokens\"\n+version = \"0.48.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b34c9a3b28cb41db7385546f7f9a8179348dffc89923dde66857b1ba5312f6b4\"\n+\n [[package]]\n name = \"windows_aarch64_gnullvm\"\n version = \"0.42.2\""}, {"sha": "53331e2869f2e799adcce4808316f80dca012220", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -39,6 +39,7 @@ members = [\n   \"src/tools/collect-license-metadata\",\n   \"src/tools/generate-copyright\",\n   \"src/tools/suggest-tests\",\n+  \"src/tools/generate-windows-sys\",\n ]\n \n exclude = ["}, {"sha": "43b429f6947ec2f2f436ed371c1430ed1f63b713", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -120,6 +120,12 @@ impl Path {\n     pub fn is_global(&self) -> bool {\n         !self.segments.is_empty() && self.segments[0].ident.name == kw::PathRoot\n     }\n+\n+    /// If this path is a single identifier with no arguments, does not ensure\n+    /// that the path resolves to a const param, the caller should check this.\n+    pub fn is_potential_trivial_const_arg(&self) -> bool {\n+        self.segments.len() == 1 && self.segments[0].args.is_none()\n+    }\n }\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of types.\n@@ -1154,7 +1160,9 @@ impl Expr {\n     ///\n     /// If this is not the case, name resolution does not resolve `N` when using\n     /// `min_const_generics` as more complex expressions are not supported.\n-    pub fn is_potential_trivial_const_param(&self) -> bool {\n+    ///\n+    /// Does not ensure that the path resolves to a const param, the caller should check this.\n+    pub fn is_potential_trivial_const_arg(&self) -> bool {\n         let this = if let ExprKind::Block(block, None) = &self.kind\n             && block.stmts.len() == 1\n             && let StmtKind::Expr(expr) = &block.stmts[0].kind\n@@ -1165,8 +1173,7 @@ impl Expr {\n         };\n \n         if let ExprKind::Path(None, path) = &this.kind\n-            && path.segments.len() == 1\n-            && path.segments[0].args.is_none()\n+            && path.is_potential_trivial_const_arg()\n         {\n             true\n         } else {"}, {"sha": "275692ad5dda7f54a2341fccfc9df7e7ee6fd058", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -188,6 +188,9 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_variant(&mut self, v: &'ast Variant) {\n         walk_variant(self, v)\n     }\n+    fn visit_variant_discr(&mut self, discr: &'ast AnonConst) {\n+        self.visit_anon_const(discr);\n+    }\n     fn visit_label(&mut self, label: &'ast Label) {\n         walk_label(self, label)\n     }\n@@ -380,7 +383,7 @@ where\n     visitor.visit_ident(variant.ident);\n     visitor.visit_vis(&variant.vis);\n     visitor.visit_variant_data(&variant.data);\n-    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+    walk_list!(visitor, visit_variant_discr, &variant.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.attrs);\n }\n "}, {"sha": "afcf8b15cd80053910711345b36d6a8542f80fa5", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -446,7 +446,30 @@ fn expand_format_args<'hir>(\n         && argmap.iter().enumerate().all(|(i, (&(j, _), _))| i == j)\n         && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n \n-    let args = if use_simple_array {\n+    let args = if arguments.is_empty() {\n+        // Generate:\n+        //    &<core::fmt::Argument>::none()\n+        //\n+        // Note:\n+        //     `none()` just returns `[]`. We use `none()` rather than `[]` to limit the lifetime.\n+        //\n+        //     This makes sure that this still fails to compile, even when the argument is inlined:\n+        //\n+        //     ```\n+        //     let f = format_args!(\"{}\", \"a\");\n+        //     println!(\"{f}\"); // error E0716\n+        //     ```\n+        //\n+        //     Cases where keeping the object around is allowed, such as `format_args!(\"a\")`,\n+        //     are handled above by the `allow_const` case.\n+        let none_fn = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArgument,\n+            sym::none,\n+        ));\n+        let none = ctx.expr_call(macsp, none_fn, &[]);\n+        ctx.expr(macsp, hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, none))\n+    } else if use_simple_array {\n         // Generate:\n         //     &[\n         //         <core::fmt::Argument>::new_display(&arg0),"}, {"sha": "1fd7cc6647037e847019a90d57afaec5da76ba02", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1190,13 +1190,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // parsing. We try to resolve that ambiguity by attempting resolution in both the\n                     // type and value namespaces. If we resolved the path in the value namespace, we\n                     // transform it into a generic const argument.\n-                    TyKind::Path(qself, path) => {\n+                    TyKind::Path(None, path) => {\n                         if let Some(res) = self\n                             .resolver\n                             .get_partial_res(ty.id)\n                             .and_then(|partial_res| partial_res.full_res())\n                         {\n-                            if !res.matches_ns(Namespace::TypeNS) {\n+                            if !res.matches_ns(Namespace::TypeNS)\n+                                && path.is_potential_trivial_const_arg()\n+                            {\n                                 debug!(\n                                     \"lower_generic_arg: Lowering type argument as const argument: {:?}\",\n                                     ty,\n@@ -1218,7 +1220,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                                 let path_expr = Expr {\n                                     id: ty.id,\n-                                    kind: ExprKind::Path(qself.clone(), path.clone()),\n+                                    kind: ExprKind::Path(None, path.clone()),\n                                     span,\n                                     attrs: AttrVec::new(),\n                                     tokens: None,\n@@ -1477,20 +1479,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Given a function definition like:\n     ///\n     /// ```rust\n+    /// use std::fmt::Debug;\n+    ///\n     /// fn test<'a, T: Debug>(x: &'a T) -> impl Debug + 'a {\n     ///     x\n     /// }\n     /// ```\n     ///\n     /// we will create a TAIT definition in the HIR like\n     ///\n-    /// ```\n+    /// ```rust,ignore (pseudo-Rust)\n     /// type TestReturn<'a, T, 'x> = impl Debug + 'x\n     /// ```\n     ///\n     /// and return a type like `TestReturn<'static, T, 'a>`, so that the function looks like:\n     ///\n-    /// ```rust\n+    /// ```rust,ignore (pseudo-Rust)\n     /// fn test<'a, T: Debug>(x: &'a T) -> TestReturn<'static, T, 'a>\n     /// ```\n     ///"}, {"sha": "3d5056d82c56c4c8c3e96f2c9a39e81290cd0fe7", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -603,6 +603,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(yeet_expr, \"`do yeet` expression is experimental\");\n     gate_all!(dyn_star, \"`dyn*` trait objects are experimental\");\n     gate_all!(const_closures, \"const closures are experimental\");\n+    gate_all!(builtin_syntax, \"`builtin #` syntax is unstable\");\n \n     if !visitor.features.negative_bounds {\n         for &span in spans.get(&sym::negative_bounds).iter().copied().flatten() {"}, {"sha": "87c32ffce1214b6ffbced065d7eb358561f0509b", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -556,8 +556,7 @@ impl<'a> State<'a> {\n                 self.pclose();\n             }\n             ast::ExprKind::OffsetOf(container, fields) => {\n-                // FIXME: This should have its own syntax, distinct from a macro invocation.\n-                self.word(\"offset_of!\");\n+                self.word(\"builtin # offset_of\");\n                 self.popen();\n                 self.rbox(0, Inconsistent);\n                 self.print_type(container);"}, {"sha": "6286033e0672d2bf2a041c1705def878ddfb582c", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 264, "deletions": 245, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,4 +1,4 @@\n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n@@ -478,186 +478,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n-                        let label = match *local_decl.local_info() {\n-                            LocalInfo::User(mir::BindingForm::ImplicitSelf(_)) => {\n-                                let (span, suggestion) =\n-                                    suggest_ampmut_self(self.infcx.tcx, local_decl);\n-                                Some((true, span, suggestion))\n-                            }\n-\n-                            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n-                                binding_mode: ty::BindingMode::BindByValue(_),\n-                                opt_ty_info,\n-                                ..\n-                            })) => {\n-                                // check if the RHS is from desugaring\n-                                let opt_assignment_rhs_span =\n-                                    self.body.find_assignments(local).first().map(|&location| {\n-                                        if let Some(mir::Statement {\n-                                            source_info: _,\n-                                            kind:\n-                                                mir::StatementKind::Assign(box (\n-                                                    _,\n-                                                    mir::Rvalue::Use(mir::Operand::Copy(place)),\n-                                                )),\n-                                        }) = self.body[location.block]\n-                                            .statements\n-                                            .get(location.statement_index)\n-                                        {\n-                                            self.body.local_decls[place.local].source_info.span\n-                                        } else {\n-                                            self.body.source_info(location).span\n-                                        }\n-                                    });\n-                                match opt_assignment_rhs_span.and_then(|s| s.desugaring_kind()) {\n-                                    // on for loops, RHS points to the iterator part\n-                                    Some(DesugaringKind::ForLoop) => {\n-                                        self.suggest_similar_mut_method_for_for_loop(&mut err);\n-                                        err.span_label(opt_assignment_rhs_span.unwrap(), format!(\n-                                            \"this iterator yields `{pointer_sigil}` {pointer_desc}s\",\n-                                        ));\n-                                        None\n-                                    }\n-                                    // don't create labels for compiler-generated spans\n-                                    Some(_) => None,\n-                                    None => {\n-                                        let label = if name != kw::SelfLower {\n-                                            suggest_ampmut(\n-                                                self.infcx.tcx,\n-                                                local_decl,\n-                                                opt_assignment_rhs_span,\n-                                                opt_ty_info,\n-                                            )\n-                                        } else {\n-                                            match local_decl.local_info() {\n-                                                LocalInfo::User(mir::BindingForm::Var(\n-                                                    mir::VarBindingForm {\n-                                                        opt_ty_info: None, ..\n-                                                    },\n-                                                )) => {\n-                                                    let (span, sugg) = suggest_ampmut_self(\n-                                                        self.infcx.tcx,\n-                                                        local_decl,\n-                                                    );\n-                                                    (true, span, sugg)\n-                                                }\n-                                                // explicit self (eg `self: &'a Self`)\n-                                                _ => suggest_ampmut(\n-                                                    self.infcx.tcx,\n-                                                    local_decl,\n-                                                    opt_assignment_rhs_span,\n-                                                    opt_ty_info,\n-                                                ),\n-                                            }\n-                                        };\n-                                        Some(label)\n-                                    }\n-                                }\n-                            }\n-\n-                            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n-                                binding_mode: ty::BindingMode::BindByReference(_),\n-                                ..\n-                            })) => {\n-                                let pattern_span = local_decl.source_info.span;\n-                                suggest_ref_mut(self.infcx.tcx, pattern_span)\n-                                    .map(|replacement| (true, pattern_span, replacement))\n-                            }\n-\n-                            _ => unreachable!(),\n-                        };\n-\n-                        match label {\n-                            Some((true, err_help_span, suggested_code)) => {\n-                                let (is_trait_sig, local_trait) = self.is_error_in_trait(local);\n-                                if !is_trait_sig {\n-                                    err.span_suggestion_verbose(\n-                                        err_help_span,\n-                                        format!(\n-                                            \"consider changing this to be a mutable {pointer_desc}\"\n-                                        ),\n-                                        suggested_code,\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                } else if let Some(x) = local_trait {\n-                                    err.span_suggestion_verbose(\n-                                        x,\n-                                        format!(\n-                                            \"consider changing that to be a mutable {pointer_desc}\"\n-                                        ),\n-                                        suggested_code,\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                            }\n-                            Some((false, err_label_span, message)) => {\n-                                struct BindingFinder {\n-                                    span: Span,\n-                                    hir_id: Option<hir::HirId>,\n-                                }\n-\n-                                impl<'tcx> Visitor<'tcx> for BindingFinder {\n-                                    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n-                                        if let hir::StmtKind::Local(local) = s.kind {\n-                                            if local.pat.span == self.span {\n-                                                self.hir_id = Some(local.hir_id);\n-                                            }\n-                                        }\n-                                        hir::intravisit::walk_stmt(self, s);\n-                                    }\n-                                }\n-                                let hir_map = self.infcx.tcx.hir();\n-                                let def_id = self.body.source.def_id();\n-                                let hir_id = hir_map.local_def_id_to_hir_id(def_id.expect_local());\n-                                let node = hir_map.find(hir_id);\n-                                let hir_id = if let Some(hir::Node::Item(item)) = node\n-                                    && let hir::ItemKind::Fn(.., body_id) = item.kind\n-                                {\n-                                    let body = hir_map.body(body_id);\n-                                    let mut v = BindingFinder {\n-                                        span: err_label_span,\n-                                        hir_id: None,\n-                                    };\n-                                    v.visit_body(body);\n-                                    v.hir_id\n-                                } else {\n-                                    None\n-                                };\n-                                if let Some(hir_id) = hir_id\n-                                    && let Some(hir::Node::Local(local)) = hir_map.find(hir_id)\n-                                {\n-                                    let (changing, span, sugg) = match local.ty {\n-                                        Some(ty) => (\"changing\", ty.span, message),\n-                                        None => (\n-                                            \"specifying\",\n-                                            local.pat.span.shrink_to_hi(),\n-                                            format!(\": {message}\"),\n-                                        ),\n-                                    };\n-                                    err.span_suggestion_verbose(\n-                                        span,\n-                                        format!(\"consider {changing} this binding's type\"),\n-                                        sugg,\n-                                        Applicability::HasPlaceholders,\n-                                    );\n-                                } else {\n-                                    err.span_label(\n-                                        err_label_span,\n-                                        format!(\n-                                            \"consider changing this binding's type to be: `{message}`\"\n-                                        ),\n-                                    );\n-                                }\n-                            }\n-                            None => {}\n-                        }\n                         err.span_label(\n                             span,\n                             format!(\n                                 \"`{name}` is a `{pointer_sigil}` {pointer_desc}, \\\n                                  so the data it refers to cannot be {acted_on}\",\n                             ),\n                         );\n+\n+                        self.suggest_make_local_mut(&mut err, local, name);\n                     }\n                     _ => {\n                         err.span_label(\n@@ -1131,6 +960,184 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn suggest_make_local_mut(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        local: Local,\n+        name: Symbol,\n+    ) {\n+        let local_decl = &self.body.local_decls[local];\n+\n+        let (pointer_sigil, pointer_desc) =\n+            if local_decl.ty.is_ref() { (\"&\", \"reference\") } else { (\"*const\", \"pointer\") };\n+\n+        let (is_trait_sig, local_trait) = self.is_error_in_trait(local);\n+        if is_trait_sig && local_trait.is_none() {\n+            return;\n+        }\n+\n+        let decl_span = match local_trait {\n+            Some(span) => span,\n+            None => local_decl.source_info.span,\n+        };\n+\n+        let label = match *local_decl.local_info() {\n+            LocalInfo::User(mir::BindingForm::ImplicitSelf(_)) => {\n+                let suggestion = suggest_ampmut_self(self.infcx.tcx, decl_span);\n+                Some((true, decl_span, suggestion))\n+            }\n+\n+            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByValue(_),\n+                opt_ty_info,\n+                ..\n+            })) => {\n+                // check if the RHS is from desugaring\n+                let opt_assignment_rhs_span =\n+                    self.body.find_assignments(local).first().map(|&location| {\n+                        if let Some(mir::Statement {\n+                            source_info: _,\n+                            kind:\n+                                mir::StatementKind::Assign(box (\n+                                    _,\n+                                    mir::Rvalue::Use(mir::Operand::Copy(place)),\n+                                )),\n+                        }) = self.body[location.block].statements.get(location.statement_index)\n+                        {\n+                            self.body.local_decls[place.local].source_info.span\n+                        } else {\n+                            self.body.source_info(location).span\n+                        }\n+                    });\n+                match opt_assignment_rhs_span.and_then(|s| s.desugaring_kind()) {\n+                    // on for loops, RHS points to the iterator part\n+                    Some(DesugaringKind::ForLoop) => {\n+                        self.suggest_similar_mut_method_for_for_loop(err);\n+                        err.span_label(\n+                            opt_assignment_rhs_span.unwrap(),\n+                            format!(\"this iterator yields `{pointer_sigil}` {pointer_desc}s\",),\n+                        );\n+                        None\n+                    }\n+                    // don't create labels for compiler-generated spans\n+                    Some(_) => None,\n+                    None => {\n+                        let label = if name != kw::SelfLower {\n+                            suggest_ampmut(\n+                                self.infcx.tcx,\n+                                local_decl.ty,\n+                                decl_span,\n+                                opt_assignment_rhs_span,\n+                                opt_ty_info,\n+                            )\n+                        } else {\n+                            match local_decl.local_info() {\n+                                LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                                    opt_ty_info: None,\n+                                    ..\n+                                })) => {\n+                                    let sugg = suggest_ampmut_self(self.infcx.tcx, decl_span);\n+                                    (true, decl_span, sugg)\n+                                }\n+                                // explicit self (eg `self: &'a Self`)\n+                                _ => suggest_ampmut(\n+                                    self.infcx.tcx,\n+                                    local_decl.ty,\n+                                    decl_span,\n+                                    opt_assignment_rhs_span,\n+                                    opt_ty_info,\n+                                ),\n+                            }\n+                        };\n+                        Some(label)\n+                    }\n+                }\n+            }\n+\n+            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByReference(_),\n+                ..\n+            })) => {\n+                let pattern_span: Span = local_decl.source_info.span;\n+                suggest_ref_mut(self.infcx.tcx, pattern_span)\n+                    .map(|span| (true, span, \"mut \".to_owned()))\n+            }\n+\n+            _ => unreachable!(),\n+        };\n+\n+        match label {\n+            Some((true, err_help_span, suggested_code)) => {\n+                err.span_suggestion_verbose(\n+                    err_help_span,\n+                    format!(\"consider changing this to be a mutable {pointer_desc}\"),\n+                    suggested_code,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            Some((false, err_label_span, message)) => {\n+                struct BindingFinder {\n+                    span: Span,\n+                    hir_id: Option<hir::HirId>,\n+                }\n+\n+                impl<'tcx> Visitor<'tcx> for BindingFinder {\n+                    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n+                        if let hir::StmtKind::Local(local) = s.kind {\n+                            if local.pat.span == self.span {\n+                                self.hir_id = Some(local.hir_id);\n+                            }\n+                        }\n+                        hir::intravisit::walk_stmt(self, s);\n+                    }\n+                }\n+                let hir_map = self.infcx.tcx.hir();\n+                let def_id = self.body.source.def_id();\n+                let hir_id = hir_map.local_def_id_to_hir_id(def_id.expect_local());\n+                let node = hir_map.find(hir_id);\n+                let hir_id = if let Some(hir::Node::Item(item)) = node\n+                && let hir::ItemKind::Fn(.., body_id) = item.kind\n+            {\n+                let body = hir_map.body(body_id);\n+                let mut v = BindingFinder {\n+                    span: err_label_span,\n+                    hir_id: None,\n+                };\n+                v.visit_body(body);\n+                v.hir_id\n+            } else {\n+                None\n+            };\n+                if let Some(hir_id) = hir_id\n+                && let Some(hir::Node::Local(local)) = hir_map.find(hir_id)\n+            {\n+                let (changing, span, sugg) = match local.ty {\n+                    Some(ty) => (\"changing\", ty.span, message),\n+                    None => (\n+                        \"specifying\",\n+                        local.pat.span.shrink_to_hi(),\n+                        format!(\": {message}\"),\n+                    ),\n+                };\n+                err.span_suggestion_verbose(\n+                    span,\n+                    format!(\"consider {changing} this binding's type\"),\n+                    sugg,\n+                    Applicability::HasPlaceholders,\n+                );\n+            } else {\n+                err.span_label(\n+                    err_label_span,\n+                    format!(\n+                        \"consider changing this binding's type to be: `{message}`\"\n+                    ),\n+                );\n+            }\n+            }\n+            None => {}\n+        }\n+    }\n }\n \n pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n@@ -1160,25 +1167,18 @@ pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<\n     }\n }\n \n-fn suggest_ampmut_self<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    local_decl: &mir::LocalDecl<'tcx>,\n-) -> (Span, String) {\n-    let sp = local_decl.source_info.span;\n-    (\n-        sp,\n-        match tcx.sess.source_map().span_to_snippet(sp) {\n-            Ok(snippet) => {\n-                let lt_pos = snippet.find('\\'');\n-                if let Some(lt_pos) = lt_pos {\n-                    format!(\"&{}mut self\", &snippet[lt_pos..snippet.len() - 4])\n-                } else {\n-                    \"&mut self\".to_string()\n-                }\n+fn suggest_ampmut_self<'tcx>(tcx: TyCtxt<'tcx>, span: Span) -> String {\n+    match tcx.sess.source_map().span_to_snippet(span) {\n+        Ok(snippet) => {\n+            let lt_pos = snippet.find('\\'');\n+            if let Some(lt_pos) = lt_pos {\n+                format!(\"&{}mut self\", &snippet[lt_pos..snippet.len() - 4])\n+            } else {\n+                \"&mut self\".to_string()\n             }\n-            _ => \"&mut self\".to_string(),\n-        },\n-    )\n+        }\n+        _ => \"&mut self\".to_string(),\n+    }\n }\n \n // When we want to suggest a user change a local variable to be a `&mut`, there\n@@ -1198,72 +1198,89 @@ fn suggest_ampmut_self<'tcx>(\n // by trying (3.), then (2.) and finally falling back on (1.).\n fn suggest_ampmut<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    local_decl: &mir::LocalDecl<'tcx>,\n+    decl_ty: Ty<'tcx>,\n+    decl_span: Span,\n     opt_assignment_rhs_span: Option<Span>,\n     opt_ty_info: Option<Span>,\n ) -> (bool, Span, String) {\n+    // if there is a RHS and it starts with a `&` from it, then check if it is\n+    // mutable, and if not, put suggest putting `mut ` to make it mutable.\n+    // we don't have to worry about lifetime annotations here because they are\n+    // not valid when taking a reference. For example, the following is not valid Rust:\n+    //\n+    // let x: &i32 = &'a 5;\n+    //                ^^ lifetime annotation not allowed\n+    //\n     if let Some(assignment_rhs_span) = opt_assignment_rhs_span\n         && let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span)\n+        && let Some(stripped) = src.strip_prefix('&')\n     {\n-        let is_mutbl = |ty: &str| -> bool {\n-            if let Some(rest) = ty.strip_prefix(\"mut\") {\n-                match rest.chars().next() {\n-                    // e.g. `&mut x`\n-                    Some(c) if c.is_whitespace() => true,\n-                    // e.g. `&mut(x)`\n-                    Some('(') => true,\n-                    // e.g. `&mut{x}`\n-                    Some('{') => true,\n-                    // e.g. `&mutablevar`\n-                    _ => false,\n-                }\n-            } else {\n-                false\n+        let is_mut = if let Some(rest) = stripped.trim_start().strip_prefix(\"mut\") {\n+            match rest.chars().next() {\n+                // e.g. `&mut x`\n+                Some(c) if c.is_whitespace() => true,\n+                // e.g. `&mut(x)`\n+                Some('(') => true,\n+                // e.g. `&mut{x}`\n+                Some('{') => true,\n+                // e.g. `&mutablevar`\n+                _ => false,\n             }\n+        } else {\n+            false\n         };\n-        if let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace)) {\n-            let lt_name = &src[1..ws_pos];\n-            let ty = src[ws_pos..].trim_start();\n-            if !is_mutbl(ty) {\n-                return (true, assignment_rhs_span, format!(\"&{lt_name} mut {ty}\"));\n-            }\n-        } else if let Some(stripped) = src.strip_prefix('&') {\n-            let stripped = stripped.trim_start();\n-            if !is_mutbl(stripped) {\n-                return (true, assignment_rhs_span, format!(\"&mut {stripped}\"));\n-            }\n+        // if the reference is already mutable then there is nothing we can do\n+        // here.\n+        if !is_mut {\n+            let span = assignment_rhs_span;\n+            // shrink the span to just after the `&` in `&variable`\n+            let span = span.with_lo(span.lo() + BytePos(1)).shrink_to_lo();\n+\n+            // FIXME(Ezrashaw): returning is bad because we still might want to\n+            // update the annotated type, see #106857.\n+            return (true, span, \"mut \".to_owned());\n         }\n     }\n \n-    let (suggestibility, highlight_span) = match opt_ty_info {\n+    let (binding_exists, span) = match opt_ty_info {\n         // if this is a variable binding with an explicit type,\n-        // try to highlight that for the suggestion.\n+        // then we will suggest changing it to be mutable.\n+        // this is `Applicability::MachineApplicable`.\n         Some(ty_span) => (true, ty_span),\n \n-        // otherwise, just highlight the span associated with\n-        // the (MIR) LocalDecl.\n-        None => (false, local_decl.source_info.span),\n+        // otherwise, we'll suggest *adding* an annotated type, we'll suggest\n+        // the RHS's type for that.\n+        // this is `Applicability::HasPlaceholders`.\n+        None => (false, decl_span),\n     };\n \n-    if let Ok(src) = tcx.sess.source_map().span_to_snippet(highlight_span)\n-        && let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace))\n+    // if the binding already exists and is a reference with a explicit\n+    // lifetime, then we can suggest adding ` mut`. this is special-cased from\n+    // the path without a explicit lifetime.\n+    if let Ok(src) = tcx.sess.source_map().span_to_snippet(span)\n+        && src.starts_with(\"&'\")\n+        // note that `&     'a T` is invalid so this is correct.\n+        && let Some(ws_pos) = src.find(char::is_whitespace)\n     {\n-        let lt_name = &src[1..ws_pos];\n-        let ty = &src[ws_pos..];\n-        return (true, highlight_span, format!(\"&{lt_name} mut{ty}\"));\n-    }\n+        let span = span.with_lo(span.lo() + BytePos(ws_pos as u32)).shrink_to_lo();\n+        (true, span, \" mut\".to_owned())\n+    // if there is already a binding, we modify it to be `mut`\n+    } else if binding_exists {\n+        // shrink the span to just after the `&` in `&variable`\n+        let span = span.with_lo(span.lo() + BytePos(1)).shrink_to_lo();\n+        (true, span, \"mut \".to_owned())\n+    } else {\n+        // otherwise, suggest that the user annotates the binding; we provide the\n+        // type of the local.\n+        let ty_mut = decl_ty.builtin_deref(true).unwrap();\n+        assert_eq!(ty_mut.mutbl, hir::Mutability::Not);\n \n-    let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n-    assert_eq!(ty_mut.mutbl, hir::Mutability::Not);\n-    (\n-        suggestibility,\n-        highlight_span,\n-        if local_decl.ty.is_ref() {\n-            format!(\"&mut {}\", ty_mut.ty)\n-        } else {\n-            format!(\"*mut {}\", ty_mut.ty)\n-        },\n-    )\n+        (\n+            false,\n+            span,\n+            format!(\"{}mut {}\", if decl_ty.is_ref() {\"&\"} else {\"*\"}, ty_mut.ty)\n+        )\n+    }\n }\n \n fn is_closure_or_generator(ty: Ty<'_>) -> bool {\n@@ -1300,11 +1317,13 @@ fn get_mut_span_in_struct_field<'tcx>(\n }\n \n /// If possible, suggest replacing `ref` with `ref mut`.\n-fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<String> {\n-    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).ok()?;\n-    if hi_src.starts_with(\"ref\") && hi_src[\"ref\".len()..].starts_with(rustc_lexer::is_whitespace) {\n-        let replacement = format!(\"ref mut{}\", &hi_src[\"ref\".len()..]);\n-        Some(replacement)\n+fn suggest_ref_mut(tcx: TyCtxt<'_>, span: Span) -> Option<Span> {\n+    let pattern_str = tcx.sess.source_map().span_to_snippet(span).ok()?;\n+    if pattern_str.starts_with(\"ref\")\n+        && pattern_str[\"ref\".len()..].starts_with(rustc_lexer::is_whitespace)\n+    {\n+        let span = span.with_lo(span.lo() + BytePos(4)).shrink_to_lo();\n+        Some(span)\n     } else {\n         None\n     }"}, {"sha": "8ec872e205792b909a67e4bfec76711045c9ce2f", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -845,7 +845,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 return;\n             }\n \n-            let Some((alias_tys, alias_span)) = self\n+            let Some((alias_tys, alias_span, lt_addition_span)) = self\n                 .infcx\n                 .tcx\n                 .return_type_impl_or_dyn_traits_with_type_alias(suitable_region.def_id) else { return; };\n@@ -858,10 +858,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ()\n                 }\n                 if let TyKind::TraitObject(_, lt, _) = alias_ty.kind {\n-                    spans_suggs.push((lt.ident.span.shrink_to_hi(), \" + 'a\".to_string()));\n+                    if lt.ident.name == kw::Empty {\n+                        spans_suggs.push((lt.ident.span.shrink_to_hi(), \" + 'a\".to_string()));\n+                    } else {\n+                        spans_suggs.push((lt.ident.span, \"'a\".to_string()));\n+                    }\n                 }\n             }\n-            spans_suggs.push((alias_span.shrink_to_hi(), \"<'a>\".to_string()));\n+\n+            if let Some(lt_addition_span) = lt_addition_span {\n+                spans_suggs.push((lt_addition_span, \"'a, \".to_string()));\n+            } else {\n+                spans_suggs.push((alias_span.shrink_to_hi(), \"<'a>\".to_string()));\n+            }\n+\n             diag.multipart_suggestion_verbose(\n                 format!(\n                     \"to declare that the trait object {captures}, you can add a lifetime parameter `'a` in the type alias\""}, {"sha": "3b458b1d30ba7f7d7996bc31d317b6298620798e", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -150,10 +150,6 @@ builtin_macros_format_pos_mismatch = {$n} positional {$n ->\n     *[more] arguments\n     } in format string, but {$desc}\n \n-builtin_macros_offset_of_expected_field = expected field\n-\n-builtin_macros_offset_of_expected_two_args = expected 2 arguments\n-\n builtin_macros_test_case_non_item = `#[test_case]` attribute is only allowed on items\n \n builtin_macros_test_bad_fn = {$kind} functions cannot be used for tests"}, {"sha": "caced3d64472424159950b32052c5ef4b213f0cd", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1038,7 +1038,7 @@ impl<'a> MethodDef<'a> {\n     /// `&self.x` because that might cause an unaligned ref. So for any trait\n     /// method that takes a reference, we use a local block to force a copy.\n     /// This requires that the field impl `Copy`.\n-    /// ```\n+    /// ```rust,ignore (example)\n     /// # struct A { x: u8, y: u8 }\n     /// impl PartialEq for A {\n     ///     fn eq(&self, other: &A) -> bool {"}, {"sha": "4e5edb4d6b1dfd1906465a4a2c4d52168dca65b1", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -44,7 +44,6 @@ mod format;\n mod format_foreign;\n mod global_allocator;\n mod log_syntax;\n-mod offset_of;\n mod source_util;\n mod test;\n mod trace_macros;\n@@ -92,7 +91,6 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n         line: source_util::expand_line,\n         log_syntax: log_syntax::expand_log_syntax,\n         module_path: source_util::expand_mod,\n-        offset_of: offset_of::expand_offset_of,\n         option_env: env::expand_option_env,\n         core_panic: edition_panic::expand_panic,\n         std_panic: edition_panic::expand_panic,"}, {"sha": "0ef3e000e414c40c69fb87601320f8f07098957f", "filename": "compiler/rustc_builtin_macros/src/offset_of.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7fb4332ce452875b0f86dd62be0b1356e6d9537d/compiler%2Frustc_builtin_macros%2Fsrc%2Foffset_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb4332ce452875b0f86dd62be0b1356e6d9537d/compiler%2Frustc_builtin_macros%2Fsrc%2Foffset_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Foffset_of.rs?ref=7fb4332ce452875b0f86dd62be0b1356e6d9537d", "patch": "@@ -1,99 +0,0 @@\n-use rustc_ast as ast;\n-use rustc_ast::ptr::P;\n-use rustc_ast::token;\n-use rustc_ast::tokenstream::TokenStream;\n-use rustc_errors::PResult;\n-use rustc_expand::base::{self, *};\n-use rustc_macros::Diagnostic;\n-use rustc_parse::parser::Parser;\n-use rustc_span::{symbol::Ident, Span};\n-\n-#[derive(Diagnostic)]\n-#[diag(builtin_macros_offset_of_expected_field)]\n-struct ExpectedField {\n-    #[primary_span]\n-    span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(builtin_macros_offset_of_expected_two_args)]\n-struct ExpectedTwoArgs {\n-    #[primary_span]\n-    span: Span,\n-}\n-\n-fn parse_field<'a>(cx: &ExtCtxt<'a>, p: &mut Parser<'a>) -> PResult<'a, Ident> {\n-    let token = p.token.uninterpolate();\n-    let field = match token.kind {\n-        token::Ident(name, _) => Ident::new(name, token.span),\n-        token::Literal(token::Lit { kind: token::Integer, symbol, suffix: None }) => {\n-            Ident::new(symbol, token.span)\n-        }\n-        _ => return Err(cx.create_err(ExpectedField { span: p.token.span })),\n-    };\n-\n-    p.bump();\n-\n-    Ok(field)\n-}\n-\n-fn parse_args<'a>(\n-    cx: &mut ExtCtxt<'a>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> PResult<'a, (P<ast::Ty>, P<[Ident]>)> {\n-    let mut p = cx.new_parser_from_tts(tts);\n-\n-    let container = p.parse_ty()?;\n-\n-    p.expect(&token::Comma)?;\n-\n-    if p.eat(&token::Eof) {\n-        return Err(cx.create_err(ExpectedTwoArgs { span: sp }));\n-    }\n-\n-    let mut fields = Vec::new();\n-\n-    loop {\n-        let field = parse_field(cx, &mut p)?;\n-        fields.push(field);\n-\n-        if p.eat(&token::Dot) {\n-            continue;\n-        }\n-\n-        p.eat(&token::Comma);\n-\n-        if !p.eat(&token::Eof) {\n-            return Err(cx.create_err(ExpectedTwoArgs { span: sp }));\n-        }\n-\n-        break;\n-    }\n-\n-    Ok((container, fields.into()))\n-}\n-\n-pub fn expand_offset_of<'cx>(\n-    cx: &'cx mut ExtCtxt<'_>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Box<dyn base::MacResult + 'cx> {\n-    match parse_args(cx, sp, tts) {\n-        Ok((container, fields)) => {\n-            let expr = P(ast::Expr {\n-                id: ast::DUMMY_NODE_ID,\n-                kind: ast::ExprKind::OffsetOf(container, fields),\n-                span: sp,\n-                attrs: ast::AttrVec::new(),\n-                tokens: None,\n-            });\n-\n-            MacEager::expr(expr)\n-        }\n-        Err(mut err) => {\n-            err.emit();\n-            DummyResult::any(sp)\n-        }\n-    }\n-}"}, {"sha": "ccb3a0c4f27e4ef183f66396be5ad5c049add808", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -361,7 +361,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         self.instance.subst_mir_and_normalize_erasing_regions(\n             self.tcx,\n             ty::ParamEnv::reveal_all(),\n-            value,\n+            ty::EarlyBinder(value),\n         )\n     }\n "}, {"sha": "869344ce92d7de544b9d6090f86c5b872f4ad9ca", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1227,6 +1227,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         (value1, value2)\n     }\n \n+    fn filter_landing_pad(&mut self, pers_fn: RValue<'gcc>) -> (RValue<'gcc>, RValue<'gcc>) {\n+        // TODO(antoyo): generate the correct landing pad\n+        self.cleanup_landing_pad(pers_fn)\n+    }\n+\n     #[cfg(feature=\"master\")]\n     fn resume(&mut self, exn0: RValue<'gcc>, _exn1: RValue<'gcc>) {\n         let exn_type = exn0.get_type();"}, {"sha": "2a6ad1be76309f9a4e398179ee1048532ec0a233", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -236,7 +236,18 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 InlineAsmArch::Nvptx64 => {}\n                 InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {}\n                 InlineAsmArch::Hexagon => {}\n-                InlineAsmArch::LoongArch64 => {}\n+                InlineAsmArch::LoongArch64 => {\n+                    constraints.extend_from_slice(&[\n+                        \"~{$fcc0}\".to_string(),\n+                        \"~{$fcc1}\".to_string(),\n+                        \"~{$fcc2}\".to_string(),\n+                        \"~{$fcc3}\".to_string(),\n+                        \"~{$fcc4}\".to_string(),\n+                        \"~{$fcc5}\".to_string(),\n+                        \"~{$fcc6}\".to_string(),\n+                        \"~{$fcc7}\".to_string(),\n+                    ]);\n+                }\n                 InlineAsmArch::Mips | InlineAsmArch::Mips64 => {}\n                 InlineAsmArch::S390x => {\n                     constraints.push(\"~{cc}\".to_string());"}, {"sha": "4d0bcd53d15624b3a2f7b91281d33f8c19b8a56c", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -985,13 +985,20 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn cleanup_landing_pad(&mut self, pers_fn: &'ll Value) -> (&'ll Value, &'ll Value) {\n         let ty = self.type_struct(&[self.type_i8p(), self.type_i32()], false);\n-        let landing_pad = self.landing_pad(ty, pers_fn, 1 /* FIXME should this be 0? */);\n+        let landing_pad = self.landing_pad(ty, pers_fn, 0);\n         unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n         (self.extract_value(landing_pad, 0), self.extract_value(landing_pad, 1))\n     }\n \n+    fn filter_landing_pad(&mut self, pers_fn: &'ll Value) -> (&'ll Value, &'ll Value) {\n+        let ty = self.type_struct(&[self.type_i8p(), self.type_i32()], false);\n+        let landing_pad = self.landing_pad(ty, pers_fn, 1);\n+        self.add_clause(landing_pad, self.const_array(self.type_i8p(), &[]));\n+        (self.extract_value(landing_pad, 0), self.extract_value(landing_pad, 1))\n+    }\n+\n     fn resume(&mut self, exn0: &'ll Value, exn1: &'ll Value) {\n         let ty = self.type_struct(&[self.type_i8p(), self.type_i32()], false);\n         let mut exn = self.const_poison(ty);"}, {"sha": "3fff112a02056ac970bd23cbd42e93a7294e4e8d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -93,7 +93,7 @@ fn make_mir_scope<'ll, 'tcx>(\n             let callee = cx.tcx.subst_and_normalize_erasing_regions(\n                 instance.substs,\n                 ty::ParamEnv::reveal_all(),\n-                callee,\n+                ty::EarlyBinder(callee),\n             );\n             let callee_fn_abi = cx.fn_abi_of_instance(callee, ty::List::empty());\n             cx.dbg_scope_fn(callee, callee_fn_abi, None)"}, {"sha": "c3f0a0033b0eadcfbbd5eca07efeddf0b6a78c49", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -529,7 +529,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     let impl_self_ty = cx.tcx.subst_and_normalize_erasing_regions(\n                         instance.substs,\n                         ty::ParamEnv::reveal_all(),\n-                        cx.tcx.type_of(impl_def_id).skip_binder(),\n+                        cx.tcx.type_of(impl_def_id),\n                     );\n \n                     // Only \"class\" methods are generally understood by LLVM,"}, {"sha": "8968133bac5ba0cdf55b31f1d203736a146b7ef7", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -12,6 +12,7 @@ use object::{\n \n use snap::write::FrameEncoder;\n \n+use object::elf::NT_GNU_PROPERTY_TYPE_0;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owned_slice::try_slice_owned;\n use rustc_data_structures::sync::MetadataRef;\n@@ -93,6 +94,54 @@ pub(super) fn search_for_section<'a>(\n         .map_err(|e| format!(\"failed to read {} section in '{}': {}\", section, path.display(), e))\n }\n \n+fn add_gnu_property_note(\n+    file: &mut write::Object<'static>,\n+    architecture: Architecture,\n+    binary_format: BinaryFormat,\n+    endianness: Endianness,\n+) {\n+    // check bti protection\n+    if binary_format != BinaryFormat::Elf\n+        || !matches!(architecture, Architecture::X86_64 | Architecture::Aarch64)\n+    {\n+        return;\n+    }\n+\n+    let section = file.add_section(\n+        file.segment_name(StandardSegment::Data).to_vec(),\n+        b\".note.gnu.property\".to_vec(),\n+        SectionKind::Note,\n+    );\n+    let mut data: Vec<u8> = Vec::new();\n+    let n_namsz: u32 = 4; // Size of the n_name field\n+    let n_descsz: u32 = 16; // Size of the n_desc field\n+    let n_type: u32 = NT_GNU_PROPERTY_TYPE_0; // Type of note descriptor\n+    let header_values = [n_namsz, n_descsz, n_type];\n+    header_values.iter().for_each(|v| {\n+        data.extend_from_slice(&match endianness {\n+            Endianness::Little => v.to_le_bytes(),\n+            Endianness::Big => v.to_be_bytes(),\n+        })\n+    });\n+    data.extend_from_slice(b\"GNU\\0\"); // Owner of the program property note\n+    let pr_type: u32 = match architecture {\n+        Architecture::X86_64 => 0xc0000002,\n+        Architecture::Aarch64 => 0xc0000000,\n+        _ => unreachable!(),\n+    };\n+    let pr_datasz: u32 = 4; //size of the pr_data field\n+    let pr_data: u32 = 3; //program property descriptor\n+    let pr_padding: u32 = 0;\n+    let property_values = [pr_type, pr_datasz, pr_data, pr_padding];\n+    property_values.iter().for_each(|v| {\n+        data.extend_from_slice(&match endianness {\n+            Endianness::Little => v.to_le_bytes(),\n+            Endianness::Big => v.to_be_bytes(),\n+        })\n+    });\n+    file.append_section_data(section, &data, 8);\n+}\n+\n pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static>> {\n     let endianness = match sess.target.options.endian {\n         Endian::Little => Endianness::Little,\n@@ -205,6 +254,7 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n         _ => elf::ELFOSABI_NONE,\n     };\n     let abi_version = 0;\n+    add_gnu_property_note(&mut file, architecture, binary_format, endianness);\n     file.flags = FileFlags::Elf { os_abi, abi_version, e_flags };\n     Some(file)\n }"}, {"sha": "a832999225ab667c89212c885313f3e0ab91e3c1", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1600,7 +1600,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx = Bx::build(self.cx, llbb);\n \n                 let llpersonality = self.cx.eh_personality();\n-                bx.cleanup_landing_pad(llpersonality);\n+                bx.filter_landing_pad(llpersonality);\n \n                 funclet = None;\n             }"}, {"sha": "1204c99e533e277880039c5c40fbfb407e68ee69", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.instance.subst_mir_and_normalize_erasing_regions(\n             self.cx.tcx(),\n             ty::ParamEnv::reveal_all(),\n-            value,\n+            ty::EarlyBinder(value),\n         )\n     }\n }"}, {"sha": "853c6934c2c243b68ab7797c7650dadb04abfb8e", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -274,6 +274,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     // These are used by everyone except msvc\n     fn cleanup_landing_pad(&mut self, pers_fn: Self::Value) -> (Self::Value, Self::Value);\n+    fn filter_landing_pad(&mut self, pers_fn: Self::Value) -> (Self::Value, Self::Value);\n     fn resume(&mut self, exn0: Self::Value, exn1: Self::Value);\n \n     // These are used only by msvc"}, {"sha": "b2197a0aabbfe0d8dc4275e6fab1228195d59a65", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -495,7 +495,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> Result<T, InterpError<'tcx>> {\n         frame\n             .instance\n-            .try_subst_mir_and_normalize_erasing_regions(*self.tcx, self.param_env, value)\n+            .try_subst_mir_and_normalize_erasing_regions(\n+                *self.tcx,\n+                self.param_env,\n+                ty::EarlyBinder(value),\n+            )\n             .map_err(|_| err_inval!(TooGeneric))\n     }\n "}, {"sha": "311a42aa42a3d5f2cdbea48bbcd33fab2d32e299", "filename": "compiler/rustc_data_structures/src/owned_slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -109,9 +109,11 @@ impl Borrow<[u8]> for OwnedSlice {\n }\n \n // Safety: `OwnedSlice` is conceptually `(&'self.1 [u8], Box<dyn Send + Sync>)`, which is `Send`\n+#[cfg(parallel_compiler)]\n unsafe impl Send for OwnedSlice {}\n \n // Safety: `OwnedSlice` is conceptually `(&'self.1 [u8], Box<dyn Send + Sync>)`, which is `Sync`\n+#[cfg(parallel_compiler)]\n unsafe impl Sync for OwnedSlice {}\n \n #[cfg(test)]"}, {"sha": "5e13e7c8aafc8187a4876e65d44f0a069675175d", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -101,7 +101,7 @@ use parking_lot::RwLock;\n use smallvec::SmallVec;\n \n bitflags::bitflags! {\n-    struct EventFilter: u32 {\n+    struct EventFilter: u16 {\n         const GENERIC_ACTIVITIES  = 1 << 0;\n         const QUERY_PROVIDERS     = 1 << 1;\n         const QUERY_CACHE_HITS    = 1 << 2;"}, {"sha": "d7d97fcc3e7b7154382bcc6513e245e2576a05dd", "filename": "compiler/rustc_driver_impl/Cargo.toml", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_driver_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_driver_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FCargo.toml?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -51,6 +51,7 @@ rustc_interface = { path = \"../rustc_interface\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n+rustc_mir_transform = { path = \"../rustc_mir_transform\" }\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2\"\n@@ -64,5 +65,8 @@ features = [\n [features]\n llvm = ['rustc_interface/llvm']\n max_level_info = ['rustc_log/max_level_info']\n-rustc_use_parallel_compiler = ['rustc_data_structures/rustc_use_parallel_compiler', 'rustc_interface/rustc_use_parallel_compiler',\n-    'rustc_middle/rustc_use_parallel_compiler']\n+rustc_use_parallel_compiler = [\n+    'rustc_data_structures/rustc_use_parallel_compiler',\n+    'rustc_interface/rustc_use_parallel_compiler',\n+    'rustc_middle/rustc_use_parallel_compiler'\n+]"}, {"sha": "9b16f246193f783a1f993b96f90528b0d9eb3b55", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -99,6 +99,7 @@ pub static DEFAULT_LOCALE_RESOURCES: &[&str] = &[\n     rustc_middle::DEFAULT_LOCALE_RESOURCE,\n     rustc_mir_build::DEFAULT_LOCALE_RESOURCE,\n     rustc_mir_dataflow::DEFAULT_LOCALE_RESOURCE,\n+    rustc_mir_transform::DEFAULT_LOCALE_RESOURCE,\n     rustc_monomorphize::DEFAULT_LOCALE_RESOURCE,\n     rustc_parse::DEFAULT_LOCALE_RESOURCE,\n     rustc_passes::DEFAULT_LOCALE_RESOURCE,\n@@ -745,6 +746,22 @@ fn print_crate_info(\n                     }\n                 }\n             }\n+            DeploymentTarget => {\n+                use rustc_target::spec::current_apple_deployment_target;\n+\n+                if sess.target.is_like_osx {\n+                    safe_println!(\n+                        \"deployment_target={}\",\n+                        current_apple_deployment_target(&sess.target)\n+                            .expect(\"unknown Apple target OS\")\n+                    )\n+                } else {\n+                    early_error(\n+                        ErrorOutputType::default(),\n+                        \"only Apple targets currently support deployment version info\",\n+                    )\n+                }\n+            }\n         }\n     }\n     Compilation::Stop"}, {"sha": "4f36590025bae4e6d66001a524e7730c203cc2d4", "filename": "compiler/rustc_error_codes/src/error_codes/E0771.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0771.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0771.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0771.md?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,9 +1,11 @@\n+#### Note: this error code is no longer emitted by the compiler\n+\n A non-`'static` lifetime was used in a const generic. This is currently not\n allowed.\n \n Erroneous code example:\n \n-```compile_fail,E0771\n+```compile_fail,E0770\n #![feature(adt_const_params)]\n \n fn function_with_str<'a, const STRING: &'a str>() {} // error!"}, {"sha": "db97d96fccd181eeb8cd156f7f6fb3ad3441532d", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -571,6 +571,14 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         Some((diagnostic, handler))\n     }\n \n+    /// Retrieves the [`Handler`] if available\n+    pub fn handler(&self) -> Option<&Handler> {\n+        match self.inner.state {\n+            DiagnosticBuilderState::Emittable(handler) => Some(handler),\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => None,\n+        }\n+    }\n+\n     /// Buffers the diagnostic for later emission,\n     /// unless handler has disabled such buffering.\n     pub fn buffer(self, buffered_diagnostics: &mut Vec<Diagnostic>) {"}, {"sha": "f4615445f8e9bb6947cda99b803c5d2a3a767f17", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -313,6 +313,8 @@ declare_features! (\n     (active, async_closure, \"1.37.0\", Some(62290), None),\n     /// Allows async functions to be declared, implemented, and used in traits.\n     (active, async_fn_in_trait, \"1.66.0\", Some(91611), None),\n+    /// Allows builtin # foo() syntax\n+    (active, builtin_syntax, \"CURRENT_RUSTC_VERSION\", Some(110680), None),\n     /// Allows `c\"foo\"` literals.\n     (active, c_str_literals, \"CURRENT_RUSTC_VERSION\", Some(105723), None),\n     /// Treat `extern \"C\"` function as nounwind."}, {"sha": "5d86d895817554a79496229867ce85f8f26d14ed", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -167,7 +167,7 @@\n //!     fn node_label(&self, n: &Nd) -> dot::LabelText<'_> {\n //!         dot::LabelText::LabelStr(self.nodes[*n].into())\n //!     }\n-//!     fn edge_label<'b>(&'b self, _: &Ed) -> dot::LabelText<'b> {\n+//!     fn edge_label(&self, _: &Ed<'_>) -> dot::LabelText<'_> {\n //!         dot::LabelText::LabelStr(\"&sube;\".into())\n //!     }\n //! }\n@@ -177,8 +177,8 @@\n //!     type Edge = Ed<'a>;\n //!     fn nodes(&self) -> dot::Nodes<'a,Nd> { (0..self.nodes.len()).collect() }\n //!     fn edges(&'a self) -> dot::Edges<'a,Ed<'a>> { self.edges.iter().collect() }\n-//!     fn source(&self, e: &Ed) -> Nd { let & &(s,_) = e; s }\n-//!     fn target(&self, e: &Ed) -> Nd { let & &(_,t) = e; t }\n+//!     fn source(&self, e: &Ed<'_>) -> Nd { let & &(s,_) = e; s }\n+//!     fn target(&self, e: &Ed<'_>) -> Nd { let & &(_,t) = e; t }\n //! }\n //!\n //! # pub fn main() { render_to(&mut Vec::new()) }\n@@ -226,11 +226,11 @@\n //!     fn node_id(&'a self, n: &Nd<'a>) -> dot::Id<'a> {\n //!         dot::Id::new(format!(\"N{}\", n.0)).unwrap()\n //!     }\n-//!     fn node_label<'b>(&'b self, n: &Nd<'b>) -> dot::LabelText<'b> {\n+//!     fn node_label(&self, n: &Nd<'_>) -> dot::LabelText<'_> {\n //!         let &(i, _) = n;\n //!         dot::LabelText::LabelStr(self.nodes[i].into())\n //!     }\n-//!     fn edge_label<'b>(&'b self, _: &Ed<'b>) -> dot::LabelText<'b> {\n+//!     fn edge_label(&self, _: &Ed<'_>) -> dot::LabelText<'_> {\n //!         dot::LabelText::LabelStr(\"&sube;\".into())\n //!     }\n //! }"}, {"sha": "5e5c984a7ea15e75d302c0c2373e70f9365b20c1", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -279,6 +279,9 @@ hir_analysis_specialization_trait = implementing `rustc_specialization_trait` tr\n hir_analysis_closure_implicit_hrtb = implicit types in closure signatures are forbidden when `for<...>` is present\n     .label = `for<...>` is here\n \n+hir_analysis_empty_specialization = specialization impl does not specialize any associated items\n+    .note = impl is a specialization of this impl\n+\n hir_analysis_const_specialize = cannot specialize on const impl with non-const impl\n \n hir_analysis_static_specialize = cannot specialize on `'static` lifetime"}, {"sha": "6ac1df6a079287c8779394fbd684c1bcfa54535f", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -2419,6 +2419,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             return Ok(None);\n         }\n \n+        //\n+        // Select applicable inherent associated type candidates modulo regions.\n+        //\n+\n         // In contexts that have no inference context, just make a new one.\n         // We do need a local variable to store it, though.\n         let infcx_;\n@@ -2431,14 +2435,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         };\n \n-        let param_env = tcx.param_env(block.owner.to_def_id());\n+        // FIXME(inherent_associated_types): Acquiring the ParamEnv this early leads to cycle errors\n+        // when inside of an ADT (#108491) or where clause.\n+        let param_env = tcx.param_env(block.owner);\n         let cause = ObligationCause::misc(span, block.owner.def_id);\n \n         let mut fulfillment_errors = Vec::new();\n         let mut applicable_candidates: Vec<_> = infcx.probe(|_| {\n             let universe = infcx.create_next_universe();\n \n             // Regions are not considered during selection.\n+            // FIXME(non_lifetime_binders): Here we are \"truncating\" or \"flattening\" the universes\n+            // of type and const binders. Is that correct in the selection phase? See also #109505.\n             let self_ty = tcx.replace_escaping_bound_vars_uncached(\n                 self_ty,\n                 FnMutDelegate {\n@@ -2454,41 +2462,40 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             candidates\n                 .iter()\n-                .filter_map(|&(impl_, (assoc_item, def_scope))| {\n+                .copied()\n+                .filter(|&(impl_, _)| {\n                     infcx.probe(|_| {\n                         let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n \n-                        let impl_ty = tcx.type_of(impl_);\n                         let impl_substs = infcx.fresh_item_substs(impl_);\n-                        let impl_ty = impl_ty.subst(tcx, impl_substs);\n+                        let impl_ty = tcx.type_of(impl_).subst(tcx, impl_substs);\n                         let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n \n-                        // Check that the Self-types can be related.\n-                        // FIXME(fmease): Should we use `eq` here?\n-                        ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n+                        // Check that the self types can be related.\n+                        // FIXME(inherent_associated_types): Should we use `eq` here? Method probing uses\n+                        // `sup` for this situtation, too. What for? To constrain inference variables?\n+                        if ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).is_err()\n+                        {\n+                            return false;\n+                        }\n \n                         // Check whether the impl imposes obligations we have to worry about.\n-                        let impl_bounds = tcx.predicates_of(impl_);\n-                        let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n-\n+                        let impl_bounds = tcx.predicates_of(impl_).instantiate(tcx, impl_substs);\n                         let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n-\n                         let impl_obligations = traits::predicates_for_generics(\n                             |_, _| cause.clone(),\n                             param_env,\n                             impl_bounds,\n                         );\n-\n                         ocx.register_obligations(impl_obligations);\n \n                         let mut errors = ocx.select_where_possible();\n                         if !errors.is_empty() {\n                             fulfillment_errors.append(&mut errors);\n-                            return None;\n+                            return false;\n                         }\n \n-                        // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n-                        Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                        true\n                     })\n                 })\n                 .collect()\n@@ -2497,24 +2504,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if applicable_candidates.len() > 1 {\n             return Err(self.complain_about_ambiguous_inherent_assoc_type(\n                 name,\n-                applicable_candidates.into_iter().map(|(candidate, ..)| candidate).collect(),\n+                applicable_candidates.into_iter().map(|(_, (candidate, _))| candidate).collect(),\n                 span,\n             ));\n         }\n \n-        if let Some((assoc_item, def_scope, impl_substs)) = applicable_candidates.pop() {\n+        if let Some((impl_, (assoc_item, def_scope))) = applicable_candidates.pop() {\n             self.check_assoc_ty(assoc_item, name, def_scope, block, span);\n \n-            // FIXME(inherent_associated_types): To fully *confirm* the *probed* candidate, we still\n-            // need to relate the Self-type with fresh item substs & register region obligations for\n-            // regionck to prove/disprove.\n-\n-            let item_substs =\n-                self.create_substs_for_associated_item(span, assoc_item, segment, impl_substs);\n+            // FIXME(fmease): Currently creating throwaway `parent_substs` to please\n+            // `create_substs_for_associated_item`. Modify the latter instead (or sth. similar) to\n+            // not require the parent substs logic.\n+            let parent_substs = InternalSubsts::identity_for_item(tcx, impl_);\n+            let substs =\n+                self.create_substs_for_associated_item(span, assoc_item, segment, parent_substs);\n+            let substs = tcx.mk_substs_from_iter(\n+                std::iter::once(ty::GenericArg::from(self_ty))\n+                    .chain(substs.into_iter().skip(parent_substs.len())),\n+            );\n \n-            // FIXME(fmease, #106722): Check if the bounds on the parameters of the\n-            // associated type hold, if any.\n-            let ty = tcx.type_of(assoc_item).subst(tcx, item_substs);\n+            let ty = tcx.mk_alias(ty::Inherent, tcx.mk_alias_ty(assoc_item, substs));\n \n             return Ok(Some((ty, assoc_item)));\n         }"}, {"sha": "8bf1e0e84a4fa869cfec816b4fdaffe4e4d14457", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -60,19 +60,21 @@ pub(super) fn compare_impl_method<'tcx>(\n     };\n }\n \n-/// This function is best explained by example. Consider a trait:\n+/// This function is best explained by example. Consider a trait with it's implementation:\n ///\n-///     trait Trait<'t, T> {\n-///         // `trait_m`\n-///         fn method<'a, M>(t: &'t T, m: &'a M) -> Self;\n-///     }\n+/// ```rust\n+/// trait Trait<'t, T> {\n+///     // `trait_m`\n+///     fn method<'a, M>(t: &'t T, m: &'a M) -> Self;\n+/// }\n ///\n-/// And an impl:\n+/// struct Foo;\n ///\n-///     impl<'i, 'j, U> Trait<'j, &'i U> for Foo {\n-///          // `impl_m`\n-///          fn method<'b, N>(t: &'j &'i U, m: &'b N) -> Foo;\n-///     }\n+/// impl<'i, 'j, U> Trait<'j, &'i U> for Foo {\n+///     // `impl_m`\n+///     fn method<'b, N>(t: &'j &'i U, m: &'b N) -> Foo { Foo }\n+/// }\n+/// ```\n ///\n /// We wish to decide if those two method types are compatible.\n /// For this we have to show that, assuming the bounds of the impl hold, the\n@@ -82,7 +84,9 @@ pub(super) fn compare_impl_method<'tcx>(\n /// type parameters to impl type parameters. This is taken from the\n /// impl trait reference:\n ///\n-///     trait_to_impl_substs = {'t => 'j, T => &'i U, Self => Foo}\n+/// ```rust,ignore (pseudo-Rust)\n+/// trait_to_impl_substs = {'t => 'j, T => &'i U, Self => Foo}\n+/// ```\n ///\n /// We create a mapping `dummy_substs` that maps from the impl type\n /// parameters to fresh types and regions. For type parameters,\n@@ -91,13 +95,17 @@ pub(super) fn compare_impl_method<'tcx>(\n /// regions (Note: but only early-bound regions, i.e., those\n /// declared on the impl or used in type parameter bounds).\n ///\n-///     impl_to_placeholder_substs = {'i => 'i0, U => U0, N => N0 }\n+/// ```rust,ignore (pseudo-Rust)\n+/// impl_to_placeholder_substs = {'i => 'i0, U => U0, N => N0 }\n+/// ```\n ///\n /// Now we can apply `placeholder_substs` to the type of the impl method\n /// to yield a new function type in terms of our fresh, placeholder\n /// types:\n ///\n-///     <'b> fn(t: &'i0 U0, m: &'b) -> Foo\n+/// ```rust,ignore (pseudo-Rust)\n+/// <'b> fn(t: &'i0 U0, m: &'b) -> Foo\n+/// ```\n ///\n /// We now want to extract and substitute the type of the *trait*\n /// method and compare it. To do so, we must create a compound\n@@ -106,11 +114,15 @@ pub(super) fn compare_impl_method<'tcx>(\n /// type parameters. We extend the mapping to also include\n /// the method parameters.\n ///\n-///     trait_to_placeholder_substs = { T => &'i0 U0, Self => Foo, M => N0 }\n+/// ```rust,ignore (pseudo-Rust)\n+/// trait_to_placeholder_substs = { T => &'i0 U0, Self => Foo, M => N0 }\n+/// ```\n ///\n /// Applying this to the trait method type yields:\n ///\n-///     <'a> fn(t: &'i0 U0, m: &'a) -> Foo\n+/// ```rust,ignore (pseudo-Rust)\n+/// <'a> fn(t: &'i0 U0, m: &'a) -> Foo\n+/// ```\n ///\n /// This type is also the same but the name of the bound region (`'a`\n /// vs `'b`). However, the normal subtyping rules on fn types handle\n@@ -1163,7 +1175,7 @@ fn compare_self_type<'tcx>(\n /// as the number of generics on the respective assoc item in the trait definition.\n ///\n /// For example this code emits the errors in the following code:\n-/// ```\n+/// ```rust,compile_fail\n /// trait Trait {\n ///     fn foo();\n ///     type Assoc<T>;\n@@ -1547,7 +1559,7 @@ fn compare_synthetic_generics<'tcx>(\n /// the same kind as the respective generic parameter in the trait def.\n ///\n /// For example all 4 errors in the following code are emitted here:\n-/// ```\n+/// ```rust,ignore (pseudo-Rust)\n /// trait Foo {\n ///     fn foo<const N: u8>();\n ///     type bar<const N: u8>;"}, {"sha": "272177dfbd0f858ea5bc562e4ad6bda2d2255cd0", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -210,6 +210,19 @@ fn do_orphan_check_impl<'tcx>(\n                 NonlocalImpl::DisallowOther,\n             ),\n \n+            // ```\n+            // struct S<T>(T);\n+            // impl<T: ?Sized> S<T> {\n+            //     type This = T;\n+            // }\n+            // impl<T: ?Sized> AutoTrait for S<T>::This {}\n+            // ```\n+            // FIXME(inherent_associated_types): The example code above currently leads to a cycle\n+            ty::Alias(AliasKind::Inherent, _) => (\n+                LocalImpl::Disallow { problematic_kind: \"associated type\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n             // type Opaque = impl Trait;\n             // impl AutoTrait for Opaque {}\n             ty::Alias(AliasKind::Opaque, _) => ("}, {"sha": "ab2932bf969ad9c0980bc08c4a993ff86890bbed", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -51,7 +51,15 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Generics {\n                 // of a const parameter type, e.g. `struct Foo<const N: usize, const M: [u8; N]>` is not allowed.\n                 None\n             } else if tcx.lazy_normalization() {\n-                if let Some(param_id) = tcx.hir().opt_const_param_default_param_def_id(hir_id) {\n+                let parent_node = tcx.hir().get_parent(hir_id);\n+                if let Node::Variant(Variant { disr_expr: Some(constant), .. }) = parent_node\n+                    && constant.hir_id == hir_id\n+                {\n+                    // enum variant discriminants are not allowed to use any kind of generics\n+                    None\n+                } else if let Some(param_id) =\n+                    tcx.hir().opt_const_param_default_param_def_id(hir_id)\n+                {\n                     // If the def_id we are calling generics_of on is an anon ct default i.e:\n                     //\n                     // struct Foo<const N: usize = { .. }>;\n@@ -94,15 +102,15 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Generics {\n                         has_self: generics.has_self,\n                         has_late_bound_regions: generics.has_late_bound_regions,\n                     };\n+                } else {\n+                    // HACK(eddyb) this provides the correct generics when\n+                    // `feature(generic_const_expressions)` is enabled, so that const expressions\n+                    // used with const generics, e.g. `Foo<{N+1}>`, can work at all.\n+                    //\n+                    // Note that we do not supply the parent generics when using\n+                    // `min_const_generics`.\n+                    Some(parent_def_id.to_def_id())\n                 }\n-\n-                // HACK(eddyb) this provides the correct generics when\n-                // `feature(generic_const_expressions)` is enabled, so that const expressions\n-                // used with const generics, e.g. `Foo<{N+1}>`, can work at all.\n-                //\n-                // Note that we do not supply the parent generics when using\n-                // `min_const_generics`.\n-                Some(parent_def_id.to_def_id())\n             } else {\n                 let parent_node = tcx.hir().get_parent(hir_id);\n                 match parent_node {\n@@ -115,11 +123,6 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Generics {\n                     {\n                         Some(parent_def_id.to_def_id())\n                     }\n-                    Node::Variant(Variant { disr_expr: Some(constant), .. })\n-                        if constant.hir_id == hir_id =>\n-                    {\n-                        Some(parent_def_id.to_def_id())\n-                    }\n                     Node::Expr(&Expr { kind: ExprKind::ConstBlock(_), .. }) => {\n                         Some(tcx.typeck_root_def_id(def_id.to_def_id()))\n                     }"}, {"sha": "e04658c8e774e578d076f9a861a187a00832bd64", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -657,14 +657,15 @@ pub(super) fn implied_predicates_with_filter(\n         &*tcx.arena.alloc_from_iter(superbounds.predicates().chain(where_bounds_that_match));\n     debug!(?implied_bounds);\n \n-    // Now require that immediate supertraits are converted,\n-    // which will, in turn, reach indirect supertraits.\n+    // Now require that immediate supertraits are converted, which will, in\n+    // turn, reach indirect supertraits, so we detect cycles now instead of\n+    // overflowing during elaboration.\n     if matches!(filter, PredicateFilter::SelfOnly) {\n-        // Now require that immediate supertraits are converted,\n-        // which will, in turn, reach indirect supertraits.\n         for &(pred, span) in implied_bounds {\n             debug!(\"superbound: {:?}\", pred);\n-            if let ty::PredicateKind::Clause(ty::Clause::Trait(bound)) = pred.kind().skip_binder() {\n+            if let ty::PredicateKind::Clause(ty::Clause::Trait(bound)) = pred.kind().skip_binder()\n+                && bound.polarity == ty::ImplPolarity::Positive\n+            {\n                 tcx.at(span).super_predicates_of(bound.def_id());\n             }\n         }"}, {"sha": "5c7f7f10b17ecc2cd1b3f8b3f59bd23eb67ad90e", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1923,7 +1923,7 @@ fn is_late_bound_map(\n     /// handles cycle detection as we go through the query system.\n     ///\n     /// This is necessary in the first place for the following case:\n-    /// ```\n+    /// ```rust,ignore (pseudo-Rust)\n     /// type Alias<'a, T> = <T as Trait<'a>>::Assoc;\n     /// fn foo<'a>(_: Alias<'a, ()>) -> Alias<'a, ()> { ... }\n     /// ```\n@@ -1948,7 +1948,7 @@ fn is_late_bound_map(\n                 ty::Param(param_ty) => {\n                     self.arg_is_constrained[param_ty.index as usize] = true;\n                 }\n-                ty::Alias(ty::Projection, _) => return ControlFlow::Continue(()),\n+                ty::Alias(ty::Projection | ty::Inherent, _) => return ControlFlow::Continue(()),\n                 _ => (),\n             }\n             t.super_visit_with(self)"}, {"sha": "8df0166f76b4b269c8f97d2760f914b927423eef", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -127,7 +127,7 @@ fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n             // the def_id that this query was called with. We filter to only type and const args here\n             // as a precaution for if it's ever allowed to elide lifetimes in GAT's. It currently isn't\n             // but it can't hurt to be safe ^^\n-            if let ty::Alias(ty::Projection, projection) = ty.kind() {\n+            if let ty::Alias(ty::Projection | ty::Inherent, projection) = ty.kind() {\n                 let generics = tcx.generics_of(projection.def_id);\n \n                 let arg_index = segment"}, {"sha": "9200c2aecf55c07699e9bcdf1f289ea64d2d6977", "filename": "compiler/rustc_hir_analysis/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -59,7 +59,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *t.kind() {\n-            ty::Alias(ty::Projection, ..) if !self.include_nonconstraining => {\n+            ty::Alias(ty::Projection | ty::Inherent, ..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return ControlFlow::Continue(());\n             }"}, {"sha": "6e7eb4f6cdcd8eba1fc0cfbf8e3654a2126bb76e", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -814,6 +814,15 @@ pub(crate) struct ClosureImplicitHrtb {\n     pub for_sp: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_empty_specialization)]\n+pub(crate) struct EmptySpecialization {\n+    #[primary_span]\n+    pub span: Span,\n+    #[note]\n+    pub base_impl_span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(hir_analysis_const_specialize)]\n pub(crate) struct ConstSpecialize {"}, {"sha": "e84da2519ae812bce3b4a48c17dcb65948517ef5", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -80,7 +80,7 @@ use rustc_middle::ty::{self, TyCtxt, TypeVisitableExt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n-use rustc_trait_selection::traits::{self, translate_substs, wf, ObligationCtxt};\n+use rustc_trait_selection::traits::{self, translate_substs_with_cause, wf, ObligationCtxt};\n \n pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) {\n     if let Some(node) = parent_specialization_node(tcx, impl_def_id) {\n@@ -100,12 +100,19 @@ fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId) -> Opti\n         // Implementing a normal trait isn't a specialization.\n         return None;\n     }\n+    if trait_def.is_marker {\n+        // Overlapping marker implementations are not really specializations.\n+        return None;\n+    }\n     Some(impl2_node)\n }\n \n /// Check that `impl1` is a sound specialization\n #[instrument(level = \"debug\", skip(tcx))]\n fn check_always_applicable(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node) {\n+    let span = tcx.def_span(impl1_def_id);\n+    check_has_items(tcx, impl1_def_id, impl2_node, span);\n+\n     if let Some((impl1_substs, impl2_substs)) = get_impl_substs(tcx, impl1_def_id, impl2_node) {\n         let impl2_def_id = impl2_node.def_id();\n         debug!(?impl2_def_id, ?impl2_substs);\n@@ -116,14 +123,20 @@ fn check_always_applicable(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node\n             unconstrained_parent_impl_substs(tcx, impl2_def_id, impl2_substs)\n         };\n \n-        let span = tcx.def_span(impl1_def_id);\n         check_constness(tcx, impl1_def_id, impl2_node, span);\n         check_static_lifetimes(tcx, &parent_substs, span);\n         check_duplicate_params(tcx, impl1_substs, &parent_substs, span);\n         check_predicates(tcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n     }\n }\n \n+fn check_has_items(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node, span: Span) {\n+    if let Node::Impl(impl2_id) = impl2_node && tcx.associated_item_def_ids(impl1_def_id).is_empty() {\n+        let base_impl_span = tcx.def_span(impl2_id);\n+        tcx.sess.emit_err(errors::EmptySpecialization { span, base_impl_span });\n+    }\n+}\n+\n /// Check that the specializing impl `impl1` is at least as const as the base\n /// impl `impl2`\n fn check_constness(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node, span: Span) {\n@@ -167,8 +180,21 @@ fn get_impl_substs(\n         ocx.assumed_wf_types(param_env, tcx.def_span(impl1_def_id), impl1_def_id);\n \n     let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id);\n-    let impl2_substs =\n-        translate_substs(infcx, param_env, impl1_def_id.to_def_id(), impl1_substs, impl2_node);\n+    let impl1_span = tcx.def_span(impl1_def_id);\n+    let impl2_substs = translate_substs_with_cause(\n+        infcx,\n+        param_env,\n+        impl1_def_id.to_def_id(),\n+        impl1_substs,\n+        impl2_node,\n+        |_, span| {\n+            traits::ObligationCause::new(\n+                impl1_span,\n+                impl1_def_id,\n+                traits::ObligationCauseCode::BindingObligation(impl2_node.def_id(), span),\n+            )\n+        },\n+    );\n \n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {"}, {"sha": "0cd2fc1aa299a4dc3f8a5b532de37fdaebca84e5", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -210,6 +210,9 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 );\n             }\n \n+            // FIXME(inherent_associated_types): Handle this case properly.\n+            ty::Alias(ty::Inherent, _) => {}\n+\n             _ => {}\n         }\n     }"}, {"sha": "aa664031a8742e0bc48f1a714cc5e524256be54d", "filename": "compiler/rustc_hir_typeck/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fmessages.ftl?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -75,3 +75,7 @@ hir_typeck_union_pat_dotdot = `..` cannot be used in union patterns\n \n hir_typeck_arg_mismatch_indeterminate = argument type mismatch was detected, but rustc had trouble determining where\n     .note = we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new\n+\n+hir_typeck_suggest_boxing_note = for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n+\n+hir_typeck_suggest_boxing_when_appropriate = store this in the heap by calling `Box::new`"}, {"sha": "2defca54aff24ef697a7bb7fbd904fd3ddcd23f3", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 103, "deletions": 97, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_non_zero_new_unwrap(err, expr, expected, expr_ty)\n             || self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty)\n             || self.suggest_no_capture_closure(err, expected, expr_ty)\n-            || self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty)\n+            || self.suggest_boxing_when_appropriate(err, expr.span, expr.hir_id, expected, expr_ty)\n             || self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected)\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n             || self.suggest_clone_for_ref(err, expr, expr_ty, expected)\n@@ -86,9 +86,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.emit_type_mismatch_suggestions(err, expr, expr_ty, expected, expected_ty_expr, error);\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_internal_mutation_in_method(err, expr, Some(expected), expr_ty);\n-        self.check_for_range_as_method_call(err, expr, expr_ty, expected);\n-        self.check_for_binding_assigned_block_without_tail_expression(err, expr, expr_ty, expected);\n-        self.check_wrong_return_type_due_to_generic_arg(err, expr, expr_ty);\n+        self.suggest_method_call_on_range_literal(err, expr, expr_ty, expected);\n+        self.suggest_return_binding_for_missing_tail_expr(err, expr, expr_ty, expected);\n+        self.note_wrong_return_ty_due_to_generic_arg(err, expr, expr_ty);\n     }\n \n     /// Requires that the two types unify, and prints an error message if\n@@ -1087,7 +1087,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```ignore (illustrative)\n     /// opt.map(|param| { takes_ref(param) });\n     /// ```\n-    fn can_use_as_ref(&self, expr: &hir::Expr<'_>) -> Option<(Span, &'static str, String)> {\n+    fn can_use_as_ref(&self, expr: &hir::Expr<'_>) -> Option<(Vec<(Span, String)>, &'static str)> {\n         let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind else {\n             return None;\n         };\n@@ -1133,12 +1133,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             _ => false,\n         };\n-        match (is_as_ref_able, self.sess().source_map().span_to_snippet(method_path.ident.span)) {\n-            (true, Ok(src)) => {\n-                let suggestion = format!(\"as_ref().{}\", src);\n-                Some((method_path.ident.span, \"consider using `as_ref` instead\", suggestion))\n-            }\n-            _ => None,\n+        if is_as_ref_able {\n+            Some((\n+                vec![(method_path.ident.span.shrink_to_lo(), \"as_ref().\".to_string())],\n+                \"consider using `as_ref` instead\",\n+            ))\n+        } else {\n+            None\n         }\n     }\n \n@@ -1217,14 +1218,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// In addition of this check, it also checks between references mutability state. If the\n     /// expected is mutable but the provided isn't, maybe we could just say \"Hey, try with\n     /// `&mut`!\".\n-    pub fn check_ref(\n+    pub fn suggest_deref_or_ref(\n         &self,\n         expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> Option<(\n-        Span,\n-        String,\n+        Vec<(Span, String)>,\n         String,\n         Applicability,\n         bool, /* verbose */\n@@ -1254,30 +1254,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         && let Ok(src) = sm.span_to_snippet(sp)\n                         && replace_prefix(&src, \"b\\\"\", \"\\\"\").is_some()\n                     {\n-                                let pos = sp.lo() + BytePos(1);\n-                                return Some((\n-                                    sp.with_hi(pos),\n-                                    \"consider removing the leading `b`\".to_string(),\n-                                    String::new(),\n-                                    Applicability::MachineApplicable,\n-                                    true,\n-                                    false,\n-                                ));\n-                            }\n-                        }\n+                        let pos = sp.lo() + BytePos(1);\n+                        return Some((\n+                            vec![(sp.with_hi(pos), String::new())],\n+                            \"consider removing the leading `b`\".to_string(),\n+                            Applicability::MachineApplicable,\n+                            true,\n+                            false,\n+                        ));\n+                    }\n+                }\n                 (&ty::Array(arr, _) | &ty::Slice(arr), &ty::Str) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.kind\n                         && let Ok(src) = sm.span_to_snippet(sp)\n                         && replace_prefix(&src, \"\\\"\", \"b\\\"\").is_some()\n                     {\n-                                return Some((\n-                                    sp.shrink_to_lo(),\n-                                    \"consider adding a leading `b`\".to_string(),\n-                                    \"b\".to_string(),\n-                                    Applicability::MachineApplicable,\n-                                    true,\n-                                    false,\n-                                ));\n+                        return Some((\n+                            vec![(sp.shrink_to_lo(), \"b\".to_string())],\n+                            \"consider adding a leading `b`\".to_string(),\n+                            Applicability::MachineApplicable,\n+                            true,\n+                            false,\n+                        ));\n                     }\n                 }\n                 _ => {}\n@@ -1320,66 +1318,73 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n \n                     if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner) = expr.kind\n-                        && let Some(1) = self.deref_steps(expected, checked_ty) {\n+                        && let Some(1) = self.deref_steps(expected, checked_ty)\n+                    {\n                         // We have `*&T`, check if what was expected was `&T`.\n                         // If so, we may want to suggest removing a `*`.\n                         sugg_sp = sugg_sp.with_hi(inner.span.lo());\n                         return Some((\n-                            sugg_sp,\n+                            vec![(sugg_sp, String::new())],\n                             \"consider removing deref here\".to_string(),\n-                            \"\".to_string(),\n                             Applicability::MachineApplicable,\n                             true,\n                             false,\n                         ));\n                     }\n \n-                    if let Ok(src) = sm.span_to_snippet(sugg_sp) {\n-                        let needs_parens = match expr.kind {\n-                            // parenthesize if needed (Issue #46756)\n-                            hir::ExprKind::Cast(_, _) | hir::ExprKind::Binary(_, _, _) => true,\n-                            // parenthesize borrows of range literals (Issue #54505)\n-                            _ if is_range_literal(expr) => true,\n-                            _ => false,\n-                        };\n-\n-                        if let Some(sugg) = self.can_use_as_ref(expr) {\n-                            return Some((\n-                                sugg.0,\n-                                sugg.1.to_string(),\n-                                sugg.2,\n-                                Applicability::MachineApplicable,\n-                                false,\n-                                false,\n-                            ));\n-                        }\n-\n-                        let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n-                            Some(ident) => format!(\"{ident}: \"),\n-                            None => String::new(),\n-                        };\n-\n-                        if let Some(hir::Node::Expr(hir::Expr {\n-                            kind: hir::ExprKind::Assign(..),\n-                            ..\n-                        })) = self.tcx.hir().find_parent(expr.hir_id)\n-                        {\n-                            if mutability.is_mut() {\n-                                // Suppressing this diagnostic, we'll properly print it in `check_expr_assign`\n-                                return None;\n-                            }\n-                        }\n+                    let needs_parens = match expr.kind {\n+                        // parenthesize if needed (Issue #46756)\n+                        hir::ExprKind::Cast(_, _) | hir::ExprKind::Binary(_, _, _) => true,\n+                        // parenthesize borrows of range literals (Issue #54505)\n+                        _ if is_range_literal(expr) => true,\n+                        _ => false,\n+                    };\n \n-                        let sugg_expr = if needs_parens { format!(\"({src})\") } else { src };\n+                    if let Some((sugg, msg)) = self.can_use_as_ref(expr) {\n                         return Some((\n-                            sp,\n-                            format!(\"consider {}borrowing here\", mutability.mutably_str()),\n-                            format!(\"{prefix}{}{sugg_expr}\", mutability.ref_prefix_str()),\n+                            sugg,\n+                            msg.to_string(),\n                             Applicability::MachineApplicable,\n-                            false,\n+                            true,\n                             false,\n                         ));\n                     }\n+\n+                    let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                        Some(ident) => format!(\"{ident}: \"),\n+                        None => String::new(),\n+                    };\n+\n+                    if let Some(hir::Node::Expr(hir::Expr {\n+                        kind: hir::ExprKind::Assign(..),\n+                        ..\n+                    })) = self.tcx.hir().find_parent(expr.hir_id)\n+                    {\n+                        if mutability.is_mut() {\n+                            // Suppressing this diagnostic, we'll properly print it in `check_expr_assign`\n+                            return None;\n+                        }\n+                    }\n+\n+                    let sugg = mutability.ref_prefix_str();\n+                    let (sugg, verbose) = if needs_parens {\n+                        (\n+                            vec![\n+                                (sp.shrink_to_lo(), format!(\"{prefix}{sugg}(\")),\n+                                (sp.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            false,\n+                        )\n+                    } else {\n+                        (vec![(sp.shrink_to_lo(), format!(\"{prefix}{sugg}\"))], true)\n+                    };\n+                    return Some((\n+                        sugg,\n+                        format!(\"consider {}borrowing here\", mutability.mutably_str()),\n+                        Applicability::MachineApplicable,\n+                        verbose,\n+                        false,\n+                    ));\n                 }\n             }\n             (\n@@ -1401,23 +1406,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         && sm.is_span_accessible(call_span)\n                     {\n                         return Some((\n-                            sp.with_hi(call_span.lo()),\n+                            vec![(sp.with_hi(call_span.lo()), String::new())],\n                             \"consider removing the borrow\".to_string(),\n-                            String::new(),\n                             Applicability::MachineApplicable,\n                             true,\n-                            true\n+                            true,\n                         ));\n                     }\n                     return None;\n                 }\n-                if sp.contains(expr.span)\n-                    && sm.is_span_accessible(expr.span)\n-                {\n+                if sp.contains(expr.span) && sm.is_span_accessible(expr.span) {\n                     return Some((\n-                        sp.with_hi(expr.span.lo()),\n+                        vec![(sp.with_hi(expr.span.lo()), String::new())],\n                         \"consider removing the borrow\".to_string(),\n-                        String::new(),\n                         Applicability::MachineApplicable,\n                         true,\n                         true,\n@@ -1441,23 +1442,30 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     let suggestion = replace_prefix(&src, old_prefix, &new_prefix).map(|_| {\n                         // skip `&` or `&mut ` if both mutabilities are mutable\n-                        let lo = sp.lo() + BytePos(min(old_prefix.len(), mutbl_b.ref_prefix_str().len()) as _);\n+                        let lo = sp.lo()\n+                            + BytePos(min(old_prefix.len(), mutbl_b.ref_prefix_str().len()) as _);\n                         // skip `&` or `&mut `\n                         let hi = sp.lo() + BytePos(old_prefix.len() as _);\n                         let sp = sp.with_lo(lo).with_hi(hi);\n \n                         (\n                             sp,\n-                            format!(\"{}{derefs}\", if mutbl_a != mutbl_b { mutbl_b.prefix_str() } else { \"\" }),\n-                            if mutbl_b <= mutbl_a { Applicability::MachineApplicable } else { Applicability::MaybeIncorrect }\n+                            format!(\n+                                \"{}{derefs}\",\n+                                if mutbl_a != mutbl_b { mutbl_b.prefix_str() } else { \"\" }\n+                            ),\n+                            if mutbl_b <= mutbl_a {\n+                                Applicability::MachineApplicable\n+                            } else {\n+                                Applicability::MaybeIncorrect\n+                            },\n                         )\n                     });\n \n                     if let Some((span, src, applicability)) = suggestion {\n                         return Some((\n-                            span,\n+                            vec![(span, src)],\n                             \"consider dereferencing\".to_string(),\n-                            src,\n                             applicability,\n                             true,\n                             false,\n@@ -1486,9 +1494,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // If we've reached our target type with just removing `&`, then just print now.\n                     if steps == 0 && !remove.trim().is_empty() {\n                         return Some((\n-                            prefix_span,\n+                            vec![(prefix_span, String::new())],\n                             format!(\"consider removing the `{}`\", remove.trim()),\n-                            String::new(),\n                             // Do not remove `&&` to get to bool, because it might be something like\n                             // { a } && b, which we have a separate fixup suggestion that is more\n                             // likely correct...\n@@ -1554,9 +1561,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n \n                         return Some((\n-                            span,\n+                            vec![(span, suggestion)],\n                             message,\n-                            suggestion,\n                             Applicability::MachineApplicable,\n                             true,\n                             false,\n@@ -1569,7 +1575,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n-    pub fn check_for_cast(\n+    pub fn suggest_cast(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n@@ -1936,7 +1942,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Identify when the user has written `foo..bar()` instead of `foo.bar()`.\n-    pub fn check_for_range_as_method_call(\n+    pub fn suggest_method_call_on_range_literal(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'tcx>,\n@@ -2005,7 +2011,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Identify when the type error is because `()` is found in a binding that was assigned a\n     /// block without a tail expression.\n-    fn check_for_binding_assigned_block_without_tail_expression(\n+    fn suggest_return_binding_for_missing_tail_expr(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n@@ -2047,7 +2053,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_wrong_return_type_due_to_generic_arg(\n+    fn note_wrong_return_ty_due_to_generic_arg(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,"}, {"sha": "ce30bbeca0badea51978a293379c963b95624e2e", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -267,3 +267,31 @@ pub struct ArgMismatchIndeterminate {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestBoxing {\n+    #[note(hir_typeck_suggest_boxing_note)]\n+    #[multipart_suggestion(\n+        hir_typeck_suggest_boxing_when_appropriate,\n+        applicability = \"machine-applicable\"\n+    )]\n+    Unit {\n+        #[suggestion_part(code = \"Box::new(())\")]\n+        start: Span,\n+        #[suggestion_part(code = \"\")]\n+        end: Span,\n+    },\n+    #[note(hir_typeck_suggest_boxing_note)]\n+    AsyncBody,\n+    #[note(hir_typeck_suggest_boxing_note)]\n+    #[multipart_suggestion(\n+        hir_typeck_suggest_boxing_when_appropriate,\n+        applicability = \"machine-applicable\"\n+    )]\n+    Other {\n+        #[suggestion_part(code = \"Box::new(\")]\n+        start: Span,\n+        #[suggestion_part(code = \")\")]\n+        end: Span,\n+    },\n+}"}, {"sha": "05e5d850bf958cc6471a15ed5ff489abdbbe0a09", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -843,7 +843,7 @@ fn find_param_in_ty<'tcx>(\n             return true;\n         }\n         if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                && let ty::Alias(ty::Projection, ..) = ty.kind()\n+                && let ty::Alias(ty::Projection | ty::Inherent, ..) = ty.kind()\n             {\n                 // This logic may seem a bit strange, but typically when\n                 // we have a projection type in a function signature, the"}, {"sha": "c7011b23a7da7b5ac20a6ec5d2003938d083266a", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1519,7 +1519,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // case we can ignore the tail expression (e.g., `'a: {\n         // break 'a 22; }` would not force the type of the block\n         // to be `()`).\n-        let tail_expr = blk.expr.as_ref();\n         let coerce_to_ty = expected.coercion_target_type(self, blk.span);\n         let coerce = if blk.targeted_by_break {\n             CoerceMany::new(coerce_to_ty)\n@@ -1537,13 +1536,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // check the tail expression **without** holding the\n             // `enclosing_breakables` lock below.\n-            let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n+            let tail_expr_ty =\n+                blk.expr.map(|expr| (expr, self.check_expr_with_expectation(expr, expected)));\n \n             let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n             let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n             let coerce = ctxt.coerce.as_mut().unwrap();\n-            if let Some(tail_expr_ty) = tail_expr_ty {\n-                let tail_expr = tail_expr.unwrap();\n+            if let Some((tail_expr, tail_expr_ty)) = tail_expr_ty {\n                 let span = self.get_expr_coercion_span(tail_expr);\n                 let cause = self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n                 let ty_for_diagnostic = coerce.merged_ty();\n@@ -1596,6 +1595,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         &self.misc(sp),\n                         &mut |err| {\n                             if let Some(expected_ty) = expected.only_has_type(self) {\n+                                if blk.stmts.is_empty() && blk.expr.is_none() {\n+                                    self.suggest_boxing_when_appropriate(\n+                                        err,\n+                                        blk.span,\n+                                        blk.hir_id,\n+                                        expected_ty,\n+                                        self.tcx.mk_unit(),\n+                                    );\n+                                }\n                                 if !self.consider_removing_semicolon(blk, expected_ty, err) {\n                                     self.err_ctxt().consider_returning_binding(\n                                         blk,\n@@ -1608,7 +1616,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // silence this redundant error, as we already emit E0070.\n \n                                     // Our block must be a `assign desugar local; assignment`\n-                                    if let Some(hir::Node::Block(hir::Block {\n+                                    if let hir::Block {\n                                         stmts:\n                                             [\n                                                 hir::Stmt {\n@@ -1630,7 +1638,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                 },\n                                             ],\n                                         ..\n-                                    })) = self.tcx.hir().find(blk.hir_id)\n+                                    } = blk\n                                     {\n                                         self.comes_from_while_condition(blk.hir_id, |_| {\n                                             err.downgrade_to_delayed_bug();"}, {"sha": "67f45f9aa3f0dd64977c8bdd10ab4d142ab76bde", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         match ty.kind() {\n             ty::Adt(adt_def, _) => Some(*adt_def),\n             // FIXME(#104767): Should we handle bound regions here?\n-            ty::Alias(ty::Projection, _) if !ty.has_escaping_bound_vars() => {\n+            ty::Alias(ty::Projection | ty::Inherent, _) if !ty.has_escaping_bound_vars() => {\n                 self.normalize(span, ty).ty_adt_def()\n             }\n             _ => None,"}, {"sha": "c4add4dbdfb2fb29038f464931cfe04bbabe71f1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,6 +1,6 @@\n use super::FnCtxt;\n \n-use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n+use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel, SuggestBoxing};\n use crate::fluent_generated as fluent;\n use crate::method::probe::{IsSuggestion, Mode, ProbeScope};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n@@ -9,7 +9,8 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n-    Expr, ExprKind, GenericBound, Node, Path, QPath, Stmt, StmtKind, TyKind, WherePredicate,\n+    AsyncGeneratorKind, Expr, ExprKind, GeneratorKind, GenericBound, HirId, Node, Path, QPath,\n+    Stmt, StmtKind, TyKind, WherePredicate,\n };\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::traits::{self, StatementAsExpression};\n@@ -274,13 +275,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> bool {\n         let expr = expr.peel_blocks();\n-        if let Some((sp, msg, suggestion, applicability, verbose, annotation)) =\n-            self.check_ref(expr, found, expected)\n+        if let Some((suggestion, msg, applicability, verbose, annotation)) =\n+            self.suggest_deref_or_ref(expr, found, expected)\n         {\n             if verbose {\n-                err.span_suggestion_verbose(sp, msg, suggestion, applicability);\n+                err.multipart_suggestion_verbose(msg, suggestion, applicability);\n             } else {\n-                err.span_suggestion(sp, msg, suggestion, applicability);\n+                err.multipart_suggestion(msg, suggestion, applicability);\n             }\n             if annotation {\n                 let suggest_annotation = match expr.peel_drop_temps().kind {\n@@ -342,7 +343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.span_label(sp, format!(\"{descr} `{name}` defined here\"));\n             }\n             return true;\n-        } else if self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n+        } else if self.suggest_cast(err, expr, found, expected, expected_ty_expr) {\n             return true;\n         } else {\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n@@ -438,33 +439,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn suggest_boxing_when_appropriate(\n         &self,\n         err: &mut Diagnostic,\n-        expr: &hir::Expr<'_>,\n+        span: Span,\n+        hir_id: HirId,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) -> bool {\n-        if self.tcx.hir().is_inside_const_context(expr.hir_id) {\n-            // Do not suggest `Box::new` in const context.\n-            return false;\n-        }\n-        if !expected.is_box() || found.is_box() {\n+        // Do not suggest `Box::new` in const context.\n+        if self.tcx.hir().is_inside_const_context(hir_id) || !expected.is_box() || found.is_box() {\n             return false;\n         }\n-        let boxed_found = self.tcx.mk_box(found);\n-        if self.can_coerce(boxed_found, expected) {\n-            err.multipart_suggestion(\n-                \"store this in the heap by calling `Box::new`\",\n-                vec![\n-                    (expr.span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                    (expr.span.shrink_to_hi(), \")\".to_string()),\n-                ],\n-                Applicability::MachineApplicable,\n-            );\n-            err.note(\n-                \"for more on the distinction between the stack and the heap, read \\\n-                 https://doc.rust-lang.org/book/ch15-01-box.html, \\\n-                 https://doc.rust-lang.org/rust-by-example/std/box.html, and \\\n-                 https://doc.rust-lang.org/std/boxed/index.html\",\n-            );\n+        if self.can_coerce(self.tcx.mk_box(found), expected) {\n+            let suggest_boxing = match found.kind() {\n+                ty::Tuple(tuple) if tuple.is_empty() => {\n+                    SuggestBoxing::Unit { start: span.shrink_to_lo(), end: span }\n+                }\n+                ty::Generator(def_id, ..)\n+                    if matches!(\n+                        self.tcx.generator_kind(def_id),\n+                        Some(GeneratorKind::Async(AsyncGeneratorKind::Closure))\n+                    ) =>\n+                {\n+                    SuggestBoxing::AsyncBody\n+                }\n+                _ => SuggestBoxing::Other { start: span.shrink_to_lo(), end: span.shrink_to_hi() },\n+            };\n+            err.subdiagnostic(suggest_boxing);\n+\n             true\n         } else {\n             false"}, {"sha": "486c217707e78cced843d0c4cdb695af9d75efb1", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1045,7 +1045,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             );\n         }\n \n-        self.check_for_inner_self(&mut err, source, rcvr_ty, item_name);\n+        self.suggest_unwrapping_inner_self(&mut err, source, rcvr_ty, item_name);\n \n         bound_spans.sort();\n         bound_spans.dedup();\n@@ -1132,7 +1132,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.check_for_deref_method(&mut err, source, rcvr_ty, item_name, expected);\n+        self.note_derefed_ty_has_method(&mut err, source, rcvr_ty, item_name, expected);\n         return Some(err);\n     }\n \n@@ -1805,7 +1805,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_for_inner_self(\n+    fn suggest_unwrapping_inner_self(\n         &self,\n         err: &mut Diagnostic,\n         source: SelfSource<'tcx>,\n@@ -2175,7 +2175,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_for_deref_method(\n+    fn note_derefed_ty_has_method(\n         &self,\n         err: &mut Diagnostic,\n         self_source: SelfSource<'tcx>,\n@@ -2211,7 +2211,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         | ty::Float(_)\n                         | ty::Adt(_, _)\n                         | ty::Str\n-                        | ty::Alias(ty::Projection, _)\n+                        | ty::Alias(ty::Projection | ty::Inherent, _)\n                         | ty::Param(_) => format!(\"{deref_ty}\"),\n                         // we need to test something like  <&[_]>::len or <(&[u32])>::len\n                         // and Vec::function();"}, {"sha": "08eec0707c0adaf9db0f3b720a9896fd1f2efc35", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -127,7 +127,8 @@ impl<'tcx> InferCtxt<'tcx> {\n                 bug!()\n             }\n \n-            (_, ty::Alias(AliasKind::Projection, _)) | (ty::Alias(AliasKind::Projection, _), _)\n+            (_, ty::Alias(AliasKind::Projection | AliasKind::Inherent, _))\n+            | (ty::Alias(AliasKind::Projection | AliasKind::Inherent, _), _)\n                 if self.tcx.trait_solver_next() =>\n             {\n                 relation.register_type_relate_obligation(a, b);"}, {"sha": "ce70f39cc4014d66aae79c447b747a06e9732761", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -2354,7 +2354,9 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n             GenericKind::Alias(ref p) => match p.kind(self.tcx) {\n-                ty::AliasKind::Projection => format!(\"the associated type `{}`\", p),\n+                ty::AliasKind::Projection | ty::AliasKind::Inherent => {\n+                    format!(\"the associated type `{}`\", p)\n+                }\n                 ty::AliasKind::Opaque => format!(\"the opaque type `{}`\", p),\n             },\n         };"}, {"sha": "5000b0139df285228fd04ff79a416459a320f895", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -31,7 +31,7 @@ pub enum TypeAnnotationNeeded {\n     /// ```\n     E0282,\n     /// An implementation cannot be chosen unambiguously because of lack of information.\n-    /// ```compile_fail,E0283\n+    /// ```compile_fail,E0790\n     /// let _ = Default::default();\n     /// ```\n     E0283,"}, {"sha": "1a60bab18dbda7aa0ce61fcc15f5011cc2789d68", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -21,7 +21,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     ///\n     /// Consider a case where we have\n     ///\n-    /// ```compile_fail,E0623\n+    /// ```compile_fail\n     /// fn foo(x: &mut Vec<&u8>, y: &u8) {\n     ///     x.push(y);\n     /// }"}, {"sha": "0df417d095013d5d704e9994c95942ddbbaef361", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::ty::{self, Region, TyCtxt};\n /// br - the bound region corresponding to the above region which is of type `BrAnon(_)`\n ///\n /// # Example\n-/// ```compile_fail,E0623\n+/// ```compile_fail\n /// fn foo(x: &mut Vec<&u8>, y: &u8)\n ///    { x.push(y); }\n /// ```"}, {"sha": "064811bd29d77a25aade79585d08a67122adb6f9", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -71,9 +71,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                              #traits-as-parameters\",\n                         );\n                     }\n-                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n+                    (ty::Alias(ty::Projection | ty::Inherent, _), ty::Alias(ty::Projection | ty::Inherent, _)) => {\n                         diag.note(\"an associated type was expected, but a different one was found\");\n                     }\n+                    // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n                         if !tcx.is_impl_trait_in_trait(proj.def_id) =>\n                     {\n@@ -222,7 +223,7 @@ impl<T> Trait<T> for X {\n                             diag.span_label(p_span, \"this type parameter\");\n                         }\n                     }\n-                    (ty::Alias(ty::Projection, proj_ty), _) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n+                    (ty::Alias(ty::Projection | ty::Inherent, proj_ty), _) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n                         self.expected_projection(\n                             diag,\n                             proj_ty,\n@@ -231,7 +232,7 @@ impl<T> Trait<T> for X {\n                             cause.code(),\n                         );\n                     }\n-                    (_, ty::Alias(ty::Projection, proj_ty)) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n+                    (_, ty::Alias(ty::Projection | ty::Inherent, proj_ty)) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n                         let msg = format!(\n                             \"consider constraining the associated type `{}` to `{}`\",\n                             values.found, values.expected,"}, {"sha": "362b22b23a8dad81e64d37cb4bad130696df32fe", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -549,6 +549,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // We can't normalize associated types from `rustc_infer`,\n                     // but we can eagerly register inference variables for them.\n                     // FIXME(RPITIT): Don't replace RPITITs with inference vars.\n+                    // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     ty::Alias(ty::Projection, projection_ty)\n                         if !projection_ty.has_escaping_bound_vars()\n                             && !tcx.is_impl_trait_in_trait(projection_ty.def_id) =>\n@@ -569,6 +570,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                         hidden_ty\n                     }\n                     // FIXME(RPITIT): This can go away when we move to associated types\n+                    // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     ty::Alias(\n                         ty::Projection,\n                         ty::AliasTy { def_id: def_id2, substs: substs2, .. },"}, {"sha": "75ce0f83fd63fb8b43e8c8640f5b9b82b5ca9f6e", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -13,9 +13,11 @@ use crate::infer::region_constraints::VerifyIfEq;\n \n /// Given a \"verify-if-eq\" type test like:\n ///\n-///     exists<'a...> {\n-///         verify_if_eq(some_type, bound_region)\n-///     }\n+/// ```rust,ignore (pseudo-Rust)\n+/// exists<'a...> {\n+///     verify_if_eq(some_type, bound_region)\n+/// }\n+/// ```\n ///\n /// and the type `test_ty` that the type test is being tested against,\n /// returns:"}, {"sha": "c2bf0f3db253ce5a7819860f6f91a23c3d2b672c", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -277,7 +277,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     ///\n     /// It will not, however, work for higher-ranked bounds like:\n     ///\n-    /// ```compile_fail,E0311\n+    /// ```ignore(this does compile today, previously was marked as `compile_fail,E0311`)\n     /// trait Foo<'a, 'b>\n     /// where for<'x> <Self as Foo<'x, 'b>>::Bar: 'x\n     /// {"}, {"sha": "c7a307b89e414d8dc76ac3482b6730e42c9fbe1f", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -217,7 +217,7 @@ pub enum VerifyBound<'tcx> {\n /// and supplies a bound if it ended up being relevant. It's used in situations\n /// like this:\n ///\n-/// ```rust\n+/// ```rust,ignore (pseudo-Rust)\n /// fn foo<'a, 'b, T: SomeTrait<'a>>\n /// where\n ///    <T as SomeTrait<'a>>::Item: 'b\n@@ -232,7 +232,7 @@ pub enum VerifyBound<'tcx> {\n /// In the [`VerifyBound`], this struct is enclosed in `Binder` to account\n /// for cases like\n ///\n-/// ```rust\n+/// ```rust,ignore (pseudo-Rust)\n /// where for<'a> <T as SomeTrait<'a>::Item: 'a\n /// ```\n ///"}, {"sha": "3025cce7ba7e52960b0724e427782264f49c7cb2", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -62,6 +62,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::TypeVisitableExt;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, VariantDef};\n use rustc_session::config::ExpectedValues;\n use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n@@ -1442,6 +1443,10 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n             // Bounds are respected for `type X = impl Trait`\n             return;\n         }\n+        if cx.tcx.type_of(item.owner_id).skip_binder().has_inherent_projections() {\n+            // Bounds are respected for `type X = \u2026 Type::Inherent \u2026`\n+            return;\n+        }\n         // There must not be a where clause\n         if type_alias_generics.predicates.is_empty() {\n             return;\n@@ -1561,7 +1566,6 @@ declare_lint_pass!(\n \n impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-        use rustc_middle::ty::visit::TypeVisitableExt;\n         use rustc_middle::ty::Clause;\n         use rustc_middle::ty::PredicateKind::*;\n \n@@ -2898,6 +2902,7 @@ impl ClashingExternDeclarations {\n                         | (Generator(..), Generator(..))\n                         | (GeneratorWitness(..), GeneratorWitness(..))\n                         | (Alias(ty::Projection, ..), Alias(ty::Projection, ..))\n+                        | (Alias(ty::Inherent, ..), Alias(ty::Inherent, ..))\n                         | (Alias(ty::Opaque, ..), Alias(ty::Opaque, ..)) => false,\n \n                         // These definitely should have been caught above."}, {"sha": "125b4dc5503100548be60daa014cd00d05560fb5", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1119,14 +1119,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n             //  so they are currently ignored for the purposes of this lint.\n-            ty::Param(..) | ty::Alias(ty::Projection, ..)\n+            ty::Param(..) | ty::Alias(ty::Projection | ty::Inherent, ..)\n                 if matches!(self.mode, CItemKind::Definition) =>\n             {\n                 FfiSafe\n             }\n \n             ty::Param(..)\n-            | ty::Alias(ty::Projection, ..)\n+            | ty::Alias(ty::Projection | ty::Inherent, ..)\n             | ty::Infer(..)\n             | ty::Bound(..)\n             | ty::Error(_)"}, {"sha": "6e9dc880a7deecbf2e2f62b028450d52e2555f97", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -333,6 +333,7 @@ declare_lint! {\n     ///\n     /// ```rust,compile_fail\n     /// #![deny(unused_extern_crates)]\n+    /// #![deny(warnings)]\n     /// extern crate proc_macro;\n     /// ```\n     ///\n@@ -1667,6 +1668,7 @@ declare_lint! {\n     ///\n     /// ```rust,compile_fail\n     /// #![deny(elided_lifetimes_in_paths)]\n+    /// #![deny(warnings)]\n     /// struct Foo<'a> {\n     ///     x: &'a u32\n     /// }\n@@ -2158,6 +2160,7 @@ declare_lint! {\n     /// ```rust,compile_fail\n     /// # #![allow(unused)]\n     /// #![deny(explicit_outlives_requirements)]\n+    /// #![deny(warnings)]\n     ///\n     /// struct SharedRef<'a, T>\n     /// where"}, {"sha": "cd6e36874603f8a499100c817af10ca83079af44", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -9,7 +9,7 @@ use crate::diagnostics::utils::{\n     FieldInnerTy, FieldMap, HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n-use quote::{format_ident, quote};\n+use quote::{format_ident, quote, quote_spanned};\n use syn::Token;\n use syn::{parse_quote, spanned::Spanned, Attribute, Meta, Path, Type};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n@@ -251,7 +251,8 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         let diag = &self.parent.diag;\n \n         let field = binding_info.ast();\n-        let field_binding = &binding_info.binding;\n+        let mut field_binding = binding_info.binding.clone();\n+        field_binding.set_span(field.ty.span());\n \n         let ident = field.ident.as_ref().unwrap();\n         let ident = format_ident!(\"{}\", ident); // strip `r#` prefix, if present\n@@ -284,9 +285,9 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     name == \"primary_span\" && matches!(inner_ty, FieldInnerTy::Vec(_));\n                 let (binding, needs_destructure) = if needs_clone {\n                     // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n-                    (quote! { #field_binding.clone() }, false)\n+                    (quote_spanned! {inner_ty.span()=> #field_binding.clone() }, false)\n                 } else {\n-                    (quote! { #field_binding }, true)\n+                    (quote_spanned! {inner_ty.span()=> #field_binding }, true)\n                 };\n \n                 let generated_code = self"}, {"sha": "a536eb3b04e69e648ed9282d05b96c8e4db6c5b3", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -140,7 +140,7 @@ pub fn lint_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n /// ```fluent\n /// parser_expected_identifier = expected identifier\n ///\n-/// parser_expected_identifier-found = expected identifier, found {$found}\n+/// parser_expected_identifier_found = expected identifier, found {$found}\n ///\n /// parser_raw_identifier = escape `{$ident}` to use it as an identifier\n /// ```"}, {"sha": "374ba1a45c06ec89ada4f940cf52d01e357ef5f8", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -4,17 +4,16 @@ use crate::diagnostics::error::{\n     invalid_attr, span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    build_field_mapping, is_doc_comment, new_code_ident,\n-    report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span, FieldInfo,\n-    FieldInnerTy, FieldMap, HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n+    build_field_mapping, build_suggestion_code, is_doc_comment, new_code_ident,\n+    report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span,\n+    should_generate_set_arg, AllowMultipleAlternatives, FieldInfo, FieldInnerTy, FieldMap,\n+    HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n use syn::{spanned::Spanned, Attribute, Meta, MetaList, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n-use super::utils::{build_suggestion_code, AllowMultipleAlternatives};\n-\n /// The central struct for constructing the `add_to_diagnostic` method from an annotated struct.\n pub(crate) struct SubdiagnosticDeriveBuilder {\n     diag: syn::Ident,\n@@ -210,19 +209,20 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n     }\n \n     /// Generates the code for a field with no attributes.\n-    fn generate_field_set_arg(&mut self, binding: &BindingInfo<'_>) -> TokenStream {\n-        let ast = binding.ast();\n-        assert_eq!(ast.attrs.len(), 0, \"field with attribute used as diagnostic arg\");\n-\n+    fn generate_field_set_arg(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n         let diag = &self.parent.diag;\n-        let ident = ast.ident.as_ref().unwrap();\n-        // strip `r#` prefix, if present\n-        let ident = format_ident!(\"{}\", ident);\n+\n+        let field = binding_info.ast();\n+        let mut field_binding = binding_info.binding.clone();\n+        field_binding.set_span(field.ty.span());\n+\n+        let ident = field.ident.as_ref().unwrap();\n+        let ident = format_ident!(\"{}\", ident); // strip `r#` prefix, if present\n \n         quote! {\n             #diag.set_arg(\n                 stringify!(#ident),\n-                #binding\n+                #field_binding\n             );\n         }\n     }\n@@ -399,7 +399,8 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let span = attr.span().unwrap();\n-        let ident = &list.path.segments.last().unwrap().ident;\n+        let mut ident = list.path.segments.last().unwrap().ident.clone();\n+        ident.set_span(info.ty.span());\n         let name = ident.to_string();\n         let name = name.as_str();\n \n@@ -498,7 +499,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             .variant\n             .bindings()\n             .iter()\n-            .filter(|binding| !binding.ast().attrs.is_empty())\n+            .filter(|binding| !should_generate_set_arg(binding.ast()))\n             .map(|binding| self.generate_field_attr_code(binding, kind_stats))\n             .collect();\n \n@@ -580,7 +581,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             .variant\n             .bindings()\n             .iter()\n-            .filter(|binding| binding.ast().attrs.is_empty())\n+            .filter(|binding| should_generate_set_arg(binding.ast()))\n             .map(|binding| self.generate_field_set_arg(binding))\n             .collect();\n "}, {"sha": "e2434981f8d1782fd3fdfb0f051bcae1a6a9f8be", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -207,6 +207,12 @@ impl<'ty> FieldInnerTy<'ty> {\n             FieldInnerTy::Plain(..) => quote! { #inner },\n         }\n     }\n+\n+    pub fn span(&self) -> proc_macro2::Span {\n+        match self {\n+            FieldInnerTy::Option(ty) | FieldInnerTy::Vec(ty) | FieldInnerTy::Plain(ty) => ty.span(),\n+        }\n+    }\n }\n \n /// Field information passed to the builder. Deliberately omits attrs to discourage the\n@@ -851,7 +857,8 @@ impl quote::IdentFragment for SubdiagnosticKind {\n /// Returns `true` if `field` should generate a `set_arg` call rather than any other diagnostic\n /// call (like `span_label`).\n pub(super) fn should_generate_set_arg(field: &Field) -> bool {\n-    field.attrs.is_empty()\n+    // Perhaps this should be an exhaustive list...\n+    field.attrs.iter().all(|attr| is_doc_comment(attr))\n }\n \n pub(super) fn is_doc_comment(attr: &Attribute) -> bool {"}, {"sha": "967fed687b6a8de21f9d27c20d5c695766314fe4", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -64,26 +64,14 @@ impl EffectiveVisibility {\n         self.at_level(level).is_public()\n     }\n \n-    pub const fn from_vis(vis: Visibility) -> EffectiveVisibility {\n+    pub fn from_vis(vis: Visibility) -> EffectiveVisibility {\n         EffectiveVisibility {\n             direct: vis,\n             reexported: vis,\n             reachable: vis,\n             reachable_through_impl_trait: vis,\n         }\n     }\n-\n-    #[must_use]\n-    pub fn min(mut self, lhs: EffectiveVisibility, tcx: TyCtxt<'_>) -> Self {\n-        for l in Level::all_levels() {\n-            let rhs_vis = self.at_level_mut(l);\n-            let lhs_vis = *lhs.at_level(l);\n-            if rhs_vis.is_at_least(lhs_vis, tcx) {\n-                *rhs_vis = lhs_vis;\n-            };\n-        }\n-        self\n-    }\n }\n \n /// Holds a map of effective visibilities for reachable HIR nodes.\n@@ -149,6 +137,24 @@ impl EffectiveVisibilities {\n         };\n     }\n \n+    pub fn set_public_at_level(\n+        &mut self,\n+        id: LocalDefId,\n+        lazy_private_vis: impl FnOnce() -> Visibility,\n+        level: Level,\n+    ) {\n+        let mut effective_vis = self\n+            .effective_vis(id)\n+            .copied()\n+            .unwrap_or_else(|| EffectiveVisibility::from_vis(lazy_private_vis()));\n+        for l in Level::all_levels() {\n+            if l <= level {\n+                *effective_vis.at_level_mut(l) = Visibility::Public;\n+            }\n+        }\n+        self.map.insert(id, effective_vis);\n+    }\n+\n     pub fn check_invariants(&self, tcx: TyCtxt<'_>, early: bool) {\n         if !cfg!(debug_assertions) {\n             return;\n@@ -213,7 +219,7 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n     pub fn update(\n         &mut self,\n         id: Id,\n-        nominal_vis: Option<Visibility>,\n+        nominal_vis: Visibility,\n         lazy_private_vis: impl FnOnce() -> Visibility,\n         inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n@@ -237,11 +243,12 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n                 if !(inherited_effective_vis_at_prev_level == inherited_effective_vis_at_level\n                     && level != l)\n                 {\n-                    calculated_effective_vis = if let Some(nominal_vis) = nominal_vis && !nominal_vis.is_at_least(inherited_effective_vis_at_level, tcx) {\n-                        nominal_vis\n-                    } else {\n-                        inherited_effective_vis_at_level\n-                    }\n+                    calculated_effective_vis =\n+                        if nominal_vis.is_at_least(inherited_effective_vis_at_level, tcx) {\n+                            inherited_effective_vis_at_level\n+                        } else {\n+                            nominal_vis\n+                        };\n                 }\n                 // effective visibility can't be decreased at next update call for the\n                 // same id"}, {"sha": "55991facd89a35b5ded43137da3ae9d1b4887629", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1524,6 +1524,19 @@ impl<V, T> ProjectionElem<V, T> {\n         }\n     }\n \n+    /// Returns `true` if the target of this projection always refers to the same memory region\n+    /// whatever the state of the program.\n+    pub fn is_stable_offset(&self) -> bool {\n+        match self {\n+            Self::Deref | Self::Index(_) => false,\n+            Self::Field(_, _)\n+            | Self::OpaqueCast(_)\n+            | Self::ConstantIndex { .. }\n+            | Self::Subslice { .. }\n+            | Self::Downcast(_, _) => true,\n+        }\n+    }\n+\n     /// Returns `true` if this is a `Downcast` projection with the given `VariantIdx`.\n     pub fn is_downcast_to(&self, v: VariantIdx) -> bool {\n         matches!(*self, Self::Downcast(_, x) if x == v)\n@@ -2728,8 +2741,6 @@ pub struct UserTypeProjection {\n     pub projs: Vec<ProjectionKind>,\n }\n \n-impl Copy for ProjectionKind {}\n-\n impl UserTypeProjection {\n     pub(crate) fn index(mut self) -> Self {\n         self.projs.push(ProjectionElem::Index(()));"}, {"sha": "d5b185e45d6b4aba261ce06424c011b12e93bfc8", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1821,6 +1821,16 @@ rustc_queries! {\n         desc { \"normalizing `{}`\", goal.value.value }\n     }\n \n+    /// Do not call this query directly: invoke `normalize` instead.\n+    query normalize_inherent_projection_ty(\n+        goal: CanonicalProjectionGoal<'tcx>\n+    ) -> Result<\n+        &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>,\n+        NoSolution,\n+    > {\n+        desc { \"normalizing `{}`\", goal.value.value }\n+    }\n+\n     /// Do not call this query directly: invoke `try_normalize_erasing_regions` instead.\n     query try_normalize_generic_arg_after_erasing_regions(\n         goal: ParamEnvAnd<'tcx, GenericArg<'tcx>>"}, {"sha": "ad9891a5dca687cc1b98716c519a15d3ddf8bdf3", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -26,7 +26,7 @@ use super::{Destructor, FieldDef, GenericPredicates, Ty, TyCtxt, VariantDef, Var\n \n bitflags! {\n     #[derive(HashStable, TyEncodable, TyDecodable)]\n-    pub struct AdtFlags: u32 {\n+    pub struct AdtFlags: u16 {\n         const NO_ADT_FLAGS        = 0;\n         /// Indicates whether the ADT is an enum.\n         const IS_ENUM             = 1 << 0;"}, {"sha": "8aea2d8aedf982aeb936247069f5ee966fd32e02", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1093,11 +1093,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         v.0\n     }\n \n-    /// Given a `DefId` for an `fn`, return all the `dyn` and `impl` traits in its return type and associated alias span when type alias is used\n+    /// Given a `DefId` for an `fn`, return all the `dyn` and `impl` traits in\n+    /// its return type, and the associated alias span when type alias is used,\n+    /// along with a span for lifetime suggestion (if there are existing generics).\n     pub fn return_type_impl_or_dyn_traits_with_type_alias(\n         self,\n         scope_def_id: LocalDefId,\n-    ) -> Option<(Vec<&'tcx hir::Ty<'tcx>>, Span)> {\n+    ) -> Option<(Vec<&'tcx hir::Ty<'tcx>>, Span, Option<Span>)> {\n         let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n         let mut v = TraitObjectVisitor(vec![], self.hir());\n         // when the return type is a type alias\n@@ -1111,7 +1113,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         {\n             v.visit_ty(alias_ty);\n             if !v.0.is_empty() {\n-                return Some((v.0, alias_generics.span));\n+                return Some((v.0, alias_generics.span, alias_generics.span_for_lifetime_suggestion()));\n             }\n         }\n         return None;\n@@ -1846,7 +1848,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         let substs = substs.into_iter().map(Into::into);\n         #[cfg(debug_assertions)]\n         {\n-            let n = self.generics_of(_def_id).count();\n+            let generics = self.generics_of(_def_id);\n+\n+            let n = if let DefKind::AssocTy = self.def_kind(_def_id)\n+                && let DefKind::Impl { of_trait: false } = self.def_kind(self.parent(_def_id))\n+            {\n+                // If this is an inherent projection.\n+\n+                generics.params.len() + 1\n+            } else {\n+                generics.count()\n+            };\n             assert_eq!(\n                 (n, Some(n)),\n                 substs.size_hint(),\n@@ -2007,7 +2019,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug_assert_matches!(\n             (kind, self.def_kind(alias_ty.def_id)),\n             (ty::Opaque, DefKind::OpaqueTy)\n-                | (ty::Projection, DefKind::AssocTy)\n+                | (ty::Projection | ty::Inherent, DefKind::AssocTy)\n                 | (ty::Opaque | ty::Projection, DefKind::ImplTraitPlaceholder)\n         );\n         self.mk_ty_from_kind(Alias(kind, alias_ty))"}, {"sha": "49ab9b79e96f32de0dbf5799d9a35f4a56d3d44d", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -265,7 +265,7 @@ impl<'tcx> Ty<'tcx> {\n             ty::Infer(ty::FreshTy(_)) => \"fresh type\".into(),\n             ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".into(),\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n-            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n+            ty::Alias(ty::Projection | ty::Inherent, _) => \"associated type\".into(),\n             ty::Param(p) => format!(\"type parameter `{p}`\").into(),\n             ty::Alias(ty::Opaque, ..) => if tcx.ty_is_opaque_future(self) { \"future\".into() } else { \"opaque type\".into() },\n             ty::Error(_) => \"type error\".into(),\n@@ -312,7 +312,7 @@ impl<'tcx> Ty<'tcx> {\n             ty::Tuple(..) => \"tuple\".into(),\n             ty::Placeholder(..) => \"higher-ranked type\".into(),\n             ty::Bound(..) => \"bound type variable\".into(),\n-            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n+            ty::Alias(ty::Projection | ty::Inherent, _) => \"associated type\".into(),\n             ty::Param(_) => \"type parameter\".into(),\n             ty::Alias(ty::Opaque, ..) => \"opaque type\".into(),\n         }"}, {"sha": "d64875a9f00e8cc08cae1abf9cd1a3829836ecb7", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -176,14 +176,14 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::Alias(ty::Projection, data) => {\n-                self.add_flags(TypeFlags::HAS_TY_PROJECTION);\n-                self.add_alias_ty(data);\n-            }\n+            &ty::Alias(kind, data) => {\n+                self.add_flags(match kind {\n+                    ty::Projection => TypeFlags::HAS_TY_PROJECTION,\n+                    ty::Inherent => TypeFlags::HAS_TY_INHERENT,\n+                    ty::Opaque => TypeFlags::HAS_TY_OPAQUE,\n+                });\n \n-            &ty::Alias(ty::Opaque, ty::AliasTy { substs, .. }) => {\n-                self.add_flags(TypeFlags::HAS_TY_OPAQUE);\n-                self.add_substs(substs);\n+                self.add_alias_ty(data);\n             }\n \n             &ty::Dynamic(obj, r, _) => {"}, {"sha": "9e672004cf9c0e6dc8d5fbe7598a2643c7831434", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -113,6 +113,12 @@ impl<'tcx> Ty<'tcx> {\n             }\n             Never => InhabitedPredicate::False,\n             Param(_) | Alias(ty::Projection, _) => InhabitedPredicate::GenericType(self),\n+            // FIXME(inherent_associated_types): Most likely we can just map to `GenericType` like above.\n+            // However it's unclear if the substs passed to `InhabitedPredicate::subst` are of the correct\n+            // format, i.e. don't contain parent substs. If you hit this case, please verify this beforehand.\n+            Alias(ty::Inherent, _) => {\n+                bug!(\"unimplemented: inhabitedness checking for inherent projections\")\n+            }\n             Tuple(tys) if tys.is_empty() => InhabitedPredicate::True,\n             // use a query for more complex cases\n             Adt(..) | Array(..) | Tuple(_) => tcx.inhabited_predicate_type(self),"}, {"sha": "8c69894f5ba7ead82ca4dd57231d4e54d7504800", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -115,7 +115,7 @@ impl<'tcx> Instance<'tcx> {\n     /// lifetimes erased, allowing a `ParamEnv` to be specified for use during normalization.\n     pub fn ty(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Ty<'tcx> {\n         let ty = tcx.type_of(self.def.def_id());\n-        tcx.subst_and_normalize_erasing_regions(self.substs, param_env, ty.skip_binder())\n+        tcx.subst_and_normalize_erasing_regions(self.substs, param_env, ty)\n     }\n \n     /// Finds a crate that contains a monomorphization of this instance that\n@@ -578,14 +578,15 @@ impl<'tcx> Instance<'tcx> {\n         self.def.has_polymorphic_mir_body().then_some(self.substs)\n     }\n \n-    pub fn subst_mir<T>(&self, tcx: TyCtxt<'tcx>, v: &T) -> T\n+    pub fn subst_mir<T>(&self, tcx: TyCtxt<'tcx>, v: EarlyBinder<&T>) -> T\n     where\n         T: TypeFoldable<TyCtxt<'tcx>> + Copy,\n     {\n+        let v = v.map_bound(|v| *v);\n         if let Some(substs) = self.substs_for_mir_body() {\n-            EarlyBinder(*v).subst(tcx, substs)\n+            v.subst(tcx, substs)\n         } else {\n-            *v\n+            v.skip_binder()\n         }\n     }\n \n@@ -594,15 +595,15 @@ impl<'tcx> Instance<'tcx> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        v: T,\n+        v: EarlyBinder<T>,\n     ) -> T\n     where\n         T: TypeFoldable<TyCtxt<'tcx>> + Clone,\n     {\n         if let Some(substs) = self.substs_for_mir_body() {\n             tcx.subst_and_normalize_erasing_regions(substs, param_env, v)\n         } else {\n-            tcx.normalize_erasing_regions(param_env, v)\n+            tcx.normalize_erasing_regions(param_env, v.skip_binder())\n         }\n     }\n \n@@ -611,15 +612,15 @@ impl<'tcx> Instance<'tcx> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        v: T,\n+        v: EarlyBinder<T>,\n     ) -> Result<T, NormalizationError<'tcx>>\n     where\n         T: TypeFoldable<TyCtxt<'tcx>> + Clone,\n     {\n         if let Some(substs) = self.substs_for_mir_body() {\n             tcx.try_subst_and_normalize_erasing_regions(substs, param_env, v)\n         } else {\n-            tcx.try_normalize_erasing_regions(param_env, v)\n+            tcx.try_normalize_erasing_regions(param_env, v.skip_binder())\n         }\n     }\n "}, {"sha": "47cf48f46cf891fbff7c6493190295f94638ad66", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -324,7 +324,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.kind() {\n-                    ty::Param(_) | ty::Alias(ty::Projection, _) => {\n+                    ty::Param(_) | ty::Alias(ty::Projection | ty::Inherent, _) => {\n                         debug_assert!(tail.has_non_region_param());\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }"}, {"sha": "f882f54d6281118999c2e1badb136b59dcb58b44", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1004,7 +1004,7 @@ impl<'tcx> Term<'tcx> {\n         match self.unpack() {\n             TermKind::Ty(ty) => match ty.kind() {\n                 ty::Alias(kind, alias_ty) => match kind {\n-                    AliasKind::Projection => Some(*alias_ty),\n+                    AliasKind::Projection | AliasKind::Inherent => Some(*alias_ty),\n                     AliasKind::Opaque => None,\n                 },\n                 _ => None,\n@@ -1739,7 +1739,7 @@ pub struct Destructor {\n \n bitflags! {\n     #[derive(HashStable, TyEncodable, TyDecodable)]\n-    pub struct VariantFlags: u32 {\n+    pub struct VariantFlags: u8 {\n         const NO_VARIANT_FLAGS        = 0;\n         /// Indicates whether the field list of this variant is `#[non_exhaustive]`.\n         const IS_FIELD_LIST_NON_EXHAUSTIVE = 1 << 0;"}, {"sha": "9332b0430ffca294bcbbea218abb6ddef9b34365", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         param_substs: SubstsRef<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: T,\n+        value: EarlyBinder<T>,\n     ) -> T\n     where\n         T: TypeFoldable<TyCtxt<'tcx>>,\n@@ -151,7 +151,7 @@ impl<'tcx> TyCtxt<'tcx> {\n              param_env={:?})\",\n             param_substs, value, param_env,\n         );\n-        let substituted = EarlyBinder(value).subst(self, param_substs);\n+        let substituted = value.subst(self, param_substs);\n         self.normalize_erasing_regions(param_env, substituted)\n     }\n \n@@ -163,7 +163,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         param_substs: SubstsRef<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: T,\n+        value: EarlyBinder<T>,\n     ) -> Result<T, NormalizationError<'tcx>>\n     where\n         T: TypeFoldable<TyCtxt<'tcx>>,\n@@ -175,7 +175,7 @@ impl<'tcx> TyCtxt<'tcx> {\n              param_env={:?})\",\n             param_substs, value, param_env,\n         );\n-        let substituted = EarlyBinder(value).subst(self, param_substs);\n+        let substituted = value.subst(self, param_substs);\n         self.try_normalize_erasing_regions(param_env, substituted)\n     }\n }"}, {"sha": "926172ff828c725a9451a193b3d3c7f0cdacad72", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -729,7 +729,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Foreign(def_id) => {\n                 p!(print_def_path(def_id, &[]));\n             }\n-            ty::Alias(ty::Projection, ref data) => {\n+            ty::Alias(ty::Projection | ty::Inherent, ref data) => {\n                 if !(self.should_print_verbose() || NO_QUERIES.with(|q| q.get()))\n                     && self.tcx().is_impl_trait_in_trait(data.def_id)\n                 {"}, {"sha": "da43475941ee5a309780d63a02e38febb36ec9bc", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -550,6 +550,11 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n             Ok(tcx.mk_projection(projection_ty.def_id, projection_ty.substs))\n         }\n \n+        (&ty::Alias(ty::Inherent, a_data), &ty::Alias(ty::Inherent, b_data)) => {\n+            let alias_ty = relation.relate(a_data, b_data)?;\n+            Ok(tcx.mk_alias(ty::Inherent, tcx.mk_alias_ty(alias_ty.def_id, alias_ty.substs)))\n+        }\n+\n         (\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: a_substs, .. }),\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: b_substs, .. }),"}, {"sha": "8d0737e1eeeeb979b95e4ff4fb1ca194c6984f81", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1190,9 +1190,9 @@ where\n \n /// Represents the projection of an associated type.\n ///\n-/// For a projection, this would be `<Ty as Trait<...>>::N`.\n-///\n-/// For an opaque type, there is no explicit syntax.\n+/// * For a projection, this would be `<Ty as Trait<...>>::N<...>`.\n+/// * For an inherent projection, this would be `Ty::N<...>`.\n+/// * For an opaque type, there is no explicit syntax.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct AliasTy<'tcx> {\n@@ -1201,12 +1201,16 @@ pub struct AliasTy<'tcx> {\n     /// For a projection, these are the substitutions for the trait and the\n     /// GAT substitutions, if there are any.\n     ///\n+    /// For an inherent projection, they consist of the self type and the GAT substitutions,\n+    /// if there are any.\n+    ///\n     /// For RPIT the substitutions are for the generics of the function,\n     /// while for TAIT it is used for the generic parameters of the alias.\n     pub substs: SubstsRef<'tcx>,\n \n-    /// The `DefId` of the `TraitItem` for the associated type `N` if this is a projection,\n-    /// or the `OpaqueType` item if this is an opaque.\n+    /// The `DefId` of the `TraitItem` or `ImplItem` for the associated type `N` depending on whether\n+    /// this is a projection or an inherent projection or the `DefId` of the `OpaqueType` item if\n+    /// this is an opaque.\n     ///\n     /// During codegen, `tcx.type_of(def_id)` can be used to get the type of the\n     /// underlying type if the type is an opaque.\n@@ -1224,6 +1228,7 @@ pub struct AliasTy<'tcx> {\n impl<'tcx> AliasTy<'tcx> {\n     pub fn kind(self, tcx: TyCtxt<'tcx>) -> ty::AliasKind {\n         match tcx.def_kind(self.def_id) {\n+            DefKind::AssocTy if let DefKind::Impl { of_trait: false } = tcx.def_kind(tcx.parent(self.def_id)) => ty::Inherent,\n             DefKind::AssocTy | DefKind::ImplTraitPlaceholder => ty::Projection,\n             DefKind::OpaqueTy => ty::Opaque,\n             kind => bug!(\"unexpected DefKind in AliasTy: {kind:?}\"),\n@@ -1236,6 +1241,17 @@ impl<'tcx> AliasTy<'tcx> {\n }\n \n /// The following methods work only with associated type projections.\n+impl<'tcx> AliasTy<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n+        self.substs.type_at(0)\n+    }\n+\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        tcx.mk_alias_ty(self.def_id, [self_ty.into()].into_iter().chain(self.substs.iter().skip(1)))\n+    }\n+}\n+\n+/// The following methods work only with trait associated type projections.\n impl<'tcx> AliasTy<'tcx> {\n     pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n         match tcx.def_kind(self.def_id) {\n@@ -1274,13 +1290,28 @@ impl<'tcx> AliasTy<'tcx> {\n         let def_id = self.trait_def_id(tcx);\n         ty::TraitRef::new(tcx, def_id, self.substs.truncate_to(tcx, tcx.generics_of(def_id)))\n     }\n+}\n \n-    pub fn self_ty(self) -> Ty<'tcx> {\n-        self.substs.type_at(0)\n-    }\n+/// The following methods work only with inherent associated type projections.\n+impl<'tcx> AliasTy<'tcx> {\n+    /// Transform the substitutions to have the given `impl` substs as the base and the GAT substs on top of that.\n+    ///\n+    /// Does the following transformation:\n+    ///\n+    /// ```text\n+    /// [Self, P_0...P_m] -> [I_0...I_n, P_0...P_m]\n+    ///\n+    ///     I_i impl subst\n+    ///     P_j GAT subst\n+    /// ```\n+    pub fn rebase_substs_onto_impl(\n+        self,\n+        impl_substs: ty::SubstsRef<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> ty::SubstsRef<'tcx> {\n+        debug_assert_eq!(self.kind(tcx), ty::Inherent);\n \n-    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n-        tcx.mk_alias_ty(self.def_id, [self_ty.into()].into_iter().chain(self.substs.iter().skip(1)))\n+        tcx.mk_substs_from_iter(impl_substs.into_iter().chain(self.substs.into_iter().skip(1)))\n     }\n }\n "}, {"sha": "520bb55e031c70f366f8e6029eb37cc84c86b421", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -49,6 +49,9 @@ pub trait TypeVisitableExt<'tcx>: TypeVisitable<TyCtxt<'tcx>> {\n     fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n     }\n+    fn has_inherent_projections(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_INHERENT)\n+    }\n     fn has_opaque_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n     }"}, {"sha": "171db6965ac18f9a9cd1ee90111655245a154b62", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -26,7 +26,7 @@ pub use self::borrowed_locals::borrowed_locals;\n pub use self::borrowed_locals::MaybeBorrowedLocals;\n pub use self::liveness::MaybeLiveLocals;\n pub use self::liveness::MaybeTransitiveLiveLocals;\n-pub use self::storage_liveness::{MaybeRequiresStorage, MaybeStorageLive};\n+pub use self::storage_liveness::{MaybeRequiresStorage, MaybeStorageDead, MaybeStorageLive};\n \n /// `MaybeInitializedPlaces` tracks all places that might be\n /// initialized upon reaching a particular point in the control flow"}, {"sha": "463ce083a64fd643cf2797d44383daeb846caabc", "filename": "compiler/rustc_mir_dataflow/src/impls/storage_liveness.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -74,6 +74,73 @@ impl<'tcx, 'a> crate::GenKillAnalysis<'tcx> for MaybeStorageLive<'a> {\n     }\n }\n \n+#[derive(Clone)]\n+pub struct MaybeStorageDead {\n+    always_live_locals: BitSet<Local>,\n+}\n+\n+impl MaybeStorageDead {\n+    pub fn new(always_live_locals: BitSet<Local>) -> Self {\n+        MaybeStorageDead { always_live_locals }\n+    }\n+}\n+\n+impl<'tcx> crate::AnalysisDomain<'tcx> for MaybeStorageDead {\n+    type Domain = BitSet<Local>;\n+\n+    const NAME: &'static str = \"maybe_storage_dead\";\n+\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = live\n+        BitSet::new_empty(body.local_decls.len())\n+    }\n+\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, on_entry: &mut Self::Domain) {\n+        assert_eq!(body.local_decls.len(), self.always_live_locals.domain_size());\n+        // Do not iterate on return place and args, as they are trivially always live.\n+        for local in body.vars_and_temps_iter() {\n+            if !self.always_live_locals.contains(local) {\n+                on_entry.insert(local);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> crate::GenKillAnalysis<'tcx> for MaybeStorageDead {\n+    type Idx = Local;\n+\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        stmt: &mir::Statement<'tcx>,\n+        _: Location,\n+    ) {\n+        match stmt.kind {\n+            StatementKind::StorageLive(l) => trans.kill(l),\n+            StatementKind::StorageDead(l) => trans.gen(l),\n+            _ => (),\n+        }\n+    }\n+\n+    fn terminator_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _: &mir::Terminator<'tcx>,\n+        _: Location,\n+    ) {\n+        // Terminators have no effect\n+    }\n+\n+    fn call_return_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _block: BasicBlock,\n+        _return_places: CallReturnPlaces<'_, 'tcx>,\n+    ) {\n+        // Nothing to do when a call returns successfully\n+    }\n+}\n+\n type BorrowedLocalsResults<'a, 'tcx> = ResultsRefCursor<'a, 'a, 'tcx, MaybeBorrowedLocals>;\n \n /// Dataflow analysis that determines whether each local requires storage at a"}, {"sha": "eca5f98a2c01cd22cfa1362a751fe36db913e2d5", "filename": "compiler/rustc_mir_transform/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2FCargo.toml?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -24,6 +24,8 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_span = { path = \"../rustc_span\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n \n [dev-dependencies]\n coverage_test_macros = { path = \"src/coverage/test_macros\" }"}, {"sha": "8c85cb5f76d8627076b9f7f7dc5d50e2678dfb03", "filename": "compiler/rustc_mir_transform/messages.ftl", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fmessages.ftl?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -0,0 +1,66 @@\n+mir_transform_const_modify = attempting to modify a `const` item\n+    .note = each usage of a `const` item creates a new temporary; the original `const` item will not be modified\n+\n+mir_transform_const_mut_borrow = taking a mutable reference to a `const` item\n+    .note = each usage of a `const` item creates a new temporary\n+    .note2 = the mutable reference will refer to this temporary, not the original `const` item\n+    .note3 = mutable reference created due to call to this method\n+\n+mir_transform_const_defined_here = `const` item defined here\n+\n+mir_transform_unaligned_packed_ref = reference to packed field is unaligned\n+    .note = packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\n+    .note_ub = creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+    .help = copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+mir_transform_unused_unsafe = unnecessary `unsafe` block\n+    .label = because it's nested under this `unsafe` block\n+\n+mir_transform_requires_unsafe = {$details} is unsafe and requires unsafe {$op_in_unsafe_fn_allowed ->\n+    [true] function or block\n+    *[false] block\n+    }\n+    .not_inherited = items do not inherit unsafety from separate enclosing items\n+\n+mir_transform_call_to_unsafe_label = call to unsafe function\n+mir_transform_call_to_unsafe_note = consult the function's documentation for information on how to avoid undefined behavior\n+mir_transform_use_of_asm_label = use of inline assembly\n+mir_transform_use_of_asm_note = inline assembly is entirely unchecked and can cause undefined behavior\n+mir_transform_initializing_valid_range_label = initializing type with `rustc_layout_scalar_valid_range` attr\n+mir_transform_initializing_valid_range_note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+mir_transform_const_ptr2int_label = cast of pointer to int\n+mir_transform_const_ptr2int_note = casting pointers to integers in constants\n+mir_transform_use_of_static_mut_label = use of mutable static\n+mir_transform_use_of_static_mut_note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+mir_transform_use_of_extern_static_label = use of extern static\n+mir_transform_use_of_extern_static_note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+mir_transform_deref_ptr_label = dereference of raw pointer\n+mir_transform_deref_ptr_note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+mir_transform_union_access_label = access to union field\n+mir_transform_union_access_note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+mir_transform_mutation_layout_constrained_label = mutation of layout constrained field\n+mir_transform_mutation_layout_constrained_note = mutating layout constrained fields cannot statically be checked for valid values\n+mir_transform_mutation_layout_constrained_borrow_label = borrow of layout constrained field with interior mutability\n+mir_transform_mutation_layout_constrained_borrow_note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+mir_transform_target_feature_call_label = call to function with `#[target_feature]`\n+mir_transform_target_feature_call_note = can only be called if the required target features are available\n+\n+mir_transform_unsafe_op_in_unsafe_fn = {$details} is unsafe and requires unsafe block (error E0133)\n+\n+mir_transform_arithmetic_overflow = this arithmetic operation will overflow\n+mir_transform_operation_will_panic = this operation will panic at runtime\n+\n+mir_transform_ffi_unwind_call = call to {$foreign ->\n+    [true] foreign function\n+    *[false] function pointer\n+    } with FFI-unwind ABI\n+\n+mir_transform_fn_item_ref = taking a reference to a function item does not give a function pointer\n+    .suggestion = cast `{$ident}` to obtain a function pointer\n+\n+mir_transform_must_not_suspend = {$pre}`{$def_path}`{$post} held across a suspend point, but should not be\n+    .label = the value is held across this suspend point\n+    .note = {$reason}\n+    .help = consider using a block (`{\"{ ... }\"}`) to shrink the value's scope, ending before the suspend point\n+\n+mir_transform_simd_shuffle_last_const = last argument of `simd_shuffle` is required to be a `const` item"}, {"sha": "b79150737d6129fc5cd9936b82b69333b177d6b1", "filename": "compiler/rustc_mir_transform/src/check_const_item_mutation.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,11 +1,12 @@\n-use rustc_errors::{DiagnosticBuilder, DiagnosticMessage};\n+use rustc_hir::HirId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::CONST_ITEM_MUTATION;\n use rustc_span::def_id::DefId;\n+use rustc_span::Span;\n \n-use crate::MirLint;\n+use crate::{errors, MirLint};\n \n pub struct CheckConstItemMutation;\n \n@@ -58,16 +59,14 @@ impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n         }\n     }\n \n-    fn lint_const_item_usage(\n+    /// If we should lint on this usage, return the [`HirId`], source [`Span`]\n+    /// and [`Span`] of the const item to use in the lint.\n+    fn should_lint_const_item_usage(\n         &self,\n         place: &Place<'tcx>,\n         const_item: DefId,\n         location: Location,\n-        msg: impl Into<DiagnosticMessage>,\n-        decorate: impl for<'a, 'b> FnOnce(\n-            &'a mut DiagnosticBuilder<'b, ()>,\n-        ) -> &'a mut DiagnosticBuilder<'b, ()>,\n-    ) {\n+    ) -> Option<(HirId, Span, Span)> {\n         // Don't lint on borrowing/assigning when a dereference is involved.\n         // If we 'leave' the temporary via a dereference, we must\n         // be modifying something else\n@@ -83,16 +82,9 @@ impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n                 .assert_crate_local()\n                 .lint_root;\n \n-            self.tcx.struct_span_lint_hir(\n-                CONST_ITEM_MUTATION,\n-                lint_root,\n-                source_info.span,\n-                msg,\n-                |lint| {\n-                    decorate(lint)\n-                        .span_note(self.tcx.def_span(const_item), \"`const` item defined here\")\n-                },\n-            );\n+            Some((lint_root, source_info.span, self.tcx.def_span(const_item)))\n+        } else {\n+            None\n         }\n     }\n }\n@@ -104,10 +96,14 @@ impl<'tcx> Visitor<'tcx> for ConstMutationChecker<'_, 'tcx> {\n             // Assigning directly to a constant (e.g. `FOO = true;`) is a hard error,\n             // so emitting a lint would be redundant.\n             if !lhs.projection.is_empty() {\n-                if let Some(def_id) = self.is_const_item_without_destructor(lhs.local) {\n-                    self.lint_const_item_usage(&lhs, def_id, loc, \"attempting to modify a `const` item\",|lint| {\n-                        lint.note(\"each usage of a `const` item creates a new temporary; the original `const` item will not be modified\")\n-                    })\n+                if let Some(def_id) = self.is_const_item_without_destructor(lhs.local)\n+                    && let Some((lint_root, span, item)) = self.should_lint_const_item_usage(&lhs, def_id, loc) {\n+                        self.tcx.emit_spanned_lint(\n+                            CONST_ITEM_MUTATION,\n+                            lint_root,\n+                            span,\n+                            errors::ConstMutate::Modify { konst: item }\n+                        );\n                 }\n             }\n             // We are looking for MIR of the form:\n@@ -143,17 +139,22 @@ impl<'tcx> Visitor<'tcx> for ConstMutationChecker<'_, 'tcx> {\n                 });\n                 let lint_loc =\n                     if method_did.is_some() { self.body.terminator_loc(loc.block) } else { loc };\n-                self.lint_const_item_usage(place, def_id, lint_loc, \"taking a mutable reference to a `const` item\", |lint| {\n-                    lint\n-                        .note(\"each usage of a `const` item creates a new temporary\")\n-                        .note(\"the mutable reference will refer to this temporary, not the original `const` item\");\n-\n-                    if let Some((method_did, _substs)) = method_did {\n-                        lint.span_note(self.tcx.def_span(method_did), \"mutable reference created due to call to this method\");\n-                    }\n \n-                    lint\n-                });\n+                let method_call = if let Some((method_did, _)) = method_did {\n+                    Some(self.tcx.def_span(method_did))\n+                } else {\n+                    None\n+                };\n+                if let Some((lint_root, span, item)) =\n+                    self.should_lint_const_item_usage(place, def_id, lint_loc)\n+                {\n+                    self.tcx.emit_spanned_lint(\n+                        CONST_ITEM_MUTATION,\n+                        lint_root,\n+                        span,\n+                        errors::ConstMutate::MutBorrow { method_call, konst: item },\n+                    );\n+                }\n             }\n         }\n         self.super_rvalue(rvalue, loc);"}, {"sha": "2e6cf603d5968938b463e0b85291388dd70ba6be", "filename": "compiler/rustc_mir_transform/src/check_packed_ref.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,10 +1,9 @@\n-use rustc_errors::struct_span_err;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n \n-use crate::util;\n use crate::MirLint;\n+use crate::{errors, util};\n \n pub struct CheckPackedRef;\n \n@@ -49,25 +48,7 @@ impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n                     // shouldn't do.\n                     span_bug!(self.source_info.span, \"builtin derive created an unaligned reference\");\n                 } else {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        self.source_info.span,\n-                        E0793,\n-                        \"reference to packed field is unaligned\"\n-                    )\n-                    .note(\n-                        \"packed structs are only aligned by one byte, and many modern architectures \\\n-                        penalize unaligned field accesses\"\n-                    )\n-                    .note(\n-                        \"creating a misaligned reference is undefined behavior (even if that \\\n-                        reference is never dereferenced)\",\n-                    ).help(\n-                        \"copy the field contents to a local variable, or replace the \\\n-                        reference with a raw pointer and use `read_unaligned`/`write_unaligned` \\\n-                        (loads and stores via `*p` must be properly aligned even when using raw pointers)\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(errors::UnalignedPackedRef { span: self.source_info.span });\n                 }\n             }\n         }"}, {"sha": "bdb4f20da10590c31a132c42c2ca8fec238c784c", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,4 @@\n use rustc_data_structures::unord::{UnordItems, UnordSet};\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -15,6 +14,8 @@ use rustc_session::lint::Level;\n \n use std::ops::Bound;\n \n+use crate::errors;\n+\n pub struct UnsafetyChecker<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     body_did: LocalDefId,\n@@ -509,21 +510,12 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def: LocalDefId) -> &UnsafetyCheckResu\n \n fn report_unused_unsafe(tcx: TyCtxt<'_>, kind: UnusedUnsafe, id: HirId) {\n     let span = tcx.sess.source_map().guess_head_span(tcx.hir().span(id));\n-    let msg = \"unnecessary `unsafe` block\";\n-    tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg, |lint| {\n-        lint.span_label(span, msg);\n-        match kind {\n-            UnusedUnsafe::Unused => {}\n-            UnusedUnsafe::InUnsafeBlock(id) => {\n-                lint.span_label(\n-                    tcx.sess.source_map().guess_head_span(tcx.hir().span(id)),\n-                    \"because it's nested under this `unsafe` block\",\n-                );\n-            }\n-        }\n-\n-        lint\n-    });\n+    let nested_parent = if let UnusedUnsafe::InUnsafeBlock(id) = kind {\n+        Some(tcx.sess.source_map().guess_head_span(tcx.hir().span(id)))\n+    } else {\n+        None\n+    };\n+    tcx.emit_spanned_lint(UNUSED_UNSAFE, id, span, errors::UnusedUnsafe { span, nested_parent });\n }\n \n pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n@@ -537,26 +529,11 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let UnsafetyCheckResult { violations, unused_unsafes, .. } = tcx.unsafety_check_result(def_id);\n \n     for &UnsafetyViolation { source_info, lint_root, kind, details } in violations.iter() {\n-        let (description, note) = details.description_and_note();\n+        let details = errors::RequiresUnsafeDetail { violation: details, span: source_info.span };\n \n         match kind {\n             UnsafetyViolationKind::General => {\n-                // once\n-                let unsafe_fn_msg = if unsafe_op_in_unsafe_fn_allowed(tcx, lint_root) {\n-                    \" function or\"\n-                } else {\n-                    \"\"\n-                };\n-\n-                let mut err = struct_span_err!(\n-                    tcx.sess,\n-                    source_info.span,\n-                    E0133,\n-                    \"{} is unsafe and requires unsafe{} block\",\n-                    description,\n-                    unsafe_fn_msg,\n-                );\n-                err.span_label(source_info.span, description).note(note);\n+                let op_in_unsafe_fn_allowed = unsafe_op_in_unsafe_fn_allowed(tcx, lint_root);\n                 let note_non_inherited = tcx.hir().parent_iter(lint_root).find(|(id, node)| {\n                     if let Node::Expr(block) = node\n                         && let ExprKind::Block(block, _) = block.kind\n@@ -572,22 +549,23 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                         false\n                     }\n                 });\n-                if let Some((id, _)) = note_non_inherited {\n-                    let span = tcx.hir().span(id);\n-                    err.span_label(\n-                        tcx.sess.source_map().guess_head_span(span),\n-                        \"items do not inherit unsafety from separate enclosing items\",\n-                    );\n-                }\n-\n-                err.emit();\n+                let enclosing = if let Some((id, _)) = note_non_inherited {\n+                    Some(tcx.sess.source_map().guess_head_span(tcx.hir().span(id)))\n+                } else {\n+                    None\n+                };\n+                tcx.sess.emit_err(errors::RequiresUnsafe {\n+                    span: source_info.span,\n+                    enclosing,\n+                    details,\n+                    op_in_unsafe_fn_allowed,\n+                });\n             }\n-            UnsafetyViolationKind::UnsafeFn => tcx.struct_span_lint_hir(\n+            UnsafetyViolationKind::UnsafeFn => tcx.emit_spanned_lint(\n                 UNSAFE_OP_IN_UNSAFE_FN,\n                 lint_root,\n                 source_info.span,\n-                format!(\"{} is unsafe and requires unsafe block (error E0133)\", description,),\n-                |lint| lint.span_label(source_info.span, description).note(note),\n+                errors::UnsafeOpInUnsafeFn { details },\n             ),\n         }\n     }"}, {"sha": "a5d18fff89bd79c63a47ef71d75b4d83678ed9bb", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -806,6 +806,24 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         }\n     }\n \n+    fn process_projection_elem(\n+        &mut self,\n+        elem: PlaceElem<'tcx>,\n+        _: Location,\n+    ) -> Option<PlaceElem<'tcx>> {\n+        if let PlaceElem::Index(local) = elem\n+            && let Some(value) = self.get_const(local.into())\n+            && self.should_const_prop(&value)\n+            && let interpret::Operand::Immediate(interpret::Immediate::Scalar(scalar)) = *value\n+            && let Ok(offset) = scalar.to_target_usize(&self.tcx)\n+            && let Some(min_length) = offset.checked_add(1)\n+        {\n+            Some(PlaceElem::ConstantIndex { offset, min_length, from_end: false })\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn visit_assign(\n         &mut self,\n         place: &mut Place<'tcx>,"}, {"sha": "adb09c509d287e8f8a646beb0df113f21c56eb1d", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,6 +1,8 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n+use std::fmt::Debug;\n+\n use either::Left;\n \n use rustc_const_eval::interpret::Immediate;\n@@ -17,14 +19,14 @@ use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{\n     self, ConstInt, Instance, ParamEnv, ScalarInt, Ty, TyCtxt, TypeVisitableExt,\n };\n-use rustc_session::lint;\n use rustc_span::Span;\n use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n use rustc_trait_selection::traits;\n \n use crate::const_prop::CanConstProp;\n use crate::const_prop::ConstPropMachine;\n use crate::const_prop::ConstPropMode;\n+use crate::errors::AssertLint;\n use crate::MirLint;\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -311,18 +313,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn report_assert_as_lint(\n-        &self,\n-        lint: &'static lint::Lint,\n-        location: Location,\n-        message: &'static str,\n-        panic: AssertKind<impl std::fmt::Debug>,\n-    ) {\n-        let source_info = self.body().source_info(location);\n+    fn report_assert_as_lint(&self, source_info: &SourceInfo, lint: AssertLint<impl Debug>) {\n         if let Some(lint_root) = self.lint_root(*source_info) {\n-            self.tcx.struct_span_lint_hir(lint, lint_root, source_info.span, message, |lint| {\n-                lint.span_label(source_info.span, format!(\"{:?}\", panic))\n-            });\n+            self.tcx.emit_spanned_lint(lint.lint(), lint_root, source_info.span, lint);\n         }\n     }\n \n@@ -335,11 +328,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // `AssertKind` only has an `OverflowNeg` variant, so make sure that is\n             // appropriate to use.\n             assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n+            let source_info = self.body().source_info(location);\n             self.report_assert_as_lint(\n-                lint::builtin::ARITHMETIC_OVERFLOW,\n-                location,\n-                \"this arithmetic operation will overflow\",\n-                AssertKind::OverflowNeg(val.to_const_int()),\n+                source_info,\n+                AssertLint::ArithmeticOverflow(\n+                    source_info.span,\n+                    AssertKind::OverflowNeg(val.to_const_int()),\n+                ),\n             );\n             return None;\n         }\n@@ -370,23 +365,23 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let r_bits = r.to_scalar().to_bits(right_size).ok();\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n                 debug!(\"check_binary_op: reporting assert for {:?}\", location);\n+                let source_info = self.body().source_info(location);\n+                let panic = AssertKind::Overflow(\n+                    op,\n+                    match l {\n+                        Some(l) => l.to_const_int(),\n+                        // Invent a dummy value, the diagnostic ignores it anyway\n+                        None => ConstInt::new(\n+                            ScalarInt::try_from_uint(1_u8, left_size).unwrap(),\n+                            left_ty.is_signed(),\n+                            left_ty.is_ptr_sized_integral(),\n+                        ),\n+                    },\n+                    r.to_const_int(),\n+                );\n                 self.report_assert_as_lint(\n-                    lint::builtin::ARITHMETIC_OVERFLOW,\n-                    location,\n-                    \"this arithmetic operation will overflow\",\n-                    AssertKind::Overflow(\n-                        op,\n-                        match l {\n-                            Some(l) => l.to_const_int(),\n-                            // Invent a dummy value, the diagnostic ignores it anyway\n-                            None => ConstInt::new(\n-                                ScalarInt::try_from_uint(1_u8, left_size).unwrap(),\n-                                left_ty.is_signed(),\n-                                left_ty.is_ptr_sized_integral(),\n-                            ),\n-                        },\n-                        r.to_const_int(),\n-                    ),\n+                    source_info,\n+                    AssertLint::ArithmeticOverflow(source_info.span, panic),\n                 );\n                 return None;\n             }\n@@ -398,11 +393,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, &l, &r)?;\n                 Ok(overflow)\n             })? {\n+                let source_info = self.body().source_info(location);\n                 self.report_assert_as_lint(\n-                    lint::builtin::ARITHMETIC_OVERFLOW,\n-                    location,\n-                    \"this arithmetic operation will overflow\",\n-                    AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n+                    source_info,\n+                    AssertLint::ArithmeticOverflow(\n+                        source_info.span,\n+                        AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n+                    ),\n                 );\n                 return None;\n             }\n@@ -543,11 +540,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 // Need proper const propagator for these.\n                 _ => return None,\n             };\n+            let source_info = self.body().source_info(location);\n             self.report_assert_as_lint(\n-                lint::builtin::UNCONDITIONAL_PANIC,\n-                location,\n-                \"this operation will panic at runtime\",\n-                msg,\n+                source_info,\n+                AssertLint::UnconditionalPanic(source_info.span, msg),\n             );\n         }\n "}, {"sha": "c565d6f13b17f7b2799d6423cbdf2d124539fdeb", "filename": "compiler/rustc_mir_transform/src/copy_prop.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -33,9 +33,8 @@ impl<'tcx> MirPass<'tcx> for CopyProp {\n }\n \n fn propagate_ssa<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-    let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n     let borrowed_locals = borrowed_locals(body);\n-    let ssa = SsaLocals::new(tcx, param_env, body, &borrowed_locals);\n+    let ssa = SsaLocals::new(body);\n \n     let fully_moved = fully_moved_locals(&ssa, body);\n     debug!(?fully_moved);\n@@ -76,7 +75,7 @@ fn propagate_ssa<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n fn fully_moved_locals(ssa: &SsaLocals, body: &Body<'_>) -> BitSet<Local> {\n     let mut fully_moved = BitSet::new_filled(body.local_decls.len());\n \n-    for (_, rvalue) in ssa.assignments(body) {\n+    for (_, rvalue, _) in ssa.assignments(body) {\n         let (Rvalue::Use(Operand::Copy(place) | Operand::Move(place)) | Rvalue::CopyForDeref(place))\n             = rvalue\n         else { continue };"}, {"sha": "602e40d513104c0517da0a89a135dcadf4307de2", "filename": "compiler/rustc_mir_transform/src/errors.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -0,0 +1,245 @@\n+use rustc_errors::{\n+    DecorateLint, DiagnosticBuilder, DiagnosticMessage, EmissionGuarantee, Handler, IntoDiagnostic,\n+};\n+use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n+use rustc_middle::mir::{AssertKind, UnsafetyViolationDetails};\n+use rustc_session::lint::{self, Lint};\n+use rustc_span::Span;\n+\n+#[derive(LintDiagnostic)]\n+pub(crate) enum ConstMutate {\n+    #[diag(mir_transform_const_modify)]\n+    #[note]\n+    Modify {\n+        #[note(mir_transform_const_defined_here)]\n+        konst: Span,\n+    },\n+    #[diag(mir_transform_const_mut_borrow)]\n+    #[note]\n+    #[note(mir_transform_note2)]\n+    MutBorrow {\n+        #[note(mir_transform_note3)]\n+        method_call: Option<Span>,\n+        #[note(mir_transform_const_defined_here)]\n+        konst: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_transform_unaligned_packed_ref, code = \"E0793\")]\n+#[note]\n+#[note(mir_transform_note_ub)]\n+#[help]\n+pub(crate) struct UnalignedPackedRef {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_transform_unused_unsafe)]\n+pub(crate) struct UnusedUnsafe {\n+    #[label(mir_transform_unused_unsafe)]\n+    pub span: Span,\n+    #[label]\n+    pub nested_parent: Option<Span>,\n+}\n+\n+pub(crate) struct RequiresUnsafe {\n+    pub span: Span,\n+    pub details: RequiresUnsafeDetail,\n+    pub enclosing: Option<Span>,\n+    pub op_in_unsafe_fn_allowed: bool,\n+}\n+\n+// The primary message for this diagnostic should be '{$label} is unsafe and...',\n+// so we need to eagerly translate the label here, which isn't supported by the derive API\n+// We could also exhaustively list out the primary messages for all unsafe violations,\n+// but this would result in a lot of duplication.\n+impl<'sess, G: EmissionGuarantee> IntoDiagnostic<'sess, G> for RequiresUnsafe {\n+    #[track_caller]\n+    fn into_diagnostic(self, handler: &'sess Handler) -> DiagnosticBuilder<'sess, G> {\n+        let mut diag =\n+            handler.struct_diagnostic(crate::fluent_generated::mir_transform_requires_unsafe);\n+        diag.code(rustc_errors::DiagnosticId::Error(\"E0133\".to_string()));\n+        diag.set_span(self.span);\n+        diag.span_label(self.span, self.details.label());\n+        diag.note(self.details.note());\n+        let desc = handler.eagerly_translate_to_string(self.details.label(), [].into_iter());\n+        diag.set_arg(\"details\", desc);\n+        diag.set_arg(\"op_in_unsafe_fn_allowed\", self.op_in_unsafe_fn_allowed);\n+        if let Some(sp) = self.enclosing {\n+            diag.span_label(sp, crate::fluent_generated::mir_transform_not_inherited);\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub(crate) struct RequiresUnsafeDetail {\n+    pub span: Span,\n+    pub violation: UnsafetyViolationDetails,\n+}\n+\n+impl RequiresUnsafeDetail {\n+    fn note(self) -> DiagnosticMessage {\n+        use UnsafetyViolationDetails::*;\n+        match self.violation {\n+            CallToUnsafeFunction => crate::fluent_generated::mir_transform_call_to_unsafe_note,\n+            UseOfInlineAssembly => crate::fluent_generated::mir_transform_use_of_asm_note,\n+            InitializingTypeWith => {\n+                crate::fluent_generated::mir_transform_initializing_valid_range_note\n+            }\n+            CastOfPointerToInt => crate::fluent_generated::mir_transform_const_ptr2int_note,\n+            UseOfMutableStatic => crate::fluent_generated::mir_transform_use_of_static_mut_note,\n+            UseOfExternStatic => crate::fluent_generated::mir_transform_use_of_extern_static_note,\n+            DerefOfRawPointer => crate::fluent_generated::mir_transform_deref_ptr_note,\n+            AccessToUnionField => crate::fluent_generated::mir_transform_union_access_note,\n+            MutationOfLayoutConstrainedField => {\n+                crate::fluent_generated::mir_transform_mutation_layout_constrained_note\n+            }\n+            BorrowOfLayoutConstrainedField => {\n+                crate::fluent_generated::mir_transform_mutation_layout_constrained_borrow_note\n+            }\n+            CallToFunctionWith => crate::fluent_generated::mir_transform_target_feature_call_note,\n+        }\n+    }\n+\n+    fn label(self) -> DiagnosticMessage {\n+        use UnsafetyViolationDetails::*;\n+        match self.violation {\n+            CallToUnsafeFunction => crate::fluent_generated::mir_transform_call_to_unsafe_label,\n+            UseOfInlineAssembly => crate::fluent_generated::mir_transform_use_of_asm_label,\n+            InitializingTypeWith => {\n+                crate::fluent_generated::mir_transform_initializing_valid_range_label\n+            }\n+            CastOfPointerToInt => crate::fluent_generated::mir_transform_const_ptr2int_label,\n+            UseOfMutableStatic => crate::fluent_generated::mir_transform_use_of_static_mut_label,\n+            UseOfExternStatic => crate::fluent_generated::mir_transform_use_of_extern_static_label,\n+            DerefOfRawPointer => crate::fluent_generated::mir_transform_deref_ptr_label,\n+            AccessToUnionField => crate::fluent_generated::mir_transform_union_access_label,\n+            MutationOfLayoutConstrainedField => {\n+                crate::fluent_generated::mir_transform_mutation_layout_constrained_label\n+            }\n+            BorrowOfLayoutConstrainedField => {\n+                crate::fluent_generated::mir_transform_mutation_layout_constrained_borrow_label\n+            }\n+            CallToFunctionWith => crate::fluent_generated::mir_transform_target_feature_call_label,\n+        }\n+    }\n+}\n+\n+pub(crate) struct UnsafeOpInUnsafeFn {\n+    pub details: RequiresUnsafeDetail,\n+}\n+\n+impl<'a> DecorateLint<'a, ()> for UnsafeOpInUnsafeFn {\n+    #[track_caller]\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut DiagnosticBuilder<'a, ()> {\n+        let desc = diag\n+            .handler()\n+            .expect(\"lint should not yet be emitted\")\n+            .eagerly_translate_to_string(self.details.label(), [].into_iter());\n+        diag.set_arg(\"details\", desc);\n+        diag.span_label(self.details.span, self.details.label());\n+        diag.note(self.details.note());\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        crate::fluent_generated::mir_transform_unsafe_op_in_unsafe_fn\n+    }\n+}\n+\n+pub(crate) enum AssertLint<P> {\n+    ArithmeticOverflow(Span, AssertKind<P>),\n+    UnconditionalPanic(Span, AssertKind<P>),\n+}\n+\n+impl<'a, P: std::fmt::Debug> DecorateLint<'a, ()> for AssertLint<P> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut DiagnosticBuilder<'a, ()> {\n+        diag.span_label(self.span(), format!(\"{:?}\", self.panic()));\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        match self {\n+            AssertLint::ArithmeticOverflow(..) => {\n+                crate::fluent_generated::mir_transform_arithmetic_overflow\n+            }\n+            AssertLint::UnconditionalPanic(..) => {\n+                crate::fluent_generated::mir_transform_operation_will_panic\n+            }\n+        }\n+    }\n+}\n+\n+impl<P> AssertLint<P> {\n+    pub fn lint(&self) -> &'static Lint {\n+        match self {\n+            AssertLint::ArithmeticOverflow(..) => lint::builtin::ARITHMETIC_OVERFLOW,\n+            AssertLint::UnconditionalPanic(..) => lint::builtin::UNCONDITIONAL_PANIC,\n+        }\n+    }\n+    pub fn span(&self) -> Span {\n+        match self {\n+            AssertLint::ArithmeticOverflow(sp, _) | AssertLint::UnconditionalPanic(sp, _) => *sp,\n+        }\n+    }\n+    pub fn panic(&self) -> &AssertKind<P> {\n+        match self {\n+            AssertLint::ArithmeticOverflow(_, p) | AssertLint::UnconditionalPanic(_, p) => p,\n+        }\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_transform_ffi_unwind_call)]\n+pub(crate) struct FfiUnwindCall {\n+    #[label(mir_transform_ffi_unwind_call)]\n+    pub span: Span,\n+    pub foreign: bool,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_transform_fn_item_ref)]\n+pub(crate) struct FnItemRef {\n+    #[suggestion(code = \"{sugg}\", applicability = \"unspecified\")]\n+    pub span: Span,\n+    pub sugg: String,\n+    pub ident: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_transform_must_not_suspend)]\n+pub(crate) struct MustNotSupend<'a> {\n+    #[label]\n+    pub yield_sp: Span,\n+    #[subdiagnostic]\n+    pub reason: Option<MustNotSuspendReason>,\n+    #[help]\n+    pub src_sp: Span,\n+    pub pre: &'a str,\n+    pub def_path: String,\n+    pub post: &'a str,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(mir_transform_note)]\n+pub(crate) struct MustNotSuspendReason {\n+    #[primary_span]\n+    pub span: Span,\n+    pub reason: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_transform_simd_shuffle_last_const)]\n+pub(crate) struct SimdShuffleLastConst {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "ac1de989a7204406d2a4f47a940c57e41042dac3", "filename": "compiler/rustc_mir_transform/src/ffi_unwind_calls.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -8,6 +8,8 @@ use rustc_session::lint::builtin::FFI_UNWIND_CALLS;\n use rustc_target::spec::abi::Abi;\n use rustc_target::spec::PanicStrategy;\n \n+use crate::errors;\n+\n fn abi_can_unwind(abi: Abi) -> bool {\n     use Abi::*;\n     match abi {\n@@ -107,13 +109,13 @@ fn has_ffi_unwind_calls(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> bool {\n                 .lint_root;\n             let span = terminator.source_info.span;\n \n-            let msg = match fn_def_id {\n-                Some(_) => \"call to foreign function with FFI-unwind ABI\",\n-                None => \"call to function pointer with FFI-unwind ABI\",\n-            };\n-            tcx.struct_span_lint_hir(FFI_UNWIND_CALLS, lint_root, span, msg, |lint| {\n-                lint.span_label(span, msg)\n-            });\n+            let foreign = fn_def_id.is_some();\n+            tcx.emit_spanned_lint(\n+                FFI_UNWIND_CALLS,\n+                lint_root,\n+                span,\n+                errors::FfiUnwindCall { span, foreign },\n+            );\n \n             tainted = true;\n         }"}, {"sha": "5989dbebf2db9badf1fd699a1135044768281de0", "filename": "compiler/rustc_mir_transform/src/function_item_references.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,4 @@\n use itertools::Itertools;\n-use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n@@ -8,7 +7,7 @@ use rustc_session::lint::builtin::FUNCTION_ITEM_REFERENCES;\n use rustc_span::{symbol::sym, Span};\n use rustc_target::spec::abi::Abi;\n \n-use crate::MirLint;\n+use crate::{errors, MirLint};\n \n pub struct FunctionItemReferences;\n \n@@ -174,27 +173,21 @@ impl<'tcx> FunctionItemRefChecker<'_, 'tcx> {\n         let num_args = fn_sig.inputs().map_bound(|inputs| inputs.len()).skip_binder();\n         let variadic = if fn_sig.c_variadic() { \", ...\" } else { \"\" };\n         let ret = if fn_sig.output().skip_binder().is_unit() { \"\" } else { \" -> _\" };\n-        self.tcx.struct_span_lint_hir(\n+        let sugg = format!(\n+            \"{} as {}{}fn({}{}){}\",\n+            if params.is_empty() { ident.clone() } else { format!(\"{}::<{}>\", ident, params) },\n+            unsafety,\n+            abi,\n+            vec![\"_\"; num_args].join(\", \"),\n+            variadic,\n+            ret,\n+        );\n+\n+        self.tcx.emit_spanned_lint(\n             FUNCTION_ITEM_REFERENCES,\n             lint_root,\n             span,\n-            \"taking a reference to a function item does not give a function pointer\",\n-            |lint| {\n-                lint.span_suggestion(\n-                    span,\n-                    format!(\"cast `{}` to obtain a function pointer\", ident),\n-                    format!(\n-                        \"{} as {}{}fn({}{}){}\",\n-                        if params.is_empty() { ident } else { format!(\"{}::<{}>\", ident, params) },\n-                        unsafety,\n-                        abi,\n-                        vec![\"_\"; num_args].join(\", \"),\n-                        variadic,\n-                        ret,\n-                    ),\n-                    Applicability::Unspecified,\n-                )\n-            },\n+            errors::FnItemRef { span, sugg, ident },\n         );\n     }\n }"}, {"sha": "c9144729145b6143bb51dbcd4505b1878764a07e", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -51,6 +51,7 @@\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n use crate::deref_separator::deref_finder;\n+use crate::errors;\n use crate::simplify;\n use crate::MirPass;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -1891,36 +1892,21 @@ fn check_must_not_suspend_def(\n     data: SuspendCheckData<'_>,\n ) -> bool {\n     if let Some(attr) = tcx.get_attr(def_id, sym::must_not_suspend) {\n-        let msg = rustc_errors::DelayDm(|| {\n-            format!(\n-                \"{}`{}`{} held across a suspend point, but should not be\",\n-                data.descr_pre,\n-                tcx.def_path_str(def_id),\n-                data.descr_post,\n-            )\n+        let reason = attr.value_str().map(|s| errors::MustNotSuspendReason {\n+            span: data.source_span,\n+            reason: s.as_str().to_string(),\n         });\n-        tcx.struct_span_lint_hir(\n+        tcx.emit_spanned_lint(\n             rustc_session::lint::builtin::MUST_NOT_SUSPEND,\n             hir_id,\n             data.source_span,\n-            msg,\n-            |lint| {\n-                // add span pointing to the offending yield/await\n-                lint.span_label(data.yield_span, \"the value is held across this suspend point\");\n-\n-                // Add optional reason note\n-                if let Some(note) = attr.value_str() {\n-                    // FIXME(guswynn): consider formatting this better\n-                    lint.span_note(data.source_span, note.as_str());\n-                }\n-\n-                // Add some quick suggestions on what to do\n-                // FIXME: can `drop` work as a suggestion here as well?\n-                lint.span_help(\n-                    data.source_span,\n-                    \"consider using a block (`{ ... }`) \\\n-                    to shrink the value's scope, ending before the suspend point\",\n-                )\n+            errors::MustNotSupend {\n+                yield_sp: data.yield_span,\n+                reason,\n+                src_sp: data.source_span,\n+                pre: data.descr_pre,\n+                def_path: tcx.def_path_str(def_id),\n+                post: data.descr_post,\n             },\n         );\n "}, {"sha": "ece20d8d3e6ed9b6d48d2848caa0909c5c2613db", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -180,7 +180,7 @@ impl<'tcx> Inliner<'tcx> {\n         let Ok(callee_body) = callsite.callee.try_subst_mir_and_normalize_erasing_regions(\n             self.tcx,\n             self.param_env,\n-            callee_body.clone(),\n+            ty::EarlyBinder(callee_body.clone()),\n         ) else {\n             return Err(\"failed to normalize callee body\");\n         };\n@@ -444,7 +444,9 @@ impl<'tcx> Inliner<'tcx> {\n                 work_list.push(target);\n \n                 // If the place doesn't actually need dropping, treat it like a regular goto.\n-                let ty = callsite.callee.subst_mir(self.tcx, &place.ty(callee_body, tcx).ty);\n+                let ty = callsite\n+                    .callee\n+                    .subst_mir(self.tcx, ty::EarlyBinder(&place.ty(callee_body, tcx).ty));\n                 if ty.needs_drop(tcx, self.param_env) && let UnwindAction::Cleanup(unwind) = unwind {\n                         work_list.push(unwind);\n                     }\n@@ -788,7 +790,9 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n         match terminator.kind {\n             TerminatorKind::Drop { ref place, unwind, .. } => {\n                 // If the place doesn't actually need dropping, treat it like a regular goto.\n-                let ty = self.instance.subst_mir(tcx, &place.ty(self.callee_body, tcx).ty);\n+                let ty = self\n+                    .instance\n+                    .subst_mir(tcx, ty::EarlyBinder(&place.ty(self.callee_body, tcx).ty));\n                 if ty.needs_drop(tcx, self.param_env) {\n                     self.cost += CALL_PENALTY;\n                     if let UnwindAction::Cleanup(_) = unwind {\n@@ -799,7 +803,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n                 }\n             }\n             TerminatorKind::Call { func: Operand::Constant(ref f), unwind, .. } => {\n-                let fn_ty = self.instance.subst_mir(tcx, &f.literal.ty());\n+                let fn_ty = self.instance.subst_mir(tcx, ty::EarlyBinder(&f.literal.ty()));\n                 self.cost += if let ty::FnDef(def_id, _) = *fn_ty.kind() && tcx.is_intrinsic(def_id) {\n                     // Don't give intrinsics the extra penalty for calls\n                     INSTR_COST"}, {"sha": "1ccf06f6153fc369031864834d55c577dccd2f51", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -44,7 +44,11 @@ pub(crate) fn mir_callgraph_reachable<'tcx>(\n     ) -> bool {\n         trace!(%caller);\n         for &(callee, substs) in tcx.mir_inliner_callees(caller.def) {\n-            let Ok(substs) = caller.try_subst_mir_and_normalize_erasing_regions(tcx, param_env, substs) else {\n+            let Ok(substs) = caller.try_subst_mir_and_normalize_erasing_regions(\n+                tcx,\n+                param_env,\n+                ty::EarlyBinder(substs),\n+            ) else {\n                 trace!(?caller, ?param_env, ?substs, \"cannot normalize, skipping\");\n                 continue;\n             };"}, {"sha": "6bff535586ad30f996167a5a2d0f621f3e1fee27", "filename": "compiler/rustc_mir_transform/src/instsimplify.rs", "status": "renamed", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Finstsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Finstsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finstsimplify.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,6 +1,6 @@\n //! Performs various peephole optimizations.\n \n-use crate::simplify::combine_duplicate_switch_targets;\n+use crate::simplify::simplify_duplicate_switch_targets;\n use crate::MirPass;\n use rustc_hir::Mutability;\n use rustc_middle::mir::*;\n@@ -10,15 +10,15 @@ use rustc_middle::ty::{self, ParamEnv, SubstsRef, Ty, TyCtxt};\n use rustc_span::symbol::Symbol;\n use rustc_target::abi::FieldIdx;\n \n-pub struct InstCombine;\n+pub struct InstSimplify;\n \n-impl<'tcx> MirPass<'tcx> for InstCombine {\n+impl<'tcx> MirPass<'tcx> for InstSimplify {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n         sess.mir_opt_level() > 0\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let ctx = InstCombineContext {\n+        let ctx = InstSimplifyContext {\n             tcx,\n             local_decls: &body.local_decls,\n             param_env: tcx.param_env_reveal_all_normalized(body.source.def_id()),\n@@ -27,43 +27,43 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n             for statement in block.statements.iter_mut() {\n                 match statement.kind {\n                     StatementKind::Assign(box (_place, ref mut rvalue)) => {\n-                        ctx.combine_bool_cmp(&statement.source_info, rvalue);\n-                        ctx.combine_ref_deref(&statement.source_info, rvalue);\n-                        ctx.combine_len(&statement.source_info, rvalue);\n-                        ctx.combine_cast(&statement.source_info, rvalue);\n+                        ctx.simplify_bool_cmp(&statement.source_info, rvalue);\n+                        ctx.simplify_ref_deref(&statement.source_info, rvalue);\n+                        ctx.simplify_len(&statement.source_info, rvalue);\n+                        ctx.simplify_cast(&statement.source_info, rvalue);\n                     }\n                     _ => {}\n                 }\n             }\n \n-            ctx.combine_primitive_clone(\n+            ctx.simplify_primitive_clone(\n                 &mut block.terminator.as_mut().unwrap(),\n                 &mut block.statements,\n             );\n-            ctx.combine_intrinsic_assert(\n+            ctx.simplify_intrinsic_assert(\n                 &mut block.terminator.as_mut().unwrap(),\n                 &mut block.statements,\n             );\n-            combine_duplicate_switch_targets(block.terminator.as_mut().unwrap());\n+            simplify_duplicate_switch_targets(block.terminator.as_mut().unwrap());\n         }\n     }\n }\n \n-struct InstCombineContext<'tcx, 'a> {\n+struct InstSimplifyContext<'tcx, 'a> {\n     tcx: TyCtxt<'tcx>,\n     local_decls: &'a LocalDecls<'tcx>,\n     param_env: ParamEnv<'tcx>,\n }\n \n-impl<'tcx> InstCombineContext<'tcx, '_> {\n-    fn should_combine(&self, source_info: &SourceInfo, rvalue: &Rvalue<'tcx>) -> bool {\n+impl<'tcx> InstSimplifyContext<'tcx, '_> {\n+    fn should_simplify(&self, source_info: &SourceInfo, rvalue: &Rvalue<'tcx>) -> bool {\n         self.tcx.consider_optimizing(|| {\n-            format!(\"InstCombine - Rvalue: {:?} SourceInfo: {:?}\", rvalue, source_info)\n+            format!(\"InstSimplify - Rvalue: {:?} SourceInfo: {:?}\", rvalue, source_info)\n         })\n     }\n \n     /// Transform boolean comparisons into logical operations.\n-    fn combine_bool_cmp(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n+    fn simplify_bool_cmp(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n         match rvalue {\n             Rvalue::BinaryOp(op @ (BinOp::Eq | BinOp::Ne), box (a, b)) => {\n                 let new = match (op, self.try_eval_bool(a), self.try_eval_bool(b)) {\n@@ -94,7 +94,7 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n                     _ => None,\n                 };\n \n-                if let Some(new) = new && self.should_combine(source_info, rvalue) {\n+                if let Some(new) = new && self.should_simplify(source_info, rvalue) {\n                     *rvalue = new;\n                 }\n             }\n@@ -109,14 +109,14 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n     }\n \n     /// Transform \"&(*a)\" ==> \"a\".\n-    fn combine_ref_deref(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n+    fn simplify_ref_deref(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n         if let Rvalue::Ref(_, _, place) = rvalue {\n             if let Some((base, ProjectionElem::Deref)) = place.as_ref().last_projection() {\n                 if rvalue.ty(self.local_decls, self.tcx) != base.ty(self.local_decls, self.tcx).ty {\n                     return;\n                 }\n \n-                if !self.should_combine(source_info, rvalue) {\n+                if !self.should_simplify(source_info, rvalue) {\n                     return;\n                 }\n \n@@ -129,11 +129,11 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n     }\n \n     /// Transform \"Len([_; N])\" ==> \"N\".\n-    fn combine_len(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n+    fn simplify_len(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n         if let Rvalue::Len(ref place) = *rvalue {\n             let place_ty = place.ty(self.local_decls, self.tcx).ty;\n             if let ty::Array(_, len) = *place_ty.kind() {\n-                if !self.should_combine(source_info, rvalue) {\n+                if !self.should_simplify(source_info, rvalue) {\n                     return;\n                 }\n \n@@ -144,7 +144,7 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n         }\n     }\n \n-    fn combine_cast(&self, _source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n+    fn simplify_cast(&self, _source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n         if let Rvalue::Cast(kind, operand, cast_ty) = rvalue {\n             let operand_ty = operand.ty(self.local_decls, self.tcx);\n             if operand_ty == *cast_ty {\n@@ -196,7 +196,7 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n         }\n     }\n \n-    fn combine_primitive_clone(\n+    fn simplify_primitive_clone(\n         &self,\n         terminator: &mut Terminator<'tcx>,\n         statements: &mut Vec<Statement<'tcx>>,\n@@ -239,7 +239,7 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n \n         if !self.tcx.consider_optimizing(|| {\n             format!(\n-                \"InstCombine - Call: {:?} SourceInfo: {:?}\",\n+                \"InstSimplify - Call: {:?} SourceInfo: {:?}\",\n                 (fn_def_id, fn_substs),\n                 terminator.source_info\n             )\n@@ -262,7 +262,7 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n         terminator.kind = TerminatorKind::Goto { target: destination_block };\n     }\n \n-    fn combine_intrinsic_assert(\n+    fn simplify_intrinsic_assert(\n         &self,\n         terminator: &mut Terminator<'tcx>,\n         _statements: &mut Vec<Statement<'tcx>>,", "previous_filename": "compiler/rustc_mir_transform/src/instcombine.rs"}, {"sha": "277237a5515a43c118b11dba91f1cddb4827d60e", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,4 +1,6 @@\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(let_chains)]\n@@ -69,18 +71,20 @@ pub mod dump_mir;\n mod early_otherwise_branch;\n mod elaborate_box_derefs;\n mod elaborate_drops;\n+mod errors;\n mod ffi_unwind_calls;\n mod function_item_references;\n mod generator;\n mod inline;\n-mod instcombine;\n+mod instsimplify;\n mod large_enums;\n mod lower_intrinsics;\n mod lower_slice_len;\n mod match_branches;\n mod multiple_return_terminators;\n mod normalize_array_len;\n mod nrvo;\n+mod ref_prop;\n mod remove_noop_landing_pads;\n mod remove_storage_markers;\n mod remove_uninit_drops;\n@@ -105,6 +109,11 @@ use rustc_const_eval::transform::promote_consts;\n use rustc_const_eval::transform::validate;\n use rustc_mir_dataflow::rustc_peek;\n \n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_fluent_macro::fluent_messages;\n+\n+fluent_messages! { \"../messages.ftl\" }\n+\n pub fn provide(providers: &mut Providers) {\n     check_unsafety::provide(providers);\n     coverage::query::provide(providers);\n@@ -547,10 +556,11 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             &match_branches::MatchBranchSimplification,\n             // inst combine is after MatchBranchSimplification to clean up Ne(_1, false)\n             &multiple_return_terminators::MultipleReturnTerminators,\n-            &instcombine::InstCombine,\n+            &instsimplify::InstSimplify,\n             &separate_const_switch::SeparateConstSwitch,\n             &simplify::SimplifyLocals::BeforeConstProp,\n             &copy_prop::CopyProp,\n+            &ref_prop::ReferencePropagation,\n             &const_prop::ConstProp,\n             &dataflow_const_prop::DataflowConstProp,\n             //"}, {"sha": "dae01e41e5f3d3f466cf7729fabd258d1f537f51", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,6 +1,6 @@\n //! Lowers intrinsic calls\n \n-use crate::MirPass;\n+use crate::{errors, MirPass};\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -310,11 +310,7 @@ fn resolve_rust_intrinsic<'tcx>(\n }\n \n fn validate_simd_shuffle<'tcx>(tcx: TyCtxt<'tcx>, args: &[Operand<'tcx>], span: Span) {\n-    match &args[2] {\n-        Operand::Constant(_) => {} // all good\n-        _ => {\n-            let msg = \"last argument of `simd_shuffle` is required to be a `const` item\";\n-            tcx.sess.span_err(span, msg);\n-        }\n+    if !matches!(args[2], Operand::Constant(_)) {\n+        tcx.sess.emit_err(errors::SimdShuffleLastConst { span });\n     }\n }"}, {"sha": "3d61d33ce3536acf49e7827533c36d5e43d43b07", "filename": "compiler/rustc_mir_transform/src/normalize_array_len.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -7,7 +7,6 @@ use rustc_index::IndexVec;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_mir_dataflow::impls::borrowed_locals;\n \n pub struct NormalizeArrayLen;\n \n@@ -24,9 +23,7 @@ impl<'tcx> MirPass<'tcx> for NormalizeArrayLen {\n }\n \n fn normalize_array_len_calls<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-    let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n-    let borrowed_locals = borrowed_locals(body);\n-    let ssa = SsaLocals::new(tcx, param_env, body, &borrowed_locals);\n+    let ssa = SsaLocals::new(body);\n \n     let slice_lengths = compute_slice_length(tcx, &ssa, body);\n     debug!(?slice_lengths);\n@@ -41,7 +38,7 @@ fn compute_slice_length<'tcx>(\n ) -> IndexVec<Local, Option<ty::Const<'tcx>>> {\n     let mut slice_lengths = IndexVec::from_elem(None, &body.local_decls);\n \n-    for (local, rvalue) in ssa.assignments(body) {\n+    for (local, rvalue, _) in ssa.assignments(body) {\n         match rvalue {\n             Rvalue::Cast(\n                 CastKind::Pointer(ty::adjustment::PointerCast::Unsize),"}, {"sha": "85b26220b1e806cdbf225bb412000a982498f300", "filename": "compiler/rustc_mir_transform/src/nrvo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -34,7 +34,8 @@ pub struct RenameReturnPlace;\n \n impl<'tcx> MirPass<'tcx> for RenameReturnPlace {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        sess.mir_opt_level() > 0\n+        // #111005\n+        sess.mir_opt_level() > 0 && sess.opts.unstable_opts.unsound_mir_opts\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut mir::Body<'tcx>) {"}, {"sha": "dafd2ae23a635cef72a3a93cad057b5a4660c8c8", "filename": "compiler/rustc_mir_transform/src/ref_prop.rs", "status": "added", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fref_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fref_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fref_prop.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -0,0 +1,355 @@\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::IndexVec;\n+use rustc_middle::mir::visit::*;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_mir_dataflow::impls::MaybeStorageDead;\n+use rustc_mir_dataflow::storage::always_storage_live_locals;\n+use rustc_mir_dataflow::Analysis;\n+\n+use crate::ssa::{SsaLocals, StorageLiveLocals};\n+use crate::MirPass;\n+\n+/// Propagate references using SSA analysis.\n+///\n+/// MIR building may produce a lot of borrow-dereference patterns.\n+///\n+/// This pass aims to transform the following pattern:\n+///   _1 = &raw? mut? PLACE;\n+///   _3 = *_1;\n+///   _4 = &raw? mut? *_1;\n+///\n+/// Into\n+///   _1 = &raw? mut? PLACE;\n+///   _3 = PLACE;\n+///   _4 = &raw? mut? PLACE;\n+///\n+/// where `PLACE` is a direct or an indirect place expression.\n+///\n+/// There are 3 properties that need to be upheld for this transformation to be legal:\n+/// - place stability: `PLACE` must refer to the same memory wherever it appears;\n+/// - pointer liveness: we must not introduce dereferences of dangling pointers;\n+/// - `&mut` borrow uniqueness.\n+///\n+/// # Stability\n+///\n+/// If `PLACE` is an indirect projection, if its of the form `(*LOCAL).PROJECTIONS` where:\n+/// - `LOCAL` is SSA;\n+/// - all projections in `PROJECTIONS` have a stable offset (no dereference and no indexing).\n+///\n+/// If `PLACE` is a direct projection of a local, we consider it as constant if:\n+/// - the local is always live, or it has a single `StorageLive`;\n+/// - all projections have a stable offset.\n+///\n+/// # Liveness\n+///\n+/// When performing a substitution, we must take care not to introduce uses of dangling locals.\n+/// To ensure this, we walk the body with the `MaybeStorageDead` dataflow analysis:\n+/// - if we want to replace `*x` by reborrow `*y` and `y` may be dead, we allow replacement and\n+///   mark storage statements on `y` for removal;\n+/// - if we want to replace `*x` by non-reborrow `y` and `y` must be live, we allow replacement;\n+/// - if we want to replace `*x` by non-reborrow `y` and `y` may be dead, we do not replace.\n+///\n+/// # Uniqueness\n+///\n+/// For `&mut` borrows, we also need to preserve the uniqueness property:\n+/// we must avoid creating a state where we interleave uses of `*_1` and `_2`.\n+/// To do it, we only perform full substitution of mutable borrows:\n+/// we replace either all or none of the occurrences of `*_1`.\n+///\n+/// Some care has to be taken when `_1` is copied in other locals.\n+///   _1 = &raw? mut? _2;\n+///   _3 = *_1;\n+///   _4 = _1\n+///   _5 = *_4\n+/// In such cases, fully substituting `_1` means fully substituting all of the copies.\n+///\n+/// For immutable borrows, we do not need to preserve such uniqueness property,\n+/// so we perform all the possible substitutions without removing the `_1 = &_2` statement.\n+pub struct ReferencePropagation;\n+\n+impl<'tcx> MirPass<'tcx> for ReferencePropagation {\n+    fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n+        sess.mir_opt_level() >= 4\n+    }\n+\n+    #[instrument(level = \"trace\", skip(self, tcx, body))]\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        debug!(def_id = ?body.source.def_id());\n+        propagate_ssa(tcx, body);\n+    }\n+}\n+\n+fn propagate_ssa<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let ssa = SsaLocals::new(body);\n+\n+    let mut replacer = compute_replacement(tcx, body, &ssa);\n+    debug!(?replacer.targets, ?replacer.allowed_replacements, ?replacer.storage_to_remove);\n+\n+    replacer.visit_body_preserves_cfg(body);\n+\n+    if replacer.any_replacement {\n+        crate::simplify::remove_unused_definitions(body);\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum Value<'tcx> {\n+    /// Not a pointer, or we can't know.\n+    Unknown,\n+    /// We know the value to be a pointer to this place.\n+    /// The boolean indicates whether the reference is mutable, subject the uniqueness rule.\n+    Pointer(Place<'tcx>, bool),\n+}\n+\n+/// For each local, save the place corresponding to `*local`.\n+#[instrument(level = \"trace\", skip(tcx, body))]\n+fn compute_replacement<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    ssa: &SsaLocals,\n+) -> Replacer<'tcx> {\n+    let always_live_locals = always_storage_live_locals(body);\n+\n+    // Compute which locals have a single `StorageLive` statement ever.\n+    let storage_live = StorageLiveLocals::new(body, &always_live_locals);\n+\n+    // Compute `MaybeStorageDead` dataflow to check that we only replace when the pointee is\n+    // definitely live.\n+    let mut maybe_dead = MaybeStorageDead::new(always_live_locals)\n+        .into_engine(tcx, body)\n+        .iterate_to_fixpoint()\n+        .into_results_cursor(body);\n+\n+    // Map for each local to the pointee.\n+    let mut targets = IndexVec::from_elem(Value::Unknown, &body.local_decls);\n+    // Set of locals for which we will remove their storage statement. This is useful for\n+    // reborrowed references.\n+    let mut storage_to_remove = BitSet::new_empty(body.local_decls.len());\n+\n+    let fully_replacable_locals = fully_replacable_locals(ssa);\n+\n+    // Returns true iff we can use `place` as a pointee.\n+    //\n+    // Note that we only need to verify that there is a single `StorageLive` statement, and we do\n+    // not need to verify that it dominates all uses of that local.\n+    //\n+    // Consider the three statements:\n+    //   SL : StorageLive(a)\n+    //   DEF: b = &raw? mut? a\n+    //   USE: stuff that uses *b\n+    //\n+    // First, we recall that DEF is checked to dominate USE. Now imagine for the sake of\n+    // contradiction there is a DEF -> SL -> USE path. Consider two cases:\n+    //\n+    // - DEF dominates SL. We always have UB the first time control flow reaches DEF,\n+    //   because the storage of `a` is dead. Since DEF dominates USE, that means we cannot\n+    //   reach USE and so our optimization is ok.\n+    //\n+    // - DEF does not dominate SL. Then there is a `START_BLOCK -> SL` path not including DEF.\n+    //   But we can extend this path to USE, meaning there is also a `START_BLOCK -> USE` path not\n+    //   including DEF. This violates the DEF dominates USE condition, and so is impossible.\n+    let is_constant_place = |place: Place<'_>| {\n+        // We only allow `Deref` as the first projection, to avoid surprises.\n+        if place.projection.first() == Some(&PlaceElem::Deref) {\n+            // `place == (*some_local).xxx`, it is constant only if `some_local` is constant.\n+            // We approximate constness using SSAness.\n+            ssa.is_ssa(place.local) && place.projection[1..].iter().all(PlaceElem::is_stable_offset)\n+        } else {\n+            storage_live.has_single_storage(place.local)\n+                && place.projection[..].iter().all(PlaceElem::is_stable_offset)\n+        }\n+    };\n+\n+    let mut can_perform_opt = |target: Place<'tcx>, loc: Location| {\n+        if target.projection.first() == Some(&PlaceElem::Deref) {\n+            // We are creating a reborrow. As `place.local` is a reference, removing the storage\n+            // statements should not make it much harder for LLVM to optimize.\n+            storage_to_remove.insert(target.local);\n+            true\n+        } else {\n+            // This is a proper dereference. We can only allow it if `target` is live.\n+            maybe_dead.seek_after_primary_effect(loc);\n+            let maybe_dead = maybe_dead.contains(target.local);\n+            !maybe_dead\n+        }\n+    };\n+\n+    for (local, rvalue, location) in ssa.assignments(body) {\n+        debug!(?local);\n+\n+        // Only visit if we have something to do.\n+        let Value::Unknown = targets[local] else { bug!() };\n+\n+        let ty = body.local_decls[local].ty;\n+\n+        // If this is not a reference or pointer, do nothing.\n+        if !ty.is_any_ptr() {\n+            debug!(\"not a reference or pointer\");\n+            continue;\n+        }\n+\n+        // If this a mutable reference that we cannot fully replace, mark it as unknown.\n+        if ty.is_mutable_ptr() && !fully_replacable_locals.contains(local) {\n+            debug!(\"not fully replaceable\");\n+            continue;\n+        }\n+\n+        debug!(?rvalue);\n+        match rvalue {\n+            // This is a copy, just use the value we have in store for the previous one.\n+            // As we are visiting in `assignment_order`, ie. reverse postorder, `rhs` should\n+            // have been visited before.\n+            Rvalue::Use(Operand::Copy(place) | Operand::Move(place))\n+            | Rvalue::CopyForDeref(place) => {\n+                if let Some(rhs) = place.as_local() {\n+                    let target = targets[rhs];\n+                    if matches!(target, Value::Pointer(..)) {\n+                        targets[local] = target;\n+                    } else if ssa.is_ssa(rhs) {\n+                        let refmut = body.local_decls[rhs].ty.is_mutable_ptr();\n+                        targets[local] = Value::Pointer(tcx.mk_place_deref(rhs.into()), refmut);\n+                    }\n+                }\n+            }\n+            Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n+                let mut place = *place;\n+                // Try to see through `place` in order to collapse reborrow chains.\n+                if place.projection.first() == Some(&PlaceElem::Deref)\n+                    && let Value::Pointer(target, refmut) = targets[place.local]\n+                    // Only see through immutable reference and pointers, as we do not know yet if\n+                    // mutable references are fully replaced.\n+                    && !refmut\n+                    // Only collapse chain if the pointee is definitely live.\n+                    && can_perform_opt(target, location)\n+                {\n+                    place = target.project_deeper(&place.projection[1..], tcx);\n+                }\n+                assert_ne!(place.local, local);\n+                if is_constant_place(place) {\n+                    targets[local] = Value::Pointer(place, ty.is_mutable_ptr());\n+                }\n+            }\n+            // We do not know what to do, so keep as not-a-pointer.\n+            _ => {}\n+        }\n+    }\n+\n+    debug!(?targets);\n+\n+    let mut finder = ReplacementFinder {\n+        targets: &mut targets,\n+        can_perform_opt,\n+        allowed_replacements: FxHashSet::default(),\n+    };\n+    let reachable_blocks = traversal::reachable_as_bitset(body);\n+    for (bb, bbdata) in body.basic_blocks.iter_enumerated() {\n+        // Only visit reachable blocks as we rely on dataflow.\n+        if reachable_blocks.contains(bb) {\n+            finder.visit_basic_block_data(bb, bbdata);\n+        }\n+    }\n+\n+    let allowed_replacements = finder.allowed_replacements;\n+    return Replacer {\n+        tcx,\n+        targets,\n+        storage_to_remove,\n+        allowed_replacements,\n+        any_replacement: false,\n+    };\n+\n+    struct ReplacementFinder<'a, 'tcx, F> {\n+        targets: &'a mut IndexVec<Local, Value<'tcx>>,\n+        can_perform_opt: F,\n+        allowed_replacements: FxHashSet<(Local, Location)>,\n+    }\n+\n+    impl<'tcx, F> Visitor<'tcx> for ReplacementFinder<'_, 'tcx, F>\n+    where\n+        F: FnMut(Place<'tcx>, Location) -> bool,\n+    {\n+        fn visit_place(&mut self, place: &Place<'tcx>, ctxt: PlaceContext, loc: Location) {\n+            if matches!(ctxt, PlaceContext::NonUse(_)) {\n+                // There is no need to check liveness for non-uses.\n+                return;\n+            }\n+\n+            if let Value::Pointer(target, refmut) = self.targets[place.local]\n+                && place.projection.first() == Some(&PlaceElem::Deref)\n+            {\n+                let perform_opt = (self.can_perform_opt)(target, loc);\n+                if perform_opt {\n+                    self.allowed_replacements.insert((target.local, loc));\n+                } else if refmut {\n+                    // This mutable reference is not fully replacable, so drop it.\n+                    self.targets[place.local] = Value::Unknown;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Compute the set of locals that can be fully replaced.\n+///\n+/// We consider a local to be replacable iff it's only used in a `Deref` projection `*_local` or\n+/// non-use position (like storage statements and debuginfo).\n+fn fully_replacable_locals(ssa: &SsaLocals) -> BitSet<Local> {\n+    let mut replacable = BitSet::new_empty(ssa.num_locals());\n+\n+    // First pass: for each local, whether its uses can be fully replaced.\n+    for local in ssa.locals() {\n+        if ssa.num_direct_uses(local) == 0 {\n+            replacable.insert(local);\n+        }\n+    }\n+\n+    // Second pass: a local can only be fully replaced if all its copies can.\n+    ssa.meet_copy_equivalence(&mut replacable);\n+\n+    replacable\n+}\n+\n+/// Utility to help performing subtitution of `*pattern` by `target`.\n+struct Replacer<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    targets: IndexVec<Local, Value<'tcx>>,\n+    storage_to_remove: BitSet<Local>,\n+    allowed_replacements: FxHashSet<(Local, Location)>,\n+    any_replacement: bool,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for Replacer<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn visit_place(&mut self, place: &mut Place<'tcx>, ctxt: PlaceContext, loc: Location) {\n+        if let Value::Pointer(target, _) = self.targets[place.local]\n+            && place.projection.first() == Some(&PlaceElem::Deref)\n+        {\n+            let perform_opt = matches!(ctxt, PlaceContext::NonUse(_))\n+                || self.allowed_replacements.contains(&(target.local, loc));\n+\n+            if perform_opt {\n+                *place = target.project_deeper(&place.projection[1..], self.tcx);\n+                self.any_replacement = true;\n+            }\n+        } else {\n+            self.super_place(place, ctxt, loc);\n+        }\n+    }\n+\n+    fn visit_statement(&mut self, stmt: &mut Statement<'tcx>, loc: Location) {\n+        match stmt.kind {\n+            StatementKind::StorageLive(l) | StatementKind::StorageDead(l)\n+                if self.storage_to_remove.contains(l) =>\n+            {\n+                stmt.make_nop();\n+            }\n+            // Do not remove assignments as they may still be useful for debuginfo.\n+            _ => self.super_statement(stmt, loc),\n+        }\n+    }\n+}"}, {"sha": "1b96df3aed5be8020b89ee764697fa4d7a08b54b", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -278,7 +278,7 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n     }\n }\n \n-pub fn combine_duplicate_switch_targets(terminator: &mut Terminator<'_>) {\n+pub fn simplify_duplicate_switch_targets(terminator: &mut Terminator<'_>) {\n     if let TerminatorKind::SwitchInt { targets, .. } = &mut terminator.kind {\n         let otherwise = targets.otherwise();\n         if targets.iter().any(|t| t.1 == otherwise) {\n@@ -310,7 +310,7 @@ pub fn remove_duplicate_unreachable_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut B\n                 }\n             }\n \n-            combine_duplicate_switch_targets(terminator);\n+            simplify_duplicate_switch_targets(terminator);\n \n             self.super_terminator(terminator, location);\n         }"}, {"sha": "05a7b226f0c213ce2561fbb67294b1cc91ee0eac", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 113, "deletions": 60, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,11 +1,17 @@\n+//! We denote as \"SSA\" the set of locals that verify the following properties:\n+//! 1/ They are only assigned-to once, either as a function parameter, or in an assign statement;\n+//! 2/ This single assignment dominates all uses;\n+//!\n+//! As a consequence of rule 2, we consider that borrowed locals are not SSA, even if they are\n+//! `Freeze`, as we do not track that the assignment dominates all uses of the borrow.\n+\n use either::Either;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n use rustc_index::{IndexSlice, IndexVec};\n use rustc_middle::middle::resolve_bound_vars::Set1;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{ParamEnv, TyCtxt};\n \n #[derive(Debug)]\n pub struct SsaLocals {\n@@ -17,6 +23,9 @@ pub struct SsaLocals {\n     assignment_order: Vec<Local>,\n     /// Copy equivalence classes between locals. See `copy_classes` for documentation.\n     copy_classes: IndexVec<Local, Local>,\n+    /// Number of \"direct\" uses of each local, ie. uses that are not dereferences.\n+    /// We ignore non-uses (Storage statements, debuginfo).\n+    direct_uses: IndexVec<Local, u32>,\n }\n \n /// We often encounter MIR bodies with 1 or 2 basic blocks. In those cases, it's unnecessary to\n@@ -26,48 +35,48 @@ struct SmallDominators {\n     inner: Option<Dominators<BasicBlock>>,\n }\n \n-trait DomExt {\n-    fn dominates(self, _other: Self, dominators: &SmallDominators) -> bool;\n-}\n-\n-impl DomExt for Location {\n-    fn dominates(self, other: Location, dominators: &SmallDominators) -> bool {\n-        if self.block == other.block {\n-            self.statement_index <= other.statement_index\n+impl SmallDominators {\n+    fn dominates(&self, first: Location, second: Location) -> bool {\n+        if first.block == second.block {\n+            first.statement_index <= second.statement_index\n+        } else if let Some(inner) = &self.inner {\n+            inner.dominates(first.block, second.block)\n         } else {\n-            dominators.dominates(self.block, other.block)\n+            first.block < second.block\n         }\n     }\n-}\n \n-impl SmallDominators {\n-    fn dominates(&self, dom: BasicBlock, node: BasicBlock) -> bool {\n-        if let Some(inner) = &self.inner { inner.dominates(dom, node) } else { dom < node }\n+    fn check_dominates(&mut self, set: &mut Set1<LocationExtended>, loc: Location) {\n+        let assign_dominates = match *set {\n+            Set1::Empty | Set1::Many => false,\n+            Set1::One(LocationExtended::Arg) => true,\n+            Set1::One(LocationExtended::Plain(assign)) => {\n+                self.dominates(assign.successor_within_block(), loc)\n+            }\n+        };\n+        // We are visiting a use that is not dominated by an assignment.\n+        // Either there is a cycle involved, or we are reading for uninitialized local.\n+        // Bail out.\n+        if !assign_dominates {\n+            *set = Set1::Many;\n+        }\n     }\n }\n \n impl SsaLocals {\n-    pub fn new<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ParamEnv<'tcx>,\n-        body: &Body<'tcx>,\n-        borrowed_locals: &BitSet<Local>,\n-    ) -> SsaLocals {\n+    pub fn new<'tcx>(body: &Body<'tcx>) -> SsaLocals {\n         let assignment_order = Vec::with_capacity(body.local_decls.len());\n \n         let assignments = IndexVec::from_elem(Set1::Empty, &body.local_decls);\n         let dominators =\n             if body.basic_blocks.len() > 2 { Some(body.basic_blocks.dominators()) } else { None };\n         let dominators = SmallDominators { inner: dominators };\n-        let mut visitor = SsaVisitor { assignments, assignment_order, dominators };\n \n-        for (local, decl) in body.local_decls.iter_enumerated() {\n-            if matches!(body.local_kind(local), LocalKind::Arg) {\n-                visitor.assignments[local] = Set1::One(LocationExtended::Arg);\n-            }\n-            if borrowed_locals.contains(local) && !decl.ty.is_freeze(tcx, param_env) {\n-                visitor.assignments[local] = Set1::Many;\n-            }\n+        let direct_uses = IndexVec::from_elem(0, &body.local_decls);\n+        let mut visitor = SsaVisitor { assignments, assignment_order, dominators, direct_uses };\n+\n+        for local in body.args_iter() {\n+            visitor.assignments[local] = Set1::One(LocationExtended::Arg);\n         }\n \n         if body.basic_blocks.len() > 2 {\n@@ -85,36 +94,51 @@ impl SsaLocals {\n         }\n \n         debug!(?visitor.assignments);\n+        debug!(?visitor.direct_uses);\n \n         visitor\n             .assignment_order\n             .retain(|&local| matches!(visitor.assignments[local], Set1::One(_)));\n         debug!(?visitor.assignment_order);\n \n-        let copy_classes = compute_copy_classes(&visitor, body);\n+        let copy_classes = compute_copy_classes(&mut visitor, body);\n \n         SsaLocals {\n             assignments: visitor.assignments,\n             assignment_order: visitor.assignment_order,\n+            direct_uses: visitor.direct_uses,\n             copy_classes,\n         }\n     }\n \n+    pub fn num_locals(&self) -> usize {\n+        self.assignments.len()\n+    }\n+\n+    pub fn locals(&self) -> impl Iterator<Item = Local> {\n+        self.assignments.indices()\n+    }\n+\n     pub fn is_ssa(&self, local: Local) -> bool {\n         matches!(self.assignments[local], Set1::One(_))\n     }\n \n+    /// Return the number of uses if a local that are not \"Deref\".\n+    pub fn num_direct_uses(&self, local: Local) -> u32 {\n+        self.direct_uses[local]\n+    }\n+\n     pub fn assignments<'a, 'tcx>(\n         &'a self,\n         body: &'a Body<'tcx>,\n-    ) -> impl Iterator<Item = (Local, &'a Rvalue<'tcx>)> + 'a {\n+    ) -> impl Iterator<Item = (Local, &'a Rvalue<'tcx>, Location)> + 'a {\n         self.assignment_order.iter().filter_map(|&local| {\n             if let Set1::One(LocationExtended::Plain(loc)) = self.assignments[local] {\n                 // `loc` must point to a direct assignment to `local`.\n                 let Either::Left(stmt) = body.stmt_at(loc) else { bug!() };\n                 let Some((target, rvalue)) = stmt.kind.as_assign() else { bug!() };\n                 assert_eq!(target.as_local(), Some(local));\n-                Some((local, rvalue))\n+                Some((local, rvalue, loc))\n             } else {\n                 None\n             }\n@@ -177,30 +201,14 @@ struct SsaVisitor {\n     dominators: SmallDominators,\n     assignments: IndexVec<Local, Set1<LocationExtended>>,\n     assignment_order: Vec<Local>,\n-}\n-\n-impl SsaVisitor {\n-    fn check_assignment_dominates(&mut self, local: Local, loc: Location) {\n-        let set = &mut self.assignments[local];\n-        let assign_dominates = match *set {\n-            Set1::Empty | Set1::Many => false,\n-            Set1::One(LocationExtended::Arg) => true,\n-            Set1::One(LocationExtended::Plain(assign)) => {\n-                assign.successor_within_block().dominates(loc, &self.dominators)\n-            }\n-        };\n-        // We are visiting a use that is not dominated by an assignment.\n-        // Either there is a cycle involved, or we are reading for uninitialized local.\n-        // Bail out.\n-        if !assign_dominates {\n-            *set = Set1::Many;\n-        }\n-    }\n+    direct_uses: IndexVec<Local, u32>,\n }\n \n impl<'tcx> Visitor<'tcx> for SsaVisitor {\n     fn visit_local(&mut self, local: Local, ctxt: PlaceContext, loc: Location) {\n         match ctxt {\n+            PlaceContext::MutatingUse(MutatingUseContext::Projection)\n+            | PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection) => bug!(),\n             PlaceContext::MutatingUse(MutatingUseContext::Store) => {\n                 self.assignments[local].insert(LocationExtended::Plain(loc));\n                 if let Set1::One(_) = self.assignments[local] {\n@@ -209,12 +217,20 @@ impl<'tcx> Visitor<'tcx> for SsaVisitor {\n                 }\n             }\n             // Anything can happen with raw pointers, so remove them.\n-            PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf)\n-            | PlaceContext::MutatingUse(_) => self.assignments[local] = Set1::Many,\n-            // Immutable borrows are taken into account in `SsaLocals::new` by\n-            // removing non-freeze locals.\n+            // We do not verify that all uses of the borrow dominate the assignment to `local`,\n+            // so we have to remove them too.\n+            PlaceContext::NonMutatingUse(\n+                NonMutatingUseContext::SharedBorrow\n+                | NonMutatingUseContext::ShallowBorrow\n+                | NonMutatingUseContext::UniqueBorrow\n+                | NonMutatingUseContext::AddressOf,\n+            )\n+            | PlaceContext::MutatingUse(_) => {\n+                self.assignments[local] = Set1::Many;\n+            }\n             PlaceContext::NonMutatingUse(_) => {\n-                self.check_assignment_dominates(local, loc);\n+                self.dominators.check_dominates(&mut self.assignments[local], loc);\n+                self.direct_uses[local] += 1;\n             }\n             PlaceContext::NonUse(_) => {}\n         }\n@@ -224,20 +240,22 @@ impl<'tcx> Visitor<'tcx> for SsaVisitor {\n         if place.projection.first() == Some(&PlaceElem::Deref) {\n             // Do not do anything for storage statements and debuginfo.\n             if ctxt.is_use() {\n-                // A use through a `deref` only reads from the local, and cannot write to it.\n-                let new_ctxt = PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection);\n+                // Only change the context if it is a real use, not a \"use\" in debuginfo.\n+                let new_ctxt = PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy);\n \n                 self.visit_projection(place.as_ref(), new_ctxt, loc);\n-                self.check_assignment_dominates(place.local, loc);\n+                self.dominators.check_dominates(&mut self.assignments[place.local], loc);\n             }\n             return;\n+        } else {\n+            self.visit_projection(place.as_ref(), ctxt, loc);\n+            self.visit_local(place.local, ctxt, loc);\n         }\n-        self.super_place(place, ctxt, loc);\n     }\n }\n \n #[instrument(level = \"trace\", skip(ssa, body))]\n-fn compute_copy_classes(ssa: &SsaVisitor, body: &Body<'_>) -> IndexVec<Local, Local> {\n+fn compute_copy_classes(ssa: &mut SsaVisitor, body: &Body<'_>) -> IndexVec<Local, Local> {\n     let mut copies = IndexVec::from_fn_n(|l| l, body.local_decls.len());\n \n     for &local in &ssa.assignment_order {\n@@ -267,9 +285,11 @@ fn compute_copy_classes(ssa: &SsaVisitor, body: &Body<'_>) -> IndexVec<Local, Lo\n         // We visit in `assignment_order`, ie. reverse post-order, so `rhs` has been\n         // visited before `local`, and we just have to copy the representing local.\n         copies[local] = copies[rhs];\n+        ssa.direct_uses[rhs] -= 1;\n     }\n \n     debug!(?copies);\n+    debug!(?ssa.direct_uses);\n \n     // Invariant: `copies` must point to the head of an equivalence class.\n     #[cfg(debug_assertions)]\n@@ -279,3 +299,36 @@ fn compute_copy_classes(ssa: &SsaVisitor, body: &Body<'_>) -> IndexVec<Local, Lo\n \n     copies\n }\n+\n+#[derive(Debug)]\n+pub(crate) struct StorageLiveLocals {\n+    /// Set of \"StorageLive\" statements for each local.\n+    storage_live: IndexVec<Local, Set1<LocationExtended>>,\n+}\n+\n+impl StorageLiveLocals {\n+    pub(crate) fn new(\n+        body: &Body<'_>,\n+        always_storage_live_locals: &BitSet<Local>,\n+    ) -> StorageLiveLocals {\n+        let mut storage_live = IndexVec::from_elem(Set1::Empty, &body.local_decls);\n+        for local in always_storage_live_locals.iter() {\n+            storage_live[local] = Set1::One(LocationExtended::Arg);\n+        }\n+        for (block, bbdata) in body.basic_blocks.iter_enumerated() {\n+            for (statement_index, statement) in bbdata.statements.iter().enumerate() {\n+                if let StatementKind::StorageLive(local) = statement.kind {\n+                    storage_live[local]\n+                        .insert(LocationExtended::Plain(Location { block, statement_index }));\n+                }\n+            }\n+        }\n+        debug!(?storage_live);\n+        StorageLiveLocals { storage_live }\n+    }\n+\n+    #[inline]\n+    pub(crate) fn has_single_storage(&self, local: Local) -> bool {\n+        matches!(self.storage_live[local], Set1::One(_))\n+    }\n+}"}, {"sha": "55c937b305a49d11e33b2dbbd044941ff2853623", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -677,7 +677,7 @@ impl<'a, 'tcx> MirNeighborCollector<'a, 'tcx> {\n         self.instance.subst_mir_and_normalize_erasing_regions(\n             self.tcx,\n             ty::ParamEnv::reveal_all(),\n-            value,\n+            ty::EarlyBinder(value),\n         )\n     }\n }"}, {"sha": "37b7f6bf8a8fcc61e11c556b577467075e45fb15", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -310,7 +310,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n                     let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n                         instance.substs,\n                         ty::ParamEnv::reveal_all(),\n-                        tcx.type_of(impl_def_id).skip_binder(),\n+                        tcx.type_of(impl_def_id),\n                     );\n                     if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n                         return Some(def_id);"}, {"sha": "d12bfc6f6bb1d6d6588b403ed7c2cff54a5b501e", "filename": "compiler/rustc_monomorphize/src/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -29,12 +29,12 @@ pub(crate) fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: In\n         let before_feature_tys = tcx.subst_and_normalize_erasing_regions(\n             closure_instance.substs,\n             param_env,\n-            before_feature_tys,\n+            ty::EarlyBinder(before_feature_tys),\n         );\n         let after_feature_tys = tcx.subst_and_normalize_erasing_regions(\n             closure_instance.substs,\n             param_env,\n-            after_feature_tys,\n+            ty::EarlyBinder(after_feature_tys),\n         );\n \n         let new_size = tcx"}, {"sha": "1bbf833e3cdf5c7729c10577495f8c0eabeefb79", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -257,6 +257,10 @@ parse_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are inva\n     .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n     .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n \n+parse_expected_builtin_ident = expected identifier after `builtin #`\n+\n+parse_unknown_builtin_construct = unknown `builtin #` construct `{$name}`\n+\n parse_non_string_abi_literal = non-string ABI literal\n     .suggestion = specify the ABI with a string literal\n \n@@ -339,6 +343,7 @@ parse_expected_identifier = expected identifier\n parse_sugg_escape_identifier = escape `{$ident_name}` to use it as an identifier\n \n parse_sugg_remove_comma = remove this comma\n+parse_sugg_add_let_for_stmt = you might have meant to introduce a new binding\n \n parse_expected_semi_found_reserved_identifier_str = expected `;`, found reserved identifier `{$token}`\n parse_expected_semi_found_keyword_str = expected `;`, found keyword `{$token}`"}, {"sha": "b6aeaf3d59f64d2475bdbe78ecb9d26987cfa23f", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -906,6 +906,18 @@ pub(crate) struct SuggRemoveComma {\n     pub span: Span,\n }\n \n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    parse_sugg_add_let_for_stmt,\n+    style = \"verbose\",\n+    applicability = \"maybe-incorrect\",\n+    code = \"let \"\n+)]\n+pub(crate) struct SuggAddMissingLetStmt {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n #[derive(Subdiagnostic)]\n pub(crate) enum ExpectedIdentifierFound {\n     #[label(parse_expected_identifier_found_reserved_identifier)]\n@@ -2644,3 +2656,18 @@ pub(crate) struct MalformedCfgAttr {\n     pub span: Span,\n     pub sugg: &'static str,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unknown_builtin_construct)]\n+pub(crate) struct UnknownBuiltinConstruct {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expected_builtin_ident)]\n+pub(crate) struct ExpectedBuiltinIdent {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "3002f23da75cca74f7938424a2c18afb071c53f0", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -13,7 +13,7 @@ use crate::errors::{\n     IncorrectUseOfAwait, ParenthesesInForHead, ParenthesesInForHeadSugg,\n     PatternMethodParamWithoutBody, QuestionMarkInType, QuestionMarkInTypeSugg, SelfParamNotFirst,\n     StructLiteralBodyWithoutPath, StructLiteralBodyWithoutPathSugg, StructLiteralNeedingParens,\n-    StructLiteralNeedingParensSugg, SuggEscapeIdentifier, SuggRemoveComma,\n+    StructLiteralNeedingParensSugg, SuggAddMissingLetStmt, SuggEscapeIdentifier, SuggRemoveComma,\n     UnexpectedConstInGenericParam, UnexpectedConstParamDeclaration,\n     UnexpectedConstParamDeclarationSugg, UnmatchedAngleBrackets, UseEqInstead,\n };\n@@ -32,8 +32,8 @@ use rustc_ast::{\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{\n-    pluralize, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed,\n-    FatalError, Handler, IntoDiagnostic, MultiSpan, PResult,\n+    pluralize, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage,\n+    ErrorGuaranteed, FatalError, Handler, IntoDiagnostic, MultiSpan, PResult,\n };\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n@@ -1006,6 +1006,31 @@ impl<'a> Parser<'a> {\n         Err(e)\n     }\n \n+    /// Suggest add the missing `let` before the identifier in stmt\n+    /// `a: Ty = 1` -> `let a: Ty = 1`\n+    pub(super) fn suggest_add_missing_let_for_stmt(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'a, ErrorGuaranteed>,\n+    ) {\n+        if self.token == token::Colon {\n+            let prev_span = self.prev_token.span.shrink_to_lo();\n+            let snapshot = self.create_snapshot_for_diagnostic();\n+            self.bump();\n+            match self.parse_ty() {\n+                Ok(_) => {\n+                    if self.token == token::Eq {\n+                        let sugg = SuggAddMissingLetStmt { span: prev_span };\n+                        sugg.add_to_diagnostic(err);\n+                    }\n+                }\n+                Err(e) => {\n+                    e.cancel();\n+                }\n+            }\n+            self.restore_snapshot(snapshot);\n+        }\n+    }\n+\n     /// Check to see if a pair of chained operators looks like an attempt at chained comparison,\n     /// e.g. `1 < x <= 3`. If so, suggest either splitting the comparison into two, or\n     /// parenthesising the leftmost comparison."}, {"sha": "887e155426fa1b5fe8c52da7ca18925fdaae2109", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1300,6 +1300,8 @@ impl<'a> Parser<'a> {\n             })\n         } else if self.check(&token::OpenDelim(Delimiter::Bracket)) {\n             self.parse_expr_array_or_repeat(Delimiter::Bracket)\n+        } else if self.is_builtin() {\n+            self.parse_expr_builtin()\n         } else if self.check_path() {\n             self.parse_expr_path_start()\n         } else if self.check_keyword(kw::Move)\n@@ -1766,6 +1768,61 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n+    /// Parse `builtin # ident(args,*)`.\n+    fn parse_expr_builtin(&mut self) -> PResult<'a, P<Expr>> {\n+        self.parse_builtin(|this, lo, ident| {\n+            if ident.name == sym::offset_of {\n+                return Ok(Some(this.parse_expr_offset_of(lo)?));\n+            }\n+\n+            Ok(None)\n+        })\n+    }\n+\n+    pub(crate) fn parse_builtin<T>(\n+        &mut self,\n+        parse: impl FnOnce(&mut Parser<'a>, Span, Ident) -> PResult<'a, Option<T>>,\n+    ) -> PResult<'a, T> {\n+        let lo = self.token.span;\n+\n+        self.bump(); // `builtin`\n+        self.bump(); // `#`\n+\n+        let Some((ident, false)) = self.token.ident() else {\n+            let err = errors::ExpectedBuiltinIdent { span: self.token.span }\n+                .into_diagnostic(&self.sess.span_diagnostic);\n+            return Err(err);\n+        };\n+        self.sess.gated_spans.gate(sym::builtin_syntax, ident.span);\n+        self.bump();\n+\n+        self.expect(&TokenKind::OpenDelim(Delimiter::Parenthesis))?;\n+        let ret = if let Some(res) = parse(self, lo, ident)? {\n+            Ok(res)\n+        } else {\n+            let err = errors::UnknownBuiltinConstruct { span: lo.to(ident.span), name: ident.name }\n+                .into_diagnostic(&self.sess.span_diagnostic);\n+            return Err(err);\n+        };\n+        self.expect(&TokenKind::CloseDelim(Delimiter::Parenthesis))?;\n+\n+        ret\n+    }\n+\n+    pub(crate) fn parse_expr_offset_of(&mut self, lo: Span) -> PResult<'a, P<Expr>> {\n+        let container = self.parse_ty()?;\n+        self.expect(&TokenKind::Comma)?;\n+\n+        let seq_sep = SeqSep { sep: Some(token::Dot), trailing_sep_allowed: false };\n+        let (fields, _trailing, _recovered) = self.parse_seq_to_before_end(\n+            &TokenKind::CloseDelim(Delimiter::Parenthesis),\n+            seq_sep,\n+            Parser::parse_field_name,\n+        )?;\n+        let span = lo.to(self.token.span);\n+        Ok(self.mk_expr(span, ExprKind::OffsetOf(container, fields.to_vec().into())))\n+    }\n+\n     /// Returns a string literal if the next token is a string literal.\n     /// In case of error returns `Some(lit)` if the next token is a literal with a wrong kind,\n     /// and returns `None` if the next token is not literal at all.\n@@ -2835,6 +2892,10 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    pub(crate) fn is_builtin(&self) -> bool {\n+        self.token.is_keyword(kw::Builtin) && self.look_ahead(1, |t| *t == token::Pound)\n+    }\n+\n     /// Parses a `try {...}` expression (`try` token already eaten).\n     fn parse_try_block(&mut self, span_lo: Span) -> PResult<'a, P<Expr>> {\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;"}, {"sha": "840cfe908997ffbfe55525fe4684d5b64066cf39", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -265,6 +265,9 @@ impl<'a> Parser<'a> {\n             // UNION ITEM\n             self.bump(); // `union`\n             self.parse_item_union()?\n+        } else if self.is_builtin() {\n+            // BUILTIN# ITEM\n+            return self.parse_item_builtin();\n         } else if self.eat_keyword(kw::Macro) {\n             // MACROS 2.0 ITEM\n             self.parse_item_decl_macro(lo)?\n@@ -434,6 +437,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn parse_item_builtin(&mut self) -> PResult<'a, Option<ItemInfo>> {\n+        // To be expanded\n+        return Ok(None);\n+    }\n+\n     /// Parses an item macro, e.g., `item!();`.\n     fn parse_item_macro(&mut self, vis: &Visibility) -> PResult<'a, MacCall> {\n         let path = self.parse_path(PathStyle::Mod)?; // `foo::bar`\n@@ -1262,6 +1270,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n+        let prev_span = self.prev_token.span;\n         let id = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n         generics.where_clause = self.parse_where_clause()?;\n@@ -1273,10 +1282,28 @@ impl<'a> Parser<'a> {\n             (thin_vec![], false)\n         } else {\n             self.parse_delim_comma_seq(Delimiter::Brace, |p| p.parse_enum_variant()).map_err(\n-                |mut e| {\n-                    e.span_label(id.span, \"while parsing this enum\");\n+                |mut err| {\n+                    err.span_label(id.span, \"while parsing this enum\");\n+                    if self.token == token::Colon {\n+                        let snapshot = self.create_snapshot_for_diagnostic();\n+                        self.bump();\n+                        match self.parse_ty() {\n+                            Ok(_) => {\n+                                err.span_suggestion_verbose(\n+                                    prev_span,\n+                                    \"perhaps you meant to use `struct` here\",\n+                                    \"struct\".to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            Err(e) => {\n+                                e.cancel();\n+                            }\n+                        }\n+                        self.restore_snapshot(snapshot);\n+                    }\n                     self.recover_stmt();\n-                    e\n+                    err\n                 },\n             )?\n         };"}, {"sha": "03279124177e3e30d024e028aedf117d85bb7818", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -90,7 +90,11 @@ impl<'a> Parser<'a> {\n                 attrs,\n                 errors::InvalidVariableDeclarationSub::UseLetNotVar,\n             )?\n-        } else if self.check_path() && !self.token.is_qpath_start() && !self.is_path_start_item() {\n+        } else if self.check_path()\n+            && !self.token.is_qpath_start()\n+            && !self.is_path_start_item()\n+            && !self.is_builtin()\n+        {\n             // We have avoided contextual keywords like `union`, items with `crate` visibility,\n             // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n             // that starts like a path (1 token), but it fact not a path.\n@@ -99,7 +103,13 @@ impl<'a> Parser<'a> {\n                 ForceCollect::Yes => {\n                     self.collect_tokens_no_attrs(|this| this.parse_stmt_path_start(lo, attrs))?\n                 }\n-                ForceCollect::No => self.parse_stmt_path_start(lo, attrs)?,\n+                ForceCollect::No => match self.parse_stmt_path_start(lo, attrs) {\n+                    Ok(stmt) => stmt,\n+                    Err(mut err) => {\n+                        self.suggest_add_missing_let_for_stmt(&mut err);\n+                        return Err(err);\n+                    }\n+                },\n             }\n         } else if let Some(item) = self.parse_item_common(\n             attrs.clone(),\n@@ -555,7 +565,6 @@ impl<'a> Parser<'a> {\n                     if self.token == token::Colon {\n                         // if next token is following a colon, it's likely a path\n                         // and we can suggest a path separator\n-                        let ident_span = self.prev_token.span;\n                         self.bump();\n                         if self.token.span.lo() == self.prev_token.span.hi() {\n                             err.span_suggestion_verbose(\n@@ -565,14 +574,6 @@ impl<'a> Parser<'a> {\n                                 Applicability::MaybeIncorrect,\n                             );\n                         }\n-                        if self.look_ahead(1, |token| token == &token::Eq) {\n-                            err.span_suggestion_verbose(\n-                                ident_span.shrink_to_lo(),\n-                                \"you might have meant to introduce a new binding\",\n-                                \"let \",\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n                         if self.sess.unstable_features.is_nightly_build() {\n                             // FIXME(Nilstrieb): Remove this again after a few months.\n                             err.note(\"type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\");"}, {"sha": "d6eb5463870effcdc23efddef75926bd5fb1cc87", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 150, "deletions": 154, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -25,7 +25,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{AssocItemKind, HirIdSet, ItemId, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility, Level};\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n@@ -38,7 +38,7 @@ use rustc_span::Span;\n \n use std::marker::PhantomData;\n use std::ops::ControlFlow;\n-use std::{fmt, mem};\n+use std::{cmp, fmt, mem};\n \n use errors::{\n     FieldIsPrivate, FieldIsPrivateLabel, FromPrivateDependencyInPublicInterface, InPublicInterface,\n@@ -243,6 +243,39 @@ where\n                 // This will also visit substs if necessary, so we don't need to recurse.\n                 return self.visit_projection_ty(proj);\n             }\n+            ty::Alias(ty::Inherent, data) => {\n+                if self.def_id_visitor.skip_assoc_tys() {\n+                    // Visitors searching for minimal visibility/reachability want to\n+                    // conservatively approximate associated types like `Type::Alias`\n+                    // as visible/reachable even if `Type` is private.\n+                    // Ideally, associated types should be substituted in the same way as\n+                    // free type aliases, but this isn't done yet.\n+                    return ControlFlow::Continue(());\n+                }\n+\n+                self.def_id_visitor.visit_def_id(\n+                    data.def_id,\n+                    \"associated type\",\n+                    &LazyDefPathStr { def_id: data.def_id, tcx },\n+                )?;\n+\n+                struct LazyDefPathStr<'tcx> {\n+                    def_id: DefId,\n+                    tcx: TyCtxt<'tcx>,\n+                }\n+                impl<'tcx> fmt::Display for LazyDefPathStr<'tcx> {\n+                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                        write!(f, \"{}\", self.tcx.def_path_str(self.def_id))\n+                    }\n+                }\n+\n+                // This will also visit substs if necessary, so we don't need to recurse.\n+                return if self.def_id_visitor.shallow() {\n+                    ControlFlow::Continue(())\n+                } else {\n+                    data.substs.iter().try_for_each(|subst| subst.visit_with(self))\n+                };\n+            }\n             ty::Dynamic(predicates, ..) => {\n                 // All traits in the list are considered the \"primary\" part of the type\n                 // and are visited by shallow visitors.\n@@ -375,9 +408,8 @@ impl VisibilityLike for ty::Visibility {\n         min(find.tcx.local_visibility(def_id), find.min, find.tcx)\n     }\n }\n-\n-impl VisibilityLike for Option<EffectiveVisibility> {\n-    const MAX: Self = Some(EffectiveVisibility::from_vis(ty::Visibility::Public));\n+impl VisibilityLike for Option<Level> {\n+    const MAX: Self = Some(Level::Direct);\n     // Type inference is very smart sometimes.\n     // It can make an impl reachable even some components of its type or trait are unreachable.\n     // E.g. methods of `impl ReachableTrait<UnreachableTy> for ReachableTy<UnreachableTy> { ... }`\n@@ -389,13 +421,7 @@ impl VisibilityLike for Option<EffectiveVisibility> {\n     // (which require reaching the `DefId`s in them).\n     const SHALLOW: bool = true;\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: LocalDefId) -> Self {\n-        if let Some(min) = find.min {\n-            return find\n-                .effective_visibilities\n-                .effective_vis(def_id)\n-                .map(|eff_vis| min.min(*eff_vis, find.tcx));\n-        }\n-        None\n+        cmp::min(find.effective_visibilities.public_at_level(def_id), find.min)\n     }\n }\n \n@@ -421,79 +447,49 @@ struct EmbargoVisitor<'tcx> {\n     ///     n::p::f()\n     /// }\n     macro_reachable: FxHashSet<(LocalDefId, LocalDefId)>,\n+    /// Previous visibility level; `None` means unreachable.\n+    prev_level: Option<Level>,\n     /// Has something changed in the level map?\n     changed: bool,\n }\n \n struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n-    effective_vis: Option<EffectiveVisibility>,\n+    level: Option<Level>,\n     item_def_id: LocalDefId,\n     ev: &'a mut EmbargoVisitor<'tcx>,\n-    level: Level,\n }\n \n impl<'tcx> EmbargoVisitor<'tcx> {\n-    fn get(&self, def_id: LocalDefId) -> Option<EffectiveVisibility> {\n-        self.effective_visibilities.effective_vis(def_id).copied()\n-    }\n-\n-    // Updates node effective visibility.\n-    fn update(\n-        &mut self,\n-        def_id: LocalDefId,\n-        inherited_effective_vis: Option<EffectiveVisibility>,\n-        level: Level,\n-    ) {\n-        let nominal_vis = self.tcx.local_visibility(def_id);\n-        self.update_eff_vis(def_id, inherited_effective_vis, Some(nominal_vis), level);\n-    }\n-\n-    fn update_eff_vis(\n-        &mut self,\n-        def_id: LocalDefId,\n-        inherited_effective_vis: Option<EffectiveVisibility>,\n-        nominal_vis: Option<ty::Visibility>,\n-        level: Level,\n-    ) {\n-        if let Some(inherited_effective_vis) = inherited_effective_vis {\n-            let private_vis =\n-                ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id));\n-            if Some(private_vis) != nominal_vis {\n-                self.changed |= self.effective_visibilities.update(\n-                    def_id,\n-                    nominal_vis,\n-                    || private_vis,\n-                    inherited_effective_vis,\n-                    level,\n-                    self.tcx,\n-                );\n-            }\n+    fn get(&self, def_id: LocalDefId) -> Option<Level> {\n+        self.effective_visibilities.public_at_level(def_id)\n+    }\n+\n+    /// Updates node level and returns the updated level.\n+    fn update(&mut self, def_id: LocalDefId, level: Option<Level>) -> Option<Level> {\n+        let old_level = self.get(def_id);\n+        // Visibility levels can only grow.\n+        if level > old_level {\n+            self.effective_visibilities.set_public_at_level(\n+                def_id,\n+                || ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id)),\n+                level.unwrap(),\n+            );\n+            self.changed = true;\n+            level\n+        } else {\n+            old_level\n         }\n     }\n \n     fn reach(\n         &mut self,\n         def_id: LocalDefId,\n-        effective_vis: Option<EffectiveVisibility>,\n+        level: Option<Level>,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n-            effective_vis,\n+            level: cmp::min(level, Some(Level::Reachable)),\n             item_def_id: def_id,\n             ev: self,\n-            level: Level::Reachable,\n-        }\n-    }\n-\n-    fn reach_through_impl_trait(\n-        &mut self,\n-        def_id: LocalDefId,\n-        effective_vis: Option<EffectiveVisibility>,\n-    ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n-        ReachEverythingInTheInterfaceVisitor {\n-            effective_vis,\n-            item_def_id: def_id,\n-            ev: self,\n-            level: Level::ReachableThroughImplTrait,\n         }\n     }\n \n@@ -514,18 +510,16 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             return;\n         }\n \n-        if self.effective_visibilities.public_at_level(local_def_id).is_none() {\n+        if self.get(local_def_id).is_none() {\n             return;\n         }\n \n         // Since we are starting from an externally visible module,\n         // all the parents in the loop below are also guaranteed to be modules.\n         let mut module_def_id = macro_module_def_id;\n-        let macro_ev = self.get(local_def_id);\n-        assert!(macro_ev.is_some());\n         loop {\n             let changed_reachability =\n-                self.update_macro_reachable(module_def_id, macro_module_def_id, macro_ev);\n+                self.update_macro_reachable(module_def_id, macro_module_def_id);\n             if changed_reachability || module_def_id == CRATE_DEF_ID {\n                 break;\n             }\n@@ -539,33 +533,21 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         &mut self,\n         module_def_id: LocalDefId,\n         defining_mod: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n     ) -> bool {\n         if self.macro_reachable.insert((module_def_id, defining_mod)) {\n-            self.update_macro_reachable_mod(module_def_id, defining_mod, macro_ev);\n+            self.update_macro_reachable_mod(module_def_id, defining_mod);\n             true\n         } else {\n             false\n         }\n     }\n \n-    fn update_macro_reachable_mod(\n-        &mut self,\n-        module_def_id: LocalDefId,\n-        defining_mod: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n-    ) {\n+    fn update_macro_reachable_mod(&mut self, module_def_id: LocalDefId, defining_mod: LocalDefId) {\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n             let def_kind = self.tcx.def_kind(item_id.owner_id);\n             let vis = self.tcx.local_visibility(item_id.owner_id.def_id);\n-            self.update_macro_reachable_def(\n-                item_id.owner_id.def_id,\n-                def_kind,\n-                vis,\n-                defining_mod,\n-                macro_ev,\n-            );\n+            self.update_macro_reachable_def(item_id.owner_id.def_id, def_kind, vis, defining_mod);\n         }\n         for child in self.tcx.module_children_local(module_def_id) {\n             // FIXME: Use module children for the logic above too.\n@@ -574,7 +556,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n                 && let Res::Def(def_kind, def_id) = child.res\n                 && let Some(def_id) = def_id.as_local() {\n                 let vis = self.tcx.local_visibility(def_id);\n-                self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod, macro_ev);\n+                self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod);\n             }\n         }\n     }\n@@ -585,14 +567,16 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         def_kind: DefKind,\n         vis: ty::Visibility,\n         module: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n     ) {\n-        self.update(def_id, macro_ev, Level::Reachable);\n+        let level = Some(Level::Reachable);\n+        if vis.is_public() {\n+            self.update(def_id, level);\n+        }\n         match def_kind {\n             // No type privacy, so can be directly marked as reachable.\n             DefKind::Const | DefKind::Static(_) | DefKind::TraitAlias | DefKind::TyAlias => {\n                 if vis.is_accessible_from(module, self.tcx) {\n-                    self.update(def_id, macro_ev, Level::Reachable);\n+                    self.update(def_id, level);\n                 }\n             }\n \n@@ -604,7 +588,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n                 let item = self.tcx.hir().expect_item(def_id);\n                 if let hir::ItemKind::Macro(MacroDef { macro_rules: false, .. }, _) = item.kind {\n                     if vis.is_accessible_from(module, self.tcx) {\n-                        self.update(def_id, macro_ev, Level::Reachable);\n+                        self.update(def_id, level);\n                     }\n                 }\n             }\n@@ -615,24 +599,26 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             // the module, however may be reachable.\n             DefKind::Mod => {\n                 if vis.is_accessible_from(module, self.tcx) {\n-                    self.update_macro_reachable(def_id, module, macro_ev);\n+                    self.update_macro_reachable(def_id, module);\n                 }\n             }\n \n             DefKind::Struct | DefKind::Union => {\n                 // While structs and unions have type privacy, their fields do not.\n-                let item = self.tcx.hir().expect_item(def_id);\n-                if let hir::ItemKind::Struct(ref struct_def, _)\n-                | hir::ItemKind::Union(ref struct_def, _) = item.kind\n-                {\n-                    for field in struct_def.fields() {\n-                        let field_vis = self.tcx.local_visibility(field.def_id);\n-                        if field_vis.is_accessible_from(module, self.tcx) {\n-                            self.reach(field.def_id, macro_ev).ty();\n+                if vis.is_public() {\n+                    let item = self.tcx.hir().expect_item(def_id);\n+                    if let hir::ItemKind::Struct(ref struct_def, _)\n+                    | hir::ItemKind::Union(ref struct_def, _) = item.kind\n+                    {\n+                        for field in struct_def.fields() {\n+                            let field_vis = self.tcx.local_visibility(field.def_id);\n+                            if field_vis.is_accessible_from(module, self.tcx) {\n+                                self.reach(field.def_id, level).ty();\n+                            }\n                         }\n+                    } else {\n+                        bug!(\"item {:?} with DefKind {:?}\", item, def_kind);\n                     }\n-                } else {\n-                    bug!(\"item {:?} with DefKind {:?}\", item, def_kind);\n                 }\n             }\n \n@@ -676,16 +662,14 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_ev = match item.kind {\n+        let item_level = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n-                let impl_ev = Option::<EffectiveVisibility>::of_impl(\n+                let impl_level = Option::<Level>::of_impl(\n                     item.owner_id.def_id,\n                     self.tcx,\n                     &self.effective_visibilities,\n                 );\n-\n-                self.update_eff_vis(item.owner_id.def_id, impl_ev, None, Level::Direct);\n-                impl_ev\n+                self.update(item.owner_id.def_id, impl_level)\n             }\n             _ => self.get(item.owner_id.def_id),\n         };\n@@ -694,40 +678,48 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         match item.kind {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in def.variants {\n-                    self.update(variant.def_id, item_ev, Level::Reachable);\n-                    let variant_ev = self.get(variant.def_id);\n+                    let variant_level = self.update(variant.def_id, item_level);\n                     if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        self.update(ctor_def_id, variant_ev, Level::Reachable);\n+                        self.update(ctor_def_id, item_level);\n                     }\n                     for field in variant.data.fields() {\n-                        self.update(field.def_id, variant_ev, Level::Reachable);\n+                        self.update(field.def_id, variant_level);\n                     }\n                 }\n             }\n             hir::ItemKind::Impl(ref impl_) => {\n                 for impl_item_ref in impl_.items {\n-                    self.update(impl_item_ref.id.owner_id.def_id, item_ev, Level::Direct);\n+                    if impl_.of_trait.is_some()\n+                        || self.tcx.visibility(impl_item_ref.id.owner_id).is_public()\n+                    {\n+                        self.update(impl_item_ref.id.owner_id.def_id, item_level);\n+                    }\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.owner_id.def_id, item_ev, Level::Reachable);\n+                    self.update(trait_item_ref.id.owner_id.def_id, item_level);\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n                 if let Some(ctor_def_id) = def.ctor_def_id() {\n-                    self.update(ctor_def_id, item_ev, Level::Reachable);\n+                    self.update(ctor_def_id, item_level);\n                 }\n                 for field in def.fields() {\n-                    self.update(field.def_id, item_ev, Level::Reachable);\n+                    let vis = self.tcx.visibility(field.def_id);\n+                    if vis.is_public() {\n+                        self.update(field.def_id, item_level);\n+                    }\n                 }\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 self.update_reachability_from_macro(item.owner_id.def_id, macro_def);\n             }\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    self.update(foreign_item.id.owner_id.def_id, item_ev, Level::Reachable);\n+                    if self.tcx.visibility(foreign_item.id.owner_id).is_public() {\n+                        self.update(foreign_item.id.owner_id.def_id, item_level);\n+                    }\n                 }\n             }\n \n@@ -762,30 +754,26 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // FIXME: This is some serious pessimization intended to workaround deficiencies\n                     // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n-                    let exist_ev = Some(EffectiveVisibility::from_vis(ty::Visibility::Public));\n-                    self.reach_through_impl_trait(item.owner_id.def_id, exist_ev)\n-                        .generics()\n-                        .predicates()\n-                        .ty();\n+                    let exist_level = cmp::max(item_level, Some(Level::ReachableThroughImplTrait));\n+                    self.reach(item.owner_id.def_id, exist_level).generics().predicates().ty();\n                 }\n             }\n             // Visit everything.\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n-                if item_ev.is_some() {\n-                    self.reach(item.owner_id.def_id, item_ev).generics().predicates().ty();\n+                if item_level.is_some() {\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n-                if item_ev.is_some() {\n-                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n+                if item_level.is_some() {\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n                         let tcx = self.tcx;\n-                        let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_ev);\n-\n+                        let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_level);\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n@@ -799,24 +787,23 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                if item_ev.is_some() {\n-                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n+                if item_level.is_some() {\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n-                if item_ev.is_some() {\n-                    self.reach(item.owner_id.def_id, item_ev)\n+                if item_level.is_some() {\n+                    self.reach(item.owner_id.def_id, item_level)\n                         .generics()\n                         .predicates()\n                         .ty()\n                         .trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        let impl_item_ev = self.get(impl_item_ref.id.owner_id.def_id);\n-\n-                        if impl_item_ev.is_some() {\n-                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_ev)\n+                        let impl_item_level = self.get(impl_item_ref.id.owner_id.def_id);\n+                        if impl_item_level.is_some() {\n+                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_level)\n                                 .generics()\n                                 .predicates()\n                                 .ty();\n@@ -827,33 +814,33 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n \n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n-                if item_ev.is_some() {\n-                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n+                if item_level.is_some() {\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n                 }\n                 for variant in def.variants {\n-                    let variant_ev = self.get(variant.def_id);\n-                    if variant_ev.is_some() {\n+                    let variant_level = self.get(variant.def_id);\n+                    if variant_level.is_some() {\n                         for field in variant.data.fields() {\n-                            self.reach(field.def_id, variant_ev).ty();\n+                            self.reach(field.def_id, variant_level).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.reach(item.owner_id.def_id, variant_ev).ty();\n+                        self.reach(item.owner_id.def_id, variant_level).ty();\n                     }\n                     if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        let ctor_ev = self.get(ctor_def_id);\n-                        if ctor_ev.is_some() {\n-                            self.reach(item.owner_id.def_id, ctor_ev).ty();\n+                        let ctor_level = self.get(ctor_def_id);\n+                        if ctor_level.is_some() {\n+                            self.reach(item.owner_id.def_id, ctor_level).ty();\n                         }\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let foreign_item_ev = self.get(foreign_item.id.owner_id.def_id);\n-                    if foreign_item_ev.is_some() {\n-                        self.reach(foreign_item.id.owner_id.def_id, foreign_item_ev)\n+                    let foreign_item_level = self.get(foreign_item.id.owner_id.def_id);\n+                    if foreign_item_level.is_some() {\n+                        self.reach(foreign_item.id.owner_id.def_id, foreign_item_level)\n                             .generics()\n                             .predicates()\n                             .ty();\n@@ -862,32 +849,36 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                if item_ev.is_some() {\n-                    self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n+                if item_level.is_some() {\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n                     for field in struct_def.fields() {\n-                        let field_ev = self.get(field.def_id);\n-                        if field_ev.is_some() {\n-                            self.reach(field.def_id, field_ev).ty();\n+                        let field_level = self.get(field.def_id);\n+                        if field_level.is_some() {\n+                            self.reach(field.def_id, field_level).ty();\n                         }\n                     }\n                 }\n                 if let Some(ctor_def_id) = struct_def.ctor_def_id() {\n-                    let ctor_ev = self.get(ctor_def_id);\n-                    if ctor_ev.is_some() {\n-                        self.reach(item.owner_id.def_id, ctor_ev).ty();\n+                    let ctor_level = self.get(ctor_def_id);\n+                    if ctor_level.is_some() {\n+                        self.reach(item.owner_id.def_id, ctor_level).ty();\n                     }\n                 }\n             }\n         }\n \n+        let orig_level = mem::replace(&mut self.prev_level, item_level);\n         intravisit::walk_item(self, item);\n+        self.prev_level = orig_level;\n     }\n \n     fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n         // Blocks can have public items, for example impls, but they always\n         // start as completely private regardless of publicity of a function,\n         // constant, type, field, etc., in which this block resides.\n+        let orig_level = mem::replace(&mut self.prev_level, None);\n         intravisit::walk_block(self, b);\n+        self.prev_level = orig_level;\n     }\n }\n \n@@ -941,7 +932,11 @@ impl<'tcx> DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx>\n         _descr: &dyn fmt::Display,\n     ) -> ControlFlow<Self::BreakTy> {\n         if let Some(def_id) = def_id.as_local() {\n-            self.ev.update_eff_vis(def_id, self.effective_vis, None, self.level);\n+            if let (ty::Visibility::Public, _) | (_, Some(Level::ReachableThroughImplTrait)) =\n+                (self.tcx().visibility(def_id.to_def_id()), self.level)\n+            {\n+                self.ev.update(def_id, self.level);\n+            }\n         }\n         ControlFlow::Continue(())\n     }\n@@ -2169,6 +2164,7 @@ fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n         tcx,\n         effective_visibilities: tcx.resolutions(()).effective_visibilities.clone(),\n         macro_reachable: Default::default(),\n+        prev_level: Some(Level::Direct),\n         changed: false,\n     };\n "}, {"sha": "ff8bd462dd8d8277fbdd34c7bf32dc0f8b9dda2e", "filename": "compiler/rustc_resolve/messages.ftl", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fmessages.ftl?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -145,6 +145,15 @@ resolve_param_in_ty_of_const_param =\n     the type of const parameters must not depend on other generic parameters\n     .label = the type must not depend on the parameter `{$name}`\n \n+resolve_type_param_in_ty_of_const_param =\n+    type parameters may not be used in the type of const parameters\n+\n+resolve_const_param_in_ty_of_const_param =\n+    const parameters may not be used in the type of const parameters\n+\n+resolve_lifetime_param_in_ty_of_const_param =\n+    lifetime parameters may not be used in the type of const parameters\n+\n resolve_self_in_generic_param_default =\n     generic parameters cannot use `Self` in their defaults\n     .label = `Self` in generic parameter default\n@@ -156,12 +165,15 @@ resolve_param_in_non_trivial_anon_const =\n resolve_param_in_non_trivial_anon_const_help =\n     use `#![feature(generic_const_exprs)]` to allow generic const expressions\n \n-resolve_param_in_non_trivial_anon_const_sub_type =\n+resolve_type_param_in_non_trivial_anon_const =\n     type parameters may not be used in const expressions\n \n-resolve_param_in_non_trivial_anon_const_sub_non_type =\n+resolve_const_param_in_non_trivial_anon_const =\n     const parameters may only be used as standalone arguments, i.e. `{$name}`\n \n+resolve_lifetime_param_in_non_trivial_anon_const =\n+    lifetime parameters may not be used in const expressions\n+\n resolve_unreachable_label =\n     use of unreachable label `{$name}`\n     .label = unreachable label `{$name}`\n@@ -233,3 +245,16 @@ resolve_macro_use_extern_crate_self = `#[macro_use]` is not supported on `extern\n \n resolve_accessible_unsure = not sure whether the path is accessible or not\n     .note = the type may have associated items, but we are currently not checking them\n+\n+resolve_param_in_enum_discriminant =\n+    generic parameters may not be used in enum discriminant values\n+    .label = cannot perform const operation using `{$name}`\n+\n+resolve_type_param_in_enum_discriminant =\n+    type parameters may not be used in enum discriminant values\n+\n+resolve_const_param_in_enum_discriminant =\n+    const parameters may not be used in enum discriminant values\n+\n+resolve_lifetime_param_in_enum_discriminant =\n+    lifetime parameters may not be used in enum discriminant values"}, {"sha": "72cdce5c8f05e2a1dea05a73f0faab0dfdf9f0be", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -864,25 +864,26 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ResolutionError::ForwardDeclaredGenericParam => {\n                 self.tcx.sess.create_err(errs::ForwardDeclaredGenericParam { span })\n             }\n-            ResolutionError::ParamInTyOfConstParam(name) => {\n-                self.tcx.sess.create_err(errs::ParamInTyOfConstParam { span, name })\n-            }\n-            ResolutionError::ParamInNonTrivialAnonConst { name, is_type } => {\n+            ResolutionError::ParamInTyOfConstParam { name, param_kind: is_type } => self\n+                .tcx\n+                .sess\n+                .create_err(errs::ParamInTyOfConstParam { span, name, param_kind: is_type }),\n+            ResolutionError::ParamInNonTrivialAnonConst { name, param_kind: is_type } => {\n                 self.tcx.sess.create_err(errs::ParamInNonTrivialAnonConst {\n                     span,\n                     name,\n-                    sub_is_type: if is_type {\n-                        errs::ParamInNonTrivialAnonConstIsType::AType\n-                    } else {\n-                        errs::ParamInNonTrivialAnonConstIsType::NotAType { name }\n-                    },\n+                    param_kind: is_type,\n                     help: self\n                         .tcx\n                         .sess\n                         .is_nightly_build()\n                         .then_some(errs::ParamInNonTrivialAnonConstHelp),\n                 })\n             }\n+            ResolutionError::ParamInEnumDiscriminant { name, param_kind: is_type } => self\n+                .tcx\n+                .sess\n+                .create_err(errs::ParamInEnumDiscriminant { span, name, param_kind: is_type }),\n             ResolutionError::SelfInGenericParamDefault => {\n                 self.tcx.sess.create_err(errs::SelfInGenericParamDefault { span })\n             }"}, {"sha": "87067189a77580edd1948c21fc285203d115408e", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -199,7 +199,7 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         let tcx = self.r.tcx;\n         self.changed |= self.import_effective_visibilities.update(\n             binding,\n-            Some(nominal_vis),\n+            nominal_vis,\n             || cheap_private_vis.unwrap_or_else(|| self.r.private_vis_import(binding)),\n             inherited_eff_vis,\n             parent_id.level(),\n@@ -213,7 +213,7 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         let tcx = self.r.tcx;\n         self.changed |= self.def_effective_visibilities.update(\n             def_id,\n-            Some(nominal_vis),\n+            nominal_vis,\n             || cheap_private_vis.unwrap_or_else(|| self.r.private_vis_def(def_id)),\n             inherited_eff_vis,\n             parent_id.level(),"}, {"sha": "f6d7e8b4c873d932c5afbc5852642eaa25986253", "filename": "compiler/rustc_resolve/src/errors.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -326,6 +326,18 @@ pub(crate) struct ParamInTyOfConstParam {\n     #[label]\n     pub(crate) span: Span,\n     pub(crate) name: Symbol,\n+    #[subdiagnostic]\n+    pub(crate) param_kind: Option<ParamKindInTyOfConstParam>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum ParamKindInTyOfConstParam {\n+    #[note(resolve_type_param_in_ty_of_const_param)]\n+    Type,\n+    #[note(resolve_const_param_in_ty_of_const_param)]\n+    Const,\n+    #[note(resolve_lifetime_param_in_ty_of_const_param)]\n+    Lifetime,\n }\n \n #[derive(Diagnostic)]\n@@ -344,7 +356,7 @@ pub(crate) struct ParamInNonTrivialAnonConst {\n     pub(crate) span: Span,\n     pub(crate) name: Symbol,\n     #[subdiagnostic]\n-    pub(crate) sub_is_type: ParamInNonTrivialAnonConstIsType,\n+    pub(crate) param_kind: ParamKindInNonTrivialAnonConst,\n     #[subdiagnostic]\n     pub(crate) help: Option<ParamInNonTrivialAnonConstHelp>,\n }\n@@ -354,11 +366,13 @@ pub(crate) struct ParamInNonTrivialAnonConst {\n pub(crate) struct ParamInNonTrivialAnonConstHelp;\n \n #[derive(Subdiagnostic)]\n-pub(crate) enum ParamInNonTrivialAnonConstIsType {\n-    #[note(resolve_param_in_non_trivial_anon_const_sub_type)]\n-    AType,\n-    #[help(resolve_param_in_non_trivial_anon_const_sub_non_type)]\n-    NotAType { name: Symbol },\n+pub(crate) enum ParamKindInNonTrivialAnonConst {\n+    #[note(resolve_type_param_in_non_trivial_anon_const)]\n+    Type,\n+    #[help(resolve_const_param_in_non_trivial_anon_const)]\n+    Const { name: Symbol },\n+    #[note(resolve_lifetime_param_in_non_trivial_anon_const)]\n+    Lifetime,\n }\n \n #[derive(Diagnostic)]\n@@ -539,3 +553,24 @@ pub(crate) struct CfgAccessibleUnsure {\n     #[primary_span]\n     pub(crate) span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_param_in_enum_discriminant)]\n+pub(crate) struct ParamInEnumDiscriminant {\n+    #[primary_span]\n+    #[label]\n+    pub(crate) span: Span,\n+    pub(crate) name: Symbol,\n+    #[subdiagnostic]\n+    pub(crate) param_kind: ParamKindInEnumDiscriminant,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum ParamKindInEnumDiscriminant {\n+    #[note(resolve_type_param_in_enum_discriminant)]\n+    Type,\n+    #[note(resolve_const_param_in_enum_discriminant)]\n+    Const,\n+    #[note(resolve_lifetime_param_in_enum_discriminant)]\n+    Lifetime,\n+}"}, {"sha": "5a3ae656ad459c1943906d793a4f99b2ff4fe961", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 53, "deletions": 29, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -13,8 +13,10 @@ use rustc_span::{Span, DUMMY_SP};\n \n use std::ptr;\n \n+use crate::errors::{ParamKindInEnumDiscriminant, ParamKindInNonTrivialAnonConst};\n use crate::late::{\n-    ConstantHasGenerics, ConstantItemKind, HasGenericParams, PathSource, Rib, RibKind,\n+    ConstantHasGenerics, ConstantItemKind, HasGenericParams, NoConstantGenericsReason, PathSource,\n+    Rib, RibKind,\n };\n use crate::macros::{sub_namespace_match, MacroRulesScope};\n use crate::{errors, AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n@@ -1153,7 +1155,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                         RibKind::ConstParamTy => {\n                             if let Some(span) = finalize {\n-                                self.report_error(span, ParamInTyOfConstParam(rib_ident.name));\n+                                self.report_error(\n+                                    span,\n+                                    ParamInTyOfConstParam {\n+                                        name: rib_ident.name,\n+                                        param_kind: None,\n+                                    },\n+                                );\n                             }\n                             return Res::Err;\n                         }\n@@ -1188,11 +1196,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n \n                         RibKind::ConstantItem(trivial, _) => {\n-                            let features = self.tcx.sess.features_untracked();\n-                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial == ConstantHasGenerics::Yes\n-                                || features.generic_const_exprs)\n-                            {\n+                            if let ConstantHasGenerics::No(cause) = trivial {\n                                 // HACK(min_const_generics): If we encounter `Self` in an anonymous\n                                 // constant we can't easily tell if it's generic at this stage, so\n                                 // we instead remember this and then enforce the self type to be\n@@ -1210,13 +1214,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     }\n                                 } else {\n                                     if let Some(span) = finalize {\n-                                        self.report_error(\n-                                            span,\n-                                            ResolutionError::ParamInNonTrivialAnonConst {\n-                                                name: rib_ident.name,\n-                                                is_type: true,\n-                                            },\n-                                        );\n+                                        let error = match cause {\n+                                            NoConstantGenericsReason::IsEnumDiscriminant => {\n+                                                ResolutionError::ParamInEnumDiscriminant {\n+                                                    name: rib_ident.name,\n+                                                    param_kind: ParamKindInEnumDiscriminant::Type,\n+                                                }\n+                                            }\n+                                            NoConstantGenericsReason::NonTrivialConstArg => {\n+                                                ResolutionError::ParamInNonTrivialAnonConst {\n+                                                    name: rib_ident.name,\n+                                                    param_kind:\n+                                                        ParamKindInNonTrivialAnonConst::Type,\n+                                                }\n+                                            }\n+                                        };\n+                                        self.report_error(span, error);\n                                         self.tcx.sess.delay_span_bug(span, CG_BUG_STR);\n                                     }\n \n@@ -1233,7 +1246,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             if let Some(span) = finalize {\n                                 self.report_error(\n                                     span,\n-                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n+                                    ResolutionError::ParamInTyOfConstParam {\n+                                        name: rib_ident.name,\n+                                        param_kind: Some(errors::ParamKindInTyOfConstParam::Type),\n+                                    },\n                                 );\n                             }\n                             return Res::Err;\n@@ -1264,20 +1280,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         | RibKind::ForwardGenericParamBan => continue,\n \n                         RibKind::ConstantItem(trivial, _) => {\n-                            let features = self.tcx.sess.features_untracked();\n-                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial == ConstantHasGenerics::Yes\n-                                || features.generic_const_exprs)\n-                            {\n+                            if let ConstantHasGenerics::No(cause) = trivial {\n                                 if let Some(span) = finalize {\n-                                    self.report_error(\n-                                        span,\n-                                        ResolutionError::ParamInNonTrivialAnonConst {\n-                                            name: rib_ident.name,\n-                                            is_type: false,\n-                                        },\n-                                    );\n-                                    self.tcx.sess.delay_span_bug(span, CG_BUG_STR);\n+                                    let error = match cause {\n+                                        NoConstantGenericsReason::IsEnumDiscriminant => {\n+                                            ResolutionError::ParamInEnumDiscriminant {\n+                                                name: rib_ident.name,\n+                                                param_kind: ParamKindInEnumDiscriminant::Const,\n+                                            }\n+                                        }\n+                                        NoConstantGenericsReason::NonTrivialConstArg => {\n+                                            ResolutionError::ParamInNonTrivialAnonConst {\n+                                                name: rib_ident.name,\n+                                                param_kind: ParamKindInNonTrivialAnonConst::Const {\n+                                                    name: rib_ident.name,\n+                                                },\n+                                            }\n+                                        }\n+                                    };\n+                                    self.report_error(span, error);\n                                 }\n \n                                 return Res::Err;\n@@ -1291,7 +1312,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             if let Some(span) = finalize {\n                                 self.report_error(\n                                     span,\n-                                    ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n+                                    ResolutionError::ParamInTyOfConstParam {\n+                                        name: rib_ident.name,\n+                                        param_kind: Some(errors::ParamKindInTyOfConstParam::Const),\n+                                    },\n                                 );\n                             }\n                             return Res::Err;"}, {"sha": "2a8287d5554f874f8b6d9fbbb458721165ff61fc", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 163, "deletions": 103, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -66,6 +66,15 @@ enum IsRepeatExpr {\n     Yes,\n }\n \n+/// Describes whether an `AnonConst` is a type level const arg or\n+/// some other form of anon const (i.e. inline consts or enum discriminants)\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum AnonConstKind {\n+    EnumDiscriminant,\n+    InlineConst,\n+    ConstArg(IsRepeatExpr),\n+}\n+\n impl PatternSource {\n     fn descr(self) -> &'static str {\n         match self {\n@@ -105,7 +114,7 @@ pub(crate) enum HasGenericParams {\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub(crate) enum ConstantHasGenerics {\n     Yes,\n-    No,\n+    No(NoConstantGenericsReason),\n }\n \n impl ConstantHasGenerics {\n@@ -114,6 +123,27 @@ impl ConstantHasGenerics {\n     }\n }\n \n+/// Reason for why an anon const is not allowed to reference generic parameters\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub(crate) enum NoConstantGenericsReason {\n+    /// Const arguments are only allowed to use generic parameters when:\n+    /// - `feature(generic_const_exprs)` is enabled\n+    /// or\n+    /// - the const argument is a sole const generic paramater, i.e. `foo::<{ N }>()`\n+    ///\n+    /// If neither of the above are true then this is used as the cause.\n+    NonTrivialConstArg,\n+    /// Enum discriminants are not allowed to reference generic parameters ever, this\n+    /// is used when an anon const is in the following position:\n+    ///\n+    /// ```rust,compile_fail\n+    /// enum Foo<const N: isize> {\n+    ///     Variant = { N }, // this anon const is not allowed to use generics\n+    /// }\n+    /// ```\n+    IsEnumDiscriminant,\n+}\n+\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub(crate) enum ConstantItemKind {\n     Const,\n@@ -273,15 +303,18 @@ enum LifetimeRibKind {\n     /// Signal we cannot find which should be the anonymous lifetime.\n     ElisionFailure,\n \n-    /// FIXME(const_generics): This patches over an ICE caused by non-'static lifetimes in const\n-    /// generics. We are disallowing this until we can decide on how we want to handle non-'static\n-    /// lifetimes in const generics. See issue #74052 for discussion.\n-    ConstGeneric,\n+    /// This rib forbids usage of generic parameters inside of const parameter types.\n+    ///\n+    /// While this is desirable to support eventually, it is difficult to do and so is\n+    /// currently forbidden. See rust-lang/project-const-generics#28 for more info.\n+    ConstParamTy,\n \n-    /// Non-static lifetimes are prohibited in anonymous constants under `min_const_generics`.\n-    /// This function will emit an error if `generic_const_exprs` is not enabled, the body\n-    /// identified by `body_id` is an anonymous constant and `lifetime_ref` is non-static.\n-    AnonConst,\n+    /// Usage of generic parameters is forbidden in various positions for anon consts:\n+    /// - const arguments when `generic_const_exprs` is not enabled\n+    /// - enum discriminant values\n+    ///\n+    /// This rib emits an error when a lifetime would resolve to a lifetime parameter.\n+    ConcreteAnonConst(NoConstantGenericsReason),\n \n     /// This rib acts as a barrier to forbid reference to lifetimes of a parent item.\n     Item,\n@@ -648,13 +681,8 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n         self.resolve_block(block);\n         self.parent_scope.macro_rules = old_macro_rules;\n     }\n-    fn visit_anon_const(&mut self, constant: &'ast AnonConst) {\n-        // We deal with repeat expressions explicitly in `resolve_expr`.\n-        self.with_lifetime_rib(LifetimeRibKind::AnonConst, |this| {\n-            this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n-                this.resolve_anon_const(constant, IsRepeatExpr::No);\n-            })\n-        })\n+    fn visit_anon_const(&mut self, _constant: &'ast AnonConst) {\n+        bug!(\"encountered anon const without a manual call to `resolve_anon_const`\");\n     }\n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         self.resolve_expr(expr, None);\n@@ -676,7 +704,7 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n     fn visit_ty(&mut self, ty: &'ast Ty) {\n         let prev = self.diagnostic_metadata.current_trait_object;\n         let prev_ty = self.diagnostic_metadata.current_type_path;\n-        match ty.kind {\n+        match &ty.kind {\n             TyKind::Ref(None, _) => {\n                 // Elided lifetime in reference: we resolve as if there was some lifetime `'_` with\n                 // NodeId `ty.id`.\n@@ -685,7 +713,7 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 self.resolve_elided_lifetime(ty.id, span);\n                 visit::walk_ty(self, ty);\n             }\n-            TyKind::Path(ref qself, ref path) => {\n+            TyKind::Path(qself, path) => {\n                 self.diagnostic_metadata.current_type_path = Some(ty);\n                 self.smart_resolve_path(ty.id, &qself, path, PathSource::Type);\n \n@@ -730,11 +758,11 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 visit::walk_ty(self, ty);\n                 self.lifetime_elision_candidates = candidates;\n             }\n-            TyKind::TraitObject(ref bounds, ..) => {\n+            TyKind::TraitObject(bounds, ..) => {\n                 self.diagnostic_metadata.current_trait_object = Some(&bounds[..]);\n                 visit::walk_ty(self, ty)\n             }\n-            TyKind::BareFn(ref bare_fn) => {\n+            TyKind::BareFn(bare_fn) => {\n                 let span = ty.span.shrink_to_lo().to(bare_fn.decl_span.shrink_to_lo());\n                 self.with_generic_param_rib(\n                     &bare_fn.generic_params,\n@@ -769,6 +797,13 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                     },\n                 )\n             }\n+            TyKind::Array(element_ty, length) => {\n+                self.visit_ty(element_ty);\n+                self.resolve_anon_const(length, AnonConstKind::ConstArg(IsRepeatExpr::No));\n+            }\n+            TyKind::Typeof(ct) => {\n+                self.resolve_anon_const(ct, AnonConstKind::ConstArg(IsRepeatExpr::No))\n+            }\n             _ => visit::walk_ty(self, ty),\n         }\n         self.diagnostic_metadata.current_trait_object = prev;\n@@ -994,36 +1029,25 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 // namespace first, and if that fails we try again in the value namespace. If\n                 // resolution in the value namespace succeeds, we have an generic const argument on\n                 // our hands.\n-                if let TyKind::Path(ref qself, ref path) = ty.kind {\n+                if let TyKind::Path(None, ref path) = ty.kind {\n                     // We cannot disambiguate multi-segment paths right now as that requires type\n                     // checking.\n-                    if path.segments.len() == 1 && path.segments[0].args.is_none() {\n+                    if path.is_potential_trivial_const_arg() {\n                         let mut check_ns = |ns| {\n                             self.maybe_resolve_ident_in_lexical_scope(path.segments[0].ident, ns)\n                                 .is_some()\n                         };\n                         if !check_ns(TypeNS) && check_ns(ValueNS) {\n-                            // This must be equivalent to `visit_anon_const`, but we cannot call it\n-                            // directly due to visitor lifetimes so we have to copy-paste some code.\n-                            //\n-                            // Note that we might not be inside of an repeat expression here,\n-                            // but considering that `IsRepeatExpr` is only relevant for\n-                            // non-trivial constants this is doesn't matter.\n-                            self.with_constant_rib(\n-                                IsRepeatExpr::No,\n-                                ConstantHasGenerics::Yes,\n-                                None,\n+                            self.resolve_anon_const_manual(\n+                                true,\n+                                AnonConstKind::ConstArg(IsRepeatExpr::No),\n                                 |this| {\n                                     this.smart_resolve_path(\n                                         ty.id,\n-                                        qself,\n+                                        &None,\n                                         path,\n                                         PathSource::Expr(None),\n                                     );\n-\n-                                    if let Some(ref qself) = *qself {\n-                                        this.visit_ty(&qself.ty);\n-                                    }\n                                     this.visit_path(path, ty.id);\n                                 },\n                             );\n@@ -1037,7 +1061,9 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 self.visit_ty(ty);\n             }\n             GenericArg::Lifetime(lt) => self.visit_lifetime(lt, visit::LifetimeCtxt::GenericArg),\n-            GenericArg::Const(ct) => self.visit_anon_const(ct),\n+            GenericArg::Const(ct) => {\n+                self.resolve_anon_const(ct, AnonConstKind::ConstArg(IsRepeatExpr::No))\n+            }\n         }\n         self.diagnostic_metadata.currently_processing_generics = prev;\n     }\n@@ -1053,7 +1079,9 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n         match constraint.kind {\n             AssocConstraintKind::Equality { ref term } => match term {\n                 Term::Ty(ty) => self.visit_ty(ty),\n-                Term::Const(c) => self.visit_anon_const(c),\n+                Term::Const(c) => {\n+                    self.resolve_anon_const(c, AnonConstKind::ConstArg(IsRepeatExpr::No))\n+                }\n             },\n             AssocConstraintKind::Bound { ref bounds } => {\n                 walk_list!(self, visit_param_bound, bounds, BoundKind::Bound);\n@@ -1102,8 +1130,8 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                             | LifetimeRibKind::AnonymousReportError\n                             | LifetimeRibKind::Elided(_)\n                             | LifetimeRibKind::ElisionFailure\n-                            | LifetimeRibKind::AnonConst\n-                            | LifetimeRibKind::ConstGeneric => {}\n+                            | LifetimeRibKind::ConcreteAnonConst(_)\n+                            | LifetimeRibKind::ConstParamTy => {}\n                         }\n                     }\n                 }\n@@ -1164,7 +1192,7 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 InlineAsmOperand::Const { anon_const, .. } => {\n                     // Although this is `DefKind::AnonConst`, it is allowed to reference outer\n                     // generic parameters like an inline const.\n-                    self.resolve_inline_const(anon_const);\n+                    self.resolve_anon_const(anon_const, AnonConstKind::InlineConst);\n                 }\n                 InlineAsmOperand::Sym { sym } => self.visit_inline_asm_sym(sym),\n             }\n@@ -1188,6 +1216,10 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n         visit::walk_variant(self, v)\n     }\n \n+    fn visit_variant_discr(&mut self, discr: &'ast AnonConst) {\n+        self.resolve_anon_const(discr, AnonConstKind::EnumDiscriminant);\n+    }\n+\n     fn visit_field_def(&mut self, f: &'ast FieldDef) {\n         self.resolve_doc_links(&f.attrs, MaybeExported::Ok(f.id));\n         visit::walk_field_def(self, f)\n@@ -1386,7 +1418,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n                         this.ribs[TypeNS].push(Rib::new(RibKind::ConstParamTy));\n                         this.ribs[ValueNS].push(Rib::new(RibKind::ConstParamTy));\n-                        this.with_lifetime_rib(LifetimeRibKind::ConstGeneric, |this| {\n+                        this.with_lifetime_rib(LifetimeRibKind::ConstParamTy, |this| {\n                             this.visit_ty(ty)\n                         });\n                         this.ribs[TypeNS].pop().unwrap();\n@@ -1395,9 +1427,10 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         if let Some(ref expr) = default {\n                             this.ribs[TypeNS].push(forward_ty_ban_rib);\n                             this.ribs[ValueNS].push(forward_const_ban_rib);\n-                            this.with_lifetime_rib(LifetimeRibKind::ConstGeneric, |this| {\n-                                this.resolve_anon_const(expr, IsRepeatExpr::No)\n-                            });\n+                            this.resolve_anon_const(\n+                                expr,\n+                                AnonConstKind::ConstArg(IsRepeatExpr::No),\n+                            );\n                             forward_const_ban_rib = this.ribs[ValueNS].pop().unwrap();\n                             forward_ty_ban_rib = this.ribs[TypeNS].pop().unwrap();\n                         }\n@@ -1475,8 +1508,8 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                                         LifetimeUseSet::Many\n                                     }),\n                                     LifetimeRibKind::Generics { .. }\n-                                    | LifetimeRibKind::ConstGeneric => None,\n-                                    LifetimeRibKind::AnonConst => {\n+                                    | LifetimeRibKind::ConstParamTy => None,\n+                                    LifetimeRibKind::ConcreteAnonConst(_) => {\n                                         span_bug!(ident.span, \"unexpected rib kind: {:?}\", rib.kind)\n                                     }\n                                 })\n@@ -1495,17 +1528,17 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             match rib.kind {\n                 LifetimeRibKind::Item => break,\n-                LifetimeRibKind::ConstGeneric => {\n-                    self.emit_non_static_lt_in_const_generic_error(lifetime);\n+                LifetimeRibKind::ConstParamTy => {\n+                    self.emit_non_static_lt_in_const_param_ty_error(lifetime);\n                     self.record_lifetime_res(\n                         lifetime.id,\n                         LifetimeRes::Error,\n                         LifetimeElisionCandidate::Ignore,\n                     );\n                     return;\n                 }\n-                LifetimeRibKind::AnonConst => {\n-                    self.maybe_emit_forbidden_non_static_lifetime_error(lifetime);\n+                LifetimeRibKind::ConcreteAnonConst(cause) => {\n+                    self.emit_forbidden_non_static_lifetime_error(cause, lifetime);\n                     self.record_lifetime_res(\n                         lifetime.id,\n                         LifetimeRes::Error,\n@@ -1604,9 +1637,9 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     return;\n                 }\n                 LifetimeRibKind::Item => break,\n-                LifetimeRibKind::Generics { .. } | LifetimeRibKind::ConstGeneric => {}\n-                LifetimeRibKind::AnonConst => {\n-                    // There is always an `Elided(LifetimeRes::Static)` inside an `AnonConst`.\n+                LifetimeRibKind::Generics { .. } | LifetimeRibKind::ConstParamTy => {}\n+                LifetimeRibKind::ConcreteAnonConst(_) => {\n+                    // There is always an `Elided(LifetimeRes::Infer)` inside an `AnonConst`.\n                     span_bug!(lifetime.ident.span, \"unexpected rib kind: {:?}\", rib.kind)\n                 }\n             }\n@@ -1826,9 +1859,9 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         self.report_missing_lifetime_specifiers(vec![missing_lifetime], None);\n                         break;\n                     }\n-                    LifetimeRibKind::Generics { .. } | LifetimeRibKind::ConstGeneric => {}\n-                    LifetimeRibKind::AnonConst => {\n-                        // There is always an `Elided(LifetimeRes::Static)` inside an `AnonConst`.\n+                    LifetimeRibKind::Generics { .. } | LifetimeRibKind::ConstParamTy => {}\n+                    LifetimeRibKind::ConcreteAnonConst(_) => {\n+                        // There is always an `Elided(LifetimeRes::Infer)` inside an `AnonConst`.\n                         span_bug!(elided_lifetime_span, \"unexpected rib kind: {:?}\", rib.kind)\n                     }\n                 }\n@@ -2560,7 +2593,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         self.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n     }\n \n-    // HACK(min_const_generics,const_evaluatable_unchecked): We\n+    // HACK(min_const_generics, generic_const_exprs): We\n     // want to keep allowing `[0; std::mem::size_of::<*mut T>()]`\n     // with a future compat lint for now. We do this by adding an\n     // additional special case for repeat expressions.\n@@ -2576,18 +2609,26 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         item: Option<(Ident, ConstantItemKind)>,\n         f: impl FnOnce(&mut Self),\n     ) {\n-        self.with_rib(ValueNS, RibKind::ConstantItem(may_use_generics, item), |this| {\n-            this.with_rib(\n-                TypeNS,\n-                RibKind::ConstantItem(\n-                    may_use_generics.force_yes_if(is_repeat == IsRepeatExpr::Yes),\n-                    item,\n-                ),\n-                |this| {\n-                    this.with_label_rib(RibKind::ConstantItem(may_use_generics, item), f);\n-                },\n-            )\n-        });\n+        let f = |this: &mut Self| {\n+            this.with_rib(ValueNS, RibKind::ConstantItem(may_use_generics, item), |this| {\n+                this.with_rib(\n+                    TypeNS,\n+                    RibKind::ConstantItem(\n+                        may_use_generics.force_yes_if(is_repeat == IsRepeatExpr::Yes),\n+                        item,\n+                    ),\n+                    |this| {\n+                        this.with_label_rib(RibKind::ConstantItem(may_use_generics, item), f);\n+                    },\n+                )\n+            })\n+        };\n+\n+        if let ConstantHasGenerics::No(cause) = may_use_generics {\n+            self.with_lifetime_rib(LifetimeRibKind::ConcreteAnonConst(cause), f)\n+        } else {\n+            f(self)\n+        }\n     }\n \n     fn with_current_self_type<T>(&mut self, self_type: &Ty, f: impl FnOnce(&mut Self) -> T) -> T {\n@@ -3924,24 +3965,54 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    fn resolve_anon_const(&mut self, constant: &'ast AnonConst, is_repeat: IsRepeatExpr) {\n-        debug!(\"resolve_anon_const {:?} is_repeat: {:?}\", constant, is_repeat);\n-        self.with_constant_rib(\n-            is_repeat,\n-            if constant.value.is_potential_trivial_const_param() {\n-                ConstantHasGenerics::Yes\n-            } else {\n-                ConstantHasGenerics::No\n-            },\n-            None,\n-            |this| visit::walk_anon_const(this, constant),\n+    fn resolve_anon_const(&mut self, constant: &'ast AnonConst, anon_const_kind: AnonConstKind) {\n+        debug!(\n+            \"resolve_anon_const(constant: {:?}, anon_const_kind: {:?})\",\n+            constant, anon_const_kind\n         );\n+\n+        self.resolve_anon_const_manual(\n+            constant.value.is_potential_trivial_const_arg(),\n+            anon_const_kind,\n+            |this| this.resolve_expr(&constant.value, None),\n+        )\n     }\n \n-    fn resolve_inline_const(&mut self, constant: &'ast AnonConst) {\n-        debug!(\"resolve_anon_const {constant:?}\");\n-        self.with_constant_rib(IsRepeatExpr::No, ConstantHasGenerics::Yes, None, |this| {\n-            visit::walk_anon_const(this, constant)\n+    /// There are a few places that we need to resolve an anon const but we did not parse an\n+    /// anon const so cannot provide an `&'ast AnonConst`. Right now this is just unbraced\n+    /// const arguments that were parsed as type arguments, and `legact_const_generics` which\n+    /// parse as normal function argument expressions. To avoid duplicating the code for resolving\n+    /// an anon const we have this function which lets the caller manually call `resolve_expr` or\n+    /// `smart_resolve_path`.\n+    fn resolve_anon_const_manual(\n+        &mut self,\n+        is_trivial_const_arg: bool,\n+        anon_const_kind: AnonConstKind,\n+        resolve_expr: impl FnOnce(&mut Self),\n+    ) {\n+        let is_repeat_expr = match anon_const_kind {\n+            AnonConstKind::ConstArg(is_repeat_expr) => is_repeat_expr,\n+            _ => IsRepeatExpr::No,\n+        };\n+\n+        let may_use_generics = match anon_const_kind {\n+            AnonConstKind::EnumDiscriminant => {\n+                ConstantHasGenerics::No(NoConstantGenericsReason::IsEnumDiscriminant)\n+            }\n+            AnonConstKind::InlineConst => ConstantHasGenerics::Yes,\n+            AnonConstKind::ConstArg(_) => {\n+                if self.r.tcx.features().generic_const_exprs || is_trivial_const_arg {\n+                    ConstantHasGenerics::Yes\n+                } else {\n+                    ConstantHasGenerics::No(NoConstantGenericsReason::NonTrivialConstArg)\n+                }\n+            }\n+        };\n+\n+        self.with_constant_rib(is_repeat_expr, may_use_generics, None, |this| {\n+            this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n+                resolve_expr(this);\n+            });\n         });\n     }\n \n@@ -4046,17 +4117,10 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     // Constant arguments need to be treated as AnonConst since\n                     // that is how they will be later lowered to HIR.\n                     if const_args.contains(&idx) {\n-                        self.with_constant_rib(\n-                            IsRepeatExpr::No,\n-                            if argument.is_potential_trivial_const_param() {\n-                                ConstantHasGenerics::Yes\n-                            } else {\n-                                ConstantHasGenerics::No\n-                            },\n-                            None,\n-                            |this| {\n-                                this.resolve_expr(argument, None);\n-                            },\n+                        self.resolve_anon_const_manual(\n+                            argument.is_potential_trivial_const_arg(),\n+                            AnonConstKind::ConstArg(IsRepeatExpr::No),\n+                            |this| this.resolve_expr(argument, None),\n                         );\n                     } else {\n                         self.resolve_expr(argument, None);\n@@ -4115,14 +4179,10 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             }\n             ExprKind::Repeat(ref elem, ref ct) => {\n                 self.visit_expr(elem);\n-                self.with_lifetime_rib(LifetimeRibKind::AnonConst, |this| {\n-                    this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n-                        this.resolve_anon_const(ct, IsRepeatExpr::Yes)\n-                    })\n-                });\n+                self.resolve_anon_const(ct, AnonConstKind::ConstArg(IsRepeatExpr::Yes));\n             }\n             ExprKind::ConstBlock(ref ct) => {\n-                self.resolve_inline_const(ct);\n+                self.resolve_anon_const(ct, AnonConstKind::InlineConst);\n             }\n             ExprKind::Index(ref elem, ref idx) => {\n                 self.resolve_expr(elem, Some(expr));"}, {"sha": "c9131d8c8a917d181e9c3a8bfb109a1d25d01f27", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,7 +1,7 @@\n use crate::diagnostics::{ImportSuggestion, LabelSuggestion, TypoSuggestion};\n use crate::late::{AliasPossibility, LateResolutionVisitor, RibKind};\n use crate::late::{LifetimeBinderKind, LifetimeRes, LifetimeRibKind, LifetimeUseSet};\n-use crate::path_names_to_string;\n+use crate::{errors, path_names_to_string};\n use crate::{Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n@@ -22,7 +22,6 @@ use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::PrimTy;\n use rustc_session::lint;\n-use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n@@ -35,6 +34,8 @@ use std::ops::Deref;\n \n use thin_vec::ThinVec;\n \n+use super::NoConstantGenericsReason;\n+\n type Res = def::Res<ast::NodeId>;\n \n /// A field or associated item from self type suggested in case of resolution failure.\n@@ -2316,37 +2317,56 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn emit_non_static_lt_in_const_generic_error(&self, lifetime_ref: &ast::Lifetime) {\n-        struct_span_err!(\n-            self.r.tcx.sess,\n-            lifetime_ref.ident.span,\n-            E0771,\n-            \"use of non-static lifetime `{}` in const generic\",\n-            lifetime_ref.ident\n-        )\n-        .note(\n-            \"for more information, see issue #74052 \\\n-            <https://github.com/rust-lang/rust/issues/74052>\",\n-        )\n-        .emit();\n+    pub(crate) fn emit_non_static_lt_in_const_param_ty_error(&self, lifetime_ref: &ast::Lifetime) {\n+        self.r\n+            .tcx\n+            .sess\n+            .create_err(errors::ParamInTyOfConstParam {\n+                span: lifetime_ref.ident.span,\n+                name: lifetime_ref.ident.name,\n+                param_kind: Some(errors::ParamKindInTyOfConstParam::Lifetime),\n+            })\n+            .emit();\n     }\n \n     /// Non-static lifetimes are prohibited in anonymous constants under `min_const_generics`.\n     /// This function will emit an error if `generic_const_exprs` is not enabled, the body identified by\n     /// `body_id` is an anonymous constant and `lifetime_ref` is non-static.\n-    pub(crate) fn maybe_emit_forbidden_non_static_lifetime_error(\n+    pub(crate) fn emit_forbidden_non_static_lifetime_error(\n         &self,\n+        cause: NoConstantGenericsReason,\n         lifetime_ref: &ast::Lifetime,\n     ) {\n-        let feature_active = self.r.tcx.sess.features_untracked().generic_const_exprs;\n-        if !feature_active {\n-            feature_err(\n-                &self.r.tcx.sess.parse_sess,\n-                sym::generic_const_exprs,\n-                lifetime_ref.ident.span,\n-                \"a non-static lifetime is not allowed in a `const`\",\n-            )\n-            .emit();\n+        match cause {\n+            NoConstantGenericsReason::IsEnumDiscriminant => {\n+                self.r\n+                    .tcx\n+                    .sess\n+                    .create_err(errors::ParamInEnumDiscriminant {\n+                        span: lifetime_ref.ident.span,\n+                        name: lifetime_ref.ident.name,\n+                        param_kind: errors::ParamKindInEnumDiscriminant::Lifetime,\n+                    })\n+                    .emit();\n+            }\n+            NoConstantGenericsReason::NonTrivialConstArg => {\n+                assert!(!self.r.tcx.features().generic_const_exprs);\n+                self.r\n+                    .tcx\n+                    .sess\n+                    .create_err(errors::ParamInNonTrivialAnonConst {\n+                        span: lifetime_ref.ident.span,\n+                        name: lifetime_ref.ident.name,\n+                        param_kind: errors::ParamKindInNonTrivialAnonConst::Lifetime,\n+                        help: self\n+                            .r\n+                            .tcx\n+                            .sess\n+                            .is_nightly_build()\n+                            .then_some(errors::ParamInNonTrivialAnonConstHelp),\n+                    })\n+                    .emit();\n+            }\n         }\n     }\n "}, {"sha": "590609f9ed3dbfe4d268a25c41bee942959f67ab", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -21,6 +21,9 @@\n #[macro_use]\n extern crate tracing;\n \n+use errors::{\n+    ParamKindInEnumDiscriminant, ParamKindInNonTrivialAnonConst, ParamKindInTyOfConstParam,\n+};\n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::{self as ast, attr, NodeId, CRATE_NODE_ID};\n@@ -223,11 +226,15 @@ enum ResolutionError<'a> {\n     /// Error E0128: generic parameters with a default cannot use forward-declared identifiers.\n     ForwardDeclaredGenericParam,\n     /// ERROR E0770: the type of const parameters must not depend on other generic parameters.\n-    ParamInTyOfConstParam(Symbol),\n+    ParamInTyOfConstParam { name: Symbol, param_kind: Option<ParamKindInTyOfConstParam> },\n     /// generic parameters must not be used inside const evaluations.\n     ///\n     /// This error is only emitted when using `min_const_generics`.\n-    ParamInNonTrivialAnonConst { name: Symbol, is_type: bool },\n+    ParamInNonTrivialAnonConst { name: Symbol, param_kind: ParamKindInNonTrivialAnonConst },\n+    /// generic parameters must not be used inside enum discriminants.\n+    ///\n+    /// This error is emitted even with `generic_const_exprs`.\n+    ParamInEnumDiscriminant { name: Symbol, param_kind: ParamKindInEnumDiscriminant },\n     /// Error E0735: generic parameters with a default cannot use `Self`\n     SelfInGenericParamDefault,\n     /// Error E0767: use of unreachable label"}, {"sha": "aa3cb03bad89267bf4f5689b144a3ab397115a26", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -599,6 +599,7 @@ pub enum PrintRequest {\n     StackProtectorStrategies,\n     LinkArgs,\n     SplitDebuginfo,\n+    DeploymentTarget,\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n@@ -1481,7 +1482,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n             \"[crate-name|file-names|sysroot|target-libdir|cfg|calling-conventions|\\\n              target-list|target-cpus|target-features|relocation-models|code-models|\\\n              tls-models|target-spec-json|all-target-specs-json|native-static-libs|\\\n-             stack-protector-strategies|link-args]\",\n+             stack-protector-strategies|link-args|deployment-target]\",\n         ),\n         opt::flagmulti_s(\"g\", \"\", \"Equivalent to -C debuginfo=2\"),\n         opt::flagmulti_s(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n@@ -1931,6 +1932,7 @@ fn collect_print_requests(\n         (\"all-target-specs-json\", PrintRequest::AllTargetSpecs),\n         (\"link-args\", PrintRequest::LinkArgs),\n         (\"split-debuginfo\", PrintRequest::SplitDebuginfo),\n+        (\"deployment-target\", PrintRequest::DeploymentTarget),\n     ];\n \n     prints.extend(matches.opt_strs(\"print\").into_iter().map(|req| {"}, {"sha": "5cbd7f98b6be3b301c65c9d334b50ff5ab29e737", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1555,7 +1555,7 @@ options! {\n         \"emit Retagging MIR statements, interpreted e.g., by miri; implies -Zmir-opt-level=0 \\\n         (default: no)\"),\n     mir_enable_passes: Vec<(String, bool)> = (Vec::new(), parse_list_with_polarity, [TRACKED],\n-        \"use like `-Zmir-enable-passes=+DestProp,-InstCombine`. Forces the specified passes to be \\\n+        \"use like `-Zmir-enable-passes=+DestinationPropagation,-InstSimplify`. Forces the specified passes to be \\\n         enabled, overriding all other checks. Passes that are not specified are enabled or \\\n         disabled by other flags as usual.\"),\n     mir_keep_place_mention: bool = (false, parse_bool, [TRACKED],"}, {"sha": "60efcb768cb076b7e18513ddff42738ca6201bc1", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -95,6 +95,7 @@ symbols! {\n \n         // Weak keywords, have special meaning only in specific contexts.\n         Auto:               \"auto\",\n+        Builtin:            \"builtin\",\n         Catch:              \"catch\",\n         Default:            \"default\",\n         MacroRules:         \"macro_rules\",\n@@ -440,6 +441,7 @@ symbols! {\n         breakpoint,\n         bridge,\n         bswap,\n+        builtin_syntax,\n         c_str,\n         c_str_literals,\n         c_unwind,\n@@ -1031,6 +1033,7 @@ symbols! {\n         non_exhaustive_omitted_patterns_lint,\n         non_lifetime_binders,\n         non_modrs_mods,\n+        none,\n         nontemporal_store,\n         noop_method_borrow,\n         noop_method_clone,"}, {"sha": "52159a7b06aa5178310ea0e4a2b3fc2aa4e58f33", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -65,7 +65,7 @@ mod attr_impl {\n     // The subset of llvm::Attribute needed for arguments, packed into a bitfield.\n     bitflags::bitflags! {\n         #[derive(Default, HashStable_Generic)]\n-        pub struct ArgAttribute: u16 {\n+        pub struct ArgAttribute: u8 {\n             const NoAlias   = 1 << 1;\n             const NoCapture = 1 << 2;\n             const NonNull   = 1 << 3;"}, {"sha": "9d1a4f3eeeafa4961a80424848a5c093c72386de", "filename": "compiler/rustc_target/src/asm/loongarch.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fasm%2Floongarch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fasm%2Floongarch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Floongarch.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -33,12 +33,11 @@ impl LoongArchInlineAsmRegClass {\n \n     pub fn supported_types(\n         self,\n-        arch: InlineAsmArch,\n+        _arch: InlineAsmArch,\n     ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n-        match (self, arch) {\n-            (Self::reg, InlineAsmArch::LoongArch64) => types! { _: I8, I16, I32, I64, F32, F64; },\n-            (Self::reg, _) => types! { _: I8, I16, I32, F32; },\n-            (Self::freg, _) => types! { _: F32, F64; },\n+        match self {\n+            Self::reg => types! { _: I8, I16, I32, I64, F32, F64; },\n+            Self::freg => types! { _: F32, F64; },\n         }\n     }\n }"}, {"sha": "ff2246318288ea92d2948b9c29b83a8fecba5f55", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,7 +1,7 @@\n use std::{borrow::Cow, env};\n \n use crate::spec::{cvs, Cc, DebuginfoKind, FramePointer, LinkArgs};\n-use crate::spec::{LinkerFlavor, Lld, SplitDebuginfo, StaticCow, TargetOptions};\n+use crate::spec::{LinkerFlavor, Lld, SplitDebuginfo, StaticCow, Target, TargetOptions};\n \n #[cfg(test)]\n #[path = \"apple/tests.rs\"]\n@@ -179,12 +179,28 @@ pub fn opts(os: &'static str, arch: Arch) -> TargetOptions {\n     }\n }\n \n-fn deployment_target(var_name: &str) -> Option<(u32, u32)> {\n-    let deployment_target = env::var(var_name).ok();\n-    deployment_target\n-        .as_ref()\n-        .and_then(|s| s.split_once('.'))\n-        .and_then(|(a, b)| a.parse::<u32>().and_then(|a| b.parse::<u32>().map(|b| (a, b))).ok())\n+pub fn deployment_target(target: &Target) -> Option<String> {\n+    let (major, minor) = match &*target.os {\n+        \"macos\" => {\n+            // This does not need to be specific. It just needs to handle x86 vs M1.\n+            let arch = if target.arch == \"x86\" || target.arch == \"x86_64\" { X86_64 } else { Arm64 };\n+            macos_deployment_target(arch)\n+        }\n+        \"ios\" => ios_deployment_target(),\n+        \"watchos\" => watchos_deployment_target(),\n+        \"tvos\" => tvos_deployment_target(),\n+        _ => return None,\n+    };\n+\n+    Some(format!(\"{major}.{minor}\"))\n+}\n+\n+fn from_set_deployment_target(var_name: &str) -> Option<(u32, u32)> {\n+    let deployment_target = env::var(var_name).ok()?;\n+    let (unparsed_major, unparsed_minor) = deployment_target.split_once('.')?;\n+    let (major, minor) = (unparsed_major.parse().ok()?, unparsed_minor.parse().ok()?);\n+\n+    Some((major, minor))\n }\n \n fn macos_default_deployment_target(arch: Arch) -> (u32, u32) {\n@@ -198,7 +214,8 @@ fn macos_default_deployment_target(arch: Arch) -> (u32, u32) {\n }\n \n fn macos_deployment_target(arch: Arch) -> (u32, u32) {\n-    deployment_target(\"MACOSX_DEPLOYMENT_TARGET\")\n+    // If you are looking for the default deployment target, prefer `rustc --print deployment-target`.\n+    from_set_deployment_target(\"MACOSX_DEPLOYMENT_TARGET\")\n         .unwrap_or_else(|| macos_default_deployment_target(arch))\n }\n \n@@ -247,7 +264,8 @@ fn link_env_remove(arch: Arch, os: &'static str) -> StaticCow<[StaticCow<str>]>\n }\n \n fn ios_deployment_target() -> (u32, u32) {\n-    deployment_target(\"IPHONEOS_DEPLOYMENT_TARGET\").unwrap_or((7, 0))\n+    // If you are looking for the default deployment target, prefer `rustc --print deployment-target`.\n+    from_set_deployment_target(\"IPHONEOS_DEPLOYMENT_TARGET\").unwrap_or((7, 0))\n }\n \n pub fn ios_llvm_target(arch: Arch) -> String {\n@@ -272,7 +290,8 @@ pub fn ios_sim_llvm_target(arch: Arch) -> String {\n }\n \n fn tvos_deployment_target() -> (u32, u32) {\n-    deployment_target(\"TVOS_DEPLOYMENT_TARGET\").unwrap_or((7, 0))\n+    // If you are looking for the default deployment target, prefer `rustc --print deployment-target`.\n+    from_set_deployment_target(\"TVOS_DEPLOYMENT_TARGET\").unwrap_or((7, 0))\n }\n \n fn tvos_lld_platform_version() -> String {\n@@ -281,7 +300,8 @@ fn tvos_lld_platform_version() -> String {\n }\n \n fn watchos_deployment_target() -> (u32, u32) {\n-    deployment_target(\"WATCHOS_DEPLOYMENT_TARGET\").unwrap_or((5, 0))\n+    // If you are looking for the default deployment target, prefer `rustc --print deployment-target`.\n+    from_set_deployment_target(\"WATCHOS_DEPLOYMENT_TARGET\").unwrap_or((5, 0))\n }\n \n fn watchos_lld_platform_version() -> String {"}, {"sha": "5632bcfcefe286b26901b172e01d6a20aa1dbe2f", "filename": "compiler/rustc_target/src/spec/armebv7r_none_eabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabi.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> Target {\n             linker: Some(\"rust-lld\".into()),\n             relocation_model: RelocModel::Static,\n             panic_strategy: PanicStrategy::Abort,\n-            max_atomic_width: Some(32),\n+            max_atomic_width: Some(64),\n             emit_debug_gdb_scripts: false,\n             // GCC and Clang default to 8 for arm-none here\n             c_enum_min_bits: Some(8),"}, {"sha": "2815de3589db61d126bcdbc3874aec40959890d4", "filename": "compiler/rustc_target/src/spec/armebv7r_none_eabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabihf.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -17,7 +17,7 @@ pub fn target() -> Target {\n             relocation_model: RelocModel::Static,\n             panic_strategy: PanicStrategy::Abort,\n             features: \"+vfp3,-d32,-fp16\".into(),\n-            max_atomic_width: Some(32),\n+            max_atomic_width: Some(64),\n             emit_debug_gdb_scripts: false,\n             // GCC and Clang default to 8 for arm-none here\n             c_enum_min_bits: Some(8),"}, {"sha": "e2c0808f1fdbf238fc1a7f39f93f36718459066f", "filename": "compiler/rustc_target/src/spec/armv7_sony_vita_newlibeabihf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_sony_vita_newlibeabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_sony_vita_newlibeabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_sony_vita_newlibeabihf.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -9,7 +9,7 @@ pub fn target() -> Target {\n     let pre_link_args = TargetOptions::link_args(LinkerFlavor::Gnu(Cc::Yes, Lld::No), &[\"-Wl,-q\"]);\n \n     Target {\n-        llvm_target: \"armv7a-vita-newlibeabihf\".into(),\n+        llvm_target: \"armv7a-vita-eabihf\".into(),\n         pointer_width: 32,\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".into(),\n         arch: \"arm\".into(),\n@@ -33,7 +33,7 @@ pub fn target() -> Target {\n             pre_link_args,\n             exe_suffix: \".elf\".into(),\n             panic_strategy: PanicStrategy::Abort,\n-            max_atomic_width: Some(32),\n+            max_atomic_width: Some(64),\n             ..Default::default()\n         },\n     }"}, {"sha": "74905ed5a4e07b51c204abf7cb7f0294ae1fc52c", "filename": "compiler/rustc_target/src/spec/armv7r_none_eabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabi.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> Target {\n             linker: Some(\"rust-lld\".into()),\n             relocation_model: RelocModel::Static,\n             panic_strategy: PanicStrategy::Abort,\n-            max_atomic_width: Some(32),\n+            max_atomic_width: Some(64),\n             emit_debug_gdb_scripts: false,\n             // GCC and Clang default to 8 for arm-none here\n             c_enum_min_bits: Some(8),"}, {"sha": "516b3f5c17eed42b25ce078ced930dd74467a1c5", "filename": "compiler/rustc_target/src/spec/armv7r_none_eabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabihf.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -16,7 +16,7 @@ pub fn target() -> Target {\n             relocation_model: RelocModel::Static,\n             panic_strategy: PanicStrategy::Abort,\n             features: \"+vfp3,-d32,-fp16\".into(),\n-            max_atomic_width: Some(32),\n+            max_atomic_width: Some(64),\n             emit_debug_gdb_scripts: false,\n             // GCC and Clang default to 8 for arm-none here\n             c_enum_min_bits: Some(8),"}, {"sha": "ba4b89c9ea10b23853c1066e814e87cf5c7eaaab", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -60,6 +60,7 @@ pub mod crt_objects;\n mod aix_base;\n mod android_base;\n mod apple_base;\n+pub use apple_base::deployment_target as current_apple_deployment_target;\n mod avr_gnu_base;\n mod bpf_base;\n mod dragonfly_base;"}, {"sha": "8fea3fc140d7296d6bb352a33d9bd11e6d3e530f", "filename": "compiler/rustc_trait_selection/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fmessages.ftl?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -20,3 +20,5 @@ trait_selection_negative_positive_conflict = found both positive and negative im\n     .negative_implementation_in_crate = negative implementation in crate `{$negative_impl_cname}`\n     .positive_implementation_here = positive implementation here\n     .positive_implementation_in_crate = positive implementation in crate `{$positive_impl_cname}`\n+\n+trait_selection_inherent_projection_normalization_overflow = overflow evaluating associated type `{$ty}`"}, {"sha": "54e22cc3d7fe28635e2bf4115bd8f204fca2ac01", "filename": "compiler/rustc_trait_selection/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -89,3 +89,11 @@ impl IntoDiagnostic<'_> for NegativePositiveConflict<'_> {\n         diag\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(trait_selection_inherent_projection_normalization_overflow)]\n+pub struct InherentProjectionNormalizationOverflow {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: String,\n+}"}, {"sha": "0ede32c753c6924ba22fa60e9d82c7a2d33abb47", "filename": "compiler/rustc_trait_selection/src/solve/assembly/structural_traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -33,7 +33,7 @@ pub(in crate::solve) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n         ty::Dynamic(..)\n         | ty::Param(..)\n         | ty::Foreign(..)\n-        | ty::Alias(ty::Projection, ..)\n+        | ty::Alias(ty::Projection | ty::Inherent, ..)\n         | ty::Placeholder(..)\n         | ty::Bound(..)\n         | ty::Infer(_) => {"}, {"sha": "04b38edc1265fc783b1a6133623fef0b1a98d334", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -655,7 +655,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             ty::Dynamic(..)\n             | ty::Param(..)\n             | ty::Foreign(..)\n-            | ty::Alias(ty::Projection, ..)\n+            | ty::Alias(ty::Projection | ty::Inherent, ..)\n             | ty::Placeholder(..) => Some(Err(NoSolution)),\n \n             ty::Infer(_) | ty::Bound(_, _) => bug!(\"unexpected type `{self_ty}`\"),"}, {"sha": "969e5fa64b0b16c147be1844c63d153cf0fcdec5", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -322,7 +322,9 @@ fn negative_impl(tcx: TyCtxt<'_>, impl1_def_id: DefId, impl2_def_id: DefId) -> b\n     let selcx = &mut SelectionContext::new(&infcx);\n     let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n     let (subject2, obligations) =\n-        impl_subject_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs);\n+        impl_subject_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs, |_, _| {\n+            ObligationCause::dummy()\n+        });\n \n     !equate(&infcx, impl_env, subject1, subject2, obligations, impl1_def_id)\n }\n@@ -673,7 +675,7 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for OrphanChecker<'tcx> {\n             | ty::RawPtr(..)\n             | ty::Never\n             | ty::Tuple(..)\n-            | ty::Alias(ty::Projection, ..) => self.found_non_local_ty(ty),\n+            | ty::Alias(ty::Projection | ty::Inherent, ..) => self.found_non_local_ty(ty),\n \n             ty::Param(..) => self.found_param_ty(ty),\n "}, {"sha": "c9e2ed092d160b0cfd10d05f01eb1e3a808dd568", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1687,13 +1687,14 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ty::Tuple(..) => Some(10),\n                 ty::Param(..) => Some(11),\n                 ty::Alias(ty::Projection, ..) => Some(12),\n-                ty::Alias(ty::Opaque, ..) => Some(13),\n-                ty::Never => Some(14),\n-                ty::Adt(..) => Some(15),\n-                ty::Generator(..) => Some(16),\n-                ty::Foreign(..) => Some(17),\n-                ty::GeneratorWitness(..) => Some(18),\n-                ty::GeneratorWitnessMIR(..) => Some(19),\n+                ty::Alias(ty::Inherent, ..) => Some(13),\n+                ty::Alias(ty::Opaque, ..) => Some(14),\n+                ty::Never => Some(15),\n+                ty::Adt(..) => Some(16),\n+                ty::Generator(..) => Some(17),\n+                ty::Foreign(..) => Some(18),\n+                ty::GeneratorWitness(..) => Some(19),\n+                ty::GeneratorWitnessMIR(..) => Some(20),\n                 ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => None,\n             }\n         }"}, {"sha": "38daca5377a8b88aff473a888b1ecee889eb6e65", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -49,12 +49,15 @@ pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::is_vtable_safe_method;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n-pub use self::project::{normalize_projection_type, NormalizeExt};\n+pub use self::project::NormalizeExt;\n+pub use self::project::{normalize_inherent_projection, normalize_projection_type};\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n-pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n+pub use self::specialize::{\n+    specialization_graph, translate_substs, translate_substs_with_cause, OverlapError,\n+};\n pub use self::structural_match::{\n     search_for_adt_const_param_violation, search_for_structural_match_violation,\n };"}, {"sha": "8e684b7ac239b38ee3697a474ba605254af8e906", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 161, "deletions": 2, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -16,6 +16,7 @@ use super::{\n };\n use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n \n+use crate::errors::InherentProjectionNormalizationOverflow;\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::traits::error_reporting::TypeErrCtxtExt as _;\n@@ -370,10 +371,14 @@ pub(crate) fn needs_normalization<'tcx, T: TypeVisitable<TyCtxt<'tcx>>>(\n     reveal: Reveal,\n ) -> bool {\n     match reveal {\n-        Reveal::UserFacing => value\n-            .has_type_flags(ty::TypeFlags::HAS_TY_PROJECTION | ty::TypeFlags::HAS_CT_PROJECTION),\n+        Reveal::UserFacing => value.has_type_flags(\n+            ty::TypeFlags::HAS_TY_PROJECTION\n+                | ty::TypeFlags::HAS_TY_INHERENT\n+                | ty::TypeFlags::HAS_CT_PROJECTION,\n+        ),\n         Reveal::All => value.has_type_flags(\n             ty::TypeFlags::HAS_TY_PROJECTION\n+                | ty::TypeFlags::HAS_TY_INHERENT\n                 | ty::TypeFlags::HAS_TY_OPAQUE\n                 | ty::TypeFlags::HAS_CT_PROJECTION,\n         ),\n@@ -616,6 +621,51 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                 );\n                 normalized_ty\n             }\n+\n+            ty::Inherent if !data.has_escaping_bound_vars() => {\n+                // This branch is *mostly* just an optimization: when we don't\n+                // have escaping bound vars, we don't need to replace them with\n+                // placeholders (see branch below). *Also*, we know that we can\n+                // register an obligation to *later* project, since we know\n+                // there won't be bound vars there.\n+\n+                let data = data.fold_with(self);\n+\n+                // FIXME(inherent_associated_types): Do we need to honor `self.eager_inference_replacement`\n+                // here like `ty::Projection`?\n+                normalize_inherent_projection(\n+                    self.selcx,\n+                    self.param_env,\n+                    data,\n+                    self.cause.clone(),\n+                    self.depth,\n+                    &mut self.obligations,\n+                )\n+            }\n+\n+            ty::Inherent => {\n+                let infcx = self.selcx.infcx;\n+                let (data, mapped_regions, mapped_types, mapped_consts) =\n+                    BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n+                let data = data.fold_with(self);\n+                let ty = normalize_inherent_projection(\n+                    self.selcx,\n+                    self.param_env,\n+                    data,\n+                    self.cause.clone(),\n+                    self.depth,\n+                    &mut self.obligations,\n+                );\n+\n+                PlaceholderReplacer::replace_placeholders(\n+                    infcx,\n+                    mapped_regions,\n+                    mapped_types,\n+                    mapped_consts,\n+                    &self.universes,\n+                    ty,\n+                )\n+            }\n         }\n     }\n \n@@ -1204,6 +1254,115 @@ fn normalize_to_error<'a, 'tcx>(\n     Normalized { value: new_value, obligations: vec![trait_obligation] }\n }\n \n+/// Confirm and normalize the given inherent projection.\n+#[instrument(level = \"debug\", skip(selcx, param_env, cause, obligations))]\n+pub fn normalize_inherent_projection<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    alias_ty: ty::AliasTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> Ty<'tcx> {\n+    let tcx = selcx.tcx();\n+\n+    if !tcx.recursion_limit().value_within_limit(depth) {\n+        // Halt compilation because it is important that overflows never be masked.\n+        tcx.sess.emit_fatal(InherentProjectionNormalizationOverflow {\n+            span: cause.span,\n+            ty: alias_ty.to_string(),\n+        });\n+    }\n+\n+    let substs = compute_inherent_assoc_ty_substs(\n+        selcx,\n+        param_env,\n+        alias_ty,\n+        cause.clone(),\n+        depth,\n+        obligations,\n+    );\n+\n+    // Register the obligations arising from the impl and from the associated type itself.\n+    let predicates = tcx.predicates_of(alias_ty.def_id).instantiate(tcx, substs);\n+    for (predicate, span) in predicates {\n+        let predicate = normalize_with_depth_to(\n+            selcx,\n+            param_env,\n+            cause.clone(),\n+            depth + 1,\n+            predicate,\n+            obligations,\n+        );\n+\n+        let nested_cause = ObligationCause::new(\n+            cause.span,\n+            cause.body_id,\n+            // FIXME(inherent_associated_types): Since we can't pass along the self type to the\n+            // cause code, inherent projections will be printed with identity substitutions in\n+            // diagnostics which is not ideal.\n+            // Consider creating separate cause codes for this specific situation.\n+            if span.is_dummy() {\n+                super::ItemObligation(alias_ty.def_id)\n+            } else {\n+                super::BindingObligation(alias_ty.def_id, span)\n+            },\n+        );\n+\n+        obligations.push(Obligation::with_depth(\n+            tcx,\n+            nested_cause,\n+            depth + 1,\n+            param_env,\n+            predicate,\n+        ));\n+    }\n+\n+    let ty = tcx.type_of(alias_ty.def_id).subst(tcx, substs);\n+\n+    let mut ty = selcx.infcx.resolve_vars_if_possible(ty);\n+    if ty.has_projections() {\n+        ty = normalize_with_depth_to(selcx, param_env, cause.clone(), depth + 1, ty, obligations);\n+    }\n+\n+    ty\n+}\n+\n+pub fn compute_inherent_assoc_ty_substs<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    alias_ty: ty::AliasTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> ty::SubstsRef<'tcx> {\n+    let tcx = selcx.tcx();\n+\n+    let impl_def_id = tcx.parent(alias_ty.def_id);\n+    let impl_substs = selcx.infcx.fresh_substs_for_item(cause.span, impl_def_id);\n+\n+    let impl_ty = tcx.type_of(impl_def_id).subst(tcx, impl_substs);\n+    let impl_ty =\n+        normalize_with_depth_to(selcx, param_env, cause.clone(), depth + 1, impl_ty, obligations);\n+\n+    // Infer the generic parameters of the impl by unifying the\n+    // impl type with the self type of the projection.\n+    let self_ty = alias_ty.self_ty();\n+    match selcx.infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, impl_ty, self_ty) {\n+        Ok(mut ok) => obligations.append(&mut ok.obligations),\n+        Err(_) => {\n+            tcx.sess.delay_span_bug(\n+                cause.span,\n+                format!(\n+                    \"{self_ty:?} was a subtype of {impl_ty:?} during selection but now it is not\"\n+                ),\n+            );\n+        }\n+    }\n+\n+    alias_ty.rebase_substs_onto_impl(impl_substs, tcx)\n+}\n+\n enum Projected<'tcx> {\n     Progress(Progress<'tcx>),\n     NoProgress(ty::Term<'tcx>),"}, {"sha": "8bf934cb78ae1545fdfaa28162541d208ab4d41e", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -257,11 +257,11 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n \n             ty::Opaque => ty.try_super_fold_with(self)?,\n \n-            ty::Projection => {\n+            ty::Projection | ty::Inherent => {\n                 // See note in `rustc_trait_selection::traits::project`\n \n-                let tcx = self.infcx.tcx;\n                 let infcx = self.infcx;\n+                let tcx = infcx.tcx;\n                 // Just an optimization: When we don't have escaping bound vars,\n                 // we don't need to replace them with placeholders.\n                 let (data, maps) = if data.has_escaping_bound_vars() {\n@@ -276,12 +276,15 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                 let mut orig_values = OriginalQueryValues::default();\n                 // HACK(matthewjasper) `'static` is special-cased in selection,\n                 // so we cannot canonicalize it.\n-                let c_data = self\n-                    .infcx\n+                let c_data = infcx\n                     .canonicalize_query_keep_static(self.param_env.and(data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n-                let result = tcx.normalize_projection_ty(c_data)?;\n+                let result = match kind {\n+                    ty::Projection => tcx.normalize_projection_ty(c_data),\n+                    ty::Inherent => tcx.normalize_inherent_projection_ty(c_data),\n+                    _ => unreachable!(),\n+                }?;\n                 // We don't expect ambiguity.\n                 if result.is_ambiguous() {\n                     // Rustdoc normalizes possibly not well-formed types, so only\n@@ -294,8 +297,8 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                     }\n                     return Err(NoSolution);\n                 }\n-                let InferOk { value: result, obligations } =\n-                    self.infcx.instantiate_query_response_and_region_obligations(\n+                let InferOk { value: result, obligations } = infcx\n+                    .instantiate_query_response_and_region_obligations(\n                         self.cause,\n                         self.param_env,\n                         &orig_values,"}, {"sha": "a8fb55df2d3029cf04a93a4fb143746e5300f9b9", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -498,7 +498,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // this trait and type.\n                 }\n                 ty::Param(..)\n-                | ty::Alias(ty::Projection, ..)\n+                | ty::Alias(ty::Projection | ty::Inherent, ..)\n                 | ty::Placeholder(..)\n                 | ty::Bound(..) => {\n                     // In these cases, we don't know what the actual"}, {"sha": "616187b69dde4bd89cbb05cd00599f585212cddc", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1268,7 +1268,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // If we have a projection type, make sure to normalize it so we replace it\n                 // with a fresh infer variable\n-                ty::Alias(ty::Projection, ..) => {\n+                ty::Alias(ty::Projection | ty::Inherent, ..) => {\n                     let predicate = normalize_with_depth_to(\n                         self,\n                         obligation.param_env,"}, {"sha": "e4f5a84f4244e1a8a02eefefd5cdd6d70106aa1f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -2315,7 +2315,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n             | ty::Dynamic(..)\n             | ty::Param(..)\n             | ty::Foreign(..)\n-            | ty::Alias(ty::Projection, ..)\n+            | ty::Alias(ty::Projection | ty::Inherent, ..)\n             | ty::Bound(..)\n             | ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble constituent types of unexpected type: {:?}\", t);"}, {"sha": "9a4b72013b88db225fefd83ef8097b7e3b28965f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -82,6 +82,30 @@ pub fn translate_substs<'tcx>(\n     source_impl: DefId,\n     source_substs: SubstsRef<'tcx>,\n     target_node: specialization_graph::Node,\n+) -> SubstsRef<'tcx> {\n+    translate_substs_with_cause(\n+        infcx,\n+        param_env,\n+        source_impl,\n+        source_substs,\n+        target_node,\n+        |_, _| ObligationCause::dummy(),\n+    )\n+}\n+\n+/// Like [translate_substs], but obligations from the parent implementation\n+/// are registered with the provided `ObligationCause`.\n+///\n+/// This is for reporting *region* errors from those bounds. Type errors should\n+/// not happen because the specialization graph already checks for those, and\n+/// will result in an ICE.\n+pub fn translate_substs_with_cause<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    source_impl: DefId,\n+    source_substs: SubstsRef<'tcx>,\n+    target_node: specialization_graph::Node,\n+    cause: impl Fn(usize, Span) -> ObligationCause<'tcx>,\n ) -> SubstsRef<'tcx> {\n     debug!(\n         \"translate_substs({:?}, {:?}, {:?}, {:?})\",\n@@ -99,14 +123,13 @@ pub fn translate_substs<'tcx>(\n                 return source_substs;\n             }\n \n-            fulfill_implication(infcx, param_env, source_trait_ref, target_impl).unwrap_or_else(\n-                |()| {\n+            fulfill_implication(infcx, param_env, source_trait_ref, source_impl, target_impl, cause)\n+                .unwrap_or_else(|()| {\n                     bug!(\n                         \"When translating substitutions from {source_impl:?} to {target_impl:?}, \\\n                         the expected specialization failed to hold\"\n                     )\n-                },\n-            )\n+                })\n         }\n         specialization_graph::Node::Trait(..) => source_trait_ref.substs,\n     };\n@@ -153,20 +176,12 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n \n     // Create an infcx, taking the predicates of impl1 as assumptions:\n     let infcx = tcx.infer_ctxt().build();\n-    let impl1_trait_ref =\n-        match traits::fully_normalize(&infcx, ObligationCause::dummy(), penv, impl1_trait_ref) {\n-            Ok(impl1_trait_ref) => impl1_trait_ref,\n-            Err(_errors) => {\n-                tcx.sess.delay_span_bug(\n-                    tcx.def_span(impl1_def_id),\n-                    format!(\"failed to fully normalize {impl1_trait_ref}\"),\n-                );\n-                impl1_trait_ref\n-            }\n-        };\n \n     // Attempt to prove that impl2 applies, given all of the above.\n-    fulfill_implication(&infcx, penv, impl1_trait_ref, impl2_def_id).is_ok()\n+    fulfill_implication(&infcx, penv, impl1_trait_ref, impl1_def_id, impl2_def_id, |_, _| {\n+        ObligationCause::dummy()\n+    })\n+    .is_ok()\n }\n \n /// Attempt to fulfill all obligations of `target_impl` after unification with\n@@ -178,23 +193,41 @@ fn fulfill_implication<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     source_trait_ref: ty::TraitRef<'tcx>,\n+    source_impl: DefId,\n     target_impl: DefId,\n+    error_cause: impl Fn(usize, Span) -> ObligationCause<'tcx>,\n ) -> Result<SubstsRef<'tcx>, ()> {\n     debug!(\n         \"fulfill_implication({:?}, trait_ref={:?} |- {:?} applies)\",\n         param_env, source_trait_ref, target_impl\n     );\n \n+    let source_trait_ref = match traits::fully_normalize(\n+        &infcx,\n+        ObligationCause::dummy(),\n+        param_env,\n+        source_trait_ref,\n+    ) {\n+        Ok(source_trait_ref) => source_trait_ref,\n+        Err(_errors) => {\n+            infcx.tcx.sess.delay_span_bug(\n+                infcx.tcx.def_span(source_impl),\n+                format!(\"failed to fully normalize {source_trait_ref}\"),\n+            );\n+            source_trait_ref\n+        }\n+    };\n+\n     let source_trait = ImplSubject::Trait(source_trait_ref);\n \n     let selcx = &mut SelectionContext::new(&infcx);\n     let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n     let (target_trait, obligations) =\n-        util::impl_subject_and_oblig(selcx, param_env, target_impl, target_substs);\n+        util::impl_subject_and_oblig(selcx, param_env, target_impl, target_substs, error_cause);\n \n     // do the impls unify? If not, no specialization.\n     let Ok(InferOk { obligations: more_obligations, .. }) =\n-        infcx.at(&ObligationCause::dummy(), param_env, ).eq(DefineOpaqueTypes::No,source_trait, target_trait)\n+        infcx.at(&ObligationCause::dummy(), param_env).eq(DefineOpaqueTypes::No, source_trait, target_trait)\n     else {\n         debug!(\n             \"fulfill_implication: {:?} does not unify with {:?}\","}, {"sha": "82f3df401988dc94a4f43f766e8aa5d63d9d7c88", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -197,6 +197,7 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     impl_def_id: DefId,\n     impl_substs: SubstsRef<'tcx>,\n+    cause: impl Fn(usize, Span) -> ObligationCause<'tcx>,\n ) -> (ImplSubject<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n     let subject = selcx.tcx().impl_subject(impl_def_id);\n     let subject = subject.subst(selcx.tcx(), impl_substs);\n@@ -208,8 +209,7 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let InferOk { value: predicates, obligations: normalization_obligations2 } =\n         selcx.infcx.at(&ObligationCause::dummy(), param_env).normalize(predicates);\n-    let impl_obligations =\n-        super::predicates_for_generics(|_, _| ObligationCause::dummy(), param_env, predicates);\n+    let impl_obligations = super::predicates_for_generics(cause, param_env, predicates);\n \n     let impl_obligations = impl_obligations\n         .chain(normalization_obligations1.into_iter())"}, {"sha": "086ab32b520076946de1e1efcd46cff83e66f8d8", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 57, "deletions": 29, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -58,15 +58,8 @@ pub fn obligations<'tcx>(\n         GenericArgKind::Lifetime(..) => return Some(Vec::new()),\n     };\n \n-    let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n-        param_env,\n-        body_id,\n-        span,\n-        out: vec![],\n-        recursion_depth,\n-        item: None,\n-    };\n+    let mut wf =\n+        WfPredicates { infcx, param_env, body_id, span, out: vec![], recursion_depth, item: None };\n     wf.compute(arg);\n     debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", arg, body_id, wf.out);\n \n@@ -91,7 +84,7 @@ pub fn unnormalized_obligations<'tcx>(\n     debug_assert_eq!(arg, infcx.resolve_vars_if_possible(arg));\n \n     let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n+        infcx,\n         param_env,\n         body_id: CRATE_DEF_ID,\n         span: DUMMY_SP,\n@@ -116,7 +109,7 @@ pub fn trait_obligations<'tcx>(\n     item: &'tcx hir::Item<'tcx>,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n+        infcx,\n         param_env,\n         body_id,\n         span,\n@@ -138,7 +131,7 @@ pub fn predicate_obligations<'tcx>(\n     span: Span,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n+        infcx,\n         param_env,\n         body_id,\n         span,\n@@ -190,8 +183,8 @@ pub fn predicate_obligations<'tcx>(\n     wf.normalize(infcx)\n }\n \n-struct WfPredicates<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct WfPredicates<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: LocalDefId,\n     span: Span,\n@@ -290,9 +283,9 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n     }\n }\n \n-impl<'tcx> WfPredicates<'tcx> {\n+impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n+        self.infcx.tcx\n     }\n \n     fn cause(&self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n@@ -325,7 +318,7 @@ impl<'tcx> WfPredicates<'tcx> {\n \n     /// Pushes the obligations required for `trait_ref` to be WF into `self.out`.\n     fn compute_trait_pred(&mut self, trait_pred: &ty::TraitPredicate<'tcx>, elaborate: Elaborate) {\n-        let tcx = self.tcx;\n+        let tcx = self.tcx();\n         let trait_ref = &trait_pred.trait_ref;\n \n         // Negative trait predicates don't require supertraits to hold, just\n@@ -369,7 +362,6 @@ impl<'tcx> WfPredicates<'tcx> {\n             self.out.extend(obligations);\n         }\n \n-        let tcx = self.tcx();\n         self.out.extend(\n             trait_ref\n                 .substs\n@@ -436,13 +428,45 @@ impl<'tcx> WfPredicates<'tcx> {\n         let obligations = self.nominal_obligations_without_const(data.def_id, data.substs);\n         self.out.extend(obligations);\n \n+        self.compute_projection_substs(data.substs);\n+    }\n+\n+    fn compute_inherent_projection(&mut self, data: ty::AliasTy<'tcx>) {\n+        // An inherent projection is well-formed if\n+        //\n+        // (a) its predicates hold (*)\n+        // (b) its substs are wf\n+        //\n+        // (*) The predicates of an inherent associated type include the\n+        //     predicates of the impl that it's contained in.\n+\n+        if !data.self_ty().has_escaping_bound_vars() {\n+            // FIXME(inherent_associated_types): Should this happen inside of a snapshot?\n+            // FIXME(inherent_associated_types): This is incompatible with the new solver and lazy norm!\n+            let substs = traits::project::compute_inherent_assoc_ty_substs(\n+                &mut traits::SelectionContext::new(self.infcx),\n+                self.param_env,\n+                data,\n+                self.cause(traits::WellFormed(None)),\n+                self.recursion_depth,\n+                &mut self.out,\n+            );\n+            // Inherent projection types do not require const predicates.\n+            let obligations = self.nominal_obligations_without_const(data.def_id, substs);\n+            self.out.extend(obligations);\n+        }\n+\n+        self.compute_projection_substs(data.substs);\n+    }\n+\n+    fn compute_projection_substs(&mut self, substs: SubstsRef<'tcx>) {\n         let tcx = self.tcx();\n         let cause = self.cause(traits::WellFormed(None));\n         let param_env = self.param_env;\n         let depth = self.recursion_depth;\n \n         self.out.extend(\n-            data.substs\n+            substs\n                 .iter()\n                 .filter(|arg| {\n                     matches!(arg.unpack(), GenericArgKind::Type(..) | GenericArgKind::Const(..))\n@@ -464,9 +488,9 @@ impl<'tcx> WfPredicates<'tcx> {\n         if !subty.has_escaping_bound_vars() {\n             let cause = self.cause(cause);\n             let trait_ref =\n-                ty::TraitRef::from_lang_item(self.tcx, LangItem::Sized, cause.span, [subty]);\n+                ty::TraitRef::from_lang_item(self.tcx(), LangItem::Sized, cause.span, [subty]);\n             self.out.push(traits::Obligation::with_depth(\n-                self.tcx,\n+                self.tcx(),\n                 cause,\n                 self.recursion_depth,\n                 self.param_env,\n@@ -605,6 +629,10 @@ impl<'tcx> WfPredicates<'tcx> {\n                     walker.skip_current_subtree(); // Subtree handled by compute_projection.\n                     self.compute_projection(data);\n                 }\n+                ty::Alias(ty::Inherent, data) => {\n+                    walker.skip_current_subtree(); // Subtree handled by compute_inherent_projection.\n+                    self.compute_inherent_projection(data);\n+                }\n \n                 ty::Adt(def, substs) => {\n                     // WfNominalType\n@@ -697,7 +725,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                     // All of the requirements on type parameters\n                     // have already been checked for `impl Trait` in\n                     // return position. We do need to check type-alias-impl-trait though.\n-                    if self.tcx.is_type_alias_impl_trait(def_id) {\n+                    if self.tcx().is_type_alias_impl_trait(def_id) {\n                         let obligations = self.nominal_obligations(def_id, substs);\n                         self.out.extend(obligations);\n                     }\n@@ -767,15 +795,15 @@ impl<'tcx> WfPredicates<'tcx> {\n         substs: SubstsRef<'tcx>,\n         remap_constness: bool,\n     ) -> Vec<traits::PredicateObligation<'tcx>> {\n-        let predicates = self.tcx.predicates_of(def_id);\n+        let predicates = self.tcx().predicates_of(def_id);\n         let mut origins = vec![def_id; predicates.predicates.len()];\n         let mut head = predicates;\n         while let Some(parent) = head.parent {\n-            head = self.tcx.predicates_of(parent);\n+            head = self.tcx().predicates_of(parent);\n             origins.extend(iter::repeat(parent).take(head.predicates.len()));\n         }\n \n-        let predicates = predicates.instantiate(self.tcx, substs);\n+        let predicates = predicates.instantiate(self.tcx(), substs);\n         trace!(\"{:#?}\", predicates);\n         debug_assert_eq!(predicates.predicates.len(), origins.len());\n \n@@ -788,10 +816,10 @@ impl<'tcx> WfPredicates<'tcx> {\n                 };\n                 let cause = self.cause(code);\n                 if remap_constness {\n-                    pred = pred.without_const(self.tcx);\n+                    pred = pred.without_const(self.tcx());\n                 }\n                 traits::Obligation::with_depth(\n-                    self.tcx,\n+                    self.tcx(),\n                     cause,\n                     self.recursion_depth,\n                     self.param_env,\n@@ -856,7 +884,7 @@ impl<'tcx> WfPredicates<'tcx> {\n         // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n         // am looking forward to the future here.\n         if !data.has_escaping_bound_vars() && !region.has_escaping_bound_vars() {\n-            let implicit_bounds = object_region_bounds(self.tcx, data);\n+            let implicit_bounds = object_region_bounds(self.tcx(), data);\n \n             let explicit_bound = region;\n \n@@ -866,7 +894,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                 let outlives =\n                     ty::Binder::dummy(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n                 self.out.push(traits::Obligation::with_depth(\n-                    self.tcx,\n+                    self.tcx(),\n                     cause,\n                     self.recursion_depth,\n                     self.param_env,"}, {"sha": "2f9e480d8bd529dc1fff1892ba61e3859bf28296", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -372,6 +372,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                     substitution: substs.lower_into(interner),\n                 }))\n             }\n+            ty::Alias(ty::Inherent, _) => unimplemented!(),\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n                 chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n                     opaque_ty_id: chalk_ir::OpaqueTyId(def_id),"}, {"sha": "36d80a06ee7e9edc13c4cf94bfa3fc8f2121f6ca", "filename": "compiler/rustc_traits/src/normalize_projection_ty.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -10,7 +10,7 @@ use rustc_trait_selection::traits::{self, ObligationCause, SelectionContext};\n use std::sync::atomic::Ordering;\n \n pub(crate) fn provide(p: &mut Providers) {\n-    *p = Providers { normalize_projection_ty, ..*p };\n+    *p = Providers { normalize_projection_ty, normalize_inherent_projection_ty, ..*p };\n }\n \n fn normalize_projection_ty<'tcx>(\n@@ -42,3 +42,30 @@ fn normalize_projection_ty<'tcx>(\n         },\n     )\n }\n+\n+fn normalize_inherent_projection_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    goal: CanonicalProjectionGoal<'tcx>,\n+) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, NormalizationResult<'tcx>>>, NoSolution> {\n+    debug!(\"normalize_provider(goal={:#?})\", goal);\n+\n+    tcx.infer_ctxt().enter_canonical_trait_query(\n+        &goal,\n+        |ocx, ParamEnvAnd { param_env, value: goal }| {\n+            let selcx = &mut SelectionContext::new(ocx.infcx);\n+            let cause = ObligationCause::dummy();\n+            let mut obligations = vec![];\n+            let answer = traits::normalize_inherent_projection(\n+                selcx,\n+                param_env,\n+                goal,\n+                cause,\n+                0,\n+                &mut obligations,\n+            );\n+            ocx.register_obligations(obligations);\n+\n+            Ok(NormalizationResult { normalized_ty: answer })\n+        },\n+    )\n+}"}, {"sha": "9029ba2a51aa1f1ff67239c5e28105065c02e6bf", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -334,7 +334,7 @@ fn associated_type_for_impl_trait_in_trait(\n             parent_count,\n             params,\n             param_def_id_to_index,\n-            has_self: false,\n+            has_self: opaque_ty_generics.has_self,\n             has_late_bound_regions: opaque_ty_generics.has_late_bound_regions,\n         }\n     });"}, {"sha": "eb3c21163ab2aef6ac4434429ee8c8b80ad34f6c", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -27,8 +27,7 @@ fn resolve_instance<'tcx>(\n         )\n     } else {\n         let ty = tcx.type_of(def);\n-        let item_type =\n-            tcx.subst_and_normalize_erasing_regions(substs, param_env, ty.skip_binder());\n+        let item_type = tcx.subst_and_normalize_erasing_regions(substs, param_env, ty);\n \n         let def = match *item_type.kind() {\n             ty::FnDef(def_id, ..) if tcx.is_intrinsic(def_id) => {\n@@ -195,21 +194,18 @@ fn resolve_associated_item<'tcx>(\n             })\n         }\n         traits::ImplSource::Future(future_data) => {\n-            if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::poll {\n-                // For compiler developers who'd like to add new items to `Future`,\n-                // you either need to generate a shim body, or perhaps return\n-                // `InstanceDef::Item` pointing to a trait default method body if\n-                // it is given a default implementation by the trait.\n-                span_bug!(\n-                    tcx.def_span(future_data.generator_def_id),\n-                    \"no definition for `{trait_ref}::{}` for built-in async generator type\",\n-                    tcx.item_name(trait_item_id)\n-                )\n+            if Some(trait_item_id) == tcx.lang_items().future_poll_fn() {\n+                // `Future::poll` is generated by the compiler.\n+                Some(Instance {\n+                    def: ty::InstanceDef::Item(future_data.generator_def_id),\n+                    substs: future_data.substs,\n+                })\n+            } else {\n+                // All other methods are default methods of the `Future` trait.\n+                // (this assumes that `ImplSource::Future` is only used for methods on `Future`)\n+                debug_assert!(tcx.impl_defaultness(trait_item_id).has_value());\n+                Some(Instance::new(trait_item_id, rcvr_substs))\n             }\n-            Some(Instance {\n-                def: ty::InstanceDef::Item(future_data.generator_def_id),\n-                substs: future_data.substs,\n-            })\n         }\n         traits::ImplSource::Closure(closure_data) => {\n             if cfg!(debug_assertions)"}, {"sha": "7e5a4d1c735324cccdabcd7ad5c4012820e90b72", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -229,50 +229,53 @@ bitflags! {\n \n         /// Does this have `Projection`?\n         const HAS_TY_PROJECTION           = 1 << 10;\n+        /// Does this have `Inherent`?\n+        const HAS_TY_INHERENT             = 1 << 11;\n         /// Does this have `Opaque`?\n-        const HAS_TY_OPAQUE               = 1 << 11;\n+        const HAS_TY_OPAQUE               = 1 << 12;\n         /// Does this have `ConstKind::Unevaluated`?\n-        const HAS_CT_PROJECTION           = 1 << 12;\n+        const HAS_CT_PROJECTION           = 1 << 13;\n \n         /// Could this type be normalized further?\n         const HAS_PROJECTION              = TypeFlags::HAS_TY_PROJECTION.bits\n                                           | TypeFlags::HAS_TY_OPAQUE.bits\n+                                          | TypeFlags::HAS_TY_INHERENT.bits\n                                           | TypeFlags::HAS_CT_PROJECTION.bits;\n \n         /// Is an error type/const reachable?\n-        const HAS_ERROR                   = 1 << 13;\n+        const HAS_ERROR                   = 1 << 14;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but `ReLateBound` and `ReErased`.\n-        const HAS_FREE_REGIONS            = 1 << 14;\n+        const HAS_FREE_REGIONS            = 1 << 15;\n \n         /// Does this have any `ReLateBound` regions?\n-        const HAS_RE_LATE_BOUND           = 1 << 15;\n+        const HAS_RE_LATE_BOUND           = 1 << 16;\n         /// Does this have any `Bound` types?\n-        const HAS_TY_LATE_BOUND           = 1 << 16;\n+        const HAS_TY_LATE_BOUND           = 1 << 17;\n         /// Does this have any `ConstKind::Bound` consts?\n-        const HAS_CT_LATE_BOUND           = 1 << 17;\n+        const HAS_CT_LATE_BOUND           = 1 << 18;\n         /// Does this have any bound variables?\n         /// Used to check if a global bound is safe to evaluate.\n         const HAS_LATE_BOUND              = TypeFlags::HAS_RE_LATE_BOUND.bits\n                                           | TypeFlags::HAS_TY_LATE_BOUND.bits\n                                           | TypeFlags::HAS_CT_LATE_BOUND.bits;\n \n         /// Does this have any `ReErased` regions?\n-        const HAS_RE_ERASED               = 1 << 18;\n+        const HAS_RE_ERASED               = 1 << 19;\n \n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n-        const STILL_FURTHER_SPECIALIZABLE = 1 << 19;\n+        const STILL_FURTHER_SPECIALIZABLE = 1 << 20;\n \n         /// Does this value have `InferTy::FreshTy/FreshIntTy/FreshFloatTy`?\n-        const HAS_TY_FRESH                = 1 << 20;\n+        const HAS_TY_FRESH                = 1 << 21;\n \n         /// Does this value have `InferConst::Fresh`?\n-        const HAS_CT_FRESH                = 1 << 21;\n+        const HAS_CT_FRESH                = 1 << 22;\n \n         /// Does this have `Generator` or `GeneratorWitness`?\n-        const HAS_TY_GENERATOR            = 1 << 22;\n+        const HAS_TY_GENERATOR            = 1 << 23;\n     }\n }\n "}, {"sha": "f7344bacc028cfabde19ed343575dc54a9020616", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -37,6 +37,7 @@ pub enum DynKind {\n #[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum AliasKind {\n     Projection,\n+    Inherent,\n     Opaque,\n }\n "}, {"sha": "d0eaa9fd7ffac3dd33bdc810e37abba949d829a1", "filename": "config.example.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/config.example.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/config.example.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.example.toml?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -750,6 +750,10 @@ changelog-seen = 2\n # This option will override the same option under [build] section.\n #profiler = build.profiler (bool)\n \n+# This option supports enable `rpath` in each target independently, \n+# and will override the same option under [rust] section. It only works on Unix platforms\n+#rpath = rust.rpath (bool)\n+\n # Force static or dynamic linkage of the standard library for this target. If\n # this target is a host for rustc, this will also affect the linkage of the\n # compiler itself. This is useful for building rustc on targets that normally"}, {"sha": "84331eba2d49dc08a92b1effd363a810d88383ac", "filename": "library/alloc/src/borrow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fborrow.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -115,7 +115,7 @@ where\n /// ```\n /// use std::borrow::Cow;\n ///\n-/// fn abs_all(input: &mut Cow<[i32]>) {\n+/// fn abs_all(input: &mut Cow<'_, [i32]>) {\n ///     for i in 0..input.len() {\n ///         let v = input[i];\n ///         if v < 0 {\n@@ -145,7 +145,7 @@ where\n /// ```\n /// use std::borrow::Cow;\n ///\n-/// struct Items<'a, X: 'a> where [X]: ToOwned<Owned = Vec<X>> {\n+/// struct Items<'a, X> where [X]: ToOwned<Owned = Vec<X>> {\n ///     values: Cow<'a, [X]>,\n /// }\n ///\n@@ -267,7 +267,7 @@ impl<B: ?Sized + ToOwned> Cow<'_, B> {\n     ///\n     /// assert_eq!(\n     ///   cow,\n-    ///   Cow::Owned(String::from(\"FOO\")) as Cow<str>\n+    ///   Cow::Owned(String::from(\"FOO\")) as Cow<'_, str>\n     /// );\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -311,7 +311,7 @@ impl<B: ?Sized + ToOwned> Cow<'_, B> {\n     /// use std::borrow::Cow;\n     ///\n     /// let s = \"Hello world!\";\n-    /// let cow: Cow<str> = Cow::Owned(String::from(s));\n+    /// let cow: Cow<'_, str> = Cow::Owned(String::from(s));\n     ///\n     /// assert_eq!(\n     ///   cow.into_owned(),"}, {"sha": "fb8d00e8d8730d7a34df042c955cc6708a559672", "filename": "library/alloc/src/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ffmt.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -363,7 +363,7 @@\n //! # use std::fmt;\n //! # struct Foo; // our custom type\n //! # impl fmt::Display for Foo {\n-//! fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+//! fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n //! # write!(f, \"testing, testing\")\n //! # } }\n //! ```\n@@ -399,7 +399,7 @@\n //! }\n //!\n //! impl fmt::Display for Vector2D {\n-//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+//!     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n //!         // The `f` value implements the `Write` trait, which is what the\n //!         // write! macro is expecting. Note that this formatting ignores the\n //!         // various flags provided to format strings.\n@@ -410,7 +410,7 @@\n //! // Different traits allow different forms of output of a type. The meaning\n //! // of this format is to print the magnitude of a vector.\n //! impl fmt::Binary for Vector2D {\n-//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+//!     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n //!         let magnitude = (self.x * self.x + self.y * self.y) as f64;\n //!         let magnitude = magnitude.sqrt();\n //!\n@@ -517,7 +517,7 @@\n //! let mut some_writer = io::stdout();\n //! write!(&mut some_writer, \"{}\", format_args!(\"print with a {}\", \"macro\"));\n //!\n-//! fn my_fmt_fn(args: fmt::Arguments) {\n+//! fn my_fmt_fn(args: fmt::Arguments<'_>) {\n //!     write!(&mut io::stdout(), \"{args}\");\n //! }\n //! my_fmt_fn(format_args!(\", or a {} too\", \"function\"));"}, {"sha": "59fa91c1066dc4ef4f225e5eca569848dd335941", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -113,7 +113,6 @@\n #![feature(const_maybe_uninit_write)]\n #![feature(const_maybe_uninit_zeroed)]\n #![feature(const_pin)]\n-#![feature(const_ptr_read)]\n #![feature(const_refs_to_cell)]\n #![feature(const_size_of_val)]\n #![feature(const_waker)]"}, {"sha": "38a711ac7509f721ebce446519cece257862d998", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -2039,7 +2039,7 @@ where\n     /// ```rust\n     /// # use std::rc::Rc;\n     /// # use std::borrow::Cow;\n-    /// let cow: Cow<str> = Cow::Borrowed(\"eggplant\");\n+    /// let cow: Cow<'_, str> = Cow::Borrowed(\"eggplant\");\n     /// let shared: Rc<str> = Rc::from(cow);\n     /// assert_eq!(\"eggplant\", &shared[..]);\n     /// ```"}, {"sha": "088139a6907b8bf44482de608901e93b78e9d04d", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -2741,7 +2741,7 @@ impl<'a> From<Cow<'a, str>> for String {\n     /// ```\n     /// # use std::borrow::Cow;\n     /// // If the string is not owned...\n-    /// let cow: Cow<str> = Cow::Borrowed(\"eggplant\");\n+    /// let cow: Cow<'_, str> = Cow::Borrowed(\"eggplant\");\n     /// // It will allocate on the heap and copy the string.\n     /// let owned: String = String::from(cow);\n     /// assert_eq!(&owned[..], \"eggplant\");"}, {"sha": "7347980abbc99110cfbc4e56aa917987d98d15b9", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -2768,7 +2768,7 @@ where\n     /// ```rust\n     /// # use std::sync::Arc;\n     /// # use std::borrow::Cow;\n-    /// let cow: Cow<str> = Cow::Borrowed(\"eggplant\");\n+    /// let cow: Cow<'_, str> = Cow::Borrowed(\"eggplant\");\n     /// let shared: Arc<str> = Arc::from(cow);\n     /// assert_eq!(\"eggplant\", &shared[..]);\n     /// ```"}, {"sha": "f0b63759ac70f8701beebd52f87858e0ed45d90a", "filename": "library/alloc/src/vec/drain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -16,7 +16,7 @@ use super::Vec;\n ///\n /// ```\n /// let mut v = vec![0, 1, 2];\n-/// let iter: std::vec::Drain<_> = v.drain(..);\n+/// let iter: std::vec::Drain<'_, _> = v.drain(..);\n /// ```\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<"}, {"sha": "21b0902346206aaef0dccefc37f4d8dfdc4a1298", "filename": "library/alloc/src/vec/drain_filter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -16,7 +16,7 @@ use super::Vec;\n /// #![feature(drain_filter)]\n ///\n /// let mut v = vec![0, 1, 2];\n-/// let iter: std::vec::DrainFilter<_, _> = v.drain_filter(|x| *x % 2 == 0);\n+/// let iter: std::vec::DrainFilter<'_, _, _> = v.drain_filter(|x| *x % 2 == 0);\n /// ```\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n #[derive(Debug)]"}, {"sha": "97da6f06b700fae1482c9abd002d2d40ce503abd", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -3142,8 +3142,8 @@ where\n     ///\n     /// ```\n     /// # use std::borrow::Cow;\n-    /// let o: Cow<[i32]> = Cow::Owned(vec![1, 2, 3]);\n-    /// let b: Cow<[i32]> = Cow::Borrowed(&[1, 2, 3]);\n+    /// let o: Cow<'_, [i32]> = Cow::Owned(vec![1, 2, 3]);\n+    /// let b: Cow<'_, [i32]> = Cow::Borrowed(&[1, 2, 3]);\n     /// assert_eq!(Vec::from(o), Vec::from(b));\n     /// ```\n     fn from(s: Cow<'a, [T]>) -> Vec<T> {"}, {"sha": "852fdcc3f5ce7b685e7370996283ab0d794b9c5e", "filename": "library/alloc/src/vec/splice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -14,7 +14,7 @@ use super::{Drain, Vec};\n /// ```\n /// let mut v = vec![0, 1, 2];\n /// let new = [7, 8];\n-/// let iter: std::vec::Splice<_> = v.splice(1.., new);\n+/// let iter: std::vec::Splice<'_, _> = v.splice(1.., new);\n /// ```\n #[derive(Debug)]\n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]"}, {"sha": "4245978ca8169c40c088ff733825e4527f7b914c", "filename": "library/backtrace", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fbacktrace?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1 +1 @@\n-Subproject commit 8ad84ca5ad88ade697637387e7cb4d7c3cf4bde8\n+Subproject commit 4245978ca8169c40c088ff733825e4527f7b914c"}, {"sha": "a96dfafd9c48948360f8b44f25f4dccf14dfbe10", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -115,7 +115,7 @@\n //!     let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));\n //!     // Create a new block to limit the scope of the dynamic borrow\n //!     {\n-//!         let mut map: RefMut<_> = shared_map.borrow_mut();\n+//!         let mut map: RefMut<'_, _> = shared_map.borrow_mut();\n //!         map.insert(\"africa\", 92388);\n //!         map.insert(\"kyoto\", 11837);\n //!         map.insert(\"piccadilly\", 11826);\n@@ -1435,8 +1435,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// use std::cell::{RefCell, Ref};\n     ///\n     /// let c = RefCell::new((5, 'b'));\n-    /// let b1: Ref<(u32, char)> = c.borrow();\n-    /// let b2: Ref<u32> = Ref::map(b1, |t| &t.0);\n+    /// let b1: Ref<'_, (u32, char)> = c.borrow();\n+    /// let b2: Ref<'_, u32> = Ref::map(b1, |t| &t.0);\n     /// assert_eq!(*b2, 5)\n     /// ```\n     #[stable(feature = \"cell_map\", since = \"1.8.0\")]\n@@ -1464,8 +1464,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// use std::cell::{RefCell, Ref};\n     ///\n     /// let c = RefCell::new(vec![1, 2, 3]);\n-    /// let b1: Ref<Vec<u32>> = c.borrow();\n-    /// let b2: Result<Ref<u32>, _> = Ref::filter_map(b1, |v| v.get(1));\n+    /// let b1: Ref<'_, Vec<u32>> = c.borrow();\n+    /// let b2: Result<Ref<'_, u32>, _> = Ref::filter_map(b1, |v| v.get(1));\n     /// assert_eq!(*b2.unwrap(), 2);\n     /// ```\n     #[stable(feature = \"cell_filter_map\", since = \"1.63.0\")]\n@@ -1577,8 +1577,8 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     ///\n     /// let c = RefCell::new((5, 'b'));\n     /// {\n-    ///     let b1: RefMut<(u32, char)> = c.borrow_mut();\n-    ///     let mut b2: RefMut<u32> = RefMut::map(b1, |t| &mut t.0);\n+    ///     let b1: RefMut<'_, (u32, char)> = c.borrow_mut();\n+    ///     let mut b2: RefMut<'_, u32> = RefMut::map(b1, |t| &mut t.0);\n     ///     assert_eq!(*b2, 5);\n     ///     *b2 = 42;\n     /// }\n@@ -1612,8 +1612,8 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     /// let c = RefCell::new(vec![1, 2, 3]);\n     ///\n     /// {\n-    ///     let b1: RefMut<Vec<u32>> = c.borrow_mut();\n-    ///     let mut b2: Result<RefMut<u32>, _> = RefMut::filter_map(b1, |v| v.get_mut(1));\n+    ///     let b1: RefMut<'_, Vec<u32>> = c.borrow_mut();\n+    ///     let mut b2: Result<RefMut<'_, u32>, _> = RefMut::filter_map(b1, |v| v.get_mut(1));\n     ///\n     ///     if let Ok(mut b2) = b2 {\n     ///         *b2 += 2;"}, {"sha": "faf48ae570fdd9ddd180f68216f5b39f14ef778a", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1412,6 +1412,7 @@ mod impls {\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n     impl PartialEq for ! {\n+        #[inline]\n         fn eq(&self, _: &!) -> bool {\n             *self\n         }\n@@ -1422,13 +1423,15 @@ mod impls {\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n     impl PartialOrd for ! {\n+        #[inline]\n         fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n             *self\n         }\n     }\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n     impl Ord for ! {\n+        #[inline]\n         fn cmp(&self, _: &!) -> Ordering {\n             *self\n         }"}, {"sha": "38a6d1ccdb552d9bc7546fb6777670e16fb7ec91", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -915,6 +915,7 @@ impl Ord for Infallible {\n \n #[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n impl From<!> for Infallible {\n+    #[inline]\n     fn from(x: !) -> Self {\n         x\n     }"}, {"sha": "36f49d51ca6d3ec690697daa5c2496f9cc5c892b", "filename": "library/core/src/fmt/builders.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fbuilders.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -60,7 +60,7 @@ impl fmt::Write for PadAdapter<'_, '_> {\n /// }\n ///\n /// impl fmt::Debug for Foo {\n-///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         fmt.debug_struct(\"Foo\")\n ///            .field(\"bar\", &self.bar)\n ///            .field(\"baz\", &self.baz)\n@@ -249,7 +249,7 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n /// struct Foo(i32, String);\n ///\n /// impl fmt::Debug for Foo {\n-///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         fmt.debug_tuple(\"Foo\")\n ///            .field(&self.0)\n ///            .field(&self.1)\n@@ -418,7 +418,7 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n /// struct Foo(Vec<i32>);\n ///\n /// impl fmt::Debug for Foo {\n-///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         fmt.debug_set().entries(self.0.iter()).finish()\n ///     }\n /// }\n@@ -548,7 +548,7 @@ impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n /// struct Foo(Vec<i32>);\n ///\n /// impl fmt::Debug for Foo {\n-///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         fmt.debug_list().entries(self.0.iter()).finish()\n ///     }\n /// }\n@@ -678,7 +678,7 @@ impl<'a, 'b: 'a> DebugList<'a, 'b> {\n /// struct Foo(Vec<(String, i32)>);\n ///\n /// impl fmt::Debug for Foo {\n-///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n ///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref v)| (k, v))).finish()\n ///     }\n /// }"}, {"sha": "bac2f31878b0a42cc332667aa04f0441bf069ce4", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -381,7 +381,7 @@ impl<'a> Arguments<'a> {\n     ///\n     /// fn write_str(_: &str) { /* ... */ }\n     ///\n-    /// fn write_fmt(args: &Arguments) {\n+    /// fn write_fmt(args: &Arguments<'_>) {\n     ///     if let Some(s) = args.as_str() {\n     ///         write_str(s)\n     ///     } else {\n@@ -1228,7 +1228,7 @@ impl<'a> Formatter<'a> {\n     /// }\n     ///\n     /// impl fmt::Display for Foo {\n-    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         // We need to remove \"-\" from the number output.\n     ///         let tmp = self.nb.abs().to_string();\n     ///\n@@ -1328,7 +1328,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo;\n     ///\n     /// impl fmt::Display for Foo {\n-    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         formatter.pad(\"Foo\")\n     ///     }\n     /// }\n@@ -1510,7 +1510,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo;\n     ///\n     /// impl fmt::Display for Foo {\n-    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         formatter.write_str(\"Foo\")\n     ///         // This is equivalent to:\n     ///         // write!(formatter, \"Foo\")\n@@ -1535,7 +1535,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo(i32);\n     ///\n     /// impl fmt::Display for Foo {\n-    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         formatter.write_fmt(format_args!(\"Foo {}\", self.0))\n     ///     }\n     /// }\n@@ -1570,7 +1570,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo;\n     ///\n     /// impl fmt::Display for Foo {\n-    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         let c = formatter.fill();\n     ///         if let Some(width) = formatter.width() {\n     ///             for _ in 0..width {\n@@ -1598,14 +1598,12 @@ impl<'a> Formatter<'a> {\n     /// # Examples\n     ///\n     /// ```\n-    /// extern crate core;\n-    ///\n     /// use std::fmt::{self, Alignment};\n     ///\n     /// struct Foo;\n     ///\n     /// impl fmt::Display for Foo {\n-    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         let s = if let Some(s) = formatter.align() {\n     ///             match s {\n     ///                 Alignment::Left    => \"left\",\n@@ -1645,7 +1643,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo(i32);\n     ///\n     /// impl fmt::Display for Foo {\n-    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         if let Some(width) = formatter.width() {\n     ///             // If we received a width, we use it\n     ///             write!(formatter, \"{:width$}\", format!(\"Foo({})\", self.0), width = width)\n@@ -1676,7 +1674,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo(f32);\n     ///\n     /// impl fmt::Display for Foo {\n-    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         if let Some(precision) = formatter.precision() {\n     ///             // If we received a precision, we use it.\n     ///             write!(formatter, \"Foo({1:.*})\", precision, self.0)\n@@ -1706,7 +1704,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo(i32);\n     ///\n     /// impl fmt::Display for Foo {\n-    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         if formatter.sign_plus() {\n     ///             write!(formatter,\n     ///                    \"Foo({}{})\",\n@@ -1738,7 +1736,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo(i32);\n     ///\n     /// impl fmt::Display for Foo {\n-    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         if formatter.sign_minus() {\n     ///             // You want a minus sign? Have one!\n     ///             write!(formatter, \"-Foo({})\", self.0)\n@@ -1767,7 +1765,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo(i32);\n     ///\n     /// impl fmt::Display for Foo {\n-    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         if formatter.alternate() {\n     ///             write!(formatter, \"Foo({})\", self.0)\n     ///         } else {\n@@ -1795,7 +1793,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo(i32);\n     ///\n     /// impl fmt::Display for Foo {\n-    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         assert!(formatter.sign_aware_zero_pad());\n     ///         assert_eq!(formatter.width(), Some(4));\n     ///         // We ignore the formatter's options.\n@@ -1839,7 +1837,7 @@ impl<'a> Formatter<'a> {\n     /// }\n     ///\n     /// impl fmt::Debug for Foo {\n-    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         fmt.debug_struct(\"Foo\")\n     ///             .field(\"bar\", &self.bar)\n     ///             .field(\"baz\", &self.baz)\n@@ -1997,7 +1995,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo<T>(i32, String, PhantomData<T>);\n     ///\n     /// impl<T> fmt::Debug for Foo<T> {\n-    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         fmt.debug_tuple(\"Foo\")\n     ///             .field(&self.0)\n     ///             .field(&self.1)\n@@ -2129,7 +2127,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo(Vec<i32>);\n     ///\n     /// impl fmt::Debug for Foo {\n-    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         fmt.debug_list().entries(self.0.iter()).finish()\n     ///     }\n     /// }\n@@ -2152,7 +2150,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo(Vec<i32>);\n     ///\n     /// impl fmt::Debug for Foo {\n-    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         fmt.debug_set().entries(self.0.iter()).finish()\n     ///     }\n     /// }\n@@ -2168,14 +2166,14 @@ impl<'a> Formatter<'a> {\n     /// ```rust\n     /// use std::fmt;\n     ///\n-    /// struct Arm<'a, L: 'a, R: 'a>(&'a (L, R));\n-    /// struct Table<'a, K: 'a, V: 'a>(&'a [(K, V)], V);\n+    /// struct Arm<'a, L, R>(&'a (L, R));\n+    /// struct Table<'a, K, V>(&'a [(K, V)], V);\n     ///\n     /// impl<'a, L, R> fmt::Debug for Arm<'a, L, R>\n     /// where\n     ///     L: 'a + fmt::Debug, R: 'a + fmt::Debug\n     /// {\n-    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         L::fmt(&(self.0).0, fmt)?;\n     ///         fmt.write_str(\" => \")?;\n     ///         R::fmt(&(self.0).1, fmt)\n@@ -2186,7 +2184,7 @@ impl<'a> Formatter<'a> {\n     /// where\n     ///     K: 'a + fmt::Debug, V: 'a + fmt::Debug\n     /// {\n-    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         fmt.debug_set()\n     ///         .entries(self.0.iter().map(Arm))\n     ///         .entry(&Arm(&(format_args!(\"_\"), &self.1)))\n@@ -2210,7 +2208,7 @@ impl<'a> Formatter<'a> {\n     /// struct Foo(Vec<(String, i32)>);\n     ///\n     /// impl fmt::Debug for Foo {\n-    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n     ///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref v)| (k, v))).finish()\n     ///     }\n     /// }\n@@ -2269,13 +2267,15 @@ fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperEx\n \n #[unstable(feature = \"never_type\", issue = \"35121\")]\n impl Debug for ! {\n+    #[inline]\n     fn fmt(&self, _: &mut Formatter<'_>) -> Result {\n         *self\n     }\n }\n \n #[unstable(feature = \"never_type\", issue = \"35121\")]\n impl Display for ! {\n+    #[inline]\n     fn fmt(&self, _: &mut Formatter<'_>) -> Result {\n         *self\n     }"}, {"sha": "d37888c27bde3644d087812acc285722e2186835", "filename": "library/core/src/fmt/rt.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Frt.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -152,6 +152,21 @@ impl<'a> Argument<'a> {\n             None\n         }\n     }\n+\n+    /// Used by `format_args` when all arguments are gone after inlining,\n+    /// when using `&[]` would incorrectly allow for a bigger lifetime.\n+    ///\n+    /// This fails without format argument inlining, and that shouldn't be different\n+    /// when the argument is inlined:\n+    ///\n+    /// ```compile_fail,E0716\n+    /// let f = format_args!(\"{}\", \"a\");\n+    /// println!(\"{f}\");\n+    /// ```\n+    #[inline(always)]\n+    pub fn none() -> [Self; 0] {\n+        []\n+    }\n }\n \n /// This struct represents the unsafety of constructing an `Arguments`."}, {"sha": "089493d3766de182ada97e0f49aa7b469ffb75f3", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -66,10 +66,3 @@ pub unsafe fn get_context<'a, 'b>(cx: ResumeTy) -> &'a mut Context<'b> {\n     // that fulfills all the requirements for a mutable reference.\n     unsafe { &mut *cx.0.as_ptr().cast() }\n }\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"gen_future\", issue = \"50547\")]\n-#[inline]\n-pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n-    f\n-}"}, {"sha": "9c02029f93513ba8f7791a4fe0d43461522ded19", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -2260,7 +2260,7 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic can *only* be called where the pointer is a local without\n     /// projections (`read_via_copy(ptr)`, not `read_via_copy(*ptr)`) so that it\n     /// trivially obeys runtime-MIR rules about derefs in operands.\n-    #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n     #[rustc_nounwind]\n     pub fn read_via_copy<T>(ptr: *const T) -> T;\n \n@@ -2523,6 +2523,7 @@ macro_rules! assert_unsafe_precondition {\n                 }\n             }\n             #[allow(non_snake_case)]\n+            #[inline]\n             const fn comptime$(<$($tt)*>)?($(_:$ty),*) {}\n \n             ::core::intrinsics::const_eval_select(($($i,)*), comptime, runtime);"}, {"sha": "19f8b944c1f6f7c4a314306ee89bfffaa768e3ab", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -15,7 +15,6 @@\n //! ```rust\n //! #![feature(core_intrinsics, custom_mir)]\n //!\n-//! extern crate core;\n //! use core::intrinsics::mir::*;\n //!\n //! #[custom_mir(dialect = \"built\")]\n@@ -65,7 +64,6 @@\n //! ```rust\n //! #![feature(core_intrinsics, custom_mir)]\n //!\n-//! extern crate core;\n //! use core::intrinsics::mir::*;\n //!\n //! #[custom_mir(dialect = \"built\")]\n@@ -265,6 +263,7 @@ pub struct BasicBlock;\n macro_rules! define {\n     ($name:literal, $( #[ $meta:meta ] )* fn $($sig:tt)*) => {\n         #[rustc_diagnostic_item = $name]\n+        #[inline]\n         $( #[ $meta ] )*\n         pub fn $($sig)* { panic!() }\n     }\n@@ -317,7 +316,6 @@ define!(\n     /// ```rust\n     /// #![feature(custom_mir, core_intrinsics)]\n     ///\n-    /// extern crate core;\n     /// use core::intrinsics::mir::*;\n     ///\n     /// #[custom_mir(dialect = \"built\")]"}, {"sha": "26aa959e6da3f0ba80ffdb161af59c006d54d83c", "filename": "library/core/src/iter/adapters/chain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -15,7 +15,7 @@ use crate::ops::Try;\n ///\n /// let a1 = [1, 2, 3];\n /// let a2 = [4, 5, 6];\n-/// let iter: Chain<Iter<_>, Iter<_>> = a1.iter().chain(a2.iter());\n+/// let iter: Chain<Iter<'_, _>, Iter<'_, _>> = a1.iter().chain(a2.iter());\n /// ```\n #[derive(Clone, Debug)]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]"}, {"sha": "520ec9abcf0dcbb675756adedc40043535c8e91d", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -310,7 +310,6 @@ where\n /// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n /// this type.\n #[derive(Clone, Debug)]\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n struct FlattenCompat<I, U> {\n     iter: Fuse<I>,\n     frontiter: Option<U>,\n@@ -464,7 +463,6 @@ where\n     }\n }\n \n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n impl<I, U> Iterator for FlattenCompat<I, U>\n where\n     I: Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n@@ -579,7 +577,6 @@ where\n     }\n }\n \n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n where\n     I: DoubleEndedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n@@ -649,23 +646,20 @@ where\n     }\n }\n \n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<const N: usize, I, T> TrustedLen\n     for FlattenCompat<I, <[T; N] as IntoIterator>::IntoIter>\n where\n     I: TrustedLen<Item = [T; N]>,\n {\n }\n \n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, const N: usize, I, T> TrustedLen\n     for FlattenCompat<I, <&'a [T; N] as IntoIterator>::IntoIter>\n where\n     I: TrustedLen<Item = &'a [T; N]>,\n {\n }\n \n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, const N: usize, I, T> TrustedLen\n     for FlattenCompat<I, <&'a mut [T; N] as IntoIterator>::IntoIter>\n where"}, {"sha": "26c51e840352212456a04d57a0e13d1253b24499", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -140,7 +140,6 @@\n #![feature(const_pointer_is_aligned)]\n #![feature(const_ptr_as_ref)]\n #![feature(const_ptr_is_null)]\n-#![feature(const_ptr_read)]\n #![feature(const_ptr_sub_ptr)]\n #![feature(const_ptr_write)]\n #![feature(const_raw_ptr_comparison)]"}, {"sha": "b24882ddb179f12ecef4887faafa4b0a2a1a87cd", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -498,7 +498,6 @@ macro_rules! r#try {\n /// In a `no_std` setup you are responsible for the implementation details of the components.\n ///\n /// ```no_run\n-/// # extern crate core;\n /// use core::fmt::Write;\n ///\n /// struct Example;"}, {"sha": "97f9d01e0168c42d7427f30f7693dd71a16423c0", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -688,7 +688,7 @@ impl<T: ?Sized> !Sync for *mut T {}\n /// use std::marker::PhantomData;\n ///\n /// # #[allow(dead_code)]\n-/// struct Slice<'a, T: 'a> {\n+/// struct Slice<'a, T> {\n ///     start: *const T,\n ///     end: *const T,\n ///     phantom: PhantomData<&'a T>,\n@@ -704,7 +704,7 @@ impl<T: ?Sized> !Sync for *mut T {}\n /// ```\n /// # #![allow(dead_code)]\n /// # use std::marker::PhantomData;\n-/// # struct Slice<'a, T: 'a> {\n+/// # struct Slice<'a, T> {\n /// #     start: *const T,\n /// #     end: *const T,\n /// #     phantom: PhantomData<&'a T>,"}, {"sha": "4913a6de918286ae24820d42c2df0eaaa4cb66b0", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1315,9 +1315,9 @@ impl<T> SizedTypeProperties for T {}\n ///\n /// assert_eq!(mem::offset_of!(NestedA, b.0), 0);\n /// ```\n-#[unstable(feature = \"offset_of\", issue = \"106655\")]\n-#[rustc_builtin_macro]\n #[cfg(not(bootstrap))]\n+#[unstable(feature = \"offset_of\", issue = \"106655\")]\n+#[allow_internal_unstable(builtin_syntax)]\n pub macro offset_of($Container:ty, $($fields:tt).+ $(,)?) {\n-    /* compiler built-in */\n+    builtin # offset_of($Container, $($fields).+)\n }"}, {"sha": "14e99578a7c7d1b2e5557e6543c27a9315f7c0e6", "filename": "library/core/src/num/error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -34,6 +34,7 @@ impl From<Infallible> for TryFromIntError {\n \n #[unstable(feature = \"never_type\", issue = \"35121\")]\n impl From<!> for TryFromIntError {\n+    #[inline]\n     fn from(never: !) -> TryFromIntError {\n         // Match rather than coerce to make sure that code like\n         // `From<Infallible> for TryFromIntError` above will keep working"}, {"sha": "840c8cd2fe8d07a50894a5753f4bbe0a44725c4a", "filename": "library/core/src/ops/arith.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Farith.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -517,7 +517,7 @@ div_impl_float! { f32 f64 }\n /// use std::ops::Rem;\n ///\n /// #[derive(PartialEq, Debug)]\n-/// struct SplitSlice<'a, T: 'a> {\n+/// struct SplitSlice<'a, T> {\n ///     slice: &'a [T],\n /// }\n ///"}, {"sha": "8266e899011cb99f878b29c9a3276a7488a8aefb", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -550,6 +550,7 @@ impl Copy for () {\n ///\n /// ```\n /// # #![feature(rustc_private)]\n+/// #[allow(unused_extern_crates)]\n /// extern crate libc;\n ///\n /// use std::mem;"}, {"sha": "5ee1b5e4afc785c713c72ca229de7bcadd0dbec5", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1195,7 +1195,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// [`ptr::read`]: crate::ptr::read()\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n     #[inline]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn read(self) -> T\n@@ -1236,7 +1236,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// [`ptr::read_unaligned`]: crate::ptr::read_unaligned()\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n     #[inline]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn read_unaligned(self) -> T"}, {"sha": "ecbf4e66fa4897847e438d9efe1ece01d56d4a87", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1133,7 +1133,8 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n /// [valid]: self#safety\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+#[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[rustc_allow_const_fn_unstable(const_mut_refs, const_maybe_uninit_as_mut_ptr)]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn read<T>(src: *const T) -> T {\n     // It would be semantically correct to implement this via `copy_nonoverlapping`\n@@ -1249,7 +1250,8 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n /// ```\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n-#[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+#[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[rustc_allow_const_fn_unstable(const_mut_refs, const_maybe_uninit_as_mut_ptr)]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn read_unaligned<T>(src: *const T) -> T {\n     let mut tmp = MaybeUninit::<T>::uninit();"}, {"sha": "5edd291fb76aa5384c9ac7e4d599b61d33b2479c", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1305,7 +1305,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// [`ptr::read`]: crate::ptr::read()\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n     #[inline(always)]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn read(self) -> T\n@@ -1346,7 +1346,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// [`ptr::read_unaligned`]: crate::ptr::read_unaligned()\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n     #[inline(always)]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn read_unaligned(self) -> T"}, {"sha": "c2e9ba273a522c6f73820d511f23446fac492b72", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 37, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -3478,44 +3478,13 @@ impl<T> [T] {\n         // Ts = size_of::<U> / gcd(size_of::<T>, size_of::<U>)\n         //\n         // Luckily since all this is constant-evaluated... performance here matters not!\n-        #[inline]\n-        fn gcd(a: usize, b: usize) -> usize {\n-            use crate::intrinsics;\n-            // iterative stein\u2019s algorithm\n-            // We should still make this `const fn` (and revert to recursive algorithm if we do)\n-            // because relying on llvm to consteval all this is\u2026 well, it makes me uncomfortable.\n-\n-            // SAFETY: `a` and `b` are checked to be non-zero values.\n-            let (ctz_a, mut ctz_b) = unsafe {\n-                if a == 0 {\n-                    return b;\n-                }\n-                if b == 0 {\n-                    return a;\n-                }\n-                (intrinsics::cttz_nonzero(a), intrinsics::cttz_nonzero(b))\n-            };\n-            let k = ctz_a.min(ctz_b);\n-            let mut a = a >> ctz_a;\n-            let mut b = b;\n-            loop {\n-                // remove all factors of 2 from b\n-                b >>= ctz_b;\n-                if a > b {\n-                    mem::swap(&mut a, &mut b);\n-                }\n-                b = b - a;\n-                // SAFETY: `b` is checked to be non-zero.\n-                unsafe {\n-                    if b == 0 {\n-                        break;\n-                    }\n-                    ctz_b = intrinsics::cttz_nonzero(b);\n-                }\n-            }\n-            a << k\n+        const fn gcd(a: usize, b: usize) -> usize {\n+            if b == 0 { a } else { gcd(b, a % b) }\n         }\n-        let gcd: usize = gcd(mem::size_of::<T>(), mem::size_of::<U>());\n+\n+        // Explicitly wrap the function call in a const block so it gets\n+        // constant-evaluated even in debug mode.\n+        let gcd: usize = const { gcd(mem::size_of::<T>(), mem::size_of::<U>()) };\n         let ts: usize = mem::size_of::<U>() / gcd;\n         let us: usize = mem::size_of::<T>() / gcd;\n "}, {"sha": "3c49d1705e5ca60a381d95f0babb3a4736d81621", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -18,7 +18,6 @@\n #![feature(const_pointer_byte_offsets)]\n #![feature(const_pointer_is_aligned)]\n #![feature(const_ptr_as_ref)]\n-#![feature(const_ptr_read)]\n #![feature(const_ptr_write)]\n #![feature(const_trait_impl)]\n #![feature(const_likely)]"}, {"sha": "1454b00255650109af24b3181b139daba91a1cc1", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -15,11 +15,11 @@ cfg-if = { version = \"1.0\", features = ['rustc-dep-of-std'] }\n panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n-libc = { version = \"0.2.142\", default-features = false, features = ['rustc-dep-of-std'] }\n+libc = { version = \"0.2.143\", default-features = false, features = ['rustc-dep-of-std'] }\n compiler_builtins = { version = \"0.1.91\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n-hashbrown = { version = \"0.12\", default-features = false, features = ['rustc-dep-of-std'] }\n+hashbrown = { version = \"0.13\", default-features = false, features = ['rustc-dep-of-std'] }\n std_detect = { path = \"../stdarch/crates/std_detect\", default-features = false, features = ['rustc-dep-of-std'] }\n \n # Dependencies of the `backtrace` crate"}, {"sha": "0fb03c8e88af5f02f9946f2b5ac0cb07dfa4c833", "filename": "library/std/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fbuild.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -34,6 +34,7 @@ fn main() {\n         || target.contains(\"espidf\")\n         || target.contains(\"solid\")\n         || target.contains(\"nintendo-3ds\")\n+        || target.contains(\"vita\")\n         || target.contains(\"nto\")\n     {\n         // These platforms don't have any special requirements."}, {"sha": "eb46f4e54bb675a43c34da83dadddeae9094361b", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -2287,7 +2287,7 @@ mod use_keyword {}\n /// # #![allow(dead_code)]\n /// pub enum Cow<'a, B>\n /// where\n-///     B: 'a + ToOwned + ?Sized,\n+///     B: ToOwned + ?Sized,\n /// {\n ///     Borrowed(&'a B),\n ///     Owned(<B as ToOwned>::Owned),"}, {"sha": "5b54cc5f2e4913f191566667edbafd504e037842", "filename": "library/std/src/os/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -137,6 +137,8 @@ pub mod redox;\n pub mod solaris;\n #[cfg(target_os = \"solid_asp3\")]\n pub mod solid;\n+#[cfg(target_os = \"vita\")]\n+pub mod vita;\n #[cfg(target_os = \"vxworks\")]\n pub mod vxworks;\n #[cfg(target_os = \"watchos\")]"}, {"sha": "1e1c3693105474338564aa7620a2a426eb33a1af", "filename": "library/std/src/os/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -368,7 +368,7 @@ pub trait OpenOptionsExt {\n     ///\n     /// ```no_run\n     /// # #![feature(rustc_private)]\n-    /// extern crate libc;\n+    /// use libc;\n     /// use std::fs::OpenOptions;\n     /// use std::os::unix::fs::OpenOptionsExt;\n     ///"}, {"sha": "6fe1111188aa880a5f1f58b47f63dbc3db8098eb", "filename": "library/std/src/os/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -73,6 +73,8 @@ mod platform {\n     pub use crate::os::redox::*;\n     #[cfg(target_os = \"solaris\")]\n     pub use crate::os::solaris::*;\n+    #[cfg(target_os = \"vita\")]\n+    pub use crate::os::vita::*;\n     #[cfg(target_os = \"vxworks\")]\n     pub use crate::os::vxworks::*;\n     #[cfg(target_os = \"watchos\")]"}, {"sha": "a5a06764a4dd8aef4e0057850635e4fdd4df60f8", "filename": "library/std/src/os/vita/fs.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Fvita%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Fvita%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fvita%2Ffs.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -0,0 +1,95 @@\n+#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+\n+use crate::fs::Metadata;\n+use crate::sys_common::AsInner;\n+\n+/// OS-specific extensions to [`fs::Metadata`].\n+///\n+/// [`fs::Metadata`]: crate::fs::Metadata\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+pub trait MetadataExt {\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_dev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ino(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mode(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_nlink(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_uid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_gid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_rdev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_size(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blksize(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blocks(&self) -> u64;\n+}\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+impl MetadataExt for Metadata {\n+    fn st_dev(&self) -> u64 {\n+        self.as_inner().as_inner().st_dev as u64\n+    }\n+    fn st_ino(&self) -> u64 {\n+        self.as_inner().as_inner().st_ino as u64\n+    }\n+    fn st_mode(&self) -> u32 {\n+        self.as_inner().as_inner().st_mode as u32\n+    }\n+    fn st_nlink(&self) -> u64 {\n+        self.as_inner().as_inner().st_nlink as u64\n+    }\n+    fn st_uid(&self) -> u32 {\n+        self.as_inner().as_inner().st_uid as u32\n+    }\n+    fn st_gid(&self) -> u32 {\n+        self.as_inner().as_inner().st_gid as u32\n+    }\n+    fn st_rdev(&self) -> u64 {\n+        self.as_inner().as_inner().st_rdev as u64\n+    }\n+    fn st_size(&self) -> u64 {\n+        self.as_inner().as_inner().st_size as u64\n+    }\n+    fn st_atime(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime as i64\n+    }\n+    fn st_atime_nsec(&self) -> i64 {\n+        0\n+    }\n+    fn st_mtime(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime as i64\n+    }\n+    fn st_mtime_nsec(&self) -> i64 {\n+        0\n+    }\n+    fn st_ctime(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime as i64\n+    }\n+    fn st_ctime_nsec(&self) -> i64 {\n+        0\n+    }\n+    fn st_blksize(&self) -> u64 {\n+        self.as_inner().as_inner().st_blksize as u64\n+    }\n+    fn st_blocks(&self) -> u64 {\n+        self.as_inner().as_inner().st_blocks as u64\n+    }\n+}"}, {"sha": "da9edd12f7b03daddc3544113395779027eb9f7b", "filename": "library/std/src/os/vita/mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Fvita%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Fvita%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fvita%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -0,0 +1,6 @@\n+//! Definitions for vita\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+\n+pub mod fs;\n+pub(crate) mod raw;"}, {"sha": "74cae4d4135d18c755f14be18c4ad1094b4463c2", "filename": "library/std/src/os/vita/raw.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Fvita%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Fvita%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fvita%2Fraw.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -0,0 +1,70 @@\n+//! vita raw type definitions\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+#![deprecated(\n+    since = \"1.8.0\",\n+    note = \"these type aliases are no longer supported by \\\n+            the standard library, the `libc` crate on \\\n+            crates.io should be used instead for the correct \\\n+            definitions\"\n+)]\n+#![allow(deprecated)]\n+\n+use crate::os::raw::c_long;\n+use crate::os::unix::raw::{gid_t, uid_t};\n+\n+#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n+pub type pthread_t = libc::pthread_t;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = libc::blkcnt_t;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = libc::blksize_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = libc::dev_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = libc::ino_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = libc::mode_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = libc::nlink_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = libc::off_t;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = libc::time_t;\n+\n+#[repr(C)]\n+#[derive(Clone)]\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub struct stat {\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_dev: dev_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_ino: ino_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_mode: mode_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_nlink: nlink_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_uid: uid_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_gid: gid_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_rdev: dev_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_size: off_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_atime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_mtime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_ctime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_blksize: blksize_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_blocks: blkcnt_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_spare4: [c_long; 2usize],\n+}"}, {"sha": "ce34cd1a9bfb3fe9e03f74ccd97145295aff1e32", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -110,7 +110,7 @@ impl BorrowedSocket<'_> {\n     /// object as the existing `BorrowedSocket` instance.\n     #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n     pub fn try_clone_to_owned(&self) -> io::Result<OwnedSocket> {\n-        let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFO>() };\n+        let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFOW>() };\n         let result = unsafe {\n             c::WSADuplicateSocketW(self.as_raw_socket(), c::GetCurrentProcessId(), &mut info)\n         };"}, {"sha": "43203c5824dad5cdfe0cd33a7558396e07ee99a2", "filename": "library/std/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -117,7 +117,7 @@ use crate::sys::path::{is_sep_byte, is_verbatim_sep, parse_prefix, MAIN_SEP_STR}\n /// use std::path::Prefix::*;\n /// use std::ffi::OsStr;\n ///\n-/// fn get_path_prefix(s: &str) -> Prefix {\n+/// fn get_path_prefix(s: &str) -> Prefix<'_> {\n ///     let path = Path::new(s);\n ///     match path.components().next().unwrap() {\n ///         Component::Prefix(prefix_component) => prefix_component.kind(),"}, {"sha": "79624703a4cf7576a88d43386e517fd9af6ea80d", "filename": "library/std/src/personality/dwarf/eh.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -47,6 +47,7 @@ pub enum EHAction {\n     None,\n     Cleanup(usize),\n     Catch(usize),\n+    Filter(usize),\n     Terminate,\n }\n \n@@ -142,9 +143,11 @@ unsafe fn interpret_cs_action(\n         let ttype_index = action_reader.read_sleb128();\n         if ttype_index == 0 {\n             EHAction::Cleanup(lpad)\n-        } else {\n+        } else if ttype_index > 0 {\n             // Stop unwinding Rust panics at catch_unwind.\n             EHAction::Catch(lpad)\n+        } else {\n+            EHAction::Filter(lpad)\n         }\n     }\n }"}, {"sha": "82edb11cbd1461349aea5716f3b2fead13605907", "filename": "library/std/src/personality/gcc.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -135,7 +135,7 @@ cfg_if::cfg_if! {\n                     EHAction::None | EHAction::Cleanup(_) => {\n                         return continue_unwind(exception_object, context);\n                     }\n-                    EHAction::Catch(_) => {\n+                    EHAction::Catch(_) | EHAction::Filter(_) => {\n                         // EHABI requires the personality routine to update the\n                         // SP value in the barrier cache of the exception object.\n                         (*exception_object).private[5] =\n@@ -147,7 +147,8 @@ cfg_if::cfg_if! {\n             } else {\n                 match eh_action {\n                     EHAction::None => return continue_unwind(exception_object, context),\n-                    EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                    EHAction::Filter(_) if state & uw::_US_FORCE_UNWIND as c_int != 0 => return continue_unwind(exception_object, context),\n+                    EHAction::Cleanup(lpad) | EHAction::Catch(lpad) | EHAction::Filter(lpad) => {\n                         uw::_Unwind_SetGR(\n                             context,\n                             UNWIND_DATA_REG.0,\n@@ -201,13 +202,15 @@ cfg_if::cfg_if! {\n             if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n                 match eh_action {\n                     EHAction::None | EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n-                    EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n+                    EHAction::Catch(_) | EHAction::Filter(_) => uw::_URC_HANDLER_FOUND,\n                     EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n                 }\n             } else {\n                 match eh_action {\n                     EHAction::None => uw::_URC_CONTINUE_UNWIND,\n-                    EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                    // Forced unwinding hits a terminate action.\n+                    EHAction::Filter(_) if actions as i32 & uw::_UA_FORCE_UNWIND as i32 != 0 => uw::_URC_CONTINUE_UNWIND,\n+                    EHAction::Cleanup(lpad) | EHAction::Catch(lpad) | EHAction::Filter(lpad) => {\n                         uw::_Unwind_SetGR(\n                             context,\n                             UNWIND_DATA_REG.0,"}, {"sha": "8266e899011cb99f878b29c9a3276a7488a8aefb", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -550,6 +550,7 @@ impl Copy for () {\n ///\n /// ```\n /// # #![feature(rustc_private)]\n+/// #[allow(unused_extern_crates)]\n /// extern crate libc;\n ///\n /// use std::mem;"}, {"sha": "9da74a5ddb574787510ccf47c0c523ee67e921da", "filename": "library/std/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1842,7 +1842,7 @@ impl ExitCode {\n     /// # use std::fmt;\n     /// # enum UhOhError { GenericProblem, Specific, WithCode { exit_code: ExitCode, _x: () } }\n     /// # impl fmt::Display for UhOhError {\n-    /// #     fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result { unimplemented!() }\n+    /// #     fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result { unimplemented!() }\n     /// # }\n     /// // there's no way to gracefully recover from an UhOhError, so we just\n     /// // print a message and exit"}, {"sha": "8604b53983d6cb7b4c03d092887ac9ef9d3cb77d", "filename": "library/std/src/sys/unix/alloc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -59,7 +59,8 @@ cfg_if::cfg_if! {\n         target_os = \"redox\",\n         target_os = \"solaris\",\n         target_os = \"espidf\",\n-        target_os = \"horizon\"\n+        target_os = \"horizon\",\n+        target_os = \"vita\",\n     ))] {\n         #[inline]\n         unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {"}, {"sha": "9ed4d9c1e0dd395b16884c221bab1c1a2bea2fdd", "filename": "library/std/src/sys/unix/args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -265,7 +265,7 @@ mod imp {\n     }\n }\n \n-#[cfg(target_os = \"espidf\")]\n+#[cfg(any(target_os = \"espidf\", target_os = \"vita\"))]\n mod imp {\n     use super::Args;\n "}, {"sha": "8c3ef88d8f8e02ee18cb981b827e3c2181864b14", "filename": "library/std/src/sys/unix/env.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -141,6 +141,17 @@ pub mod os {\n     pub const EXE_EXTENSION: &str = \"elf\";\n }\n \n+#[cfg(target_os = \"vita\")]\n+pub mod os {\n+    pub const FAMILY: &str = \"unix\";\n+    pub const OS: &str = \"vita\";\n+    pub const DLL_PREFIX: &str = \"lib\";\n+    pub const DLL_SUFFIX: &str = \".so\";\n+    pub const DLL_EXTENSION: &str = \"so\";\n+    pub const EXE_SUFFIX: &str = \".elf\";\n+    pub const EXE_EXTENSION: &str = \"elf\";\n+}\n+\n #[cfg(all(target_os = \"emscripten\", target_arch = \"asmjs\"))]\n pub mod os {\n     pub const FAMILY: &str = \"unix\";"}, {"sha": "cb630eede6da0b983cc71699f40408d030ac40d9", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -75,6 +75,7 @@ const fn max_iov() -> usize {\n     target_os = \"nto\",\n     target_os = \"openbsd\",\n     target_os = \"horizon\",\n+    target_os = \"vita\",\n     target_os = \"watchos\",\n )))]\n const fn max_iov() -> usize {\n@@ -93,7 +94,7 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n-    #[cfg(not(any(target_os = \"espidf\", target_os = \"horizon\")))]\n+    #[cfg(not(any(target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\")))]\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n             libc::readv(\n@@ -105,14 +106,14 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n-    #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))]\n+    #[cfg(any(target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\"))]\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         io::default_read_vectored(|b| self.read(b), bufs)\n     }\n \n     #[inline]\n     pub fn is_read_vectored(&self) -> bool {\n-        cfg!(not(any(target_os = \"espidf\", target_os = \"horizon\")))\n+        cfg!(not(any(target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\")))\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n@@ -253,7 +254,7 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n-    #[cfg(not(any(target_os = \"espidf\", target_os = \"horizon\")))]\n+    #[cfg(not(any(target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\")))]\n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n             libc::writev(\n@@ -265,14 +266,14 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n-    #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))]\n+    #[cfg(any(target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\"))]\n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         io::default_write_vectored(|b| self.write(b), bufs)\n     }\n \n     #[inline]\n     pub fn is_write_vectored(&self) -> bool {\n-        cfg!(not(any(target_os = \"espidf\", target_os = \"horizon\")))\n+        cfg!(not(any(target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\")))\n     }\n \n     pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {"}, {"sha": "22d2ae397137a1441a225d5e9b814f45c934a025", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -447,7 +447,12 @@ impl FileAttr {\n \n #[cfg(not(any(target_os = \"netbsd\", target_os = \"nto\")))]\n impl FileAttr {\n-    #[cfg(not(any(target_os = \"vxworks\", target_os = \"espidf\", target_os = \"horizon\")))]\n+    #[cfg(not(any(\n+        target_os = \"vxworks\",\n+        target_os = \"espidf\",\n+        target_os = \"horizon\",\n+        target_os = \"vita\"\n+    )))]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n         #[cfg(target_pointer_width = \"32\")]\n         cfg_has_statx! {\n@@ -459,7 +464,7 @@ impl FileAttr {\n         Ok(SystemTime::new(self.stat.st_mtime as i64, self.stat.st_mtime_nsec as i64))\n     }\n \n-    #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\"))]\n+    #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\", target_os = \"vita\"))]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::new(self.stat.st_mtime as i64, 0))\n     }\n@@ -469,7 +474,12 @@ impl FileAttr {\n         Ok(SystemTime::from(self.stat.st_mtim))\n     }\n \n-    #[cfg(not(any(target_os = \"vxworks\", target_os = \"espidf\", target_os = \"horizon\")))]\n+    #[cfg(not(any(\n+        target_os = \"vxworks\",\n+        target_os = \"espidf\",\n+        target_os = \"horizon\",\n+        target_os = \"vita\"\n+    )))]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         #[cfg(target_pointer_width = \"32\")]\n         cfg_has_statx! {\n@@ -481,7 +491,7 @@ impl FileAttr {\n         Ok(SystemTime::new(self.stat.st_atime as i64, self.stat.st_atime_nsec as i64))\n     }\n \n-    #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\"))]\n+    #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\", target_os = \"vita\"))]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::new(self.stat.st_atime as i64, 0))\n     }\n@@ -866,6 +876,7 @@ impl DirEntry {\n         target_os = \"vxworks\",\n         target_os = \"espidf\",\n         target_os = \"horizon\",\n+        target_os = \"vita\",\n         target_os = \"nto\",\n     ))]\n     pub fn ino(&self) -> u64 {"}, {"sha": "bb9e65e68e5e877268a3b0191becfa2b53eef91e", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -92,6 +92,7 @@ pub unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {\n             target_os = \"redox\",\n             target_os = \"l4re\",\n             target_os = \"horizon\",\n+            target_os = \"vita\",\n         )))]\n         'poll: {\n             use crate::sys::os::errno;\n@@ -140,6 +141,7 @@ pub unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {\n             target_os = \"vxworks\",\n             target_os = \"l4re\",\n             target_os = \"horizon\",\n+            target_os = \"vita\",\n         )))]\n         {\n             use crate::sys::os::errno;\n@@ -162,7 +164,12 @@ pub unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {\n     }\n \n     unsafe fn reset_sigpipe(#[allow(unused_variables)] sigpipe: u8) {\n-        #[cfg(not(any(target_os = \"emscripten\", target_os = \"fuchsia\", target_os = \"horizon\")))]\n+        #[cfg(not(any(\n+            target_os = \"emscripten\",\n+            target_os = \"fuchsia\",\n+            target_os = \"horizon\",\n+            target_os = \"vita\"\n+        )))]\n         {\n             // We don't want to add this as a public type to std, nor do we\n             // want to `include!` a file from the compiler (which would break\n@@ -199,7 +206,8 @@ pub unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {\n     target_os = \"espidf\",\n     target_os = \"emscripten\",\n     target_os = \"fuchsia\",\n-    target_os = \"horizon\"\n+    target_os = \"horizon\",\n+    target_os = \"vita\"\n )))]\n static UNIX_SIGPIPE_ATTR_SPECIFIED: crate::sync::atomic::AtomicBool =\n     crate::sync::atomic::AtomicBool::new(false);\n@@ -208,7 +216,8 @@ static UNIX_SIGPIPE_ATTR_SPECIFIED: crate::sync::atomic::AtomicBool =\n     target_os = \"espidf\",\n     target_os = \"emscripten\",\n     target_os = \"fuchsia\",\n-    target_os = \"horizon\"\n+    target_os = \"horizon\",\n+    target_os = \"vita\",\n )))]\n pub(crate) fn unix_sigpipe_attr_specified() -> bool {\n     UNIX_SIGPIPE_ATTR_SPECIFIED.load(crate::sync::atomic::Ordering::Relaxed)\n@@ -402,7 +411,7 @@ cfg_if::cfg_if! {\n     }\n }\n \n-#[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))]\n+#[cfg(any(target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\"))]\n mod unsupported {\n     use crate::io;\n "}, {"sha": "8edfd331304426fba22a0c0336ef5681cac514f4", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -460,7 +460,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     path.canonicalize()\n }\n \n-#[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))]\n+#[cfg(any(target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     super::unsupported::unsupported()\n }\n@@ -614,7 +614,8 @@ pub fn home_dir() -> Option<PathBuf> {\n         target_os = \"redox\",\n         target_os = \"vxworks\",\n         target_os = \"espidf\",\n-        target_os = \"horizon\"\n+        target_os = \"horizon\",\n+        target_os = \"vita\",\n     ))]\n     unsafe fn fallback() -> Option<OsString> {\n         None\n@@ -627,7 +628,8 @@ pub fn home_dir() -> Option<PathBuf> {\n         target_os = \"redox\",\n         target_os = \"vxworks\",\n         target_os = \"espidf\",\n-        target_os = \"horizon\"\n+        target_os = \"horizon\",\n+        target_os = \"vita\",\n     )))]\n     unsafe fn fallback() -> Option<OsString> {\n         let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {"}, {"sha": "0cf163d9fb8e9409e70f54a533645bf4a701e252", "filename": "library/std/src/sys/unix/process/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -14,7 +14,7 @@ cfg_if::cfg_if! {\n     } else if #[cfg(target_os = \"vxworks\")] {\n         #[path = \"process_vxworks.rs\"]\n         mod process_inner;\n-    } else if #[cfg(any(target_os = \"espidf\", target_os = \"horizon\"))] {\n+    } else if #[cfg(any(target_os = \"espidf\", target_os = \"horizon\", target_os = \"vita\"))] {\n         #[path = \"process_unsupported.rs\"]\n         mod process_inner;\n     } else {"}, {"sha": "d8b63546b9ed1d129d95926f96d8c95326c86764", "filename": "library/std/src/sys/unix/rand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -21,7 +21,8 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n     not(target_os = \"fuchsia\"),\n     not(target_os = \"redox\"),\n     not(target_os = \"vxworks\"),\n-    not(target_os = \"emscripten\")\n+    not(target_os = \"emscripten\"),\n+    not(target_os = \"vita\"),\n ))]\n mod imp {\n     use crate::fs::File;\n@@ -175,7 +176,7 @@ mod imp {\n     }\n }\n \n-#[cfg(any(target_os = \"openbsd\", target_os = \"emscripten\"))]\n+#[cfg(any(target_os = \"openbsd\", target_os = \"emscripten\", target_os = \"vita\"))]\n mod imp {\n     use crate::sys::os::errno;\n "}, {"sha": "2bc40c4748a355ebde011d4f9eef74693b028887", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 153, "deletions": 1162, "changes": 1315, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -6,33 +6,18 @@\n \n use crate::ffi::CStr;\n use crate::mem;\n-use crate::os::raw::{c_char, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n-use crate::os::windows::io::{BorrowedHandle, HandleOrInvalid, HandleOrNull};\n+pub use crate::os::raw::c_int;\n+use crate::os::raw::{c_char, c_long, c_longlong, c_uint, c_ulong, c_ushort, c_void};\n+use crate::os::windows::io::{AsRawHandle, BorrowedHandle};\n use crate::ptr;\n use core::ffi::NonZero_c_ulong;\n \n-use libc::{c_void, size_t, wchar_t};\n-\n-pub use crate::os::raw::c_int;\n-\n-#[path = \"c/errors.rs\"] // c.rs is included from two places so we need to specify this\n-mod errors;\n-pub use errors::*;\n+#[path = \"c/windows_sys.rs\"] // c.rs is included from two places so we need to specify this\n+mod windows_sys;\n+pub use windows_sys::*;\n \n-pub use self::EXCEPTION_DISPOSITION::*;\n-pub use self::FILE_INFO_BY_HANDLE_CLASS::*;\n-\n-pub type DWORD_PTR = ULONG_PTR;\n pub type DWORD = c_ulong;\n pub type NonZeroDWORD = NonZero_c_ulong;\n-pub type HANDLE = LPVOID;\n-pub type HINSTANCE = HANDLE;\n-pub type HMODULE = HINSTANCE;\n-pub type HRESULT = LONG;\n-pub type BOOL = c_int;\n-pub type BYTE = u8;\n-pub type BOOLEAN = BYTE;\n-pub type GROUP = c_uint;\n pub type LARGE_INTEGER = c_longlong;\n pub type LONG = c_long;\n pub type UINT = c_uint;\n@@ -41,218 +26,40 @@ pub type USHORT = c_ushort;\n pub type SIZE_T = usize;\n pub type WORD = u16;\n pub type CHAR = c_char;\n-pub type CCHAR = c_char;\n-pub type ULONG_PTR = usize;\n pub type ULONG = c_ulong;\n-pub type NTSTATUS = LONG;\n pub type ACCESS_MASK = DWORD;\n \n-pub type LPBOOL = *mut BOOL;\n-pub type LPBYTE = *mut BYTE;\n-pub type LPCCH = *const CHAR;\n-pub type LPCSTR = *const CHAR;\n-pub type LPCWCH = *const WCHAR;\n-pub type LPCWSTR = *const WCHAR;\n pub type LPCVOID = *const c_void;\n-pub type LPDWORD = *mut DWORD;\n pub type LPHANDLE = *mut HANDLE;\n pub type LPOVERLAPPED = *mut OVERLAPPED;\n-pub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;\n pub type LPSECURITY_ATTRIBUTES = *mut SECURITY_ATTRIBUTES;\n-pub type LPSTARTUPINFO = *mut STARTUPINFO;\n-pub type LPSTR = *mut CHAR;\n pub type LPVOID = *mut c_void;\n pub type LPWCH = *mut WCHAR;\n-pub type LPWIN32_FIND_DATAW = *mut WIN32_FIND_DATAW;\n-pub type LPWSADATA = *mut WSADATA;\n-pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;\n pub type LPWSTR = *mut WCHAR;\n-pub type LPFILETIME = *mut FILETIME;\n-pub type LPSYSTEM_INFO = *mut SYSTEM_INFO;\n-pub type LPWSABUF = *mut WSABUF;\n-pub type LPWSAOVERLAPPED = *mut c_void;\n-pub type LPWSAOVERLAPPED_COMPLETION_ROUTINE = *mut c_void;\n-pub type BCRYPT_ALG_HANDLE = LPVOID;\n \n-pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n pub type PLARGE_INTEGER = *mut c_longlong;\n pub type PSRWLOCK = *mut SRWLOCK;\n-pub type LPINIT_ONCE = *mut INIT_ONCE;\n \n-pub type SOCKET = crate::os::windows::raw::SOCKET;\n pub type socklen_t = c_int;\n pub type ADDRESS_FAMILY = USHORT;\n+pub use FD_SET as fd_set;\n+pub use LINGER as linger;\n+pub use TIMEVAL as timeval;\n \n-pub const TRUE: BOOL = 1;\n-pub const FALSE: BOOL = 0;\n-\n-pub const CSTR_LESS_THAN: c_int = 1;\n-pub const CSTR_EQUAL: c_int = 2;\n-pub const CSTR_GREATER_THAN: c_int = 3;\n-\n-pub const FILE_ATTRIBUTE_READONLY: DWORD = 0x1;\n-pub const FILE_ATTRIBUTE_DIRECTORY: DWORD = 0x10;\n-pub const FILE_ATTRIBUTE_REPARSE_POINT: DWORD = 0x400;\n-pub const INVALID_FILE_ATTRIBUTES: DWORD = DWORD::MAX;\n-\n-pub const FILE_SHARE_DELETE: DWORD = 0x4;\n-pub const FILE_SHARE_READ: DWORD = 0x1;\n-pub const FILE_SHARE_WRITE: DWORD = 0x2;\n+pub type CONDITION_VARIABLE = RTL_CONDITION_VARIABLE;\n+pub type SRWLOCK = RTL_SRWLOCK;\n+pub type INIT_ONCE = RTL_RUN_ONCE;\n \n-pub const FILE_OPEN: ULONG = 0x00000001;\n-pub const FILE_OPEN_REPARSE_POINT: ULONG = 0x200000;\n-pub const OBJ_DONT_REPARSE: ULONG = 0x1000;\n+pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE { Ptr: ptr::null_mut() };\n+pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { Ptr: ptr::null_mut() };\n+pub const INIT_ONCE_STATIC_INIT: INIT_ONCE = INIT_ONCE { Ptr: ptr::null_mut() };\n \n-pub const CREATE_ALWAYS: DWORD = 2;\n-pub const CREATE_NEW: DWORD = 1;\n-pub const OPEN_ALWAYS: DWORD = 4;\n-pub const OPEN_EXISTING: DWORD = 3;\n-pub const TRUNCATE_EXISTING: DWORD = 5;\n-\n-pub const FILE_LIST_DIRECTORY: DWORD = 0x1;\n-pub const FILE_WRITE_DATA: DWORD = 0x00000002;\n-pub const FILE_APPEND_DATA: DWORD = 0x00000004;\n-pub const FILE_WRITE_EA: DWORD = 0x00000010;\n-pub const FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\n-pub const DELETE: DWORD = 0x10000;\n-pub const READ_CONTROL: DWORD = 0x00020000;\n-pub const SYNCHRONIZE: DWORD = 0x00100000;\n-pub const GENERIC_READ: DWORD = 0x80000000;\n-pub const GENERIC_WRITE: DWORD = 0x40000000;\n-pub const STANDARD_RIGHTS_WRITE: DWORD = READ_CONTROL;\n-pub const FILE_GENERIC_WRITE: DWORD = STANDARD_RIGHTS_WRITE\n-    | FILE_WRITE_DATA\n-    | FILE_WRITE_ATTRIBUTES\n-    | FILE_WRITE_EA\n-    | FILE_APPEND_DATA\n-    | SYNCHRONIZE;\n-\n-pub const FILE_FLAG_OPEN_REPARSE_POINT: DWORD = 0x00200000;\n-pub const FILE_FLAG_BACKUP_SEMANTICS: DWORD = 0x02000000;\n-pub const SECURITY_SQOS_PRESENT: DWORD = 0x00100000;\n-\n-pub const FIONBIO: c_ulong = 0x8004667e;\n-\n-pub const MAX_PATH: usize = 260;\n-\n-pub const FILE_TYPE_PIPE: u32 = 3;\n-\n-pub const CP_UTF8: DWORD = 65001;\n-pub const MB_ERR_INVALID_CHARS: DWORD = 0x08;\n-pub const WC_ERR_INVALID_CHARS: DWORD = 0x80;\n-\n-#[repr(C)]\n-#[derive(Copy)]\n-pub struct WIN32_FIND_DATAW {\n-    pub dwFileAttributes: DWORD,\n-    pub ftCreationTime: FILETIME,\n-    pub ftLastAccessTime: FILETIME,\n-    pub ftLastWriteTime: FILETIME,\n-    pub nFileSizeHigh: DWORD,\n-    pub nFileSizeLow: DWORD,\n-    pub dwReserved0: DWORD,\n-    pub dwReserved1: DWORD,\n-    pub cFileName: [wchar_t; 260], // #define MAX_PATH 260\n-    pub cAlternateFileName: [wchar_t; 14],\n-}\n-impl Clone for WIN32_FIND_DATAW {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-pub const WSA_FLAG_OVERLAPPED: DWORD = 0x01;\n-pub const WSA_FLAG_NO_HANDLE_INHERIT: DWORD = 0x80;\n-\n-pub const WSADESCRIPTION_LEN: usize = 256;\n-pub const WSASYS_STATUS_LEN: usize = 128;\n-pub const WSAPROTOCOL_LEN: DWORD = 255;\n-pub const INVALID_SOCKET: SOCKET = !0;\n-\n-pub const MAX_PROTOCOL_CHAIN: DWORD = 7;\n-\n-pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n-pub const FSCTL_GET_REPARSE_POINT: DWORD = 0x900a8;\n-pub const IO_REPARSE_TAG_SYMLINK: DWORD = 0xa000000c;\n-pub const IO_REPARSE_TAG_MOUNT_POINT: DWORD = 0xa0000003;\n-pub const SYMLINK_FLAG_RELATIVE: DWORD = 0x00000001;\n-pub const FSCTL_SET_REPARSE_POINT: DWORD = 0x900a4;\n-\n-pub const SYMBOLIC_LINK_FLAG_DIRECTORY: DWORD = 0x1;\n-pub const SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE: DWORD = 0x2;\n-\n-// Note that these are not actually HANDLEs, just values to pass to GetStdHandle\n-pub const STD_INPUT_HANDLE: DWORD = -10i32 as DWORD;\n-pub const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n-pub const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n-\n-pub const PROGRESS_CONTINUE: DWORD = 0;\n-\n-pub const E_NOTIMPL: HRESULT = 0x80004001u32 as HRESULT;\n-\n-pub const INVALID_HANDLE_VALUE: HANDLE = ptr::invalid_mut(!0);\n-\n-pub const FACILITY_NT_BIT: DWORD = 0x1000_0000;\n-\n-pub const FORMAT_MESSAGE_FROM_SYSTEM: DWORD = 0x00001000;\n-pub const FORMAT_MESSAGE_FROM_HMODULE: DWORD = 0x00000800;\n-pub const FORMAT_MESSAGE_IGNORE_INSERTS: DWORD = 0x00000200;\n-\n-pub const TLS_OUT_OF_INDEXES: DWORD = 0xFFFFFFFF;\n-\n-pub const DLL_THREAD_DETACH: DWORD = 3;\n-pub const DLL_PROCESS_DETACH: DWORD = 0;\n-\n-pub const INFINITE: DWORD = !0;\n-\n-pub const DUPLICATE_SAME_ACCESS: DWORD = 0x00000002;\n-\n-pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE { ptr: ptr::null_mut() };\n-pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: ptr::null_mut() };\n-pub const INIT_ONCE_STATIC_INIT: INIT_ONCE = INIT_ONCE { ptr: ptr::null_mut() };\n-\n-pub const INIT_ONCE_INIT_FAILED: DWORD = 0x00000004;\n-\n-pub const DETACHED_PROCESS: DWORD = 0x00000008;\n-pub const CREATE_NEW_PROCESS_GROUP: DWORD = 0x00000200;\n-pub const CREATE_UNICODE_ENVIRONMENT: DWORD = 0x00000400;\n-pub const STARTF_USESTDHANDLES: DWORD = 0x00000100;\n-\n-pub const AF_INET: c_int = 2;\n-pub const AF_INET6: c_int = 23;\n-pub const SD_BOTH: c_int = 2;\n-pub const SD_RECEIVE: c_int = 0;\n-pub const SD_SEND: c_int = 1;\n-pub const SOCK_DGRAM: c_int = 2;\n-pub const SOCK_STREAM: c_int = 1;\n-pub const SOCKET_ERROR: c_int = -1;\n-pub const SOL_SOCKET: c_int = 0xffff;\n-pub const SO_LINGER: c_int = 0x0080;\n-pub const SO_RCVTIMEO: c_int = 0x1006;\n-pub const SO_SNDTIMEO: c_int = 0x1005;\n-pub const IPPROTO_IP: c_int = 0;\n-pub const IPPROTO_TCP: c_int = 6;\n-pub const IPPROTO_IPV6: c_int = 41;\n-pub const TCP_NODELAY: c_int = 0x0001;\n-pub const IP_TTL: c_int = 4;\n-pub const IPV6_V6ONLY: c_int = 27;\n-pub const SO_ERROR: c_int = 0x1007;\n-pub const SO_BROADCAST: c_int = 0x0020;\n-pub const IP_MULTICAST_LOOP: c_int = 11;\n-pub const IPV6_MULTICAST_LOOP: c_int = 11;\n-pub const IP_MULTICAST_TTL: c_int = 10;\n-pub const IP_ADD_MEMBERSHIP: c_int = 12;\n-pub const IP_DROP_MEMBERSHIP: c_int = 13;\n-pub const IPV6_ADD_MEMBERSHIP: c_int = 12;\n-pub const IPV6_DROP_MEMBERSHIP: c_int = 13;\n-pub const MSG_PEEK: c_int = 0x2;\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub struct linger {\n-    pub l_onoff: c_ushort,\n-    pub l_linger: c_ushort,\n-}\n+// Some windows_sys types have different signs than the types we use.\n+pub const OBJ_DONT_REPARSE: u32 = windows_sys::OBJ_DONT_REPARSE as u32;\n+pub const FRS_ERR_SYSVOL_POPULATE_TIMEOUT: u32 =\n+    windows_sys::FRS_ERR_SYSVOL_POPULATE_TIMEOUT as u32;\n+pub const AF_INET: c_int = windows_sys::AF_INET as c_int;\n+pub const AF_INET6: c_int = windows_sys::AF_INET6 as c_int;\n \n #[repr(C)]\n pub struct ip_mreq {\n@@ -266,66 +73,19 @@ pub struct ipv6_mreq {\n     pub ipv6mr_interface: c_uint,\n }\n \n-pub const VOLUME_NAME_DOS: DWORD = 0x0;\n-pub const MOVEFILE_REPLACE_EXISTING: DWORD = 1;\n-\n-pub const FILE_BEGIN: DWORD = 0;\n-pub const FILE_CURRENT: DWORD = 1;\n-pub const FILE_END: DWORD = 2;\n-\n-pub const WAIT_OBJECT_0: DWORD = 0x00000000;\n-pub const WAIT_TIMEOUT: DWORD = 258;\n-pub const WAIT_FAILED: DWORD = 0xFFFFFFFF;\n-\n-pub const PIPE_ACCESS_INBOUND: DWORD = 0x00000001;\n-pub const PIPE_ACCESS_OUTBOUND: DWORD = 0x00000002;\n-pub const FILE_FLAG_FIRST_PIPE_INSTANCE: DWORD = 0x00080000;\n-pub const FILE_FLAG_OVERLAPPED: DWORD = 0x40000000;\n-pub const PIPE_WAIT: DWORD = 0x00000000;\n-pub const PIPE_TYPE_BYTE: DWORD = 0x00000000;\n-pub const PIPE_REJECT_REMOTE_CLIENTS: DWORD = 0x00000008;\n-pub const PIPE_READMODE_BYTE: DWORD = 0x00000000;\n-\n-pub const FD_SETSIZE: usize = 64;\n-\n-pub const STACK_SIZE_PARAM_IS_A_RESERVATION: DWORD = 0x00010000;\n-\n-pub const STATUS_SUCCESS: NTSTATUS = 0x00000000;\n-pub const STATUS_DELETE_PENDING: NTSTATUS = 0xc0000056_u32 as _;\n-pub const STATUS_INVALID_PARAMETER: NTSTATUS = 0xc000000d_u32 as _;\n-\n-pub const STATUS_PENDING: NTSTATUS = 0x103 as _;\n-pub const STATUS_END_OF_FILE: NTSTATUS = 0xC0000011_u32 as _;\n-\n // Equivalent to the `NT_SUCCESS` C preprocessor macro.\n // See: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values\n pub fn nt_success(status: NTSTATUS) -> bool {\n     status >= 0\n }\n \n-pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG: DWORD = 0x00000002;\n-\n-#[repr(C)]\n-pub struct UNICODE_STRING {\n-    pub Length: u16,\n-    pub MaximumLength: u16,\n-    pub Buffer: *mut u16,\n-}\n impl UNICODE_STRING {\n     pub fn from_ref(slice: &[u16]) -> Self {\n         let len = slice.len() * mem::size_of::<u16>();\n         Self { Length: len as _, MaximumLength: len as _, Buffer: slice.as_ptr() as _ }\n     }\n }\n-#[repr(C)]\n-pub struct OBJECT_ATTRIBUTES {\n-    pub Length: ULONG,\n-    pub RootDirectory: HANDLE,\n-    pub ObjectName: *const UNICODE_STRING,\n-    pub Attributes: ULONG,\n-    pub SecurityDescriptor: *mut c_void,\n-    pub SecurityQualityOfService: *mut c_void,\n-}\n+\n impl Default for OBJECT_ATTRIBUTES {\n     fn default() -> Self {\n         Self {\n@@ -338,193 +98,20 @@ impl Default for OBJECT_ATTRIBUTES {\n         }\n     }\n }\n-#[repr(C)]\n-union IO_STATUS_BLOCK_union {\n-    Status: NTSTATUS,\n-    Pointer: *mut c_void,\n-}\n-impl Default for IO_STATUS_BLOCK_union {\n-    fn default() -> Self {\n-        let mut this = Self { Pointer: ptr::null_mut() };\n-        this.Status = STATUS_PENDING;\n-        this\n-    }\n-}\n-#[repr(C)]\n-#[derive(Default)]\n-pub struct IO_STATUS_BLOCK {\n-    u: IO_STATUS_BLOCK_union,\n-    pub Information: usize,\n-}\n+\n impl IO_STATUS_BLOCK {\n+    pub const PENDING: Self =\n+        IO_STATUS_BLOCK { Anonymous: IO_STATUS_BLOCK_0 { Status: STATUS_PENDING }, Information: 0 };\n     pub fn status(&self) -> NTSTATUS {\n-        // SAFETY: If `self.u.Status` was set then this is obviously safe.\n-        // If `self.u.Pointer` was set then this is the equivalent to converting\n+        // SAFETY: If `self.Anonymous.Status` was set then this is obviously safe.\n+        // If `self.Anonymous.Pointer` was set then this is the equivalent to converting\n         // the pointer to an integer, which is also safe.\n         // Currently the only safe way to construct `IO_STATUS_BLOCK` outside of\n         // this module is to call the `default` method, which sets the `Status`.\n-        unsafe { self.u.Status }\n+        unsafe { self.Anonymous.Status }\n     }\n }\n \n-pub type LPOVERLAPPED_COMPLETION_ROUTINE = unsafe extern \"system\" fn(\n-    dwErrorCode: DWORD,\n-    dwNumberOfBytesTransferred: DWORD,\n-    lpOverlapped: *mut OVERLAPPED,\n-);\n-\n-type IO_APC_ROUTINE = unsafe extern \"system\" fn(\n-    ApcContext: *mut c_void,\n-    IoStatusBlock: *mut IO_STATUS_BLOCK,\n-    Reserved: ULONG,\n-);\n-\n-#[repr(C)]\n-#[cfg(not(target_pointer_width = \"64\"))]\n-pub struct WSADATA {\n-    pub wVersion: WORD,\n-    pub wHighVersion: WORD,\n-    pub szDescription: [u8; WSADESCRIPTION_LEN + 1],\n-    pub szSystemStatus: [u8; WSASYS_STATUS_LEN + 1],\n-    pub iMaxSockets: u16,\n-    pub iMaxUdpDg: u16,\n-    pub lpVendorInfo: *mut u8,\n-}\n-#[repr(C)]\n-#[cfg(target_pointer_width = \"64\")]\n-pub struct WSADATA {\n-    pub wVersion: WORD,\n-    pub wHighVersion: WORD,\n-    pub iMaxSockets: u16,\n-    pub iMaxUdpDg: u16,\n-    pub lpVendorInfo: *mut u8,\n-    pub szDescription: [u8; WSADESCRIPTION_LEN + 1],\n-    pub szSystemStatus: [u8; WSASYS_STATUS_LEN + 1],\n-}\n-\n-#[derive(Copy, Clone)]\n-#[repr(C)]\n-pub struct WSABUF {\n-    pub len: ULONG,\n-    pub buf: *mut CHAR,\n-}\n-\n-#[repr(C)]\n-pub struct WSAPROTOCOL_INFO {\n-    pub dwServiceFlags1: DWORD,\n-    pub dwServiceFlags2: DWORD,\n-    pub dwServiceFlags3: DWORD,\n-    pub dwServiceFlags4: DWORD,\n-    pub dwProviderFlags: DWORD,\n-    pub ProviderId: GUID,\n-    pub dwCatalogEntryId: DWORD,\n-    pub ProtocolChain: WSAPROTOCOLCHAIN,\n-    pub iVersion: c_int,\n-    pub iAddressFamily: c_int,\n-    pub iMaxSockAddr: c_int,\n-    pub iMinSockAddr: c_int,\n-    pub iSocketType: c_int,\n-    pub iProtocol: c_int,\n-    pub iProtocolMaxOffset: c_int,\n-    pub iNetworkByteOrder: c_int,\n-    pub iSecurityScheme: c_int,\n-    pub dwMessageSize: DWORD,\n-    pub dwProviderReserved: DWORD,\n-    pub szProtocol: [u16; (WSAPROTOCOL_LEN as usize) + 1],\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub struct WIN32_FILE_ATTRIBUTE_DATA {\n-    pub dwFileAttributes: DWORD,\n-    pub ftCreationTime: FILETIME,\n-    pub ftLastAccessTime: FILETIME,\n-    pub ftLastWriteTime: FILETIME,\n-    pub nFileSizeHigh: DWORD,\n-    pub nFileSizeLow: DWORD,\n-}\n-\n-#[repr(C)]\n-#[allow(dead_code)] // we only use some variants\n-pub enum FILE_INFO_BY_HANDLE_CLASS {\n-    FileBasicInfo = 0,\n-    FileStandardInfo = 1,\n-    FileNameInfo = 2,\n-    FileRenameInfo = 3,\n-    FileDispositionInfo = 4,\n-    FileAllocationInfo = 5,\n-    FileEndOfFileInfo = 6,\n-    FileStreamInfo = 7,\n-    FileCompressionInfo = 8,\n-    FileAttributeTagInfo = 9,\n-    FileIdBothDirectoryInfo = 10,        // 0xA\n-    FileIdBothDirectoryRestartInfo = 11, // 0xB\n-    FileIoPriorityHintInfo = 12,         // 0xC\n-    FileRemoteProtocolInfo = 13,         // 0xD\n-    FileFullDirectoryInfo = 14,          // 0xE\n-    FileFullDirectoryRestartInfo = 15,   // 0xF\n-    FileStorageInfo = 16,                // 0x10\n-    FileAlignmentInfo = 17,              // 0x11\n-    FileIdInfo = 18,                     // 0x12\n-    FileIdExtdDirectoryInfo = 19,        // 0x13\n-    FileIdExtdDirectoryRestartInfo = 20, // 0x14\n-    FileDispositionInfoEx = 21,          // 0x15, Windows 10 version 1607\n-    MaximumFileInfoByHandlesClass,\n-}\n-\n-#[repr(C)]\n-pub struct FILE_ATTRIBUTE_TAG_INFO {\n-    pub FileAttributes: DWORD,\n-    pub ReparseTag: DWORD,\n-}\n-\n-#[repr(C)]\n-pub struct FILE_DISPOSITION_INFO {\n-    pub DeleteFile: BOOLEAN,\n-}\n-\n-pub const FILE_DISPOSITION_DELETE: DWORD = 0x1;\n-pub const FILE_DISPOSITION_POSIX_SEMANTICS: DWORD = 0x2;\n-pub const FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE: DWORD = 0x10;\n-\n-#[repr(C)]\n-pub struct FILE_DISPOSITION_INFO_EX {\n-    pub Flags: DWORD,\n-}\n-\n-#[repr(C)]\n-#[derive(Default)]\n-pub struct FILE_ID_BOTH_DIR_INFO {\n-    pub NextEntryOffset: DWORD,\n-    pub FileIndex: DWORD,\n-    pub CreationTime: LARGE_INTEGER,\n-    pub LastAccessTime: LARGE_INTEGER,\n-    pub LastWriteTime: LARGE_INTEGER,\n-    pub ChangeTime: LARGE_INTEGER,\n-    pub EndOfFile: LARGE_INTEGER,\n-    pub AllocationSize: LARGE_INTEGER,\n-    pub FileAttributes: DWORD,\n-    pub FileNameLength: DWORD,\n-    pub EaSize: DWORD,\n-    pub ShortNameLength: CCHAR,\n-    pub ShortName: [WCHAR; 12],\n-    pub FileId: LARGE_INTEGER,\n-    pub FileName: [WCHAR; 1],\n-}\n-#[repr(C)]\n-pub struct FILE_BASIC_INFO {\n-    pub CreationTime: LARGE_INTEGER,\n-    pub LastAccessTime: LARGE_INTEGER,\n-    pub LastWriteTime: LARGE_INTEGER,\n-    pub ChangeTime: LARGE_INTEGER,\n-    pub FileAttributes: DWORD,\n-}\n-\n-#[repr(C)]\n-pub struct FILE_END_OF_FILE_INFO {\n-    pub EndOfFile: LARGE_INTEGER,\n-}\n-\n /// NB: Use carefully! In general using this as a reference is likely to get the\n /// provenance wrong for the `rest` field!\n #[repr(C)]\n@@ -555,34 +142,6 @@ pub struct MOUNT_POINT_REPARSE_BUFFER {\n     pub PrintNameLength: c_ushort,\n     pub PathBuffer: WCHAR,\n }\n-\n-pub type LPPROGRESS_ROUTINE = crate::option::Option<\n-    unsafe extern \"system\" fn(\n-        TotalFileSize: LARGE_INTEGER,\n-        TotalBytesTransferred: LARGE_INTEGER,\n-        StreamSize: LARGE_INTEGER,\n-        StreamBytesTransferred: LARGE_INTEGER,\n-        dwStreamNumber: DWORD,\n-        dwCallbackReason: DWORD,\n-        hSourceFile: HANDLE,\n-        hDestinationFile: HANDLE,\n-        lpData: LPVOID,\n-    ) -> DWORD,\n->;\n-\n-#[repr(C)]\n-pub struct CONDITION_VARIABLE {\n-    pub ptr: LPVOID,\n-}\n-#[repr(C)]\n-pub struct SRWLOCK {\n-    pub ptr: LPVOID,\n-}\n-#[repr(C)]\n-pub struct INIT_ONCE {\n-    pub ptr: LPVOID,\n-}\n-\n #[repr(C)]\n pub struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n     pub ReparseTag: DWORD,\n@@ -594,103 +153,6 @@ pub struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n     pub ReparseTarget: WCHAR,\n }\n \n-#[repr(C)]\n-pub struct GUID {\n-    pub Data1: DWORD,\n-    pub Data2: WORD,\n-    pub Data3: WORD,\n-    pub Data4: [BYTE; 8],\n-}\n-\n-#[repr(C)]\n-pub struct WSAPROTOCOLCHAIN {\n-    pub ChainLen: c_int,\n-    pub ChainEntries: [DWORD; MAX_PROTOCOL_CHAIN as usize],\n-}\n-\n-#[repr(C)]\n-pub struct SECURITY_ATTRIBUTES {\n-    pub nLength: DWORD,\n-    pub lpSecurityDescriptor: LPVOID,\n-    pub bInheritHandle: BOOL,\n-}\n-\n-#[repr(C)]\n-pub struct PROCESS_INFORMATION {\n-    pub hProcess: HANDLE,\n-    pub hThread: HANDLE,\n-    pub dwProcessId: DWORD,\n-    pub dwThreadId: DWORD,\n-}\n-\n-#[repr(C)]\n-pub struct STARTUPINFO {\n-    pub cb: DWORD,\n-    pub lpReserved: LPWSTR,\n-    pub lpDesktop: LPWSTR,\n-    pub lpTitle: LPWSTR,\n-    pub dwX: DWORD,\n-    pub dwY: DWORD,\n-    pub dwXSize: DWORD,\n-    pub dwYSize: DWORD,\n-    pub dwXCountChars: DWORD,\n-    pub dwYCountCharts: DWORD,\n-    pub dwFillAttribute: DWORD,\n-    pub dwFlags: DWORD,\n-    pub wShowWindow: WORD,\n-    pub cbReserved2: WORD,\n-    pub lpReserved2: LPBYTE,\n-    pub hStdInput: HANDLE,\n-    pub hStdOutput: HANDLE,\n-    pub hStdError: HANDLE,\n-}\n-\n-#[repr(C)]\n-pub struct SOCKADDR {\n-    pub sa_family: ADDRESS_FAMILY,\n-    pub sa_data: [CHAR; 14],\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone, Debug, Default)]\n-pub struct FILETIME {\n-    pub dwLowDateTime: DWORD,\n-    pub dwHighDateTime: DWORD,\n-}\n-\n-#[repr(C)]\n-pub struct SYSTEM_INFO {\n-    pub wProcessorArchitecture: WORD,\n-    pub wReserved: WORD,\n-    pub dwPageSize: DWORD,\n-    pub lpMinimumApplicationAddress: LPVOID,\n-    pub lpMaximumApplicationAddress: LPVOID,\n-    pub dwActiveProcessorMask: DWORD_PTR,\n-    pub dwNumberOfProcessors: DWORD,\n-    pub dwProcessorType: DWORD,\n-    pub dwAllocationGranularity: DWORD,\n-    pub wProcessorLevel: WORD,\n-    pub wProcessorRevision: WORD,\n-}\n-\n-#[repr(C)]\n-pub struct OVERLAPPED {\n-    pub Internal: *mut c_ulong,\n-    pub InternalHigh: *mut c_ulong,\n-    pub Offset: DWORD,\n-    pub OffsetHigh: DWORD,\n-    pub hEvent: HANDLE,\n-}\n-\n-#[repr(C)]\n-#[allow(dead_code)] // we only use some variants\n-pub enum ADDRESS_MODE {\n-    AddrMode1616,\n-    AddrMode1632,\n-    AddrModeReal,\n-    AddrModeFlat,\n-}\n-\n #[repr(C)]\n pub struct SOCKADDR_STORAGE_LH {\n     pub ss_family: ADDRESS_FAMILY,\n@@ -699,18 +161,6 @@ pub struct SOCKADDR_STORAGE_LH {\n     pub __ss_pad2: [CHAR; 112],\n }\n \n-#[repr(C)]\n-pub struct ADDRINFOA {\n-    pub ai_flags: c_int,\n-    pub ai_family: c_int,\n-    pub ai_socktype: c_int,\n-    pub ai_protocol: c_int,\n-    pub ai_addrlen: size_t,\n-    pub ai_canonname: *mut c_char,\n-    pub ai_addr: *mut SOCKADDR,\n-    pub ai_next: *mut ADDRINFOA,\n-}\n-\n #[repr(C)]\n #[derive(Copy, Clone)]\n pub struct sockaddr_in {\n@@ -742,583 +192,126 @@ pub struct in6_addr {\n     pub s6_addr: [u8; 16],\n }\n \n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-#[allow(dead_code)] // we only use some variants\n-pub enum EXCEPTION_DISPOSITION {\n-    ExceptionContinueExecution,\n-    ExceptionContinueSearch,\n-    ExceptionNestedException,\n-    ExceptionCollidedUnwind,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy)]\n-pub struct fd_set {\n-    pub fd_count: c_uint,\n-    pub fd_array: [SOCKET; FD_SETSIZE],\n-}\n-\n-impl Clone for fd_set {\n-    fn clone(&self) -> fd_set {\n-        *self\n-    }\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub struct timeval {\n-    pub tv_sec: c_long,\n-    pub tv_usec: c_long,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub struct CONSOLE_READCONSOLE_CONTROL {\n-    pub nLength: ULONG,\n-    pub nInitialChars: ULONG,\n-    pub dwCtrlWakeupMask: ULONG,\n-    pub dwControlKeyState: ULONG,\n-}\n-pub type PCONSOLE_READCONSOLE_CONTROL = *mut CONSOLE_READCONSOLE_CONTROL;\n-\n // Desktop specific functions & types\n cfg_if::cfg_if! {\n if #[cfg(not(target_vendor = \"uwp\"))] {\n-    pub const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n-    pub const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n-    pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n-\n-    #[repr(C)]\n-    pub struct EXCEPTION_RECORD {\n-        pub ExceptionCode: DWORD,\n-        pub ExceptionFlags: DWORD,\n-        pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-        pub ExceptionAddress: LPVOID,\n-        pub NumberParameters: DWORD,\n-        pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS],\n-    }\n-\n-    pub enum CONTEXT {}\n-\n-    #[repr(C)]\n-    pub struct EXCEPTION_POINTERS {\n-        pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-        pub ContextRecord: *mut CONTEXT,\n-    }\n-\n-    pub type PVECTORED_EXCEPTION_HANDLER =\n-        extern \"system\" fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n-\n-    #[repr(C)]\n-    pub struct BY_HANDLE_FILE_INFORMATION {\n-        pub dwFileAttributes: DWORD,\n-        pub ftCreationTime: FILETIME,\n-        pub ftLastAccessTime: FILETIME,\n-        pub ftLastWriteTime: FILETIME,\n-        pub dwVolumeSerialNumber: DWORD,\n-        pub nFileSizeHigh: DWORD,\n-        pub nFileSizeLow: DWORD,\n-        pub nNumberOfLinks: DWORD,\n-        pub nFileIndexHigh: DWORD,\n-        pub nFileIndexLow: DWORD,\n-    }\n-\n-    pub type LPBY_HANDLE_FILE_INFORMATION = *mut BY_HANDLE_FILE_INFORMATION;\n-\n-    pub const HANDLE_FLAG_INHERIT: DWORD = 0x00000001;\n-\n-    pub const TOKEN_READ: DWORD = 0x20008;\n-\n-    #[link(name = \"advapi32\")]\n-    extern \"system\" {\n-        // Forbidden when targeting UWP\n-        #[link_name = \"SystemFunction036\"]\n-        pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;\n-\n-        // Allowed but unused by UWP\n-        pub fn OpenProcessToken(\n-            ProcessHandle: HANDLE,\n-            DesiredAccess: DWORD,\n-            TokenHandle: *mut HANDLE,\n-        ) -> BOOL;\n-    }\n-\n-    #[link(name = \"userenv\")]\n-    extern \"system\" {\n-        // Allowed but unused by UWP\n-        pub fn GetUserProfileDirectoryW(\n-            hToken: HANDLE,\n-            lpProfileDir: LPWSTR,\n-            lpcchSize: *mut DWORD,\n-        ) -> BOOL;\n-    }\n-\n-    #[link(name = \"kernel32\")]\n-    extern \"system\" {\n-        // Allowed but unused by UWP\n-        pub fn GetFileInformationByHandle(\n-            hFile: HANDLE,\n-            lpFileInformation: LPBY_HANDLE_FILE_INFORMATION,\n-        ) -> BOOL;\n-        pub fn SetHandleInformation(hObject: HANDLE, dwMask: DWORD, dwFlags: DWORD) -> BOOL;\n-        pub fn AddVectoredExceptionHandler(\n-            FirstHandler: ULONG,\n-            VectoredHandler: PVECTORED_EXCEPTION_HANDLER,\n-        ) -> LPVOID;\n-        pub fn CreateHardLinkW(\n-            lpSymlinkFileName: LPCWSTR,\n-            lpTargetFileName: LPCWSTR,\n-            lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n-        ) -> BOOL;\n-        pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL;\n-        pub fn GetWindowsDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;\n-    }\n-}\n-}\n-\n-// UWP specific functions & types\n-cfg_if::cfg_if! {\n-if #[cfg(target_vendor = \"uwp\")] {\n-    #[repr(C)]\n-    pub struct FILE_STANDARD_INFO {\n-        pub AllocationSize: LARGE_INTEGER,\n-        pub EndOfFile: LARGE_INTEGER,\n-        pub NumberOfLinks: DWORD,\n-        pub DeletePending: BOOLEAN,\n-        pub Directory: BOOLEAN,\n-    }\n-}\n-}\n-\n-// Shared between Desktop & UWP\n-\n-#[link(name = \"kernel32\")]\n-extern \"system\" {\n-    pub fn GetCurrentProcessId() -> DWORD;\n-\n-    pub fn ReadConsoleW(\n-        hConsoleInput: HANDLE,\n-        lpBuffer: LPVOID,\n-        nNumberOfCharsToRead: DWORD,\n-        lpNumberOfCharsRead: LPDWORD,\n-        pInputControl: PCONSOLE_READCONSOLE_CONTROL,\n-    ) -> BOOL;\n-    pub fn WriteConsoleW(\n-        hConsoleOutput: HANDLE,\n-        lpBuffer: LPCVOID,\n-        nNumberOfCharsToWrite: DWORD,\n-        lpNumberOfCharsWritten: LPDWORD,\n-        lpReserved: LPVOID,\n-    ) -> BOOL;\n-    pub fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n-\n-    pub fn GetSystemDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;\n-    pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n-    pub fn SetFileAttributesW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) -> BOOL;\n-    pub fn SetFileTime(\n-        hFile: BorrowedHandle<'_>,\n-        lpCreationTime: Option<&FILETIME>,\n-        lpLastAccessTime: Option<&FILETIME>,\n-        lpLastWriteTime: Option<&FILETIME>,\n-    ) -> BOOL;\n-    pub fn SetLastError(dwErrCode: DWORD);\n-    pub fn GetCommandLineW() -> LPWSTR;\n-    pub fn GetTempPathW(nBufferLength: DWORD, lpBuffer: LPCWSTR) -> DWORD;\n-    pub fn GetCurrentProcess() -> HANDLE;\n-    pub fn GetCurrentThread() -> HANDLE;\n-    pub fn GetStdHandle(which: DWORD) -> HANDLE;\n-    pub fn ExitProcess(uExitCode: c_uint) -> !;\n-    pub fn DeviceIoControl(\n-        hDevice: HANDLE,\n-        dwIoControlCode: DWORD,\n-        lpInBuffer: LPVOID,\n-        nInBufferSize: DWORD,\n-        lpOutBuffer: LPVOID,\n-        nOutBufferSize: DWORD,\n-        lpBytesReturned: LPDWORD,\n-        lpOverlapped: LPOVERLAPPED,\n-    ) -> BOOL;\n-    pub fn CreateThread(\n-        lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n-        dwStackSize: SIZE_T,\n-        lpStartAddress: extern \"system\" fn(*mut c_void) -> DWORD,\n-        lpParameter: LPVOID,\n-        dwCreationFlags: DWORD,\n-        lpThreadId: LPDWORD,\n-    ) -> HandleOrNull;\n-    pub fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n-    pub fn SwitchToThread() -> BOOL;\n-    pub fn Sleep(dwMilliseconds: DWORD);\n-    pub fn SleepEx(dwMilliseconds: DWORD, bAlertable: BOOL) -> DWORD;\n-    pub fn GetProcessId(handle: HANDLE) -> DWORD;\n-    pub fn CopyFileExW(\n-        lpExistingFileName: LPCWSTR,\n-        lpNewFileName: LPCWSTR,\n-        lpProgressRoutine: LPPROGRESS_ROUTINE,\n-        lpData: LPVOID,\n-        pbCancel: LPBOOL,\n-        dwCopyFlags: DWORD,\n-    ) -> BOOL;\n-    pub fn FormatMessageW(\n-        flags: DWORD,\n-        lpSrc: LPVOID,\n-        msgId: DWORD,\n-        langId: DWORD,\n-        buf: LPWSTR,\n-        nsize: DWORD,\n-        args: *const c_void,\n-    ) -> DWORD;\n-    pub fn TlsAlloc() -> DWORD;\n-    pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n-    pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n-    pub fn TlsFree(dwTlsIndex: DWORD) -> BOOL;\n-    pub fn GetLastError() -> DWORD;\n-    pub fn QueryPerformanceFrequency(lpFrequency: *mut LARGE_INTEGER) -> BOOL;\n-    pub fn QueryPerformanceCounter(lpPerformanceCount: *mut LARGE_INTEGER) -> BOOL;\n-    pub fn GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) -> BOOL;\n-    pub fn TerminateProcess(hProcess: HANDLE, uExitCode: UINT) -> BOOL;\n-    pub fn CreateProcessW(\n-        lpApplicationName: LPCWSTR,\n-        lpCommandLine: LPWSTR,\n-        lpProcessAttributes: LPSECURITY_ATTRIBUTES,\n-        lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n-        bInheritHandles: BOOL,\n-        dwCreationFlags: DWORD,\n-        lpEnvironment: LPVOID,\n-        lpCurrentDirectory: LPCWSTR,\n-        lpStartupInfo: LPSTARTUPINFO,\n-        lpProcessInformation: LPPROCESS_INFORMATION,\n-    ) -> BOOL;\n-    pub fn GetEnvironmentVariableW(n: LPCWSTR, v: LPWSTR, nsize: DWORD) -> DWORD;\n-    pub fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR) -> BOOL;\n-    pub fn GetEnvironmentStringsW() -> LPWCH;\n-    pub fn FreeEnvironmentStringsW(env_ptr: LPWCH) -> BOOL;\n-    pub fn GetModuleFileNameW(hModule: HMODULE, lpFilename: LPWSTR, nSize: DWORD) -> DWORD;\n-    pub fn CreateDirectoryW(\n-        lpPathName: LPCWSTR,\n-        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n-    ) -> BOOL;\n-    pub fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;\n-    pub fn GetCurrentDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;\n-    pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n-    pub fn DuplicateHandle(\n-        hSourceProcessHandle: HANDLE,\n-        hSourceHandle: HANDLE,\n-        hTargetProcessHandle: HANDLE,\n-        lpTargetHandle: LPHANDLE,\n-        dwDesiredAccess: DWORD,\n-        bInheritHandle: BOOL,\n-        dwOptions: DWORD,\n-    ) -> BOOL;\n-    pub fn ReadFile(\n-        hFile: BorrowedHandle<'_>,\n-        lpBuffer: LPVOID,\n-        nNumberOfBytesToRead: DWORD,\n-        lpNumberOfBytesRead: LPDWORD,\n-        lpOverlapped: LPOVERLAPPED,\n-    ) -> BOOL;\n-    pub fn ReadFileEx(\n-        hFile: BorrowedHandle<'_>,\n-        lpBuffer: LPVOID,\n-        nNumberOfBytesToRead: DWORD,\n-        lpOverlapped: LPOVERLAPPED,\n-        lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,\n-    ) -> BOOL;\n-    pub fn WriteFileEx(\n-        hFile: BorrowedHandle<'_>,\n-        lpBuffer: LPVOID,\n-        nNumberOfBytesToWrite: DWORD,\n-        lpOverlapped: LPOVERLAPPED,\n-        lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,\n-    ) -> BOOL;\n-    pub fn CloseHandle(hObject: HANDLE) -> BOOL;\n-    pub fn MoveFileExW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, dwFlags: DWORD)\n-    -> BOOL;\n-    pub fn SetFilePointerEx(\n-        hFile: HANDLE,\n-        liDistanceToMove: LARGE_INTEGER,\n-        lpNewFilePointer: PLARGE_INTEGER,\n-        dwMoveMethod: DWORD,\n-    ) -> BOOL;\n-    pub fn FlushFileBuffers(hFile: HANDLE) -> BOOL;\n-    pub fn CreateFileW(\n-        lpFileName: LPCWSTR,\n-        dwDesiredAccess: DWORD,\n-        dwShareMode: DWORD,\n-        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n-        dwCreationDisposition: DWORD,\n-        dwFlagsAndAttributes: DWORD,\n-        hTemplateFile: HANDLE,\n-    ) -> HandleOrInvalid;\n-\n-    pub fn FindFirstFileW(fileName: LPCWSTR, findFileData: LPWIN32_FIND_DATAW) -> HANDLE;\n-    pub fn FindNextFileW(findFile: HANDLE, findFileData: LPWIN32_FIND_DATAW) -> BOOL;\n-    pub fn FindClose(findFile: HANDLE) -> BOOL;\n-\n-    pub fn GetProcAddress(handle: HMODULE, name: LPCSTR) -> *mut c_void;\n-    pub fn GetModuleHandleA(lpModuleName: LPCSTR) -> HMODULE;\n-    pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n-\n-    pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);\n-    pub fn GetSystemInfo(lpSystemInfo: LPSYSTEM_INFO);\n-\n-    pub fn CreateEventW(\n-        lpEventAttributes: LPSECURITY_ATTRIBUTES,\n-        bManualReset: BOOL,\n-        bInitialState: BOOL,\n-        lpName: LPCWSTR,\n-    ) -> HANDLE;\n-    pub fn WaitForMultipleObjects(\n-        nCount: DWORD,\n-        lpHandles: *const HANDLE,\n-        bWaitAll: BOOL,\n-        dwMilliseconds: DWORD,\n-    ) -> DWORD;\n-    pub fn CreateNamedPipeW(\n-        lpName: LPCWSTR,\n-        dwOpenMode: DWORD,\n-        dwPipeMode: DWORD,\n-        nMaxInstances: DWORD,\n-        nOutBufferSize: DWORD,\n-        nInBufferSize: DWORD,\n-        nDefaultTimeOut: DWORD,\n-        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n-    ) -> HANDLE;\n-    pub fn CancelIo(handle: HANDLE) -> BOOL;\n-    pub fn GetOverlappedResult(\n-        hFile: HANDLE,\n-        lpOverlapped: LPOVERLAPPED,\n-        lpNumberOfBytesTransferred: LPDWORD,\n-        bWait: BOOL,\n-    ) -> BOOL;\n-    pub fn CreateSymbolicLinkW(\n-        lpSymlinkFileName: LPCWSTR,\n-        lpTargetFileName: LPCWSTR,\n-        dwFlags: DWORD,\n-    ) -> BOOLEAN;\n-    pub fn GetFinalPathNameByHandleW(\n-        hFile: HANDLE,\n-        lpszFilePath: LPCWSTR,\n-        cchFilePath: DWORD,\n-        dwFlags: DWORD,\n-    ) -> DWORD;\n-    pub fn GetFileInformationByHandleEx(\n-        hFile: HANDLE,\n-        fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n-        lpFileInformation: LPVOID,\n-        dwBufferSize: DWORD,\n-    ) -> BOOL;\n-    pub fn SetFileInformationByHandle(\n-        hFile: HANDLE,\n-        FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n-        lpFileInformation: LPVOID,\n-        dwBufferSize: DWORD,\n-    ) -> BOOL;\n-    pub fn GetFileType(hfile: HANDLE) -> DWORD;\n-    pub fn SleepConditionVariableSRW(\n-        ConditionVariable: PCONDITION_VARIABLE,\n-        SRWLock: PSRWLOCK,\n-        dwMilliseconds: DWORD,\n-        Flags: ULONG,\n-    ) -> BOOL;\n-\n-    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n-    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n-\n-    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);\n-    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);\n-    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);\n-    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK);\n-    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;\n-    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;\n-\n-    pub fn InitOnceBeginInitialize(\n-        lpInitOnce: LPINIT_ONCE,\n-        dwFlags: DWORD,\n-        fPending: LPBOOL,\n-        lpContext: *mut LPVOID,\n-    ) -> BOOL;\n-    pub fn InitOnceComplete(lpInitOnce: LPINIT_ONCE, dwFlags: DWORD, lpContext: LPVOID) -> BOOL;\n-\n-    pub fn CompareStringOrdinal(\n-        lpString1: LPCWSTR,\n-        cchCount1: c_int,\n-        lpString2: LPCWSTR,\n-        cchCount2: c_int,\n-        bIgnoreCase: BOOL,\n-    ) -> c_int;\n-    pub fn GetFullPathNameW(\n-        lpFileName: LPCWSTR,\n-        nBufferLength: DWORD,\n-        lpBuffer: LPWSTR,\n-        lpFilePart: *mut LPWSTR,\n-    ) -> DWORD;\n-    pub fn GetFileAttributesW(lpFileName: LPCWSTR) -> DWORD;\n-\n-    pub fn MultiByteToWideChar(\n-        CodePage: UINT,\n-        dwFlags: DWORD,\n-        lpMultiByteStr: LPCCH,\n-        cbMultiByte: c_int,\n-        lpWideCharStr: LPWSTR,\n-        cchWideChar: c_int,\n-    ) -> c_int;\n-    pub fn WideCharToMultiByte(\n-        CodePage: UINT,\n-        dwFlags: DWORD,\n-        lpWideCharStr: LPCWCH,\n-        cchWideChar: c_int,\n-        lpMultiByteStr: LPSTR,\n-        cbMultiByte: c_int,\n-        lpDefaultChar: LPCCH,\n-        lpUsedDefaultChar: LPBOOL,\n-    ) -> c_int;\n+    pub const EXCEPTION_CONTINUE_SEARCH: i32 = 0;\n }\n-\n-#[link(name = \"ws2_32\")]\n-extern \"system\" {\n-    pub fn WSAStartup(wVersionRequested: WORD, lpWSAData: LPWSADATA) -> c_int;\n-    pub fn WSACleanup() -> c_int;\n-    pub fn WSAGetLastError() -> c_int;\n-    pub fn WSADuplicateSocketW(\n-        s: SOCKET,\n-        dwProcessId: DWORD,\n-        lpProtocolInfo: LPWSAPROTOCOL_INFO,\n-    ) -> c_int;\n-    pub fn WSASend(\n-        s: SOCKET,\n-        lpBuffers: LPWSABUF,\n-        dwBufferCount: DWORD,\n-        lpNumberOfBytesSent: LPDWORD,\n-        dwFlags: DWORD,\n-        lpOverlapped: LPWSAOVERLAPPED,\n-        lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,\n-    ) -> c_int;\n-    pub fn WSARecv(\n-        s: SOCKET,\n-        lpBuffers: LPWSABUF,\n-        dwBufferCount: DWORD,\n-        lpNumberOfBytesRecvd: LPDWORD,\n-        lpFlags: LPDWORD,\n-        lpOverlapped: LPWSAOVERLAPPED,\n-        lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,\n-    ) -> c_int;\n-    pub fn WSASocketW(\n-        af: c_int,\n-        kind: c_int,\n-        protocol: c_int,\n-        lpProtocolInfo: LPWSAPROTOCOL_INFO,\n-        g: GROUP,\n-        dwFlags: DWORD,\n-    ) -> SOCKET;\n-    pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut c_ulong) -> c_int;\n-    pub fn closesocket(socket: SOCKET) -> c_int;\n-    pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int, flags: c_int) -> c_int;\n-    pub fn send(socket: SOCKET, buf: *const c_void, len: c_int, flags: c_int) -> c_int;\n-    pub fn recvfrom(\n-        socket: SOCKET,\n-        buf: *mut c_void,\n-        len: c_int,\n-        flags: c_int,\n-        addr: *mut SOCKADDR,\n-        addrlen: *mut c_int,\n-    ) -> c_int;\n-    pub fn sendto(\n-        socket: SOCKET,\n-        buf: *const c_void,\n-        len: c_int,\n-        flags: c_int,\n-        addr: *const SOCKADDR,\n-        addrlen: c_int,\n-    ) -> c_int;\n-    pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;\n-    pub fn accept(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> SOCKET;\n-    pub fn getsockopt(\n-        s: SOCKET,\n-        level: c_int,\n-        optname: c_int,\n-        optval: *mut c_char,\n-        optlen: *mut c_int,\n-    ) -> c_int;\n-    pub fn setsockopt(\n-        s: SOCKET,\n-        level: c_int,\n-        optname: c_int,\n-        optval: *const c_void,\n-        optlen: c_int,\n-    ) -> c_int;\n-    pub fn getsockname(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;\n-    pub fn getpeername(socket: SOCKET, address: *mut SOCKADDR, address_len: *mut c_int) -> c_int;\n-    pub fn bind(socket: SOCKET, address: *const SOCKADDR, address_len: socklen_t) -> c_int;\n-    pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;\n-    pub fn connect(socket: SOCKET, address: *const SOCKADDR, len: c_int) -> c_int;\n-    pub fn getaddrinfo(\n-        node: *const c_char,\n-        service: *const c_char,\n-        hints: *const ADDRINFOA,\n-        res: *mut *mut ADDRINFOA,\n-    ) -> c_int;\n-    pub fn freeaddrinfo(res: *mut ADDRINFOA);\n-    pub fn select(\n-        nfds: c_int,\n-        readfds: *mut fd_set,\n-        writefds: *mut fd_set,\n-        exceptfds: *mut fd_set,\n-        timeout: *const timeval,\n-    ) -> c_int;\n-}\n-\n-#[link(name = \"bcrypt\")]\n-extern \"system\" {\n-    // >= Vista / Server 2008\n-    // https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom\n-    pub fn BCryptGenRandom(\n-        hAlgorithm: BCRYPT_ALG_HANDLE,\n-        pBuffer: *mut u8,\n-        cbBuffer: ULONG,\n-        dwFlags: ULONG,\n-    ) -> NTSTATUS;\n }\n \n-#[link(name = \"ntdll\")]\n-extern \"system\" {\n-    pub fn NtCreateFile(\n-        FileHandle: *mut HANDLE,\n-        DesiredAccess: ACCESS_MASK,\n-        ObjectAttributes: *const OBJECT_ATTRIBUTES,\n-        IoStatusBlock: *mut IO_STATUS_BLOCK,\n-        AllocationSize: *mut i64,\n-        FileAttributes: ULONG,\n-        ShareAccess: ULONG,\n-        CreateDisposition: ULONG,\n-        CreateOptions: ULONG,\n-        EaBuffer: *mut c_void,\n-        EaLength: ULONG,\n-    ) -> NTSTATUS;\n-    pub fn NtReadFile(\n-        FileHandle: BorrowedHandle<'_>,\n-        Event: HANDLE,\n-        ApcRoutine: Option<IO_APC_ROUTINE>,\n-        ApcContext: *mut c_void,\n-        IoStatusBlock: &mut IO_STATUS_BLOCK,\n-        Buffer: *mut crate::mem::MaybeUninit<u8>,\n-        Length: ULONG,\n-        ByteOffset: Option<&LARGE_INTEGER>,\n-        Key: Option<&ULONG>,\n-    ) -> NTSTATUS;\n-    pub fn NtWriteFile(\n-        FileHandle: BorrowedHandle<'_>,\n-        Event: HANDLE,\n-        ApcRoutine: Option<IO_APC_ROUTINE>,\n-        ApcContext: *mut c_void,\n-        IoStatusBlock: &mut IO_STATUS_BLOCK,\n-        Buffer: *const u8,\n-        Length: ULONG,\n-        ByteOffset: Option<&LARGE_INTEGER>,\n-        Key: Option<&ULONG>,\n-    ) -> NTSTATUS;\n-    pub fn RtlNtStatusToDosError(Status: NTSTATUS) -> ULONG;\n+pub unsafe extern \"system\" fn WriteFileEx(\n+    hFile: BorrowedHandle<'_>,\n+    lpBuffer: *mut ::core::ffi::c_void,\n+    nNumberOfBytesToWrite: u32,\n+    lpOverlapped: *mut OVERLAPPED,\n+    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,\n+) -> BOOL {\n+    windows_sys::WriteFileEx(\n+        hFile.as_raw_handle(),\n+        lpBuffer.cast::<u8>(),\n+        nNumberOfBytesToWrite,\n+        lpOverlapped,\n+        lpCompletionRoutine,\n+    )\n+}\n+\n+pub unsafe extern \"system\" fn ReadFileEx(\n+    hFile: BorrowedHandle<'_>,\n+    lpBuffer: *mut ::core::ffi::c_void,\n+    nNumberOfBytesToRead: u32,\n+    lpOverlapped: *mut OVERLAPPED,\n+    lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,\n+) -> BOOL {\n+    windows_sys::ReadFileEx(\n+        hFile.as_raw_handle(),\n+        lpBuffer,\n+        nNumberOfBytesToRead,\n+        lpOverlapped,\n+        lpCompletionRoutine,\n+    )\n+}\n+\n+// POSIX compatibility shims.\n+pub unsafe fn recv(socket: SOCKET, buf: *mut c_void, len: c_int, flags: c_int) -> c_int {\n+    windows_sys::recv(socket, buf.cast::<u8>(), len, flags)\n+}\n+pub unsafe fn send(socket: SOCKET, buf: *const c_void, len: c_int, flags: c_int) -> c_int {\n+    windows_sys::send(socket, buf.cast::<u8>(), len, flags)\n+}\n+pub unsafe fn recvfrom(\n+    socket: SOCKET,\n+    buf: *mut c_void,\n+    len: c_int,\n+    flags: c_int,\n+    addr: *mut SOCKADDR,\n+    addrlen: *mut c_int,\n+) -> c_int {\n+    windows_sys::recvfrom(socket, buf.cast::<u8>(), len, flags, addr, addrlen)\n+}\n+pub unsafe fn sendto(\n+    socket: SOCKET,\n+    buf: *const c_void,\n+    len: c_int,\n+    flags: c_int,\n+    addr: *const SOCKADDR,\n+    addrlen: c_int,\n+) -> c_int {\n+    windows_sys::sendto(socket, buf.cast::<u8>(), len, flags, addr, addrlen)\n+}\n+pub unsafe fn getaddrinfo(\n+    node: *const c_char,\n+    service: *const c_char,\n+    hints: *const ADDRINFOA,\n+    res: *mut *mut ADDRINFOA,\n+) -> c_int {\n+    windows_sys::getaddrinfo(node.cast::<u8>(), service.cast::<u8>(), hints, res)\n+}\n+\n+pub unsafe fn NtReadFile(\n+    filehandle: BorrowedHandle<'_>,\n+    event: HANDLE,\n+    apcroutine: PIO_APC_ROUTINE,\n+    apccontext: *mut c_void,\n+    iostatusblock: &mut IO_STATUS_BLOCK,\n+    buffer: *mut crate::mem::MaybeUninit<u8>,\n+    length: ULONG,\n+    byteoffset: Option<&LARGE_INTEGER>,\n+    key: Option<&ULONG>,\n+) -> NTSTATUS {\n+    windows_sys::NtReadFile(\n+        filehandle.as_raw_handle(),\n+        event,\n+        apcroutine,\n+        apccontext,\n+        iostatusblock,\n+        buffer.cast::<c_void>(),\n+        length,\n+        byteoffset.map(|o| o as *const i64).unwrap_or(ptr::null()),\n+        key.map(|k| k as *const u32).unwrap_or(ptr::null()),\n+    )\n+}\n+pub unsafe fn NtWriteFile(\n+    filehandle: BorrowedHandle<'_>,\n+    event: HANDLE,\n+    apcroutine: PIO_APC_ROUTINE,\n+    apccontext: *mut c_void,\n+    iostatusblock: &mut IO_STATUS_BLOCK,\n+    buffer: *const u8,\n+    length: ULONG,\n+    byteoffset: Option<&LARGE_INTEGER>,\n+    key: Option<&ULONG>,\n+) -> NTSTATUS {\n+    windows_sys::NtWriteFile(\n+        filehandle.as_raw_handle(),\n+        event,\n+        apcroutine,\n+        apccontext,\n+        iostatusblock,\n+        buffer.cast::<c_void>(),\n+        length,\n+        byteoffset.map(|o| o as *const i64).unwrap_or(ptr::null()),\n+        key.map(|k| k as *const u32).unwrap_or(ptr::null()),\n+    )\n }\n \n // Functions that aren't available on every version of Windows that we support,\n@@ -1328,34 +321,32 @@ compat_fn_with_fallback! {\n \n     // >= Win10 1607\n     // https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreaddescription\n-    pub fn SetThreadDescription(hThread: HANDLE,\n-                                lpThreadDescription: LPCWSTR) -> HRESULT {\n+    pub fn SetThreadDescription(hthread: HANDLE, lpthreaddescription: PCWSTR) -> HRESULT {\n         SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); E_NOTIMPL\n     }\n \n     // >= Win8 / Server 2012\n     // https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimepreciseasfiletime\n-    pub fn GetSystemTimePreciseAsFileTime(lpSystemTimeAsFileTime: LPFILETIME)\n-                                          -> () {\n-        GetSystemTimeAsFileTime(lpSystemTimeAsFileTime)\n+    pub fn GetSystemTimePreciseAsFileTime(lpsystemtimeasfiletime: *mut FILETIME) -> () {\n+        GetSystemTimeAsFileTime(lpsystemtimeasfiletime)\n     }\n \n     // >= Win11 / Server 2022\n     // https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppath2a\n-    pub fn GetTempPath2W(nBufferLength: DWORD, lpBuffer: LPCWSTR) -> DWORD {\n-        GetTempPathW(nBufferLength, lpBuffer)\n+    pub fn GetTempPath2W(bufferlength: u32, buffer: PWSTR) -> u32 {\n+        GetTempPathW(bufferlength, buffer)\n     }\n }\n \n compat_fn_optional! {\n     crate::sys::compat::load_synch_functions();\n     pub fn WaitOnAddress(\n-        Address: LPVOID,\n-        CompareAddress: LPVOID,\n-        AddressSize: SIZE_T,\n-        dwMilliseconds: DWORD\n-    );\n-    pub fn WakeByAddressSingle(Address: LPVOID);\n+        address: *const ::core::ffi::c_void,\n+        compareaddress: *const ::core::ffi::c_void,\n+        addresssize: usize,\n+        dwmilliseconds: u32\n+    ) -> BOOL;\n+    pub fn WakeByAddressSingle(address: *const ::core::ffi::c_void);\n }\n \n compat_fn_with_fallback! {"}, {"sha": "ad8da19b6daa8332d858520766578f230b1a356e", "filename": "library/std/src/sys/windows/c/errors.rs", "status": "removed", "additions": 0, "deletions": 1883, "changes": 1883, "blob_url": "https://github.com/rust-lang/rust/blob/7fb4332ce452875b0f86dd62be0b1356e6d9537d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb4332ce452875b0f86dd62be0b1356e6d9537d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc%2Ferrors.rs?ref=7fb4332ce452875b0f86dd62be0b1356e6d9537d", "patch": "@@ -1,1883 +0,0 @@\n-// List of Windows system error codes with descriptions:\n-// https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes#system-error-codes\n-\n-#![allow(dead_code)]\n-\n-use super::{c_int, DWORD};\n-\n-pub const ERROR_DIRECTORY_NOT_SUPPORTED: DWORD = 336;\n-pub const ERROR_DRIVER_CANCEL_TIMEOUT: DWORD = 594;\n-pub const ERROR_DISK_QUOTA_EXCEEDED: DWORD = 1295;\n-pub const ERROR_RESOURCE_CALL_TIMED_OUT: DWORD = 5910;\n-pub const FRS_ERR_SYSVOL_POPULATE_TIMEOUT: DWORD = 8014;\n-pub const DNS_ERROR_RECORD_TIMED_OUT: DWORD = 9705;\n-\n-// The following list was obtained from\n-//   `/usr/x86_64-w64-mingw32/include/winerror.h`\n-// in the Debian package\n-//   mingw-w64_6.0.0-3_all.deb\n-//\n-// The header of that file says:\n-//   * This file has no copyright assigned and is placed in the Public Domain.\n-//   * This file is part of the mingw-w64 runtime package.\n-//   * No warranty is given; refer to the file DISCLAIMER.PD within this package.\n-//\n-// The text here is the result of the following rune:\n-//   grep -P '#define ERROR' /usr/x86_64-w64-mingw32/include/winerror.h >>library/std/src/sys/windows/c/errors.rs\n-//   grep -P '#define WSA' /usr/x86_64-w64-mingw32/include/winerror.h >>library/std/src/sys/windows/c/errors.rs\n-// and then using some manually-invented but rather obvious editor search-and-replace\n-// invocations, plus some straightforward manual fixups, to turn it into Rust syntax\n-// and remove all the duplicates from the manual table above.\n-\n-pub const ERROR_SUCCESS: DWORD = 0;\n-pub const ERROR_INVALID_FUNCTION: DWORD = 1;\n-pub const ERROR_FILE_NOT_FOUND: DWORD = 2;\n-pub const ERROR_PATH_NOT_FOUND: DWORD = 3;\n-pub const ERROR_TOO_MANY_OPEN_FILES: DWORD = 4;\n-pub const ERROR_ACCESS_DENIED: DWORD = 5;\n-pub const ERROR_INVALID_HANDLE: DWORD = 6;\n-pub const ERROR_ARENA_TRASHED: DWORD = 7;\n-pub const ERROR_NOT_ENOUGH_MEMORY: DWORD = 8;\n-pub const ERROR_INVALID_BLOCK: DWORD = 9;\n-pub const ERROR_BAD_ENVIRONMENT: DWORD = 10;\n-pub const ERROR_BAD_FORMAT: DWORD = 11;\n-pub const ERROR_INVALID_ACCESS: DWORD = 12;\n-pub const ERROR_INVALID_DATA: DWORD = 13;\n-pub const ERROR_OUTOFMEMORY: DWORD = 14;\n-pub const ERROR_INVALID_DRIVE: DWORD = 15;\n-pub const ERROR_CURRENT_DIRECTORY: DWORD = 16;\n-pub const ERROR_NOT_SAME_DEVICE: DWORD = 17;\n-pub const ERROR_NO_MORE_FILES: DWORD = 18;\n-pub const ERROR_WRITE_PROTECT: DWORD = 19;\n-pub const ERROR_BAD_UNIT: DWORD = 20;\n-pub const ERROR_NOT_READY: DWORD = 21;\n-pub const ERROR_BAD_COMMAND: DWORD = 22;\n-pub const ERROR_CRC: DWORD = 23;\n-pub const ERROR_BAD_LENGTH: DWORD = 24;\n-pub const ERROR_SEEK: DWORD = 25;\n-pub const ERROR_NOT_DOS_DISK: DWORD = 26;\n-pub const ERROR_SECTOR_NOT_FOUND: DWORD = 27;\n-pub const ERROR_OUT_OF_PAPER: DWORD = 28;\n-pub const ERROR_WRITE_FAULT: DWORD = 29;\n-pub const ERROR_READ_FAULT: DWORD = 30;\n-pub const ERROR_GEN_FAILURE: DWORD = 31;\n-pub const ERROR_SHARING_VIOLATION: DWORD = 32;\n-pub const ERROR_LOCK_VIOLATION: DWORD = 33;\n-pub const ERROR_WRONG_DISK: DWORD = 34;\n-pub const ERROR_SHARING_BUFFER_EXCEEDED: DWORD = 36;\n-pub const ERROR_HANDLE_EOF: DWORD = 38;\n-pub const ERROR_HANDLE_DISK_FULL: DWORD = 39;\n-pub const ERROR_NOT_SUPPORTED: DWORD = 50;\n-pub const ERROR_REM_NOT_LIST: DWORD = 51;\n-pub const ERROR_DUP_NAME: DWORD = 52;\n-pub const ERROR_BAD_NETPATH: DWORD = 53;\n-pub const ERROR_NETWORK_BUSY: DWORD = 54;\n-pub const ERROR_DEV_NOT_EXIST: DWORD = 55;\n-pub const ERROR_TOO_MANY_CMDS: DWORD = 56;\n-pub const ERROR_ADAP_HDW_ERR: DWORD = 57;\n-pub const ERROR_BAD_NET_RESP: DWORD = 58;\n-pub const ERROR_UNEXP_NET_ERR: DWORD = 59;\n-pub const ERROR_BAD_REM_ADAP: DWORD = 60;\n-pub const ERROR_PRINTQ_FULL: DWORD = 61;\n-pub const ERROR_NO_SPOOL_SPACE: DWORD = 62;\n-pub const ERROR_PRINT_CANCELLED: DWORD = 63;\n-pub const ERROR_NETNAME_DELETED: DWORD = 64;\n-pub const ERROR_NETWORK_ACCESS_DENIED: DWORD = 65;\n-pub const ERROR_BAD_DEV_TYPE: DWORD = 66;\n-pub const ERROR_BAD_NET_NAME: DWORD = 67;\n-pub const ERROR_TOO_MANY_NAMES: DWORD = 68;\n-pub const ERROR_TOO_MANY_SESS: DWORD = 69;\n-pub const ERROR_SHARING_PAUSED: DWORD = 70;\n-pub const ERROR_REQ_NOT_ACCEP: DWORD = 71;\n-pub const ERROR_REDIR_PAUSED: DWORD = 72;\n-pub const ERROR_FILE_EXISTS: DWORD = 80;\n-pub const ERROR_CANNOT_MAKE: DWORD = 82;\n-pub const ERROR_FAIL_I24: DWORD = 83;\n-pub const ERROR_OUT_OF_STRUCTURES: DWORD = 84;\n-pub const ERROR_ALREADY_ASSIGNED: DWORD = 85;\n-pub const ERROR_INVALID_PASSWORD: DWORD = 86;\n-pub const ERROR_INVALID_PARAMETER: DWORD = 87;\n-pub const ERROR_NET_WRITE_FAULT: DWORD = 88;\n-pub const ERROR_NO_PROC_SLOTS: DWORD = 89;\n-pub const ERROR_TOO_MANY_SEMAPHORES: DWORD = 100;\n-pub const ERROR_EXCL_SEM_ALREADY_OWNED: DWORD = 101;\n-pub const ERROR_SEM_IS_SET: DWORD = 102;\n-pub const ERROR_TOO_MANY_SEM_REQUESTS: DWORD = 103;\n-pub const ERROR_INVALID_AT_INTERRUPT_TIME: DWORD = 104;\n-pub const ERROR_SEM_OWNER_DIED: DWORD = 105;\n-pub const ERROR_SEM_USER_LIMIT: DWORD = 106;\n-pub const ERROR_DISK_CHANGE: DWORD = 107;\n-pub const ERROR_DRIVE_LOCKED: DWORD = 108;\n-pub const ERROR_BROKEN_PIPE: DWORD = 109;\n-pub const ERROR_OPEN_FAILED: DWORD = 110;\n-pub const ERROR_BUFFER_OVERFLOW: DWORD = 111;\n-pub const ERROR_DISK_FULL: DWORD = 112;\n-pub const ERROR_NO_MORE_SEARCH_HANDLES: DWORD = 113;\n-pub const ERROR_INVALID_TARGET_HANDLE: DWORD = 114;\n-pub const ERROR_INVALID_CATEGORY: DWORD = 117;\n-pub const ERROR_INVALID_VERIFY_SWITCH: DWORD = 118;\n-pub const ERROR_BAD_DRIVER_LEVEL: DWORD = 119;\n-pub const ERROR_CALL_NOT_IMPLEMENTED: DWORD = 120;\n-pub const ERROR_SEM_TIMEOUT: DWORD = 121;\n-pub const ERROR_INSUFFICIENT_BUFFER: DWORD = 122;\n-pub const ERROR_INVALID_NAME: DWORD = 123;\n-pub const ERROR_INVALID_LEVEL: DWORD = 124;\n-pub const ERROR_NO_VOLUME_LABEL: DWORD = 125;\n-pub const ERROR_MOD_NOT_FOUND: DWORD = 126;\n-pub const ERROR_PROC_NOT_FOUND: DWORD = 127;\n-pub const ERROR_WAIT_NO_CHILDREN: DWORD = 128;\n-pub const ERROR_CHILD_NOT_COMPLETE: DWORD = 129;\n-pub const ERROR_DIRECT_ACCESS_HANDLE: DWORD = 130;\n-pub const ERROR_NEGATIVE_SEEK: DWORD = 131;\n-pub const ERROR_SEEK_ON_DEVICE: DWORD = 132;\n-pub const ERROR_IS_JOIN_TARGET: DWORD = 133;\n-pub const ERROR_IS_JOINED: DWORD = 134;\n-pub const ERROR_IS_SUBSTED: DWORD = 135;\n-pub const ERROR_NOT_JOINED: DWORD = 136;\n-pub const ERROR_NOT_SUBSTED: DWORD = 137;\n-pub const ERROR_JOIN_TO_JOIN: DWORD = 138;\n-pub const ERROR_SUBST_TO_SUBST: DWORD = 139;\n-pub const ERROR_JOIN_TO_SUBST: DWORD = 140;\n-pub const ERROR_SUBST_TO_JOIN: DWORD = 141;\n-pub const ERROR_BUSY_DRIVE: DWORD = 142;\n-pub const ERROR_SAME_DRIVE: DWORD = 143;\n-pub const ERROR_DIR_NOT_ROOT: DWORD = 144;\n-pub const ERROR_DIR_NOT_EMPTY: DWORD = 145;\n-pub const ERROR_IS_SUBST_PATH: DWORD = 146;\n-pub const ERROR_IS_JOIN_PATH: DWORD = 147;\n-pub const ERROR_PATH_BUSY: DWORD = 148;\n-pub const ERROR_IS_SUBST_TARGET: DWORD = 149;\n-pub const ERROR_SYSTEM_TRACE: DWORD = 150;\n-pub const ERROR_INVALID_EVENT_COUNT: DWORD = 151;\n-pub const ERROR_TOO_MANY_MUXWAITERS: DWORD = 152;\n-pub const ERROR_INVALID_LIST_FORMAT: DWORD = 153;\n-pub const ERROR_LABEL_TOO_LONG: DWORD = 154;\n-pub const ERROR_TOO_MANY_TCBS: DWORD = 155;\n-pub const ERROR_SIGNAL_REFUSED: DWORD = 156;\n-pub const ERROR_DISCARDED: DWORD = 157;\n-pub const ERROR_NOT_LOCKED: DWORD = 158;\n-pub const ERROR_BAD_THREADID_ADDR: DWORD = 159;\n-pub const ERROR_BAD_ARGUMENTS: DWORD = 160;\n-pub const ERROR_BAD_PATHNAME: DWORD = 161;\n-pub const ERROR_SIGNAL_PENDING: DWORD = 162;\n-pub const ERROR_MAX_THRDS_REACHED: DWORD = 164;\n-pub const ERROR_LOCK_FAILED: DWORD = 167;\n-pub const ERROR_BUSY: DWORD = 170;\n-pub const ERROR_CANCEL_VIOLATION: DWORD = 173;\n-pub const ERROR_ATOMIC_LOCKS_NOT_SUPPORTED: DWORD = 174;\n-pub const ERROR_INVALID_SEGMENT_NUMBER: DWORD = 180;\n-pub const ERROR_INVALID_ORDINAL: DWORD = 182;\n-pub const ERROR_ALREADY_EXISTS: DWORD = 183;\n-pub const ERROR_INVALID_FLAG_NUMBER: DWORD = 186;\n-pub const ERROR_SEM_NOT_FOUND: DWORD = 187;\n-pub const ERROR_INVALID_STARTING_CODESEG: DWORD = 188;\n-pub const ERROR_INVALID_STACKSEG: DWORD = 189;\n-pub const ERROR_INVALID_MODULETYPE: DWORD = 190;\n-pub const ERROR_INVALID_EXE_SIGNATURE: DWORD = 191;\n-pub const ERROR_EXE_MARKED_INVALID: DWORD = 192;\n-pub const ERROR_BAD_EXE_FORMAT: DWORD = 193;\n-pub const ERROR_ITERATED_DATA_EXCEEDS_64k: DWORD = 194;\n-pub const ERROR_INVALID_MINALLOCSIZE: DWORD = 195;\n-pub const ERROR_DYNLINK_FROM_INVALID_RING: DWORD = 196;\n-pub const ERROR_IOPL_NOT_ENABLED: DWORD = 197;\n-pub const ERROR_INVALID_SEGDPL: DWORD = 198;\n-pub const ERROR_AUTODATASEG_EXCEEDS_64k: DWORD = 199;\n-pub const ERROR_RING2SEG_MUST_BE_MOVABLE: DWORD = 200;\n-pub const ERROR_RELOC_CHAIN_XEEDS_SEGLIM: DWORD = 201;\n-pub const ERROR_INFLOOP_IN_RELOC_CHAIN: DWORD = 202;\n-pub const ERROR_ENVVAR_NOT_FOUND: DWORD = 203;\n-pub const ERROR_NO_SIGNAL_SENT: DWORD = 205;\n-pub const ERROR_FILENAME_EXCED_RANGE: DWORD = 206;\n-pub const ERROR_RING2_STACK_IN_USE: DWORD = 207;\n-pub const ERROR_META_EXPANSION_TOO_LONG: DWORD = 208;\n-pub const ERROR_INVALID_SIGNAL_NUMBER: DWORD = 209;\n-pub const ERROR_THREAD_1_INACTIVE: DWORD = 210;\n-pub const ERROR_LOCKED: DWORD = 212;\n-pub const ERROR_TOO_MANY_MODULES: DWORD = 214;\n-pub const ERROR_NESTING_NOT_ALLOWED: DWORD = 215;\n-pub const ERROR_EXE_MACHINE_TYPE_MISMATCH: DWORD = 216;\n-pub const ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY: DWORD = 217;\n-pub const ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY: DWORD = 218;\n-pub const ERROR_FILE_CHECKED_OUT: DWORD = 220;\n-pub const ERROR_CHECKOUT_REQUIRED: DWORD = 221;\n-pub const ERROR_BAD_FILE_TYPE: DWORD = 222;\n-pub const ERROR_FILE_TOO_LARGE: DWORD = 223;\n-pub const ERROR_FORMS_AUTH_REQUIRED: DWORD = 224;\n-pub const ERROR_PIPE_LOCAL: DWORD = 229;\n-pub const ERROR_BAD_PIPE: DWORD = 230;\n-pub const ERROR_PIPE_BUSY: DWORD = 231;\n-pub const ERROR_NO_DATA: DWORD = 232;\n-pub const ERROR_PIPE_NOT_CONNECTED: DWORD = 233;\n-pub const ERROR_MORE_DATA: DWORD = 234;\n-pub const ERROR_VC_DISCONNECTED: DWORD = 240;\n-pub const ERROR_INVALID_EA_NAME: DWORD = 254;\n-pub const ERROR_EA_LIST_INCONSISTENT: DWORD = 255;\n-pub const ERROR_NO_MORE_ITEMS: DWORD = 259;\n-pub const ERROR_CANNOT_COPY: DWORD = 266;\n-pub const ERROR_DIRECTORY: DWORD = 267;\n-pub const ERROR_EAS_DIDNT_FIT: DWORD = 275;\n-pub const ERROR_EA_FILE_CORRUPT: DWORD = 276;\n-pub const ERROR_EA_TABLE_FULL: DWORD = 277;\n-pub const ERROR_INVALID_EA_HANDLE: DWORD = 278;\n-pub const ERROR_EAS_NOT_SUPPORTED: DWORD = 282;\n-pub const ERROR_NOT_OWNER: DWORD = 288;\n-pub const ERROR_TOO_MANY_POSTS: DWORD = 298;\n-pub const ERROR_PARTIAL_COPY: DWORD = 299;\n-pub const ERROR_OPLOCK_NOT_GRANTED: DWORD = 300;\n-pub const ERROR_INVALID_OPLOCK_PROTOCOL: DWORD = 301;\n-pub const ERROR_DISK_TOO_FRAGMENTED: DWORD = 302;\n-pub const ERROR_DELETE_PENDING: DWORD = 303;\n-pub const ERROR_INVALID_TOKEN: DWORD = 315;\n-pub const ERROR_MR_MID_NOT_FOUND: DWORD = 317;\n-pub const ERROR_SCOPE_NOT_FOUND: DWORD = 318;\n-pub const ERROR_INVALID_ADDRESS: DWORD = 487;\n-pub const ERROR_ARITHMETIC_OVERFLOW: DWORD = 534;\n-pub const ERROR_PIPE_CONNECTED: DWORD = 535;\n-pub const ERROR_PIPE_LISTENING: DWORD = 536;\n-pub const ERROR_WAKE_SYSTEM: DWORD = 730;\n-pub const ERROR_WAIT_1: DWORD = 731;\n-pub const ERROR_WAIT_2: DWORD = 732;\n-pub const ERROR_WAIT_3: DWORD = 733;\n-pub const ERROR_WAIT_63: DWORD = 734;\n-pub const ERROR_ABANDONED_WAIT_0: DWORD = 735;\n-pub const ERROR_ABANDONED_WAIT_63: DWORD = 736;\n-pub const ERROR_USER_APC: DWORD = 737;\n-pub const ERROR_KERNEL_APC: DWORD = 738;\n-pub const ERROR_ALERTED: DWORD = 739;\n-pub const ERROR_EA_ACCESS_DENIED: DWORD = 994;\n-pub const ERROR_OPERATION_ABORTED: DWORD = 995;\n-pub const ERROR_IO_INCOMPLETE: DWORD = 996;\n-pub const ERROR_IO_PENDING: DWORD = 997;\n-pub const ERROR_NOACCESS: DWORD = 998;\n-pub const ERROR_SWAPERROR: DWORD = 999;\n-pub const ERROR_STACK_OVERFLOW: DWORD = 1001;\n-pub const ERROR_INVALID_MESSAGE: DWORD = 1002;\n-pub const ERROR_CAN_NOT_COMPLETE: DWORD = 1003;\n-pub const ERROR_INVALID_FLAGS: DWORD = 1004;\n-pub const ERROR_UNRECOGNIZED_VOLUME: DWORD = 1005;\n-pub const ERROR_FILE_INVALID: DWORD = 1006;\n-pub const ERROR_FULLSCREEN_MODE: DWORD = 1007;\n-pub const ERROR_NO_TOKEN: DWORD = 1008;\n-pub const ERROR_BADDB: DWORD = 1009;\n-pub const ERROR_BADKEY: DWORD = 1010;\n-pub const ERROR_CANTOPEN: DWORD = 1011;\n-pub const ERROR_CANTREAD: DWORD = 1012;\n-pub const ERROR_CANTWRITE: DWORD = 1013;\n-pub const ERROR_REGISTRY_RECOVERED: DWORD = 1014;\n-pub const ERROR_REGISTRY_CORRUPT: DWORD = 1015;\n-pub const ERROR_REGISTRY_IO_FAILED: DWORD = 1016;\n-pub const ERROR_NOT_REGISTRY_FILE: DWORD = 1017;\n-pub const ERROR_KEY_DELETED: DWORD = 1018;\n-pub const ERROR_NO_LOG_SPACE: DWORD = 1019;\n-pub const ERROR_KEY_HAS_CHILDREN: DWORD = 1020;\n-pub const ERROR_CHILD_MUST_BE_VOLATILE: DWORD = 1021;\n-pub const ERROR_NOTIFY_ENUM_DIR: DWORD = 1022;\n-pub const ERROR_DEPENDENT_SERVICES_RUNNING: DWORD = 1051;\n-pub const ERROR_INVALID_SERVICE_CONTROL: DWORD = 1052;\n-pub const ERROR_SERVICE_REQUEST_TIMEOUT: DWORD = 1053;\n-pub const ERROR_SERVICE_NO_THREAD: DWORD = 1054;\n-pub const ERROR_SERVICE_DATABASE_LOCKED: DWORD = 1055;\n-pub const ERROR_SERVICE_ALREADY_RUNNING: DWORD = 1056;\n-pub const ERROR_INVALID_SERVICE_ACCOUNT: DWORD = 1057;\n-pub const ERROR_SERVICE_DISABLED: DWORD = 1058;\n-pub const ERROR_CIRCULAR_DEPENDENCY: DWORD = 1059;\n-pub const ERROR_SERVICE_DOES_NOT_EXIST: DWORD = 1060;\n-pub const ERROR_SERVICE_CANNOT_ACCEPT_CTRL: DWORD = 1061;\n-pub const ERROR_SERVICE_NOT_ACTIVE: DWORD = 1062;\n-pub const ERROR_FAILED_SERVICE_CONTROLLER_CONNECT: DWORD = 1063;\n-pub const ERROR_EXCEPTION_IN_SERVICE: DWORD = 1064;\n-pub const ERROR_DATABASE_DOES_NOT_EXIST: DWORD = 1065;\n-pub const ERROR_SERVICE_SPECIFIC_ERROR: DWORD = 1066;\n-pub const ERROR_PROCESS_ABORTED: DWORD = 1067;\n-pub const ERROR_SERVICE_DEPENDENCY_FAIL: DWORD = 1068;\n-pub const ERROR_SERVICE_LOGON_FAILED: DWORD = 1069;\n-pub const ERROR_SERVICE_START_HANG: DWORD = 1070;\n-pub const ERROR_INVALID_SERVICE_LOCK: DWORD = 1071;\n-pub const ERROR_SERVICE_MARKED_FOR_DELETE: DWORD = 1072;\n-pub const ERROR_SERVICE_EXISTS: DWORD = 1073;\n-pub const ERROR_ALREADY_RUNNING_LKG: DWORD = 1074;\n-pub const ERROR_SERVICE_DEPENDENCY_DELETED: DWORD = 1075;\n-pub const ERROR_BOOT_ALREADY_ACCEPTED: DWORD = 1076;\n-pub const ERROR_SERVICE_NEVER_STARTED: DWORD = 1077;\n-pub const ERROR_DUPLICATE_SERVICE_NAME: DWORD = 1078;\n-pub const ERROR_DIFFERENT_SERVICE_ACCOUNT: DWORD = 1079;\n-pub const ERROR_CANNOT_DETECT_DRIVER_FAILURE: DWORD = 1080;\n-pub const ERROR_CANNOT_DETECT_PROCESS_ABORT: DWORD = 1081;\n-pub const ERROR_NO_RECOVERY_PROGRAM: DWORD = 1082;\n-pub const ERROR_SERVICE_NOT_IN_EXE: DWORD = 1083;\n-pub const ERROR_NOT_SAFEBOOT_SERVICE: DWORD = 1084;\n-pub const ERROR_END_OF_MEDIA: DWORD = 1100;\n-pub const ERROR_FILEMARK_DETECTED: DWORD = 1101;\n-pub const ERROR_BEGINNING_OF_MEDIA: DWORD = 1102;\n-pub const ERROR_SETMARK_DETECTED: DWORD = 1103;\n-pub const ERROR_NO_DATA_DETECTED: DWORD = 1104;\n-pub const ERROR_PARTITION_FAILURE: DWORD = 1105;\n-pub const ERROR_INVALID_BLOCK_LENGTH: DWORD = 1106;\n-pub const ERROR_DEVICE_NOT_PARTITIONED: DWORD = 1107;\n-pub const ERROR_UNABLE_TO_LOCK_MEDIA: DWORD = 1108;\n-pub const ERROR_UNABLE_TO_UNLOAD_MEDIA: DWORD = 1109;\n-pub const ERROR_MEDIA_CHANGED: DWORD = 1110;\n-pub const ERROR_BUS_RESET: DWORD = 1111;\n-pub const ERROR_NO_MEDIA_IN_DRIVE: DWORD = 1112;\n-pub const ERROR_NO_UNICODE_TRANSLATION: DWORD = 1113;\n-pub const ERROR_DLL_INIT_FAILED: DWORD = 1114;\n-pub const ERROR_SHUTDOWN_IN_PROGRESS: DWORD = 1115;\n-pub const ERROR_NO_SHUTDOWN_IN_PROGRESS: DWORD = 1116;\n-pub const ERROR_IO_DEVICE: DWORD = 1117;\n-pub const ERROR_SERIAL_NO_DEVICE: DWORD = 1118;\n-pub const ERROR_IRQ_BUSY: DWORD = 1119;\n-pub const ERROR_MORE_WRITES: DWORD = 1120;\n-pub const ERROR_COUNTER_TIMEOUT: DWORD = 1121;\n-pub const ERROR_FLOPPY_ID_MARK_NOT_FOUND: DWORD = 1122;\n-pub const ERROR_FLOPPY_WRONG_CYLINDER: DWORD = 1123;\n-pub const ERROR_FLOPPY_UNKNOWN_ERROR: DWORD = 1124;\n-pub const ERROR_FLOPPY_BAD_REGISTERS: DWORD = 1125;\n-pub const ERROR_DISK_RECALIBRATE_FAILED: DWORD = 1126;\n-pub const ERROR_DISK_OPERATION_FAILED: DWORD = 1127;\n-pub const ERROR_DISK_RESET_FAILED: DWORD = 1128;\n-pub const ERROR_EOM_OVERFLOW: DWORD = 1129;\n-pub const ERROR_NOT_ENOUGH_SERVER_MEMORY: DWORD = 1130;\n-pub const ERROR_POSSIBLE_DEADLOCK: DWORD = 1131;\n-pub const ERROR_MAPPED_ALIGNMENT: DWORD = 1132;\n-pub const ERROR_SET_POWER_STATE_VETOED: DWORD = 1140;\n-pub const ERROR_SET_POWER_STATE_FAILED: DWORD = 1141;\n-pub const ERROR_TOO_MANY_LINKS: DWORD = 1142;\n-pub const ERROR_OLD_WIN_VERSION: DWORD = 1150;\n-pub const ERROR_APP_WRONG_OS: DWORD = 1151;\n-pub const ERROR_SINGLE_INSTANCE_APP: DWORD = 1152;\n-pub const ERROR_RMODE_APP: DWORD = 1153;\n-pub const ERROR_INVALID_DLL: DWORD = 1154;\n-pub const ERROR_NO_ASSOCIATION: DWORD = 1155;\n-pub const ERROR_DDE_FAIL: DWORD = 1156;\n-pub const ERROR_DLL_NOT_FOUND: DWORD = 1157;\n-pub const ERROR_NO_MORE_USER_HANDLES: DWORD = 1158;\n-pub const ERROR_MESSAGE_SYNC_ONLY: DWORD = 1159;\n-pub const ERROR_SOURCE_ELEMENT_EMPTY: DWORD = 1160;\n-pub const ERROR_DESTINATION_ELEMENT_FULL: DWORD = 1161;\n-pub const ERROR_ILLEGAL_ELEMENT_ADDRESS: DWORD = 1162;\n-pub const ERROR_MAGAZINE_NOT_PRESENT: DWORD = 1163;\n-pub const ERROR_DEVICE_REINITIALIZATION_NEEDED: DWORD = 1164;\n-pub const ERROR_DEVICE_REQUIRES_CLEANING: DWORD = 1165;\n-pub const ERROR_DEVICE_DOOR_OPEN: DWORD = 1166;\n-pub const ERROR_DEVICE_NOT_CONNECTED: DWORD = 1167;\n-pub const ERROR_NOT_FOUND: DWORD = 1168;\n-pub const ERROR_NO_MATCH: DWORD = 1169;\n-pub const ERROR_SET_NOT_FOUND: DWORD = 1170;\n-pub const ERROR_POINT_NOT_FOUND: DWORD = 1171;\n-pub const ERROR_NO_TRACKING_SERVICE: DWORD = 1172;\n-pub const ERROR_NO_VOLUME_ID: DWORD = 1173;\n-pub const ERROR_UNABLE_TO_REMOVE_REPLACED: DWORD = 1175;\n-pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT: DWORD = 1176;\n-pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT_2: DWORD = 1177;\n-pub const ERROR_JOURNAL_DELETE_IN_PROGRESS: DWORD = 1178;\n-pub const ERROR_JOURNAL_NOT_ACTIVE: DWORD = 1179;\n-pub const ERROR_POTENTIAL_FILE_FOUND: DWORD = 1180;\n-pub const ERROR_JOURNAL_ENTRY_DELETED: DWORD = 1181;\n-pub const ERROR_BAD_DEVICE: DWORD = 1200;\n-pub const ERROR_CONNECTION_UNAVAIL: DWORD = 1201;\n-pub const ERROR_DEVICE_ALREADY_REMEMBERED: DWORD = 1202;\n-pub const ERROR_NO_NET_OR_BAD_PATH: DWORD = 1203;\n-pub const ERROR_BAD_PROVIDER: DWORD = 1204;\n-pub const ERROR_CANNOT_OPEN_PROFILE: DWORD = 1205;\n-pub const ERROR_BAD_PROFILE: DWORD = 1206;\n-pub const ERROR_NOT_CONTAINER: DWORD = 1207;\n-pub const ERROR_EXTENDED_ERROR: DWORD = 1208;\n-pub const ERROR_INVALID_GROUPNAME: DWORD = 1209;\n-pub const ERROR_INVALID_COMPUTERNAME: DWORD = 1210;\n-pub const ERROR_INVALID_EVENTNAME: DWORD = 1211;\n-pub const ERROR_INVALID_DOMAINNAME: DWORD = 1212;\n-pub const ERROR_INVALID_SERVICENAME: DWORD = 1213;\n-pub const ERROR_INVALID_NETNAME: DWORD = 1214;\n-pub const ERROR_INVALID_SHARENAME: DWORD = 1215;\n-pub const ERROR_INVALID_PASSWORDNAME: DWORD = 1216;\n-pub const ERROR_INVALID_MESSAGENAME: DWORD = 1217;\n-pub const ERROR_INVALID_MESSAGEDEST: DWORD = 1218;\n-pub const ERROR_SESSION_CREDENTIAL_CONFLICT: DWORD = 1219;\n-pub const ERROR_REMOTE_SESSION_LIMIT_EXCEEDED: DWORD = 1220;\n-pub const ERROR_DUP_DOMAINNAME: DWORD = 1221;\n-pub const ERROR_NO_NETWORK: DWORD = 1222;\n-pub const ERROR_CANCELLED: DWORD = 1223;\n-pub const ERROR_USER_MAPPED_FILE: DWORD = 1224;\n-pub const ERROR_CONNECTION_REFUSED: DWORD = 1225;\n-pub const ERROR_GRACEFUL_DISCONNECT: DWORD = 1226;\n-pub const ERROR_ADDRESS_ALREADY_ASSOCIATED: DWORD = 1227;\n-pub const ERROR_ADDRESS_NOT_ASSOCIATED: DWORD = 1228;\n-pub const ERROR_CONNECTION_INVALID: DWORD = 1229;\n-pub const ERROR_CONNECTION_ACTIVE: DWORD = 1230;\n-pub const ERROR_NETWORK_UNREACHABLE: DWORD = 1231;\n-pub const ERROR_HOST_UNREACHABLE: DWORD = 1232;\n-pub const ERROR_PROTOCOL_UNREACHABLE: DWORD = 1233;\n-pub const ERROR_PORT_UNREACHABLE: DWORD = 1234;\n-pub const ERROR_REQUEST_ABORTED: DWORD = 1235;\n-pub const ERROR_CONNECTION_ABORTED: DWORD = 1236;\n-pub const ERROR_RETRY: DWORD = 1237;\n-pub const ERROR_CONNECTION_COUNT_LIMIT: DWORD = 1238;\n-pub const ERROR_LOGIN_TIME_RESTRICTION: DWORD = 1239;\n-pub const ERROR_LOGIN_WKSTA_RESTRICTION: DWORD = 1240;\n-pub const ERROR_INCORRECT_ADDRESS: DWORD = 1241;\n-pub const ERROR_ALREADY_REGISTERED: DWORD = 1242;\n-pub const ERROR_SERVICE_NOT_FOUND: DWORD = 1243;\n-pub const ERROR_NOT_AUTHENTICATED: DWORD = 1244;\n-pub const ERROR_NOT_LOGGED_ON: DWORD = 1245;\n-pub const ERROR_CONTINUE: DWORD = 1246;\n-pub const ERROR_ALREADY_INITIALIZED: DWORD = 1247;\n-pub const ERROR_NO_MORE_DEVICES: DWORD = 1248;\n-pub const ERROR_NO_SUCH_SITE: DWORD = 1249;\n-pub const ERROR_DOMAIN_CONTROLLER_EXISTS: DWORD = 1250;\n-pub const ERROR_ONLY_IF_CONNECTED: DWORD = 1251;\n-pub const ERROR_OVERRIDE_NOCHANGES: DWORD = 1252;\n-pub const ERROR_BAD_USER_PROFILE: DWORD = 1253;\n-pub const ERROR_NOT_SUPPORTED_ON_SBS: DWORD = 1254;\n-pub const ERROR_SERVER_SHUTDOWN_IN_PROGRESS: DWORD = 1255;\n-pub const ERROR_HOST_DOWN: DWORD = 1256;\n-pub const ERROR_NON_ACCOUNT_SID: DWORD = 1257;\n-pub const ERROR_NON_DOMAIN_SID: DWORD = 1258;\n-pub const ERROR_APPHELP_BLOCK: DWORD = 1259;\n-pub const ERROR_ACCESS_DISABLED_BY_POLICY: DWORD = 1260;\n-pub const ERROR_REG_NAT_CONSUMPTION: DWORD = 1261;\n-pub const ERROR_CSCSHARE_OFFLINE: DWORD = 1262;\n-pub const ERROR_PKINIT_FAILURE: DWORD = 1263;\n-pub const ERROR_SMARTCARD_SUBSYSTEM_FAILURE: DWORD = 1264;\n-pub const ERROR_DOWNGRADE_DETECTED: DWORD = 1265;\n-pub const ERROR_MACHINE_LOCKED: DWORD = 1271;\n-pub const ERROR_CALLBACK_SUPPLIED_INVALID_DATA: DWORD = 1273;\n-pub const ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED: DWORD = 1274;\n-pub const ERROR_DRIVER_BLOCKED: DWORD = 1275;\n-pub const ERROR_INVALID_IMPORT_OF_NON_DLL: DWORD = 1276;\n-pub const ERROR_ACCESS_DISABLED_WEBBLADE: DWORD = 1277;\n-pub const ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER: DWORD = 1278;\n-pub const ERROR_RECOVERY_FAILURE: DWORD = 1279;\n-pub const ERROR_ALREADY_FIBER: DWORD = 1280;\n-pub const ERROR_ALREADY_THREAD: DWORD = 1281;\n-pub const ERROR_STACK_BUFFER_OVERRUN: DWORD = 1282;\n-pub const ERROR_PARAMETER_QUOTA_EXCEEDED: DWORD = 1283;\n-pub const ERROR_DEBUGGER_INACTIVE: DWORD = 1284;\n-pub const ERROR_DELAY_LOAD_FAILED: DWORD = 1285;\n-pub const ERROR_VDM_DISALLOWED: DWORD = 1286;\n-pub const ERROR_UNIDENTIFIED_ERROR: DWORD = 1287;\n-pub const ERROR_NOT_ALL_ASSIGNED: DWORD = 1300;\n-pub const ERROR_SOME_NOT_MAPPED: DWORD = 1301;\n-pub const ERROR_NO_QUOTAS_FOR_ACCOUNT: DWORD = 1302;\n-pub const ERROR_LOCAL_USER_SESSION_KEY: DWORD = 1303;\n-pub const ERROR_NULL_LM_PASSWORD: DWORD = 1304;\n-pub const ERROR_UNKNOWN_REVISION: DWORD = 1305;\n-pub const ERROR_REVISION_MISMATCH: DWORD = 1306;\n-pub const ERROR_INVALID_OWNER: DWORD = 1307;\n-pub const ERROR_INVALID_PRIMARY_GROUP: DWORD = 1308;\n-pub const ERROR_NO_IMPERSONATION_TOKEN: DWORD = 1309;\n-pub const ERROR_CANT_DISABLE_MANDATORY: DWORD = 1310;\n-pub const ERROR_NO_LOGON_SERVERS: DWORD = 1311;\n-pub const ERROR_NO_SUCH_LOGON_SESSION: DWORD = 1312;\n-pub const ERROR_NO_SUCH_PRIVILEGE: DWORD = 1313;\n-pub const ERROR_PRIVILEGE_NOT_HELD: DWORD = 1314;\n-pub const ERROR_INVALID_ACCOUNT_NAME: DWORD = 1315;\n-pub const ERROR_USER_EXISTS: DWORD = 1316;\n-pub const ERROR_NO_SUCH_USER: DWORD = 1317;\n-pub const ERROR_GROUP_EXISTS: DWORD = 1318;\n-pub const ERROR_NO_SUCH_GROUP: DWORD = 1319;\n-pub const ERROR_MEMBER_IN_GROUP: DWORD = 1320;\n-pub const ERROR_MEMBER_NOT_IN_GROUP: DWORD = 1321;\n-pub const ERROR_LAST_ADMIN: DWORD = 1322;\n-pub const ERROR_WRONG_PASSWORD: DWORD = 1323;\n-pub const ERROR_ILL_FORMED_PASSWORD: DWORD = 1324;\n-pub const ERROR_PASSWORD_RESTRICTION: DWORD = 1325;\n-pub const ERROR_LOGON_FAILURE: DWORD = 1326;\n-pub const ERROR_ACCOUNT_RESTRICTION: DWORD = 1327;\n-pub const ERROR_INVALID_LOGON_HOURS: DWORD = 1328;\n-pub const ERROR_INVALID_WORKSTATION: DWORD = 1329;\n-pub const ERROR_PASSWORD_EXPIRED: DWORD = 1330;\n-pub const ERROR_ACCOUNT_DISABLED: DWORD = 1331;\n-pub const ERROR_NONE_MAPPED: DWORD = 1332;\n-pub const ERROR_TOO_MANY_LUIDS_REQUESTED: DWORD = 1333;\n-pub const ERROR_LUIDS_EXHAUSTED: DWORD = 1334;\n-pub const ERROR_INVALID_SUB_AUTHORITY: DWORD = 1335;\n-pub const ERROR_INVALID_ACL: DWORD = 1336;\n-pub const ERROR_INVALID_SID: DWORD = 1337;\n-pub const ERROR_INVALID_SECURITY_DESCR: DWORD = 1338;\n-pub const ERROR_BAD_INHERITANCE_ACL: DWORD = 1340;\n-pub const ERROR_SERVER_DISABLED: DWORD = 1341;\n-pub const ERROR_SERVER_NOT_DISABLED: DWORD = 1342;\n-pub const ERROR_INVALID_ID_AUTHORITY: DWORD = 1343;\n-pub const ERROR_ALLOTTED_SPACE_EXCEEDED: DWORD = 1344;\n-pub const ERROR_INVALID_GROUP_ATTRIBUTES: DWORD = 1345;\n-pub const ERROR_BAD_IMPERSONATION_LEVEL: DWORD = 1346;\n-pub const ERROR_CANT_OPEN_ANONYMOUS: DWORD = 1347;\n-pub const ERROR_BAD_VALIDATION_CLASS: DWORD = 1348;\n-pub const ERROR_BAD_TOKEN_TYPE: DWORD = 1349;\n-pub const ERROR_NO_SECURITY_ON_OBJECT: DWORD = 1350;\n-pub const ERROR_CANT_ACCESS_DOMAIN_INFO: DWORD = 1351;\n-pub const ERROR_INVALID_SERVER_STATE: DWORD = 1352;\n-pub const ERROR_INVALID_DOMAIN_STATE: DWORD = 1353;\n-pub const ERROR_INVALID_DOMAIN_ROLE: DWORD = 1354;\n-pub const ERROR_NO_SUCH_DOMAIN: DWORD = 1355;\n-pub const ERROR_DOMAIN_EXISTS: DWORD = 1356;\n-pub const ERROR_DOMAIN_LIMIT_EXCEEDED: DWORD = 1357;\n-pub const ERROR_INTERNAL_DB_CORRUPTION: DWORD = 1358;\n-pub const ERROR_INTERNAL_ERROR: DWORD = 1359;\n-pub const ERROR_GENERIC_NOT_MAPPED: DWORD = 1360;\n-pub const ERROR_BAD_DESCRIPTOR_FORMAT: DWORD = 1361;\n-pub const ERROR_NOT_LOGON_PROCESS: DWORD = 1362;\n-pub const ERROR_LOGON_SESSION_EXISTS: DWORD = 1363;\n-pub const ERROR_NO_SUCH_PACKAGE: DWORD = 1364;\n-pub const ERROR_BAD_LOGON_SESSION_STATE: DWORD = 1365;\n-pub const ERROR_LOGON_SESSION_COLLISION: DWORD = 1366;\n-pub const ERROR_INVALID_LOGON_TYPE: DWORD = 1367;\n-pub const ERROR_CANNOT_IMPERSONATE: DWORD = 1368;\n-pub const ERROR_RXACT_INVALID_STATE: DWORD = 1369;\n-pub const ERROR_RXACT_COMMIT_FAILURE: DWORD = 1370;\n-pub const ERROR_SPECIAL_ACCOUNT: DWORD = 1371;\n-pub const ERROR_SPECIAL_GROUP: DWORD = 1372;\n-pub const ERROR_SPECIAL_USER: DWORD = 1373;\n-pub const ERROR_MEMBERS_PRIMARY_GROUP: DWORD = 1374;\n-pub const ERROR_TOKEN_ALREADY_IN_USE: DWORD = 1375;\n-pub const ERROR_NO_SUCH_ALIAS: DWORD = 1376;\n-pub const ERROR_MEMBER_NOT_IN_ALIAS: DWORD = 1377;\n-pub const ERROR_MEMBER_IN_ALIAS: DWORD = 1378;\n-pub const ERROR_ALIAS_EXISTS: DWORD = 1379;\n-pub const ERROR_LOGON_NOT_GRANTED: DWORD = 1380;\n-pub const ERROR_TOO_MANY_SECRETS: DWORD = 1381;\n-pub const ERROR_SECRET_TOO_LONG: DWORD = 1382;\n-pub const ERROR_INTERNAL_DB_ERROR: DWORD = 1383;\n-pub const ERROR_TOO_MANY_CONTEXT_IDS: DWORD = 1384;\n-pub const ERROR_LOGON_TYPE_NOT_GRANTED: DWORD = 1385;\n-pub const ERROR_NT_CROSS_ENCRYPTION_REQUIRED: DWORD = 1386;\n-pub const ERROR_NO_SUCH_MEMBER: DWORD = 1387;\n-pub const ERROR_INVALID_MEMBER: DWORD = 1388;\n-pub const ERROR_TOO_MANY_SIDS: DWORD = 1389;\n-pub const ERROR_LM_CROSS_ENCRYPTION_REQUIRED: DWORD = 1390;\n-pub const ERROR_NO_INHERITANCE: DWORD = 1391;\n-pub const ERROR_FILE_CORRUPT: DWORD = 1392;\n-pub const ERROR_DISK_CORRUPT: DWORD = 1393;\n-pub const ERROR_NO_USER_SESSION_KEY: DWORD = 1394;\n-pub const ERROR_LICENSE_QUOTA_EXCEEDED: DWORD = 1395;\n-pub const ERROR_WRONG_TARGET_NAME: DWORD = 1396;\n-pub const ERROR_MUTUAL_AUTH_FAILED: DWORD = 1397;\n-pub const ERROR_TIME_SKEW: DWORD = 1398;\n-pub const ERROR_CURRENT_DOMAIN_NOT_ALLOWED: DWORD = 1399;\n-pub const ERROR_INVALID_WINDOW_HANDLE: DWORD = 1400;\n-pub const ERROR_INVALID_MENU_HANDLE: DWORD = 1401;\n-pub const ERROR_INVALID_CURSOR_HANDLE: DWORD = 1402;\n-pub const ERROR_INVALID_ACCEL_HANDLE: DWORD = 1403;\n-pub const ERROR_INVALID_HOOK_HANDLE: DWORD = 1404;\n-pub const ERROR_INVALID_DWP_HANDLE: DWORD = 1405;\n-pub const ERROR_TLW_WITH_WSCHILD: DWORD = 1406;\n-pub const ERROR_CANNOT_FIND_WND_CLASS: DWORD = 1407;\n-pub const ERROR_WINDOW_OF_OTHER_THREAD: DWORD = 1408;\n-pub const ERROR_HOTKEY_ALREADY_REGISTERED: DWORD = 1409;\n-pub const ERROR_CLASS_ALREADY_EXISTS: DWORD = 1410;\n-pub const ERROR_CLASS_DOES_NOT_EXIST: DWORD = 1411;\n-pub const ERROR_CLASS_HAS_WINDOWS: DWORD = 1412;\n-pub const ERROR_INVALID_INDEX: DWORD = 1413;\n-pub const ERROR_INVALID_ICON_HANDLE: DWORD = 1414;\n-pub const ERROR_PRIVATE_DIALOG_INDEX: DWORD = 1415;\n-pub const ERROR_LISTBOX_ID_NOT_FOUND: DWORD = 1416;\n-pub const ERROR_NO_WILDCARD_CHARACTERS: DWORD = 1417;\n-pub const ERROR_CLIPBOARD_NOT_OPEN: DWORD = 1418;\n-pub const ERROR_HOTKEY_NOT_REGISTERED: DWORD = 1419;\n-pub const ERROR_WINDOW_NOT_DIALOG: DWORD = 1420;\n-pub const ERROR_CONTROL_ID_NOT_FOUND: DWORD = 1421;\n-pub const ERROR_INVALID_COMBOBOX_MESSAGE: DWORD = 1422;\n-pub const ERROR_WINDOW_NOT_COMBOBOX: DWORD = 1423;\n-pub const ERROR_INVALID_EDIT_HEIGHT: DWORD = 1424;\n-pub const ERROR_DC_NOT_FOUND: DWORD = 1425;\n-pub const ERROR_INVALID_HOOK_FILTER: DWORD = 1426;\n-pub const ERROR_INVALID_FILTER_PROC: DWORD = 1427;\n-pub const ERROR_HOOK_NEEDS_HMOD: DWORD = 1428;\n-pub const ERROR_GLOBAL_ONLY_HOOK: DWORD = 1429;\n-pub const ERROR_JOURNAL_HOOK_SET: DWORD = 1430;\n-pub const ERROR_HOOK_NOT_INSTALLED: DWORD = 1431;\n-pub const ERROR_INVALID_LB_MESSAGE: DWORD = 1432;\n-pub const ERROR_SETCOUNT_ON_BAD_LB: DWORD = 1433;\n-pub const ERROR_LB_WITHOUT_TABSTOPS: DWORD = 1434;\n-pub const ERROR_DESTROY_OBJECT_OF_OTHER_THREAD: DWORD = 1435;\n-pub const ERROR_CHILD_WINDOW_MENU: DWORD = 1436;\n-pub const ERROR_NO_SYSTEM_MENU: DWORD = 1437;\n-pub const ERROR_INVALID_MSGBOX_STYLE: DWORD = 1438;\n-pub const ERROR_INVALID_SPI_VALUE: DWORD = 1439;\n-pub const ERROR_SCREEN_ALREADY_LOCKED: DWORD = 1440;\n-pub const ERROR_HWNDS_HAVE_DIFF_PARENT: DWORD = 1441;\n-pub const ERROR_NOT_CHILD_WINDOW: DWORD = 1442;\n-pub const ERROR_INVALID_GW_COMMAND: DWORD = 1443;\n-pub const ERROR_INVALID_THREAD_ID: DWORD = 1444;\n-pub const ERROR_NON_MDICHILD_WINDOW: DWORD = 1445;\n-pub const ERROR_POPUP_ALREADY_ACTIVE: DWORD = 1446;\n-pub const ERROR_NO_SCROLLBARS: DWORD = 1447;\n-pub const ERROR_INVALID_SCROLLBAR_RANGE: DWORD = 1448;\n-pub const ERROR_INVALID_SHOWWIN_COMMAND: DWORD = 1449;\n-pub const ERROR_NO_SYSTEM_RESOURCES: DWORD = 1450;\n-pub const ERROR_NONPAGED_SYSTEM_RESOURCES: DWORD = 1451;\n-pub const ERROR_PAGED_SYSTEM_RESOURCES: DWORD = 1452;\n-pub const ERROR_WORKING_SET_QUOTA: DWORD = 1453;\n-pub const ERROR_PAGEFILE_QUOTA: DWORD = 1454;\n-pub const ERROR_COMMITMENT_LIMIT: DWORD = 1455;\n-pub const ERROR_MENU_ITEM_NOT_FOUND: DWORD = 1456;\n-pub const ERROR_INVALID_KEYBOARD_HANDLE: DWORD = 1457;\n-pub const ERROR_HOOK_TYPE_NOT_ALLOWED: DWORD = 1458;\n-pub const ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION: DWORD = 1459;\n-pub const ERROR_TIMEOUT: DWORD = 1460;\n-pub const ERROR_INVALID_MONITOR_HANDLE: DWORD = 1461;\n-pub const ERROR_INCORRECT_SIZE: DWORD = 1462;\n-pub const ERROR_SYMLINK_CLASS_DISABLED: DWORD = 1463;\n-pub const ERROR_SYMLINK_NOT_SUPPORTED: DWORD = 1464;\n-pub const ERROR_XML_PARSE_ERROR: DWORD = 1465;\n-pub const ERROR_XMLDSIG_ERROR: DWORD = 1466;\n-pub const ERROR_RESTART_APPLICATION: DWORD = 1467;\n-pub const ERROR_WRONG_COMPARTMENT: DWORD = 1468;\n-pub const ERROR_AUTHIP_FAILURE: DWORD = 1469;\n-pub const ERROR_NO_NVRAM_RESOURCES: DWORD = 1470;\n-pub const ERROR_NOT_GUI_PROCESS: DWORD = 1471;\n-pub const ERROR_EVENTLOG_FILE_CORRUPT: DWORD = 1500;\n-pub const ERROR_EVENTLOG_CANT_START: DWORD = 1501;\n-pub const ERROR_LOG_FILE_FULL: DWORD = 1502;\n-pub const ERROR_EVENTLOG_FILE_CHANGED: DWORD = 1503;\n-pub const ERROR_INSTALL_SERVICE_FAILURE: DWORD = 1601;\n-pub const ERROR_INSTALL_USEREXIT: DWORD = 1602;\n-pub const ERROR_INSTALL_FAILURE: DWORD = 1603;\n-pub const ERROR_INSTALL_SUSPEND: DWORD = 1604;\n-pub const ERROR_UNKNOWN_PRODUCT: DWORD = 1605;\n-pub const ERROR_UNKNOWN_FEATURE: DWORD = 1606;\n-pub const ERROR_UNKNOWN_COMPONENT: DWORD = 1607;\n-pub const ERROR_UNKNOWN_PROPERTY: DWORD = 1608;\n-pub const ERROR_INVALID_HANDLE_STATE: DWORD = 1609;\n-pub const ERROR_BAD_CONFIGURATION: DWORD = 1610;\n-pub const ERROR_INDEX_ABSENT: DWORD = 1611;\n-pub const ERROR_INSTALL_SOURCE_ABSENT: DWORD = 1612;\n-pub const ERROR_INSTALL_PACKAGE_VERSION: DWORD = 1613;\n-pub const ERROR_PRODUCT_UNINSTALLED: DWORD = 1614;\n-pub const ERROR_BAD_QUERY_SYNTAX: DWORD = 1615;\n-pub const ERROR_INVALID_FIELD: DWORD = 1616;\n-pub const ERROR_DEVICE_REMOVED: DWORD = 1617;\n-pub const ERROR_INSTALL_ALREADY_RUNNING: DWORD = 1618;\n-pub const ERROR_INSTALL_PACKAGE_OPEN_FAILED: DWORD = 1619;\n-pub const ERROR_INSTALL_PACKAGE_INVALID: DWORD = 1620;\n-pub const ERROR_INSTALL_UI_FAILURE: DWORD = 1621;\n-pub const ERROR_INSTALL_LOG_FAILURE: DWORD = 1622;\n-pub const ERROR_INSTALL_LANGUAGE_UNSUPPORTED: DWORD = 1623;\n-pub const ERROR_INSTALL_TRANSFORM_FAILURE: DWORD = 1624;\n-pub const ERROR_INSTALL_PACKAGE_REJECTED: DWORD = 1625;\n-pub const ERROR_FUNCTION_NOT_CALLED: DWORD = 1626;\n-pub const ERROR_FUNCTION_FAILED: DWORD = 1627;\n-pub const ERROR_INVALID_TABLE: DWORD = 1628;\n-pub const ERROR_DATATYPE_MISMATCH: DWORD = 1629;\n-pub const ERROR_UNSUPPORTED_TYPE: DWORD = 1630;\n-pub const ERROR_CREATE_FAILED: DWORD = 1631;\n-pub const ERROR_INSTALL_TEMP_UNWRITABLE: DWORD = 1632;\n-pub const ERROR_INSTALL_PLATFORM_UNSUPPORTED: DWORD = 1633;\n-pub const ERROR_INSTALL_NOTUSED: DWORD = 1634;\n-pub const ERROR_PATCH_PACKAGE_OPEN_FAILED: DWORD = 1635;\n-pub const ERROR_PATCH_PACKAGE_INVALID: DWORD = 1636;\n-pub const ERROR_PATCH_PACKAGE_UNSUPPORTED: DWORD = 1637;\n-pub const ERROR_PRODUCT_VERSION: DWORD = 1638;\n-pub const ERROR_INVALID_COMMAND_LINE: DWORD = 1639;\n-pub const ERROR_INSTALL_REMOTE_DISALLOWED: DWORD = 1640;\n-pub const ERROR_SUCCESS_REBOOT_INITIATED: DWORD = 1641;\n-pub const ERROR_PATCH_TARGET_NOT_FOUND: DWORD = 1642;\n-pub const ERROR_PATCH_PACKAGE_REJECTED: DWORD = 1643;\n-pub const ERROR_INSTALL_TRANSFORM_REJECTED: DWORD = 1644;\n-pub const ERROR_INSTALL_REMOTE_PROHIBITED: DWORD = 1645;\n-pub const ERROR_INVALID_USER_BUFFER: DWORD = 1784;\n-pub const ERROR_UNRECOGNIZED_MEDIA: DWORD = 1785;\n-pub const ERROR_NO_TRUST_LSA_SECRET: DWORD = 1786;\n-pub const ERROR_NO_TRUST_SAM_ACCOUNT: DWORD = 1787;\n-pub const ERROR_TRUSTED_DOMAIN_FAILURE: DWORD = 1788;\n-pub const ERROR_TRUSTED_RELATIONSHIP_FAILURE: DWORD = 1789;\n-pub const ERROR_TRUST_FAILURE: DWORD = 1790;\n-pub const ERROR_NETLOGON_NOT_STARTED: DWORD = 1792;\n-pub const ERROR_ACCOUNT_EXPIRED: DWORD = 1793;\n-pub const ERROR_REDIRECTOR_HAS_OPEN_HANDLES: DWORD = 1794;\n-pub const ERROR_PRINTER_DRIVER_ALREADY_INSTALLED: DWORD = 1795;\n-pub const ERROR_UNKNOWN_PORT: DWORD = 1796;\n-pub const ERROR_UNKNOWN_PRINTER_DRIVER: DWORD = 1797;\n-pub const ERROR_UNKNOWN_PRINTPROCESSOR: DWORD = 1798;\n-pub const ERROR_INVALID_SEPARATOR_FILE: DWORD = 1799;\n-pub const ERROR_INVALID_PRIORITY: DWORD = 1800;\n-pub const ERROR_INVALID_PRINTER_NAME: DWORD = 1801;\n-pub const ERROR_PRINTER_ALREADY_EXISTS: DWORD = 1802;\n-pub const ERROR_INVALID_PRINTER_COMMAND: DWORD = 1803;\n-pub const ERROR_INVALID_DATATYPE: DWORD = 1804;\n-pub const ERROR_INVALID_ENVIRONMENT: DWORD = 1805;\n-pub const ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT: DWORD = 1807;\n-pub const ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT: DWORD = 1808;\n-pub const ERROR_NOLOGON_SERVER_TRUST_ACCOUNT: DWORD = 1809;\n-pub const ERROR_DOMAIN_TRUST_INCONSISTENT: DWORD = 1810;\n-pub const ERROR_SERVER_HAS_OPEN_HANDLES: DWORD = 1811;\n-pub const ERROR_RESOURCE_DATA_NOT_FOUND: DWORD = 1812;\n-pub const ERROR_RESOURCE_TYPE_NOT_FOUND: DWORD = 1813;\n-pub const ERROR_RESOURCE_NAME_NOT_FOUND: DWORD = 1814;\n-pub const ERROR_RESOURCE_LANG_NOT_FOUND: DWORD = 1815;\n-pub const ERROR_NOT_ENOUGH_QUOTA: DWORD = 1816;\n-pub const ERROR_INVALID_TIME: DWORD = 1901;\n-pub const ERROR_INVALID_FORM_NAME: DWORD = 1902;\n-pub const ERROR_INVALID_FORM_SIZE: DWORD = 1903;\n-pub const ERROR_ALREADY_WAITING: DWORD = 1904;\n-pub const ERROR_PRINTER_DELETED: DWORD = 1905;\n-pub const ERROR_INVALID_PRINTER_STATE: DWORD = 1906;\n-pub const ERROR_PASSWORD_MUST_CHANGE: DWORD = 1907;\n-pub const ERROR_DOMAIN_CONTROLLER_NOT_FOUND: DWORD = 1908;\n-pub const ERROR_ACCOUNT_LOCKED_OUT: DWORD = 1909;\n-pub const ERROR_NO_SITENAME: DWORD = 1919;\n-pub const ERROR_CANT_ACCESS_FILE: DWORD = 1920;\n-pub const ERROR_CANT_RESOLVE_FILENAME: DWORD = 1921;\n-pub const ERROR_KM_DRIVER_BLOCKED: DWORD = 1930;\n-pub const ERROR_CONTEXT_EXPIRED: DWORD = 1931;\n-pub const ERROR_PER_USER_TRUST_QUOTA_EXCEEDED: DWORD = 1932;\n-pub const ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED: DWORD = 1933;\n-pub const ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED: DWORD = 1934;\n-pub const ERROR_AUTHENTICATION_FIREWALL_FAILED: DWORD = 1935;\n-pub const ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED: DWORD = 1936;\n-pub const ERROR_INVALID_PIXEL_FORMAT: DWORD = 2000;\n-pub const ERROR_BAD_DRIVER: DWORD = 2001;\n-pub const ERROR_INVALID_WINDOW_STYLE: DWORD = 2002;\n-pub const ERROR_METAFILE_NOT_SUPPORTED: DWORD = 2003;\n-pub const ERROR_TRANSFORM_NOT_SUPPORTED: DWORD = 2004;\n-pub const ERROR_CLIPPING_NOT_SUPPORTED: DWORD = 2005;\n-pub const ERROR_INVALID_CMM: DWORD = 2010;\n-pub const ERROR_INVALID_PROFILE: DWORD = 2011;\n-pub const ERROR_TAG_NOT_FOUND: DWORD = 2012;\n-pub const ERROR_TAG_NOT_PRESENT: DWORD = 2013;\n-pub const ERROR_DUPLICATE_TAG: DWORD = 2014;\n-pub const ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE: DWORD = 2015;\n-pub const ERROR_PROFILE_NOT_FOUND: DWORD = 2016;\n-pub const ERROR_INVALID_COLORSPACE: DWORD = 2017;\n-pub const ERROR_ICM_NOT_ENABLED: DWORD = 2018;\n-pub const ERROR_DELETING_ICM_XFORM: DWORD = 2019;\n-pub const ERROR_INVALID_TRANSFORM: DWORD = 2020;\n-pub const ERROR_COLORSPACE_MISMATCH: DWORD = 2021;\n-pub const ERROR_INVALID_COLORINDEX: DWORD = 2022;\n-pub const ERROR_CONNECTED_OTHER_PASSWORD: DWORD = 2108;\n-pub const ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT: DWORD = 2109;\n-pub const ERROR_BAD_USERNAME: DWORD = 2202;\n-pub const ERROR_NOT_CONNECTED: DWORD = 2250;\n-pub const ERROR_OPEN_FILES: DWORD = 2401;\n-pub const ERROR_ACTIVE_CONNECTIONS: DWORD = 2402;\n-pub const ERROR_DEVICE_IN_USE: DWORD = 2404;\n-pub const ERROR_UNKNOWN_PRINT_MONITOR: DWORD = 3000;\n-pub const ERROR_PRINTER_DRIVER_IN_USE: DWORD = 3001;\n-pub const ERROR_SPOOL_FILE_NOT_FOUND: DWORD = 3002;\n-pub const ERROR_SPL_NO_STARTDOC: DWORD = 3003;\n-pub const ERROR_SPL_NO_ADDJOB: DWORD = 3004;\n-pub const ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED: DWORD = 3005;\n-pub const ERROR_PRINT_MONITOR_ALREADY_INSTALLED: DWORD = 3006;\n-pub const ERROR_INVALID_PRINT_MONITOR: DWORD = 3007;\n-pub const ERROR_PRINT_MONITOR_IN_USE: DWORD = 3008;\n-pub const ERROR_PRINTER_HAS_JOBS_QUEUED: DWORD = 3009;\n-pub const ERROR_SUCCESS_REBOOT_REQUIRED: DWORD = 3010;\n-pub const ERROR_SUCCESS_RESTART_REQUIRED: DWORD = 3011;\n-pub const ERROR_PRINTER_NOT_FOUND: DWORD = 3012;\n-pub const ERROR_PRINTER_DRIVER_WARNED: DWORD = 3013;\n-pub const ERROR_PRINTER_DRIVER_BLOCKED: DWORD = 3014;\n-pub const ERROR_WINS_INTERNAL: DWORD = 4000;\n-pub const ERROR_CAN_NOT_DEL_LOCAL_WINS: DWORD = 4001;\n-pub const ERROR_STATIC_INIT: DWORD = 4002;\n-pub const ERROR_INC_BACKUP: DWORD = 4003;\n-pub const ERROR_FULL_BACKUP: DWORD = 4004;\n-pub const ERROR_REC_NON_EXISTENT: DWORD = 4005;\n-pub const ERROR_RPL_NOT_ALLOWED: DWORD = 4006;\n-pub const ERROR_DHCP_ADDRESS_CONFLICT: DWORD = 4100;\n-pub const ERROR_WMI_GUID_NOT_FOUND: DWORD = 4200;\n-pub const ERROR_WMI_INSTANCE_NOT_FOUND: DWORD = 4201;\n-pub const ERROR_WMI_ITEMID_NOT_FOUND: DWORD = 4202;\n-pub const ERROR_WMI_TRY_AGAIN: DWORD = 4203;\n-pub const ERROR_WMI_DP_NOT_FOUND: DWORD = 4204;\n-pub const ERROR_WMI_UNRESOLVED_INSTANCE_REF: DWORD = 4205;\n-pub const ERROR_WMI_ALREADY_ENABLED: DWORD = 4206;\n-pub const ERROR_WMI_GUID_DISCONNECTED: DWORD = 4207;\n-pub const ERROR_WMI_SERVER_UNAVAILABLE: DWORD = 4208;\n-pub const ERROR_WMI_DP_FAILED: DWORD = 4209;\n-pub const ERROR_WMI_INVALID_MOF: DWORD = 4210;\n-pub const ERROR_WMI_INVALID_REGINFO: DWORD = 4211;\n-pub const ERROR_WMI_ALREADY_DISABLED: DWORD = 4212;\n-pub const ERROR_WMI_READ_ONLY: DWORD = 4213;\n-pub const ERROR_WMI_SET_FAILURE: DWORD = 4214;\n-pub const ERROR_INVALID_MEDIA: DWORD = 4300;\n-pub const ERROR_INVALID_LIBRARY: DWORD = 4301;\n-pub const ERROR_INVALID_MEDIA_POOL: DWORD = 4302;\n-pub const ERROR_DRIVE_MEDIA_MISMATCH: DWORD = 4303;\n-pub const ERROR_MEDIA_OFFLINE: DWORD = 4304;\n-pub const ERROR_LIBRARY_OFFLINE: DWORD = 4305;\n-pub const ERROR_EMPTY: DWORD = 4306;\n-pub const ERROR_NOT_EMPTY: DWORD = 4307;\n-pub const ERROR_MEDIA_UNAVAILABLE: DWORD = 4308;\n-pub const ERROR_RESOURCE_DISABLED: DWORD = 4309;\n-pub const ERROR_INVALID_CLEANER: DWORD = 4310;\n-pub const ERROR_UNABLE_TO_CLEAN: DWORD = 4311;\n-pub const ERROR_OBJECT_NOT_FOUND: DWORD = 4312;\n-pub const ERROR_DATABASE_FAILURE: DWORD = 4313;\n-pub const ERROR_DATABASE_FULL: DWORD = 4314;\n-pub const ERROR_MEDIA_INCOMPATIBLE: DWORD = 4315;\n-pub const ERROR_RESOURCE_NOT_PRESENT: DWORD = 4316;\n-pub const ERROR_INVALID_OPERATION: DWORD = 4317;\n-pub const ERROR_MEDIA_NOT_AVAILABLE: DWORD = 4318;\n-pub const ERROR_DEVICE_NOT_AVAILABLE: DWORD = 4319;\n-pub const ERROR_REQUEST_REFUSED: DWORD = 4320;\n-pub const ERROR_INVALID_DRIVE_OBJECT: DWORD = 4321;\n-pub const ERROR_LIBRARY_FULL: DWORD = 4322;\n-pub const ERROR_MEDIUM_NOT_ACCESSIBLE: DWORD = 4323;\n-pub const ERROR_UNABLE_TO_LOAD_MEDIUM: DWORD = 4324;\n-pub const ERROR_UNABLE_TO_INVENTORY_DRIVE: DWORD = 4325;\n-pub const ERROR_UNABLE_TO_INVENTORY_SLOT: DWORD = 4326;\n-pub const ERROR_UNABLE_TO_INVENTORY_TRANSPORT: DWORD = 4327;\n-pub const ERROR_TRANSPORT_FULL: DWORD = 4328;\n-pub const ERROR_CONTROLLING_IEPORT: DWORD = 4329;\n-pub const ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA: DWORD = 4330;\n-pub const ERROR_CLEANER_SLOT_SET: DWORD = 4331;\n-pub const ERROR_CLEANER_SLOT_NOT_SET: DWORD = 4332;\n-pub const ERROR_CLEANER_CARTRIDGE_SPENT: DWORD = 4333;\n-pub const ERROR_UNEXPECTED_OMID: DWORD = 4334;\n-pub const ERROR_CANT_DELETE_LAST_ITEM: DWORD = 4335;\n-pub const ERROR_MESSAGE_EXCEEDS_MAX_SIZE: DWORD = 4336;\n-pub const ERROR_VOLUME_CONTAINS_SYS_FILES: DWORD = 4337;\n-pub const ERROR_INDIGENOUS_TYPE: DWORD = 4338;\n-pub const ERROR_NO_SUPPORTING_DRIVES: DWORD = 4339;\n-pub const ERROR_CLEANER_CARTRIDGE_INSTALLED: DWORD = 4340;\n-pub const ERROR_IEPORT_FULL: DWORD = 4341;\n-pub const ERROR_FILE_OFFLINE: DWORD = 4350;\n-pub const ERROR_REMOTE_STORAGE_NOT_ACTIVE: DWORD = 4351;\n-pub const ERROR_REMOTE_STORAGE_MEDIA_ERROR: DWORD = 4352;\n-pub const ERROR_NOT_A_REPARSE_POINT: DWORD = 4390;\n-pub const ERROR_REPARSE_ATTRIBUTE_CONFLICT: DWORD = 4391;\n-pub const ERROR_INVALID_REPARSE_DATA: DWORD = 4392;\n-pub const ERROR_REPARSE_TAG_INVALID: DWORD = 4393;\n-pub const ERROR_REPARSE_TAG_MISMATCH: DWORD = 4394;\n-pub const ERROR_VOLUME_NOT_SIS_ENABLED: DWORD = 4500;\n-pub const ERROR_DEPENDENT_RESOURCE_EXISTS: DWORD = 5001;\n-pub const ERROR_DEPENDENCY_NOT_FOUND: DWORD = 5002;\n-pub const ERROR_DEPENDENCY_ALREADY_EXISTS: DWORD = 5003;\n-pub const ERROR_RESOURCE_NOT_ONLINE: DWORD = 5004;\n-pub const ERROR_HOST_NODE_NOT_AVAILABLE: DWORD = 5005;\n-pub const ERROR_RESOURCE_NOT_AVAILABLE: DWORD = 5006;\n-pub const ERROR_RESOURCE_NOT_FOUND: DWORD = 5007;\n-pub const ERROR_SHUTDOWN_CLUSTER: DWORD = 5008;\n-pub const ERROR_CANT_EVICT_ACTIVE_NODE: DWORD = 5009;\n-pub const ERROR_OBJECT_ALREADY_EXISTS: DWORD = 5010;\n-pub const ERROR_OBJECT_IN_LIST: DWORD = 5011;\n-pub const ERROR_GROUP_NOT_AVAILABLE: DWORD = 5012;\n-pub const ERROR_GROUP_NOT_FOUND: DWORD = 5013;\n-pub const ERROR_GROUP_NOT_ONLINE: DWORD = 5014;\n-pub const ERROR_HOST_NODE_NOT_RESOURCE_OWNER: DWORD = 5015;\n-pub const ERROR_HOST_NODE_NOT_GROUP_OWNER: DWORD = 5016;\n-pub const ERROR_RESMON_CREATE_FAILED: DWORD = 5017;\n-pub const ERROR_RESMON_ONLINE_FAILED: DWORD = 5018;\n-pub const ERROR_RESOURCE_ONLINE: DWORD = 5019;\n-pub const ERROR_QUORUM_RESOURCE: DWORD = 5020;\n-pub const ERROR_NOT_QUORUM_CAPABLE: DWORD = 5021;\n-pub const ERROR_CLUSTER_SHUTTING_DOWN: DWORD = 5022;\n-pub const ERROR_INVALID_STATE: DWORD = 5023;\n-pub const ERROR_RESOURCE_PROPERTIES_STORED: DWORD = 5024;\n-pub const ERROR_NOT_QUORUM_CLASS: DWORD = 5025;\n-pub const ERROR_CORE_RESOURCE: DWORD = 5026;\n-pub const ERROR_QUORUM_RESOURCE_ONLINE_FAILED: DWORD = 5027;\n-pub const ERROR_QUORUMLOG_OPEN_FAILED: DWORD = 5028;\n-pub const ERROR_CLUSTERLOG_CORRUPT: DWORD = 5029;\n-pub const ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE: DWORD = 5030;\n-pub const ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE: DWORD = 5031;\n-pub const ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND: DWORD = 5032;\n-pub const ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE: DWORD = 5033;\n-pub const ERROR_QUORUM_OWNER_ALIVE: DWORD = 5034;\n-pub const ERROR_NETWORK_NOT_AVAILABLE: DWORD = 5035;\n-pub const ERROR_NODE_NOT_AVAILABLE: DWORD = 5036;\n-pub const ERROR_ALL_NODES_NOT_AVAILABLE: DWORD = 5037;\n-pub const ERROR_RESOURCE_FAILED: DWORD = 5038;\n-pub const ERROR_CLUSTER_INVALID_NODE: DWORD = 5039;\n-pub const ERROR_CLUSTER_NODE_EXISTS: DWORD = 5040;\n-pub const ERROR_CLUSTER_JOIN_IN_PROGRESS: DWORD = 5041;\n-pub const ERROR_CLUSTER_NODE_NOT_FOUND: DWORD = 5042;\n-pub const ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND: DWORD = 5043;\n-pub const ERROR_CLUSTER_NETWORK_EXISTS: DWORD = 5044;\n-pub const ERROR_CLUSTER_NETWORK_NOT_FOUND: DWORD = 5045;\n-pub const ERROR_CLUSTER_NETINTERFACE_EXISTS: DWORD = 5046;\n-pub const ERROR_CLUSTER_NETINTERFACE_NOT_FOUND: DWORD = 5047;\n-pub const ERROR_CLUSTER_INVALID_REQUEST: DWORD = 5048;\n-pub const ERROR_CLUSTER_INVALID_NETWORK_PROVIDER: DWORD = 5049;\n-pub const ERROR_CLUSTER_NODE_DOWN: DWORD = 5050;\n-pub const ERROR_CLUSTER_NODE_UNREACHABLE: DWORD = 5051;\n-pub const ERROR_CLUSTER_NODE_NOT_MEMBER: DWORD = 5052;\n-pub const ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS: DWORD = 5053;\n-pub const ERROR_CLUSTER_INVALID_NETWORK: DWORD = 5054;\n-pub const ERROR_CLUSTER_NODE_UP: DWORD = 5056;\n-pub const ERROR_CLUSTER_IPADDR_IN_USE: DWORD = 5057;\n-pub const ERROR_CLUSTER_NODE_NOT_PAUSED: DWORD = 5058;\n-pub const ERROR_CLUSTER_NO_SECURITY_CONTEXT: DWORD = 5059;\n-pub const ERROR_CLUSTER_NETWORK_NOT_INTERNAL: DWORD = 5060;\n-pub const ERROR_CLUSTER_NODE_ALREADY_UP: DWORD = 5061;\n-pub const ERROR_CLUSTER_NODE_ALREADY_DOWN: DWORD = 5062;\n-pub const ERROR_CLUSTER_NETWORK_ALREADY_ONLINE: DWORD = 5063;\n-pub const ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE: DWORD = 5064;\n-pub const ERROR_CLUSTER_NODE_ALREADY_MEMBER: DWORD = 5065;\n-pub const ERROR_CLUSTER_LAST_INTERNAL_NETWORK: DWORD = 5066;\n-pub const ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS: DWORD = 5067;\n-pub const ERROR_INVALID_OPERATION_ON_QUORUM: DWORD = 5068;\n-pub const ERROR_DEPENDENCY_NOT_ALLOWED: DWORD = 5069;\n-pub const ERROR_CLUSTER_NODE_PAUSED: DWORD = 5070;\n-pub const ERROR_NODE_CANT_HOST_RESOURCE: DWORD = 5071;\n-pub const ERROR_CLUSTER_NODE_NOT_READY: DWORD = 5072;\n-pub const ERROR_CLUSTER_NODE_SHUTTING_DOWN: DWORD = 5073;\n-pub const ERROR_CLUSTER_JOIN_ABORTED: DWORD = 5074;\n-pub const ERROR_CLUSTER_INCOMPATIBLE_VERSIONS: DWORD = 5075;\n-pub const ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED: DWORD = 5076;\n-pub const ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED: DWORD = 5077;\n-pub const ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND: DWORD = 5078;\n-pub const ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED: DWORD = 5079;\n-pub const ERROR_CLUSTER_RESNAME_NOT_FOUND: DWORD = 5080;\n-pub const ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED: DWORD = 5081;\n-pub const ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST: DWORD = 5082;\n-pub const ERROR_CLUSTER_DATABASE_SEQMISMATCH: DWORD = 5083;\n-pub const ERROR_RESMON_INVALID_STATE: DWORD = 5084;\n-pub const ERROR_CLUSTER_GUM_NOT_LOCKER: DWORD = 5085;\n-pub const ERROR_QUORUM_DISK_NOT_FOUND: DWORD = 5086;\n-pub const ERROR_DATABASE_BACKUP_CORRUPT: DWORD = 5087;\n-pub const ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT: DWORD = 5088;\n-pub const ERROR_RESOURCE_PROPERTY_UNCHANGEABLE: DWORD = 5089;\n-pub const ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE: DWORD = 5890;\n-pub const ERROR_CLUSTER_QUORUMLOG_NOT_FOUND: DWORD = 5891;\n-pub const ERROR_CLUSTER_MEMBERSHIP_HALT: DWORD = 5892;\n-pub const ERROR_CLUSTER_INSTANCE_ID_MISMATCH: DWORD = 5893;\n-pub const ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP: DWORD = 5894;\n-pub const ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH: DWORD = 5895;\n-pub const ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP: DWORD = 5896;\n-pub const ERROR_CLUSTER_PARAMETER_MISMATCH: DWORD = 5897;\n-pub const ERROR_NODE_CANNOT_BE_CLUSTERED: DWORD = 5898;\n-pub const ERROR_CLUSTER_WRONG_OS_VERSION: DWORD = 5899;\n-pub const ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME: DWORD = 5900;\n-pub const ERROR_CLUSCFG_ALREADY_COMMITTED: DWORD = 5901;\n-pub const ERROR_CLUSCFG_ROLLBACK_FAILED: DWORD = 5902;\n-pub const ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT: DWORD = 5903;\n-pub const ERROR_CLUSTER_OLD_VERSION: DWORD = 5904;\n-pub const ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME: DWORD = 5905;\n-pub const ERROR_ENCRYPTION_FAILED: DWORD = 6000;\n-pub const ERROR_DECRYPTION_FAILED: DWORD = 6001;\n-pub const ERROR_FILE_ENCRYPTED: DWORD = 6002;\n-pub const ERROR_NO_RECOVERY_POLICY: DWORD = 6003;\n-pub const ERROR_NO_EFS: DWORD = 6004;\n-pub const ERROR_WRONG_EFS: DWORD = 6005;\n-pub const ERROR_NO_USER_KEYS: DWORD = 6006;\n-pub const ERROR_FILE_NOT_ENCRYPTED: DWORD = 6007;\n-pub const ERROR_NOT_EXPORT_FORMAT: DWORD = 6008;\n-pub const ERROR_FILE_READ_ONLY: DWORD = 6009;\n-pub const ERROR_DIR_EFS_DISALLOWED: DWORD = 6010;\n-pub const ERROR_EFS_SERVER_NOT_TRUSTED: DWORD = 6011;\n-pub const ERROR_BAD_RECOVERY_POLICY: DWORD = 6012;\n-pub const ERROR_EFS_ALG_BLOB_TOO_BIG: DWORD = 6013;\n-pub const ERROR_VOLUME_NOT_SUPPORT_EFS: DWORD = 6014;\n-pub const ERROR_EFS_DISABLED: DWORD = 6015;\n-pub const ERROR_EFS_VERSION_NOT_SUPPORT: DWORD = 6016;\n-pub const ERROR_NO_BROWSER_SERVERS_FOUND: DWORD = 6118;\n-pub const ERROR_CTX_WINSTATION_NAME_INVALID: DWORD = 7001;\n-pub const ERROR_CTX_INVALID_PD: DWORD = 7002;\n-pub const ERROR_CTX_PD_NOT_FOUND: DWORD = 7003;\n-pub const ERROR_CTX_WD_NOT_FOUND: DWORD = 7004;\n-pub const ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY: DWORD = 7005;\n-pub const ERROR_CTX_SERVICE_NAME_COLLISION: DWORD = 7006;\n-pub const ERROR_CTX_CLOSE_PENDING: DWORD = 7007;\n-pub const ERROR_CTX_NO_OUTBUF: DWORD = 7008;\n-pub const ERROR_CTX_MODEM_INF_NOT_FOUND: DWORD = 7009;\n-pub const ERROR_CTX_INVALID_MODEMNAME: DWORD = 7010;\n-pub const ERROR_CTX_MODEM_RESPONSE_ERROR: DWORD = 7011;\n-pub const ERROR_CTX_MODEM_RESPONSE_TIMEOUT: DWORD = 7012;\n-pub const ERROR_CTX_MODEM_RESPONSE_NO_CARRIER: DWORD = 7013;\n-pub const ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE: DWORD = 7014;\n-pub const ERROR_CTX_MODEM_RESPONSE_BUSY: DWORD = 7015;\n-pub const ERROR_CTX_MODEM_RESPONSE_VOICE: DWORD = 7016;\n-pub const ERROR_CTX_TD_ERROR: DWORD = 7017;\n-pub const ERROR_CTX_WINSTATION_NOT_FOUND: DWORD = 7022;\n-pub const ERROR_CTX_WINSTATION_ALREADY_EXISTS: DWORD = 7023;\n-pub const ERROR_CTX_WINSTATION_BUSY: DWORD = 7024;\n-pub const ERROR_CTX_BAD_VIDEO_MODE: DWORD = 7025;\n-pub const ERROR_CTX_GRAPHICS_INVALID: DWORD = 7035;\n-pub const ERROR_CTX_LOGON_DISABLED: DWORD = 7037;\n-pub const ERROR_CTX_NOT_CONSOLE: DWORD = 7038;\n-pub const ERROR_CTX_CLIENT_QUERY_TIMEOUT: DWORD = 7040;\n-pub const ERROR_CTX_CONSOLE_DISCONNECT: DWORD = 7041;\n-pub const ERROR_CTX_CONSOLE_CONNECT: DWORD = 7042;\n-pub const ERROR_CTX_SHADOW_DENIED: DWORD = 7044;\n-pub const ERROR_CTX_WINSTATION_ACCESS_DENIED: DWORD = 7045;\n-pub const ERROR_CTX_INVALID_WD: DWORD = 7049;\n-pub const ERROR_CTX_SHADOW_INVALID: DWORD = 7050;\n-pub const ERROR_CTX_SHADOW_DISABLED: DWORD = 7051;\n-pub const ERROR_CTX_CLIENT_LICENSE_IN_USE: DWORD = 7052;\n-pub const ERROR_CTX_CLIENT_LICENSE_NOT_SET: DWORD = 7053;\n-pub const ERROR_CTX_LICENSE_NOT_AVAILABLE: DWORD = 7054;\n-pub const ERROR_CTX_LICENSE_CLIENT_INVALID: DWORD = 7055;\n-pub const ERROR_CTX_LICENSE_EXPIRED: DWORD = 7056;\n-pub const ERROR_CTX_SHADOW_NOT_RUNNING: DWORD = 7057;\n-pub const ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE: DWORD = 7058;\n-pub const ERROR_ACTIVATION_COUNT_EXCEEDED: DWORD = 7059;\n-pub const ERROR_DS_NOT_INSTALLED: DWORD = 8200;\n-pub const ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY: DWORD = 8201;\n-pub const ERROR_DS_NO_ATTRIBUTE_OR_VALUE: DWORD = 8202;\n-pub const ERROR_DS_INVALID_ATTRIBUTE_SYNTAX: DWORD = 8203;\n-pub const ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED: DWORD = 8204;\n-pub const ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS: DWORD = 8205;\n-pub const ERROR_DS_BUSY: DWORD = 8206;\n-pub const ERROR_DS_UNAVAILABLE: DWORD = 8207;\n-pub const ERROR_DS_NO_RIDS_ALLOCATED: DWORD = 8208;\n-pub const ERROR_DS_NO_MORE_RIDS: DWORD = 8209;\n-pub const ERROR_DS_INCORRECT_ROLE_OWNER: DWORD = 8210;\n-pub const ERROR_DS_RIDMGR_INIT_ERROR: DWORD = 8211;\n-pub const ERROR_DS_OBJ_CLASS_VIOLATION: DWORD = 8212;\n-pub const ERROR_DS_CANT_ON_NON_LEAF: DWORD = 8213;\n-pub const ERROR_DS_CANT_ON_RDN: DWORD = 8214;\n-pub const ERROR_DS_CANT_MOD_OBJ_CLASS: DWORD = 8215;\n-pub const ERROR_DS_CROSS_DOM_MOVE_ERROR: DWORD = 8216;\n-pub const ERROR_DS_GC_NOT_AVAILABLE: DWORD = 8217;\n-pub const ERROR_SHARED_POLICY: DWORD = 8218;\n-pub const ERROR_POLICY_OBJECT_NOT_FOUND: DWORD = 8219;\n-pub const ERROR_POLICY_ONLY_IN_DS: DWORD = 8220;\n-pub const ERROR_PROMOTION_ACTIVE: DWORD = 8221;\n-pub const ERROR_NO_PROMOTION_ACTIVE: DWORD = 8222;\n-pub const ERROR_DS_OPERATIONS_ERROR: DWORD = 8224;\n-pub const ERROR_DS_PROTOCOL_ERROR: DWORD = 8225;\n-pub const ERROR_DS_TIMELIMIT_EXCEEDED: DWORD = 8226;\n-pub const ERROR_DS_SIZELIMIT_EXCEEDED: DWORD = 8227;\n-pub const ERROR_DS_ADMIN_LIMIT_EXCEEDED: DWORD = 8228;\n-pub const ERROR_DS_COMPARE_FALSE: DWORD = 8229;\n-pub const ERROR_DS_COMPARE_TRUE: DWORD = 8230;\n-pub const ERROR_DS_AUTH_METHOD_NOT_SUPPORTED: DWORD = 8231;\n-pub const ERROR_DS_STRONG_AUTH_REQUIRED: DWORD = 8232;\n-pub const ERROR_DS_INAPPROPRIATE_AUTH: DWORD = 8233;\n-pub const ERROR_DS_AUTH_UNKNOWN: DWORD = 8234;\n-pub const ERROR_DS_REFERRAL: DWORD = 8235;\n-pub const ERROR_DS_UNAVAILABLE_CRIT_EXTENSION: DWORD = 8236;\n-pub const ERROR_DS_CONFIDENTIALITY_REQUIRED: DWORD = 8237;\n-pub const ERROR_DS_INAPPROPRIATE_MATCHING: DWORD = 8238;\n-pub const ERROR_DS_CONSTRAINT_VIOLATION: DWORD = 8239;\n-pub const ERROR_DS_NO_SUCH_OBJECT: DWORD = 8240;\n-pub const ERROR_DS_ALIAS_PROBLEM: DWORD = 8241;\n-pub const ERROR_DS_INVALID_DN_SYNTAX: DWORD = 8242;\n-pub const ERROR_DS_IS_LEAF: DWORD = 8243;\n-pub const ERROR_DS_ALIAS_DEREF_PROBLEM: DWORD = 8244;\n-pub const ERROR_DS_UNWILLING_TO_PERFORM: DWORD = 8245;\n-pub const ERROR_DS_LOOP_DETECT: DWORD = 8246;\n-pub const ERROR_DS_NAMING_VIOLATION: DWORD = 8247;\n-pub const ERROR_DS_OBJECT_RESULTS_TOO_LARGE: DWORD = 8248;\n-pub const ERROR_DS_AFFECTS_MULTIPLE_DSAS: DWORD = 8249;\n-pub const ERROR_DS_SERVER_DOWN: DWORD = 8250;\n-pub const ERROR_DS_LOCAL_ERROR: DWORD = 8251;\n-pub const ERROR_DS_ENCODING_ERROR: DWORD = 8252;\n-pub const ERROR_DS_DECODING_ERROR: DWORD = 8253;\n-pub const ERROR_DS_FILTER_UNKNOWN: DWORD = 8254;\n-pub const ERROR_DS_PARAM_ERROR: DWORD = 8255;\n-pub const ERROR_DS_NOT_SUPPORTED: DWORD = 8256;\n-pub const ERROR_DS_NO_RESULTS_RETURNED: DWORD = 8257;\n-pub const ERROR_DS_CONTROL_NOT_FOUND: DWORD = 8258;\n-pub const ERROR_DS_CLIENT_LOOP: DWORD = 8259;\n-pub const ERROR_DS_REFERRAL_LIMIT_EXCEEDED: DWORD = 8260;\n-pub const ERROR_DS_SORT_CONTROL_MISSING: DWORD = 8261;\n-pub const ERROR_DS_OFFSET_RANGE_ERROR: DWORD = 8262;\n-pub const ERROR_DS_ROOT_MUST_BE_NC: DWORD = 8301;\n-pub const ERROR_DS_ADD_REPLICA_INHIBITED: DWORD = 8302;\n-pub const ERROR_DS_ATT_NOT_DEF_IN_SCHEMA: DWORD = 8303;\n-pub const ERROR_DS_MAX_OBJ_SIZE_EXCEEDED: DWORD = 8304;\n-pub const ERROR_DS_OBJ_STRING_NAME_EXISTS: DWORD = 8305;\n-pub const ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA: DWORD = 8306;\n-pub const ERROR_DS_RDN_DOESNT_MATCH_SCHEMA: DWORD = 8307;\n-pub const ERROR_DS_NO_REQUESTED_ATTS_FOUND: DWORD = 8308;\n-pub const ERROR_DS_USER_BUFFER_TO_SMALL: DWORD = 8309;\n-pub const ERROR_DS_ATT_IS_NOT_ON_OBJ: DWORD = 8310;\n-pub const ERROR_DS_ILLEGAL_MOD_OPERATION: DWORD = 8311;\n-pub const ERROR_DS_OBJ_TOO_LARGE: DWORD = 8312;\n-pub const ERROR_DS_BAD_INSTANCE_TYPE: DWORD = 8313;\n-pub const ERROR_DS_MASTERDSA_REQUIRED: DWORD = 8314;\n-pub const ERROR_DS_OBJECT_CLASS_REQUIRED: DWORD = 8315;\n-pub const ERROR_DS_MISSING_REQUIRED_ATT: DWORD = 8316;\n-pub const ERROR_DS_ATT_NOT_DEF_FOR_CLASS: DWORD = 8317;\n-pub const ERROR_DS_ATT_ALREADY_EXISTS: DWORD = 8318;\n-pub const ERROR_DS_CANT_ADD_ATT_VALUES: DWORD = 8320;\n-pub const ERROR_DS_SINGLE_VALUE_CONSTRAINT: DWORD = 8321;\n-pub const ERROR_DS_RANGE_CONSTRAINT: DWORD = 8322;\n-pub const ERROR_DS_ATT_VAL_ALREADY_EXISTS: DWORD = 8323;\n-pub const ERROR_DS_CANT_REM_MISSING_ATT: DWORD = 8324;\n-pub const ERROR_DS_CANT_REM_MISSING_ATT_VAL: DWORD = 8325;\n-pub const ERROR_DS_ROOT_CANT_BE_SUBREF: DWORD = 8326;\n-pub const ERROR_DS_NO_CHAINING: DWORD = 8327;\n-pub const ERROR_DS_NO_CHAINED_EVAL: DWORD = 8328;\n-pub const ERROR_DS_NO_PARENT_OBJECT: DWORD = 8329;\n-pub const ERROR_DS_PARENT_IS_AN_ALIAS: DWORD = 8330;\n-pub const ERROR_DS_CANT_MIX_MASTER_AND_REPS: DWORD = 8331;\n-pub const ERROR_DS_CHILDREN_EXIST: DWORD = 8332;\n-pub const ERROR_DS_OBJ_NOT_FOUND: DWORD = 8333;\n-pub const ERROR_DS_ALIASED_OBJ_MISSING: DWORD = 8334;\n-pub const ERROR_DS_BAD_NAME_SYNTAX: DWORD = 8335;\n-pub const ERROR_DS_ALIAS_POINTS_TO_ALIAS: DWORD = 8336;\n-pub const ERROR_DS_CANT_DEREF_ALIAS: DWORD = 8337;\n-pub const ERROR_DS_OUT_OF_SCOPE: DWORD = 8338;\n-pub const ERROR_DS_OBJECT_BEING_REMOVED: DWORD = 8339;\n-pub const ERROR_DS_CANT_DELETE_DSA_OBJ: DWORD = 8340;\n-pub const ERROR_DS_GENERIC_ERROR: DWORD = 8341;\n-pub const ERROR_DS_DSA_MUST_BE_INT_MASTER: DWORD = 8342;\n-pub const ERROR_DS_CLASS_NOT_DSA: DWORD = 8343;\n-pub const ERROR_DS_INSUFF_ACCESS_RIGHTS: DWORD = 8344;\n-pub const ERROR_DS_ILLEGAL_SUPERIOR: DWORD = 8345;\n-pub const ERROR_DS_ATTRIBUTE_OWNED_BY_SAM: DWORD = 8346;\n-pub const ERROR_DS_NAME_TOO_MANY_PARTS: DWORD = 8347;\n-pub const ERROR_DS_NAME_TOO_LONG: DWORD = 8348;\n-pub const ERROR_DS_NAME_VALUE_TOO_LONG: DWORD = 8349;\n-pub const ERROR_DS_NAME_UNPARSEABLE: DWORD = 8350;\n-pub const ERROR_DS_NAME_TYPE_UNKNOWN: DWORD = 8351;\n-pub const ERROR_DS_NOT_AN_OBJECT: DWORD = 8352;\n-pub const ERROR_DS_SEC_DESC_TOO_SHORT: DWORD = 8353;\n-pub const ERROR_DS_SEC_DESC_INVALID: DWORD = 8354;\n-pub const ERROR_DS_NO_DELETED_NAME: DWORD = 8355;\n-pub const ERROR_DS_SUBREF_MUST_HAVE_PARENT: DWORD = 8356;\n-pub const ERROR_DS_NCNAME_MUST_BE_NC: DWORD = 8357;\n-pub const ERROR_DS_CANT_ADD_SYSTEM_ONLY: DWORD = 8358;\n-pub const ERROR_DS_CLASS_MUST_BE_CONCRETE: DWORD = 8359;\n-pub const ERROR_DS_INVALID_DMD: DWORD = 8360;\n-pub const ERROR_DS_OBJ_GUID_EXISTS: DWORD = 8361;\n-pub const ERROR_DS_NOT_ON_BACKLINK: DWORD = 8362;\n-pub const ERROR_DS_NO_CROSSREF_FOR_NC: DWORD = 8363;\n-pub const ERROR_DS_SHUTTING_DOWN: DWORD = 8364;\n-pub const ERROR_DS_UNKNOWN_OPERATION: DWORD = 8365;\n-pub const ERROR_DS_INVALID_ROLE_OWNER: DWORD = 8366;\n-pub const ERROR_DS_COULDNT_CONTACT_FSMO: DWORD = 8367;\n-pub const ERROR_DS_CROSS_NC_DN_RENAME: DWORD = 8368;\n-pub const ERROR_DS_CANT_MOD_SYSTEM_ONLY: DWORD = 8369;\n-pub const ERROR_DS_REPLICATOR_ONLY: DWORD = 8370;\n-pub const ERROR_DS_OBJ_CLASS_NOT_DEFINED: DWORD = 8371;\n-pub const ERROR_DS_OBJ_CLASS_NOT_SUBCLASS: DWORD = 8372;\n-pub const ERROR_DS_NAME_REFERENCE_INVALID: DWORD = 8373;\n-pub const ERROR_DS_CROSS_REF_EXISTS: DWORD = 8374;\n-pub const ERROR_DS_CANT_DEL_MASTER_CROSSREF: DWORD = 8375;\n-pub const ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD: DWORD = 8376;\n-pub const ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX: DWORD = 8377;\n-pub const ERROR_DS_DUP_RDN: DWORD = 8378;\n-pub const ERROR_DS_DUP_OID: DWORD = 8379;\n-pub const ERROR_DS_DUP_MAPI_ID: DWORD = 8380;\n-pub const ERROR_DS_DUP_SCHEMA_ID_GUID: DWORD = 8381;\n-pub const ERROR_DS_DUP_LDAP_DISPLAY_NAME: DWORD = 8382;\n-pub const ERROR_DS_SEMANTIC_ATT_TEST: DWORD = 8383;\n-pub const ERROR_DS_SYNTAX_MISMATCH: DWORD = 8384;\n-pub const ERROR_DS_EXISTS_IN_MUST_HAVE: DWORD = 8385;\n-pub const ERROR_DS_EXISTS_IN_MAY_HAVE: DWORD = 8386;\n-pub const ERROR_DS_NONEXISTENT_MAY_HAVE: DWORD = 8387;\n-pub const ERROR_DS_NONEXISTENT_MUST_HAVE: DWORD = 8388;\n-pub const ERROR_DS_AUX_CLS_TEST_FAIL: DWORD = 8389;\n-pub const ERROR_DS_NONEXISTENT_POSS_SUP: DWORD = 8390;\n-pub const ERROR_DS_SUB_CLS_TEST_FAIL: DWORD = 8391;\n-pub const ERROR_DS_BAD_RDN_ATT_ID_SYNTAX: DWORD = 8392;\n-pub const ERROR_DS_EXISTS_IN_AUX_CLS: DWORD = 8393;\n-pub const ERROR_DS_EXISTS_IN_SUB_CLS: DWORD = 8394;\n-pub const ERROR_DS_EXISTS_IN_POSS_SUP: DWORD = 8395;\n-pub const ERROR_DS_RECALCSCHEMA_FAILED: DWORD = 8396;\n-pub const ERROR_DS_TREE_DELETE_NOT_FINISHED: DWORD = 8397;\n-pub const ERROR_DS_CANT_DELETE: DWORD = 8398;\n-pub const ERROR_DS_ATT_SCHEMA_REQ_ID: DWORD = 8399;\n-pub const ERROR_DS_BAD_ATT_SCHEMA_SYNTAX: DWORD = 8400;\n-pub const ERROR_DS_CANT_CACHE_ATT: DWORD = 8401;\n-pub const ERROR_DS_CANT_CACHE_CLASS: DWORD = 8402;\n-pub const ERROR_DS_CANT_REMOVE_ATT_CACHE: DWORD = 8403;\n-pub const ERROR_DS_CANT_REMOVE_CLASS_CACHE: DWORD = 8404;\n-pub const ERROR_DS_CANT_RETRIEVE_DN: DWORD = 8405;\n-pub const ERROR_DS_MISSING_SUPREF: DWORD = 8406;\n-pub const ERROR_DS_CANT_RETRIEVE_INSTANCE: DWORD = 8407;\n-pub const ERROR_DS_CODE_INCONSISTENCY: DWORD = 8408;\n-pub const ERROR_DS_DATABASE_ERROR: DWORD = 8409;\n-pub const ERROR_DS_GOVERNSID_MISSING: DWORD = 8410;\n-pub const ERROR_DS_MISSING_EXPECTED_ATT: DWORD = 8411;\n-pub const ERROR_DS_NCNAME_MISSING_CR_REF: DWORD = 8412;\n-pub const ERROR_DS_SECURITY_CHECKING_ERROR: DWORD = 8413;\n-pub const ERROR_DS_SCHEMA_NOT_LOADED: DWORD = 8414;\n-pub const ERROR_DS_SCHEMA_ALLOC_FAILED: DWORD = 8415;\n-pub const ERROR_DS_ATT_SCHEMA_REQ_SYNTAX: DWORD = 8416;\n-pub const ERROR_DS_GCVERIFY_ERROR: DWORD = 8417;\n-pub const ERROR_DS_DRA_SCHEMA_MISMATCH: DWORD = 8418;\n-pub const ERROR_DS_CANT_FIND_DSA_OBJ: DWORD = 8419;\n-pub const ERROR_DS_CANT_FIND_EXPECTED_NC: DWORD = 8420;\n-pub const ERROR_DS_CANT_FIND_NC_IN_CACHE: DWORD = 8421;\n-pub const ERROR_DS_CANT_RETRIEVE_CHILD: DWORD = 8422;\n-pub const ERROR_DS_SECURITY_ILLEGAL_MODIFY: DWORD = 8423;\n-pub const ERROR_DS_CANT_REPLACE_HIDDEN_REC: DWORD = 8424;\n-pub const ERROR_DS_BAD_HIERARCHY_FILE: DWORD = 8425;\n-pub const ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED: DWORD = 8426;\n-pub const ERROR_DS_CONFIG_PARAM_MISSING: DWORD = 8427;\n-pub const ERROR_DS_COUNTING_AB_INDICES_FAILED: DWORD = 8428;\n-pub const ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED: DWORD = 8429;\n-pub const ERROR_DS_INTERNAL_FAILURE: DWORD = 8430;\n-pub const ERROR_DS_UNKNOWN_ERROR: DWORD = 8431;\n-pub const ERROR_DS_ROOT_REQUIRES_CLASS_TOP: DWORD = 8432;\n-pub const ERROR_DS_REFUSING_FSMO_ROLES: DWORD = 8433;\n-pub const ERROR_DS_MISSING_FSMO_SETTINGS: DWORD = 8434;\n-pub const ERROR_DS_UNABLE_TO_SURRENDER_ROLES: DWORD = 8435;\n-pub const ERROR_DS_DRA_GENERIC: DWORD = 8436;\n-pub const ERROR_DS_DRA_INVALID_PARAMETER: DWORD = 8437;\n-pub const ERROR_DS_DRA_BUSY: DWORD = 8438;\n-pub const ERROR_DS_DRA_BAD_DN: DWORD = 8439;\n-pub const ERROR_DS_DRA_BAD_NC: DWORD = 8440;\n-pub const ERROR_DS_DRA_DN_EXISTS: DWORD = 8441;\n-pub const ERROR_DS_DRA_INTERNAL_ERROR: DWORD = 8442;\n-pub const ERROR_DS_DRA_INCONSISTENT_DIT: DWORD = 8443;\n-pub const ERROR_DS_DRA_CONNECTION_FAILED: DWORD = 8444;\n-pub const ERROR_DS_DRA_BAD_INSTANCE_TYPE: DWORD = 8445;\n-pub const ERROR_DS_DRA_OUT_OF_MEM: DWORD = 8446;\n-pub const ERROR_DS_DRA_MAIL_PROBLEM: DWORD = 8447;\n-pub const ERROR_DS_DRA_REF_ALREADY_EXISTS: DWORD = 8448;\n-pub const ERROR_DS_DRA_REF_NOT_FOUND: DWORD = 8449;\n-pub const ERROR_DS_DRA_OBJ_IS_REP_SOURCE: DWORD = 8450;\n-pub const ERROR_DS_DRA_DB_ERROR: DWORD = 8451;\n-pub const ERROR_DS_DRA_NO_REPLICA: DWORD = 8452;\n-pub const ERROR_DS_DRA_ACCESS_DENIED: DWORD = 8453;\n-pub const ERROR_DS_DRA_NOT_SUPPORTED: DWORD = 8454;\n-pub const ERROR_DS_DRA_RPC_CANCELLED: DWORD = 8455;\n-pub const ERROR_DS_DRA_SOURCE_DISABLED: DWORD = 8456;\n-pub const ERROR_DS_DRA_SINK_DISABLED: DWORD = 8457;\n-pub const ERROR_DS_DRA_NAME_COLLISION: DWORD = 8458;\n-pub const ERROR_DS_DRA_SOURCE_REINSTALLED: DWORD = 8459;\n-pub const ERROR_DS_DRA_MISSING_PARENT: DWORD = 8460;\n-pub const ERROR_DS_DRA_PREEMPTED: DWORD = 8461;\n-pub const ERROR_DS_DRA_ABANDON_SYNC: DWORD = 8462;\n-pub const ERROR_DS_DRA_SHUTDOWN: DWORD = 8463;\n-pub const ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET: DWORD = 8464;\n-pub const ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA: DWORD = 8465;\n-pub const ERROR_DS_DRA_EXTN_CONNECTION_FAILED: DWORD = 8466;\n-pub const ERROR_DS_INSTALL_SCHEMA_MISMATCH: DWORD = 8467;\n-pub const ERROR_DS_DUP_LINK_ID: DWORD = 8468;\n-pub const ERROR_DS_NAME_ERROR_RESOLVING: DWORD = 8469;\n-pub const ERROR_DS_NAME_ERROR_NOT_FOUND: DWORD = 8470;\n-pub const ERROR_DS_NAME_ERROR_NOT_UNIQUE: DWORD = 8471;\n-pub const ERROR_DS_NAME_ERROR_NO_MAPPING: DWORD = 8472;\n-pub const ERROR_DS_NAME_ERROR_DOMAIN_ONLY: DWORD = 8473;\n-pub const ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING: DWORD = 8474;\n-pub const ERROR_DS_CONSTRUCTED_ATT_MOD: DWORD = 8475;\n-pub const ERROR_DS_WRONG_OM_OBJ_CLASS: DWORD = 8476;\n-pub const ERROR_DS_DRA_REPL_PENDING: DWORD = 8477;\n-pub const ERROR_DS_DS_REQUIRED: DWORD = 8478;\n-pub const ERROR_DS_INVALID_LDAP_DISPLAY_NAME: DWORD = 8479;\n-pub const ERROR_DS_NON_BASE_SEARCH: DWORD = 8480;\n-pub const ERROR_DS_CANT_RETRIEVE_ATTS: DWORD = 8481;\n-pub const ERROR_DS_BACKLINK_WITHOUT_LINK: DWORD = 8482;\n-pub const ERROR_DS_EPOCH_MISMATCH: DWORD = 8483;\n-pub const ERROR_DS_SRC_NAME_MISMATCH: DWORD = 8484;\n-pub const ERROR_DS_SRC_AND_DST_NC_IDENTICAL: DWORD = 8485;\n-pub const ERROR_DS_DST_NC_MISMATCH: DWORD = 8486;\n-pub const ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC: DWORD = 8487;\n-pub const ERROR_DS_SRC_GUID_MISMATCH: DWORD = 8488;\n-pub const ERROR_DS_CANT_MOVE_DELETED_OBJECT: DWORD = 8489;\n-pub const ERROR_DS_PDC_OPERATION_IN_PROGRESS: DWORD = 8490;\n-pub const ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD: DWORD = 8491;\n-pub const ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION: DWORD = 8492;\n-pub const ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS: DWORD = 8493;\n-pub const ERROR_DS_NC_MUST_HAVE_NC_PARENT: DWORD = 8494;\n-pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE: DWORD = 8495;\n-pub const ERROR_DS_DST_DOMAIN_NOT_NATIVE: DWORD = 8496;\n-pub const ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER: DWORD = 8497;\n-pub const ERROR_DS_CANT_MOVE_ACCOUNT_GROUP: DWORD = 8498;\n-pub const ERROR_DS_CANT_MOVE_RESOURCE_GROUP: DWORD = 8499;\n-pub const ERROR_DS_INVALID_SEARCH_FLAG: DWORD = 8500;\n-pub const ERROR_DS_NO_TREE_DELETE_ABOVE_NC: DWORD = 8501;\n-pub const ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE: DWORD = 8502;\n-pub const ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE: DWORD = 8503;\n-pub const ERROR_DS_SAM_INIT_FAILURE: DWORD = 8504;\n-pub const ERROR_DS_SENSITIVE_GROUP_VIOLATION: DWORD = 8505;\n-pub const ERROR_DS_CANT_MOD_PRIMARYGROUPID: DWORD = 8506;\n-pub const ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD: DWORD = 8507;\n-pub const ERROR_DS_NONSAFE_SCHEMA_CHANGE: DWORD = 8508;\n-pub const ERROR_DS_SCHEMA_UPDATE_DISALLOWED: DWORD = 8509;\n-pub const ERROR_DS_CANT_CREATE_UNDER_SCHEMA: DWORD = 8510;\n-pub const ERROR_DS_INSTALL_NO_SRC_SCH_VERSION: DWORD = 8511;\n-pub const ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE: DWORD = 8512;\n-pub const ERROR_DS_INVALID_GROUP_TYPE: DWORD = 8513;\n-pub const ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN: DWORD = 8514;\n-pub const ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN: DWORD = 8515;\n-pub const ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER: DWORD = 8516;\n-pub const ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER: DWORD = 8517;\n-pub const ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER: DWORD = 8518;\n-pub const ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER: DWORD = 8519;\n-pub const ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER: DWORD = 8520;\n-pub const ERROR_DS_HAVE_PRIMARY_MEMBERS: DWORD = 8521;\n-pub const ERROR_DS_STRING_SD_CONVERSION_FAILED: DWORD = 8522;\n-pub const ERROR_DS_NAMING_MASTER_GC: DWORD = 8523;\n-pub const ERROR_DS_DNS_LOOKUP_FAILURE: DWORD = 8524;\n-pub const ERROR_DS_COULDNT_UPDATE_SPNS: DWORD = 8525;\n-pub const ERROR_DS_CANT_RETRIEVE_SD: DWORD = 8526;\n-pub const ERROR_DS_KEY_NOT_UNIQUE: DWORD = 8527;\n-pub const ERROR_DS_WRONG_LINKED_ATT_SYNTAX: DWORD = 8528;\n-pub const ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD: DWORD = 8529;\n-pub const ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY: DWORD = 8530;\n-pub const ERROR_DS_CANT_START: DWORD = 8531;\n-pub const ERROR_DS_INIT_FAILURE: DWORD = 8532;\n-pub const ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION: DWORD = 8533;\n-pub const ERROR_DS_SOURCE_DOMAIN_IN_FOREST: DWORD = 8534;\n-pub const ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST: DWORD = 8535;\n-pub const ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED: DWORD = 8536;\n-pub const ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN: DWORD = 8537;\n-pub const ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER: DWORD = 8538;\n-pub const ERROR_DS_SRC_SID_EXISTS_IN_FOREST: DWORD = 8539;\n-pub const ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH: DWORD = 8540;\n-pub const ERROR_SAM_INIT_FAILURE: DWORD = 8541;\n-pub const ERROR_DS_DRA_SCHEMA_INFO_SHIP: DWORD = 8542;\n-pub const ERROR_DS_DRA_SCHEMA_CONFLICT: DWORD = 8543;\n-pub const ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT: DWORD = 8544;\n-pub const ERROR_DS_DRA_OBJ_NC_MISMATCH: DWORD = 8545;\n-pub const ERROR_DS_NC_STILL_HAS_DSAS: DWORD = 8546;\n-pub const ERROR_DS_GC_REQUIRED: DWORD = 8547;\n-pub const ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY: DWORD = 8548;\n-pub const ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS: DWORD = 8549;\n-pub const ERROR_DS_CANT_ADD_TO_GC: DWORD = 8550;\n-pub const ERROR_DS_NO_CHECKPOINT_WITH_PDC: DWORD = 8551;\n-pub const ERROR_DS_SOURCE_AUDITING_NOT_ENABLED: DWORD = 8552;\n-pub const ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC: DWORD = 8553;\n-pub const ERROR_DS_INVALID_NAME_FOR_SPN: DWORD = 8554;\n-pub const ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS: DWORD = 8555;\n-pub const ERROR_DS_UNICODEPWD_NOT_IN_QUOTES: DWORD = 8556;\n-pub const ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED: DWORD = 8557;\n-pub const ERROR_DS_MUST_BE_RUN_ON_DST_DC: DWORD = 8558;\n-pub const ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER: DWORD = 8559;\n-pub const ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ: DWORD = 8560;\n-pub const ERROR_DS_INIT_FAILURE_CONSOLE: DWORD = 8561;\n-pub const ERROR_DS_SAM_INIT_FAILURE_CONSOLE: DWORD = 8562;\n-pub const ERROR_DS_FOREST_VERSION_TOO_HIGH: DWORD = 8563;\n-pub const ERROR_DS_DOMAIN_VERSION_TOO_HIGH: DWORD = 8564;\n-pub const ERROR_DS_FOREST_VERSION_TOO_LOW: DWORD = 8565;\n-pub const ERROR_DS_DOMAIN_VERSION_TOO_LOW: DWORD = 8566;\n-pub const ERROR_DS_INCOMPATIBLE_VERSION: DWORD = 8567;\n-pub const ERROR_DS_LOW_DSA_VERSION: DWORD = 8568;\n-pub const ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN: DWORD = 8569;\n-pub const ERROR_DS_NOT_SUPPORTED_SORT_ORDER: DWORD = 8570;\n-pub const ERROR_DS_NAME_NOT_UNIQUE: DWORD = 8571;\n-pub const ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4: DWORD = 8572;\n-pub const ERROR_DS_OUT_OF_VERSION_STORE: DWORD = 8573;\n-pub const ERROR_DS_INCOMPATIBLE_CONTROLS_USED: DWORD = 8574;\n-pub const ERROR_DS_NO_REF_DOMAIN: DWORD = 8575;\n-pub const ERROR_DS_RESERVED_LINK_ID: DWORD = 8576;\n-pub const ERROR_DS_LINK_ID_NOT_AVAILABLE: DWORD = 8577;\n-pub const ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER: DWORD = 8578;\n-pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE: DWORD = 8579;\n-pub const ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC: DWORD = 8580;\n-pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG: DWORD = 8581;\n-pub const ERROR_DS_MODIFYDN_WRONG_GRANDPARENT: DWORD = 8582;\n-pub const ERROR_DS_NAME_ERROR_TRUST_REFERRAL: DWORD = 8583;\n-pub const ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER: DWORD = 8584;\n-pub const ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD: DWORD = 8585;\n-pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2: DWORD = 8586;\n-pub const ERROR_DS_THREAD_LIMIT_EXCEEDED: DWORD = 8587;\n-pub const ERROR_DS_NOT_CLOSEST: DWORD = 8588;\n-pub const ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF: DWORD = 8589;\n-pub const ERROR_DS_SINGLE_USER_MODE_FAILED: DWORD = 8590;\n-pub const ERROR_DS_NTDSCRIPT_SYNTAX_ERROR: DWORD = 8591;\n-pub const ERROR_DS_NTDSCRIPT_PROCESS_ERROR: DWORD = 8592;\n-pub const ERROR_DS_DIFFERENT_REPL_EPOCHS: DWORD = 8593;\n-pub const ERROR_DS_DRS_EXTENSIONS_CHANGED: DWORD = 8594;\n-pub const ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR: DWORD = 8595;\n-pub const ERROR_DS_NO_MSDS_INTID: DWORD = 8596;\n-pub const ERROR_DS_DUP_MSDS_INTID: DWORD = 8597;\n-pub const ERROR_DS_EXISTS_IN_RDNATTID: DWORD = 8598;\n-pub const ERROR_DS_AUTHORIZATION_FAILED: DWORD = 8599;\n-pub const ERROR_DS_INVALID_SCRIPT: DWORD = 8600;\n-pub const ERROR_DS_REMOTE_CROSSREF_OP_FAILED: DWORD = 8601;\n-pub const ERROR_DS_CROSS_REF_BUSY: DWORD = 8602;\n-pub const ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN: DWORD = 8603;\n-pub const ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC: DWORD = 8604;\n-pub const ERROR_DS_DUPLICATE_ID_FOUND: DWORD = 8605;\n-pub const ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT: DWORD = 8606;\n-pub const ERROR_DS_GROUP_CONVERSION_ERROR: DWORD = 8607;\n-pub const ERROR_DS_CANT_MOVE_APP_BASIC_GROUP: DWORD = 8608;\n-pub const ERROR_DS_CANT_MOVE_APP_QUERY_GROUP: DWORD = 8609;\n-pub const ERROR_DS_ROLE_NOT_VERIFIED: DWORD = 8610;\n-pub const ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL: DWORD = 8611;\n-pub const ERROR_DS_DOMAIN_RENAME_IN_PROGRESS: DWORD = 8612;\n-pub const ERROR_DS_EXISTING_AD_CHILD_NC: DWORD = 8613;\n-pub const ERROR_DS_REPL_LIFETIME_EXCEEDED: DWORD = 8614;\n-pub const ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER: DWORD = 8615;\n-pub const ERROR_DS_LDAP_SEND_QUEUE_FULL: DWORD = 8616;\n-pub const ERROR_DS_DRA_OUT_SCHEDULE_WINDOW: DWORD = 8617;\n-pub const ERROR_SXS_SECTION_NOT_FOUND: DWORD = 14000;\n-pub const ERROR_SXS_CANT_GEN_ACTCTX: DWORD = 14001;\n-pub const ERROR_SXS_INVALID_ACTCTXDATA_FORMAT: DWORD = 14002;\n-pub const ERROR_SXS_ASSEMBLY_NOT_FOUND: DWORD = 14003;\n-pub const ERROR_SXS_MANIFEST_FORMAT_ERROR: DWORD = 14004;\n-pub const ERROR_SXS_MANIFEST_PARSE_ERROR: DWORD = 14005;\n-pub const ERROR_SXS_ACTIVATION_CONTEXT_DISABLED: DWORD = 14006;\n-pub const ERROR_SXS_KEY_NOT_FOUND: DWORD = 14007;\n-pub const ERROR_SXS_VERSION_CONFLICT: DWORD = 14008;\n-pub const ERROR_SXS_WRONG_SECTION_TYPE: DWORD = 14009;\n-pub const ERROR_SXS_THREAD_QUERIES_DISABLED: DWORD = 14010;\n-pub const ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET: DWORD = 14011;\n-pub const ERROR_SXS_UNKNOWN_ENCODING_GROUP: DWORD = 14012;\n-pub const ERROR_SXS_UNKNOWN_ENCODING: DWORD = 14013;\n-pub const ERROR_SXS_INVALID_XML_NAMESPACE_URI: DWORD = 14014;\n-pub const ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED: DWORD = 14015;\n-pub const ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED: DWORD = 14016;\n-pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE: DWORD = 14017;\n-pub const ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE: DWORD = 14018;\n-pub const ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE: DWORD = 14019;\n-pub const ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT: DWORD = 14020;\n-pub const ERROR_SXS_DUPLICATE_DLL_NAME: DWORD = 14021;\n-pub const ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME: DWORD = 14022;\n-pub const ERROR_SXS_DUPLICATE_CLSID: DWORD = 14023;\n-pub const ERROR_SXS_DUPLICATE_IID: DWORD = 14024;\n-pub const ERROR_SXS_DUPLICATE_TLBID: DWORD = 14025;\n-pub const ERROR_SXS_DUPLICATE_PROGID: DWORD = 14026;\n-pub const ERROR_SXS_DUPLICATE_ASSEMBLY_NAME: DWORD = 14027;\n-pub const ERROR_SXS_FILE_HASH_MISMATCH: DWORD = 14028;\n-pub const ERROR_SXS_POLICY_PARSE_ERROR: DWORD = 14029;\n-pub const ERROR_SXS_XML_E_MISSINGQUOTE: DWORD = 14030;\n-pub const ERROR_SXS_XML_E_COMMENTSYNTAX: DWORD = 14031;\n-pub const ERROR_SXS_XML_E_BADSTARTNAMECHAR: DWORD = 14032;\n-pub const ERROR_SXS_XML_E_BADNAMECHAR: DWORD = 14033;\n-pub const ERROR_SXS_XML_E_BADCHARINSTRING: DWORD = 14034;\n-pub const ERROR_SXS_XML_E_XMLDECLSYNTAX: DWORD = 14035;\n-pub const ERROR_SXS_XML_E_BADCHARDATA: DWORD = 14036;\n-pub const ERROR_SXS_XML_E_MISSINGWHITESPACE: DWORD = 14037;\n-pub const ERROR_SXS_XML_E_EXPECTINGTAGEND: DWORD = 14038;\n-pub const ERROR_SXS_XML_E_MISSINGSEMICOLON: DWORD = 14039;\n-pub const ERROR_SXS_XML_E_UNBALANCEDPAREN: DWORD = 14040;\n-pub const ERROR_SXS_XML_E_INTERNALERROR: DWORD = 14041;\n-pub const ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE: DWORD = 14042;\n-pub const ERROR_SXS_XML_E_INCOMPLETE_ENCODING: DWORD = 14043;\n-pub const ERROR_SXS_XML_E_MISSING_PAREN: DWORD = 14044;\n-pub const ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE: DWORD = 14045;\n-pub const ERROR_SXS_XML_E_MULTIPLE_COLONS: DWORD = 14046;\n-pub const ERROR_SXS_XML_E_INVALID_DECIMAL: DWORD = 14047;\n-pub const ERROR_SXS_XML_E_INVALID_HEXIDECIMAL: DWORD = 14048;\n-pub const ERROR_SXS_XML_E_INVALID_UNICODE: DWORD = 14049;\n-pub const ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK: DWORD = 14050;\n-pub const ERROR_SXS_XML_E_UNEXPECTEDENDTAG: DWORD = 14051;\n-pub const ERROR_SXS_XML_E_UNCLOSEDTAG: DWORD = 14052;\n-pub const ERROR_SXS_XML_E_DUPLICATEATTRIBUTE: DWORD = 14053;\n-pub const ERROR_SXS_XML_E_MULTIPLEROOTS: DWORD = 14054;\n-pub const ERROR_SXS_XML_E_INVALIDATROOTLEVEL: DWORD = 14055;\n-pub const ERROR_SXS_XML_E_BADXMLDECL: DWORD = 14056;\n-pub const ERROR_SXS_XML_E_MISSINGROOT: DWORD = 14057;\n-pub const ERROR_SXS_XML_E_UNEXPECTEDEOF: DWORD = 14058;\n-pub const ERROR_SXS_XML_E_BADPEREFINSUBSET: DWORD = 14059;\n-pub const ERROR_SXS_XML_E_UNCLOSEDSTARTTAG: DWORD = 14060;\n-pub const ERROR_SXS_XML_E_UNCLOSEDENDTAG: DWORD = 14061;\n-pub const ERROR_SXS_XML_E_UNCLOSEDSTRING: DWORD = 14062;\n-pub const ERROR_SXS_XML_E_UNCLOSEDCOMMENT: DWORD = 14063;\n-pub const ERROR_SXS_XML_E_UNCLOSEDDECL: DWORD = 14064;\n-pub const ERROR_SXS_XML_E_UNCLOSEDCDATA: DWORD = 14065;\n-pub const ERROR_SXS_XML_E_RESERVEDNAMESPACE: DWORD = 14066;\n-pub const ERROR_SXS_XML_E_INVALIDENCODING: DWORD = 14067;\n-pub const ERROR_SXS_XML_E_INVALIDSWITCH: DWORD = 14068;\n-pub const ERROR_SXS_XML_E_BADXMLCASE: DWORD = 14069;\n-pub const ERROR_SXS_XML_E_INVALID_STANDALONE: DWORD = 14070;\n-pub const ERROR_SXS_XML_E_UNEXPECTED_STANDALONE: DWORD = 14071;\n-pub const ERROR_SXS_XML_E_INVALID_VERSION: DWORD = 14072;\n-pub const ERROR_SXS_XML_E_MISSINGEQUALS: DWORD = 14073;\n-pub const ERROR_SXS_PROTECTION_RECOVERY_FAILED: DWORD = 14074;\n-pub const ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT: DWORD = 14075;\n-pub const ERROR_SXS_PROTECTION_CATALOG_NOT_VALID: DWORD = 14076;\n-pub const ERROR_SXS_UNTRANSLATABLE_HRESULT: DWORD = 14077;\n-pub const ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING: DWORD = 14078;\n-pub const ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE: DWORD = 14079;\n-pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME: DWORD = 14080;\n-pub const ERROR_SXS_ASSEMBLY_MISSING: DWORD = 14081;\n-pub const ERROR_SXS_CORRUPT_ACTIVATION_STACK: DWORD = 14082;\n-pub const ERROR_SXS_CORRUPTION: DWORD = 14083;\n-pub const ERROR_SXS_EARLY_DEACTIVATION: DWORD = 14084;\n-pub const ERROR_SXS_INVALID_DEACTIVATION: DWORD = 14085;\n-pub const ERROR_SXS_MULTIPLE_DEACTIVATION: DWORD = 14086;\n-pub const ERROR_SXS_PROCESS_TERMINATION_REQUESTED: DWORD = 14087;\n-pub const ERROR_SXS_RELEASE_ACTIVATION_CONTEXT: DWORD = 14088;\n-pub const ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY: DWORD = 14089;\n-pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE: DWORD = 14090;\n-pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME: DWORD = 14091;\n-pub const ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE: DWORD = 14092;\n-pub const ERROR_SXS_IDENTITY_PARSE_ERROR: DWORD = 14093;\n-pub const ERROR_MALFORMED_SUBSTITUTION_STRING: DWORD = 14094;\n-pub const ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN: DWORD = 14095;\n-pub const ERROR_UNMAPPED_SUBSTITUTION_STRING: DWORD = 14096;\n-pub const ERROR_SXS_ASSEMBLY_NOT_LOCKED: DWORD = 14097;\n-pub const ERROR_SXS_COMPONENT_STORE_CORRUPT: DWORD = 14098;\n-pub const ERROR_ADVANCED_INSTALLER_FAILED: DWORD = 14099;\n-pub const ERROR_XML_ENCODING_MISMATCH: DWORD = 14100;\n-pub const ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT: DWORD = 14101;\n-pub const ERROR_SXS_IDENTITIES_DIFFERENT: DWORD = 14102;\n-pub const ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT: DWORD = 14103;\n-pub const ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY: DWORD = 14104;\n-pub const ERROR_SXS_MANIFEST_TOO_BIG: DWORD = 14105;\n-pub const ERROR_SXS_SETTING_NOT_REGISTERED: DWORD = 14106;\n-pub const ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE: DWORD = 14107;\n-pub const ERROR_SMI_PRIMITIVE_INSTALLER_FAILED: DWORD = 14108;\n-pub const ERROR_GENERIC_COMMAND_FAILED: DWORD = 14109;\n-pub const ERROR_SXS_FILE_HASH_MISSING: DWORD = 14110;\n-pub const ERROR_IPSEC_QM_POLICY_EXISTS: DWORD = 13000;\n-pub const ERROR_IPSEC_QM_POLICY_NOT_FOUND: DWORD = 13001;\n-pub const ERROR_IPSEC_QM_POLICY_IN_USE: DWORD = 13002;\n-pub const ERROR_IPSEC_MM_POLICY_EXISTS: DWORD = 13003;\n-pub const ERROR_IPSEC_MM_POLICY_NOT_FOUND: DWORD = 13004;\n-pub const ERROR_IPSEC_MM_POLICY_IN_USE: DWORD = 13005;\n-pub const ERROR_IPSEC_MM_FILTER_EXISTS: DWORD = 13006;\n-pub const ERROR_IPSEC_MM_FILTER_NOT_FOUND: DWORD = 13007;\n-pub const ERROR_IPSEC_TRANSPORT_FILTER_EXISTS: DWORD = 13008;\n-pub const ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND: DWORD = 13009;\n-pub const ERROR_IPSEC_MM_AUTH_EXISTS: DWORD = 13010;\n-pub const ERROR_IPSEC_MM_AUTH_NOT_FOUND: DWORD = 13011;\n-pub const ERROR_IPSEC_MM_AUTH_IN_USE: DWORD = 13012;\n-pub const ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND: DWORD = 13013;\n-pub const ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND: DWORD = 13014;\n-pub const ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND: DWORD = 13015;\n-pub const ERROR_IPSEC_TUNNEL_FILTER_EXISTS: DWORD = 13016;\n-pub const ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND: DWORD = 13017;\n-pub const ERROR_IPSEC_MM_FILTER_PENDING_DELETION: DWORD = 13018;\n-pub const ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION: DWORD = 13019;\n-pub const ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION: DWORD = 13020;\n-pub const ERROR_IPSEC_MM_POLICY_PENDING_DELETION: DWORD = 13021;\n-pub const ERROR_IPSEC_MM_AUTH_PENDING_DELETION: DWORD = 13022;\n-pub const ERROR_IPSEC_QM_POLICY_PENDING_DELETION: DWORD = 13023;\n-pub const ERROR_IPSEC_IKE_NEG_STATUS_BEGIN: DWORD = 13800;\n-pub const ERROR_IPSEC_IKE_AUTH_FAIL: DWORD = 13801;\n-pub const ERROR_IPSEC_IKE_ATTRIB_FAIL: DWORD = 13802;\n-pub const ERROR_IPSEC_IKE_NEGOTIATION_PENDING: DWORD = 13803;\n-pub const ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR: DWORD = 13804;\n-pub const ERROR_IPSEC_IKE_TIMED_OUT: DWORD = 13805;\n-pub const ERROR_IPSEC_IKE_NO_CERT: DWORD = 13806;\n-pub const ERROR_IPSEC_IKE_SA_DELETED: DWORD = 13807;\n-pub const ERROR_IPSEC_IKE_SA_REAPED: DWORD = 13808;\n-pub const ERROR_IPSEC_IKE_MM_ACQUIRE_DROP: DWORD = 13809;\n-pub const ERROR_IPSEC_IKE_QM_ACQUIRE_DROP: DWORD = 13810;\n-pub const ERROR_IPSEC_IKE_QUEUE_DROP_MM: DWORD = 13811;\n-pub const ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM: DWORD = 13812;\n-pub const ERROR_IPSEC_IKE_DROP_NO_RESPONSE: DWORD = 13813;\n-pub const ERROR_IPSEC_IKE_MM_DELAY_DROP: DWORD = 13814;\n-pub const ERROR_IPSEC_IKE_QM_DELAY_DROP: DWORD = 13815;\n-pub const ERROR_IPSEC_IKE_ERROR: DWORD = 13816;\n-pub const ERROR_IPSEC_IKE_CRL_FAILED: DWORD = 13817;\n-pub const ERROR_IPSEC_IKE_INVALID_KEY_USAGE: DWORD = 13818;\n-pub const ERROR_IPSEC_IKE_INVALID_CERT_TYPE: DWORD = 13819;\n-pub const ERROR_IPSEC_IKE_NO_PRIVATE_KEY: DWORD = 13820;\n-pub const ERROR_IPSEC_IKE_DH_FAIL: DWORD = 13822;\n-pub const ERROR_IPSEC_IKE_INVALID_HEADER: DWORD = 13824;\n-pub const ERROR_IPSEC_IKE_NO_POLICY: DWORD = 13825;\n-pub const ERROR_IPSEC_IKE_INVALID_SIGNATURE: DWORD = 13826;\n-pub const ERROR_IPSEC_IKE_KERBEROS_ERROR: DWORD = 13827;\n-pub const ERROR_IPSEC_IKE_NO_PUBLIC_KEY: DWORD = 13828;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR: DWORD = 13829;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_SA: DWORD = 13830;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_PROP: DWORD = 13831;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_TRANS: DWORD = 13832;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_KE: DWORD = 13833;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_ID: DWORD = 13834;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT: DWORD = 13835;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ: DWORD = 13836;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_HASH: DWORD = 13837;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_SIG: DWORD = 13838;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_NONCE: DWORD = 13839;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY: DWORD = 13840;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_DELETE: DWORD = 13841;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR: DWORD = 13842;\n-pub const ERROR_IPSEC_IKE_INVALID_PAYLOAD: DWORD = 13843;\n-pub const ERROR_IPSEC_IKE_LOAD_SOFT_SA: DWORD = 13844;\n-pub const ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN: DWORD = 13845;\n-pub const ERROR_IPSEC_IKE_INVALID_COOKIE: DWORD = 13846;\n-pub const ERROR_IPSEC_IKE_NO_PEER_CERT: DWORD = 13847;\n-pub const ERROR_IPSEC_IKE_PEER_CRL_FAILED: DWORD = 13848;\n-pub const ERROR_IPSEC_IKE_POLICY_CHANGE: DWORD = 13849;\n-pub const ERROR_IPSEC_IKE_NO_MM_POLICY: DWORD = 13850;\n-pub const ERROR_IPSEC_IKE_NOTCBPRIV: DWORD = 13851;\n-pub const ERROR_IPSEC_IKE_SECLOADFAIL: DWORD = 13852;\n-pub const ERROR_IPSEC_IKE_FAILSSPINIT: DWORD = 13853;\n-pub const ERROR_IPSEC_IKE_FAILQUERYSSP: DWORD = 13854;\n-pub const ERROR_IPSEC_IKE_SRVACQFAIL: DWORD = 13855;\n-pub const ERROR_IPSEC_IKE_SRVQUERYCRED: DWORD = 13856;\n-pub const ERROR_IPSEC_IKE_GETSPIFAIL: DWORD = 13857;\n-pub const ERROR_IPSEC_IKE_INVALID_FILTER: DWORD = 13858;\n-pub const ERROR_IPSEC_IKE_OUT_OF_MEMORY: DWORD = 13859;\n-pub const ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED: DWORD = 13860;\n-pub const ERROR_IPSEC_IKE_INVALID_POLICY: DWORD = 13861;\n-pub const ERROR_IPSEC_IKE_UNKNOWN_DOI: DWORD = 13862;\n-pub const ERROR_IPSEC_IKE_INVALID_SITUATION: DWORD = 13863;\n-pub const ERROR_IPSEC_IKE_DH_FAILURE: DWORD = 13864;\n-pub const ERROR_IPSEC_IKE_INVALID_GROUP: DWORD = 13865;\n-pub const ERROR_IPSEC_IKE_ENCRYPT: DWORD = 13866;\n-pub const ERROR_IPSEC_IKE_DECRYPT: DWORD = 13867;\n-pub const ERROR_IPSEC_IKE_POLICY_MATCH: DWORD = 13868;\n-pub const ERROR_IPSEC_IKE_UNSUPPORTED_ID: DWORD = 13869;\n-pub const ERROR_IPSEC_IKE_INVALID_HASH: DWORD = 13870;\n-pub const ERROR_IPSEC_IKE_INVALID_HASH_ALG: DWORD = 13871;\n-pub const ERROR_IPSEC_IKE_INVALID_HASH_SIZE: DWORD = 13872;\n-pub const ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG: DWORD = 13873;\n-pub const ERROR_IPSEC_IKE_INVALID_AUTH_ALG: DWORD = 13874;\n-pub const ERROR_IPSEC_IKE_INVALID_SIG: DWORD = 13875;\n-pub const ERROR_IPSEC_IKE_LOAD_FAILED: DWORD = 13876;\n-pub const ERROR_IPSEC_IKE_RPC_DELETE: DWORD = 13877;\n-pub const ERROR_IPSEC_IKE_BENIGN_REINIT: DWORD = 13878;\n-pub const ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY: DWORD = 13879;\n-pub const ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN: DWORD = 13881;\n-pub const ERROR_IPSEC_IKE_MM_LIMIT: DWORD = 13882;\n-pub const ERROR_IPSEC_IKE_NEGOTIATION_DISABLED: DWORD = 13883;\n-/*pub const ERROR_IPSEC_IKE_NEG_STATUS_END: DWORD = 13884)*/\n-pub const ERROR_IPSEC_IKE_QM_LIMIT: DWORD = 13884;\n-pub const ERROR_IPSEC_IKE_MM_EXPIRED: DWORD = 13885;\n-pub const ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID: DWORD = 13886;\n-pub const ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH: DWORD = 13887;\n-pub const ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID: DWORD = 13888;\n-pub const ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD: DWORD = 13889;\n-pub const ERROR_IPSEC_IKE_DOS_COOKIE_SENT: DWORD = 13890;\n-pub const ERROR_IPSEC_IKE_SHUTTING_DOWN: DWORD = 13891;\n-pub const ERROR_IPSEC_IKE_CGA_AUTH_FAILED: DWORD = 13892;\n-pub const ERROR_IPSEC_IKE_PROCESS_ERR_NATOA: DWORD = 13893;\n-pub const ERROR_IPSEC_IKE_INVALID_MM_FOR_QM: DWORD = 13894;\n-pub const ERROR_IPSEC_IKE_QM_EXPIRED: DWORD = 13895;\n-pub const ERROR_IPSEC_IKE_TOO_MANY_FILTERS: DWORD = 13896;\n-pub const ERROR_IPSEC_IKE_NEG_STATUS_END: DWORD = 13897;\n-pub const ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL: DWORD = 13898;\n-pub const ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE: DWORD = 13899;\n-pub const ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING: DWORD = 13900;\n-pub const ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING: DWORD = 13901;\n-pub const ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS: DWORD = 13902;\n-pub const ERROR_IPSEC_IKE_RATELIMIT_DROP: DWORD = 13903;\n-pub const ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE: DWORD = 13904;\n-pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE: DWORD = 13905;\n-pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE: DWORD = 13906;\n-pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY: DWORD = 13907;\n-pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE: DWORD = 13908;\n-pub const ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END: DWORD = 13909;\n-pub const ERROR_IPSEC_BAD_SPI: DWORD = 13910;\n-pub const ERROR_IPSEC_SA_LIFETIME_EXPIRED: DWORD = 13911;\n-pub const ERROR_IPSEC_WRONG_SA: DWORD = 13912;\n-pub const ERROR_IPSEC_REPLAY_CHECK_FAILED: DWORD = 13913;\n-pub const ERROR_IPSEC_INVALID_PACKET: DWORD = 13914;\n-pub const ERROR_IPSEC_INTEGRITY_CHECK_FAILED: DWORD = 13915;\n-pub const ERROR_IPSEC_CLEAR_TEXT_DROP: DWORD = 13916;\n-pub const ERROR_IPSEC_AUTH_FIREWALL_DROP: DWORD = 13917;\n-pub const ERROR_IPSEC_THROTTLE_DROP: DWORD = 13918;\n-pub const ERROR_IPSEC_DOSP_BLOCK: DWORD = 13925;\n-pub const ERROR_IPSEC_DOSP_RECEIVED_MULTICAST: DWORD = 13926;\n-pub const ERROR_IPSEC_DOSP_INVALID_PACKET: DWORD = 13927;\n-pub const ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED: DWORD = 13928;\n-pub const ERROR_IPSEC_DOSP_MAX_ENTRIES: DWORD = 13929;\n-pub const ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED: DWORD = 13930;\n-pub const ERROR_IPSEC_DOSP_NOT_INSTALLED: DWORD = 13931;\n-pub const ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES: DWORD = 13932;\n-pub const ERROR_EVT_INVALID_CHANNEL_PATH: DWORD = 15000;\n-pub const ERROR_EVT_INVALID_QUERY: DWORD = 15001;\n-pub const ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND: DWORD = 15002;\n-pub const ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND: DWORD = 15003;\n-pub const ERROR_EVT_INVALID_PUBLISHER_NAME: DWORD = 15004;\n-pub const ERROR_EVT_INVALID_EVENT_DATA: DWORD = 15005;\n-pub const ERROR_EVT_CHANNEL_NOT_FOUND: DWORD = 15007;\n-pub const ERROR_EVT_MALFORMED_XML_TEXT: DWORD = 15008;\n-pub const ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL: DWORD = 15009;\n-pub const ERROR_EVT_CONFIGURATION_ERROR: DWORD = 15010;\n-pub const ERROR_EVT_QUERY_RESULT_STALE: DWORD = 15011;\n-pub const ERROR_EVT_QUERY_RESULT_INVALID_POSITION: DWORD = 15012;\n-pub const ERROR_EVT_NON_VALIDATING_MSXML: DWORD = 15013;\n-pub const ERROR_EVT_FILTER_ALREADYSCOPED: DWORD = 15014;\n-pub const ERROR_EVT_FILTER_NOTELTSET: DWORD = 15015;\n-pub const ERROR_EVT_FILTER_INVARG: DWORD = 15016;\n-pub const ERROR_EVT_FILTER_INVTEST: DWORD = 15017;\n-pub const ERROR_EVT_FILTER_INVTYPE: DWORD = 15018;\n-pub const ERROR_EVT_FILTER_PARSEERR: DWORD = 15019;\n-pub const ERROR_EVT_FILTER_UNSUPPORTEDOP: DWORD = 15020;\n-pub const ERROR_EVT_FILTER_UNEXPECTEDTOKEN: DWORD = 15021;\n-pub const ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL: DWORD = 15022;\n-pub const ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE: DWORD = 15023;\n-pub const ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE: DWORD = 15024;\n-pub const ERROR_EVT_CHANNEL_CANNOT_ACTIVATE: DWORD = 15025;\n-pub const ERROR_EVT_FILTER_TOO_COMPLEX: DWORD = 15026;\n-pub const ERROR_EVT_MESSAGE_NOT_FOUND: DWORD = 15027;\n-pub const ERROR_EVT_MESSAGE_ID_NOT_FOUND: DWORD = 15028;\n-pub const ERROR_EVT_UNRESOLVED_VALUE_INSERT: DWORD = 15029;\n-pub const ERROR_EVT_UNRESOLVED_PARAMETER_INSERT: DWORD = 15030;\n-pub const ERROR_EVT_MAX_INSERTS_REACHED: DWORD = 15031;\n-pub const ERROR_EVT_EVENT_DEFINITION_NOT_FOUND: DWORD = 15032;\n-pub const ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND: DWORD = 15033;\n-pub const ERROR_EVT_VERSION_TOO_OLD: DWORD = 15034;\n-pub const ERROR_EVT_VERSION_TOO_NEW: DWORD = 15035;\n-pub const ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY: DWORD = 15036;\n-pub const ERROR_EVT_PUBLISHER_DISABLED: DWORD = 15037;\n-pub const ERROR_EVT_FILTER_OUT_OF_RANGE: DWORD = 15038;\n-pub const ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE: DWORD = 15080;\n-pub const ERROR_EC_LOG_DISABLED: DWORD = 15081;\n-pub const ERROR_EC_CIRCULAR_FORWARDING: DWORD = 15082;\n-pub const ERROR_EC_CREDSTORE_FULL: DWORD = 15083;\n-pub const ERROR_EC_CRED_NOT_FOUND: DWORD = 15084;\n-pub const ERROR_EC_NO_ACTIVE_CHANNEL: DWORD = 15085;\n-pub const ERROR_MUI_FILE_NOT_FOUND: DWORD = 15100;\n-pub const ERROR_MUI_INVALID_FILE: DWORD = 15101;\n-pub const ERROR_MUI_INVALID_RC_CONFIG: DWORD = 15102;\n-pub const ERROR_MUI_INVALID_LOCALE_NAME: DWORD = 15103;\n-pub const ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME: DWORD = 15104;\n-pub const ERROR_MUI_FILE_NOT_LOADED: DWORD = 15105;\n-pub const ERROR_RESOURCE_ENUM_USER_STOP: DWORD = 15106;\n-pub const ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED: DWORD = 15107;\n-pub const ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME: DWORD = 15108;\n-pub const ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE: DWORD = 15110;\n-pub const ERROR_MRM_INVALID_PRICONFIG: DWORD = 15111;\n-pub const ERROR_MRM_INVALID_FILE_TYPE: DWORD = 15112;\n-pub const ERROR_MRM_UNKNOWN_QUALIFIER: DWORD = 15113;\n-pub const ERROR_MRM_INVALID_QUALIFIER_VALUE: DWORD = 15114;\n-pub const ERROR_MRM_NO_CANDIDATE: DWORD = 15115;\n-pub const ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE: DWORD = 15116;\n-pub const ERROR_MRM_RESOURCE_TYPE_MISMATCH: DWORD = 15117;\n-pub const ERROR_MRM_DUPLICATE_MAP_NAME: DWORD = 15118;\n-pub const ERROR_MRM_DUPLICATE_ENTRY: DWORD = 15119;\n-pub const ERROR_MRM_INVALID_RESOURCE_IDENTIFIER: DWORD = 15120;\n-pub const ERROR_MRM_FILEPATH_TOO_LONG: DWORD = 15121;\n-pub const ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE: DWORD = 15122;\n-pub const ERROR_MRM_INVALID_PRI_FILE: DWORD = 15126;\n-pub const ERROR_MRM_NAMED_RESOURCE_NOT_FOUND: DWORD = 15127;\n-pub const ERROR_MRM_MAP_NOT_FOUND: DWORD = 15135;\n-pub const ERROR_MRM_UNSUPPORTED_PROFILE_TYPE: DWORD = 15136;\n-pub const ERROR_MRM_INVALID_QUALIFIER_OPERATOR: DWORD = 15137;\n-pub const ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE: DWORD = 15138;\n-pub const ERROR_MRM_AUTOMERGE_ENABLED: DWORD = 15139;\n-pub const ERROR_MRM_TOO_MANY_RESOURCES: DWORD = 15140;\n-pub const ERROR_MCA_INVALID_CAPABILITIES_STRING: DWORD = 15200;\n-pub const ERROR_MCA_INVALID_VCP_VERSION: DWORD = 15201;\n-pub const ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION: DWORD = 15202;\n-pub const ERROR_MCA_MCCS_VERSION_MISMATCH: DWORD = 15203;\n-pub const ERROR_MCA_UNSUPPORTED_MCCS_VERSION: DWORD = 15204;\n-pub const ERROR_MCA_INTERNAL_ERROR: DWORD = 15205;\n-pub const ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED: DWORD = 15206;\n-pub const ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE: DWORD = 15207;\n-pub const ERROR_AMBIGUOUS_SYSTEM_DEVICE: DWORD = 15250;\n-pub const ERROR_SYSTEM_DEVICE_NOT_FOUND: DWORD = 15299;\n-pub const ERROR_HASH_NOT_SUPPORTED: DWORD = 15300;\n-pub const ERROR_HASH_NOT_PRESENT: DWORD = 15301;\n-pub const ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED: DWORD = 15321;\n-pub const ERROR_GPIO_CLIENT_INFORMATION_INVALID: DWORD = 15322;\n-pub const ERROR_GPIO_VERSION_NOT_SUPPORTED: DWORD = 15323;\n-pub const ERROR_GPIO_INVALID_REGISTRATION_PACKET: DWORD = 15324;\n-pub const ERROR_GPIO_OPERATION_DENIED: DWORD = 15325;\n-pub const ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE: DWORD = 15326;\n-pub const ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED: DWORD = 15327;\n-pub const ERROR_CANNOT_SWITCH_RUNLEVEL: DWORD = 15400;\n-pub const ERROR_INVALID_RUNLEVEL_SETTING: DWORD = 15401;\n-pub const ERROR_RUNLEVEL_SWITCH_TIMEOUT: DWORD = 15402;\n-pub const ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT: DWORD = 15403;\n-pub const ERROR_RUNLEVEL_SWITCH_IN_PROGRESS: DWORD = 15404;\n-pub const ERROR_SERVICES_FAILED_AUTOSTART: DWORD = 15405;\n-pub const ERROR_COM_TASK_STOP_PENDING: DWORD = 15501;\n-pub const ERROR_INSTALL_OPEN_PACKAGE_FAILED: DWORD = 15600;\n-pub const ERROR_INSTALL_PACKAGE_NOT_FOUND: DWORD = 15601;\n-pub const ERROR_INSTALL_INVALID_PACKAGE: DWORD = 15602;\n-pub const ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED: DWORD = 15603;\n-pub const ERROR_INSTALL_OUT_OF_DISK_SPACE: DWORD = 15604;\n-pub const ERROR_INSTALL_NETWORK_FAILURE: DWORD = 15605;\n-pub const ERROR_INSTALL_REGISTRATION_FAILURE: DWORD = 15606;\n-pub const ERROR_INSTALL_DEREGISTRATION_FAILURE: DWORD = 15607;\n-pub const ERROR_INSTALL_CANCEL: DWORD = 15608;\n-pub const ERROR_INSTALL_FAILED: DWORD = 15609;\n-pub const ERROR_REMOVE_FAILED: DWORD = 15610;\n-pub const ERROR_PACKAGE_ALREADY_EXISTS: DWORD = 15611;\n-pub const ERROR_NEEDS_REMEDIATION: DWORD = 15612;\n-pub const ERROR_INSTALL_PREREQUISITE_FAILED: DWORD = 15613;\n-pub const ERROR_PACKAGE_REPOSITORY_CORRUPTED: DWORD = 15614;\n-pub const ERROR_INSTALL_POLICY_FAILURE: DWORD = 15615;\n-pub const ERROR_PACKAGE_UPDATING: DWORD = 15616;\n-pub const ERROR_DEPLOYMENT_BLOCKED_BY_POLICY: DWORD = 15617;\n-pub const ERROR_PACKAGES_IN_USE: DWORD = 15618;\n-pub const ERROR_RECOVERY_FILE_CORRUPT: DWORD = 15619;\n-pub const ERROR_INVALID_STAGED_SIGNATURE: DWORD = 15620;\n-pub const ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED: DWORD = 15621;\n-pub const ERROR_INSTALL_PACKAGE_DOWNGRADE: DWORD = 15622;\n-pub const ERROR_SYSTEM_NEEDS_REMEDIATION: DWORD = 15623;\n-pub const ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN: DWORD = 15624;\n-pub const ERROR_RESILIENCY_FILE_CORRUPT: DWORD = 15625;\n-pub const ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING: DWORD = 15626;\n-pub const ERROR_STATE_LOAD_STORE_FAILED: DWORD = 15800;\n-pub const ERROR_STATE_GET_VERSION_FAILED: DWORD = 15801;\n-pub const ERROR_STATE_SET_VERSION_FAILED: DWORD = 15802;\n-pub const ERROR_STATE_STRUCTURED_RESET_FAILED: DWORD = 15803;\n-pub const ERROR_STATE_OPEN_CONTAINER_FAILED: DWORD = 15804;\n-pub const ERROR_STATE_CREATE_CONTAINER_FAILED: DWORD = 15805;\n-pub const ERROR_STATE_DELETE_CONTAINER_FAILED: DWORD = 15806;\n-pub const ERROR_STATE_READ_SETTING_FAILED: DWORD = 15807;\n-pub const ERROR_STATE_WRITE_SETTING_FAILED: DWORD = 15808;\n-pub const ERROR_STATE_DELETE_SETTING_FAILED: DWORD = 15809;\n-pub const ERROR_STATE_QUERY_SETTING_FAILED: DWORD = 15810;\n-pub const ERROR_STATE_READ_COMPOSITE_SETTING_FAILED: DWORD = 15811;\n-pub const ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED: DWORD = 15812;\n-pub const ERROR_STATE_ENUMERATE_CONTAINER_FAILED: DWORD = 15813;\n-pub const ERROR_STATE_ENUMERATE_SETTINGS_FAILED: DWORD = 15814;\n-pub const ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED: DWORD = 15815;\n-pub const ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED: DWORD = 15816;\n-pub const ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED: DWORD = 15817;\n-pub const ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED: DWORD = 15818;\n-pub const ERROR_API_UNAVAILABLE: DWORD = 15841;\n-pub const ERROR_AUDITING_DISABLED: DWORD = 0xC0090001;\n-pub const ERROR_ALL_SIDS_FILTERED: DWORD = 0xC0090002;\n-\n-pub const WSABASEERR: c_int = 10000;\n-pub const WSAEINTR: c_int = WSABASEERR + 4;\n-pub const WSAEBADF: c_int = WSABASEERR + 9;\n-pub const WSAEACCES: c_int = WSABASEERR + 13;\n-pub const WSAEFAULT: c_int = WSABASEERR + 14;\n-pub const WSAEINVAL: c_int = WSABASEERR + 22;\n-pub const WSAEMFILE: c_int = WSABASEERR + 24;\n-pub const WSAEWOULDBLOCK: c_int = WSABASEERR + 35;\n-pub const WSAEINPROGRESS: c_int = WSABASEERR + 36;\n-pub const WSAEALREADY: c_int = WSABASEERR + 37;\n-pub const WSAENOTSOCK: c_int = WSABASEERR + 38;\n-pub const WSAEDESTADDRREQ: c_int = WSABASEERR + 39;\n-pub const WSAEMSGSIZE: c_int = WSABASEERR + 40;\n-pub const WSAEPROTOTYPE: c_int = WSABASEERR + 41;\n-pub const WSAENOPROTOOPT: c_int = WSABASEERR + 42;\n-pub const WSAEPROTONOSUPPORT: c_int = WSABASEERR + 43;\n-pub const WSAESOCKTNOSUPPORT: c_int = WSABASEERR + 44;\n-pub const WSAEOPNOTSUPP: c_int = WSABASEERR + 45;\n-pub const WSAEPFNOSUPPORT: c_int = WSABASEERR + 46;\n-pub const WSAEAFNOSUPPORT: c_int = WSABASEERR + 47;\n-pub const WSAEADDRINUSE: c_int = WSABASEERR + 48;\n-pub const WSAEADDRNOTAVAIL: c_int = WSABASEERR + 49;\n-pub const WSAENETDOWN: c_int = WSABASEERR + 50;\n-pub const WSAENETUNREACH: c_int = WSABASEERR + 51;\n-pub const WSAENETRESET: c_int = WSABASEERR + 52;\n-pub const WSAECONNABORTED: c_int = WSABASEERR + 53;\n-pub const WSAECONNRESET: c_int = WSABASEERR + 54;\n-pub const WSAENOBUFS: c_int = WSABASEERR + 55;\n-pub const WSAEISCONN: c_int = WSABASEERR + 56;\n-pub const WSAENOTCONN: c_int = WSABASEERR + 57;\n-pub const WSAESHUTDOWN: c_int = WSABASEERR + 58;\n-pub const WSAETOOMANYREFS: c_int = WSABASEERR + 59;\n-pub const WSAETIMEDOUT: c_int = WSABASEERR + 60;\n-pub const WSAECONNREFUSED: c_int = WSABASEERR + 61;\n-pub const WSAELOOP: c_int = WSABASEERR + 62;\n-pub const WSAENAMETOOLONG: c_int = WSABASEERR + 63;\n-pub const WSAEHOSTDOWN: c_int = WSABASEERR + 64;\n-pub const WSAEHOSTUNREACH: c_int = WSABASEERR + 65;\n-pub const WSAENOTEMPTY: c_int = WSABASEERR + 66;\n-pub const WSAEPROCLIM: c_int = WSABASEERR + 67;\n-pub const WSAEUSERS: c_int = WSABASEERR + 68;\n-pub const WSAEDQUOT: c_int = WSABASEERR + 69;\n-pub const WSAESTALE: c_int = WSABASEERR + 70;\n-pub const WSAEREMOTE: c_int = WSABASEERR + 71;\n-pub const WSASYSNOTREADY: c_int = WSABASEERR + 91;\n-pub const WSAVERNOTSUPPORTED: c_int = WSABASEERR + 92;\n-pub const WSANOTINITIALISED: c_int = WSABASEERR + 93;\n-pub const WSAEDISCON: c_int = WSABASEERR + 101;\n-pub const WSAENOMORE: c_int = WSABASEERR + 102;\n-pub const WSAECANCELLED: c_int = WSABASEERR + 103;\n-pub const WSAEINVALIDPROCTABLE: c_int = WSABASEERR + 104;\n-pub const WSAEINVALIDPROVIDER: c_int = WSABASEERR + 105;\n-pub const WSAEPROVIDERFAILEDINIT: c_int = WSABASEERR + 106;\n-pub const WSASYSCALLFAILURE: c_int = WSABASEERR + 107;\n-pub const WSASERVICE_NOT_FOUND: c_int = WSABASEERR + 108;\n-pub const WSATYPE_NOT_FOUND: c_int = WSABASEERR + 109;\n-pub const WSA_E_NO_MORE: c_int = WSABASEERR + 110;\n-pub const WSA_E_CANCELLED: c_int = WSABASEERR + 111;\n-pub const WSAEREFUSED: c_int = WSABASEERR + 112;\n-pub const WSAHOST_NOT_FOUND: c_int = WSABASEERR + 1001;\n-pub const WSATRY_AGAIN: c_int = WSABASEERR + 1002;\n-pub const WSANO_RECOVERY: c_int = WSABASEERR + 1003;\n-pub const WSANO_DATA: c_int = WSABASEERR + 1004;\n-pub const WSA_QOS_RECEIVERS: c_int = WSABASEERR + 1005;\n-pub const WSA_QOS_SENDERS: c_int = WSABASEERR + 1006;\n-pub const WSA_QOS_NO_SENDERS: c_int = WSABASEERR + 1007;\n-pub const WSA_QOS_NO_RECEIVERS: c_int = WSABASEERR + 1008;\n-pub const WSA_QOS_REQUEST_CONFIRMED: c_int = WSABASEERR + 1009;\n-pub const WSA_QOS_ADMISSION_FAILURE: c_int = WSABASEERR + 1010;\n-pub const WSA_QOS_POLICY_FAILURE: c_int = WSABASEERR + 1011;\n-pub const WSA_QOS_BAD_STYLE: c_int = WSABASEERR + 1012;\n-pub const WSA_QOS_BAD_OBJECT: c_int = WSABASEERR + 1013;\n-pub const WSA_QOS_TRAFFIC_CTRL_ERROR: c_int = WSABASEERR + 1014;\n-pub const WSA_QOS_GENERIC_ERROR: c_int = WSABASEERR + 1015;\n-pub const WSA_QOS_ESERVICETYPE: c_int = WSABASEERR + 1016;\n-pub const WSA_QOS_EFLOWSPEC: c_int = WSABASEERR + 1017;\n-pub const WSA_QOS_EPROVSPECBUF: c_int = WSABASEERR + 1018;\n-pub const WSA_QOS_EFILTERSTYLE: c_int = WSABASEERR + 1019;\n-pub const WSA_QOS_EFILTERTYPE: c_int = WSABASEERR + 1020;\n-pub const WSA_QOS_EFILTERCOUNT: c_int = WSABASEERR + 1021;\n-pub const WSA_QOS_EOBJLENGTH: c_int = WSABASEERR + 1022;\n-pub const WSA_QOS_EFLOWCOUNT: c_int = WSABASEERR + 1023;\n-pub const WSA_QOS_EUNKNOWNPSOBJ: c_int = WSABASEERR + 1024;\n-pub const WSA_QOS_EUNKOWNPSOBJ: c_int = WSA_QOS_EUNKNOWNPSOBJ;\n-pub const WSA_QOS_EPOLICYOBJ: c_int = WSABASEERR + 1025;\n-pub const WSA_QOS_EFLOWDESC: c_int = WSABASEERR + 1026;\n-pub const WSA_QOS_EPSFLOWSPEC: c_int = WSABASEERR + 1027;\n-pub const WSA_QOS_EPSFILTERSPEC: c_int = WSABASEERR + 1028;\n-pub const WSA_QOS_ESDMODEOBJ: c_int = WSABASEERR + 1029;\n-pub const WSA_QOS_ESHAPERATEOBJ: c_int = WSABASEERR + 1030;\n-pub const WSA_QOS_RESERVED_PETYPE: c_int = WSABASEERR + 1031;"}, {"sha": "3e454199f13b18a1fb70ff246e64c21923dc05c0", "filename": "library/std/src/sys/windows/c/windows_sys.lst", "status": "added", "additions": 2590, "deletions": 0, "changes": 2590, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc%2Fwindows_sys.lst", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc%2Fwindows_sys.lst", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc%2Fwindows_sys.lst?ref=7a41eacf170ed234e059608515115e94fbe721fe"}, {"sha": "36a30f6ba56529573a955add4f274f64f9238d18", "filename": "library/std/src/sys/windows/c/windows_sys.rs", "status": "added", "additions": 4276, "deletions": 0, "changes": 4276, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc%2Fwindows_sys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc%2Fwindows_sys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc%2Fwindows_sys.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe"}, {"sha": "4fe95d41116b5e2d8ca83050f073e5832bf4b820", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -114,17 +114,20 @@ impl Module {\n     /// (e.g. kernel32 and ntdll).\n     pub unsafe fn new(name: &CStr) -> Option<Self> {\n         // SAFETY: A CStr is always null terminated.\n-        let module = c::GetModuleHandleA(name.as_ptr());\n+        let module = c::GetModuleHandleA(name.as_ptr().cast::<u8>());\n         NonNull::new(module).map(Self)\n     }\n \n     // Try to get the address of a function.\n     pub fn proc_address(self, name: &CStr) -> Option<NonNull<c_void>> {\n-        // SAFETY:\n-        // `self.0` will always be a valid module.\n-        // A CStr is always null terminated.\n-        let proc = unsafe { c::GetProcAddress(self.0.as_ptr(), name.as_ptr()) };\n-        NonNull::new(proc)\n+        unsafe {\n+            // SAFETY:\n+            // `self.0` will always be a valid module.\n+            // A CStr is always null terminated.\n+            let proc = c::GetProcAddress(self.0.as_ptr(), name.as_ptr().cast::<u8>());\n+            // SAFETY: `GetProcAddress` returns None on null.\n+            proc.map(|p| NonNull::new_unchecked(p as *mut c_void))\n+        }\n     }\n }\n \n@@ -199,6 +202,7 @@ macro_rules! compat_fn_optional {\n     )+) => (\n         $(\n             pub mod $symbol {\n+                #[allow(unused_imports)]\n                 use super::*;\n                 use crate::ffi::c_void;\n                 use crate::mem;"}, {"sha": "ce427766d17330fa75ab3154d10348e25efb9d38", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -89,6 +89,12 @@ pub struct FileTimes {\n     accessed: Option<c::FILETIME>,\n     modified: Option<c::FILETIME>,\n }\n+impl core::fmt::Debug for c::FILETIME {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let time = ((self.dwHighDateTime as u64) << 32) | self.dwLowDateTime as u64;\n+        f.debug_tuple(\"FILETIME\").field(&time).finish()\n+    }\n+}\n \n #[derive(Debug)]\n pub struct DirBuilder;\n@@ -290,6 +296,7 @@ impl File {\n                 ptr::null_mut(),\n             )\n         };\n+        let handle = unsafe { HandleOrInvalid::from_raw_handle(handle) };\n         if let Ok(handle) = handle.try_into() {\n             Ok(File { handle: Handle::from_inner(handle) })\n         } else {\n@@ -501,7 +508,8 @@ impl File {\n     }\n \n     fn readlink(&self) -> io::Result<PathBuf> {\n-        let mut space = Align8([MaybeUninit::<u8>::uninit(); c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n+        let mut space =\n+            Align8([MaybeUninit::<u8>::uninit(); c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE as usize]);\n         let (_bytes, buf) = self.reparse_point(&mut space)?;\n         unsafe {\n             let (path_buffer, subst_off, subst_len, relative) = match (*buf).ReparseTag {\n@@ -589,7 +597,11 @@ impl File {\n             ));\n         }\n         cvt(unsafe {\n-            c::SetFileTime(self.as_handle(), None, times.accessed.as_ref(), times.modified.as_ref())\n+            let accessed =\n+                times.accessed.as_ref().map(|a| a as *const c::FILETIME).unwrap_or(ptr::null());\n+            let modified =\n+                times.modified.as_ref().map(|a| a as *const c::FILETIME).unwrap_or(ptr::null());\n+            c::SetFileTime(self.as_raw_handle(), ptr::null_mut(), accessed, modified)\n         })?;\n         Ok(())\n     }\n@@ -618,9 +630,9 @@ impl File {\n     /// then errors will be `ERROR_NOT_SUPPORTED` or `ERROR_INVALID_PARAMETER`.\n     fn posix_delete(&self) -> io::Result<()> {\n         let mut info = c::FILE_DISPOSITION_INFO_EX {\n-            Flags: c::FILE_DISPOSITION_DELETE\n-                | c::FILE_DISPOSITION_POSIX_SEMANTICS\n-                | c::FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE,\n+            Flags: c::FILE_DISPOSITION_FLAG_DELETE\n+                | c::FILE_DISPOSITION_FLAG_POSIX_SEMANTICS\n+                | c::FILE_DISPOSITION_FLAG_IGNORE_READONLY_ATTRIBUTE,\n         };\n         let size = mem::size_of_val(&info);\n         cvt(unsafe {\n@@ -791,23 +803,23 @@ fn open_link_no_reparse(parent: &File, name: &[u16], access: u32) -> io::Result<\n     // See https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile\n     unsafe {\n         let mut handle = ptr::null_mut();\n-        let mut io_status = c::IO_STATUS_BLOCK::default();\n-        let name_str = c::UNICODE_STRING::from_ref(name);\n+        let mut io_status = c::IO_STATUS_BLOCK::PENDING;\n+        let mut name_str = c::UNICODE_STRING::from_ref(name);\n         use crate::sync::atomic::{AtomicU32, Ordering};\n         // The `OBJ_DONT_REPARSE` attribute ensures that we haven't been\n         // tricked into following a symlink. However, it may not be available in\n         // earlier versions of Windows.\n         static ATTRIBUTES: AtomicU32 = AtomicU32::new(c::OBJ_DONT_REPARSE);\n-        let object = c::OBJECT_ATTRIBUTES {\n-            ObjectName: &name_str,\n+        let mut object = c::OBJECT_ATTRIBUTES {\n+            ObjectName: &mut name_str,\n             RootDirectory: parent.as_raw_handle(),\n             Attributes: ATTRIBUTES.load(Ordering::Relaxed),\n             ..c::OBJECT_ATTRIBUTES::default()\n         };\n         let status = c::NtCreateFile(\n             &mut handle,\n             access,\n-            &object,\n+            &mut object,\n             &mut io_status,\n             crate::ptr::null_mut(),\n             0,\n@@ -1368,7 +1380,7 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         _dwCallbackReason: c::DWORD,\n         _hSourceFile: c::HANDLE,\n         _hDestinationFile: c::HANDLE,\n-        lpData: c::LPVOID,\n+        lpData: c::LPCVOID,\n     ) -> c::DWORD {\n         if dwStreamNumber == 1 {\n             *(lpData as *mut i64) = StreamBytesTransferred;\n@@ -1415,9 +1427,10 @@ fn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n     let f = File::open(junction, &opts)?;\n     let h = f.as_inner().as_raw_handle();\n     unsafe {\n-        let mut data = Align8([MaybeUninit::<u8>::uninit(); c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n+        let mut data =\n+            Align8([MaybeUninit::<u8>::uninit(); c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE as usize]);\n         let data_ptr = data.0.as_mut_ptr();\n-        let data_end = data_ptr.add(c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE);\n+        let data_end = data_ptr.add(c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE as usize);\n         let db = data_ptr.cast::<c::REPARSE_MOUNTPOINT_DATA_BUFFER>();\n         // Zero the header to ensure it's fully initialized, including reserved parameters.\n         *db = mem::zeroed();"}, {"sha": "84c1fbde32d2fd7bfac9bf4b8aac9b43c79fd15c", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -144,7 +144,7 @@ impl Handle {\n         let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n         let mut amt = 0;\n         let res = cvt(c::ReadFile(\n-            self.as_handle(),\n+            self.as_raw_handle(),\n             buf.as_ptr() as c::LPVOID,\n             len,\n             &mut amt,\n@@ -235,7 +235,7 @@ impl Handle {\n         len: usize,\n         offset: Option<u64>,\n     ) -> io::Result<usize> {\n-        let mut io_status = c::IO_STATUS_BLOCK::default();\n+        let mut io_status = c::IO_STATUS_BLOCK::PENDING;\n \n         // The length is clamped at u32::MAX.\n         let len = cmp::min(len, c::DWORD::MAX as usize) as c::DWORD;\n@@ -283,7 +283,7 @@ impl Handle {\n     ///\n     /// If `offset` is `None` then the current file position is used.\n     fn synchronous_write(&self, buf: &[u8], offset: Option<u64>) -> io::Result<usize> {\n-        let mut io_status = c::IO_STATUS_BLOCK::default();\n+        let mut io_status = c::IO_STATUS_BLOCK::PENDING;\n \n         // The length is clamped at u32::MAX.\n         let len = cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;"}, {"sha": "fc9856caed62fc547c07b3997338aecc07e2a70d", "filename": "library/std/src/sys/windows/io.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fio.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -17,10 +17,7 @@ impl<'a> IoSlice<'a> {\n     pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n         assert!(buf.len() <= c::ULONG::MAX as usize);\n         IoSlice {\n-            vec: c::WSABUF {\n-                len: buf.len() as c::ULONG,\n-                buf: buf.as_ptr() as *mut u8 as *mut c::CHAR,\n-            },\n+            vec: c::WSABUF { len: buf.len() as c::ULONG, buf: buf.as_ptr() as *mut u8 },\n             _p: PhantomData,\n         }\n     }\n@@ -54,7 +51,7 @@ impl<'a> IoSliceMut<'a> {\n     pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n         assert!(buf.len() <= c::ULONG::MAX as usize);\n         IoSliceMut {\n-            vec: c::WSABUF { len: buf.len() as c::ULONG, buf: buf.as_mut_ptr() as *mut c::CHAR },\n+            vec: c::WSABUF { len: buf.len() as c::ULONG, buf: buf.as_mut_ptr() },\n             _p: PhantomData,\n         }\n     }"}, {"sha": "2404bbe2b893a047215aae89afec601dc11215b6", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -263,7 +263,7 @@ impl Socket {\n                 &mut nread,\n                 &mut flags,\n                 ptr::null_mut(),\n-                ptr::null_mut(),\n+                None,\n             )\n         };\n \n@@ -347,7 +347,7 @@ impl Socket {\n                 &mut nwritten,\n                 0,\n                 ptr::null_mut(),\n-                ptr::null_mut(),\n+                None,\n             )\n         };\n         cvt(result).map(|_| nwritten as usize)"}, {"sha": "d07147eccc1d347092bb628b4b5bceefa1bd25f3", "filename": "library/std/src/sys/windows/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -373,7 +373,7 @@ impl AnonPipe {\n \n         // Asynchronous read of the pipe.\n         // If successful, `callback` will be called once it completes.\n-        let result = io(self.inner.as_handle(), buf, len, &mut overlapped, callback);\n+        let result = io(self.inner.as_handle(), buf, len, &mut overlapped, Some(callback));\n         if result == c::FALSE {\n             // We can return here because the call failed.\n             // After this we must not return until the I/O completes."}, {"sha": "df3667c0fd7886818749ad6702112eda3e5ee192", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -308,7 +308,7 @@ impl Command {\n         let stderr = stderr.to_handle(c::STD_ERROR_HANDLE, &mut pipes.stderr)?;\n \n         let mut si = zeroed_startupinfo();\n-        si.cb = mem::size_of::<c::STARTUPINFO>() as c::DWORD;\n+        si.cb = mem::size_of::<c::STARTUPINFOW>() as c::DWORD;\n \n         // If at least one of stdin, stdout or stderr are set (i.e. are non null)\n         // then set the `hStd` fields in `STARTUPINFO`.\n@@ -332,7 +332,7 @@ impl Command {\n                 flags,\n                 envp,\n                 dirp,\n-                &mut si,\n+                &si,\n                 &mut pi,\n             ))\n         }?;\n@@ -720,8 +720,8 @@ impl From<u32> for ExitCode {\n     }\n }\n \n-fn zeroed_startupinfo() -> c::STARTUPINFO {\n-    c::STARTUPINFO {\n+fn zeroed_startupinfo() -> c::STARTUPINFOW {\n+    c::STARTUPINFOW {\n         cb: 0,\n         lpReserved: ptr::null_mut(),\n         lpDesktop: ptr::null_mut(),\n@@ -731,7 +731,7 @@ fn zeroed_startupinfo() -> c::STARTUPINFO {\n         dwXSize: 0,\n         dwYSize: 0,\n         dwXCountChars: 0,\n-        dwYCountCharts: 0,\n+        dwYCountChars: 0,\n         dwFillAttribute: 0,\n         dwFlags: 0,\n         wShowWindow: 0,"}, {"sha": "bca4e38d9f62c6c9df2ae4af4ef319ab8fddabcf", "filename": "library/std/src/sys/windows/rand.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,3 +1,4 @@\n+use crate::ffi::c_void;\n use crate::io;\n use crate::mem;\n use crate::ptr;\n@@ -25,8 +26,9 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n #[inline(never)]\n fn fallback_rng() -> (u64, u64) {\n     let mut v = (0, 0);\n-    let ret =\n-        unsafe { c::RtlGenRandom(&mut v as *mut _ as *mut u8, mem::size_of_val(&v) as c::ULONG) };\n+    let ret = unsafe {\n+        c::RtlGenRandom(&mut v as *mut _ as *mut c_void, mem::size_of_val(&v) as c::ULONG)\n+    };\n \n     if ret != 0 { v } else { panic!(\"fallback RNG broken: {}\", io::Error::last_os_error()) }\n }"}, {"sha": "0caf0a317a4aa1e8597259f90d2ca937936d3516", "filename": "library/std/src/sys/windows/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -18,7 +18,7 @@ impl Handler {\n     }\n }\n \n-extern \"system\" fn vectored_handler(ExceptionInfo: *mut c::EXCEPTION_POINTERS) -> c::LONG {\n+unsafe extern \"system\" fn vectored_handler(ExceptionInfo: *mut c::EXCEPTION_POINTERS) -> c::LONG {\n     unsafe {\n         let rec = &(*(*ExceptionInfo).ExceptionRecord);\n         let code = rec.ExceptionCode;\n@@ -34,7 +34,7 @@ extern \"system\" fn vectored_handler(ExceptionInfo: *mut c::EXCEPTION_POINTERS) -\n }\n \n pub unsafe fn init() {\n-    if c::AddVectoredExceptionHandler(0, vectored_handler).is_null() {\n+    if c::AddVectoredExceptionHandler(0, Some(vectored_handler)).is_null() {\n         panic!(\"failed to install exception handler\");\n     }\n     // Set the thread stack guarantee for the main thread."}, {"sha": "2e3e0859dc18e69e437a475454305267231d45d6", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -180,7 +180,7 @@ fn write_valid_utf8_to_console(handle: c::HANDLE, utf8: &str) -> io::Result<usiz\n         let result = c::MultiByteToWideChar(\n             c::CP_UTF8,                      // CodePage\n             c::MB_ERR_INVALID_CHARS,         // dwFlags\n-            utf8.as_ptr() as c::LPCCH,       // lpMultiByteStr\n+            utf8.as_ptr(),                   // lpMultiByteStr\n             utf8.len() as c::c_int,          // cbMultiByte\n             utf16.as_mut_ptr() as c::LPWSTR, // lpWideCharStr\n             utf16.len() as c::c_int,         // cchWideChar\n@@ -344,7 +344,7 @@ fn read_u16s(handle: c::HANDLE, buf: &mut [MaybeUninit<u16>]) -> io::Result<usiz\n     // See #38274 and https://stackoverflow.com/questions/43836040/win-api-readconsole.\n     const CTRL_Z: u16 = 0x1A;\n     const CTRL_Z_MASK: c::ULONG = 1 << CTRL_Z;\n-    let mut input_control = c::CONSOLE_READCONSOLE_CONTROL {\n+    let input_control = c::CONSOLE_READCONSOLE_CONTROL {\n         nLength: crate::mem::size_of::<c::CONSOLE_READCONSOLE_CONTROL>() as c::ULONG,\n         nInitialChars: 0,\n         dwCtrlWakeupMask: CTRL_Z_MASK,\n@@ -360,7 +360,7 @@ fn read_u16s(handle: c::HANDLE, buf: &mut [MaybeUninit<u16>]) -> io::Result<usiz\n                 buf.as_mut_ptr() as c::LPVOID,\n                 buf.len() as u32,\n                 &mut amount,\n-                &mut input_control as c::PCONSOLE_READCONSOLE_CONTROL,\n+                &input_control,\n             )\n         })?;\n \n@@ -385,14 +385,14 @@ fn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n \n     let result = unsafe {\n         c::WideCharToMultiByte(\n-            c::CP_UTF8,                    // CodePage\n-            c::WC_ERR_INVALID_CHARS,       // dwFlags\n-            utf16.as_ptr(),                // lpWideCharStr\n-            utf16.len() as c::c_int,       // cchWideChar\n-            utf8.as_mut_ptr() as c::LPSTR, // lpMultiByteStr\n-            utf8.len() as c::c_int,        // cbMultiByte\n-            ptr::null(),                   // lpDefaultChar\n-            ptr::null_mut(),               // lpUsedDefaultChar\n+            c::CP_UTF8,              // CodePage\n+            c::WC_ERR_INVALID_CHARS, // dwFlags\n+            utf16.as_ptr(),          // lpWideCharStr\n+            utf16.len() as c::c_int, // cchWideChar\n+            utf8.as_mut_ptr(),       // lpMultiByteStr\n+            utf8.len() as c::c_int,  // cbMultiByte\n+            ptr::null(),             // lpDefaultChar\n+            ptr::null_mut(),         // lpUsedDefaultChar\n         )\n     };\n     if result == 0 {"}, {"sha": "18cecb65681d228e45fe100ef7ca143fccc359ba", "filename": "library/std/src/sys/windows/thread.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -2,6 +2,7 @@ use crate::ffi::CStr;\n use crate::io;\n use crate::num::NonZeroUsize;\n use crate::os::windows::io::AsRawHandle;\n+use crate::os::windows::io::HandleOrNull;\n use crate::ptr;\n use crate::sys::c;\n use crate::sys::handle::Handle;\n@@ -32,12 +33,12 @@ impl Thread {\n         let ret = c::CreateThread(\n             ptr::null_mut(),\n             stack,\n-            thread_start,\n+            Some(thread_start),\n             p as *mut _,\n             c::STACK_SIZE_PARAM_IS_A_RESERVATION,\n             ptr::null_mut(),\n         );\n-\n+        let ret = HandleOrNull::from_raw_handle(ret);\n         return if let Ok(handle) = ret.try_into() {\n             Ok(Thread { handle: Handle::from_inner(handle) })\n         } else {"}, {"sha": "9ce29a33df6e68362ed62a78984ed2a372d7f7d9", "filename": "library/std/tests/run-time-detect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Ftests%2Frun-time-detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/library%2Fstd%2Ftests%2Frun-time-detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Ftests%2Frun-time-detect.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -16,7 +16,6 @@ fn arm_linux() {\n     // tidy-alphabetical-start\n     println!(\"aes: {}\", is_arm_feature_detected!(\"aes\"));\n     println!(\"crc: {}\", is_arm_feature_detected!(\"crc\"));\n-    println!(\"crypto: {}\", is_arm_feature_detected!(\"crypto\"));\n     println!(\"neon: {}\", is_arm_feature_detected!(\"neon\"));\n     println!(\"pmull: {}\", is_arm_feature_detected!(\"pmull\"));\n     println!(\"sha2: {}\", is_arm_feature_detected!(\"sha2\"));"}, {"sha": "7e2cdc675b92165c5f8c4c794620252be4605e74", "filename": "library/stdarch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstdarch?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1 +1 @@\n-Subproject commit b655243782c18d3419439daa523782e0818ecf26\n+Subproject commit 7e2cdc675b92165c5f8c4c794620252be4605e74"}, {"sha": "d6924cf2cfb23c3d8ed7716b32e242ac5e5028bd", "filename": "src/bootstrap/CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCHANGELOG.md?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -27,6 +27,7 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n   from the default rust toolchain. [#78513](https://github.com/rust-lang/rust/pull/78513)\n - Add options for enabling overflow checks, one for std (`overflow-checks-std`) and one for everything else (`overflow-checks`). Both default to false.\n - Add llvm option `enable-warnings` to have control on llvm compilation warnings. Default to false.\n+- Add `rpath` option in `target` section to support set rpath option for each target independently. [#111242](https://github.com/rust-lang/rust/pull/111242)\n \n \n ## [Version 2] - 2020-09-25"}, {"sha": "e87125a49a6a048a8d4270264472ec1b13f22ceb", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -19,7 +19,7 @@ include!(\"../dylib_util.rs\");\n \n use std::env;\n use std::path::PathBuf;\n-use std::process::{Child, Command};\n+use std::process::{exit, Child, Command};\n use std::str::FromStr;\n use std::time::Instant;\n \n@@ -47,7 +47,12 @@ fn main() {\n     } else {\n         (\"RUSTC_REAL\", \"RUSTC_LIBDIR\")\n     };\n-    let stage = env::var(\"RUSTC_STAGE\").expect(\"RUSTC_STAGE was not set\");\n+    let stage = env::var(\"RUSTC_STAGE\").unwrap_or_else(|_| {\n+        // Don't panic here; it's reasonable to try and run these shims directly. Give a helpful error instead.\n+        eprintln!(\"rustc shim: fatal: RUSTC_STAGE was not set\");\n+        eprintln!(\"rustc shim: note: use `x.py build -vvv` to see all environment variables set by bootstrap\");\n+        exit(101);\n+    });\n     let sysroot = env::var_os(\"RUSTC_SYSROOT\").expect(\"RUSTC_SYSROOT was not set\");\n     let on_fail = env::var_os(\"RUSTC_ON_FAIL\").map(Command::new);\n "}, {"sha": "d2b85f7a6297b90caeb1e0c498600b3152e9dfac", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -5,13 +5,18 @@\n use std::env;\n use std::ffi::OsString;\n use std::path::PathBuf;\n-use std::process::Command;\n+use std::process::{exit, Command};\n \n include!(\"../dylib_util.rs\");\n \n fn main() {\n     let args = env::args_os().skip(1).collect::<Vec<_>>();\n-    let stage = env::var(\"RUSTC_STAGE\").expect(\"RUSTC_STAGE was not set\");\n+    let stage = env::var(\"RUSTC_STAGE\").unwrap_or_else(|_| {\n+        // Don't panic here; it's reasonable to try and run these shims directly. Give a helpful error instead.\n+        eprintln!(\"rustc shim: fatal: RUSTC_STAGE was not set\");\n+        eprintln!(\"rustc shim: note: use `x.py build -vvv` to see all environment variables set by bootstrap\");\n+        exit(101);\n+    });\n     let rustdoc = env::var_os(\"RUSTDOC_REAL\").expect(\"RUSTDOC_REAL was not set\");\n     let libdir = env::var_os(\"RUSTDOC_LIBDIR\").expect(\"RUSTDOC_LIBDIR was not set\");\n     let sysroot = env::var_os(\"RUSTC_SYSROOT\").expect(\"RUSTC_SYSROOT was not set\");"}, {"sha": "237f65b039f824aa6827c6133de4b54d89451b34", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -838,6 +838,7 @@ impl<'a> Builder<'a> {\n                 run::Miri,\n                 run::CollectLicenseMetadata,\n                 run::GenerateCopyright,\n+                run::GenerateWindowsSys,\n             ),\n             Kind::Setup => describe!(setup::Profile, setup::Hook, setup::Link, setup::Vscode),\n             Kind::Clean => describe!(clean::CleanAll, clean::Rustc, clean::Std),\n@@ -1622,7 +1623,7 @@ impl<'a> Builder<'a> {\n         // argument manually via `-C link-args=-Wl,-rpath,...`. Plus isn't it\n         // fun to pass a flag to a tool to pass a flag to pass a flag to a tool\n         // to change a flag in a binary?\n-        if self.config.rust_rpath && util::use_host_linker(target) {\n+        if self.config.rpath_enabled(target) && util::use_host_linker(target) {\n             let rpath = if target.contains(\"apple\") {\n                 // Note that we need to take one extra step on macOS to also pass\n                 // `-Wl,-instal_name,@rpath/...` to get things to work right. To\n@@ -2158,6 +2159,10 @@ impl<'a> Builder<'a> {\n #[cfg(test)]\n mod tests;\n \n+/// Represents flag values in `String` form with whitespace delimiter to pass it to the compiler later.\n+///\n+/// `-Z crate-attr` flags will be applied recursively on the target code using the `rustc_parse::parser::Parser`.\n+/// See `rustc_builtin_macros::cmdline_attrs::inject` for more information.\n #[derive(Debug, Clone)]\n struct Rustflags(String, TargetSelection);\n "}, {"sha": "33addb90da3721f5b682bdc4e19d16cf6983f364", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -412,6 +412,8 @@ pub fn std_cargo(builder: &Builder<'_>, target: TargetSelection, stage: u32, car\n         format!(\"-Zcrate-attr=doc(html_root_url=\\\"{}/\\\")\", builder.doc_rust_lang_org_channel(),);\n     cargo.rustflag(&html_root);\n     cargo.rustdocflag(&html_root);\n+\n+    cargo.rustdocflag(\"-Zcrate-attr=warn(rust_2018_idioms)\");\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -810,6 +812,9 @@ pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetSelec\n         .arg(builder.rustc_features(builder.kind))\n         .arg(\"--manifest-path\")\n         .arg(builder.src.join(\"compiler/rustc/Cargo.toml\"));\n+\n+    cargo.rustdocflag(\"-Zcrate-attr=warn(rust_2018_idioms)\");\n+\n     rustc_cargo_env(builder, cargo, target, stage);\n }\n "}, {"sha": "bf3bc3247acafa780936e377f1a1f81d7045e88e", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -467,6 +467,7 @@ pub struct Target {\n     pub ndk: Option<PathBuf>,\n     pub sanitizers: Option<bool>,\n     pub profiler: Option<bool>,\n+    pub rpath: Option<bool>,\n     pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n     pub musl_libdir: Option<PathBuf>,\n@@ -812,6 +813,7 @@ define_config! {\n         android_ndk: Option<String> = \"android-ndk\",\n         sanitizers: Option<bool> = \"sanitizers\",\n         profiler: Option<bool> = \"profiler\",\n+        rpath: Option<bool> = \"rpath\",\n         crt_static: Option<bool> = \"crt-static\",\n         musl_root: Option<String> = \"musl-root\",\n         musl_libdir: Option<String> = \"musl-libdir\",\n@@ -1318,6 +1320,7 @@ impl Config {\n                 target.qemu_rootfs = cfg.qemu_rootfs.map(PathBuf::from);\n                 target.sanitizers = cfg.sanitizers;\n                 target.profiler = cfg.profiler;\n+                target.rpath = cfg.rpath;\n \n                 config.target_config.insert(TargetSelection::from_user(&triple), target);\n             }\n@@ -1649,6 +1652,10 @@ impl Config {\n         self.target_config.values().any(|t| t.profiler == Some(true)) || self.profiler\n     }\n \n+    pub fn rpath_enabled(&self, target: TargetSelection) -> bool {\n+        self.target_config.get(&target).map(|t| t.rpath).flatten().unwrap_or(self.rust_rpath)\n+    }\n+\n     pub fn llvm_enabled(&self) -> bool {\n         self.rust_codegen_backends.contains(&INTERNER.intern_str(\"llvm\"))\n     }"}, {"sha": "57f3119e32230f63c4059c0aa722e34ee43d3e17", "filename": "src/bootstrap/run.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frun.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -253,3 +253,25 @@ impl Step for GenerateCopyright {\n         dest\n     }\n }\n+\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct GenerateWindowsSys;\n+\n+impl Step for GenerateWindowsSys {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/generate-windows-sys\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(GenerateWindowsSys);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) {\n+        let mut cmd = builder.tool_cmd(Tool::GenerateWindowsSys);\n+        cmd.arg(&builder.src);\n+        builder.run(&mut cmd);\n+    }\n+}"}, {"sha": "f13d365e3754db93e175aa919934387b34d9e4b5", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -301,6 +301,7 @@ bootstrap_tool!(\n     CollectLicenseMetadata, \"src/tools/collect-license-metadata\", \"collect-license-metadata\";\n     GenerateCopyright, \"src/tools/generate-copyright\", \"generate-copyright\";\n     SuggestTests, \"src/tools/suggest-tests\", \"suggest-tests\";\n+    GenerateWindowsSys, \"src/tools/generate-windows-sys\", \"generate-windows-sys\";\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]"}, {"sha": "f63e578b92ff43e8cc38fcaa257b660f45c8a8c2", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1 +1 @@\n-Subproject commit 6038be9d37d7251c966b486154af621d1794d7af\n+Subproject commit f63e578b92ff43e8cc38fcaa257b660f45c8a8c2"}, {"sha": "d9eb4c3f75435b008881062ffa77bf0d1527b37d", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1 +1 @@\n-Subproject commit 897fcf566f16bf87bf37199bdddec1801fd00532\n+Subproject commit d9eb4c3f75435b008881062ffa77bf0d1527b37d"}, {"sha": "28dc0f3576b55f5e57c5d6e65cd68ba3161e9fd5", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1 +1 @@\n-Subproject commit 1f8dc727e94ae4ef92adf70df979521a1ea1143e\n+Subproject commit 28dc0f3576b55f5e57c5d6e65cd68ba3161e9fd5"}, {"sha": "8ee9528b72b927cff8fd32346db8bbd1198816f0", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1 +1 @@\n-Subproject commit 31961fe22521a779070a44a8f30a2b00a20b6212\n+Subproject commit 8ee9528b72b927cff8fd32346db8bbd1198816f0"}, {"sha": "28dbeaf5c44bc7f5111ad412e99f2d7c5cec6c90", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1 +1 @@\n-Subproject commit 2a5eb92197e9cf8fe91164dcbf4f9b88c0d7e73d\n+Subproject commit 28dbeaf5c44bc7f5111ad412e99f2d7c5cec6c90"}, {"sha": "3be4382b0a3aa482e3756f96eabd0fdfc8ebc658", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -248,8 +248,14 @@ The valid types of print values are:\n   exact format of this debugging output is not a stable guarantee, other than\n   that it will include the linker executable and the text of each command-line\n   argument passed to the linker.\n+- `deployment-target` - The currently selected [deployment target] (or minimum OS version)\n+  for the selected Apple platform target. This value can be used or passed along to other\n+  components alongside a Rust build that need this information, such as C compilers.\n+  This returns rustc's minimum supported deployment target if no `*_DEPLOYMENT_TARGET` variable\n+  is present in the environment, or otherwise returns the variable's parsed value.\n \n [conditional compilation]: ../reference/conditional-compilation.html\n+[deployment target]: https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/cross_development/Configuring/configuring.html\n \n <a id=\"option-g-debug\"></a>\n ## `-g`: include debug information"}, {"sha": "d75bd92beda73d80a1e06dfa941fe1cec2fb2882", "filename": "src/doc/rustc/src/platform-support/armv7-sony-vita-newlibeabihf.md", "status": "renamed", "additions": 83, "deletions": 14, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmv7-sony-vita-newlibeabihf.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmv7-sony-vita-newlibeabihf.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmv7-sony-vita-newlibeabihf.md?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,26 +1,40 @@\n-# armv7-sony-vita-eabihf\n+# armv7-sony-vita-newlibeabihf\n \n **Tier: 3**\n \n This tier supports the ARM Cortex A9 processor running on a PlayStation Vita console. `armv7-vita-newlibeabihf` aims to have support for `std` crate using `newlib` as a bridge.\n \n+Rust support for this target is not affiliated with Sony, and is not derived\n+from nor used with any official Sony SDK.\n+\n ## Designated Developers\n \n * [@amg98](https://github.com/amg98)\n+* [@nikarh](https://github.com/nikarh)\n \n ## Requirements\n \n-This target is cross compiled, and requires installing [VITASDK](https://vitasdk.org/) toolchain on your system.\n+This target is cross-compiled, and requires installing [VITASDK](https://vitasdk.org/) toolchain on your system. Dynamic linking is not supported.\n+\n+`#![no_std]` crates can be built using `build-std` to build `core`, and optionally\n+`alloc`, and `panic_abort`.\n+\n+`std` is partially supported, but mostly works. Some APIs are unimplemented\n+and will simply return an error, such as `std::process`. An allocator is provided\n+by default.\n+\n+In order to support some APIs, binaries must be linked against `libc` written\n+for the target, using a linker for the target. These are provided by the\n+VITASDK toolchain.\n+\n+This target generates binaries in the ELF format.\n \n ## Building\n \n-You can build Rust with support for the target by adding it to the `target`\n-list in `config.toml`:\n+Rust does not ship pre-compiled artifacts for this target. You can use `build-std` flag to build binaries with `std`:\n \n-```toml\n-[build]\n-build-stage = 1\n-target = [\"armv7-sony-vita-newlibeabihf\"]\n+```sh\n+cargo build -Z build-std=std,panic_abort --target=armv7-sony-vita-newlibeabihf --release\n ```\n \n ## Cross-compilation\n@@ -33,26 +47,81 @@ Currently there is no support to run the rustc test suite for this target.\n \n ## Building and Running Rust Programs\n \n-To test your developed rust programs for PlayStation Vita, first you have to prepare a proper executable for the device using the resulting ELF file you get from compilation step. The needed steps can be automated using tools like `cargo-make`. Use the example below as a template for your project:\n+`std` support for this target relies on newlib. In order to work, newlib must be initialized correctly. The easiest way to achieve this with VITASDK newlib implementation is by compiling your program as a staticlib with and exposing your main function from rust to `_init` function in `crt0`.\n+\n+Add this to your `Cargo.toml`:\n+\n+```toml\n+[lib]\n+crate-type = [\"staticlib\"]\n+\n+[profile.release]\n+panic = 'abort'\n+lto = true\n+opt-level = 3\n+```\n+\n+Your entrypoint should look roughly like this, `src/lib.rs`:\n+```rust,ignore,no_run\n+#[used]\n+#[export_name = \"_newlib_heap_size_user\"]\n+pub static _NEWLIB_HEAP_SIZE_USER: u32 = 100 * 1024 * 1024; // Default heap size is only 32mb, increase it to something suitable for your application\n+\n+#[no_mangle]\n+pub extern \"C\" fn main() {\n+    println!(\"Hello, world!\");\n+}\n+```\n+\n+To test your developed rust programs on PlayStation Vita, first you must correctly link and package your rust staticlib. These steps can be preformed using tools available in VITASDK, and can be automated using tools like `cargo-make`.\n+\n+First, set up environment variables for `VITASDK`, and it's binaries:\n+\n+```sh\n+export VITASDK=/opt/vitasdk\n+export PATH=$PATH:$VITASDK/bin\n+```\n+\n+Use the example below as a template for your project:\n \n ```toml\n [env]\n TITLE = \"Rust Hello World\"\n TITLEID = \"RUST00001\"\n+# Add other libs required by your project here\n+LINKER_LIBS = \"-lpthread -lm -lmathneon\"\n+\n # At least a \"sce_sys\" folder should be place there for app metadata (title, icons, description...)\n # You can find sample assets for that on $VITASDK/share/gcc-arm-vita-eabi/samples/hello_world/sce_sys/\n STATIC_DIR = \"static\"   # Folder where static assets should be placed (sce_sys folder is at $STATIC_DIR/sce_sys)\n CARGO_TARGET_DIR = { script = [\"echo ${CARGO_TARGET_DIR:=target}\"] }\n-RUST_TARGET_PATH = { script = [\"echo $(pwd)\"]}\n RUST_TARGET = \"armv7-sony-vita-newlibeabihf\"\n CARGO_OUT_DIR = \"${CARGO_TARGET_DIR}/${RUST_TARGET}/release\"\n \n-[tasks.xbuild]\n-# This is the command where you get the ELF executable file (e.g. call to cargo build)\n+TARGET_LINKER = \"arm-vita-eabi-gcc\"\n+TARGET_LINKER_FLAGS = \"-Wl,-q\"\n+\n+[tasks.build]\n+description = \"Build the project using `cargo` as a static lib.\"\n+command = \"cargo\"\n+args = [\"build\", \"-Z\", \"build-std=std,panic_abort\", \"--target=armv7-sony-vita-newlibeabihf\", \"--release\"]\n+\n+[tasks.link]\n+description = \"Build an ELF executable using the `vitasdk` linker.\"\n+dependencies = [\"build\"]\n+script = [\n+    \"\"\"\n+    ${TARGET_LINKER} ${TARGET_LINKER_FLAGS} \\\n+        -L\"${CARGO_OUT_DIR}\" \\\n+        -l\"${CARGO_MAKE_CRATE_FS_NAME}\" \\\n+        ${LINKER_LIBS} \\\n+        -o\"${CARGO_OUT_DIR}/${CARGO_MAKE_CRATE_NAME}.elf\"\n+    \"\"\"\n+]\n \n [tasks.strip]\n description = \"Strip the produced ELF executable.\"\n-dependencies = [\"xbuild\"]\n+dependencies = [\"link\"]\n command = \"arm-vita-eabi-strip\"\n args = [\"-g\", '${CARGO_OUT_DIR}/${CARGO_MAKE_CRATE_FS_NAME}.elf']\n \n@@ -124,4 +193,4 @@ script = [\n ]\n ```\n \n-After running the above script, you should be able to get a *.vpk file in the same folder your *.elf executable resides. Now you can pick it and install it on your own PlayStation Vita using, for example, [VitaShell](https://github.com/TheOfficialFloW/VitaShell/releases) or you can use an emulator. For the time being, the most mature emulator for PlayStation Vita is [Vita3K](https://vita3k.org/), although I personally recommend testing your programs in real hardware, as the emulator is quite experimental.\n+After running the above script, you should be able to get a *.vpk file in the same folder your *.elf executable resides. Now you can pick it and install it on your own PlayStation Vita using, or you can use an [Vita3K](https://vita3k.org/) emulator.", "previous_filename": "src/doc/rustc/src/platform-support/armv7-sony-vita-eabihf.md"}, {"sha": "baf2b0a8585297e1654dbf08112eb83fad7c0868", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -556,7 +556,10 @@ where\n                 WherePredicate::EqPredicate { lhs, rhs, bound_params } => {\n                     match *lhs {\n                         Type::QPath(box QPathData {\n-                            ref assoc, ref self_type, ref trait_, ..\n+                            ref assoc,\n+                            ref self_type,\n+                            trait_: Some(ref trait_),\n+                            ..\n                         }) => {\n                             let ty = &*self_type;\n                             let mut new_trait = trait_.clone();"}, {"sha": "c852f9cca2bfde764fd4086449cdf143d5fe89a5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -706,7 +706,12 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n \n     g.where_predicates.retain(|pred| match pred {\n         clean::WherePredicate::BoundPredicate {\n-            ty: clean::QPath(box clean::QPathData { self_type: clean::Generic(ref s), trait_, .. }),\n+            ty:\n+                clean::QPath(box clean::QPathData {\n+                    self_type: clean::Generic(ref s),\n+                    trait_: Some(trait_),\n+                    ..\n+                }),\n             bounds,\n             ..\n         } => !(bounds.is_empty() || *s == kw::SelfUpper && trait_.def_id() == trait_did),"}, {"sha": "657f3c9ec4577fc598a237069a727de4cec02873", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -441,7 +441,7 @@ fn clean_projection<'tcx>(\n         assoc: projection_to_path_segment(ty, cx),\n         should_show_cast,\n         self_type,\n-        trait_,\n+        trait_: Some(trait_),\n     }))\n }\n \n@@ -1330,7 +1330,13 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                 let mut bounds: Vec<GenericBound> = Vec::new();\n                 generics.where_predicates.retain_mut(|pred| match *pred {\n                     WherePredicate::BoundPredicate {\n-                        ty: QPath(box QPathData { ref assoc, ref self_type, ref trait_, .. }),\n+                        ty:\n+                            QPath(box QPathData {\n+                                ref assoc,\n+                                ref self_type,\n+                                trait_: Some(ref trait_),\n+                                ..\n+                            }),\n                         bounds: ref mut pred_bounds,\n                         ..\n                     } => {\n@@ -1492,25 +1498,30 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n                 assoc: clean_path_segment(p.segments.last().expect(\"segments were empty\"), cx),\n                 should_show_cast,\n                 self_type,\n-                trait_,\n+                trait_: Some(trait_),\n             }))\n         }\n         hir::QPath::TypeRelative(qself, segment) => {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            let res = match ty.kind() {\n+            let self_type = clean_ty(qself, cx);\n+\n+            let (trait_, should_show_cast) = match ty.kind() {\n                 ty::Alias(ty::Projection, proj) => {\n-                    Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id)\n+                    let res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n+                    let trait_ = clean_path(&hir::Path { span, res, segments: &[] }, cx);\n+                    register_res(cx, trait_.res);\n+                    let self_def_id = res.opt_def_id();\n+                    let should_show_cast =\n+                        compute_should_show_cast(self_def_id, &trait_, &self_type);\n+\n+                    (Some(trait_), should_show_cast)\n                 }\n+                ty::Alias(ty::Inherent, _) => (None, false),\n                 // Rustdoc handles `ty::Error`s by turning them into `Type::Infer`s.\n                 ty::Error(_) => return Type::Infer,\n-                // Otherwise, this is an inherent associated type.\n-                _ => return clean_middle_ty(ty::Binder::dummy(ty), cx, None),\n+                _ => bug!(\"clean: expected associated type, found `{ty:?}`\"),\n             };\n-            let trait_ = clean_path(&hir::Path { span, res, segments: &[] }, cx);\n-            register_res(cx, trait_.res);\n-            let self_def_id = res.opt_def_id();\n-            let self_type = clean_ty(qself, cx);\n-            let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n+\n             Type::QPath(Box::new(QPathData {\n                 assoc: clean_path_segment(segment, cx),\n                 should_show_cast,\n@@ -1836,6 +1847,29 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             clean_projection(bound_ty.rebind(*data), cx, parent_def_id)\n         }\n \n+        ty::Alias(ty::Inherent, alias_ty) => {\n+            let alias_ty = bound_ty.rebind(alias_ty);\n+            let self_type = clean_middle_ty(alias_ty.map_bound(|ty| ty.self_ty()), cx, None);\n+\n+            Type::QPath(Box::new(QPathData {\n+                assoc: PathSegment {\n+                    name: cx.tcx.associated_item(alias_ty.skip_binder().def_id).name,\n+                    args: GenericArgs::AngleBracketed {\n+                        args: substs_to_args(\n+                            cx,\n+                            alias_ty.map_bound(|ty| ty.substs.as_slice()),\n+                            true,\n+                        )\n+                        .into(),\n+                        bindings: Default::default(),\n+                    },\n+                },\n+                should_show_cast: false,\n+                self_type,\n+                trait_: None,\n+            }))\n+        }\n+\n         ty::Param(ref p) => {\n             if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {\n                 ImplTrait(bounds)"}, {"sha": "38664c3e359a6b5fc44260599db35812cadd8599", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1660,7 +1660,7 @@ impl Type {\n \n     pub(crate) fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n         if let QPath(box QPathData { self_type, trait_, assoc, .. }) = self {\n-            Some((self_type, trait_.def_id(), assoc.clone()))\n+            Some((self_type, trait_.as_ref()?.def_id(), assoc.clone()))\n         } else {\n             None\n         }\n@@ -1704,7 +1704,7 @@ pub(crate) struct QPathData {\n     pub self_type: Type,\n     /// FIXME: compute this field on demand.\n     pub should_show_cast: bool,\n-    pub trait_: Path,\n+    pub trait_: Option<Path>,\n }\n \n /// A primitive (aka, builtin) type."}, {"sha": "d963d6092c48f5b201fbc985ded3e589f7698916", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1116,14 +1116,17 @@ fn fmt_type<'cx>(\n             ref trait_,\n             should_show_cast,\n         }) => {\n+            // FIXME(inherent_associated_types): Once we support non-ADT self-types (#106719),\n+            // we need to surround them with angle brackets in some cases (e.g. `<dyn \u2026>::P`).\n+\n             if f.alternate() {\n-                if should_show_cast {\n+                if let Some(trait_) = trait_ && should_show_cast {\n                     write!(f, \"<{:#} as {:#}>::\", self_type.print(cx), trait_.print(cx))?\n                 } else {\n                     write!(f, \"{:#}::\", self_type.print(cx))?\n                 }\n             } else {\n-                if should_show_cast {\n+                if let Some(trait_) = trait_ && should_show_cast {\n                     write!(f, \"&lt;{} as {}&gt;::\", self_type.print(cx), trait_.print(cx))?\n                 } else {\n                     write!(f, \"{}::\", self_type.print(cx))?\n@@ -1139,15 +1142,36 @@ fn fmt_type<'cx>(\n             //        the ugliness comes from inlining across crates where\n             //        everything comes in as a fully resolved QPath (hard to\n             //        look at).\n-            if !f.alternate() && let Ok((url, _, path)) = href(trait_.def_id(), cx) {\n-                write!(\n-                    f,\n-                    \"<a class=\\\"associatedtype\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n-                                title=\\\"type {path}::{name}\\\">{name}</a>\",\n-                    shortty = ItemType::AssocType,\n-                    name = assoc.name,\n-                    path = join_with_double_colon(&path),\n-                )\n+            if !f.alternate() {\n+                // FIXME(inherent_associated_types): We always link to the very first associated\n+                // type (in respect to source order) that bears the given name (`assoc.name`) and that is\n+                // affiliated with the computed `DefId`. This is obviously incorrect when we have\n+                // multiple impl blocks. Ideally, we would thread the `DefId` of the assoc ty itself\n+                // through here and map it to the corresponding HTML ID that was generated by\n+                // `render::Context::derive_id` when the impl blocks were rendered.\n+                // There is no such mapping unfortunately.\n+                // As a hack, we could badly imitate `derive_id` here by keeping *count* when looking\n+                // for the assoc ty `DefId` in `tcx.associated_items(self_ty_did).in_definition_order()`\n+                // considering privacy, `doc(hidden)`, etc.\n+                // I don't feel like that right now :cold_sweat:.\n+\n+                let parent_href = match trait_ {\n+                    Some(trait_) => href(trait_.def_id(), cx).ok(),\n+                    None => self_type.def_id(cx.cache()).and_then(|did| href(did, cx).ok()),\n+                };\n+\n+                if let Some((url, _, path)) = parent_href {\n+                    write!(\n+                        f,\n+                        \"<a class=\\\"associatedtype\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n+                                    title=\\\"type {path}::{name}\\\">{name}</a>\",\n+                        shortty = ItemType::AssocType,\n+                        name = assoc.name,\n+                        path = join_with_double_colon(&path),\n+                    )\n+                } else {\n+                    write!(f, \"{}\", assoc.name)\n+                }\n             } else {\n                 write!(f, \"{}\", assoc.name)\n             }?;"}, {"sha": "d6773169639c37e51b87d060a4d009e5678eb732", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -2202,7 +2202,9 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n             }\n             clean::Type::QPath(box clean::QPathData { self_type, trait_, .. }) => {\n                 work.push_back(self_type);\n-                process_path(trait_.def_id());\n+                if let Some(trait_) = trait_ {\n+                    process_path(trait_.def_id());\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "b1cef20b434a650d1e7235dbf8fbd702d0cb264e", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -574,7 +574,7 @@ impl FromWithTcx<clean::Type> for Type {\n                 name: assoc.name.to_string(),\n                 args: Box::new(assoc.args.into_tcx(tcx)),\n                 self_type: Box::new(self_type.into_tcx(tcx)),\n-                trait_: trait_.into_tcx(tcx),\n+                trait_: trait_.map(|trait_| trait_.into_tcx(tcx)),\n             },\n         }\n     }"}, {"sha": "3556834071fc964272e902fbdf3d706b5780cdad", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -8,7 +8,7 @@ use serde::{Deserialize, Serialize};\n use std::path::PathBuf;\n \n /// rustdoc format-version.\n-pub const FORMAT_VERSION: u32 = 24;\n+pub const FORMAT_VERSION: u32 = 25;\n \n /// A `Crate` is the root of the emitted JSON blob. It contains all type/documentation information\n /// about the language items in the local crate, as well as info about external items to allow\n@@ -581,13 +581,15 @@ pub enum Type {\n         #[serde(rename = \"type\")]\n         type_: Box<Type>,\n     },\n-    /// `<Type as Trait>::Name` or associated types like `T::Item` where `T: Iterator`\n+    /// Associated types like `<Type as Trait>::Name` and `T::Item` where\n+    /// `T: Iterator` or inherent associated types like `Struct::Name`.\n     QualifiedPath {\n         name: String,\n         args: Box<GenericArgs>,\n         self_type: Box<Type>,\n+        /// `None` iff this is an *inherent* associated type.\n         #[serde(rename = \"trait\")]\n-        trait_: Path,\n+        trait_: Option<Path>,\n     },\n }\n "}, {"sha": "26b73d15a68fb94579f6d3590585ec0e9d81d3d5", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1 +1 @@\n-Subproject commit 569b648b5831ae8a515e90c80843a5287c3304ef\n+Subproject commit 26b73d15a68fb94579f6d3590585ec0e9d81d3d5"}, {"sha": "b27ffe73ffda442d153333d8a92bcd5b1e91de1f", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1424,6 +1424,7 @@ fn ty_auto_deref_stability<'tcx>(\n                 continue;\n             },\n             ty::Param(_) => TyPosition::new_deref_stable_for_result(precedence, ty),\n+            ty::Alias(ty::Inherent, _) => unreachable!(\"inherent projection should have been normalized away above\"),\n             ty::Alias(ty::Projection, _) if ty.has_non_region_param() => {\n                 TyPosition::new_deref_stable_for_result(precedence, ty)\n             },"}, {"sha": "67b7d3691dc02df12ce70157704edc49d262cf1b", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -385,6 +385,9 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n             Node::Expr(parent_expr) => {\n                 if let Some((callee_def_id, call_substs, recv, call_args)) = get_callee_substs_and_args(cx, parent_expr)\n                 {\n+                    // FIXME: the `subst_identity()` below seems incorrect, since we eventually\n+                    // call `tcx.try_subst_and_normalize_erasing_regions` further down\n+                    // (i.e., we are explicitly not in the identity context).\n                     let fn_sig = cx.tcx.fn_sig(callee_def_id).subst_identity().skip_binder();\n                     if let Some(arg_index) = recv.into_iter().chain(call_args).position(|arg| arg.hir_id == expr.hir_id)\n                         && let Some(param_ty) = fn_sig.inputs().get(arg_index)\n@@ -435,7 +438,7 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n                         let output_ty = fn_sig.output();\n                         if output_ty.contains(*param_ty) {\n                             if let Ok(new_ty)  = cx.tcx.try_subst_and_normalize_erasing_regions(\n-                                new_subst, cx.param_env, output_ty) {\n+                                new_subst, cx.param_env, EarlyBinder(output_ty)) {\n                                 expr = parent_expr;\n                                 ty = new_ty;\n                                 continue;"}, {"sha": "23e88844bd0b8ded28ab90ce3bdfd5610561d92c", "filename": "src/tools/generate-windows-sys/Cargo.toml", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fgenerate-windows-sys%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fgenerate-windows-sys%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fgenerate-windows-sys%2FCargo.toml?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -0,0 +1,7 @@\n+[package]\n+name = \"generate-windows-sys\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+[dependencies.windows-bindgen]\n+version = \"0.49\""}, {"sha": "91d981462e816df1d2c496a95843c28aadeab9f3", "filename": "src/tools/generate-windows-sys/src/main.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fgenerate-windows-sys%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fgenerate-windows-sys%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fgenerate-windows-sys%2Fsrc%2Fmain.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -0,0 +1,37 @@\n+use std::fs;\n+use std::io::{self, Write};\n+use std::path::PathBuf;\n+\n+/// This is printed to the file before the rest of the contents.\n+const PRELUDE: &str = r#\"// This file is autogenerated.\n+//\n+// To add bindings, edit windows_sys.lst then use `./x run generate-windows-sys` to\n+// regenerate the bindings.\n+//\n+// ignore-tidy-filelength\n+\"#;\n+\n+fn main() -> io::Result<()> {\n+    let mut path: PathBuf =\n+        std::env::args_os().nth(1).expect(\"a path to the rust repository is required\").into();\n+    path.push(\"library/std/src/sys/windows/c/windows_sys.lst\");\n+\n+    // Load the list of APIs\n+    let buffer = fs::read_to_string(&path)?;\n+    let names: Vec<&str> = buffer\n+        .lines()\n+        .filter_map(|line| {\n+            let line = line.trim();\n+            if line.is_empty() || line.starts_with(\"//\") { None } else { Some(line) }\n+        })\n+        .collect();\n+\n+    // Write the bindings to windows-sys.rs\n+    let bindings = windows_bindgen::standalone_std(&names);\n+    path.set_extension(\"rs\");\n+    let mut f = std::fs::File::create(&path)?;\n+    f.write_all(PRELUDE.as_bytes())?;\n+    f.write_all(bindings.as_bytes())?;\n+\n+    Ok(())\n+}"}, {"sha": "bf8a64acf08d69237d717d1745085a0f2f8e7cb2", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -273,7 +273,9 @@ impl<'a> Validator<'a> {\n             Type::QualifiedPath { name: _, args, self_type, trait_ } => {\n                 self.check_generic_args(&**args);\n                 self.check_type(&**self_type);\n-                self.check_path(trait_, PathKind::Trait);\n+                if let Some(trait_) = trait_ {\n+                    self.check_path(trait_, PathKind::Trait);\n+                }\n             }\n         }\n     }"}, {"sha": "76cc2e94927c286fdc7324262274d1a0453db468", "filename": "src/tools/miri/ci.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fmiri%2Fci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fmiri%2Fci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fci.sh?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -45,7 +45,8 @@ function run_tests {\n     # them. Also error locations change so we don't run the failing tests.\n     # We explicitly enable debug-assertions here, they are disabled by -O but we have tests\n     # which exist to check that we panic on debug assertion failures.\n-    MIRIFLAGS=\"${MIRIFLAGS:-} -O -Zmir-opt-level=4 -Cdebug-assertions=yes\" MIRI_SKIP_UI_CHECKS=1 ./miri test -- tests/{pass,panic}\n+    #FIXME: Disabled due to <https://github.com/rust-lang/rust/issues/111422>.\n+    #MIRIFLAGS=\"${MIRIFLAGS:-} -O -Zmir-opt-level=4 -Cdebug-assertions=yes\" MIRI_SKIP_UI_CHECKS=1 ./miri test -- tests/{pass,panic}\n \n     # Also run some many-seeds tests. 64 seeds means this takes around a minute per test.\n     for FILE in tests/many-seeds/*.rs; do"}, {"sha": "25304fc19f7bcf4cdf644d3857b9e64a6ea00dbb", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1 +1 @@\n-c4190f2d3a46a59f435f7b42f58bc22b2f4d6917\n+65dfca8488d635552eb246eb8e15df646e987cff"}, {"sha": "9cc8b91ff500c8f1d7e9961384d857af6525d46e", "filename": "src/tools/miri/tests/fail/const-ub-checks.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconst-ub-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconst-ub-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fconst-ub-checks.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,3 @@\n-#![feature(const_ptr_read)]\n-\n const UNALIGNED_READ: () = unsafe {\n     let x = &[0u8; 4];\n     let ptr = x.as_ptr().cast::<u32>();"}, {"sha": "d338bb412054ea825317fbc300b42f3f2e6c6dbf", "filename": "src/tools/rust-analyzer/crates/hir-def/src/lang_item.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flang_item.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -379,7 +379,6 @@ language_item_table! {\n     // FIXME(swatinem): the following lang items are used for async lowering and\n     // should become obsolete eventually.\n     ResumeTy,                ResumeTy,            resume_ty,                  Target::Struct,         GenericRequirement::None;\n-    IdentityFuture,          identity_future,     identity_future_fn,         Target::Fn,             GenericRequirement::None;\n     GetContext,              get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n \n     Context,                 Context,             context,                    Target::Struct,         GenericRequirement::None;"}, {"sha": "9473eabe442ce2380a0c642909e845c1ccb7aca5", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -9,8 +9,8 @@ use std::path::{Path, PathBuf};\n \n const ENTRY_LIMIT: usize = 900;\n // FIXME: The following limits should be reduced eventually.\n-const ISSUES_ENTRY_LIMIT: usize = 1953;\n-const ROOT_ENTRY_LIMIT: usize = 894;\n+const ISSUES_ENTRY_LIMIT: usize = 1920;\n+const ROOT_ENTRY_LIMIT: usize = 895;\n \n fn check_entries(tests_path: &Path, bad: &mut bool) {\n     let mut directories: HashMap<PathBuf, usize> = HashMap::new();"}, {"sha": "df1080bff2b1c2d4d356db058a36b47b51420cec", "filename": "tests/codegen/fewer-names.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fcodegen%2Ffewer-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fcodegen%2Ffewer-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ffewer-names.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -7,14 +7,14 @@\n \n #[no_mangle]\n pub fn sum(x: u32, y: u32) -> u32 {\n-// YES-LABEL: define{{.*}}i32 @sum(i32 noundef %0, i32 noundef %1)\n-// YES-NEXT:    %3 = add i32 %1, %0\n-// YES-NEXT:    ret i32 %3\n+    // YES-LABEL: define{{.*}}i32 @sum(i32 noundef %0, i32 noundef %1)\n+    // YES-NEXT:    %3 = add i32 %1, %0\n+    // YES-NEXT:    ret i32 %3\n \n-// NO-LABEL: define{{.*}}i32 @sum(i32 noundef %x, i32 noundef %y)\n-// NO-NEXT:  start:\n-// NO-NEXT:    %0 = add i32 %y, %x\n-// NO-NEXT:    ret i32 %0\n+    // NO-LABEL: define{{.*}}i32 @sum(i32 noundef %x, i32 noundef %y)\n+    // NO-NEXT:  start:\n+    // NO-NEXT:    %z = add i32 %y, %x\n+    // NO-NEXT:    ret i32 %z\n     let z = x + y;\n     z\n }"}, {"sha": "acf759ebe54524bc5507f751be95dd1969023f7c", "filename": "tests/codegen/mem-replace-big-type.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fcodegen%2Fmem-replace-big-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fcodegen%2Fmem-replace-big-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-big-type.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -13,7 +13,8 @@ pub struct Big([u64; 7]);\n pub fn replace_big(dst: &mut Big, src: Big) -> Big {\n     // Back in 1.68, this emitted six `memcpy`s.\n     // `read_via_copy` in 1.69 got that down to three.\n-    // `write_via_move` has it down to just the two essential ones.\n+    // `write_via_move` it was originally down to the essential two, however\n+    // with nrvo disabled it is back at 3\n     std::mem::replace(dst, src)\n }\n \n@@ -22,13 +23,14 @@ pub fn replace_big(dst: &mut Big, src: Big) -> Big {\n \n // CHECK-NOT: call void @llvm.memcpy\n \n-// For a large type, we expect exactly two `memcpy`s\n+// For a large type, we expect exactly three `memcpy`s\n // CHECK-LABEL: define internal void @{{.+}}mem{{.+}}replace{{.+}}sret(%Big)\n-    // CHECK-NOT: alloca\n-    // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %0, {{i8\\*|ptr}} align 8 %dest, i{{.*}} 56, i1 false)\n-    // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %dest, {{i8\\*|ptr}} align 8 %src, i{{.*}} 56, i1 false)\n-    // CHECK-NOT: call void @llvm.memcpy\n+// CHECK-NOT: call void @llvm.memcpy\n+// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %result, {{i8\\*|ptr}} align 8 %dest, i{{.*}} 56, i1 false)\n+// CHECK-NOT: call void @llvm.memcpy\n+// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %dest, {{i8\\*|ptr}} align 8 %src, i{{.*}} 56, i1 false)\n+// CHECK-NOT: call void @llvm.memcpy\n+// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %0, {{i8\\*|ptr}} align 8 %result, i{{.*}} 56, i1 false)\n+// CHECK-NOT: call void @llvm.memcpy\n \n // CHECK-NOT: call void @llvm.memcpy"}, {"sha": "b2ae99f3761bfa8203915aeb4812c0a8f12d5e53", "filename": "tests/codegen/nrvo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fcodegen%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fcodegen%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fnrvo.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -8,7 +8,7 @@\n pub fn nrvo(init: fn(&mut [u8; 4096])) -> [u8; 4096] {\n     // CHECK-LABEL: nrvo\n     // CHECK: @llvm.memset\n-    // CHECK-NOT: @llvm.memcpy\n+    // FIXME: turn on nrvo then check-not: @llvm.memcpy\n     // CHECK: ret\n     // CHECK-EMPTY\n     let mut buf = [0; 4096];"}, {"sha": "d4715efad73c0fe0855a3a22314dd662d735861d", "filename": "tests/codegen/var-names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fcodegen%2Fvar-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fcodegen%2Fvar-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fvar-names.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -9,7 +9,7 @@ pub fn test(a: u32, b: u32) -> u32 {\n     // CHECK: %c = add i32 %a, %b\n     let d = c;\n     let e = d * a;\n-    // CHECK-NEXT: %0 = mul i32 %c, %a\n+    // CHECK-NEXT: %e = mul i32 %c, %a\n     e\n-    // CHECK-NEXT: ret i32 %0\n+    // CHECK-NEXT: ret i32 %e\n }"}, {"sha": "4e5d8dc063241af714e1d057ba815cf453a93c26", "filename": "tests/codegen/vec-shrink-panik.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fcodegen%2Fvec-shrink-panik.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fcodegen%2Fvec-shrink-panik.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fvec-shrink-panik.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -25,7 +25,7 @@ pub fn issue71861(vec: Vec<u32>) -> Box<[u32]> {\n \n     // Call to panic_cannot_unwind in case of double-panic is expected\n     // on LLVM 16 and older, but other panics are not.\n-    // CHECK: cleanup\n+    // CHECK: filter\n     // old-NEXT: ; call core::panicking::panic_cannot_unwind\n     // old-NEXT: panic_cannot_unwind\n \n@@ -40,7 +40,7 @@ pub fn issue75636<'a>(iter: &[&'a str]) -> Box<[&'a str]> {\n \n     // Call to panic_cannot_unwind in case of double-panic is expected,\n     // on LLVM 16 and older, but other panics are not.\n-    // CHECK: cleanup\n+    // CHECK: filter\n     // old-NEXT: ; call core::panicking::panic_cannot_unwind\n     // old-NEXT: panic_cannot_unwind\n "}, {"sha": "6c9df8f042b79fd924e7c4558c96cf194550405d", "filename": "tests/mir-opt/bool_compare.opt1.InstSimplify.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fbool_compare.opt1.InstSimplify.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fbool_compare.opt1.InstSimplify.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbool_compare.opt1.InstSimplify.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `opt1` before InstCombine\n-+ // MIR for `opt1` after InstCombine\n+- // MIR for `opt1` before InstSimplify\n++ // MIR for `opt1` after InstSimplify\n   \n   fn opt1(_1: bool) -> u32 {\n       debug x => _1;                       // in scope 0 at $DIR/bool_compare.rs:+0:9: +0:10", "previous_filename": "tests/mir-opt/bool_compare.opt1.InstCombine.diff"}, {"sha": "9fb3982654abbdf1ea82439ae08c5ebd336ad124", "filename": "tests/mir-opt/bool_compare.opt2.InstSimplify.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fbool_compare.opt2.InstSimplify.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fbool_compare.opt2.InstSimplify.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbool_compare.opt2.InstSimplify.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `opt2` before InstCombine\n-+ // MIR for `opt2` after InstCombine\n+- // MIR for `opt2` before InstSimplify\n++ // MIR for `opt2` after InstSimplify\n   \n   fn opt2(_1: bool) -> u32 {\n       debug x => _1;                       // in scope 0 at $DIR/bool_compare.rs:+0:9: +0:10", "previous_filename": "tests/mir-opt/bool_compare.opt2.InstCombine.diff"}, {"sha": "3a47da86735e349b62eeec5b9a74367c7711a602", "filename": "tests/mir-opt/bool_compare.opt3.InstSimplify.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fbool_compare.opt3.InstSimplify.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fbool_compare.opt3.InstSimplify.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbool_compare.opt3.InstSimplify.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `opt3` before InstCombine\n-+ // MIR for `opt3` after InstCombine\n+- // MIR for `opt3` before InstSimplify\n++ // MIR for `opt3` after InstSimplify\n   \n   fn opt3(_1: bool) -> u32 {\n       debug x => _1;                       // in scope 0 at $DIR/bool_compare.rs:+0:9: +0:10", "previous_filename": "tests/mir-opt/bool_compare.opt3.InstCombine.diff"}, {"sha": "5319c987d418bbdda8903ef7b1fd9a026a693ec4", "filename": "tests/mir-opt/bool_compare.opt4.InstSimplify.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fbool_compare.opt4.InstSimplify.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fbool_compare.opt4.InstSimplify.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbool_compare.opt4.InstSimplify.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `opt4` before InstCombine\n-+ // MIR for `opt4` after InstCombine\n+- // MIR for `opt4` before InstSimplify\n++ // MIR for `opt4` after InstSimplify\n   \n   fn opt4(_1: bool) -> u32 {\n       debug x => _1;                       // in scope 0 at $DIR/bool_compare.rs:+0:9: +0:10", "previous_filename": "tests/mir-opt/bool_compare.opt4.InstCombine.diff"}, {"sha": "080f7f72d116056dfa8f1ee283aede65ecf52d22", "filename": "tests/mir-opt/bool_compare.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fbool_compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fbool_compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbool_compare.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,21 +1,21 @@\n-// unit-test: InstCombine\n+// unit-test: InstSimplify\n \n-// EMIT_MIR bool_compare.opt1.InstCombine.diff\n+// EMIT_MIR bool_compare.opt1.InstSimplify.diff\n fn opt1(x: bool) -> u32 {\n     if x != true { 0 } else { 1 }\n }\n \n-// EMIT_MIR bool_compare.opt2.InstCombine.diff\n+// EMIT_MIR bool_compare.opt2.InstSimplify.diff\n fn opt2(x: bool) -> u32 {\n     if true != x { 0 } else { 1 }\n }\n \n-// EMIT_MIR bool_compare.opt3.InstCombine.diff\n+// EMIT_MIR bool_compare.opt3.InstSimplify.diff\n fn opt3(x: bool) -> u32 {\n     if x == false { 0 } else { 1 }\n }\n \n-// EMIT_MIR bool_compare.opt4.InstCombine.diff\n+// EMIT_MIR bool_compare.opt4.InstSimplify.diff\n fn opt4(x: bool) -> u32 {\n     if false == x { 0 } else { 1 }\n }"}, {"sha": "a641b69deb0815dfa936ab402d107afa309565e7", "filename": "tests/mir-opt/casts.redundant.InstSimplify.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcasts.redundant.InstSimplify.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcasts.redundant.InstSimplify.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcasts.redundant.InstSimplify.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `redundant` before InstCombine\n-+ // MIR for `redundant` after InstCombine\n+- // MIR for `redundant` before InstSimplify\n++ // MIR for `redundant` after InstSimplify\n   \n   fn redundant(_1: *const &u8) -> *const &u8 {\n       debug x => _1;                       // in scope 0 at $DIR/casts.rs:+0:30: +0:31", "previous_filename": "tests/mir-opt/casts.redundant.InstCombine.diff"}, {"sha": "413b0e09d3fde19b02aca37a9c80a86318eae07f", "filename": "tests/mir-opt/casts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcasts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcasts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcasts.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,6 +1,6 @@\n #![crate_type = \"lib\"]\n \n-// EMIT_MIR casts.redundant.InstCombine.diff\n+// EMIT_MIR casts.redundant.InstSimplify.diff\n // EMIT_MIR casts.redundant.PreCodegen.after.mir\n pub fn redundant<'a, 'b: 'a>(x: *const &'a u8) -> *const &'a u8 {\n     generic_cast::<&'a u8, &'b u8>(x) as *const &'a u8"}, {"sha": "0777007cefa687c26657e946c9ae927685d628d7", "filename": "tests/mir-opt/combine_array_len.norm2.InstSimplify.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_array_len.norm2.InstSimplify.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_array_len.norm2.InstSimplify.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcombine_array_len.norm2.InstSimplify.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `norm2` before InstCombine\n-+ // MIR for `norm2` after InstCombine\n+- // MIR for `norm2` before InstSimplify\n++ // MIR for `norm2` after InstSimplify\n   \n   fn norm2(_1: [f32; 2]) -> f32 {\n       debug x => _1;                       // in scope 0 at $DIR/combine_array_len.rs:+0:10: +0:11", "previous_filename": "tests/mir-opt/combine_array_len.norm2.InstCombine.diff"}, {"sha": "970cafafcf042269682a08627662b39dad5399b6", "filename": "tests/mir-opt/combine_array_len.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcombine_array_len.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,6 +1,6 @@\n // ignore-wasm32 compiled with panic=abort by default\n-// unit-test: InstCombine\n-// EMIT_MIR combine_array_len.norm2.InstCombine.diff\n+// unit-test: InstSimplify\n+// EMIT_MIR combine_array_len.norm2.InstSimplify.diff\n \n fn norm2(x: [f32; 2]) -> f32 {\n     let a = x[0];"}, {"sha": "1deee9dd6d2f25110c1abdff3dd63e1614683b83", "filename": "tests/mir-opt/combine_clone_of_primitives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_clone_of_primitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_clone_of_primitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcombine_clone_of_primitives.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,7 +1,7 @@\n-// unit-test: InstCombine\n+// unit-test: InstSimplify\n // ignore-wasm32 compiled with panic=abort by default\n \n-// EMIT_MIR combine_clone_of_primitives.{impl#0}-clone.InstCombine.diff\n+// EMIT_MIR combine_clone_of_primitives.{impl#0}-clone.InstSimplify.diff\n \n #[derive(Clone)]\n struct MyThing<T> {"}, {"sha": "bb0811a7abb2d146f6d2c25aa9601f2656e63d8e", "filename": "tests/mir-opt/combine_clone_of_primitives.{impl#0}-clone.InstSimplify.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_clone_of_primitives.%7Bimpl%230%7D-clone.InstSimplify.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_clone_of_primitives.%7Bimpl%230%7D-clone.InstSimplify.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcombine_clone_of_primitives.%7Bimpl%230%7D-clone.InstSimplify.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `<impl at $DIR/combine_clone_of_primitives.rs:6:10: 6:15>::clone` before InstCombine\n-+ // MIR for `<impl at $DIR/combine_clone_of_primitives.rs:6:10: 6:15>::clone` after InstCombine\n+- // MIR for `<impl at $DIR/combine_clone_of_primitives.rs:6:10: 6:15>::clone` before InstSimplify\n++ // MIR for `<impl at $DIR/combine_clone_of_primitives.rs:6:10: 6:15>::clone` after InstSimplify\n   \n   fn <impl at $DIR/combine_clone_of_primitives.rs:6:10: 6:15>::clone(_1: &MyThing<T>) -> MyThing<T> {\n       debug self => _1;                    // in scope 0 at $DIR/combine_clone_of_primitives.rs:+0:10: +0:15", "previous_filename": "tests/mir-opt/combine_clone_of_primitives.{impl#0}-clone.InstCombine.diff"}, {"sha": "c5907e7cf180ef500647f460e4673eabad9fc70b", "filename": "tests/mir-opt/combine_transmutes.adt_transmutes.InstSimplify.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_transmutes.adt_transmutes.InstSimplify.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_transmutes.adt_transmutes.InstSimplify.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcombine_transmutes.adt_transmutes.InstSimplify.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `adt_transmutes` before InstCombine\n-+ // MIR for `adt_transmutes` after InstCombine\n+- // MIR for `adt_transmutes` before InstSimplify\n++ // MIR for `adt_transmutes` after InstSimplify\n   \n   fn adt_transmutes() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/combine_transmutes.rs:+0:32: +0:32", "previous_filename": "tests/mir-opt/combine_transmutes.adt_transmutes.InstCombine.diff"}, {"sha": "57d9f4b14023ea7a876158e8a2ace5b002518c53", "filename": "tests/mir-opt/combine_transmutes.identity_transmutes.InstSimplify.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_transmutes.identity_transmutes.InstSimplify.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_transmutes.identity_transmutes.InstSimplify.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcombine_transmutes.identity_transmutes.InstSimplify.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `identity_transmutes` before InstCombine\n-+ // MIR for `identity_transmutes` after InstCombine\n+- // MIR for `identity_transmutes` before InstSimplify\n++ // MIR for `identity_transmutes` after InstSimplify\n   \n   fn identity_transmutes() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/combine_transmutes.rs:+0:37: +0:37", "previous_filename": "tests/mir-opt/combine_transmutes.identity_transmutes.InstCombine.diff"}, {"sha": "ec7c982c151e97074d64fa9d3ee70893f49e553c", "filename": "tests/mir-opt/combine_transmutes.integer_transmutes.InstSimplify.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_transmutes.integer_transmutes.InstSimplify.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_transmutes.integer_transmutes.InstSimplify.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcombine_transmutes.integer_transmutes.InstSimplify.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `integer_transmutes` before InstCombine\n-+ // MIR for `integer_transmutes` after InstCombine\n+- // MIR for `integer_transmutes` before InstSimplify\n++ // MIR for `integer_transmutes` after InstSimplify\n   \n   fn integer_transmutes() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/combine_transmutes.rs:+0:36: +0:36", "previous_filename": "tests/mir-opt/combine_transmutes.integer_transmutes.InstCombine.diff"}, {"sha": "7088488c1b8563a543e6588e9390a98541911e00", "filename": "tests/mir-opt/combine_transmutes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_transmutes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcombine_transmutes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcombine_transmutes.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,4 +1,4 @@\n-// unit-test: InstCombine\n+// unit-test: InstSimplify\n // compile-flags: -C panic=abort\n \n #![crate_type = \"lib\"]\n@@ -8,15 +8,15 @@\n use std::intrinsics::mir::*;\n use std::mem::{MaybeUninit, ManuallyDrop, transmute};\n \n-// EMIT_MIR combine_transmutes.identity_transmutes.InstCombine.diff\n+// EMIT_MIR combine_transmutes.identity_transmutes.InstSimplify.diff\n pub unsafe fn identity_transmutes() {\n     // These are nops and should be removed\n     let _a = transmute::<i32, i32>(1);\n     let _a = transmute::<Vec<i32>, Vec<i32>>(Vec::new());\n }\n \n #[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n-// EMIT_MIR combine_transmutes.integer_transmutes.InstCombine.diff\n+// EMIT_MIR combine_transmutes.integer_transmutes.InstSimplify.diff\n pub unsafe fn integer_transmutes() {\n     mir! {\n         {\n@@ -30,7 +30,7 @@ pub unsafe fn integer_transmutes() {\n     }\n }\n \n-// EMIT_MIR combine_transmutes.adt_transmutes.InstCombine.diff\n+// EMIT_MIR combine_transmutes.adt_transmutes.InstSimplify.diff\n pub unsafe fn adt_transmutes() {\n     let _a: u8 = transmute(EnumNoRepr::A);\n     let _a: i8 = transmute(EnumNoRepr::B);"}, {"sha": "d72675c2d1157b228810e8ab487e6112554236f8", "filename": "tests/mir-opt/const_prop/bad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -45,7 +45,8 @@\n       }\n   \n       bb1: {\n-          _5 = (*_1)[_6];                  // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n+-         _5 = (*_1)[_6];                  // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n++         _5 = (*_1)[3 of 4];              // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n           StorageDead(_6);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:25: +3:26\n           _0 = const ();                   // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+2:5: +4:6\n           StorageDead(_5);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+4:5: +4:6"}, {"sha": "d72675c2d1157b228810e8ab487e6112554236f8", "filename": "tests/mir-opt/const_prop/bad_op_unsafe_oob_for_slices.main.ConstProp.64bit.diff", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.64bit.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -45,7 +45,8 @@\n       }\n   \n       bb1: {\n-          _5 = (*_1)[_6];                  // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n+-         _5 = (*_1)[_6];                  // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n++         _5 = (*_1)[3 of 4];              // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n           StorageDead(_6);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:25: +3:26\n           _0 = const ();                   // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+2:5: +4:6\n           StorageDead(_5);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+4:5: +4:6"}, {"sha": "33bbad2f422ba0ebddd14dbe28e6c97f7575c303", "filename": "tests/mir-opt/const_prop/large_array_index.main.ConstProp.32bit.diff", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.32bit.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -27,7 +27,8 @@\n       }\n   \n       bb1: {\n-          _1 = _2[_3];                     // scope 0 at $DIR/large_array_index.rs:+2:17: +2:32\n+-         _1 = _2[_3];                     // scope 0 at $DIR/large_array_index.rs:+2:17: +2:32\n++         _1 = _2[2 of 3];                 // scope 0 at $DIR/large_array_index.rs:+2:17: +2:32\n           StorageDead(_3);                 // scope 0 at $DIR/large_array_index.rs:+2:32: +2:33\n           StorageDead(_2);                 // scope 0 at $DIR/large_array_index.rs:+2:32: +2:33\n           _0 = const ();                   // scope 0 at $DIR/large_array_index.rs:+0:11: +3:2"}, {"sha": "33bbad2f422ba0ebddd14dbe28e6c97f7575c303", "filename": "tests/mir-opt/const_prop/large_array_index.main.ConstProp.64bit.diff", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.64bit.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -27,7 +27,8 @@\n       }\n   \n       bb1: {\n-          _1 = _2[_3];                     // scope 0 at $DIR/large_array_index.rs:+2:17: +2:32\n+-         _1 = _2[_3];                     // scope 0 at $DIR/large_array_index.rs:+2:17: +2:32\n++         _1 = _2[2 of 3];                 // scope 0 at $DIR/large_array_index.rs:+2:17: +2:32\n           StorageDead(_3);                 // scope 0 at $DIR/large_array_index.rs:+2:32: +2:33\n           StorageDead(_2);                 // scope 0 at $DIR/large_array_index.rs:+2:32: +2:33\n           _0 = const ();                   // scope 0 at $DIR/large_array_index.rs:+0:11: +3:2"}, {"sha": "e3757941c8cd179ab2a987b88fd8f7c056fdc8a1", "filename": "tests/mir-opt/const_prop/offset_of.concrete.ConstProp.diff", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Foffset_of.concrete.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Foffset_of.concrete.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Foffset_of.concrete.ConstProp.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -22,17 +22,17 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/offset_of.rs:+1:9: +1:10\n--         _1 = OffsetOf(Alpha, [0]);       // scope 0 at $DIR/offset_of.rs:+1:13: +1:33\n-+         _1 = const 4_usize;              // scope 0 at $DIR/offset_of.rs:+1:13: +1:33\n+-         _1 = OffsetOf(Alpha, [0]);       // scope 0 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n++         _1 = const 4_usize;              // scope 0 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           StorageLive(_2);                 // scope 1 at $DIR/offset_of.rs:+2:9: +2:10\n--         _2 = OffsetOf(Alpha, [1]);       // scope 1 at $DIR/offset_of.rs:+2:13: +2:33\n-+         _2 = const 0_usize;              // scope 1 at $DIR/offset_of.rs:+2:13: +2:33\n+-         _2 = OffsetOf(Alpha, [1]);       // scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n++         _2 = const 0_usize;              // scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           StorageLive(_3);                 // scope 2 at $DIR/offset_of.rs:+3:9: +3:11\n--         _3 = OffsetOf(Alpha, [2, 0]);    // scope 2 at $DIR/offset_of.rs:+3:14: +3:36\n-+         _3 = const 2_usize;              // scope 2 at $DIR/offset_of.rs:+3:14: +3:36\n+-         _3 = OffsetOf(Alpha, [2, 0]);    // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n++         _3 = const 2_usize;              // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           StorageLive(_4);                 // scope 3 at $DIR/offset_of.rs:+4:9: +4:11\n--         _4 = OffsetOf(Alpha, [2, 1]);    // scope 3 at $DIR/offset_of.rs:+4:14: +4:36\n-+         _4 = const 3_usize;              // scope 3 at $DIR/offset_of.rs:+4:14: +4:36\n+-         _4 = OffsetOf(Alpha, [2, 1]);    // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n++         _4 = const 3_usize;              // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           _0 = const ();                   // scope 0 at $DIR/offset_of.rs:+0:15: +5:2\n           StorageDead(_4);                 // scope 3 at $DIR/offset_of.rs:+5:1: +5:2\n           StorageDead(_3);                 // scope 2 at $DIR/offset_of.rs:+5:1: +5:2"}, {"sha": "4a655604cd183076de1d50e7c389553dba194f15", "filename": "tests/mir-opt/const_prop/offset_of.generic.ConstProp.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Foffset_of.generic.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Foffset_of.generic.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Foffset_of.generic.ConstProp.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -22,13 +22,13 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/offset_of.rs:+1:9: +1:11\n-          _1 = OffsetOf(Gamma<T>, [0]);    // scope 0 at $DIR/offset_of.rs:+1:14: +1:37\n+          _1 = OffsetOf(Gamma<T>, [0]);    // scope 0 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           StorageLive(_2);                 // scope 1 at $DIR/offset_of.rs:+2:9: +2:11\n-          _2 = OffsetOf(Gamma<T>, [1]);    // scope 1 at $DIR/offset_of.rs:+2:14: +2:37\n+          _2 = OffsetOf(Gamma<T>, [1]);    // scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           StorageLive(_3);                 // scope 2 at $DIR/offset_of.rs:+3:9: +3:11\n-          _3 = OffsetOf(Delta<T>, [1]);    // scope 2 at $DIR/offset_of.rs:+3:14: +3:37\n+          _3 = OffsetOf(Delta<T>, [1]);    // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           StorageLive(_4);                 // scope 3 at $DIR/offset_of.rs:+4:9: +4:11\n-          _4 = OffsetOf(Delta<T>, [2]);    // scope 3 at $DIR/offset_of.rs:+4:14: +4:37\n+          _4 = OffsetOf(Delta<T>, [2]);    // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           _0 = const ();                   // scope 0 at $DIR/offset_of.rs:+0:17: +5:2\n           StorageDead(_4);                 // scope 3 at $DIR/offset_of.rs:+5:1: +5:2\n           StorageDead(_3);                 // scope 2 at $DIR/offset_of.rs:+5:1: +5:2"}, {"sha": "9821d1b1e9220f251f8276e8d7482e37321b2b80", "filename": "tests/mir-opt/const_prop/slice_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Fslice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fconst_prop%2Fslice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fslice_len.rs?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,6 +1,6 @@\n // ignore-wasm32 compiled with panic=abort by default\n // unit-test: ConstProp\n-// compile-flags: -Zmir-enable-passes=+InstCombine\n+// compile-flags: -Zmir-enable-passes=+InstSimplify\n // EMIT_MIR_FOR_EACH_BIT_WIDTH\n \n // EMIT_MIR slice_len.main.ConstProp.diff"}, {"sha": "51707e71661c5e7b872d78b2e4b2a450583ae3da", "filename": "tests/mir-opt/copy-prop/borrowed_local.f.CopyProp.diff", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcopy-prop%2Fborrowed_local.f.CopyProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fcopy-prop%2Fborrowed_local.f.CopyProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fborrowed_local.f.CopyProp.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -20,8 +20,7 @@\n       }\n   \n       bb1: {\n--         _0 = opaque::<u8>(_3) -> bb2;    // scope 0 at $DIR/borrowed_local.rs:+12:13: +12:38\n-+         _0 = opaque::<u8>(_1) -> bb2;    // scope 0 at $DIR/borrowed_local.rs:+12:13: +12:38\n+          _0 = opaque::<u8>(_3) -> bb2;    // scope 0 at $DIR/borrowed_local.rs:+12:13: +12:38\n                                            // mir::Constant\n                                            // + span: $DIR/borrowed_local.rs:28:28: 28:34\n                                            // + literal: Const { ty: fn(u8) -> bool {opaque::<u8>}, val: Value(<ZST>) }"}, {"sha": "cadf05152a43f02d5ffd13c9d3226f94687e69a0", "filename": "tests/mir-opt/dont_yeet_assert.generic.InstSimplify.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fdont_yeet_assert.generic.InstSimplify.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7a41eacf170ed234e059608515115e94fbe721fe/tests%2Fmir-opt%2Fdont_yeet_assert.generic.InstSimplify.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdont_yeet_assert.generic.InstSimplify.diff?ref=7a41eacf170ed234e059608515115e94fbe721fe", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `generic` before InstCombine\n-+ // MIR for `generic` after InstCombine\n+- // MIR for `generic` before InstSimplify\n++ // MIR for `generic` after InstSimplify\n   \n   fn generic() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/dont_yeet_assert.rs:+0:21: +0:21", "previous_filename": "tests/mir-opt/dont_yeet_assert.generic.InstCombine.diff"}]}