{"sha": "4f10c19215e4c234e25c25b57983eeb42774f873", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMTBjMTkyMTVlNGMyMzRlMjVjMjViNTc5ODNlZWI0Mjc3NGY4NzM=", "commit": {"author": {"name": "Margaret Meyerhofer", "email": "mmeyerho@andrew", "date": "2012-05-23T01:23:32Z"}, "committer": {"name": "Margaret Meyerhofer", "email": "mmeyerho@andrew", "date": "2012-05-23T01:23:32Z"}, "message": "Merge branch 'master' of git://github.com/mozilla/rust", "tree": {"sha": "afd78808f804f385b32188c577c3396ccf2fd826", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afd78808f804f385b32188c577c3396ccf2fd826"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f10c19215e4c234e25c25b57983eeb42774f873", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f10c19215e4c234e25c25b57983eeb42774f873", "html_url": "https://github.com/rust-lang/rust/commit/4f10c19215e4c234e25c25b57983eeb42774f873", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f10c19215e4c234e25c25b57983eeb42774f873/comments", "author": null, "committer": null, "parents": [{"sha": "507b8e5ae074bd24ac78d155f421f78200a5b400", "url": "https://api.github.com/repos/rust-lang/rust/commits/507b8e5ae074bd24ac78d155f421f78200a5b400", "html_url": "https://github.com/rust-lang/rust/commit/507b8e5ae074bd24ac78d155f421f78200a5b400"}, {"sha": "8caf1403be0d5968123aeba25dd7ed620a670d6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8caf1403be0d5968123aeba25dd7ed620a670d6b", "html_url": "https://github.com/rust-lang/rust/commit/8caf1403be0d5968123aeba25dd7ed620a670d6b"}], "stats": {"total": 2747, "additions": 1840, "deletions": 907}, "files": [{"sha": "87c40f4ad3c82a79ab4385cc1a0a6debceafb362", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -27,6 +27,7 @@ Eric Holk <eric.holk@gmail.com>\n Erick Tryzelaar <erick.tryzelaar@gmail.com>\n Erik Rose <erik@mozilla.com>\n Evan McClanahan <evan@evanmcc.com>\n+Gareth Daniel Smith <garethdanielsmith@gmail.com>\n Grahame Bowland <grahame@angrygoats.net>\n Graham Fawcett <fawcett@uwindsor.ca>\n Haitao Li <lihaitao@gmail.com>"}, {"sha": "aeb272d6b26eda2e3cda7266d15ee3dbdcd96ca8", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -18,13 +18,7 @@ import vec;\n import std::getopts;\n import getopts::{optflag, optopt, opt_present};\n \n-enum _src {\n-    /* Break cycles in package <-> source */\n-    _source(source),\n-}\n-\n type package = {\n-//    source: _src,\n     name: str,\n     uuid: str,\n     url: str,\n@@ -293,7 +287,6 @@ fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n     };\n \n     vec::grow(src.packages, 1u, {\n-        // source: _source(src),\n         name: name,\n         uuid: uuid,\n         url: url,"}, {"sha": "7e30d81709eebd025e6afb8f50248e5c972800af", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -188,9 +188,9 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint,\n         }\n     }\n     let afp =\n-        {fold_expr: fold::wrap(bind fold_expr_rep(j, i,\n-                                                  newexpr.node, _, _, tm))\n-         with *fold::default_ast_fold()};\n+        @{fold_expr: fold::wrap(bind fold_expr_rep(j, i,\n+                                                   newexpr.node, _, _, tm))\n+          with *fold::default_ast_fold()};\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n     *crate2\n@@ -211,8 +211,8 @@ fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty,\n         } else { fold::noop_fold_ty(original, fld) }\n     }\n     let afp =\n-        {fold_ty: fold::wrap(bind fold_ty_rep(j, i, newty.node, _, _, tm))\n-            with *fold::default_ast_fold()};\n+        @{fold_ty: fold::wrap(bind fold_ty_rep(j, i, newty.node, _, _, tm))\n+         with *fold::default_ast_fold()};\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n     *crate2"}, {"sha": "4b07e2b29b7b639319d4747f32ea34373056f097", "filename": "src/libcore/core.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -11,6 +11,7 @@ import vec_iter::extensions;\n import option::extensions;\n import option_iter::extensions;\n import ptr::extensions;\n+import rand::extensions;\n \n export path, option, some, none, unreachable;\n export extensions;"}, {"sha": "e0321b452878c63843cde37a0ba8316467084a78", "filename": "src/libcore/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -28,7 +28,7 @@ enum future<A> = {\n };\n \n #[doc = \"Methods on the `future` type\"]\n-impl future<A:send> for future<A> {\n+impl future<A:copy send> for future<A> {\n \n     fn get() -> A {\n         #[doc = \"Get the value of the future\"];"}, {"sha": "e210ab0944c418ae8f384905a49a6488310bf2a5", "filename": "src/libcore/io.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -161,6 +161,24 @@ impl reader_util for reader {\n         while !self.eof() { buf += self.read_bytes(2048u); }\n         buf\n     }\n+\n+    fn each_byte(it: fn(int) -> bool) {\n+        while !self.eof() {\n+            if !it(self.read_byte()) { break; }\n+        }\n+    }\n+\n+    fn each_char(it: fn(char) -> bool) {\n+        while !self.eof() {\n+            if !it(self.read_char()) { break; }\n+        }\n+    }\n+\n+    fn each_line(it: fn(str) -> bool) {\n+        while !self.eof() {\n+            if !it(self.read_line()) { break; }\n+        }\n+    }\n }\n \n // Reader implementations"}, {"sha": "dedcf9916701583557975fae7914aaa7b2fba606", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 353, "deletions": 64, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,12 +1,14 @@\n #[doc = \"Random number generation\"];\n \n-export rng;\n+export rng, seed, seeded_rng, weighted, extensions;\n \n enum rctx {}\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n+    fn rand_seed() -> [u8];\n     fn rand_new() -> *rctx;\n+    fn rand_new_seeded(seed: [u8]) -> *rctx;\n     fn rand_next(c: *rctx) -> u32;\n     fn rand_free(c: *rctx);\n }\n@@ -15,93 +17,380 @@ native mod rustrt {\n iface rng {\n     #[doc = \"Return the next random integer\"]\n     fn next() -> u32;\n+}\n \n-    #[doc = \"Return the next random float\"]\n-    fn next_float() -> float;\n+#[doc = \"A value with a particular weight compared to other values\"]\n+type weighted<T> = { weight: uint, item: T };\n \n-    #[doc = \"Return a random string composed of A-Z, a-z, 0-9.\"]\n-    fn gen_str(len: uint) -> str;\n+#[doc = \"Extension methods for random number generators\"]\n+impl extensions for rng {\n \n-    #[doc = \"Return a random byte string.\"]\n-    fn gen_bytes(len: uint) -> [u8];\n-}\n+    #[doc = \"Return a random int\"]\n+    fn gen_int() -> int {\n+        self.gen_i64() as int\n+    }\n \n-resource rand_res(c: *rctx) { rustrt::rand_free(c); }\n+    #[doc = \"Return an int randomly chosen from the range [start, end), \\\n+             failing if start >= end\"]\n+    fn gen_int_range(start: int, end: int) -> int {\n+        assert start < end;\n+        start + int::abs(self.gen_int() % (end - start))\n+    }\n \n-#[doc = \"Create a random number generator\"]\n-fn rng() -> rng {\n-    impl of rng for @rand_res {\n-        fn next() -> u32 { ret rustrt::rand_next(**self); }\n-        fn next_float() -> float {\n-          let u1 = rustrt::rand_next(**self) as float;\n-          let u2 = rustrt::rand_next(**self) as float;\n-          let u3 = rustrt::rand_next(**self) as float;\n-          let scale = u32::max_value as float;\n-          ret ((u1 / scale + u2) / scale + u3) / scale;\n+    #[doc = \"Return a random i8\"]\n+    fn gen_i8() -> i8 {\n+        self.next() as i8\n+    }\n+\n+    #[doc = \"Return a random i16\"]\n+    fn gen_i16() -> i16 {\n+        self.next() as i16\n+    }\n+\n+    #[doc = \"Return a random i32\"]\n+    fn gen_i32() -> i32 {\n+        self.next() as i32\n+    }\n+\n+    #[doc = \"Return a random i64\"]\n+    fn gen_i64() -> i64 {\n+        (self.next() as i64 << 32) | self.next() as i64\n+    }\n+\n+    #[doc = \"Return a random uint\"]\n+    fn gen_uint() -> uint {\n+        self.gen_u64() as uint\n+    }\n+\n+    #[doc = \"Return a uint randomly chosen from the range [start, end), \\\n+             failing if start >= end\"]\n+    fn gen_uint_range(start: uint, end: uint) -> uint {\n+        assert start < end;\n+        start + (self.gen_uint() % (end - start))\n+    }\n+\n+    #[doc = \"Return a random u8\"]\n+    fn gen_u8() -> u8 {\n+        self.next() as u8\n+    }\n+\n+    #[doc = \"Return a random u16\"]\n+    fn gen_u16() -> u16 {\n+        self.next() as u16\n+    }\n+\n+    #[doc = \"Return a random u32\"]\n+    fn gen_u32() -> u32 {\n+        self.next()\n+    }\n+\n+    #[doc = \"Return a random u64\"]\n+    fn gen_u64() -> u64 {\n+        (self.next() as u64 << 32) | self.next() as u64\n+    }\n+\n+    #[doc = \"Return a random float\"]\n+    fn gen_float() -> float {\n+        self.gen_f64() as float\n+    }\n+\n+    #[doc = \"Return a random f32\"]\n+    fn gen_f32() -> f32 {\n+        self.gen_f64() as f32\n+    }\n+\n+    #[doc = \"Return a random f64\"]\n+    fn gen_f64() -> f64 {\n+        let u1 = self.next() as f64;\n+        let u2 = self.next() as f64;\n+        let u3 = self.next() as f64;\n+        let scale = u32::max_value as f64;\n+        ret ((u1 / scale + u2) / scale + u3) / scale;\n+    }\n+\n+    #[doc = \"Return a random char\"]\n+    fn gen_char() -> char {\n+        self.next() as char\n+    }\n+\n+    #[doc = \"Return a char randomly chosen from chars, failing if chars is \\\n+             empty\"]\n+    fn gen_char_from(chars: str) -> char {\n+        assert !chars.is_empty();\n+        self.choose(str::chars(chars))\n+    }\n+\n+    #[doc = \"Return a random bool\"]\n+    fn gen_bool() -> bool {\n+        self.next() & 1u32 == 1u32\n+    }\n+\n+    #[doc = \"Return a bool with a 1 in n chance of true\"]\n+    fn gen_weighted_bool(n: uint) -> bool {\n+        if n == 0u {\n+            true\n+        } else {\n+            self.gen_uint_range(1u, n + 1u) == 1u\n         }\n-        fn gen_str(len: uint) -> str {\n-            let charset = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n-                          \"abcdefghijklmnopqrstuvwxyz\" +\n-                          \"0123456789\";\n-            let mut s = \"\";\n-            let mut i = 0u;\n-            while (i < len) {\n-                let n = rustrt::rand_next(**self) as uint %\n-                    str::len(charset);\n-                s = s + str::from_char(str::char_at(charset, n));\n-                i += 1u;\n+    }\n+\n+    #[doc = \"Return a random string of the specified length composed of A-Z, \\\n+             a-z, 0-9\"]\n+    fn gen_str(len: uint) -> str {\n+        let charset = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n+                      \"abcdefghijklmnopqrstuvwxyz\" +\n+                      \"0123456789\";\n+        let mut s = \"\";\n+        let mut i = 0u;\n+        while (i < len) {\n+            s = s + str::from_char(self.gen_char_from(charset));\n+            i += 1u;\n+        }\n+        s\n+    }\n+\n+    #[doc = \"Return a random byte string of the specified length\"]\n+    fn gen_bytes(len: uint) -> [u8] {\n+        vec::from_fn(len) {|_i|\n+            self.gen_u8()\n+        }\n+    }\n+\n+    #[doc = \"Choose an item randomly, failing if values is empty\"]\n+    fn choose<T:copy>(values: [T]) -> T {\n+        self.choose_option(values).get()\n+    }\n+\n+    #[doc = \"Choose some(item) randomly, returning none if values is empty\"]\n+    fn choose_option<T:copy>(values: [T]) -> option<T> {\n+        if values.is_empty() {\n+            none\n+        } else {\n+            some(values[self.gen_uint_range(0u, values.len())])\n+        }\n+    }\n+\n+    #[doc = \"Choose an item respecting the relative weights, failing if \\\n+             the sum of the weights is 0\"]\n+    fn choose_weighted<T: copy>(v : [weighted<T>]) -> T {\n+        self.choose_weighted_option(v).get()\n+    }\n+\n+    #[doc = \"Choose some(item) respecting the relative weights, returning \\\n+             none if the sum of the weights is 0\"]\n+    fn choose_weighted_option<T:copy>(v: [weighted<T>]) -> option<T> {\n+        let mut total = 0u;\n+        for v.each {|item|\n+            total += item.weight;\n+        }\n+        if total == 0u {\n+            ret none;\n+        }\n+        let chosen = self.gen_uint_range(0u, total);\n+        let mut so_far = 0u;\n+        for v.each {|item|\n+            so_far += item.weight;\n+            if so_far > chosen {\n+                ret some(item.item);\n             }\n-            s\n         }\n-        fn gen_bytes(len: uint) -> [u8] {\n-            let mut v = [];\n-            let mut i = 0u;\n-            while i < len {\n-                let n = rustrt::rand_next(**self) as uint;\n-                v += [(n % (u8::max_value as uint)) as u8];\n-                i += 1u;\n+        unreachable();\n+    }\n+\n+    #[doc = \"Return a vec containing copies of the items, in order, where \\\n+             the weight of the item determines how many copies there are\"]\n+    fn weighted_vec<T:copy>(v: [weighted<T>]) -> [T] {\n+        let mut r = [];\n+        for v.each {|item|\n+            uint::range(0u, item.weight) {|_i|\n+                r += [item.item];\n             }\n-            v\n         }\n+        r\n+    }\n+\n+    #[doc = \"Shuffle a vec\"]\n+    fn shuffle<T:copy>(values: [T]) -> [T] {\n+        let mut m = vec::to_mut(values);\n+        self.shuffle_mut(m);\n+        ret vec::from_mut(m);\n     }\n+\n+    #[doc = \"Shuffle a mutable vec in place\"]\n+    fn shuffle_mut<T>(&values: [mut T]) {\n+        let mut i = values.len();\n+        while i >= 2u {\n+            // invariant: elements with index >= i have been locked in place.\n+            i -= 1u;\n+            // lock element i in place.\n+            vec::swap(values, i, self.gen_uint_range(0u, i + 1u));\n+        }\n+    }\n+\n+}\n+\n+resource rand_res(c: *rctx) { rustrt::rand_free(c); }\n+\n+impl of rng for @rand_res {\n+    fn next() -> u32 { ret rustrt::rand_next(**self); }\n+}\n+\n+#[doc = \"Create a new random seed for seeded_rng\"]\n+fn seed() -> [u8] {\n+    rustrt::rand_seed()\n+}\n+\n+#[doc = \"Create a random number generator with a system specified seed\"]\n+fn rng() -> rng {\n     @rand_res(rustrt::rand_new()) as rng\n }\n \n+#[doc = \"Create a random number generator using the specified seed. A \\\n+         generator constructed with a given seed will generate the same \\\n+         sequence of values as all other generators constructed with the \\\n+         same seed. The seed may be any length.\"]\n+fn seeded_rng(seed: [u8]) -> rng {\n+    @rand_res(rustrt::rand_new_seeded(seed)) as rng\n+}\n+\n #[cfg(test)]\n mod tests {\n \n     #[test]\n-    fn test() {\n-        let r1: rand::rng = rand::rng();\n-        log(debug, r1.next());\n-        log(debug, r1.next());\n-        {\n-            let r2 = rand::rng();\n-            log(debug, r1.next());\n-            log(debug, r2.next());\n-            log(debug, r1.next());\n-            log(debug, r1.next());\n-            log(debug, r2.next());\n-            log(debug, r2.next());\n-            log(debug, r1.next());\n-            log(debug, r1.next());\n-            log(debug, r1.next());\n-            log(debug, r2.next());\n-            log(debug, r2.next());\n-            log(debug, r2.next());\n-        }\n-        log(debug, r1.next());\n-        log(debug, r1.next());\n+    fn rng_seeded() {\n+        let seed = rand::seed();\n+        let ra = rand::seeded_rng(seed);\n+        let rb = rand::seeded_rng(seed);\n+        assert ra.gen_str(100u) == rb.gen_str(100u);\n+    }\n+\n+    #[test]\n+    fn rng_seeded_custom_seed() {\n+        // much shorter than generated seeds which are 1024 bytes\n+        let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n+        let ra = rand::seeded_rng(seed);\n+        let rb = rand::seeded_rng(seed);\n+        assert ra.gen_str(100u) == rb.gen_str(100u);\n+    }\n+\n+    #[test]\n+    fn gen_int_range() {\n+        let r = rand::rng();\n+        let a = r.gen_int_range(-3, 42);\n+        assert a >= -3 && a < 42;\n+        assert r.gen_int_range(0, 1) == 0;\n+        assert r.gen_int_range(-12, -11) == -12;\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn gen_int_from_fail() {\n+        rand::rng().gen_int_range(5, -2);\n+    }\n+\n+    #[test]\n+    fn gen_uint_range() {\n+        let r = rand::rng();\n+        let a = r.gen_uint_range(3u, 42u);\n+        assert a >= 3u && a < 42u;\n+        assert r.gen_uint_range(0u, 1u) == 0u;\n+        assert r.gen_uint_range(12u, 13u) == 12u;\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn gen_uint_range_fail() {\n+        rand::rng().gen_uint_range(5u, 2u);\n+    }\n+\n+    #[test]\n+    fn gen_float() {\n+        let r = rand::rng();\n+        let a = r.gen_float();\n+        let b = r.gen_float();\n+        log(debug, (a, b));\n+    }\n+\n+    #[test]\n+    fn gen_weighted_bool() {\n+        let r = rand::rng();\n+        assert r.gen_weighted_bool(0u) == true;\n+        assert r.gen_weighted_bool(1u) == true;\n     }\n \n     #[test]\n-    fn genstr() {\n-        let r: rand::rng = rand::rng();\n+    fn gen_str() {\n+        let r = rand::rng();\n         log(debug, r.gen_str(10u));\n         log(debug, r.gen_str(10u));\n         log(debug, r.gen_str(10u));\n-        assert(str::len(r.gen_str(10u)) == 10u);\n-        assert(str::len(r.gen_str(16u)) == 16u);\n+        assert r.gen_str(0u).len() == 0u;\n+        assert r.gen_str(10u).len() == 10u;\n+        assert r.gen_str(16u).len() == 16u;\n+    }\n+\n+    #[test]\n+    fn gen_bytes() {\n+        let r = rand::rng();\n+        assert r.gen_bytes(0u).len() == 0u;\n+        assert r.gen_bytes(10u).len() == 10u;\n+        assert r.gen_bytes(16u).len() == 16u;\n+    }\n+\n+    #[test]\n+    fn choose() {\n+        let r = rand::rng();\n+        assert r.choose([1, 1, 1]) == 1;\n+    }\n+\n+    #[test]\n+    fn choose_option() {\n+        let r = rand::rng();\n+        assert r.choose_option([]) == none::<int>;\n+        assert r.choose_option([1, 1, 1]) == some(1);\n+    }\n+\n+    #[test]\n+    fn choose_weighted() {\n+        let r = rand::rng();\n+        assert r.choose_weighted([{weight: 1u, item: 42}]) == 42;\n+        assert r.choose_weighted([\n+            {weight: 0u, item: 42},\n+            {weight: 1u, item: 43}\n+        ]) == 43;\n+    }\n+\n+    #[test]\n+    fn choose_weighted_option() {\n+        let r = rand::rng();\n+        assert r.choose_weighted_option([{weight: 1u, item: 42}]) == some(42);\n+        assert r.choose_weighted_option([\n+            {weight: 0u, item: 42},\n+            {weight: 1u, item: 43}\n+        ]) == some(43);\n+        assert r.choose_weighted_option([]) == none::<int>;\n+    }\n+\n+    #[test]\n+    fn weighted_vec() {\n+        let r = rand::rng();\n+        let empty: [int] = [];\n+        assert r.weighted_vec([]) == empty;\n+        assert r.weighted_vec([\n+            {weight: 0u, item: 3u},\n+            {weight: 1u, item: 2u},\n+            {weight: 2u, item: 1u}\n+        ]) == [2u, 1u, 1u];\n+    }\n+\n+    #[test]\n+    fn shuffle() {\n+        let r = rand::rng();\n+        let empty: [int] = [];\n+        assert r.shuffle([]) == empty;\n+        assert r.shuffle([1, 1, 1]) == [1, 1, 1];\n     }\n }\n "}, {"sha": "05a5a17b2f7e78aa2bda95c0cd060bdd4b3b0e45", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -201,9 +201,8 @@ enum binop {\n     bitxor,\n     bitand,\n     bitor,\n-    lsl,\n-    lsr,\n-    asr,\n+    shl,\n+    shr,\n     eq,\n     lt,\n     le,"}, {"sha": "fbea5026b3c2fbe42fb096a1fa915bf15e1c36c5", "filename": "src/librustsyntax/ast_map.rs", "status": "renamed", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_map.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,13 +1,10 @@\n import std::map;\n import std::map::hashmap;\n-import syntax::ast::*;\n-import syntax::print::pprust;\n-import syntax::ast_util;\n-import middle::pat_util::*;\n-import syntax::ast_util::inlined_item_methods;\n-import syntax::{visit, codemap};\n-import driver::session::session;\n-import syntax::attr;\n+import ast::*;\n+import print::pprust;\n+import ast_util::path_to_ident;\n+import ast_util::inlined_item_methods;\n+import diagnostic::span_handler;\n \n enum path_elt { path_mod(str), path_name(str) }\n type path = [path_elt];\n@@ -59,7 +56,7 @@ enum a_ctor {\n \n type map = std::map::hashmap<node_id, ast_node>;\n type ctx = {map: map, mut path: path,\n-            mut local_id: uint, sess: session};\n+            mut local_id: uint, diag: span_handler};\n type vt = visit::vt<ctx>;\n \n fn extend(cx: ctx, elt: str) -> @path {\n@@ -79,19 +76,20 @@ fn mk_ast_map_visitor() -> vt {\n     });\n }\n \n-fn map_crate(sess: session, c: crate) -> map {\n+fn map_crate(diag: span_handler, c: crate) -> map {\n     let cx = {map: std::map::int_hash(),\n               mut path: [],\n               mut local_id: 0u,\n-              sess: sess};\n+              diag: diag};\n     visit::visit_crate(c, cx, mk_ast_map_visitor());\n     ret cx.map;\n }\n \n // Used for items loaded from external crate that are being inlined into this\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n-fn map_decoded_item(sess: session, map: map, path: path, ii: inlined_item) {\n+fn map_decoded_item(diag: span_handler,\n+                    map: map, path: path, ii: inlined_item) {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n     // starting from 0.  (In particular, I think these ids are only used in\n@@ -101,7 +99,7 @@ fn map_decoded_item(sess: session, map: map, path: path, ii: inlined_item) {\n     let cx = {map: map,\n               mut path: path,\n               mut local_id: 0u,\n-              sess: sess};\n+              diag: diag};\n     let v = mk_ast_map_visitor();\n \n     // methods get added to the AST map when their impl is visited.  Since we\n@@ -153,7 +151,7 @@ fn map_block(b: blk, cx: ctx, v: vt) {\n }\n \n fn number_pat(cx: ctx, pat: @pat) {\n-    pat_util::walk_pat(pat) {|p|\n+    ast_util::walk_pat(pat) {|p|\n         alt p.node {\n           pat_ident(_, _) {\n             cx.map.insert(p.id, node_local(cx.local_id));\n@@ -205,7 +203,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n       }\n       item_native_mod(nm) {\n         let abi = alt attr::native_abi(i.attrs) {\n-          either::left(msg) { cx.sess.span_fatal(i.span, msg); }\n+          either::left(msg) { cx.diag.span_fatal(i.span, msg); }\n           either::right(abi) { abi }\n         };\n         for nm.items.each {|nitem|", "previous_filename": "src/rustc/middle/ast_map.rs"}, {"sha": "55743f91713f58a81d566a1db3bffce061bcd8d4", "filename": "src/librustsyntax/ast_util.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_util.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -25,6 +25,8 @@ fn path_name(p: @path) -> str { path_name_i(p.idents) }\n \n fn path_name_i(idents: [ident]) -> str { str::connect(idents, \"::\") }\n \n+fn path_to_ident(p: @path) -> ident { vec::last(p.idents) }\n+\n fn local_def(id: node_id) -> def_id { {crate: local_crate, node: id} }\n \n pure fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n@@ -70,9 +72,8 @@ fn binop_to_str(op: binop) -> str {\n       bitxor { ret \"^\"; }\n       bitand { ret \"&\"; }\n       bitor { ret \"|\"; }\n-      lsl { ret \"<<\"; }\n-      lsr { ret \">>\"; }\n-      asr { ret \">>>\"; }\n+      shl { ret \"<<\"; }\n+      shr { ret \">>\"; }\n       eq { ret \"==\"; }\n       lt { ret \"<\"; }\n       le { ret \"<=\"; }\n@@ -88,9 +89,8 @@ pure fn lazy_binop(b: binop) -> bool {\n \n pure fn is_shift_binop(b: binop) -> bool {\n     alt b {\n-      lsl { true }\n-      lsr { true }\n-      asr { true }\n+      shl { true }\n+      shr { true }\n       _ { false }\n     }\n }\n@@ -351,7 +351,7 @@ fn operator_prec(op: ast::binop) -> uint {\n       mul | div | rem   { 12u }\n       // 'as' sits between here with 11\n       add | subtract    { 10u }\n-      lsl | lsr | asr   {  9u }\n+      shl | shr         {  9u }\n       bitand            {  8u }\n       bitxor            {  7u }\n       bitor             {  6u }\n@@ -528,6 +528,18 @@ pure fn is_item_impl(item: @ast::item) -> bool {\n     }\n }\n \n+fn walk_pat(pat: @pat, it: fn(@pat)) {\n+    it(pat);\n+    alt pat.node {\n+      pat_ident(pth, some(p)) { walk_pat(p, it); }\n+      pat_rec(fields, _) { for fields.each {|f| walk_pat(f.pat, it); } }\n+      pat_enum(_, some(s)) | pat_tup(s) { for s.each {|p| walk_pat(p, it); } }\n+      pat_box(s) | pat_uniq(s) { walk_pat(s, it); }\n+      pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _)\n+        | pat_enum(_, _) {}\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "64904d612ced92dbc379917d5c79e917ef7305af", "filename": "src/librustsyntax/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fdiagnostic.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -7,6 +7,7 @@ export level, fatal, error, warning, note;\n export span_handler, handler, mk_span_handler, mk_handler;\n export codemap_span_handler, codemap_handler;\n export ice_msg;\n+export expect;\n \n type emitter = fn@(cmsp: option<(codemap::codemap, span)>,\n                    msg: str, lvl: level);\n@@ -253,3 +254,11 @@ fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n         print_macro_backtrace(cm, ei.call_site);\n     }\n }\n+\n+fn expect<T: copy>(diag: span_handler,\n+                   opt: option<T>, msg: fn() -> str) -> T {\n+    alt opt {\n+       some(t) { t }\n+       none { diag.handler().bug(msg()); }\n+    }\n+}"}, {"sha": "dc632d6b6ac571fe0b47a1c47347a2e8b81aacda", "filename": "src/librustsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -235,7 +235,7 @@ impl helpers for ext_ctxt {\n     }\n \n     fn clone_folder() -> fold::ast_fold {\n-        fold::make_fold({\n+        fold::make_fold(@{\n             new_id: {|_id| self.next_id()}\n             with *fold::default_ast_fold()\n         })\n@@ -265,7 +265,7 @@ impl helpers for ext_ctxt {\n             }\n         }\n \n-        let fld = fold::make_fold({\n+        let fld = fold::make_fold(@{\n             new_span: repl_sp(_, ast_util::dummy_sp(), span)\n             with *fold::default_ast_fold()\n         });"}, {"sha": "90487e279565c1788a392ea4cc26ef72330459c5", "filename": "src/librustsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fexpand.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -130,11 +130,11 @@ fn expand_crate(parse_sess: parse::parse_sess,\n     let afp = default_ast_fold();\n     let cx: ext_ctxt = mk_ctxt(parse_sess, cfg);\n     let f_pre =\n-        {fold_expr: bind expand_expr(exts, cx, _, _, _, afp.fold_expr),\n-         fold_mod: bind expand_mod_items(exts, cx, _, _, afp.fold_mod),\n-         fold_item: bind expand_item(cx, _, _, afp.fold_item),\n-         new_span: bind new_span(cx, _)\n-            with *afp};\n+        @{fold_expr: bind expand_expr(exts, cx, _, _, _, afp.fold_expr),\n+          fold_mod: bind expand_mod_items(exts, cx, _, _, afp.fold_mod),\n+          fold_item: bind expand_item(cx, _, _, afp.fold_item),\n+          new_span: bind new_span(cx, _)\n+          with *afp};\n     let f = make_fold(f_pre);\n     let cm = parse_expr_from_source_str(\"<core-macros>\",\n                                         @core_macros(),"}, {"sha": "02d3c3d095b7e5c0b1522e87c08e3d2c04ce5da8", "filename": "src/librustsyntax/ext/qquote.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fqquote.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -278,11 +278,11 @@ fn replace<T>(node: T, repls: [fragment], ff: fn (ast_fold, T) -> T)\n     -> T\n {\n     let aft = default_ast_fold();\n-    let f_pre = {fold_expr: bind replace_expr(repls, _, _, _,\n-                                              aft.fold_expr),\n-                 fold_ty: bind replace_ty(repls, _, _, _,\n-                                          aft.fold_ty)\n-                 with *aft};\n+    let f_pre = @{fold_expr: bind replace_expr(repls, _, _, _,\n+                                               aft.fold_expr),\n+                  fold_ty: bind replace_ty(repls, _, _, _,\n+                                           aft.fold_ty)\n+                  with *aft};\n     ret ff(make_fold(f_pre), node);\n }\n fn fold_crate(f: ast_fold, &&n: @ast::crate) -> @ast::crate {"}, {"sha": "76b78cb2b86c394be8d8f5df7be2749696fb9d87", "filename": "src/librustsyntax/ext/simplext.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fsimplext.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -189,16 +189,17 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n     }\n     let afp = default_ast_fold();\n     let f_pre =\n-        {fold_ident: bind transcribe_ident(cx, b, idx_path, _, _),\n-         fold_path: bind transcribe_path(cx, b, idx_path, _, _),\n-         fold_expr:\n-             bind transcribe_expr(cx, b, idx_path, _, _, _, afp.fold_expr),\n-         fold_ty: bind transcribe_type(cx, b, idx_path, _, _, _, afp.fold_ty),\n-         fold_block:\n-             bind transcribe_block(cx, b, idx_path, _, _, _, afp.fold_block),\n-         map_exprs: bind transcribe_exprs(cx, b, idx_path, _, _),\n-         new_id: bind new_id(_, cx)\n-         with *afp};\n+        @{fold_ident: bind transcribe_ident(cx, b, idx_path, _, _),\n+          fold_path: bind transcribe_path(cx, b, idx_path, _, _),\n+          fold_expr:\n+              bind transcribe_expr(cx, b, idx_path, _, _, _, afp.fold_expr),\n+          fold_ty: bind transcribe_type(cx, b, idx_path,\n+                                        _, _, _, afp.fold_ty),\n+          fold_block:\n+              bind transcribe_block(cx, b, idx_path, _, _, _, afp.fold_block),\n+          map_exprs: bind transcribe_exprs(cx, b, idx_path, _, _),\n+          new_id: bind new_id(_, cx)\n+          with *afp};\n     let f = make_fold(f_pre);\n     let result = f.fold_expr(body);\n     ret result;\n@@ -247,8 +248,8 @@ fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n     // using fold is a hack: we want visit, but it doesn't hit idents ) :\n     // solve this with macros\n     let f_pre =\n-        {fold_ident: bind mark_ident(_, _, b, idents)\n-            with *default_ast_fold()};\n+        @{fold_ident: bind mark_ident(_, _, b, idents)\n+          with *default_ast_fold()};\n     let f = make_fold(f_pre);\n     f.fold_expr(e); // ignore result\n     for idents.each_key {|x| it(x); };"}, {"sha": "f98c9c173e9c14de202d277b6497c538379319e0", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 141, "deletions": 219, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -17,96 +17,67 @@ export fold_ty_param;\n export fold_ty_params;\n export fold_fn_decl;\n \n-type ast_fold = @mut a_f;\n+iface ast_fold {\n+    fn fold_crate(crate) -> crate;\n+    fn fold_crate_directive(&&@crate_directive) -> @crate_directive;\n+    fn fold_view_item(&&@view_item) -> @view_item;\n+    fn fold_native_item(&&@native_item) -> @native_item;\n+    fn fold_item(&&@item) -> @item;\n+    fn fold_class_item(&&@class_member) -> @class_member;\n+    fn fold_item_underscore(item_) -> item_;\n+    fn fold_method(&&@method) -> @method;\n+    fn fold_block(blk) -> blk;\n+    fn fold_stmt(&&@stmt) -> @stmt;\n+    fn fold_arm(arm) -> arm;\n+    fn fold_pat(&&@pat) -> @pat;\n+    fn fold_decl(&&@decl) -> @decl;\n+    fn fold_expr(&&@expr) -> @expr;\n+    fn fold_ty(&&@ty) -> @ty;\n+    fn fold_constr(&&@constr) -> @constr;\n+    fn fold_ty_constr(&&@ty_constr) -> @ty_constr;\n+    fn fold_mod(_mod) -> _mod;\n+    fn fold_native_mod(native_mod) -> native_mod;\n+    fn fold_variant(variant) -> variant;\n+    fn fold_ident(&&ident) -> ident;\n+    fn fold_path(&&@path) -> @path;\n+    fn fold_local(&&@local) -> @local;\n+    fn map_exprs(fn@(&&@expr) -> @expr, [@expr]) -> [@expr];\n+    fn new_id(node_id) -> node_id;\n+    fn new_span(span) -> span;\n+}\n \n // We may eventually want to be able to fold over type parameters, too\n \n-type ast_fold_precursor =\n+type ast_fold_precursor = @{\n     //unlike the others, item_ is non-trivial\n-    {fold_crate: fn@(crate_, span, ast_fold) -> (crate_, span),\n-     fold_crate_directive: fn@(crate_directive_, span,\n-                               ast_fold) -> (crate_directive_, span),\n-     fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n-     fold_native_item: fn@(&&@native_item, ast_fold) -> @native_item,\n-     fold_item: fn@(&&@item, ast_fold) -> @item,\n-     fold_class_item: fn@(&&@class_member, ast_fold) -> @class_member,\n-     fold_item_underscore: fn@(item_, ast_fold) -> item_,\n-     fold_method: fn@(&&@method, ast_fold) -> @method,\n-     fold_block: fn@(blk_, span, ast_fold) -> (blk_, span),\n-     fold_stmt: fn@(stmt_, span, ast_fold) -> (stmt_, span),\n-     fold_arm: fn@(arm, ast_fold) -> arm,\n-     fold_pat: fn@(pat_, span, ast_fold) -> (pat_, span),\n-     fold_decl: fn@(decl_, span, ast_fold) -> (decl_, span),\n-     fold_expr: fn@(expr_, span, ast_fold) -> (expr_, span),\n-     fold_ty: fn@(ty_, span, ast_fold) -> (ty_, span),\n-     fold_constr: fn@(ast::constr_, span, ast_fold) -> (constr_, span),\n-     fold_ty_constr: fn@(ast::ty_constr_, span, ast_fold)\n+    fold_crate: fn@(crate_, span, ast_fold) -> (crate_, span),\n+    fold_crate_directive: fn@(crate_directive_, span,\n+                              ast_fold) -> (crate_directive_, span),\n+    fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n+    fold_native_item: fn@(&&@native_item, ast_fold) -> @native_item,\n+    fold_item: fn@(&&@item, ast_fold) -> @item,\n+    fold_class_item: fn@(&&@class_member, ast_fold) -> @class_member,\n+    fold_item_underscore: fn@(item_, ast_fold) -> item_,\n+    fold_method: fn@(&&@method, ast_fold) -> @method,\n+    fold_block: fn@(blk_, span, ast_fold) -> (blk_, span),\n+    fold_stmt: fn@(stmt_, span, ast_fold) -> (stmt_, span),\n+    fold_arm: fn@(arm, ast_fold) -> arm,\n+    fold_pat: fn@(pat_, span, ast_fold) -> (pat_, span),\n+    fold_decl: fn@(decl_, span, ast_fold) -> (decl_, span),\n+    fold_expr: fn@(expr_, span, ast_fold) -> (expr_, span),\n+    fold_ty: fn@(ty_, span, ast_fold) -> (ty_, span),\n+    fold_constr: fn@(ast::constr_, span, ast_fold) -> (constr_, span),\n+    fold_ty_constr: fn@(ast::ty_constr_, span, ast_fold)\n         -> (ty_constr_, span),\n-     fold_mod: fn@(_mod, ast_fold) -> _mod,\n-     fold_native_mod: fn@(native_mod, ast_fold) -> native_mod,\n-     fold_variant: fn@(variant_, span, ast_fold) -> (variant_, span),\n-     fold_ident: fn@(&&ident, ast_fold) -> ident,\n-     fold_path: fn@(path, ast_fold) -> path,\n-     fold_local: fn@(local_, span, ast_fold) -> (local_, span),\n-     map_exprs: fn@(fn@(&&@expr) -> @expr, [@expr]) -> [@expr],\n-     new_id: fn@(node_id) -> node_id,\n-     new_span: fn@(span) -> span};\n-\n-type a_f =\n-    {fold_crate: fn@(crate) -> crate,\n-     fold_crate_directive: fn@(&&@crate_directive) -> @crate_directive,\n-     fold_view_item: fn@(&&@view_item) -> @view_item,\n-     fold_native_item: fn@(&&@native_item) -> @native_item,\n-     fold_item: fn@(&&@item) -> @item,\n-     fold_class_item: fn@(&&@class_member) -> @class_member,\n-     fold_item_underscore: fn@(item_) -> item_,\n-     fold_method: fn@(&&@method) -> @method,\n-     fold_block: fn@(blk) -> blk,\n-     fold_stmt: fn@(&&@stmt) -> @stmt,\n-     fold_arm: fn@(arm) -> arm,\n-     fold_pat: fn@(&&@pat) -> @pat,\n-     fold_decl: fn@(&&@decl) -> @decl,\n-     fold_expr: fn@(&&@expr) -> @expr,\n-     fold_ty: fn@(&&@ty) -> @ty,\n-     fold_constr: fn@(&&@constr) -> @constr,\n-     fold_ty_constr: fn@(&&@ty_constr) -> @ty_constr,\n-     fold_mod: fn@(_mod) -> _mod,\n-     fold_native_mod: fn@(native_mod) -> native_mod,\n-     fold_variant: fn@(variant) -> variant,\n-     fold_ident: fn@(&&ident) -> ident,\n-     fold_path: fn@(&&@path) -> @path,\n-     fold_local: fn@(&&@local) -> @local,\n-     map_exprs: fn@(fn@(&&@expr) -> @expr, [@expr]) -> [@expr],\n-     new_id: fn@(node_id) -> node_id,\n-     new_span: fn@(span) -> span};\n-\n-\n-//fn nf_dummy<T>(&T node) -> T { fail; }\n-fn nf_crate_dummy(_c: crate) -> crate { fail; }\n-fn nf_crate_directive_dummy(&&_c: @crate_directive) -> @crate_directive {\n-    fail;\n-}\n-fn nf_view_item_dummy(&&_v: @view_item) -> @view_item { fail; }\n-fn nf_native_item_dummy(&&_n: @native_item) -> @native_item { fail; }\n-fn nf_item_dummy(&&_i: @item) -> @item { fail; }\n-fn nf_class_item_dummy(&&_ci: @class_member) -> @class_member { fail; }\n-fn nf_item_underscore_dummy(_i: item_) -> item_ { fail; }\n-fn nf_method_dummy(&&_m: @method) -> @method { fail; }\n-fn nf_blk_dummy(_b: blk) -> blk { fail; }\n-fn nf_stmt_dummy(&&_s: @stmt) -> @stmt { fail; }\n-fn nf_arm_dummy(_a: arm) -> arm { fail; }\n-fn nf_pat_dummy(&&_p: @pat) -> @pat { fail; }\n-fn nf_decl_dummy(&&_d: @decl) -> @decl { fail; }\n-fn nf_expr_dummy(&&_e: @expr) -> @expr { fail; }\n-fn nf_ty_dummy(&&_t: @ty) -> @ty { fail; }\n-fn nf_constr_dummy(&&_c: @constr) -> @constr { fail; }\n-fn nf_ty_constr_dummy(&&_c: @ty_constr) -> @ty_constr { fail; }\n-fn nf_mod_dummy(_m: _mod) -> _mod { fail; }\n-fn nf_native_mod_dummy(_n: native_mod) -> native_mod { fail; }\n-fn nf_variant_dummy(_v: variant) -> variant { fail; }\n-fn nf_ident_dummy(&&_i: ident) -> ident { fail; }\n-fn nf_path_dummy(&&_p: @path) -> @path { fail; }\n-fn nf_local_dummy(&&_o: @local) -> @local { fail; }\n+    fold_mod: fn@(_mod, ast_fold) -> _mod,\n+    fold_native_mod: fn@(native_mod, ast_fold) -> native_mod,\n+    fold_variant: fn@(variant_, span, ast_fold) -> (variant_, span),\n+    fold_ident: fn@(&&ident, ast_fold) -> ident,\n+    fold_path: fn@(path, ast_fold) -> path,\n+    fold_local: fn@(local_, span, ast_fold) -> (local_, span),\n+    map_exprs: fn@(fn@(&&@expr) -> @expr, [@expr]) -> [@expr],\n+    new_id: fn@(node_id) -> node_id,\n+    new_span: fn@(span) -> span};\n \n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n@@ -604,8 +575,7 @@ fn noop_id(i: node_id) -> node_id { ret i; }\n \n fn noop_span(sp: span) -> span { ret sp; }\n \n-\n-fn default_ast_fold() -> @ast_fold_precursor {\n+fn default_ast_fold() -> ast_fold_precursor {\n     ret @{fold_crate: wrap(noop_fold_crate),\n           fold_crate_directive: wrap(noop_fold_crate_directive),\n           fold_view_item: noop_fold_view_item,\n@@ -634,177 +604,129 @@ fn default_ast_fold() -> @ast_fold_precursor {\n           new_span: noop_span};\n }\n \n-fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n-    // FIXME: Have to bind all the bare functions into shared functions\n-    // because @mut is invariant with respect to its contents\n-    // I assume this has something to do with Issue #1973 - tjc\n-    let result: ast_fold =\n-        @mut {fold_crate: bind nf_crate_dummy(_),\n-                  fold_crate_directive: bind nf_crate_directive_dummy(_),\n-                  fold_view_item: bind nf_view_item_dummy(_),\n-                  fold_native_item: bind nf_native_item_dummy(_),\n-                  fold_item: bind nf_item_dummy(_),\n-                  fold_class_item: bind nf_class_item_dummy(_),\n-                  fold_item_underscore: bind nf_item_underscore_dummy(_),\n-                  fold_method: bind nf_method_dummy(_),\n-                  fold_block: bind nf_blk_dummy(_),\n-                  fold_stmt: bind nf_stmt_dummy(_),\n-                  fold_arm: bind nf_arm_dummy(_),\n-                  fold_pat: bind nf_pat_dummy(_),\n-                  fold_decl: bind nf_decl_dummy(_),\n-                  fold_expr: bind nf_expr_dummy(_),\n-                  fold_ty: bind nf_ty_dummy(_),\n-                  fold_constr: bind nf_constr_dummy(_),\n-                  fold_ty_constr: bind nf_ty_constr_dummy(_),\n-                  fold_mod: bind nf_mod_dummy(_),\n-                  fold_native_mod: bind nf_native_mod_dummy(_),\n-                  fold_variant: bind nf_variant_dummy(_),\n-                  fold_ident: bind nf_ident_dummy(_),\n-                  fold_path: bind nf_path_dummy(_),\n-                  fold_local: bind nf_local_dummy(_),\n-                  map_exprs: bind noop_map_exprs(_, _),\n-                  new_id: bind noop_id(_),\n-                  new_span: bind noop_span(_)};\n-\n+impl of ast_fold for ast_fold_precursor {\n     /* naturally, a macro to write these would be nice */\n-    fn f_crate(afp: ast_fold_precursor, f: ast_fold, c: crate) -> crate {\n-        let (n, s) = afp.fold_crate(c.node, c.span, f);\n-        ret {node: n, span: afp.new_span(s)};\n+    fn fold_crate(c: crate) -> crate {\n+        let (n, s) = self.fold_crate(c.node, c.span, self as ast_fold);\n+        ret {node: n, span: self.new_span(s)};\n     }\n-    fn f_crate_directive(afp: ast_fold_precursor, f: ast_fold,\n-                         &&c: @crate_directive) -> @crate_directive {\n-        let (n, s) = afp.fold_crate_directive(c.node, c.span, f);\n+    fn fold_crate_directive(&&c: @crate_directive) -> @crate_directive {\n+        let (n, s) = self.fold_crate_directive(c.node, c.span,\n+                                               self as ast_fold);\n         ret @{node: n,\n-              span: afp.new_span(s)};\n+              span: self.new_span(s)};\n     }\n-    fn f_view_item(afp: ast_fold_precursor, f: ast_fold, &&x: @view_item) ->\n+    fn fold_view_item(&&x: @view_item) ->\n        @view_item {\n-        ret @{node: afp.fold_view_item(x.node, f),\n-              attrs: vec::map(x.attrs, {|a| fold_attribute_(a, f)}),\n+        ret @{node: self.fold_view_item(x.node, self as ast_fold),\n+              attrs: vec::map(x.attrs, {|a|\n+                  fold_attribute_(a, self as ast_fold)}),\n               vis: x.vis,\n-              span: afp.new_span(x.span)};\n+              span: self.new_span(x.span)};\n     }\n-    fn f_native_item(afp: ast_fold_precursor, f: ast_fold, &&x: @native_item)\n+    fn fold_native_item(&&x: @native_item)\n         -> @native_item {\n-        ret afp.fold_native_item(x, f);\n+        ret self.fold_native_item(x, self as ast_fold);\n     }\n-    fn f_item(afp: ast_fold_precursor, f: ast_fold, &&i: @item) -> @item {\n-        ret afp.fold_item(i, f);\n+    fn fold_item(&&i: @item) -> @item {\n+        ret self.fold_item(i, self as ast_fold);\n     }\n-    fn f_class_item(afp: ast_fold_precursor, f: ast_fold,\n-                      &&ci: @class_member) -> @class_member {\n+    fn fold_class_item(&&ci: @class_member) -> @class_member {\n         @{node: alt ci.node {\n            instance_var(nm, t, mt, id, p) {\n-               instance_var(nm, f_ty(afp, f, t),\n+               instance_var(nm, (self as ast_fold).fold_ty(t),\n                             mt, id, p)\n            }\n            class_method(m) {\n-               class_method(afp.fold_method(m, f))\n+               class_method(self.fold_method(m, self as ast_fold))\n            }\n-          }, span: afp.new_span(ci.span)}\n+          }, span: self.new_span(ci.span)}\n     }\n-    fn f_item_underscore(afp: ast_fold_precursor, f: ast_fold, i: item_) ->\n+    fn fold_item_underscore(i: item_) ->\n        item_ {\n-        ret afp.fold_item_underscore(i, f);\n+        ret self.fold_item_underscore(i, self as ast_fold);\n     }\n-    fn f_method(afp: ast_fold_precursor, f: ast_fold, &&x: @method)\n+    fn fold_method(&&x: @method)\n         -> @method {\n-        ret afp.fold_method(x, f);\n+        ret self.fold_method(x, self as ast_fold);\n     }\n-    fn f_block(afp: ast_fold_precursor, f: ast_fold, x: blk) -> blk {\n-        let (n, s) = afp.fold_block(x.node, x.span, f);\n-        ret {node: n, span: afp.new_span(s)};\n+    fn fold_block(x: blk) -> blk {\n+        let (n, s) = self.fold_block(x.node, x.span, self as ast_fold);\n+        ret {node: n, span: self.new_span(s)};\n     }\n-    fn f_stmt(afp: ast_fold_precursor, f: ast_fold, &&x: @stmt) -> @stmt {\n-        let (n, s) = afp.fold_stmt(x.node, x.span, f);\n-        ret @{node: n, span: afp.new_span(s)};\n+    fn fold_stmt(&&x: @stmt) -> @stmt {\n+        let (n, s) = self.fold_stmt(x.node, x.span, self as ast_fold);\n+        ret @{node: n, span: self.new_span(s)};\n     }\n-    fn f_arm(afp: ast_fold_precursor, f: ast_fold, x: arm) -> arm {\n-        ret afp.fold_arm(x, f);\n+    fn fold_arm(x: arm) -> arm {\n+        ret self.fold_arm(x, self as ast_fold);\n     }\n-    fn f_pat(afp: ast_fold_precursor, f: ast_fold, &&x: @pat) -> @pat {\n-        let (n, s) =  afp.fold_pat(x.node, x.span, f);\n-        ret @{id: afp.new_id(x.id),\n+    fn fold_pat(&&x: @pat) -> @pat {\n+        let (n, s) =  self.fold_pat(x.node, x.span, self as ast_fold);\n+        ret @{id: self.new_id(x.id),\n               node: n,\n-              span: afp.new_span(s)};\n+              span: self.new_span(s)};\n     }\n-    fn f_decl(afp: ast_fold_precursor, f: ast_fold, &&x: @decl) -> @decl {\n-        let (n, s) = afp.fold_decl(x.node, x.span, f);\n-        ret @{node: n, span: afp.new_span(s)};\n+    fn fold_decl(&&x: @decl) -> @decl {\n+        let (n, s) = self.fold_decl(x.node, x.span, self as ast_fold);\n+        ret @{node: n, span: self.new_span(s)};\n     }\n-    fn f_expr(afp: ast_fold_precursor, f: ast_fold, &&x: @expr) -> @expr {\n-        let (n, s) = afp.fold_expr(x.node, x.span, f);\n-        ret @{id: afp.new_id(x.id),\n+    fn fold_expr(&&x: @expr) -> @expr {\n+        let (n, s) = self.fold_expr(x.node, x.span, self as ast_fold);\n+        ret @{id: self.new_id(x.id),\n               node: n,\n-              span: afp.new_span(s)};\n+              span: self.new_span(s)};\n     }\n-    fn f_ty(afp: ast_fold_precursor, f: ast_fold, &&x: @ty) -> @ty {\n-        let (n, s) = afp.fold_ty(x.node, x.span, f);\n-        ret @{id: afp.new_id(x.id), node: n, span: afp.new_span(s)};\n+    fn fold_ty(&&x: @ty) -> @ty {\n+        let (n, s) = self.fold_ty(x.node, x.span, self as ast_fold);\n+        ret @{id: self.new_id(x.id), node: n, span: self.new_span(s)};\n     }\n-    fn f_constr(afp: ast_fold_precursor, f: ast_fold, &&x: @ast::constr) ->\n+    fn fold_constr(&&x: @ast::constr) ->\n        @ast::constr {\n-        let (n, s) = afp.fold_constr(x.node, x.span, f);\n-        ret @{node: n, span: afp.new_span(s)};\n+        let (n, s) = self.fold_constr(x.node, x.span, self as ast_fold);\n+        ret @{node: n, span: self.new_span(s)};\n     }\n-    fn f_ty_constr(afp: ast_fold_precursor, f: ast_fold,\n-                   &&x: @ast::ty_constr) ->\n+    fn fold_ty_constr(&&x: @ast::ty_constr) ->\n        @ast::ty_constr {\n         let (n, s) : (ty_constr_, span) =\n-            afp.fold_ty_constr(x.node, x.span, f);\n-        ret @{node: n, span: afp.new_span(s)};\n+            self.fold_ty_constr(x.node, x.span, self as ast_fold);\n+        ret @{node: n, span: self.new_span(s)};\n     }\n-    fn f_mod(afp: ast_fold_precursor, f: ast_fold, x: _mod) -> _mod {\n-        ret afp.fold_mod(x, f);\n+    fn fold_mod(x: _mod) -> _mod {\n+        ret self.fold_mod(x, self as ast_fold);\n     }\n-    fn f_native_mod(afp: ast_fold_precursor, f: ast_fold, x: native_mod) ->\n+    fn fold_native_mod(x: native_mod) ->\n        native_mod {\n-        ret afp.fold_native_mod(x, f);\n+        ret self.fold_native_mod(x, self as ast_fold);\n     }\n-    fn f_variant(afp: ast_fold_precursor, f: ast_fold, x: variant) ->\n+    fn fold_variant(x: variant) ->\n        variant {\n-        let (n, s) = afp.fold_variant(x.node, x.span, f);\n-        ret {node: n, span: afp.new_span(s)};\n-    }\n-    fn f_ident(afp: ast_fold_precursor, f: ast_fold, &&x: ident) -> ident {\n-        ret afp.fold_ident(x, f);\n-    }\n-    fn f_path(afp: ast_fold_precursor, f: ast_fold, &&x: @path) -> @path {\n-        @afp.fold_path(*x, f)\n-    }\n-    fn f_local(afp: ast_fold_precursor, f: ast_fold, &&x: @local) -> @local {\n-        let (n, s) = afp.fold_local(x.node, x.span, f);\n-        ret @{node: n, span: afp.new_span(s)};\n-    }\n-\n-    *result =\n-        {fold_crate: bind f_crate(afp, result, _),\n-         fold_crate_directive: bind f_crate_directive(afp, result, _),\n-         fold_view_item: bind f_view_item(afp, result, _),\n-         fold_native_item: bind f_native_item(afp, result, _),\n-         fold_item: bind f_item(afp, result, _),\n-         fold_class_item: bind f_class_item(afp, result, _),\n-         fold_item_underscore: bind f_item_underscore(afp, result, _),\n-         fold_method: bind f_method(afp, result, _),\n-         fold_block: bind f_block(afp, result, _),\n-         fold_stmt: bind f_stmt(afp, result, _),\n-         fold_arm: bind f_arm(afp, result, _),\n-         fold_pat: bind f_pat(afp, result, _),\n-         fold_decl: bind f_decl(afp, result, _),\n-         fold_expr: bind f_expr(afp, result, _),\n-         fold_ty: bind f_ty(afp, result, _),\n-         fold_constr: bind f_constr(afp, result, _),\n-         fold_ty_constr: bind f_ty_constr(afp, result, _),\n-         fold_mod: bind f_mod(afp, result, _),\n-         fold_native_mod: bind f_native_mod(afp, result, _),\n-         fold_variant: bind f_variant(afp, result, _),\n-         fold_ident: bind f_ident(afp, result, _),\n-         fold_path: bind f_path(afp, result, _),\n-         fold_local: bind f_local(afp, result, _),\n-         map_exprs: afp.map_exprs,\n-         new_id: afp.new_id,\n-         new_span: afp.new_span};\n-    ret result;\n+        let (n, s) = self.fold_variant(x.node, x.span, self as ast_fold);\n+        ret {node: n, span: self.new_span(s)};\n+    }\n+    fn fold_ident(&&x: ident) -> ident {\n+        ret self.fold_ident(x, self as ast_fold);\n+    }\n+    fn fold_path(&&x: @path) -> @path {\n+        @self.fold_path(*x, self as ast_fold)\n+    }\n+    fn fold_local(&&x: @local) -> @local {\n+        let (n, s) = self.fold_local(x.node, x.span, self as ast_fold);\n+        ret @{node: n, span: self.new_span(s)};\n+    }\n+    fn map_exprs(f: fn@(&&@expr) -> @expr, e: [@expr]) -> [@expr] {\n+        self.map_exprs(f, e)\n+    }\n+    fn new_id(node_id: ast::node_id) -> node_id {\n+        self.new_id(node_id)\n+    }\n+    fn new_span(span: span) -> span {\n+        self.new_span(span)\n+    }\n+}\n+\n+fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n+    afp as ast_fold\n }\n \n //"}, {"sha": "a4d30cf2627ac773a82481576f6f39fe757476fe", "filename": "src/librustsyntax/parse/common.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fcommon.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -114,10 +114,8 @@ fn check_restricted_keywords_(p: parser, w: ast::ident) {\n fn expect_gt(p: parser) {\n     if p.token == token::GT {\n         p.bump();\n-    } else if p.token == token::BINOP(token::LSR) {\n+    } else if p.token == token::BINOP(token::SHR) {\n         p.swap(token::GT, p.span.lo + 1u, p.span.hi);\n-    } else if p.token == token::BINOP(token::ASR) {\n-        p.swap(token::BINOP(token::LSR), p.span.lo + 1u, p.span.hi);\n     } else {\n         let mut s: str = \"expecting \";\n         s += token_to_str(p.reader, token::GT);\n@@ -132,8 +130,7 @@ fn parse_seq_to_before_gt<T: copy>(sep: option<token::token>,\n                                   p: parser) -> [T] {\n     let mut first = true;\n     let mut v = [];\n-    while p.token != token::GT && p.token != token::BINOP(token::LSR) &&\n-              p.token != token::BINOP(token::ASR) {\n+    while p.token != token::GT && p.token != token::BINOP(token::SHR) {\n         alt sep {\n           some(t) { if first { first = false; } else { expect(p, t); } }\n           _ { }"}, {"sha": "b95b10fc33e80515b5f858253e3461f8d8ae9f26", "filename": "src/librustsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Flexer.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -402,7 +402,7 @@ fn next_token_inner(rdr: reader) -> token::token {\n         rdr.bump();\n         alt rdr.curr {\n           '=' { rdr.bump(); ret token::LE; }\n-          '<' { ret binop(rdr, token::LSL); }\n+          '<' { ret binop(rdr, token::SHL); }\n           '-' {\n             rdr.bump();\n             alt rdr.curr {\n@@ -417,12 +417,7 @@ fn next_token_inner(rdr: reader) -> token::token {\n         rdr.bump();\n         alt rdr.curr {\n           '=' { rdr.bump(); ret token::GE; }\n-          '>' {\n-            if rdr.next() == '>' {\n-                rdr.bump();\n-                ret binop(rdr, token::ASR);\n-            } else { ret binop(rdr, token::LSR); }\n-          }\n+          '>' { ret binop(rdr, token::SHR); }\n           _ { ret token::GT; }\n         }\n       }"}, {"sha": "bf55ebf43c660714c3c6f54223d1a0a3b64b6076", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1119,9 +1119,8 @@ fn parse_assign_expr(p: parser) -> @expr {\n           token::CARET { aop = bitxor; }\n           token::AND { aop = bitand; }\n           token::OR { aop = bitor; }\n-          token::LSL { aop = lsl; }\n-          token::LSR { aop = lsr; }\n-          token::ASR { aop = asr; }\n+          token::SHL { aop = shl; }\n+          token::SHR { aop = shr; }\n         }\n         p.get_id(); // see ast_util::op_expr_callee_id\n         ret mk_expr(p, lo, rhs.span.hi, expr_assign_op(aop, lhs, rhs));"}, {"sha": "e2e35447af3f49070bb48fb86e4121fc37e1bc41", "filename": "src/librustsyntax/parse/prec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fparse%2Fprec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fparse%2Fprec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fprec.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -25,9 +25,8 @@ fn token_to_binop(tok: token) -> option<ast::binop> {\n       // 'as' sits between here with 11\n       BINOP(PLUS)    { some(add) }\n       BINOP(MINUS)   { some(subtract) }\n-      BINOP(LSL)     { some(lsl) }\n-      BINOP(LSR)     { some(lsr) }\n-      BINOP(ASR)     { some(asr) }\n+      BINOP(SHL)     { some(shl) }\n+      BINOP(SHR)     { some(shr) }\n       BINOP(AND)     { some(bitand) }\n       BINOP(CARET)   { some(bitxor) }\n       BINOP(OR)      { some(bitor) }"}, {"sha": "1c6f240cf82009c0e7dfc836f9e7a8b3f3dc8910", "filename": "src/librustsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Ftoken.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -14,9 +14,8 @@ enum binop {\n     CARET,\n     AND,\n     OR,\n-    LSL,\n-    LSR,\n-    ASR,\n+    SHL,\n+    SHR,\n }\n \n enum token {\n@@ -78,9 +77,8 @@ fn binop_to_str(o: binop) -> str {\n       CARET { ret \"^\"; }\n       AND { ret \"&\"; }\n       OR { ret \"|\"; }\n-      LSL { ret \"<<\"; }\n-      LSR { ret \">>\"; }\n-      ASR { ret \">>>\"; }\n+      SHL { ret \"<<\"; }\n+      SHR { ret \">>\"; }\n     }\n }\n \n@@ -261,7 +259,7 @@ fn restricted_keyword_table() -> hashmap<str, ()> {\n         \"assert\",\n         \"be\", \"break\",\n         \"check\", \"claim\", \"class\", \"const\", \"cont\", \"copy\", \"crust\",\n-        \"do\", \"drop\",\n+        \"drop\",\n         \"else\", \"enum\", \"export\",\n         \"fail\", \"false\", \"fn\", \"for\",\n         \"if\", \"iface\", \"impl\", \"import\","}, {"sha": "eeb2d31d6a3c943f55d5044edb0dfadde9834b6a", "filename": "src/librustsyntax/rustsyntax.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Frustsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibrustsyntax%2Frustsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Frustsyntax.rc?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -16,6 +16,7 @@ mod diagnostic;\n mod codemap;\n mod ast;\n mod ast_util;\n+mod ast_map;\n mod visit;\n mod fold;\n mod util {"}, {"sha": "998fc55afe8b346cce94e6753925391daffd5270", "filename": "src/libstd/map.rs", "status": "modified", "additions": 134, "deletions": 146, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -69,6 +69,8 @@ iface map<K: copy, V: copy> {\n // FIXME: package this up and export it as a datatype usable for\n // external code that doesn't want to pay the cost of a box. (#2344)\n mod chained {\n+    export t, mk, hashmap;\n+\n     type entry<K, V> = {\n         hash: uint,\n         key: K,\n@@ -94,186 +96,172 @@ mod chained {\n         found_after(@entry<K,V>, @entry<K,V>)\n     }\n \n-    fn search_rem<K: copy, V: copy>(\n-        tbl: t<K,V>, k: K, h: uint, idx: uint,\n-        e_root: @entry<K,V>) -> search_result<K,V> {\n-        let mut e0 = e_root;\n-        let mut comp = 1u;   // for logging\n-        loop {\n-            alt e0.next {\n+    impl private_methods<K: copy, V: copy> for t<K, V> {\n+        fn search_rem(k: K, h: uint, idx: uint,\n+                      e_root: @entry<K,V>) -> search_result<K,V> {\n+            let mut e0 = e_root;\n+            let mut comp = 1u;   // for logging\n+            loop {\n+                alt e0.next {\n+                  absent {\n+                    #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n+                           comp, h, idx);\n+                    ret not_found;\n+                  }\n+                  present(e1) {\n+                    comp += 1u;\n+                    let e1_key = e1.key; // Satisfy alias checker.\n+                    if e1.hash == h && self.eqer(e1_key, k) {\n+                        #debug(\"search_tbl: present, comp %u, \\\n+                                hash %u, idx %u\",\n+                               comp, h, idx);\n+                        ret found_after(e0, e1);\n+                    } else {\n+                        e0 = e1;\n+                    }\n+                  }\n+                }\n+            };\n+        }\n+\n+        fn search_tbl(k: K, h: uint) -> search_result<K,V> {\n+            let idx = h % vec::len(self.chains);\n+            alt self.chains[idx] {\n               absent {\n                 #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n-                       comp, h, idx);\n+                       0u, h, idx);\n                 ret not_found;\n               }\n-              present(e1) {\n-                comp += 1u;\n-                let e1_key = e1.key; // Satisfy alias checker.\n-                if e1.hash == h && tbl.eqer(e1_key, k) {\n+              present(e) {\n+                // FIXME: This copy of the key is not good for perf\n+                if e.hash == h && self.eqer(copy e.key, k) {\n                     #debug(\"search_tbl: present, comp %u, hash %u, idx %u\",\n-                           comp, h, idx);\n-                    ret found_after(e0, e1);\n+                           1u, h, idx);\n+                    ret found_first(idx, e);\n                 } else {\n-                    e0 = e1;\n+                    ret self.search_rem(k, h, idx, e);\n                 }\n               }\n             }\n-        };\n-    }\n-\n-    fn search_tbl<K: copy, V: copy>(\n-        tbl: t<K,V>, k: K, h: uint) -> search_result<K,V> {\n-        let idx = h % vec::len(tbl.chains);\n-        alt tbl.chains[idx] {\n-          absent {\n-            #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n-                   0u, h, idx);\n-            ret not_found;\n-          }\n-          present(e) {\n-            // FIXME: This copy of the key is not good for perf\n-            if e.hash == h && tbl.eqer(copy e.key, k) {\n-                #debug(\"search_tbl: present, comp %u, hash %u, idx %u\",\n-                       1u, h, idx);\n-                ret found_first(idx, e);\n-            } else {\n-                ret search_rem(tbl, k, h, idx, e);\n-            }\n-          }\n         }\n-    }\n \n-    fn insert<K: copy, V: copy>(tbl: t<K,V>, k: K, v: V) -> bool {\n-        let hash = tbl.hasher(k);\n-        alt search_tbl(tbl, k, hash) {\n-          not_found {\n-            tbl.count += 1u;\n-            let idx = hash % vec::len(tbl.chains);\n-            let old_chain = tbl.chains[idx];\n-            tbl.chains[idx] = present(@{\n-                hash: hash,\n-                key: k,\n-                mut value: v,\n-                mut next: old_chain});\n-            ret true;\n-          }\n-          found_first(_, entry) {\n-            entry.value = v;\n-            ret false;\n-          }\n-          found_after(_, entry) {\n-            entry.value = v;\n-            ret false\n-          }\n-        }\n-    }\n-\n-    fn get<K: copy, V: copy>(tbl: t<K,V>, k: K) -> core::option<V> {\n-        alt search_tbl(tbl, k, tbl.hasher(k)) {\n-          not_found {\n-            ret core::option::none;\n-          }\n-\n-          found_first(_, entry) {\n-            ret core::option::some(entry.value);\n-          }\n-\n-          found_after(_, entry) {\n-            ret core::option::some(entry.value);\n-          }\n-        }\n-    }\n-\n-    fn remove<K: copy, V: copy>(tbl: t<K,V>, k: K) -> core::option<V> {\n-        alt search_tbl(tbl, k, tbl.hasher(k)) {\n-          not_found {\n-            ret core::option::none;\n-          }\n-\n-          found_first(idx, entry) {\n-            tbl.count -= 1u;\n-            tbl.chains[idx] = entry.next;\n-            ret core::option::some(entry.value);\n-          }\n-\n-          found_after(eprev, entry) {\n-            tbl.count -= 1u;\n-            eprev.next = entry.next;\n-            ret core::option::some(entry.value);\n-          }\n+        fn rehash() {\n+            let n_old_chains = vec::len(self.chains);\n+            let n_new_chains: uint = uint::next_power_of_two(n_old_chains+1u);\n+            let new_chains = chains(n_new_chains);\n+            for self.each_entry {|entry|\n+                let idx = entry.hash % n_new_chains;\n+                entry.next = new_chains[idx];\n+                new_chains[idx] = present(entry);\n+            }\n+            self.chains = new_chains;\n         }\n-    }\n-\n-    fn chains<K: copy, V: copy>(nchains: uint) -> [mut chain<K,V>] {\n-        ret vec::to_mut(vec::from_elem(nchains, absent));\n-    }\n \n-    fn each_entry<K: copy, V: copy>(tbl: t<K, V>,\n-                                    blk: fn(@entry<K,V>) -> bool) {\n-        let mut i = 0u, n = vec::len(tbl.chains);\n-        while i < n {\n-            let mut chain = tbl.chains[i];\n-            loop {\n-                chain = alt chain {\n-                  absent { break; }\n-                  present(entry) {\n-                    let next = entry.next;\n-                    if !blk(entry) { ret; }\n-                    next\n-                  }\n+        fn each_entry(blk: fn(@entry<K,V>) -> bool) {\n+            let mut i = 0u, n = vec::len(self.chains);\n+            while i < n {\n+                let mut chain = self.chains[i];\n+                loop {\n+                    chain = alt chain {\n+                      absent { break; }\n+                      present(entry) {\n+                        let next = entry.next;\n+                        if !blk(entry) { ret; }\n+                        next\n+                      }\n+                    }\n                 }\n+                i += 1u;\n             }\n-            i += 1u;\n-        }\n-    }\n-\n-    fn rehash<K: copy, V: copy>(tbl: t<K,V>) {\n-        let n_old_chains = vec::len(tbl.chains);\n-        let n_new_chains: uint = uint::next_power_of_two(n_old_chains + 1u);\n-        let new_chains = chains(n_new_chains);\n-        for each_entry(tbl) {|entry|\n-            let idx = entry.hash % n_new_chains;\n-            entry.next = new_chains[idx];\n-            new_chains[idx] = present(entry);\n-        }\n-        tbl.chains = new_chains;\n-    }\n-\n-    fn each<K: copy, V: copy>(tbl: t<K,V>, blk: fn(K,V) -> bool) {\n-        for each_entry(tbl) {|entry|\n-            if !blk(copy entry.key, copy entry.value) { break; }\n         }\n     }\n \n     impl hashmap<K: copy, V: copy> of map<K, V> for t<K, V> {\n         fn size() -> uint { self.count }\n \n+        fn contains_key(k: K) -> bool {\n+            let hash = self.hasher(k);\n+            alt self.search_tbl(k, hash) {\n+              not_found {false}\n+              found_first(*) | found_after(*) {true}\n+            }\n+        }\n+\n         fn insert(k: K, v: V) -> bool {\n-            let grew = insert(self, k, v);\n-            if grew {\n+            let hash = self.hasher(k);\n+            alt self.search_tbl(k, hash) {\n+              not_found {\n+                self.count += 1u;\n+                let idx = hash % vec::len(self.chains);\n+                let old_chain = self.chains[idx];\n+                self.chains[idx] = present(@{\n+                    hash: hash,\n+                    key: k,\n+                    mut value: v,\n+                    mut next: old_chain});\n+\n+                // consider rehashing if more 3/4 full\n                 let nchains = vec::len(self.chains);\n                 let load = {num: (self.count + 1u) as int,\n                             den: nchains as int};\n-                // Structural consts would be nice. This is a const 3/4\n-                // load factor that we compare against.\n-                if !util::rational_leq(load, {num:3, den:4}) { rehash(self); }\n+                if !util::rational_leq(load, {num:3, den:4}) {\n+                    self.rehash();\n+                }\n+\n+                ret true;\n+              }\n+              found_first(_, entry) {\n+                entry.value = v;\n+                ret false;\n+              }\n+              found_after(_, entry) {\n+                entry.value = v;\n+                ret false\n+              }\n             }\n-            grew\n         }\n \n-        fn contains_key(k: K) -> bool { option::is_some(get(self, k)) }\n+        fn find(k: K) -> option<V> {\n+            alt self.search_tbl(k, self.hasher(k)) {\n+              not_found {none}\n+              found_first(_, entry) {some(entry.value)}\n+              found_after(_, entry) {some(entry.value)}\n+            }\n+        }\n \n-        fn get(k: K) -> V { option::get(get(self, k)) }\n+        fn get(k: K) -> V {\n+            option::get(self.find(k))\n+        }\n \n-        fn find(k: K) -> option<V> { get(self, k) }\n+        fn remove(k: K) -> option<V> {\n+            alt self.search_tbl(k, self.hasher(k)) {\n+              not_found {none}\n+              found_first(idx, entry) {\n+                self.count -= 1u;\n+                self.chains[idx] = entry.next;\n+                some(entry.value)\n+              }\n+              found_after(eprev, entry) {\n+                self.count -= 1u;\n+                eprev.next = entry.next;\n+                some(entry.value)\n+              }\n+            }\n+        }\n \n-        fn remove(k: K) -> option<V> { remove(self, k) }\n+        fn each(blk: fn(K,V) -> bool) {\n+            for self.each_entry { |entry|\n+                if !blk(copy entry.key, copy entry.value) { break; }\n+            }\n+        }\n \n-        fn each(blk: fn(K, V) -> bool) { each(self, blk); }\n+        fn each_key(blk: fn(K) -> bool) { self.each { |k, _v| blk(k)} }\n \n-        fn each_key(blk: fn(K) -> bool) { each(self) { |k, _v| blk(k)} }\n+        fn each_value(blk: fn(V) -> bool) { self.each { |_k, v| blk(v)} }\n+    }\n \n-        fn each_value(blk: fn(V) -> bool) { each(self) { |_k, v| blk(v)} }\n+    fn chains<K,V>(nchains: uint) -> [mut chain<K,V>] {\n+        ret vec::to_mut(vec::from_elem(nchains, absent));\n     }\n \n     fn mk<K: copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>) -> t<K,V> {"}, {"sha": "3f62c6764ed229d8a22d74073bdf7bd3b80fafcf", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,7 +1,7 @@\n #[doc =\"\n An implementation of the SHA-1 cryptographic hash.\n \n-First create a `sha1` object using the `mk_sha1` constructor, then\n+First create a `sha1` object using the `sha1` constructor, then\n feed it input using the `input` or `input_str` methods, which may be\n called any number of times.\n "}, {"sha": "2c7902c63e9d9bf2f7d21265d30f76a45b553bce", "filename": "src/libstd/time.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -7,6 +7,7 @@ export\n     get_time,\n     precise_time_ns,\n     precise_time_s,\n+    tzset,\n     tm,\n     empty_tm,\n     now,\n@@ -20,6 +21,7 @@ native mod rustrt {\n     fn get_time(&sec: i64, &nsec: i32);\n     fn precise_time_ns(&ns: u64);\n \n+    fn rust_tzset();\n     // FIXME: The i64 values can be passed by-val when #2064 is fixed.\n     fn rust_gmtime(&&sec: i64, &&nsec: i32, &&result: tm);\n     fn rust_localtime(&&sec: i64, &&nsec: i32, &&result: tm);\n@@ -59,6 +61,10 @@ fn precise_time_s() -> float {\n     ret (precise_time_ns() as float) / 1000000000.;\n }\n \n+fn tzset() {\n+    rustrt::rust_tzset();\n+}\n+\n type tm = {\n     tm_sec: i32, // seconds after the minute [0-60]\n     tm_min: i32, // minutes after the hour [0-59]\n@@ -869,6 +875,7 @@ mod tests {\n     #[test]\n     fn test_at_utc() {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        tzset();\n \n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n         let utc = at_utc(time);\n@@ -890,10 +897,13 @@ mod tests {\n     #[test]\n     fn test_at() {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        tzset();\n \n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n         let local = at(time);\n \n+        #error(\"time_at: %?\", local);\n+\n         assert local.tm_sec == 30_i32;\n         assert local.tm_min == 31_i32;\n         assert local.tm_hour == 15_i32;\n@@ -916,6 +926,7 @@ mod tests {\n     #[test]\n     fn test_to_timespec() {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        tzset();\n \n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n         let utc = at_utc(time);\n@@ -927,6 +938,7 @@ mod tests {\n     #[test]\n     fn test_conversions() {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        tzset();\n \n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n         let utc = at_utc(time);\n@@ -943,6 +955,7 @@ mod tests {\n     #[test]\n     fn test_strptime() {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        tzset();\n \n         alt strptime(\"\", \"\") {\n           ok(tm) {\n@@ -1088,18 +1101,22 @@ mod tests {\n     #[test]\n     fn test_ctime() {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        tzset();\n \n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n         let utc   = at_utc(time);\n         let local = at(time);\n \n+        #error(\"test_ctime: %? %?\", utc.ctime(), local.ctime());\n+\n         assert utc.ctime()   == \"Fri Feb 13 23:31:30 2009\";\n         assert local.ctime() == \"Fri Feb 13 15:31:30 2009\";\n     }\n \n     #[test]\n     fn test_strftime() {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        tzset();\n \n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n         let utc = at_utc(time);"}, {"sha": "cf2c10aa998d19c80eb405b681c5f9cb85a9442a", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -20,7 +20,7 @@ for *at least* that period of time.\n * ch - a channel of type T to send a `val` on\n * val - a value of type T to send over the provided `ch`\n \"]\n-fn delayed_send<T: send>(msecs: uint, ch: comm::chan<T>, val: T) {\n+fn delayed_send<T: copy send>(msecs: uint, ch: comm::chan<T>, val: T) {\n     task::spawn() {||\n         unsafe {\n             let timer_done_po = comm::port::<()>();\n@@ -94,7 +94,9 @@ An `option<T>` representing the outcome of the call. If the call `recv`'d on\n the provided port in the allotted timeout period, then the result will be a\n `some(T)`. If not, then `none` will be returned.\n \"]\n-fn recv_timeout<T: send>(msecs: uint, wait_po: comm::port<T>) -> option<T> {\n+fn recv_timeout<T: copy send>(msecs: uint, wait_po: comm::port<T>)\n+    -> option<T> {\n+\n     let timeout_po = comm::port::<()>();\n     let timeout_ch = comm::chan(timeout_po);\n     delayed_send(msecs, timeout_ch, ());\n@@ -182,40 +184,58 @@ mod test {\n         }\n     }\n \n+    // Because valgrind serializes multithreaded programs it can\n+    // make timing-sensitive tests fail in wierd ways. In these\n+    // next test we run them many times and expect them to pass\n+    // the majority of tries.\n+\n     #[test]\n     fn test_gl_timer_recv_timeout_before_time_passes() {\n-        let expected = rand::rng().gen_str(16u);\n-        let test_po = comm::port::<str>();\n-        let test_ch = comm::chan(test_po);\n+        let times = 100;\n+        let mut successes = 0;\n+        let mut failures = 0;\n \n-        task::spawn() {||\n-            delayed_send(1u, test_ch, expected);\n-        };\n+        iter::repeat(times as uint) {||\n+            task::yield();\n \n-        let actual = alt recv_timeout(1000u, test_po) {\n-          some(val) { val }\n-          _ { fail \"test_timer_recv_timeout_before_time_passes:\"+\n-                    \" didn't receive result before timeout\"; }\n-        };\n-        assert actual == expected;\n+            let expected = rand::rng().gen_str(16u);\n+            let test_po = comm::port::<str>();\n+            let test_ch = comm::chan(test_po);\n+\n+            task::spawn() {||\n+                delayed_send(1u, test_ch, expected);\n+            };\n+\n+            alt recv_timeout(10u, test_po) {\n+              some(val) { assert val == expected; successes += 1; }\n+              _ { failures += 1; }\n+            };\n+        }\n+\n+        assert successes > times / 2;\n     }\n \n     #[test]\n     fn test_gl_timer_recv_timeout_after_time_passes() {\n-        let expected = rand::rng().gen_str(16u);\n-        let fail_msg = rand::rng().gen_str(16u);\n-        let test_po = comm::port::<str>();\n-        let test_ch = comm::chan(test_po);\n+        let times = 100;\n+        let mut successes = 0;\n+        let mut failures = 0;\n \n-        task::spawn() {||\n-            delayed_send(1000u, test_ch, expected);\n-        };\n+        iter::repeat(times as uint) {||\n+            let expected = rand::rng().gen_str(16u);\n+            let test_po = comm::port::<str>();\n+            let test_ch = comm::chan(test_po);\n \n-        let actual = alt recv_timeout(1u, test_po) {\n-          none { fail_msg }\n-          _ { fail \"test_timer_recv_timeout_before_time_passes:\"+\n-                    \" didn't receive result before timeout\"; }\n-        };\n-        assert actual == fail_msg;\n+            task::spawn() {||\n+                delayed_send(1000u, test_ch, expected);\n+            };\n+\n+            let actual = alt recv_timeout(1u, test_po) {\n+              none { successes += 1; }\n+              _ { failures += 1; }\n+            };\n+        }\n+\n+        assert successes > times / 2;\n     }\n }"}, {"sha": "939e962198975597126d88dabf887d04e68bc4e1", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -178,16 +178,41 @@ rust_str_push(rust_vec** sp, uint8_t byte) {\n     (*sp)->fill = fill + 1;\n }\n \n+extern \"C\" CDECL rust_vec*\n+rand_seed() {\n+    size_t size = sizeof(ub4) * RANDSIZ;\n+    rust_task *task = rust_get_current_task();\n+    rust_vec *v = (rust_vec *) task->kernel->malloc(vec_size<uint8_t>(size),\n+                                            \"rand_seed\");\n+    v->fill = v->alloc = size;\n+    isaac_seed(task->kernel, (uint8_t*) &v->data);\n+    return v;\n+}\n+\n extern \"C\" CDECL void *\n rand_new() {\n     rust_task *task = rust_get_current_task();\n     rust_sched_loop *thread = task->sched_loop;\n-    randctx *rctx = (randctx *) task->malloc(sizeof(randctx), \"randctx\");\n+    randctx *rctx = (randctx *) task->malloc(sizeof(randctx), \"rand_new\");\n+    if (!rctx) {\n+        task->fail();\n+        return NULL;\n+    }\n+    isaac_init(thread->kernel, rctx, NULL);\n+    return rctx;\n+}\n+\n+extern \"C\" CDECL void *\n+rand_new_seeded(rust_vec* seed) {\n+    rust_task *task = rust_get_current_task();\n+    rust_sched_loop *thread = task->sched_loop;\n+    randctx *rctx = (randctx *) task->malloc(sizeof(randctx),\n+                                             \"rand_new_seeded\");\n     if (!rctx) {\n         task->fail();\n         return NULL;\n     }\n-    isaac_init(thread->kernel, rctx);\n+    isaac_init(thread->kernel, rctx, seed);\n     return rctx;\n }\n \n@@ -529,6 +554,11 @@ struct tm* LOCALTIME(const time_t *clock, tm *result) {\n #define TIMEGM(result) timegm(result)\n #endif\n \n+extern \"C\" CDECL void\n+rust_tzset() {\n+    TZSET();\n+}\n+\n extern \"C\" CDECL void\n rust_gmtime(int64_t *sec, int32_t *nsec, rust_tm *timeptr) {\n     tm tm;\n@@ -541,7 +571,6 @@ rust_gmtime(int64_t *sec, int32_t *nsec, rust_tm *timeptr) {\n extern \"C\" CDECL void\n rust_localtime(int64_t *sec, int32_t *nsec, rust_tm *timeptr) {\n     tm tm;\n-    TZSET();\n     time_t s = *sec;\n     LOCALTIME(&s, &tm);\n "}, {"sha": "697f460d3a64bf235ef535964b4d1bb05e6bb9dc", "filename": "src/rt/rust_sched_loop.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -29,7 +29,7 @@ rust_sched_loop::rust_sched_loop(rust_scheduler *sched,int id) :\n     name(\"main\")\n {\n     LOGPTR(this, \"new dom\", (uintptr_t)this);\n-    isaac_init(kernel, &rctx);\n+    isaac_init(kernel, &rctx, NULL);\n \n     if (!tls_initialized)\n         init_tls();"}, {"sha": "b517362df1ffb4efbb75bbdc516acfa6d63569be", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -32,46 +32,6 @@ align_to(T size, size_t alignment) {\n     return x;\n }\n \n-// Initialization helper for ISAAC RNG\n-\n-inline void\n-isaac_init(rust_kernel *kernel, randctx *rctx)\n-{\n-        memset(rctx, 0, sizeof(randctx));\n-\n-        char *rust_seed = kernel->env->rust_seed;\n-        if (rust_seed != NULL) {\n-            ub4 seed = (ub4) atoi(rust_seed);\n-            for (size_t i = 0; i < RANDSIZ; i ++) {\n-                memcpy(&rctx->randrsl[i], &seed, sizeof(ub4));\n-                seed = (seed + 0x7ed55d16) + (seed << 12);\n-            }\n-        } else {\n-#ifdef __WIN32__\n-            HCRYPTPROV hProv;\n-            kernel->win32_require\n-                (_T(\"CryptAcquireContext\"),\n-                 CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL,\n-                                     CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n-            kernel->win32_require\n-                (_T(\"CryptGenRandom\"),\n-                 CryptGenRandom(hProv, sizeof(rctx->randrsl),\n-                                (BYTE*)(&rctx->randrsl)));\n-            kernel->win32_require\n-                (_T(\"CryptReleaseContext\"),\n-                 CryptReleaseContext(hProv, 0));\n-#else\n-            int fd = open(\"/dev/urandom\", O_RDONLY);\n-            assert(fd > 0);\n-            assert(read(fd, (void*) &rctx->randrsl, sizeof(rctx->randrsl))\n-                   == sizeof(rctx->randrsl));\n-            assert(close(fd) == 0);\n-#endif\n-        }\n-\n-        randinit(rctx, 1);\n-}\n-\n // Interior vectors (rust-user-code level).\n \n struct\n@@ -136,6 +96,53 @@ make_str_vec(rust_kernel* kernel, size_t nstrs, char **strs) {\n     return v;\n }\n \n+// Initialization helpers for ISAAC RNG\n+\n+inline void isaac_seed(rust_kernel* kernel, uint8_t* dest)\n+{\n+    size_t size = sizeof(ub4) * RANDSIZ;\n+#ifdef __WIN32__\n+    HCRYPTPROV hProv;\n+    kernel->win32_require\n+        (_T(\"CryptAcquireContext\"),\n+         CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL,\n+                             CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n+    kernel->win32_require\n+        (_T(\"CryptGenRandom\"), CryptGenRandom(hProv, size, (BYTE*) dest));\n+    kernel->win32_require\n+        (_T(\"CryptReleaseContext\"), CryptReleaseContext(hProv, 0));\n+#else\n+    int fd = open(\"/dev/urandom\", O_RDONLY);\n+    assert(fd > 0);\n+    assert(read(fd, dest, size) == (int) size);\n+    assert(close(fd) == 0);\n+#endif\n+}\n+\n+inline void\n+isaac_init(rust_kernel *kernel, randctx *rctx, rust_vec* user_seed)\n+{\n+    memset(rctx, 0, sizeof(randctx));\n+\n+    char *env_seed = kernel->env->rust_seed;\n+    if (user_seed != NULL) {\n+        // ignore bytes after the required length\n+        size_t seed_len = user_seed->fill < sizeof(rctx->randrsl)\n+            ? user_seed->fill : sizeof(rctx->randrsl);\n+        memcpy(&rctx->randrsl, user_seed->data, seed_len);\n+    } else if (env_seed != NULL) {\n+        ub4 seed = (ub4) atoi(env_seed);\n+        for (size_t i = 0; i < RANDSIZ; i ++) {\n+            memcpy(&rctx->randrsl[i], &seed, sizeof(ub4));\n+            seed = (seed + 0x7ed55d16) + (seed << 12);\n+        }\n+    } else {\n+        isaac_seed(kernel, (uint8_t*) &rctx->randrsl);\n+    }\n+\n+    randinit(rctx, 1);\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "a93089b8f8bc4abc7816018704fa40177087bbf2", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -12,6 +12,7 @@ debug_abi_2\n get_port_id\n get_task_id\n get_time\n+rust_tzset\n rust_gmtime\n rust_localtime\n rust_timegm\n@@ -25,7 +26,9 @@ rust_port_id_send\n rust_port_select\n rand_free\n rand_new\n+rand_new_seeded\n rand_next\n+rand_seed\n refcount\n rust_get_sched_id\n rust_new_sched"}, {"sha": "5541bbd8451c30126954ee5f10821e979b078aaf", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -14,7 +14,7 @@ import syntax::print::pprust;\n import lib::llvm::{ModuleRef, mk_pass_manager, mk_target_data, True, False,\n         FileType};\n import util::filesearch;\n-import middle::ast_map::{path, path_mod, path_name};\n+import syntax::ast_map::{path, path_mod, path_name};\n \n enum output_type {\n     output_type_none,"}, {"sha": "a7febe457dd31b0b1adc9d762af462b3462d4581", "filename": "src/rustc/back/x86.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fx86.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,15 +1,12 @@\n import driver::session;\n+import session::sess_os_to_meta_os;\n+import metadata::loader::meta_section_name;\n \n fn get_target_strs(target_os: session::os) -> target_strs::t {\n     ret {\n         module_asm: \"\",\n \n-        meta_sect_name: alt target_os {\n-          session::os_macos { \"__DATA,__note.rustc\" }\n-          session::os_win32 { \".note.rustc\" }\n-          session::os_linux { \".note.rustc\" }\n-          session::os_freebsd { \".note.rustc\" }\n-        },\n+        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),\n \n         data_layout: alt target_os {\n           session::os_macos {"}, {"sha": "3210a2333f4094e0c321dad4a0158aad3ac7a83f", "filename": "src/rustc/back/x86_64.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fx86_64.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,15 +1,12 @@\n import driver::session;\n+import session::sess_os_to_meta_os;\n+import metadata::loader::meta_section_name;\n \n fn get_target_strs(target_os: session::os) -> target_strs::t {\n     ret {\n         module_asm: \"\",\n \n-        meta_sect_name: alt target_os {\n-          session::os_macos { \"__DATA,__note.rustc\" }\n-          session::os_win32 { \".note.rustc\" }\n-          session::os_linux { \".note.rustc\" }\n-          session::os_freebsd { \".note.rustc\" }\n-        },\n+        meta_sect_name: meta_section_name(sess_os_to_meta_os(target_os)),\n \n         data_layout: alt target_os {\n           session::os_macos {"}, {"sha": "655a6f82b784cbc9655bc843a79465c9f33539ec", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -160,9 +160,13 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n \n     let ast_map =\n         time(time_passes, \"ast indexing\",\n-             bind middle::ast_map::map_crate(sess, *crate));\n+             bind syntax::ast_map::map_crate(sess.diagnostic(), *crate));\n     time(time_passes, \"external crate/lib resolution\",\n-         bind creader::read_crates(sess, *crate));\n+         bind creader::read_crates(\n+             sess.diagnostic(), *crate, sess.cstore,\n+             sess.filesearch,\n+             session::sess_os_to_meta_os(sess.targ_cfg.os),\n+             sess.opts.static));\n     let {def_map, exp_map, impl_map} =\n         time(time_passes, \"resolution\",\n              bind resolve::resolve_crate(sess, ast_map, crate));\n@@ -676,7 +680,8 @@ fn early_error(emitter: diagnostic::emitter, msg: str) -> ! {\n }\n \n fn list_metadata(sess: session, path: str, out: io::writer) {\n-    metadata::loader::list_file_metadata(sess, path, out);\n+    metadata::loader::list_file_metadata(\n+        session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);\n }\n \n #[cfg(test)]"}, {"sha": "85cbc2d3a1ae5699b2c54fc1c58765ad488efc22", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -171,10 +171,7 @@ fn basic_options() -> @options {\n \n // Seems out of place, but it uses session, so I'm putting it here\n fn expect<T: copy>(sess: session, opt: option<T>, msg: fn() -> str) -> T {\n-    alt opt {\n-       some(t) { t }\n-       none { sess.bug(msg()); }\n-    }\n+    diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n \n fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n@@ -197,6 +194,17 @@ fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n     }\n }\n \n+fn sess_os_to_meta_os(os: os) -> metadata::loader::os {\n+    import metadata::loader;\n+\n+    alt os {\n+      os_win32 { loader::os_win32 }\n+      os_linux { loader::os_linux }\n+      os_macos { loader::os_macos }\n+      os_freebsd { loader::os_freebsd }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     import syntax::ast_util;"}, {"sha": "3a9dfff1ae283e0f07618353a8610b90a44a22e9", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -24,10 +24,10 @@ fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n     let ctxt = @{in_cfg: in_cfg};\n \n     let precursor =\n-        {fold_mod: bind fold_mod(ctxt, _, _),\n-         fold_block: fold::wrap(bind fold_block(ctxt, _, _)),\n-         fold_native_mod: bind fold_native_mod(ctxt, _, _)\n-            with *fold::default_ast_fold()};\n+        @{fold_mod: bind fold_mod(ctxt, _, _),\n+          fold_block: fold::wrap(bind fold_block(ctxt, _, _)),\n+          fold_native_mod: bind fold_native_mod(ctxt, _, _)\n+          with *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n     let res = @fold.fold_crate(*crate);"}, {"sha": "b410cb75ad6f76298bd6a607b237e24bbd3cd2ee", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -43,9 +43,9 @@ fn generate_test_harness(sess: session::session,\n           mut testfns: []};\n \n     let precursor =\n-        {fold_crate: fold::wrap(bind fold_crate(cx, _, _)),\n-         fold_item: bind fold_item(cx, _, _),\n-         fold_mod: bind fold_mod(cx, _, _) with *fold::default_ast_fold()};\n+        @{fold_crate: fold::wrap(bind fold_crate(cx, _, _)),\n+          fold_item: bind fold_item(cx, _, _),\n+          fold_mod: bind fold_mod(cx, _, _) with *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n     let res = @fold.fold_crate(*crate);"}, {"sha": "272c3b0e5612d7ff163b2c11cb36aee062ff28e2", "filename": "src/rustc/metadata.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -3,8 +3,6 @@\n // no dependencies on rustc it can move into its own crate.\n \n mod middle {\n-    import ast_map = middle_::ast_map;\n-    export ast_map;\n     import ty = middle_::ty;\n     export ty;\n }\n@@ -16,8 +14,6 @@ mod back {\n }\n \n mod driver {\n-    import session = driver_::session;\n-    export session;\n }\n \n mod util {"}, {"sha": "0fadf1b1f68f315b8d9151142967ec102190eb19", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -4,22 +4,28 @@ Validates all used crates and native libraries and loads their metadata\n \n \"];\n \n-import driver::session;\n-import session::session;\n+import syntax::diagnostic::span_handler;\n import syntax::{ast, ast_util};\n import syntax::attr;\n import syntax::visit;\n import syntax::codemap::span;\n import std::map::{hashmap, int_hash};\n import syntax::print::pprust;\n+import util::filesearch::filesearch;\n import common::*;\n \n export read_crates;\n \n // Traverses an AST, reading all the information about use'd crates and native\n // libraries necessary for later resolving, typechecking, linking, etc.\n-fn read_crates(sess: session::session, crate: ast::crate) {\n-    let e = @{sess: sess,\n+fn read_crates(diag: span_handler, crate: ast::crate,\n+               cstore: cstore::cstore, filesearch: filesearch,\n+               os: loader::os, static: bool) {\n+    let e = @{diag: diag,\n+              filesearch: filesearch,\n+              cstore: cstore,\n+              os: os,\n+              static: static,\n               mut crate_cache: [],\n               mut next_crate_num: 1};\n     let v =\n@@ -29,7 +35,7 @@ fn read_crates(sess: session::session, crate: ast::crate) {\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), v);\n     dump_crates(e.crate_cache);\n-    warn_if_multiple_versions(sess, copy e.crate_cache);\n+    warn_if_multiple_versions(diag, copy e.crate_cache);\n }\n \n type cache_entry = {\n@@ -54,7 +60,7 @@ fn dump_crates(crate_cache: [cache_entry]) {\n     }\n }\n \n-fn warn_if_multiple_versions(sess: session::session,\n+fn warn_if_multiple_versions(diag: span_handler,\n                              crate_cache: [cache_entry]) {\n     import either::*;\n \n@@ -73,21 +79,26 @@ fn warn_if_multiple_versions(sess: session::session,\n         assert matches.is_not_empty();\n \n         if matches.len() != 1u {\n-            sess.warn(#fmt(\"using multiple versions of crate `%s`\", name));\n+            diag.handler().warn(\n+                #fmt(\"using multiple versions of crate `%s`\", name));\n             for matches.each {|match|\n-                sess.span_note(match.span, \"used here\");\n+                diag.span_note(match.span, \"used here\");\n                 let attrs = [\n                     attr::mk_attr(attr::mk_list_item(\"link\", *match.metas))\n                 ];\n-                loader::note_linkage_attrs(sess, attrs);\n+                loader::note_linkage_attrs(diag, attrs);\n             }\n         }\n \n-        warn_if_multiple_versions(sess, non_matches);\n+        warn_if_multiple_versions(diag, non_matches);\n     }\n }\n \n-type env = @{sess: session::session,\n+type env = @{diag: span_handler,\n+             filesearch: filesearch,\n+             cstore: cstore::cstore,\n+             os: loader::os,\n+             static: bool,\n              mut crate_cache: [cache_entry],\n              mut next_crate_num: ast::crate_num};\n \n@@ -96,7 +107,7 @@ fn visit_view_item(e: env, i: @ast::view_item) {\n       ast::view_item_use(ident, meta_items, id) {\n         #debug(\"resolving use stmt. ident: %?, meta: %?\", ident, meta_items);\n         let cnum = resolve_crate(e, ident, meta_items, \"\", i.span);\n-        cstore::add_use_stmt_cnum(e.sess.cstore, id, cnum);\n+        cstore::add_use_stmt_cnum(e.cstore, id, cnum);\n       }\n       _ { }\n     }\n@@ -110,15 +121,15 @@ fn visit_item(e: env, i: @ast::item) {\n             if abi != ast::native_abi_cdecl &&\n                abi != ast::native_abi_stdcall { ret; }\n           }\n-          either::left(msg) { e.sess.span_fatal(i.span, msg); }\n+          either::left(msg) { e.diag.span_fatal(i.span, msg); }\n         }\n \n-        let cstore = e.sess.cstore;\n+        let cstore = e.cstore;\n         let native_name =\n             alt attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n               some(nn) {\n                 if nn == \"\" {\n-                    e.sess.span_fatal(\n+                    e.diag.span_fatal(\n                         i.span,\n                         \"empty #[link_name] not allowed; use #[nolink].\");\n                 }\n@@ -132,7 +143,7 @@ fn visit_item(e: env, i: @ast::item) {\n         }\n         let link_args = attr::find_attrs_by_name(i.attrs, \"link_args\");\n         if vec::len(link_args) > 0u && already_added {\n-            e.sess.span_fatal(i.span, \"library '\" + native_name +\n+            e.diag.span_fatal(i.span, \"library '\" + native_name +\n                               \"' already added: can't specify link_args.\");\n         }\n         for link_args.each {|a|\n@@ -179,8 +190,17 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n \n     alt existing_match(e, metas, hash) {\n       none {\n-        let cinfo =\n-            loader::load_library_crate(e.sess, ident, span, metas, hash);\n+        let load_ctxt: loader::ctxt = {\n+            diag: e.diag,\n+            filesearch: e.filesearch,\n+            span: span,\n+            ident: ident,\n+            metas: metas,\n+            hash: hash,\n+            os: e.os,\n+            static: e.static\n+        };\n+        let cinfo = loader::load_library_crate(load_ctxt);\n \n         let cfilename = cinfo.ident;\n         let cdata = cinfo.data;\n@@ -206,7 +226,7 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n         let cmeta = @{name: cname, data: cdata,\n                       cnum_map: cnum_map, cnum: cnum};\n \n-        let cstore = e.sess.cstore;\n+        let cstore = e.cstore;\n         cstore::set_crate_data(cstore, cnum, cmeta);\n         cstore::add_used_crate_file(cstore, cfilename);\n         ret cnum;"}, {"sha": "3994d9fa722a55472dbafadea31e8ce2768c6835", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -3,10 +3,11 @@\n import std::{ebml};\n import syntax::ast;\n import syntax::ast_util;\n-import middle::{ty, ast_map};\n+import syntax::ast_map;\n+import middle::ty;\n import option::{some, none};\n-import driver::session;\n-import driver::session::expect;\n+import syntax::diagnostic::span_handler;\n+import syntax::diagnostic::expect;\n import common::*;\n import std::map::hashmap;\n \n@@ -81,7 +82,7 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n }\n \n fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     let path = decoder::get_item_path(cdata, def.node);\n \n@@ -102,14 +103,14 @@ enum found_ast {\n fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::def_id,\n                       decode_inlined_item: decoder::decode_inlined_item)\n     -> found_ast {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::maybe_get_item_ast(cdata, tcx, def.node,\n                                 decode_inlined_item)\n }\n \n fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     ret decoder::get_enum_variants(cdata, def.node, tcx)\n }\n@@ -124,35 +125,35 @@ fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n }\n \n fn get_iface_methods(tcx: ty::ctxt, def: ast::def_id) -> @[ty::method] {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_iface_methods(cdata, def.node, tcx)\n }\n \n fn get_class_fields(tcx: ty::ctxt, def: ast::def_id) -> [ty::field_ty] {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_class_fields(cdata, def.node)\n }\n \n fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                   def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n     let all_items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     #debug(\"Looking up %?\", class_id);\n-    let class_doc = expect(tcx.sess,\n+    let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            {|| #fmt(\"get_field_type: class ID %? not found\",\n                      class_id)});\n     #debug(\"looking up %? : %?\", def, class_doc);\n-    let the_field = expect(tcx.sess,\n+    let the_field = expect(tcx.diag,\n         decoder::maybe_find_item(def.node, class_doc),\n         {|| #fmt(\"get_field_type: in class %?, field ID %? not found\",\n                  class_id, def)});\n@@ -164,7 +165,7 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n // Given a def_id for an impl or class, return the iface it implements,\n // or none if it's not for an impl or for a class that implements ifaces\n fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id) -> option<ty::t> {\n-    let cstore = tcx.sess.cstore;\n+    let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_iface(cdata, def.node, tcx)\n }"}, {"sha": "644d519fc0f283e36bf71e4d0da043f69d8d57d0", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -6,7 +6,7 @@ import io::writer_util;\n import syntax::{ast, ast_util};\n import syntax::attr;\n import middle::ty;\n-import middle::ast_map;\n+import syntax::ast_map;\n import common::*;\n import tydecode::{parse_ty_data, parse_def_id, parse_bounds_data,\n         parse_ident};"}, {"sha": "50683ec32839c0fe4c4b8c3930cf5aef9bfe21c7", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -13,7 +13,7 @@ import syntax::ast_util::local_def;\n import common::*;\n import middle::ty;\n import middle::ty::node_id_to_type;\n-import middle::ast_map;\n+import syntax::ast_map;\n import syntax::attr;\n import std::serialization::serializer;\n import std::ebml::serializer;"}, {"sha": "da991ec0c2acdd4c3b06e8353b4ace58e9b6bd95", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 62, "deletions": 51, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -4,70 +4,72 @@ Finds crate binaries and loads their metadata\n \n \"];\n \n-import driver::session;\n-import session::session;\n+import syntax::diagnostic::span_handler;\n import syntax::{ast, attr};\n import syntax::print::pprust;\n import syntax::codemap::span;\n import lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n-import util::{filesearch};\n+import util::filesearch;\n+import filesearch::filesearch;\n import io::writer_util;\n \n+export os;\n+export ctxt;\n export load_library_crate;\n export list_file_metadata;\n export note_linkage_attrs;\n export crate_name_from_metas;\n export metadata_matches;\n+export meta_section_name;\n \n-fn load_library_crate(sess: session::session, ident: ast::ident, span: span,\n-                      metas: [@ast::meta_item], hash: str)\n-   -> {ident: str, data: @[u8]} {\n-\n+enum os {\n+    os_macos,\n+    os_win32,\n+    os_linux,\n+    os_freebsd\n+}\n \n-    alt find_library_crate(sess, span, metas, hash) {\n+type ctxt = {\n+    diag: span_handler,\n+    filesearch: filesearch,\n+    span: span,\n+    ident: ast::ident,\n+    metas: [@ast::meta_item],\n+    hash: str,\n+    os: os,\n+    static: bool\n+};\n+\n+fn load_library_crate(cx: ctxt) -> {ident: str, data: @[u8]} {\n+    alt find_library_crate(cx) {\n       some(t) { ret t; }\n       none {\n-        sess.span_fatal(span, #fmt[\"can't find crate for '%s'\", ident]);\n+        cx.diag.span_fatal(\n+            cx.span, #fmt[\"can't find crate for '%s'\", cx.ident]);\n       }\n     }\n }\n \n-fn find_library_crate(sess: session::session, span: span,\n-                      metas: [@ast::meta_item], hash: str)\n-   -> option<{ident: str, data: @[u8]}> {\n-\n-    attr::require_unique_names(sess.diagnostic(), metas);\n-    let metas = metas;\n-\n-    let nn = default_native_lib_naming(sess, sess.opts.static);\n-    let x =\n-        find_library_crate_aux(sess, span, nn,\n-                               metas, hash, sess.filesearch);\n-    if x != none || sess.opts.static { ret x; }\n-    let nn2 = default_native_lib_naming(sess, true);\n-    ret find_library_crate_aux(sess, span, nn2, metas, hash,\n-                               sess.filesearch);\n+fn find_library_crate(cx: ctxt) -> option<{ident: str, data: @[u8]}> {\n+    attr::require_unique_names(cx.diag, cx.metas);\n+    find_library_crate_aux(cx, libname(cx), cx.filesearch)\n }\n \n-fn default_native_lib_naming(sess: session::session, static: bool) ->\n-   {prefix: str, suffix: str} {\n-    if static { ret {prefix: \"lib\", suffix: \".rlib\"}; }\n-    alt sess.targ_cfg.os {\n-      session::os_win32 { ret {prefix: \"\", suffix: \".dll\"}; }\n-      session::os_macos { ret {prefix: \"lib\", suffix: \".dylib\"}; }\n-      session::os_linux { ret {prefix: \"lib\", suffix: \".so\"}; }\n-      session::os_freebsd { ret {prefix: \"lib\", suffix: \".so\"}; }\n+fn libname(cx: ctxt) -> {prefix: str, suffix: str} {\n+    if cx.static { ret {prefix: \"lib\", suffix: \".rlib\"}; }\n+    alt cx.os {\n+      os_win32 { ret {prefix: \"\", suffix: \".dll\"}; }\n+      os_macos { ret {prefix: \"lib\", suffix: \".dylib\"}; }\n+      os_linux { ret {prefix: \"lib\", suffix: \".so\"}; }\n+      os_freebsd { ret {prefix: \"lib\", suffix: \".so\"}; }\n     }\n }\n \n-fn find_library_crate_aux(sess: session::session,\n-                          span: span,\n+fn find_library_crate_aux(cx: ctxt,\n                           nn: {prefix: str, suffix: str},\n-                          metas: [@ast::meta_item],\n-                          hash: str,\n                           filesearch: filesearch::filesearch) ->\n    option<{ident: str, data: @[u8]}> {\n-    let crate_name = crate_name_from_metas(metas);\n+    let crate_name = crate_name_from_metas(cx.metas);\n     let prefix: str = nn.prefix + crate_name + \"-\";\n     let suffix: str = nn.suffix;\n \n@@ -81,9 +83,9 @@ fn find_library_crate_aux(sess: session::session,\n             option::none::<()>\n         } else {\n             #debug(\"%s is a candidate\", path);\n-            alt get_metadata_section(sess, path) {\n+            alt get_metadata_section(cx.os, path) {\n               option::some(cvec) {\n-                if !crate_matches(cvec, metas, hash) {\n+                if !crate_matches(cvec, cx.metas, cx.hash) {\n                     #debug(\"skipping %s, metadata doesn't match\", path);\n                     option::none::<()>\n                 } else {\n@@ -105,15 +107,15 @@ fn find_library_crate_aux(sess: session::session,\n     } else if matches.len() == 1u {\n         some(matches[0])\n     } else {\n-        sess.span_err(\n-            span, #fmt(\"multiple matching crates for `%s`\", crate_name));\n-        sess.note(\"candidates:\");\n+        cx.diag.span_err(\n+            cx.span, #fmt(\"multiple matching crates for `%s`\", crate_name));\n+        cx.diag.handler().note(\"candidates:\");\n         for matches.each {|match|\n-            sess.note(#fmt(\"path: %s\", match.ident));\n+            cx.diag.handler().note(#fmt(\"path: %s\", match.ident));\n             let attrs = decoder::get_crate_attributes(match.data);\n-            note_linkage_attrs(sess, attrs);\n+            note_linkage_attrs(cx.diag, attrs);\n         }\n-        sess.abort_if_errors();\n+        cx.diag.handler().abort_if_errors();\n         none\n     }\n }\n@@ -133,9 +135,9 @@ fn crate_name_from_metas(metas: [@ast::meta_item]) -> str {\n     }\n }\n \n-fn note_linkage_attrs(sess: session::session, attrs: [ast::attribute]) {\n+fn note_linkage_attrs(diag: span_handler, attrs: [ast::attribute]) {\n     for attr::find_linkage_attrs(attrs).each {|attr|\n-        sess.note(#fmt(\"meta: %s\", pprust::attr_to_str(attr)));\n+        diag.handler().note(#fmt(\"meta: %s\", pprust::attr_to_str(attr)));\n     }\n }\n \n@@ -171,7 +173,7 @@ fn metadata_matches(extern_metas: [@ast::meta_item],\n     ret true;\n }\n \n-fn get_metadata_section(sess: session::session,\n+fn get_metadata_section(os: os,\n                         filename: str) -> option<@[u8]> unsafe {\n     let mb = str::as_c_str(filename, {|buf|\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n@@ -185,7 +187,7 @@ fn get_metadata_section(sess: session::session,\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n         let name_buf = llvm::LLVMGetSectionName(si.llsi);\n         let name = unsafe { str::unsafe::from_c_str(name_buf) };\n-        if str::eq(name, sess.targ_cfg.target_strs.meta_sect_name) {\n+        if str::eq(name, meta_section_name(os)) {\n             let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n             unsafe {\n@@ -198,9 +200,18 @@ fn get_metadata_section(sess: session::session,\n     ret option::none::<@[u8]>;\n }\n \n+fn meta_section_name(os: os) -> str {\n+    alt os {\n+      os_macos { \"__DATA,__note.rustc\" }\n+      os_win32 { \".note.rustc\" }\n+      os_linux { \".note.rustc\" }\n+      os_freebsd { \".note.rustc\" }\n+    }\n+}\n+\n // A diagnostic function for dumping crate metadata to an output stream\n-fn list_file_metadata(sess: session::session, path: str, out: io::writer) {\n-    alt get_metadata_section(sess, path) {\n+fn list_file_metadata(os: os, path: str, out: io::writer) {\n+    alt get_metadata_section(os, path) {\n       option::some(bytes) { decoder::list_crate_metadata(bytes, out); }\n       option::none {\n         out.write_str(\"could not find metadata in \" + path + \".\\n\");"}, {"sha": "843607380d8d9f58d94906770f48f5d906cc3fcb", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,4 +1,5 @@\n-import syntax::{ast, ast_util};\n+import syntax::{ast, ast_util, ast_map};\n+import ast_util::path_to_ident;\n import ast::{ident, fn_ident, node_id};\n import syntax::codemap::span;\n import syntax::visit;"}, {"sha": "796f316f442f79781d6ae9618bc3181fd49f07eb", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -3,6 +3,7 @@ import util::ppaux::ty_to_str;\n import syntax::ast;\n import syntax::fold;\n import syntax::visit;\n+import syntax::ast_map;\n import syntax::ast_util;\n import syntax::ast_util::inlined_item_methods;\n import syntax::codemap::span;\n@@ -17,7 +18,7 @@ import std::serialization::serializer_helpers;\n import std::serialization::deserializer_helpers;\n import std::prettyprint::serializer;\n import std::smallintmap::map;\n-import middle::{ty, typeck, last_use, ast_map};\n+import middle::{ty, typeck, last_use};\n import middle::typeck::{method_origin,\n                         serialize_method_origin,\n                         deserialize_method_origin,\n@@ -115,7 +116,8 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n                     to_id_range: to_id_range};\n         let raw_ii = decode_ast(ast_doc);\n         let ii = renumber_ast(xcx, raw_ii);\n-        ast_map::map_decoded_item(tcx.sess, dcx.tcx.items, path, ii);\n+        ast_map::map_decoded_item(tcx.sess.diagnostic(),\n+                                  dcx.tcx.items, path, ii);\n         #debug[\"Fn named: %s\", ii.ident()];\n         decode_side_tables(xcx, ast_doc);\n         #debug[\"< Decoded inlined fn: %s::%s\",\n@@ -401,7 +403,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n         fold::noop_fold_block(blk_sans_items, fld)\n     }\n \n-    let fld = fold::make_fold({\n+    let fld = fold::make_fold(@{\n         fold_block: fold::wrap(drop_nested_items)\n         with *fold::default_ast_fold()\n     });\n@@ -434,7 +436,7 @@ fn decode_ast(par_doc: ebml::doc) -> ast::inlined_item {\n \n fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n     -> ast::inlined_item {\n-    let fld = fold::make_fold({\n+    let fld = fold::make_fold(@{\n         new_id: xcx.tr_id(_),\n         new_span: xcx.tr_span(_)\n         with *fold::default_ast_fold()"}, {"sha": "0adce9b2feca8e38ad9502efa44cd1413600e69a", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -2,6 +2,7 @@ import syntax::ast;\n import syntax::ast::{m_mutbl, m_imm, m_const};\n import syntax::visit;\n import syntax::ast_util;\n+import syntax::ast_map;\n import syntax::codemap::span;\n import util::ppaux::{ty_to_str, region_to_str};\n import driver::session::session;"}, {"sha": "4fbab3879d0c48ae98388552852bdfd1c760c139", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,5 +1,5 @@\n import syntax::ast::*;\n-import syntax::{visit, ast_util};\n+import syntax::{visit, ast_util, ast_map};\n import driver::session::session;\n import std::map::hashmap;\n "}, {"sha": "99f058788b233d31f04fe127a40210aeb09e4c0a", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -44,8 +44,7 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n               mul { const_int(a * b) } div { const_int(a / b) }\n               rem { const_int(a % b) } and | bitand { const_int(a & b) }\n               or | bitor { const_int(a | b) } bitxor { const_int(a ^ b) }\n-              lsl { const_int(a << b) } lsr { const_int(a >> b) }\n-              asr { const_int(a >>> b) }\n+              shl { const_int(a << b) } shr { const_int(a >> b) }\n               eq { fromb(a == b) } lt { fromb(a < b) }\n               le { fromb(a <= b) } ne { fromb(a != b) }\n               ge { fromb(a >= b) } gt { fromb(a > b) }\n@@ -58,9 +57,7 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n               mul { const_uint(a * b) } div { const_uint(a / b) }\n               rem { const_uint(a % b) } and | bitand { const_uint(a & b) }\n               or | bitor { const_uint(a | b) } bitxor { const_uint(a ^ b) }\n-              lsl { const_int((a << b) as i64) }\n-              lsr { const_int((a >> b) as i64) }\n-              asr { const_int((a >>> b) as i64) }\n+              shl { const_uint(a << b) } shr { const_uint(a >> b) }\n               eq { fromb(a == b) } lt { fromb(a < b) }\n               le { fromb(a <= b) } ne { fromb(a != b) }\n               ge { fromb(a >= b) } gt { fromb(a > b) }"}, {"sha": "effa593109cd1c0aaf4b77d8dbb89372141ecc1e", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,7 +1,7 @@\n import syntax::{visit, ast_util};\n import syntax::ast::*;\n import syntax::codemap::span;\n-import ty::{kind, kind_copyable, kind_sendable, kind_noncopyable};\n+import ty::{kind, kind_sendable, kind_copyable, kind_noncopyable };\n import driver::session::session;\n import std::map::hashmap;\n import util::ppaux::{ty_to_str, tys_to_str};\n@@ -24,10 +24,11 @@ import freevars::freevar_entry;\n // types.\n \n fn kind_to_str(k: kind) -> str {\n-    alt k {\n-      kind_sendable { \"sendable\" }\n-      kind_copyable { \"copyable\" }\n-      kind_noncopyable { \"noncopyable\" }\n+    alt (ty::kind_can_be_copied(k), ty::kind_can_be_sent(k)) {\n+      (false, false) { \"noncopyable\" }\n+      (false, true)  { \"sendable\" }\n+      (true,  false) { \"copyable\" }\n+      (true,  true)  { \"copy-sendable\" }\n     }\n }\n "}, {"sha": "29cacf370928e52bac0d516fd8a9a92b11b39662", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,15 +1,13 @@\n import syntax::ast::*;\n import syntax::ast_util;\n-import syntax::ast_util::respan;\n+import syntax::ast_util::{path_to_ident, respan, walk_pat};\n import syntax::fold;\n import syntax::fold::*;\n import syntax::codemap::span;\n import std::map::hashmap;\n \n-export walk_pat;\n export pat_binding_ids, pat_bindings, pat_id_map;\n export pat_is_variant;\n-export path_to_ident;\n \n type pat_id_map = std::map::hashmap<str, node_id>;\n \n@@ -51,22 +49,8 @@ fn pat_bindings(dm: resolve::def_map, pat: @pat,\n     }\n }\n \n-fn walk_pat(pat: @pat, it: fn(@pat)) {\n-    it(pat);\n-    alt pat.node {\n-      pat_ident(pth, some(p)) { walk_pat(p, it); }\n-      pat_rec(fields, _) { for fields.each {|f| walk_pat(f.pat, it); } }\n-      pat_enum(_, some(s)) | pat_tup(s) { for s.each {|p| walk_pat(p, it); } }\n-      pat_box(s) | pat_uniq(s) { walk_pat(s, it); }\n-      pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _)\n-        | pat_enum(_, _) {}\n-    }\n-}\n-\n fn pat_binding_ids(dm: resolve::def_map, pat: @pat) -> [node_id] {\n     let mut found = [];\n     pat_bindings(dm, pat) {|b_id, _sp, _pt| found += [b_id]; };\n     ret found;\n }\n-\n-fn path_to_ident(p: @path) -> ident { vec::last(p.idents) }"}, {"sha": "9521b0d14882353759c76bbedf1798fc2f414548", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,7 +1,8 @@\n-import syntax::{ast, ast_util, codemap};\n+import syntax::{ast, ast_util, codemap, ast_map};\n import syntax::ast::*;\n import ast::{ident, fn_ident, def, def_id, node_id};\n-import syntax::ast_util::{local_def, def_id_of_def, class_item_ident};\n+import syntax::ast_util::{local_def, def_id_of_def,\n+                          class_item_ident, path_to_ident};\n import pat_util::*;\n \n import syntax::attr;\n@@ -687,7 +688,7 @@ fn visit_local_with_scope(e: @env, loc: @local, &&sc: scopes, v:vt<scopes>) {\n     // scope. We disallow this, in order to make alt patterns consisting of a\n     // single identifier unambiguous (does the pattern \"foo\" refer to enum\n     // foo, or is it binding a new name foo?)\n-    pat_util::walk_pat(loc.node.pat) { |p|\n+    ast_util::walk_pat(loc.node.pat) { |p|\n         alt p.node {\n           pat_ident(path, _) {\n             alt lookup_in_scope(*e, sc, loc.span, path_to_ident(path),"}, {"sha": "493d1ee4ad2dd5321f457bab1a7896f60edd8d7c", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -6,7 +6,7 @@ import build::*;\n import base::*;\n import syntax::ast;\n import syntax::ast_util;\n-import syntax::ast_util::{dummy_sp};\n+import syntax::ast_util::{dummy_sp, path_to_ident};\n import syntax::ast::def_id;\n import syntax::codemap::span;\n import syntax::print::pprust::pat_to_str;"}, {"sha": "038354da68350a0083d549ce2178091b3379f768", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -21,9 +21,8 @@ import driver::session;\n import session::session;\n import syntax::attr;\n import back::{link, abi, upcall};\n-import syntax::{ast, ast_util, codemap};\n-import ast_util::inlined_item_methods;\n-import ast_util::local_def;\n+import syntax::{ast, ast_util, codemap, ast_map};\n+import ast_util::{inlined_item_methods, local_def, path_to_ident};\n import syntax::visit;\n import syntax::codemap::span;\n import syntax::print::pprust::{expr_to_str, stmt_to_str, path_to_str};\n@@ -47,7 +46,7 @@ import build::*;\n import shape::*;\n import type_of::*;\n import type_of::type_of; // Issue #1873\n-import ast_map::{path, path_mod, path_name};\n+import syntax::ast_map::{path, path_mod, path_name};\n \n import std::smallintmap;\n \n@@ -540,22 +539,22 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n         let glue_fn_ty = T_ptr(T_glue_fn(ccx));\n         let ti = val;\n         let take_glue =\n-            alt ti.take_glue {\n+            alt copy ti.take_glue {\n               none { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n         let drop_glue =\n-            alt ti.drop_glue {\n+            alt copy ti.drop_glue {\n               none { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n         let free_glue =\n-            alt ti.free_glue {\n+            alt copy ti.free_glue {\n               none { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n         let visit_glue =\n-            alt ti.visit_glue {\n+            alt copy ti.visit_glue {\n               none { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n@@ -1618,9 +1617,12 @@ fn trans_eager_binop(cx: block, op: ast::binop, lhs: ValueRef,\n       ast::bitor { Or(cx, lhs, rhs) }\n       ast::bitand { And(cx, lhs, rhs) }\n       ast::bitxor { Xor(cx, lhs, rhs) }\n-      ast::lsl { Shl(cx, lhs, rhs) }\n-      ast::lsr { LShr(cx, lhs, rhs) }\n-      ast::asr { AShr(cx, lhs, rhs) }\n+      ast::shl { Shl(cx, lhs, rhs) }\n+      ast::shr {\n+        if ty::type_is_signed(intype) {\n+            AShr(cx, lhs, rhs)\n+        } else { LShr(cx, lhs, rhs) }\n+      }\n       _ {\n         let cmpr = trans_compare(cx, op, lhs, lhs_t, rhs, rhs_t);\n         cx = cmpr.bcx;\n@@ -2309,7 +2311,7 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n         ret take_local(cx.fcx.lllocals, nid);\n       }\n       ast::def_self(_) {\n-        let slf = alt cx.fcx.llself {\n+        let slf = alt copy cx.fcx.llself {\n              some(s) { s }\n              none { cx.sess().bug(\"trans_local_var: reference to self \\\n                                  out of context\"); }\n@@ -3031,7 +3033,7 @@ fn trans_call_inner(\n             Unreachable(bcx);\n         } else if ret_in_loop {\n             bcx = with_cond(bcx, Load(bcx, option::get(ret_flag))) {|bcx|\n-                option::iter(bcx.fcx.loop_ret) {|lret|\n+                option::iter(copy bcx.fcx.loop_ret) {|lret|\n                     Store(bcx, C_bool(true), lret.flagptr);\n                     Store(bcx, C_bool(false), bcx.fcx.llretptr);\n                 }\n@@ -3120,7 +3122,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     let mut cached = none, pad_bcx = bcx; // Guaranteed to be set below\n     in_lpad_scope_cx(bcx) {|inf|\n         // If there is a valid landing pad still around, use it\n-        alt inf.landing_pad {\n+        alt copy inf.landing_pad {\n           some(target) { cached = some(target); }\n           none {\n             pad_bcx = sub_block(bcx, \"unwind\");\n@@ -3149,7 +3151,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n \n     // We store the retval in a function-central alloca, so that calls to\n     // Resume can find it.\n-    alt bcx.fcx.personality {\n+    alt copy bcx.fcx.personality {\n       some(addr) { Store(pad_bcx, llretval, addr); }\n       none {\n         let addr = alloca(pad_bcx, val_ty(llretval));\n@@ -3832,7 +3834,7 @@ fn trans_cont(cx: block) -> block {\n fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n-    let retptr = alt bcx.fcx.loop_ret {\n+    let retptr = alt copy bcx.fcx.loop_ret {\n       some({flagptr, retptr}) {\n         // This is a loop body return. Must set continue flag (our retptr)\n         // to false, return flag to true, and then store the value in the\n@@ -4566,9 +4568,11 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n           ast::bitxor { llvm::LLVMConstXor(te1, te2) }\n           ast::bitand { llvm::LLVMConstAnd(te1, te2) }\n           ast::bitor  { llvm::LLVMConstOr(te1, te2) }\n-          ast::lsl    { llvm::LLVMConstShl(te1, te2) }\n-          ast::lsr    { llvm::LLVMConstLShr(te1, te2) }\n-          ast::asr    { llvm::LLVMConstAShr(te1, te2) }\n+          ast::shl    { llvm::LLVMConstShl(te1, te2) }\n+          ast::shr    {\n+            if signed { llvm::LLVMConstAShr(te1, te2) }\n+            else      { llvm::LLVMConstLShr(te1, te2) }\n+          }\n           ast::eq     |\n           ast::lt     |\n           ast::le     |"}, {"sha": "bfc93ddf93d673ed01dc3477acdce16fec5cf5aa", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -15,7 +15,7 @@ import back::link::{\n     mangle_internal_name_by_path,\n     mangle_internal_name_by_path_and_seq};\n import util::ppaux::ty_to_str;\n-import ast_map::{path, path_mod, path_name};\n+import syntax::ast_map::{path, path_mod, path_name};\n import driver::session::session;\n import std::map::hashmap;\n "}, {"sha": "d69e7101aba4514fbdcba2b5c71ba448705bd47d", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -6,7 +6,7 @@\n import libc::c_uint;\n import vec::unsafe::to_ptr;\n import std::map::{hashmap,set};\n-import syntax::ast;\n+import syntax::{ast, ast_map};\n import driver::session;\n import session::session;\n import middle::{resolve, ty};\n@@ -19,7 +19,7 @@ import lib::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n import lib::llvm::{True, False, Bool};\n import metadata::{csearch};\n import metadata::common::link_meta;\n-import ast_map::path;\n+import syntax::ast_map::path;\n import util::ppaux::ty_to_str;\n \n type namegen = fn@(str) -> str;\n@@ -388,7 +388,7 @@ fn ty_str(tn: type_names, t: TypeRef) -> str {\n     ret lib::llvm::type_to_str(tn, t);\n }\n \n-fn val_ty(&&v: ValueRef) -> TypeRef { ret llvm::LLVMTypeOf(v); }\n+fn val_ty(v: ValueRef) -> TypeRef { ret llvm::LLVMTypeOf(v); }\n \n fn val_str(tn: type_names, v: ValueRef) -> str { ret ty_str(tn, val_ty(v)); }\n "}, {"sha": "09e40558858b62b66cd4a81268b3a0a43e5beeb1", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -6,7 +6,7 @@ import trans::common::*;\n import trans::base;\n import trans::build::B;\n import middle::ty;\n-import syntax::{ast, codemap, ast_util};\n+import syntax::{ast, codemap, ast_util, ast_map};\n import codemap::span;\n import ast::ty;\n import pat_util::*;\n@@ -648,7 +648,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n     }\n \n     let name = alt local.node.pat.node {\n-      ast::pat_ident(pth, _) { pat_util::path_to_ident(pth) }\n+      ast::pat_ident(pth, _) { ast_util::path_to_ident(pth) }\n       // FIXME this should be handled\n       _ { fail \"no single variable name for local\"; }\n     };"}, {"sha": "7d40a9535b28609492a1fa1d721c26a7fef555bd", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -4,14 +4,14 @@ import common::*;\n import type_of::*;\n import build::*;\n import driver::session::session;\n-import syntax::ast;\n+import syntax::{ast, ast_map};\n+import ast_map::{path, path_mod, path_name, node_id_to_str};\n import syntax::ast_util::{local_def, split_class_items};\n import metadata::csearch;\n import back::{link, abi};\n import lib::llvm::llvm;\n import lib::llvm::{ValueRef, TypeRef};\n import lib::llvm::llvm::LLVMGetParam;\n-import ast_map::{path, path_mod, path_name, node_id_to_str};\n import std::map::hashmap;\n \n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,"}, {"sha": "8c71e89f930a5bf931eef681c13cc45e8aa83f1c", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -4,7 +4,7 @@\n import driver::session::{session, arch_x86_64};\n import syntax::codemap::span;\n import libc::c_uint;\n-import syntax::attr;\n+import syntax::{attr, ast_map};\n import lib::llvm::{ llvm, TypeRef, ValueRef,\n                     ModuleRef, CallConv, Attribute,\n                     StructRetAttribute, ByValAttribute"}, {"sha": "814bff13e99d838f9b6612fc2af60154b4c7bd1c", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -6,7 +6,7 @@\n // reachable as well.\n \n import syntax::ast::*;\n-import syntax::{visit, ast_util};\n+import syntax::{visit, ast_util, ast_map};\n import syntax::ast_util::def_id_of_def;\n import syntax::attr;\n import std::map::hashmap;"}, {"sha": "b91cdff15b7fa35648ddfff2e086ea6d1283230f", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -23,6 +23,7 @@ import std::list::{list, cons, nil};\n import driver::session::session;\n import metadata::csearch;\n import syntax::ast::*, syntax::ast_util, syntax::visit;\n+import syntax::ast_map;\n import common::*;\n \n // FIXME distinguish between size/alignment and take/drop dependencies"}, {"sha": "6410cfe5b6a7c11b3e71e2ab4b37423e6697f36a", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 63, "deletions": 55, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -3,7 +3,7 @@ import result::result;\n import std::map::hashmap;\n import driver::session;\n import session::session;\n-import syntax::ast;\n+import syntax::{ast, ast_map};\n import syntax::ast::*;\n import syntax::ast_util;\n import syntax::ast_util::{is_local, local_def, split_class_items};\n@@ -204,6 +204,7 @@ type ctxt =\n     @{diag: syntax::diagnostic::span_handler,\n       interner: hashmap<intern_key, t_box>,\n       mut next_id: uint,\n+      cstore: metadata::cstore::cstore,\n       sess: session::session,\n       def_map: resolve::def_map,\n       region_map: middle::region::region_map,\n@@ -421,13 +422,13 @@ impl of vid for region_vid {\n }\n \n fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n-    let mut kind = kind_noncopyable;\n+    let mut kind = kind_noncopyable();\n     for vec::each(*bounds) {|bound|\n         alt bound {\n           bound_copy {\n-            if kind != kind_sendable { kind = kind_copyable; }\n+            kind = lower_kind(kind, kind_copyable());\n           }\n-          bound_send { kind = kind_sendable; }\n+          bound_send { kind = lower_kind(kind, kind_send_only()); }\n           _ {}\n         }\n     }\n@@ -468,6 +469,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n     @{diag: s.diagnostic(),\n       interner: interner,\n       mut next_id: 0u,\n+      cstore: s.cstore,\n       sess: s,\n       def_map: dm,\n       region_map: region_map,\n@@ -1260,58 +1262,65 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n     ret needs_unwind_cleanup;\n }\n \n-enum kind { kind_sendable, kind_copyable, kind_noncopyable, }\n+enum kind { kind_(u32) }\n+\n+const KIND_MASK_COPY : u32 = 0b00000000000000000000000000000001u32;\n+const KIND_MASK_SEND : u32 = 0b00000000000000000000000000000010u32;\n+\n+fn kind_noncopyable() -> kind {\n+    kind_(0u32)\n+}\n+\n+fn kind_copyable() -> kind {\n+    kind_(KIND_MASK_COPY)\n+}\n+\n+fn kind_sendable() -> kind {\n+    kind_(KIND_MASK_COPY | KIND_MASK_SEND)\n+}\n+\n+fn kind_send_only() -> kind {\n+    kind_(KIND_MASK_SEND)\n+}\n \n // Using these query functons is preferable to direct comparison or matching\n // against the kind constants, as we may modify the kind hierarchy in the\n // future.\n pure fn kind_can_be_copied(k: kind) -> bool {\n-    ret alt k {\n-      kind_sendable { true }\n-      kind_copyable { true }\n-      kind_noncopyable { false }\n-    };\n+    *k & KIND_MASK_COPY != 0u32\n }\n \n pure fn kind_can_be_sent(k: kind) -> bool {\n-    ret alt k {\n-      kind_sendable { true }\n-      kind_copyable { false }\n-      kind_noncopyable { false }\n-    };\n+    *k & KIND_MASK_SEND != 0u32\n }\n \n fn proto_kind(p: proto) -> kind {\n     alt p {\n-      ast::proto_any { kind_noncopyable }\n-      ast::proto_block { kind_noncopyable }\n-      ast::proto_box { kind_copyable }\n-      ast::proto_uniq { kind_sendable }\n-      ast::proto_bare { kind_sendable }\n+      ast::proto_any { kind_noncopyable() }\n+      ast::proto_block { kind_noncopyable() }\n+      ast::proto_box { kind_copyable() }\n+      ast::proto_uniq { kind_sendable() }\n+      ast::proto_bare { kind_sendable() }\n     }\n }\n \n fn kind_lteq(a: kind, b: kind) -> bool {\n-    alt a {\n-      kind_noncopyable { true }\n-      kind_copyable { b != kind_noncopyable }\n-      kind_sendable { b == kind_sendable }\n-    }\n+    *a & *b == *a\n }\n \n fn lower_kind(a: kind, b: kind) -> kind {\n-    if kind_lteq(a, b) { a } else { b }\n+    kind_(*a | *b)\n }\n \n #[test]\n fn test_kinds() {\n     // The kind \"lattice\" is nocopy <= copy <= send\n-    assert kind_lteq(kind_sendable, kind_sendable);\n-    assert kind_lteq(kind_copyable, kind_sendable);\n-    assert kind_lteq(kind_copyable, kind_copyable);\n-    assert kind_lteq(kind_noncopyable, kind_sendable);\n-    assert kind_lteq(kind_noncopyable, kind_copyable);\n-    assert kind_lteq(kind_noncopyable, kind_noncopyable);\n+    assert kind_lteq(kind_sendable(), kind_sendable());\n+    assert kind_lteq(kind_copyable(), kind_sendable());\n+    assert kind_lteq(kind_copyable(), kind_copyable());\n+    assert kind_lteq(kind_noncopyable(), kind_sendable());\n+    assert kind_lteq(kind_noncopyable(), kind_copyable());\n+    assert kind_lteq(kind_noncopyable(), kind_noncopyable());\n }\n \n fn type_kind(cx: ctxt, ty: t) -> kind {\n@@ -1321,44 +1330,44 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n     }\n \n     // Insert a default in case we loop back on self recursively.\n-    cx.kind_cache.insert(ty, kind_sendable);\n+    cx.kind_cache.insert(ty, kind_sendable());\n \n     let result = alt get(ty).struct {\n       // Scalar and unique types are sendable\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_ptr(_) | ty_str { kind_sendable }\n-      ty_type { kind_copyable }\n+      ty_ptr(_) | ty_str { kind_sendable() }\n+      ty_type { kind_copyable() }\n       ty_fn(f) { proto_kind(f.proto) }\n \n       // Closures have kind determined by capture mode\n-      ty_opaque_closure_ptr(ck_block) { kind_noncopyable }\n-      ty_opaque_closure_ptr(ck_box) { kind_copyable }\n-      ty_opaque_closure_ptr(ck_uniq) { kind_sendable }\n+      ty_opaque_closure_ptr(ck_block) { kind_noncopyable() }\n+      ty_opaque_closure_ptr(ck_box) { kind_copyable() }\n+      ty_opaque_closure_ptr(ck_uniq) { kind_sendable() }\n \n       // Those with refcounts raise noncopyable to copyable,\n       // lower sendable to copyable. Therefore just set result to copyable.\n-      ty_box(_) | ty_iface(_, _) | ty_opaque_box { kind_copyable }\n-      ty_rptr(_, _) { kind_copyable }\n+      ty_box(_) | ty_iface(_, _) | ty_opaque_box { kind_copyable() }\n+      ty_rptr(_, _) { kind_copyable() }\n \n       // Unique boxes and vecs have the kind of their contained type.\n       ty_vec(tm) | ty_uniq(tm) { type_kind(cx, tm.ty) }\n \n       // Slice and refcounted evecs are copyable; uniques and interiors\n       // depend on the their contained type.\n       ty_evec(_, vstore_box) |\n-      ty_evec(_, vstore_slice(_)) { kind_copyable }\n+      ty_evec(_, vstore_slice(_)) { kind_copyable() }\n       ty_evec(tm, vstore_uniq) |\n       ty_evec(tm, vstore_fixed(_)) { type_kind(cx, tm.ty)  }\n \n       // All estrs are copyable; uniques and interiors are sendable.\n       ty_estr(vstore_box) |\n-      ty_estr(vstore_slice(_)) { kind_copyable }\n+      ty_estr(vstore_slice(_)) { kind_copyable() }\n       ty_estr(vstore_uniq) |\n-      ty_estr(vstore_fixed(_)) { kind_sendable  }\n+      ty_estr(vstore_fixed(_)) { kind_sendable()  }\n \n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n-        let mut lowest = kind_sendable;\n+        let mut lowest = kind_sendable();\n         for flds.each {|f|\n             lowest = lower_kind(lowest, type_kind(cx, f.mt.ty));\n         }\n@@ -1368,7 +1377,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       // sendable, but I'm just treating them like records (#1726)\n       ty_class(did, substs) {\n           // also factor out this code, copied from the records case\n-          let mut lowest = kind_sendable;\n+          let mut lowest = kind_sendable();\n           let flds = class_items_as_fields(cx, did, substs);\n           for flds.each {|f|\n             lowest = lower_kind(lowest, type_kind(cx, f.mt.ty));\n@@ -1377,34 +1386,34 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       }\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n-        let mut lowest = kind_sendable;\n+        let mut lowest = kind_sendable();\n         for tys.each {|ty| lowest = lower_kind(lowest, type_kind(cx, ty)); }\n         lowest\n       }\n       // Enums lower to the lowest of their variants.\n       ty_enum(did, substs) {\n-        let mut lowest = kind_sendable;\n+        let mut lowest = kind_sendable();\n         let variants = enum_variants(cx, did);\n         if vec::len(*variants) == 0u {\n-            lowest = kind_noncopyable;\n+            lowest = kind_noncopyable();\n         } else {\n             for vec::each(*variants) {|variant|\n                 for variant.args.each {|aty|\n                     // Perform any type parameter substitutions.\n                     let arg_ty = subst(cx, substs, aty);\n                     lowest = lower_kind(lowest, type_kind(cx, arg_ty));\n-                    if lowest == kind_noncopyable { break; }\n+                    if lowest == kind_noncopyable() { break; }\n                 }\n             }\n         }\n         lowest\n       }\n-      ty_res(did, inner, tps) { kind_noncopyable }\n+      ty_res(did, inner, tps) { kind_send_only() }\n       ty_param(_, did) {\n           param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n       }\n       ty_constr(t, _) { type_kind(cx, t) }\n-      ty_self { kind_noncopyable }\n+      ty_self { kind_noncopyable() }\n \n       ty_var(_) { cx.sess.bug(\"Asked to compute kind of a type variable\"); }\n     };\n@@ -1605,7 +1614,7 @@ fn type_allows_implicit_copy(cx: ctxt, ty: t) -> bool {\n           }\n           _ { false }\n         }\n-    }) && type_kind(cx, ty) != kind_noncopyable;\n+    }) && type_kind(cx, ty) != kind_noncopyable();\n }\n \n fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n@@ -2704,9 +2713,8 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n           ast::bitxor { opcat_bit }\n           ast::bitand { opcat_bit }\n           ast::bitor { opcat_bit }\n-          ast::lsl { opcat_shift }\n-          ast::lsr { opcat_shift }\n-          ast::asr { opcat_shift }\n+          ast::shl { opcat_shift }\n+          ast::shr { opcat_shift }\n           ast::eq { opcat_eq }\n           ast::ne { opcat_eq }\n           ast::lt { opcat_rel }"}, {"sha": "7b97bfb713806281fa1f7933a9beb5c14b03faa5", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -39,9 +39,9 @@ independently:\n */\n \n import result::{result, extensions};\n-import syntax::{ast, ast_util};\n+import syntax::{ast, ast_util, ast_map};\n import ast::spanned;\n-import ast_map::node_id_to_str;\n+import syntax::ast_map::node_id_to_str;\n import syntax::ast_util::{local_def, respan, split_class_items};\n import syntax::visit;\n import metadata::csearch;"}, {"sha": "0ba90e07984a4cd50c33e782746286d43ac236db", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -302,6 +302,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n             // n.b.: resolve guarantees that the self type only appears in an\n             // iface, which we rely upon in various places when creating\n             // substs\n+            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n             ty::mk_self(tcx)\n           }\n           _ {"}, {"sha": "f3c10547708f5a80383d5911991aab668f07c389", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -867,8 +867,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     fn binop_method(op: ast::binop) -> option<str> {\n         alt op {\n           ast::add | ast::subtract | ast::mul | ast::div | ast::rem |\n-          ast::bitxor | ast::bitand | ast::bitor | ast::lsl | ast::lsr |\n-          ast::asr { some(ast_util::binop_to_str(op)) }\n+          ast::bitxor | ast::bitand | ast::bitor | ast::shl | ast::shr\n+          { some(ast_util::binop_to_str(op)) }\n           _ { none }\n         }\n     }"}, {"sha": "268777f5aaf28d0f6a01175ed4e5679f99750b83", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -154,7 +154,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         let vid = lookup_local(pcx.fcx, pat.span, pat.id);\n         let mut typ = ty::mk_var(tcx, vid);\n         demand::suptype(pcx.fcx, pat.span, expected, typ);\n-        let canon_id = pcx.map.get(pat_util::path_to_ident(name));\n+        let canon_id = pcx.map.get(ast_util::path_to_ident(name));\n         if canon_id != pat.id {\n             let tv_id = lookup_local(pcx.fcx, pat.span, canon_id);\n             let ct = ty::mk_var(tcx, tv_id);"}, {"sha": "0aa8b741d12c08a7f820b1256437010d1a0bfc36", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,5 +1,6 @@\n /* Code to handle method lookups (which can be quite complex) */\n \n+import syntax::ast_map;\n import regionmanip::universally_quantify_regions;\n import middle::typeck::infer::{ty_and_region_var_methods};\n "}, {"sha": "2f75a7c2e221942118128dffa2da32cce99f8ac7", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -49,7 +49,6 @@ mod middle {\n         mod reachable;\n     }\n     mod ty;\n-    mod ast_map;\n     mod resolve;\n     mod typeck {\n         mod check {"}, {"sha": "0cd45e0dcf53ec6a07401258963e80212387f6c2", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -121,10 +121,10 @@ fn local_rhs_span(l: @ast::local, def: span) -> span {\n     alt l.node.init { some(i) { ret i.expr.span; } _ { ret def; } }\n }\n \n-fn is_main_name(path: middle::ast_map::path) -> bool {\n+fn is_main_name(path: syntax::ast_map::path) -> bool {\n     // FIXME: path should be a constrained type, so we know\n     // the call to last doesn't fail\n-    vec::last(path) == middle::ast_map::path_name(\"main\")\n+    vec::last(path) == syntax::ast_map::path_name(\"main\")\n }\n \n //"}, {"sha": "0e3682963f6b7405a76bed807adc289b68b093b1", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -7,7 +7,7 @@ import syntax::print::pprust;\n import syntax::print::pprust::{path_to_str, constr_args_to_str, proto_to_str,\n                                mode_to_str};\n import syntax::{ast, ast_util};\n-import middle::ast_map;\n+import syntax::ast_map;\n import driver::session::session;\n \n fn bound_region_to_str(cx: ctxt, br: bound_region) -> str {"}, {"sha": "30e803a898a91c9c5e3e6f1db9ae97f3010b6e8f", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -9,12 +9,13 @@\n \n import std::map::hashmap;\n import rustc::driver::session;\n+import session::session;\n import rustc::driver::driver;\n import syntax::diagnostic;\n import syntax::diagnostic::handler;\n import syntax::ast;\n import syntax::codemap;\n-import rustc::middle::ast_map;\n+import syntax::ast_map;\n import rustc::back::link;\n import rustc::util::filesearch;\n import rustc::front;\n@@ -110,7 +111,7 @@ fn build_ctxt(sess: session::session, ast: @ast::crate,\n \n     let ast = config::strip_unconfigured_items(ast);\n     let ast = front::test::modify_for_testing(sess, ast);\n-    let ast_map = ast_map::map_crate(sess, *ast);\n+    let ast_map = ast_map::map_crate(sess.diagnostic(), *ast);\n     *ignore_errors = true;\n     let {exp_map, impl_map, _} = resolve::resolve_crate(sess, ast_map, ast);\n     *ignore_errors = false;"}, {"sha": "8ea297843b038c02e502f4f0603ec37c55d71c7d", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -7,7 +7,7 @@\n )];\n \n import syntax::ast;\n-import rustc::middle::ast_map;\n+import syntax::ast_map;\n import std::map::hashmap;\n \n export mk_pass;"}, {"sha": "b4921771e04ef2c16bb5990c78cece7c9b269390", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -85,7 +85,7 @@ fn mk_fold<T:copy>(\n     })\n }\n \n-fn default_any_fold<T:send>(ctxt: T) -> fold<T> {\n+fn default_any_fold<T:send copy>(ctxt: T) -> fold<T> {\n     mk_fold(\n         ctxt,\n         {|f, d| default_seq_fold_doc(f, d)},\n@@ -121,7 +121,7 @@ fn default_seq_fold<T:copy>(ctxt: T) -> fold<T> {\n     )\n }\n \n-fn default_par_fold<T:send>(ctxt: T) -> fold<T> {\n+fn default_par_fold<T:send copy>(ctxt: T) -> fold<T> {\n     mk_fold(\n         ctxt,\n         {|f, d| default_seq_fold_doc(f, d)},"}, {"sha": "b73576448258b4624aa60b8de96a789de690f7ec", "filename": "src/rustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_hidden_pass.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -33,7 +33,7 @@ fn fold_mod(\n }\n \n fn is_hidden(srv: astsrv::srv, doc: doc::itemdoc) -> bool {\n-    import rustc::middle::ast_map;\n+    import syntax::ast_map;\n \n     let id = doc.id;\n     astsrv::exec(srv) {|ctxt|"}, {"sha": "2c14271a630b852f26f3f9f9a8ff4fc41ba2471a", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -2,7 +2,7 @@\n \n import syntax::ast;\n import syntax::ast_util;\n-import rustc::middle::ast_map;\n+import syntax::ast_map;\n import std::map::hashmap;\n \n export mk_pass;"}, {"sha": "2637f8755d0b2e69b5d086bedbb1ab2bdaffe69f", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -6,7 +6,7 @@ import std::list;\n import syntax::ast;\n import syntax::ast_util;\n import rustc::util::common;\n-import rustc::middle::ast_map;\n+import syntax::ast_map;\n import syntax::visit;\n import syntax::codemap;\n import rustc::middle::resolve;"}, {"sha": "289062ddcdf91c6dffeb2cf27b328891ffee7659", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -3,7 +3,7 @@\n \n import syntax::ast;\n import syntax::print::pprust;\n-import rustc::middle::ast_map;\n+import syntax::ast_map;\n import std::map::hashmap;\n \n export mk_pass;"}, {"sha": "07c9456d3b4f0091759280c22d0fd086a550d67e", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,3 +1,11 @@\n+S 2012-05-21 248e439\n+  macos-i386 0e4433772d39cb824f73954199b8da61d7e65bbd\n+  macos-x86_64 6bbddabd65cc579f61a12e702275f6333077eb2b\n+  freebsd-x86_64 8989700eac1a06aced19b10d8bf42620bd463aaa\n+  linux-x86_64 83e97ebd85a6664bedb26c881d2095c857708982\n+  linux-i386 c001c6b3d3967c7c19113e5fd48206bffd53d815\n+  winnt-i386 3c389de7ec57dfd2d4307f88da61a80359d8ecc4\n+\n S 2012-05-15 17d6b09\n   freebsd-x86_64 631f4fd0bf13f72870b144e99a97273450618046\n   linux-i386 c16019d7c62feb3a851790987fb0b49d357a9084"}, {"sha": "a3bb2fc8efdee27b8488eece91338a0e30eedabe", "filename": "src/test/bench/graph500-bfs.rs", "status": "added", "additions": 616, "deletions": 0, "changes": 616, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -0,0 +1,616 @@\n+/**\n+\n+An implementation of the Graph500 Bread First Search problem in Rust.\n+\n+*/\n+\n+use std;\n+import std::time;\n+import std::map;\n+import std::map::hashmap;\n+import std::deque;\n+import std::deque::t;\n+import io::writer_util;\n+import comm::*;\n+import int::abs;\n+\n+type node_id = i64;\n+type graph = [[node_id]];\n+type bfs_result = [node_id];\n+\n+iface queue<T: send> {\n+    fn add_back(T);\n+    fn pop_front() -> T;\n+    fn size() -> uint;\n+}\n+\n+#[doc=\"Creates a queue based on ports and channels.\n+\n+This is admittedly not ideal, but it will help us work around the deque\n+bugs for the time being.\"]\n+fn create_queue<T: send>() -> queue<T> {\n+    type repr<T: send> = {\n+        p : port<T>,\n+        c : chan<T>,\n+        mut s : uint,\n+    };\n+\n+    let p = port();\n+    let c = chan(p);\n+\n+    impl<T: copy send> of queue<T> for repr<T> {\n+        fn add_back(x : T) {\n+            let x = x;\n+            send(self.c, x);\n+            self.s += 1u;\n+        }\n+\n+        fn pop_front() -> T {\n+            self.s -= 1u;\n+            recv(self.p)\n+        }\n+\n+        fn size() -> uint { self.s }\n+    }\n+\n+    let Q : repr<T> = { p : p, c : c, mut s : 0u };\n+    Q as queue::<T>\n+}\n+\n+fn make_edges(scale: uint, edgefactor: uint) -> [(node_id, node_id)] {\n+    let r = rand::rng();\n+\n+    fn choose_edge(i: node_id, j: node_id, scale: uint, r: rand::rng)\n+        -> (node_id, node_id) {\n+\n+        let A = 0.57;\n+        let B = 0.19;\n+        let C = 0.19;\n+ \n+        if scale == 0u {\n+            (i, j)\n+        }\n+        else {\n+            let i = i * 2i64;\n+            let j = j * 2i64;\n+            let scale = scale - 1u;\n+            \n+            let x = r.gen_float();\n+\n+            if x < A {\n+                choose_edge(i, j, scale, r)\n+            }\n+            else {\n+                let x = x - A;\n+                if x < B {\n+                    choose_edge(i + 1i64, j, scale, r)\n+                }\n+                else {\n+                    let x = x - B;\n+                    if x < C {\n+                        choose_edge(i, j + 1i64, scale, r)\n+                    }\n+                    else {\n+                        choose_edge(i + 1i64, j + 1i64, scale, r)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    vec::from_fn((1u << scale) * edgefactor) {|_i|\n+        choose_edge(0i64, 0i64, scale, r)\n+    }\n+}\n+\n+fn make_graph(N: uint, edges: [(node_id, node_id)]) -> graph {\n+    let graph = vec::from_fn(N) {|_i| \n+        map::hashmap::<node_id, ()>({|x| x as uint }, {|x, y| x == y })\n+    };\n+\n+    vec::each(edges) {|e| \n+        let (i, j) = e;\n+        map::set_add(graph[i], j);\n+        map::set_add(graph[j], i);\n+        true\n+    }\n+\n+    graph.map() {|v|\n+        map::vec_from_set(v)\n+    }\n+}\n+\n+fn gen_search_keys(graph: graph, n: uint) -> [node_id] {\n+    let keys = map::hashmap::<node_id, ()>({|x| x as uint }, {|x, y| x == y });\n+    let r = rand::rng();\n+\n+    while keys.size() < n {\n+        let k = r.gen_uint_range(0u, graph.len());\n+\n+        if graph[k].len() > 0u && vec::any(graph[k]) {|i|\n+            i != k as node_id\n+        } {\n+            map::set_add(keys, k as node_id);\n+        }\n+    }\n+    map::vec_from_set(keys)\n+}\n+\n+#[doc=\"Returns a vector of all the parents in the BFS tree rooted at key.\n+\n+Nodes that are unreachable have a parent of -1.\"]\n+fn bfs(graph: graph, key: node_id) -> bfs_result {\n+    let marks : [mut node_id] \n+        = vec::to_mut(vec::from_elem(vec::len(graph), -1i64));\n+\n+    let Q = create_queue();\n+\n+    Q.add_back(key);\n+    marks[key] = key;\n+\n+    while Q.size() > 0u {\n+        let t = Q.pop_front();\n+\n+        graph[t].each() {|k| \n+            if marks[k] == -1i64 {\n+                marks[k] = t;\n+                Q.add_back(k);\n+            }\n+            true\n+        };\n+    }\n+\n+    vec::from_mut(marks)\n+}\n+\n+#[doc=\"Another version of the bfs function.\n+\n+This one uses the same algorithm as the parallel one, just without\n+using the parallel vector operators.\"]\n+fn bfs2(graph: graph, key: node_id) -> bfs_result {\n+    // This works by doing functional updates of a color vector.\n+\n+    enum color {\n+        white,\n+        // node_id marks which node turned this gray/black.\n+        // the node id later becomes the parent.\n+        gray(node_id),\n+        black(node_id)\n+    };\n+\n+    let mut colors = vec::from_fn(graph.len()) {|i|\n+        if i as node_id == key {\n+            gray(key)\n+        }\n+        else {\n+            white\n+        }\n+    };\n+\n+    fn is_gray(c: color) -> bool {\n+        alt c {\n+          gray(_) { true }\n+          _ { false }\n+        }\n+    }\n+\n+    let mut i = 0u;\n+    while vec::any(colors, is_gray) {\n+        // Do the BFS.\n+        log(info, #fmt(\"PBFS iteration %?\", i));\n+        i += 1u;\n+        colors = colors.mapi() {|i, c|\n+            let c : color = c;\n+            alt c {\n+              white {\n+                let i = i as node_id;\n+                \n+                let neighbors = graph[i];\n+                \n+                let mut color = white;\n+\n+                neighbors.each() {|k|\n+                    if is_gray(colors[k]) {\n+                        color = gray(k);\n+                        false\n+                    }\n+                    else { true }\n+                };\n+\n+                color\n+              }\n+              gray(parent) { black(parent) }\n+              black(parent) { black(parent) }\n+            }\n+        }\n+    }\n+\n+    // Convert the results.\n+    vec::map(colors) {|c|\n+        alt c {\n+          white { -1i64 }\n+          black(parent) { parent }\n+          _ { fail \"Found remaining gray nodes in BFS\" }\n+        }\n+    }\n+}\n+\n+#[doc=\"A parallel version of the bfs function.\"]\n+fn pbfs(graph: graph, key: node_id) -> bfs_result {\n+    // This works by doing functional updates of a color vector.\n+\n+    enum color {\n+        white,\n+        // node_id marks which node turned this gray/black.\n+        // the node id later becomes the parent.\n+        gray(node_id),\n+        black(node_id)\n+    };\n+\n+    let mut colors = vec::from_fn(graph.len()) {|i|\n+        if i as node_id == key {\n+            gray(key)\n+        }\n+        else {\n+            white\n+        }\n+    };\n+\n+    #[inline(always)]\n+    fn is_gray(c: color) -> bool {\n+        alt c {\n+          gray(_) { true }\n+          _ { false }\n+        }\n+    }\n+\n+    let mut i = 0u;\n+    while par::any(colors, is_gray) {\n+        // Do the BFS.\n+        log(info, #fmt(\"PBFS iteration %?\", i));\n+        i += 1u;\n+        let old_len = colors.len();\n+        let pc = ptr::addr_of(colors);\n+        let pg = ptr::addr_of(graph);\n+        colors = par::mapi(colors) {|i, c|\n+            let c : color = c;\n+            alt c {\n+              white {\n+                unsafe {\n+                    let i = i as node_id;\n+                    \n+                    let neighbors = &(*pg)[i];\n+                    \n+                    let mut color = white;\n+                    \n+                    (*neighbors).each() {|k|\n+                        if is_gray((*pc)[k]) {\n+                            color = gray(k);\n+                            false\n+                        }\n+                        else { true }\n+                    };\n+                    color\n+                }\n+              }\n+              gray(parent) { black(parent) }\n+              black(parent) { black(parent) }\n+            }\n+        };\n+        assert(colors.len() == old_len);\n+    }\n+\n+    // Convert the results.\n+    par::map(colors) {|c|\n+        alt c {\n+          white { -1i64 }\n+          black(parent) { parent }\n+          _ { fail \"Found remaining gray nodes in BFS\" }\n+        }\n+    }\n+}\n+\n+#[doc=\"Performs at least some of the validation in the Graph500 spec.\"]\n+fn validate(edges: [(node_id, node_id)], \n+            root: node_id, tree: bfs_result) -> bool {\n+    // There are 5 things to test. Below is code for each of them.\n+\n+    // 1. The BFS tree is a tree and does not contain cycles.\n+    //\n+    // We do this by iterating over the tree, and tracing each of the\n+    // parent chains back to the root. While we do this, we also\n+    // compute the levels for each node.\n+\n+    log(info, \"Verifying tree structure...\");\n+\n+    let mut status = true;\n+    let level = tree.map() {|parent| \n+        let mut parent = parent;\n+        let mut path = [];\n+\n+        if parent == -1i64 {\n+            // This node was not in the tree.\n+            -1\n+        }\n+        else {\n+            while parent != root {\n+                if vec::contains(path, parent) {\n+                    status = false;\n+                }\n+\n+                path += [parent];\n+                parent = tree[parent];\n+            }\n+\n+            // The length of the path back to the root is the current\n+            // level.\n+            path.len() as int\n+        }\n+    };\n+    \n+    if !status { ret status }\n+\n+    // 2. Each tree edge connects vertices whose BFS levels differ by\n+    //    exactly one.\n+\n+    log(info, \"Verifying tree edges...\");\n+\n+    let status = tree.alli() {|k, parent|\n+        if parent != root && parent != -1i64 {\n+            level[parent] == level[k] - 1\n+        }\n+        else {\n+            true\n+        }\n+    };\n+\n+    if !status { ret status }\n+\n+    // 3. Every edge in the input list has vertices with levels that\n+    //    differ by at most one or that both are not in the BFS tree.\n+\n+    log(info, \"Verifying graph edges...\");\n+\n+    let status = edges.all() {|e| \n+        let (u, v) = e;\n+\n+        abs(level[u] - level[v]) <= 1\n+    };\n+\n+    if !status { ret status }    \n+\n+    // 4. The BFS tree spans an entire connected component's vertices.\n+\n+    // This is harder. We'll skip it for now...\n+\n+    // 5. A node and its parent are joined by an edge of the original\n+    //    graph.\n+\n+    log(info, \"Verifying tree and graph edges...\");\n+\n+    let status = par::alli(tree) {|u, v|\n+        let u = u as node_id;\n+        if v == -1i64 || u == root {\n+            true\n+        }\n+        else {\n+            edges.contains((u, v)) || edges.contains((v, u))\n+        }\n+    };\n+\n+    if !status { ret status }    \n+\n+    // If we get through here, all the tests passed!\n+    true\n+}\n+\n+fn main() {\n+    let scale = 10u;\n+    let num_keys = 16u;\n+    let do_validate = false;\n+    let do_sequential = true;\n+\n+    let start = time::precise_time_s();\n+    let edges = make_edges(scale, 16u);\n+    let stop = time::precise_time_s();\n+\n+    io::stdout().write_line(#fmt(\"Generated %? edges in %? seconds.\",\n+                                 vec::len(edges), stop - start));\n+\n+    let start = time::precise_time_s();\n+    let graph = make_graph(1u << scale, edges);\n+    let stop = time::precise_time_s();\n+\n+    let mut total_edges = 0u;\n+    vec::each(graph) {|edges| total_edges += edges.len(); true };\n+\n+    io::stdout().write_line(#fmt(\"Generated graph with %? edges in %? seconds.\",\n+                                 total_edges / 2u,\n+                                 stop - start));\n+\n+    let mut total_seq = 0.0;\n+    let mut total_par = 0.0;\n+\n+    gen_search_keys(graph, num_keys).map() {|root|\n+        io::stdout().write_line(\"\");\n+        io::stdout().write_line(#fmt(\"Search key: %?\", root));\n+\n+        if do_sequential {\n+            let start = time::precise_time_s();\n+            let bfs_tree = bfs(graph, root);\n+            let stop = time::precise_time_s();\n+            \n+            //total_seq += stop - start;\n+\n+            io::stdout().write_line(\n+                #fmt(\"Sequential BFS completed in %? seconds.\",\n+                     stop - start));\n+            \n+            if do_validate {\n+                let start = time::precise_time_s();\n+                assert(validate(edges, root, bfs_tree));\n+                let stop = time::precise_time_s();\n+                \n+                io::stdout().write_line(\n+                    #fmt(\"Validation completed in %? seconds.\",\n+                         stop - start));\n+            }\n+            \n+            let start = time::precise_time_s();\n+            let bfs_tree = bfs2(graph, root);\n+            let stop = time::precise_time_s();\n+            \n+            total_seq += stop - start;\n+            \n+            io::stdout().write_line(\n+                #fmt(\"Alternate Sequential BFS completed in %? seconds.\",\n+                     stop - start));\n+            \n+            if do_validate {\n+                let start = time::precise_time_s();\n+                assert(validate(edges, root, bfs_tree));\n+                let stop = time::precise_time_s();\n+                \n+                io::stdout().write_line(\n+                    #fmt(\"Validation completed in %? seconds.\",\n+                         stop - start));\n+            }\n+        }\n+        \n+        let start = time::precise_time_s();\n+        let bfs_tree = pbfs(graph, root);\n+        let stop = time::precise_time_s();\n+\n+        total_par += stop - start;\n+\n+        io::stdout().write_line(#fmt(\"Parallel BFS completed in %? seconds.\",\n+                                     stop - start));\n+\n+        if do_validate {\n+            let start = time::precise_time_s();\n+            assert(validate(edges, root, bfs_tree));\n+            let stop = time::precise_time_s();\n+            \n+            io::stdout().write_line(#fmt(\"Validation completed in %? seconds.\",\n+                                         stop - start));\n+        }\n+    };\n+\n+    io::stdout().write_line(\"\");\n+    io::stdout().write_line(\n+        #fmt(\"Total sequential: %? \\t Total Parallel: %? \\t Speedup: %?x\",\n+             total_seq, total_par, total_seq / total_par));\n+}\n+\n+\n+// par stuff /////////////////////////////////////////////////////////\n+\n+mod par {\n+import comm::port;\n+import comm::chan;\n+import comm::send;\n+import comm::recv;\n+import future::future;\n+\n+#[doc=\"The maximum number of tasks this module will spawn for a single\n+ operationg.\"]\n+const max_tasks : uint = 32u;\n+\n+#[doc=\"The minimum number of elements each task will process.\"]\n+const min_granularity : uint = 1024u;\n+\n+#[doc=\"An internal helper to map a function over a large vector and\n+ return the intermediate results.\n+\n+This is used to build most of the other parallel vector functions,\n+like map or alli.\"]\n+fn map_slices<A: copy send, B: copy send>(xs: [A],\n+                                          f: fn~(uint, [const A]/&) -> B) \n+    -> [B] {\n+\n+    let len = xs.len();\n+    if len < min_granularity {\n+        log(info, \"small slice\");\n+        // This is a small vector, fall back on the normal map.\n+        [f(0u, xs)]\n+    }\n+    else {\n+        let num_tasks = uint::min(max_tasks, len / min_granularity);\n+\n+        let items_per_task = len / num_tasks;\n+\n+        let mut futures = [];\n+        let mut base = 0u;\n+        log(info, \"spawning tasks\");\n+        while base < len {\n+            let end = uint::min(len, base + items_per_task);\n+            // FIXME: why is the ::<A, ()> annotation required here?\n+            vec::unpack_slice::<A, ()>(xs) {|p, _len|\n+                let f = ptr::addr_of(f);\n+                futures += [future::spawn() {|copy base|\n+                    unsafe {\n+                        let len = end - base;\n+                        let slice = (ptr::offset(p, base),\n+                                     len * sys::size_of::<A>());\n+                        log(info, #fmt(\"pre-slice: %?\", (base, slice)));\n+                        let slice : [const A]/& = \n+                            unsafe::reinterpret_cast(slice);\n+                        log(info, #fmt(\"slice: %?\",\n+                                       (base, vec::len(slice), end - base)));\n+                        assert(vec::len(slice) == end - base);\n+                        (*f)(base, slice)\n+                    }\n+                }];\n+            };\n+            base += items_per_task;\n+        }\n+        log(info, \"tasks spawned\");\n+\n+        log(info, #fmt(\"num_tasks: %?\", (num_tasks, futures.len())));\n+        assert(num_tasks == futures.len());\n+\n+        let r = futures.map() {|ys|\n+            ys.get()\n+        };\n+        assert(r.len() == futures.len());\n+        r\n+    }\n+}\n+\n+#[doc=\"A parallel version of map.\"]\n+fn map<A: copy send, B: copy send>(xs: [A], f: fn~(A) -> B) -> [B] {\n+    vec::concat(map_slices(xs) {|_base, slice|\n+        vec::map(slice, f)\n+    })\n+}\n+\n+#[doc=\"A parallel version of mapi.\"]\n+fn mapi<A: copy send, B: copy send>(xs: [A], f: fn~(uint, A) -> B) -> [B] {\n+    let slices = map_slices(xs) {|base, slice|\n+        vec::mapi(slice) {|i, x|\n+            f(i + base, x)\n+        }\n+    };\n+    let r = vec::concat(slices);\n+    log(info, (r.len(), xs.len()));\n+    assert(r.len() == xs.len());\n+    r\n+}\n+\n+#[doc=\"Returns true if the function holds for all elements in the vector.\"]\n+fn alli<A: copy send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n+    vec::all(map_slices(xs) {|base, slice|\n+        vec::alli(slice) {|i, x|\n+            f(i + base, x)\n+        }\n+    }) {|x| x }\n+}\n+\n+    #[doc=\"Returns true if the function holds for any elements in the vector.\"]\n+    fn any<A: copy send>(xs: [A], f: fn~(A) -> bool) -> bool {\n+        vec::any(map_slices(xs) {|_base, slice|\n+            vec::any(slice, f)\n+        }) {|x| x }\n+    }\n+\n+}\n\\ No newline at end of file"}, {"sha": "3e5a501e69130984ea3c3e4f61d4e7a6c93c84c1", "filename": "src/test/compile-fail/kindck-nonsendable-2.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/507b8e5ae074bd24ac78d155f421f78200a5b400/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507b8e5ae074bd24ac78d155f421f78200a5b400/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-2.rs?ref=507b8e5ae074bd24ac78d155f421f78200a5b400", "patch": "@@ -1,17 +0,0 @@\n-fn foo(_x: r) {}\n-\n-resource r(_x: ()) {}\n-\n-fn main() {\n-    let x = r(());\n-    let _ = fn~() {\n-        // Error even though this is the last use:\n-        foo(x); //! ERROR not a sendable value\n-    };\n-\n-    let x = r(());\n-    let _ = fn@() {\n-        // OK in fn@ because this is the last use:\n-        foo(x);\n-    };\n-}\n\\ No newline at end of file"}, {"sha": "1a07b3f1de0e09a058ade143289db424ab92efc3", "filename": "src/test/compile-fail/pinned-deep-copy.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/507b8e5ae074bd24ac78d155f421f78200a5b400/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507b8e5ae074bd24ac78d155f421f78200a5b400/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs?ref=507b8e5ae074bd24ac78d155f421f78200a5b400", "patch": "@@ -1,16 +0,0 @@\n-// error-pattern: copying a noncopyable value\n-\n-resource r(i: @mut int) {\n-    *i = *i + 1;\n-}\n-\n-fn main() {\n-    let i = @mut 0;\n-    {\n-        // Can't do this copy\n-        let x = ~~~{y: r(i)};\n-        let z = x;\n-        log(debug, x);\n-    }\n-    log(error, *i);\n-}\n\\ No newline at end of file"}, {"sha": "ab599a44c0b183c8fa57748bda0f839f33fe2194", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -13,7 +13,7 @@ fn make_cycle<A:copy>(a: A) {\n     g.rec = some(g);\n }\n \n-fn f<A:send,B:send>(a: A, b: B) -> fn@() -> (A, B) {\n+fn f<A:send copy, B:send copy>(a: A, b: B) -> fn@() -> (A, B) {\n     fn@() -> (A, B) { (a, b) }\n }\n "}, {"sha": "87b71788e2880f506572b2fd9ac428273c6c08b4", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -47,7 +47,6 @@ fn test_char() {\n     assert (ch10 / ch4 == ch2);\n     assert (ch10 % ch4 == ch2);\n     assert (ch10 >> ch2 == ch2);\n-    assert (ch10 >>> ch2 == ch2);\n     assert (ch10 << ch4 == 160 as char);\n     assert (ch10 | ch4 == 14 as char);\n     assert (ch10 & ch2 == ch2);"}, {"sha": "f4178aad6fa3d74f77685f86eead03858651da7c", "filename": "src/test/run-pass/bitwise.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Fbitwise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Fbitwise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitwise.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -2,12 +2,12 @@\n \n #[cfg(target_arch = \"x86\")]\n fn target() {\n-    assert (-1000 >> 3 == 536870787);\n+    assert (-1000 as uint >> 3u == 536870787u);\n }\n \n #[cfg(target_arch = \"x86_64\")]\n fn target() {\n-    assert (-1000 >> 3 == 2305843009213693827);\n+    assert (-1000 as uint >> 3u == 2305843009213693827u);\n }\n \n fn general() {\n@@ -24,7 +24,7 @@ fn general() {\n     assert (0xf0 | 0xf == 0xff);\n     assert (0xf << 4 == 0xf0);\n     assert (0xf0 >> 4 == 0xf);\n-    assert (-16 >>> 2 == -4);\n+    assert (-16 >> 2 == -4);\n     assert (0b1010_1010 | 0b0101_0101 == 0xff);\n }\n "}, {"sha": "4d2811da7b1454bfb8e8b16196b971a3baa00e24", "filename": "src/test/run-pass/generic-alias-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<T: send>(t: T) -> T { ret t; }\n+fn id<T: copy send>(t: T) -> T { ret t; }\n \n fn main() {\n     let expected = ~100;"}, {"sha": "86af4e99fbcdbd9ff4409fe18c7f08f190b60fdd", "filename": "src/test/run-pass/resolve-issue-2428.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Fresolve-issue-2428.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Fresolve-issue-2428.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresolve-issue-2428.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -0,0 +1,5 @@\n+// xfail-test\n+\n+const foo: int = 4 >> 1;\n+enum bs { thing = foo }\n+fn main() { assert(thing as int == foo); }"}, {"sha": "666f253c9a12d04f3fdccf8d2a824611b52fc4f8", "filename": "src/test/run-pass/send-resource.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -0,0 +1,20 @@\n+import task::*;\n+import comm::*;\n+\n+resource test(_f: int) {\n+    // Do nothing\n+}\n+\n+fn main() {\n+    let p = port();\n+    let c = chan(p);\n+\n+    spawn() {||\n+        let p = port();\n+        c.send(chan(p));\n+\n+        let _r = p.recv();\n+    }\n+\n+    p.recv().send(test(42));\n+}\n\\ No newline at end of file"}, {"sha": "665f322de28165cc7d3eaa73450f934ceda1c111", "filename": "src/test/run-pass/shift.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Fshift.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10c19215e4c234e25c25b57983eeb42774f873/src%2Ftest%2Frun-pass%2Fshift.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshift.rs?ref=4f10c19215e4c234e25c25b57983eeb42774f873", "patch": "@@ -16,71 +16,56 @@ fn test_expr() {\n     let v4 = 4 as u8;\n     let v2 = 2 as u8;\n     assert (v10 >> v2 == v2 as uint);\n-    assert (v10 >>> v2 == v2 as uint);\n     assert (v10 << v4 == 160 as uint);\n \n     let v10 = 10 as u8;\n     let v4 = 4 as uint;\n     let v2 = 2 as uint;\n     assert (v10 >> v2 == v2 as u8);\n-    assert (v10 >>> v2 == v2 as u8);\n     assert (v10 << v4 == 160 as u8);\n \n     let v10 = 10 as int;\n     let v4 = 4 as i8;\n     let v2 = 2 as i8;\n     assert (v10 >> v2 == v2 as int);\n-    assert (v10 >>> v2 == v2 as int);\n     assert (v10 << v4 == 160 as int);\n \n     let v10 = 10 as i8;\n     let v4 = 4 as int;\n     let v2 = 2 as int;\n     assert (v10 >> v2 == v2 as i8);\n-    assert (v10 >>> v2 == v2 as i8);\n     assert (v10 << v4 == 160 as i8);\n \n     let v10 = 10 as uint;\n     let v4 = 4 as int;\n     let v2 = 2 as int;\n     assert (v10 >> v2 == v2 as uint);\n-    assert (v10 >>> v2 == v2 as uint);\n     assert (v10 << v4 == 160 as uint);\n }\n \n fn test_const() {\n     const r1_1: uint = 10u >> 2u8;\n-    const r2_1: uint = 10u >>> 2u8;\n-    const r3_1: uint = 10u << 4u8;\n+    const r2_1: uint = 10u << 4u8;\n     assert r1_1 == 2 as uint;\n-    assert r2_1 == 2 as uint;\n-    assert r3_1 == 160 as uint;\n+    assert r2_1 == 160 as uint;\n \n     const r1_2: u8 = 10u8 >> 2u;\n-    const r2_2: u8 = 10u8 >>> 2u;\n-    const r3_2: u8 = 10u8 << 4u;\n+    const r2_2: u8 = 10u8 << 4u;\n     assert r1_2 == 2 as u8;\n-    assert r2_2 == 2 as u8;\n-    assert r3_2 == 160 as u8;\n+    assert r2_2 == 160 as u8;\n \n     const r1_3: int = 10 >> 2i8;\n-    const r2_3: int = 10 >>> 2i8;\n-    const r3_3: int = 10 << 4i8;\n+    const r2_3: int = 10 << 4i8;\n     assert r1_3 == 2 as int;\n-    assert r2_3 == 2 as int;\n-    assert r3_3 == 160 as int;\n+    assert r2_3 == 160 as int;\n \n     const r1_4: i8 = 10i8 >> 2;\n-    const r2_4: i8 = 10i8 >>> 2;\n-    const r3_4: i8 = 10i8 << 4;\n+    const r2_4: i8 = 10i8 << 4;\n     assert r1_4 == 2 as i8;\n-    assert r2_4 == 2 as i8;\n-    assert r3_4 == 160 as i8;\n+    assert r2_4 == 160 as i8;\n \n     const r1_5: uint = 10u >> 2i8;\n-    const r2_5: uint = 10u >>> 2i8;\n-    const r3_5: uint = 10u << 4i8;\n+    const r2_5: uint = 10u << 4i8;\n     assert r1_5 == 2 as uint;\n-    assert r2_5 == 2 as uint;\n-    assert r3_5 == 160 as uint;\n+    assert r2_5 == 160 as uint;\n }"}]}