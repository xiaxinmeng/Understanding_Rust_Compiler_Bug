{"sha": "92145373c350d1e41b852aa0332218f614a85bc3", "node_id": "C_kwDOAAsO6NoAKDkyMTQ1MzczYzM1MGQxZTQxYjg1MmFhMDMzMjIxOGY2MTRhODViYzM", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-16T22:05:36Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:55Z"}, "message": "Put the initialisation value into the store buffer", "tree": {"sha": "1e892a1255a904f98daf4c6cf924b7dcbf22a5c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e892a1255a904f98daf4c6cf924b7dcbf22a5c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92145373c350d1e41b852aa0332218f614a85bc3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRFsACgkQGBtJ+fOP\nM3TN8gwAkXWPVPQQ1EweNDBrDxJzNS9Pl96TWthDZ99DwTNvajpEIeCP8gyZMYz8\nI/fJ652IQKAxEFZVKGTI6h2K3Sthtn1ooScaQh3m8SskzPYckyX3/M5XE7Z6CUdO\nduQRE6Arm3AuMJAvKn+bwDQ7Ik/faVyOrNxM0+vfgoGgyN72V7C5foBkoylVgjP0\n1rZaXBP1TlOQ8+3ZD5y0At2nkP+UUMP9amJb0pZH8yrhpDFuPDVwsaOoN/ijVA3d\nVQFvLXfdRGAw3s/z/v+Nzh4oZMPvfakxO7vfcnJmHxLiq5hyTCS5nCLObxJQPKYy\nf6ZgfgLcpycjzgHHkliRDUd9bOLmIDydtN3t3yGSUd/aLf8N2+s6HMcWg4HQ21gF\nyluP8XNiZUU31d0T7C0HzKDqD9e2mwmSMs510k+mLJsksC/pZjTyR4nbqL8PUN/r\npgDDOz5nYsh58BOcVBBkkLPnUCYn93E8PtbcBtxri8RVtDc/yXiUJY/wO89Lja8T\nKtJ+t3nh\n=SO/t\n-----END PGP SIGNATURE-----", "payload": "tree 1e892a1255a904f98daf4c6cf924b7dcbf22a5c4\nparent 577054c6ded13a70ee07d6fc3397518ae1e81710\nauthor Andy Wang <cbeuw.andy@gmail.com> 1652738736 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539355 +0100\n\nPut the initialisation value into the store buffer\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92145373c350d1e41b852aa0332218f614a85bc3", "html_url": "https://github.com/rust-lang/rust/commit/92145373c350d1e41b852aa0332218f614a85bc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92145373c350d1e41b852aa0332218f614a85bc3/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "577054c6ded13a70ee07d6fc3397518ae1e81710", "url": "https://api.github.com/repos/rust-lang/rust/commits/577054c6ded13a70ee07d6fc3397518ae1e81710", "html_url": "https://github.com/rust-lang/rust/commit/577054c6ded13a70ee07d6fc3397518ae1e81710"}], "stats": {"total": 184, "additions": 134, "deletions": 50}, "files": [{"sha": "2d69d02a100f5daabe8c2dc357076e4f2a646bda", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/92145373c350d1e41b852aa0332218f614a85bc3/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92145373c350d1e41b852aa0332218f614a85bc3/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=92145373c350d1e41b852aa0332218f614a85bc3", "patch": "@@ -533,7 +533,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         this.allow_data_races_mut(move |this| this.write_scalar(val, &(*dest).into()))?;\n         this.validate_atomic_store(dest, atomic)?;\n-        this.buffered_atomic_write(val, dest, atomic)\n+        // FIXME: it's not possible to get the value before write_scalar. A read_scalar will cause\n+        // side effects from a read the program did not perform. So we have to initialise\n+        // the store buffer with the value currently being written\n+        // ONCE this is fixed please remove the hack in buffered_atomic_write() in weak_memory.rs\n+        this.buffered_atomic_write(val, dest, atomic, val)\n     }\n \n     /// Perform an atomic operation on a memory location.\n@@ -556,7 +560,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n \n         this.validate_atomic_rmw(place, atomic)?;\n \n-        this.buffered_atomic_rmw(val.to_scalar_or_uninit(), place, atomic)?;\n+        this.buffered_atomic_rmw(\n+            val.to_scalar_or_uninit(),\n+            place,\n+            atomic,\n+            old.to_scalar_or_uninit(),\n+        )?;\n         Ok(old)\n     }\n \n@@ -575,7 +584,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n \n         this.validate_atomic_rmw(place, atomic)?;\n \n-        this.buffered_atomic_rmw(new, place, atomic)?;\n+        this.buffered_atomic_rmw(new, place, atomic, old)?;\n         Ok(old)\n     }\n \n@@ -603,7 +612,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n \n         this.validate_atomic_rmw(place, atomic)?;\n \n-        this.buffered_atomic_rmw(new_val.to_scalar_or_uninit(), place, atomic)?;\n+        this.buffered_atomic_rmw(\n+            new_val.to_scalar_or_uninit(),\n+            place,\n+            atomic,\n+            old.to_scalar_or_uninit(),\n+        )?;\n \n         // Return the old value.\n         Ok(old)\n@@ -654,14 +668,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         if cmpxchg_success {\n             this.allow_data_races_mut(|this| this.write_scalar(new, &(*place).into()))?;\n             this.validate_atomic_rmw(place, success)?;\n-            this.buffered_atomic_rmw(new, place, success)?;\n+            this.buffered_atomic_rmw(new, place, success, old.to_scalar_or_uninit())?;\n         } else {\n             this.validate_atomic_load(place, fail)?;\n             // A failed compare exchange is equivalent to a load, reading from the latest store\n             // in the modification order.\n             // Since `old` is only a value and not the store element, we need to separately\n             // find it in our store buffer and perform load_impl on it.\n-            this.perform_read_on_buffered_latest(place, fail)?;\n+            this.perform_read_on_buffered_latest(place, fail, old.to_scalar_or_uninit())?;\n         }\n \n         // Return the old value."}, {"sha": "1cb9fba715269210fb955e34c1f15690a8050e40", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 69, "deletions": 40, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/92145373c350d1e41b852aa0332218f614a85bc3/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92145373c350d1e41b852aa0332218f614a85bc3/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=92145373c350d1e41b852aa0332218f614a85bc3", "patch": "@@ -81,11 +81,11 @@ const STORE_BUFFER_LIMIT: usize = 128;\n pub struct StoreBufferAlloc {\n     /// Store buffer of each atomic object in this allocation\n     // Behind a RefCell because we need to allocate/remove on read access\n-    store_buffer: RefCell<AllocationMap<StoreBuffer>>,\n+    store_buffers: RefCell<AllocationMap<StoreBuffer>>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-struct StoreBuffer {\n+pub(super) struct StoreBuffer {\n     // Stores to this location in modification order\n     buffer: VecDeque<StoreElement>,\n }\n@@ -111,21 +111,23 @@ struct StoreElement {\n \n impl StoreBufferAlloc {\n     pub fn new_allocation() -> Self {\n-        Self { store_buffer: RefCell::new(AllocationMap::new()) }\n+        Self { store_buffers: RefCell::new(AllocationMap::new()) }\n     }\n \n     /// Gets a store buffer associated with an atomic object in this allocation\n-    fn get_store_buffer<'tcx>(\n+    /// Or creates one with the specified initial value\n+    fn get_or_create_store_buffer<'tcx>(\n         &self,\n         range: AllocRange,\n+        init: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx, Ref<'_, StoreBuffer>> {\n-        let access_type = self.store_buffer.borrow().access_type(range);\n+        let access_type = self.store_buffers.borrow().access_type(range);\n         let pos = match access_type {\n             AccessType::PerfectlyOverlapping(pos) => pos,\n             AccessType::Empty(pos) => {\n-                // First atomic access on this range, allocate a new StoreBuffer\n-                let mut buffer = self.store_buffer.borrow_mut();\n-                buffer.insert_at_pos(pos, range, StoreBuffer::default());\n+                let new_buffer = StoreBuffer::new(init);\n+                let mut buffers = self.store_buffers.borrow_mut();\n+                buffers.insert_at_pos(pos, range, new_buffer);\n                 pos\n             }\n             AccessType::ImperfectlyOverlapping(pos_range) => {\n@@ -140,20 +142,22 @@ impl StoreBufferAlloc {\n                 }\n             }\n         };\n-        Ok(Ref::map(self.store_buffer.borrow(), |buffer| &buffer[pos]))\n+        Ok(Ref::map(self.store_buffers.borrow(), |buffer| &buffer[pos]))\n     }\n \n     /// Gets a mutable store buffer associated with an atomic object in this allocation\n-    fn get_store_buffer_mut<'tcx>(\n+    fn get_or_create_store_buffer_mut<'tcx>(\n         &mut self,\n         range: AllocRange,\n+        init: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx, &mut StoreBuffer> {\n-        let buffer = self.store_buffer.get_mut();\n-        let access_type = buffer.access_type(range);\n+        let buffers = self.store_buffers.get_mut();\n+        let access_type = buffers.access_type(range);\n         let pos = match access_type {\n             AccessType::PerfectlyOverlapping(pos) => pos,\n             AccessType::Empty(pos) => {\n-                buffer.insert_at_pos(pos, range, StoreBuffer::default());\n+                let new_buffer = StoreBuffer::new(init);\n+                buffers.insert_at_pos(pos, range, new_buffer);\n                 pos\n             }\n             AccessType::ImperfectlyOverlapping(pos_range) => {\n@@ -164,19 +168,28 @@ impl StoreBufferAlloc {\n                 }\n             }\n         };\n-        Ok(&mut buffer[pos])\n+        Ok(&mut buffers[pos])\n     }\n }\n \n-impl Default for StoreBuffer {\n-    fn default() -> Self {\n+impl<'mir, 'tcx: 'mir> StoreBuffer {\n+    fn new(init: ScalarMaybeUninit<Tag>) -> Self {\n         let mut buffer = VecDeque::new();\n         buffer.reserve(STORE_BUFFER_LIMIT);\n-        Self { buffer }\n+        let mut ret = Self { buffer };\n+        let store_elem = StoreElement {\n+            // The thread index and timestamp of the initialisation write\n+            // are never meaningfully used, so it's fine to leave them as 0\n+            store_index: VectorIdx::from(0),\n+            timestamp: 0,\n+            val: init,\n+            is_seqcst: false,\n+            loads: RefCell::new(FxHashMap::default()),\n+        };\n+        ret.buffer.push_back(store_elem);\n+        ret\n     }\n-}\n \n-impl<'mir, 'tcx: 'mir> StoreBuffer {\n     /// Reads from the last store in modification order\n     fn read_from_last_store(&self, global: &GlobalState) {\n         let store_elem = self.buffer.back();\n@@ -192,7 +205,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         is_seqcst: bool,\n         rng: &mut (impl rand::Rng + ?Sized),\n         validate: impl FnOnce() -> InterpResult<'tcx>,\n-    ) -> InterpResult<'tcx, Option<ScalarMaybeUninit<Tag>>> {\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         // Having a live borrow to store_buffer while calling validate_atomic_load is fine\n         // because the race detector doesn't touch store_buffer\n \n@@ -210,10 +223,8 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         // requires access to ThreadClockSet.clock, which is updated by the race detector\n         validate()?;\n \n-        let loaded = store_elem.map(|store_elem| {\n-            let (index, clocks) = global.current_thread_state();\n-            store_elem.load_impl(index, &clocks)\n-        });\n+        let (index, clocks) = global.current_thread_state();\n+        let loaded = store_elem.load_impl(index, &clocks);\n         Ok(loaded)\n     }\n \n@@ -230,23 +241,18 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n     }\n \n     /// Selects a valid store element in the buffer.\n-    /// The buffer does not contain the value used to initialise the atomic object\n-    /// so a fresh atomic object has an empty store buffer and this function\n-    /// will return `None`. In this case, the caller should ensure that the non-buffered\n-    /// value from `MiriEvalContext::read_scalar()` is observed by the program, which is\n-    /// the initial value of the atomic object. `MiriEvalContext::read_scalar()` is always\n-    /// the latest value in modification order so it is always correct to be observed by any thread.\n     fn fetch_store<R: rand::Rng + ?Sized>(\n         &self,\n         is_seqcst: bool,\n         clocks: &ThreadClockSet,\n         rng: &mut R,\n-    ) -> Option<&StoreElement> {\n+    ) -> &StoreElement {\n         use rand::seq::IteratorRandom;\n         let mut found_sc = false;\n-        // FIXME: this should be an inclusive take_while (stops after a false predicate, but\n+        // FIXME: we want an inclusive take_while (stops after a false predicate, but\n         // includes the element that gave the false), but such function doesn't yet\n         // exist in the standard libary https://github.com/rust-lang/rust/issues/62208\n+        // so we have to hack around it with keep_searching\n         let mut keep_searching = true;\n         let candidates = self\n             .buffer\n@@ -303,7 +309,9 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n                 }\n             });\n \n-        candidates.choose(rng)\n+        candidates\n+            .choose(rng)\n+            .expect(\"store buffer cannot be empty, an element is populated on construction\")\n     }\n \n     /// ATOMIC STORE IMPL in the paper (except we don't need the location's vector clock)\n@@ -366,6 +374,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         new_val: ScalarMaybeUninit<Tag>,\n         place: &MPlaceTy<'tcx, Tag>,\n         atomic: AtomicRwOp,\n+        init: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n@@ -379,7 +388,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                 global.sc_write();\n             }\n             let range = alloc_range(base_offset, place.layout.size);\n-            let buffer = alloc_buffers.get_store_buffer_mut(range)?;\n+            let buffer = alloc_buffers.get_or_create_store_buffer_mut(range, init)?;\n             buffer.read_from_last_store(global);\n             buffer.buffered_write(new_val, global, atomic == AtomicRwOp::SeqCst)?;\n         }\n@@ -401,16 +410,18 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                     global.sc_read();\n                 }\n                 let mut rng = this.machine.rng.borrow_mut();\n-                let buffer =\n-                    alloc_buffers.get_store_buffer(alloc_range(base_offset, place.layout.size))?;\n+                let buffer = alloc_buffers.get_or_create_store_buffer(\n+                    alloc_range(base_offset, place.layout.size),\n+                    latest_in_mo,\n+                )?;\n                 let loaded = buffer.buffered_read(\n                     global,\n                     atomic == AtomicReadOp::SeqCst,\n                     &mut *rng,\n                     validate,\n                 )?;\n \n-                return Ok(loaded.unwrap_or(latest_in_mo));\n+                return Ok(loaded);\n             }\n         }\n \n@@ -424,6 +435,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         val: ScalarMaybeUninit<Tag>,\n         dest: &MPlaceTy<'tcx, Tag>,\n         atomic: AtomicWriteOp,\n+        init: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(dest.ptr)?;\n@@ -435,8 +447,23 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n             if atomic == AtomicWriteOp::SeqCst {\n                 global.sc_write();\n             }\n-            let buffer =\n-                alloc_buffers.get_store_buffer_mut(alloc_range(base_offset, dest.layout.size))?;\n+\n+            // UGLY HACK: in write_scalar_atomic() we don't know the value before our write,\n+            // so init == val always. If the buffer is fresh then we would've duplicated an entry,\n+            // so we need to remove it.\n+            let was_empty = matches!(\n+                alloc_buffers\n+                    .store_buffers\n+                    .borrow()\n+                    .access_type(alloc_range(base_offset, dest.layout.size)),\n+                AccessType::Empty(_)\n+            );\n+            let buffer = alloc_buffers\n+                .get_or_create_store_buffer_mut(alloc_range(base_offset, dest.layout.size), init)?;\n+            if was_empty {\n+                buffer.buffer.pop_front();\n+            }\n+\n             buffer.buffered_write(val, global, atomic == AtomicWriteOp::SeqCst)?;\n         }\n \n@@ -451,6 +478,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         &self,\n         place: &MPlaceTy<'tcx, Tag>,\n         atomic: AtomicReadOp,\n+        init: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n \n@@ -461,7 +489,8 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n             let size = place.layout.size;\n             let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n             if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n-                let buffer = alloc_buffers.get_store_buffer(alloc_range(base_offset, size))?;\n+                let buffer = alloc_buffers\n+                    .get_or_create_store_buffer(alloc_range(base_offset, size), init)?;\n                 buffer.read_from_last_store(global);\n             }\n         }"}, {"sha": "67f0e8d35dd31a2f25e5f770e909951e59f4f01f", "filename": "tests/run-pass/weak_memory/consistency.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/92145373c350d1e41b852aa0332218f614a85bc3/tests%2Frun-pass%2Fweak_memory%2Fconsistency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92145373c350d1e41b852aa0332218f614a85bc3/tests%2Frun-pass%2Fweak_memory%2Fconsistency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fweak_memory%2Fconsistency.rs?ref=92145373c350d1e41b852aa0332218f614a85bc3", "patch": "@@ -34,8 +34,6 @@ unsafe impl<T> Sync for EvilSend<T> {}\n // multiple times\n fn static_atomic(val: usize) -> &'static AtomicUsize {\n     let ret = Box::leak(Box::new(AtomicUsize::new(val)));\n-    // A workaround to put the initialisation value in the store buffer\n-    ret.store(val, Relaxed);\n     ret\n }\n \n@@ -205,8 +203,19 @@ fn test_sc_store_buffering() {\n     assert_ne!((a, b), (0, 0));\n }\n \n+fn test_single_thread() {\n+    let x = AtomicUsize::new(42);\n+\n+    assert_eq!(x.load(Relaxed), 42);\n+\n+    x.store(43, Relaxed);\n+\n+    assert_eq!(x.load(Relaxed), 43);\n+}\n+\n pub fn main() {\n     for _ in 0..100 {\n+        test_single_thread();\n         test_mixed_access();\n         test_load_buffering_acq_rel();\n         test_message_passing();"}, {"sha": "75380381922d2323f25c9dd26940ec9c54914807", "filename": "tests/run-pass/weak_memory/weak.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/92145373c350d1e41b852aa0332218f614a85bc3/tests%2Frun-pass%2Fweak_memory%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92145373c350d1e41b852aa0332218f614a85bc3/tests%2Frun-pass%2Fweak_memory%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fweak_memory%2Fweak.rs?ref=92145373c350d1e41b852aa0332218f614a85bc3", "patch": "@@ -22,11 +22,17 @@ unsafe impl<T> Sync for EvilSend<T> {}\n // multiple times\n fn static_atomic(val: usize) -> &'static AtomicUsize {\n     let ret = Box::leak(Box::new(AtomicUsize::new(val)));\n-    // A workaround to put the initialisation value in the store buffer\n-    ret.store(val, Relaxed);\n     ret\n }\n \n+// Spins until it reads the given value\n+fn reads_value(loc: &AtomicUsize, val: usize) -> usize {\n+    while loc.load(Relaxed) != val {\n+        std::hint::spin_loop();\n+    }\n+    val\n+}\n+\n fn relaxed() -> bool {\n     let x = static_atomic(0);\n     let j1 = spawn(move || {\n@@ -64,6 +70,31 @@ fn seq_cst() -> bool {\n     r3 == 1\n }\n \n+fn initialization_write() -> bool {\n+    let x = static_atomic(11);\n+    assert_eq!(x.load(Relaxed), 11);\n+\n+    let wait = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(22, Relaxed);\n+        // Relaxed is intentional. We want to test if the thread 2 reads the initialisation write\n+        // after a relaxed write\n+        wait.store(1, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        reads_value(wait, 1);\n+        x.load(Relaxed)\n+    });\n+\n+    j1.join().unwrap();\n+    let r2 = j2.join().unwrap();\n+\n+    r2 == 11\n+}\n+\n+\n // Asserts that the function returns true at least once in 100 runs\n macro_rules! assert_once {\n     ($f:ident) => {\n@@ -74,4 +105,5 @@ macro_rules! assert_once {\n pub fn main() {\n     assert_once!(relaxed);\n     assert_once!(seq_cst);\n+    assert_once!(initialization_write);\n }"}]}