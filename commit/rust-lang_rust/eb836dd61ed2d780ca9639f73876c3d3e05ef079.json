{"sha": "eb836dd61ed2d780ca9639f73876c3d3e05ef079", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViODM2ZGQ2MWVkMmQ3ODBjYTk2MzlmNzM4NzZjM2QzZTA1ZWYwNzk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-24T01:14:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-24T19:48:10Z"}, "message": "Settle on the format/write/print family of names", "tree": {"sha": "eaf2ec2ed5b7ab0087f33b3199f04f04e7cf2e68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaf2ec2ed5b7ab0087f33b3199f04f04e7cf2e68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb836dd61ed2d780ca9639f73876c3d3e05ef079", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb836dd61ed2d780ca9639f73876c3d3e05ef079", "html_url": "https://github.com/rust-lang/rust/commit/eb836dd61ed2d780ca9639f73876c3d3e05ef079", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb836dd61ed2d780ca9639f73876c3d3e05ef079/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67512f717e7592d347fc825d2917b786a19b78bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/67512f717e7592d347fc825d2917b786a19b78bd", "html_url": "https://github.com/rust-lang/rust/commit/67512f717e7592d347fc825d2917b786a19b78bd"}], "stats": {"total": 550, "additions": 295, "deletions": 255}, "files": [{"sha": "daf8c4afb0774d4169d56b6a2b8c7a3659b98325", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=eb836dd61ed2d780ca9639f73876c3d3e05ef079", "patch": "@@ -12,33 +12,33 @@\n \n # The Formatting Module\n \n-This module contains the runtime support for the `ifmt!` syntax extension. This\n+This module contains the runtime support for the `format!` syntax extension. This\n macro is implemented in the compiler to emit calls to this module in order to\n format arguments at runtime into strings and streams.\n \n The functions contained in this module should not normally be used in everyday\n-use cases of `ifmt!`. The assumptions made by these functions are unsafe for all\n+use cases of `format!`. The assumptions made by these functions are unsafe for all\n inputs, and the compiler performs a large amount of validation on the arguments\n-to `ifmt!` in order to ensure safety at runtime. While it is possible to call\n+to `format!` in order to ensure safety at runtime. While it is possible to call\n these functions directly, it is not recommended to do so in the general case.\n \n ## Usage\n \n-The `ifmt!` macro is intended to be familiar to those coming from C's\n-printf/sprintf functions or Python's `str.format` function. In its current\n-revision, the `ifmt!` macro returns a `~str` type which is the result of the\n+The `format!` macro is intended to be familiar to those coming from C's\n+printf/fprintf functions or Python's `str.format` function. In its current\n+revision, the `format!` macro returns a `~str` type which is the result of the\n formatting. In the future it will also be able to pass in a stream to format\n arguments directly while performing minimal allocations.\n \n-Some examples of the `ifmt!` extension are:\n+Some examples of the `format!` extension are:\n \n ~~~{.rust}\n-ifmt!(\"Hello\")                  // => ~\"Hello\"\n-ifmt!(\"Hello, {:s}!\", \"world\")  // => ~\"Hello, world!\"\n-ifmt!(\"The number is {:d}\", 1)  // => ~\"The number is 1\"\n-ifmt!(\"{}\", ~[3, 4])            // => ~\"~[3, 4]\"\n-ifmt!(\"{value}\", value=4)       // => ~\"4\"\n-ifmt!(\"{} {}\", 1, 2)            // => ~\"1 2\"\n+format!(\"Hello\")                  // => ~\"Hello\"\n+format!(\"Hello, {:s}!\", \"world\")  // => ~\"Hello, world!\"\n+format!(\"The number is {:d}\", 1)  // => ~\"The number is 1\"\n+format!(\"{}\", ~[3, 4])            // => ~\"~[3, 4]\"\n+format!(\"{value}\", value=4)       // => ~\"4\"\n+format!(\"{} {}\", 1, 2)            // => ~\"1 2\"\n ~~~\n \n From these, you can see that the first argument is a format string. It is\n@@ -62,7 +62,7 @@ format string, although it must always be referred to with the same type.\n ### Named parameters\n \n Rust itself does not have a Python-like equivalent of named parameters to a\n-function, but the `ifmt!` macro is a syntax extension which allows it to\n+function, but the `format!` macro is a syntax extension which allows it to\n leverage named parameters. Named parameters are listed at the end of the\n argument list and have the syntax:\n \n@@ -146,7 +146,7 @@ helper methods.\n \n ## Internationalization\n \n-The formatting syntax supported by the `ifmt!` extension supports\n+The formatting syntax supported by the `format!` extension supports\n internationalization by providing \"methods\" which execute various different\n outputs depending on the input. The syntax and methods provided are similar to\n other internationalization systems, so again nothing should seem alien.\n@@ -164,7 +164,7 @@ to reference the string value of the argument which was selected upon. As an\n example:\n \n ~~~\n-ifmt!(\"{0, select, other{#}}\", \"hello\") // => ~\"hello\"\n+format!(\"{0, select, other{#}}\", \"hello\") // => ~\"hello\"\n ~~~\n \n This example is the equivalent of `{0:s}` essentially.\n@@ -399,11 +399,11 @@ pub trait Pointer { fn fmt(&Self, &mut Formatter); }\n #[allow(missing_doc)]\n pub trait Float { fn fmt(&Self, &mut Formatter); }\n \n-/// The fprintf function takes an output stream, a precompiled format string,\n+/// The `write` function takes an output stream, a precompiled format string,\n /// and a list of arguments. The arguments will be formatted according to the\n /// specified format string into the output stream provided.\n ///\n-/// See the documentation for `sprintf` for why this function is unsafe and care\n+/// See the documentation for `format` for why this function is unsafe and care\n /// should be taken if calling it manually.\n ///\n /// Thankfully the rust compiler provides the macro `fmtf!` which will perform\n@@ -419,8 +419,8 @@ pub trait Float { fn fmt(&Self, &mut Formatter); }\n ///\n /// Note that this function assumes that there are enough arguments for the\n /// format string.\n-pub unsafe fn fprintf(output: &mut io::Writer,\n-                      fmt: &[rt::Piece], args: &[Argument]) {\n+pub unsafe fn write(output: &mut io::Writer,\n+                    fmt: &[rt::Piece], args: &[Argument]) {\n     let mut formatter = Formatter {\n         flags: 0,\n         width: None,\n@@ -436,7 +436,7 @@ pub unsafe fn fprintf(output: &mut io::Writer,\n     }\n }\n \n-/// The sprintf function takes a precompiled format string and a list of\n+/// The format function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string.\n ///\n /// This is currently an unsafe function because the types of all arguments\n@@ -446,7 +446,7 @@ pub unsafe fn fprintf(output: &mut io::Writer,\n /// for formatting the right type value. Because of this, the function is marked\n /// as `unsafe` if this is being called manually.\n ///\n-/// Thankfully the rust compiler provides the macro `ifmt!` which will perform\n+/// Thankfully the rust compiler provides the macro `format!` which will perform\n /// all of this validation at compile-time and provides a safe interface for\n /// invoking this function.\n ///\n@@ -458,17 +458,17 @@ pub unsafe fn fprintf(output: &mut io::Writer,\n ///\n /// Note that this function assumes that there are enough arguments for the\n /// format string.\n-pub unsafe fn sprintf(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n+pub unsafe fn format(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n     let mut output = MemWriter::new();\n-    fprintf(&mut output as &mut io::Writer, fmt, args);\n+    write(&mut output as &mut io::Writer, fmt, args);\n     return str::from_bytes_owned(output.inner());\n }\n \n impl<'self> Formatter<'self> {\n \n     // First up is the collection of functions used to execute a format string\n     // at runtime. This consumes all of the compile-time statics generated by\n-    // the ifmt! syntax extension.\n+    // the format! syntax extension.\n \n     fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) {\n         let setcount = |slot: &mut Option<uint>, cnt: &parse::Count| {\n@@ -732,7 +732,7 @@ impl<'self> Formatter<'self> {\n }\n \n /// This is a function which calls are emitted to by the compiler itself to\n-/// create the Argument structures that are passed into the `sprintf` function.\n+/// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)]\n pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter),\n                        t: &'a T) -> Argument<'a> {"}, {"sha": "6f9585652bd6852a78ffc6e5475633cb3dc9bee2", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=eb836dd61ed2d780ca9639f73876c3d3e05ef079", "patch": "@@ -139,10 +139,12 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 ext::tt::macro_rules::add_new_extension));\n     syntax_expanders.insert(intern(&\"fmt\"),\n                             builtin_normal_tt(ext::fmt::expand_syntax_ext));\n-    syntax_expanders.insert(intern(&\"ifmt\"),\n-                            builtin_normal_tt(ext::ifmt::expand_sprintf));\n-    syntax_expanders.insert(intern(&\"ifmtf\"),\n-                            builtin_normal_tt(ext::ifmt::expand_fprintf));\n+    syntax_expanders.insert(intern(&\"format\"),\n+                            builtin_normal_tt(ext::ifmt::expand_format));\n+    syntax_expanders.insert(intern(&\"write\"),\n+                            builtin_normal_tt(ext::ifmt::expand_write));\n+    syntax_expanders.insert(intern(&\"writeln\"),\n+                            builtin_normal_tt(ext::ifmt::expand_writeln));\n     syntax_expanders.insert(\n         intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));"}, {"sha": "49b8c994dc27686f2a651d421f0efd57a38a47d1", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=eb836dd61ed2d780ca9639f73876c3d3e05ef079", "patch": "@@ -940,6 +940,7 @@ pub fn std_macros() -> @str {\n         );\n     )\n \n+    // NOTE(acrichto): start removing this after the next snapshot\n     macro_rules! printf (\n         ($arg:expr) => (\n             print(fmt!(\\\"%?\\\", $arg))\n@@ -949,6 +950,7 @@ pub fn std_macros() -> @str {\n         )\n     )\n \n+    // NOTE(acrichto): start removing this after the next snapshot\n     macro_rules! printfln (\n         ($arg:expr) => (\n             println(fmt!(\\\"%?\\\", $arg))\n@@ -958,6 +960,21 @@ pub fn std_macros() -> @str {\n         )\n     )\n \n+    // FIXME(#6846) once stdio is redesigned, this shouldn't perform an\n+    //              allocation but should rather delegate to an invocation of\n+    //              write! instead of format!\n+    macro_rules! print (\n+        () => ();\n+        ($arg:expr) => ( ::std::io::print(format!(\\\"{}\\\", $arg)));\n+        ($fmt:expr, $($arg:tt)+) => ( ::std::io::print(format!($fmt, $($arg)+)))\n+    )\n+\n+    // FIXME(#6846) once stdio is redesigned, this shouldn't perform an\n+    //              allocation but should rather delegate to an io::Writer\n+    macro_rules! println (\n+        ($($arg:tt)*) => ({ print!($($arg)*); ::std::io::println(\\\"\\\"); })\n+    )\n+\n     // NOTE: use this after a snapshot lands to abstract the details\n     // of the TLS interface.\n     macro_rules! local_data_key ("}, {"sha": "d4274746a4eda838318c0189b35321f37dc0226e", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=eb836dd61ed2d780ca9639f73876c3d3e05ef079", "patch": "@@ -697,19 +697,24 @@ impl Context {\n     }\n }\n \n-pub fn expand_sprintf(ecx: @ExtCtxt, sp: span,\n-                      tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, false, \"sprintf\")\n+pub fn expand_format(ecx: @ExtCtxt, sp: span,\n+                     tts: &[ast::token_tree]) -> base::MacResult {\n+    expand_ifmt(ecx, sp, tts, false, false, \"format\")\n }\n \n-pub fn expand_fprintf(ecx: @ExtCtxt, sp: span,\n-                      tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, true, \"fprintf\")\n+pub fn expand_write(ecx: @ExtCtxt, sp: span,\n+                    tts: &[ast::token_tree]) -> base::MacResult {\n+    expand_ifmt(ecx, sp, tts, true, false, \"write\")\n }\n \n+pub fn expand_writeln(ecx: @ExtCtxt, sp: span,\n+                      tts: &[ast::token_tree]) -> base::MacResult {\n+    expand_ifmt(ecx, sp, tts, true, true, \"write\")\n+}\n \n fn expand_ifmt(ecx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n-               leading_arg: bool, function: &str) -> base::MacResult {\n+               leading_arg: bool, append_newline: bool,\n+               function: &str) -> base::MacResult {\n     let mut cx = Context {\n         ecx: ecx,\n         args: ~[],\n@@ -730,6 +735,7 @@ fn expand_ifmt(ecx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n     cx.fmtsp = efmt.span;\n     let fmt = expr_to_str(ecx, efmt,\n                           \"format argument must be a string literal.\");\n+    let fmt = if append_newline { fmt + \"\\n\" } else { fmt.to_owned() };\n \n     let mut err = false;\n     do parse::parse_error::cond.trap(|m| {"}, {"sha": "273394794a9965e69e5ce12a6670cd70db6ba91b", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=eb836dd61ed2d780ca9639f73876c3d3e05ef079", "patch": "@@ -9,66 +9,66 @@\n // except according to those terms.\n \n fn main() {\n-    // bad arguments to the ifmt! call\n+    // bad arguments to the format! call\n \n-    ifmt!();                //~ ERROR: expects at least one\n-    ifmt!(\"{}\");            //~ ERROR: invalid reference to argument\n+    format!();                //~ ERROR: requires at least a format string\n+    format!(\"{}\");            //~ ERROR: invalid reference to argument\n \n-    ifmt!(\"{1}\", 1);        //~ ERROR: invalid reference to argument `1`\n+    format!(\"{1}\", 1);        //~ ERROR: invalid reference to argument `1`\n                             //~^ ERROR: argument never used\n-    ifmt!(\"{foo}\");         //~ ERROR: no argument named `foo`\n+    format!(\"{foo}\");         //~ ERROR: no argument named `foo`\n \n-    ifmt!(\"{}\", 1, 2);               //~ ERROR: argument never used\n-    ifmt!(\"{1}\", 1, 2);              //~ ERROR: argument never used\n-    ifmt!(\"{}\", 1, foo=2);           //~ ERROR: named argument never used\n-    ifmt!(\"{foo}\", 1, foo=2);        //~ ERROR: argument never used\n-    ifmt!(\"\", foo=2);                //~ ERROR: named argument never used\n+    format!(\"{}\", 1, 2);               //~ ERROR: argument never used\n+    format!(\"{1}\", 1, 2);              //~ ERROR: argument never used\n+    format!(\"{}\", 1, foo=2);           //~ ERROR: named argument never used\n+    format!(\"{foo}\", 1, foo=2);        //~ ERROR: argument never used\n+    format!(\"\", foo=2);                //~ ERROR: named argument never used\n \n-    ifmt!(\"{0:d} {0:s}\", 1);         //~ ERROR: redeclared with type `s`\n-    ifmt!(\"{foo:d} {foo:s}\", foo=1); //~ ERROR: redeclared with type `s`\n+    format!(\"{0:d} {0:s}\", 1);         //~ ERROR: redeclared with type `s`\n+    format!(\"{foo:d} {foo:s}\", foo=1); //~ ERROR: redeclared with type `s`\n \n-    ifmt!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n-    ifmt!(\"#\");                      //~ ERROR: `#` reference used\n-    ifmt!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n-    ifmt!(\"\" 1);                     //~ ERROR: expected token: `,`\n-    ifmt!(\"\", 1 1);                  //~ ERROR: expected token: `,`\n+    format!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n+    format!(\"#\");                      //~ ERROR: `#` reference used\n+    format!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n+    format!(\"\" 1);                     //~ ERROR: expected token: `,`\n+    format!(\"\", 1 1);                  //~ ERROR: expected token: `,`\n \n-    ifmt!(\"{0, select, a{} a{} other{}}\", \"a\");    //~ ERROR: duplicate selector\n-    ifmt!(\"{0, plural, =1{} =1{} other{}}\", 1u);   //~ ERROR: duplicate selector\n-    ifmt!(\"{0, plural, one{} one{} other{}}\", 1u); //~ ERROR: duplicate selector\n+    format!(\"{0, select, a{} a{} other{}}\", \"a\");    //~ ERROR: duplicate selector\n+    format!(\"{0, plural, =1{} =1{} other{}}\", 1u);   //~ ERROR: duplicate selector\n+    format!(\"{0, plural, one{} one{} other{}}\", 1u); //~ ERROR: duplicate selector\n \n     // bad syntax of the format string\n \n-    ifmt!(\"{\"); //~ ERROR: unterminated format string\n-    ifmt!(\"\\\\ \"); //~ ERROR: invalid escape\n-    ifmt!(\"\\\\\"); //~ ERROR: expected an escape\n+    format!(\"{\"); //~ ERROR: unterminated format string\n+    format!(\"\\\\ \"); //~ ERROR: invalid escape\n+    format!(\"\\\\\"); //~ ERROR: expected an escape\n \n-    ifmt!(\"{0, }\", 1); //~ ERROR: expected method\n-    ifmt!(\"{0, foo}\", 1); //~ ERROR: unknown method\n-    ifmt!(\"{0, select}\", \"a\"); //~ ERROR: must be followed by\n-    ifmt!(\"{0, plural}\", 1); //~ ERROR: must be followed by\n+    format!(\"{0, }\", 1); //~ ERROR: expected method\n+    format!(\"{0, foo}\", 1); //~ ERROR: unknown method\n+    format!(\"{0, select}\", \"a\"); //~ ERROR: must be followed by\n+    format!(\"{0, plural}\", 1); //~ ERROR: must be followed by\n \n-    ifmt!(\"{0, select, a{{}\", 1); //~ ERROR: must be terminated\n-    ifmt!(\"{0, select, {} other{}}\", \"a\"); //~ ERROR: empty selector\n-    ifmt!(\"{0, select, other{} other{}}\", \"a\"); //~ ERROR: multiple `other`\n-    ifmt!(\"{0, plural, offset: other{}}\", \"a\"); //~ ERROR: must be an integer\n-    ifmt!(\"{0, plural, offset 1 other{}}\", \"a\"); //~ ERROR: be followed by `:`\n-    ifmt!(\"{0, plural, =a{} other{}}\", \"a\"); //~ ERROR: followed by an integer\n-    ifmt!(\"{0, plural, a{} other{}}\", \"a\"); //~ ERROR: unexpected plural\n-    ifmt!(\"{0, select, a{}}\", \"a\"); //~ ERROR: must provide an `other`\n-    ifmt!(\"{0, plural, =1{}}\", \"a\"); //~ ERROR: must provide an `other`\n+    format!(\"{0, select, a{{}\", 1); //~ ERROR: must be terminated\n+    format!(\"{0, select, {} other{}}\", \"a\"); //~ ERROR: empty selector\n+    format!(\"{0, select, other{} other{}}\", \"a\"); //~ ERROR: multiple `other`\n+    format!(\"{0, plural, offset: other{}}\", \"a\"); //~ ERROR: must be an integer\n+    format!(\"{0, plural, offset 1 other{}}\", \"a\"); //~ ERROR: be followed by `:`\n+    format!(\"{0, plural, =a{} other{}}\", \"a\"); //~ ERROR: followed by an integer\n+    format!(\"{0, plural, a{} other{}}\", \"a\"); //~ ERROR: unexpected plural\n+    format!(\"{0, select, a{}}\", \"a\"); //~ ERROR: must provide an `other`\n+    format!(\"{0, plural, =1{}}\", \"a\"); //~ ERROR: must provide an `other`\n \n-    ifmt!(\"{0, plural, other{{0:s}}}\", \"a\"); //~ ERROR: previously used as\n-    ifmt!(\"{:s} {0, plural, other{}}\", \"a\"); //~ ERROR: argument used to\n-    ifmt!(\"{0, select, other{}} \\\n-           {0, plural, other{}}\", \"a\");\n+    format!(\"{0, plural, other{{0:s}}}\", \"a\"); //~ ERROR: previously used as\n+    format!(\"{:s} {0, plural, other{}}\", \"a\"); //~ ERROR: argument used to\n+    format!(\"{0, select, other{}} \\\n+             {0, plural, other{}}\", \"a\");\n     //~^ ERROR: declared with multiple formats\n \n     // It should be illegal to use implicit placement arguments nested inside of\n     // format strings because otherwise the \"internal pointer of which argument\n     // is next\" would be invalidated if different cases had different numbers of\n     // arguments.\n-    ifmt!(\"{0, select, other{{}}}\", \"a\"); //~ ERROR: cannot use implicit\n-    ifmt!(\"{0, plural, other{{}}}\", 1); //~ ERROR: cannot use implicit\n-    ifmt!(\"{0, plural, other{{1:.*d}}}\", 1, 2); //~ ERROR: cannot use implicit\n+    format!(\"{0, select, other{{}}}\", \"a\"); //~ ERROR: cannot use implicit\n+    format!(\"{0, plural, other{{}}}\", 1); //~ ERROR: cannot use implicit\n+    format!(\"{0, plural, other{{1:.*d}}}\", 1, 2); //~ ERROR: cannot use implicit\n }"}, {"sha": "21c2d4b5934df5e950506145b4d4fb6b0b1fb027", "filename": "src/test/compile-fail/ifmt-bad-plural.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs?ref=eb836dd61ed2d780ca9639f73876c3d3e05ef079", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    ifmt!(\"{0, plural, other{}}\", \"a\");\n+    format!(\"{0, plural, other{}}\", \"a\");\n     //~^ ERROR: expected uint but found\n }"}, {"sha": "8a72b7920d7d2b8b189c4190c47fc104ff247eda", "filename": "src/test/compile-fail/ifmt-bad-select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs?ref=eb836dd61ed2d780ca9639f73876c3d3e05ef079", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    ifmt!(\"{0, select, other{}}\", 2);\n+    format!(\"{0, select, other{}}\", 2);\n     //~^ ERROR: expected &str but found integral\n }"}, {"sha": "830b041bbc7156c365629386042e245a24815346", "filename": "src/test/compile-fail/ifmt-unimpl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs?ref=eb836dd61ed2d780ca9639f73876c3d3e05ef079", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    ifmt!(\"{:d}\", \"3\");\n+    format!(\"{:d}\", \"3\");\n     //~^ ERROR: failed to find an implementation of trait std::fmt::Signed\n }"}, {"sha": "d90b3d3cf81df865054166f3d22b0f02b82978af", "filename": "src/test/compile-fail/ifmt-unknown-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Ftest%2Fcompile-fail%2Fifmt-unknown-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Ftest%2Fcompile-fail%2Fifmt-unknown-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-unknown-trait.rs?ref=eb836dd61ed2d780ca9639f73876c3d3e05ef079", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    ifmt!(\"{:notimplemented}\", \"3\");\n+    format!(\"{:notimplemented}\", \"3\");\n     //~^ ERROR: unknown format trait `notimplemented`\n }"}, {"sha": "e067e16f54b609cf9f3f2c9c8de02705e406e4d1", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 186, "deletions": 171, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb836dd61ed2d780ca9639f73876c3d3e05ef079/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=eb836dd61ed2d780ca9639f73876c3d3e05ef079", "patch": "@@ -26,208 +26,223 @@ macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n pub fn main() {\n \n     // Make sure there's a poly formatter that takes anything\n-    t!(ifmt!(\"{:?}\", 1), \"1\");\n-    t!(ifmt!(\"{:?}\", A), \"{}\");\n-    t!(ifmt!(\"{:?}\", ()), \"()\");\n-    t!(ifmt!(\"{:?}\", @(~1, \"foo\")), \"@(~1, \\\"foo\\\")\");\n+    t!(format!(\"{:?}\", 1), \"1\");\n+    t!(format!(\"{:?}\", A), \"{}\");\n+    t!(format!(\"{:?}\", ()), \"()\");\n+    t!(format!(\"{:?}\", @(~1, \"foo\")), \"@(~1, \\\"foo\\\")\");\n \n     // Various edge cases without formats\n-    t!(ifmt!(\"\"), \"\");\n-    t!(ifmt!(\"hello\"), \"hello\");\n-    t!(ifmt!(\"hello \\\\{\"), \"hello {\");\n+    t!(format!(\"\"), \"\");\n+    t!(format!(\"hello\"), \"hello\");\n+    t!(format!(\"hello \\\\{\"), \"hello {\");\n \n     // default formatters should work\n-    t!(ifmt!(\"{}\", 1i), \"1\");\n-    t!(ifmt!(\"{}\", 1i8), \"1\");\n-    t!(ifmt!(\"{}\", 1i16), \"1\");\n-    t!(ifmt!(\"{}\", 1i32), \"1\");\n-    t!(ifmt!(\"{}\", 1i64), \"1\");\n-    t!(ifmt!(\"{}\", 1u), \"1\");\n-    t!(ifmt!(\"{}\", 1u8), \"1\");\n-    t!(ifmt!(\"{}\", 1u16), \"1\");\n-    t!(ifmt!(\"{}\", 1u32), \"1\");\n-    t!(ifmt!(\"{}\", 1u64), \"1\");\n-    t!(ifmt!(\"{}\", 1.0f), \"1\");\n-    t!(ifmt!(\"{}\", 1.0f32), \"1\");\n-    t!(ifmt!(\"{}\", 1.0f64), \"1\");\n-    t!(ifmt!(\"{}\", \"a\"), \"a\");\n-    t!(ifmt!(\"{}\", ~\"a\"), \"a\");\n-    t!(ifmt!(\"{}\", @\"a\"), \"a\");\n-    t!(ifmt!(\"{}\", false), \"false\");\n-    t!(ifmt!(\"{}\", 'a'), \"a\");\n+    t!(format!(\"{}\", 1i), \"1\");\n+    t!(format!(\"{}\", 1i8), \"1\");\n+    t!(format!(\"{}\", 1i16), \"1\");\n+    t!(format!(\"{}\", 1i32), \"1\");\n+    t!(format!(\"{}\", 1i64), \"1\");\n+    t!(format!(\"{}\", 1u), \"1\");\n+    t!(format!(\"{}\", 1u8), \"1\");\n+    t!(format!(\"{}\", 1u16), \"1\");\n+    t!(format!(\"{}\", 1u32), \"1\");\n+    t!(format!(\"{}\", 1u64), \"1\");\n+    t!(format!(\"{}\", 1.0f), \"1\");\n+    t!(format!(\"{}\", 1.0f32), \"1\");\n+    t!(format!(\"{}\", 1.0f64), \"1\");\n+    t!(format!(\"{}\", \"a\"), \"a\");\n+    t!(format!(\"{}\", ~\"a\"), \"a\");\n+    t!(format!(\"{}\", @\"a\"), \"a\");\n+    t!(format!(\"{}\", false), \"false\");\n+    t!(format!(\"{}\", 'a'), \"a\");\n \n     // At least exercise all the formats\n-    t!(ifmt!(\"{:b}\", true), \"true\");\n-    t!(ifmt!(\"{:c}\", '\u2603'), \"\u2603\");\n-    t!(ifmt!(\"{:d}\", 10), \"10\");\n-    t!(ifmt!(\"{:i}\", 10), \"10\");\n-    t!(ifmt!(\"{:u}\", 10u), \"10\");\n-    t!(ifmt!(\"{:o}\", 10u), \"12\");\n-    t!(ifmt!(\"{:x}\", 10u), \"a\");\n-    t!(ifmt!(\"{:X}\", 10u), \"A\");\n-    t!(ifmt!(\"{:s}\", \"foo\"), \"foo\");\n-    t!(ifmt!(\"{:s}\", ~\"foo\"), \"foo\");\n-    t!(ifmt!(\"{:s}\", @\"foo\"), \"foo\");\n-    t!(ifmt!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n-    t!(ifmt!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n-    t!(ifmt!(\"{:d}\", A), \"aloha\");\n-    t!(ifmt!(\"{:d}\", B), \"adios\");\n-    t!(ifmt!(\"foo {:s} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n-    t!(ifmt!(\"{1} {0}\", 0, 1), \"1 0\");\n-    t!(ifmt!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n-    t!(ifmt!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n-    t!(ifmt!(\"{} {0:s}\", \"a\"), \"a a\");\n-    t!(ifmt!(\"{} {0}\", \"a\"), \"a a\");\n+    t!(format!(\"{:b}\", true), \"true\");\n+    t!(format!(\"{:c}\", '\u2603'), \"\u2603\");\n+    t!(format!(\"{:d}\", 10), \"10\");\n+    t!(format!(\"{:i}\", 10), \"10\");\n+    t!(format!(\"{:u}\", 10u), \"10\");\n+    t!(format!(\"{:o}\", 10u), \"12\");\n+    t!(format!(\"{:x}\", 10u), \"a\");\n+    t!(format!(\"{:X}\", 10u), \"A\");\n+    t!(format!(\"{:s}\", \"foo\"), \"foo\");\n+    t!(format!(\"{:s}\", ~\"foo\"), \"foo\");\n+    t!(format!(\"{:s}\", @\"foo\"), \"foo\");\n+    t!(format!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n+    t!(format!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n+    t!(format!(\"{:d}\", A), \"aloha\");\n+    t!(format!(\"{:d}\", B), \"adios\");\n+    t!(format!(\"foo {:s} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n+    t!(format!(\"{1} {0}\", 0, 1), \"1 0\");\n+    t!(format!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n+    t!(format!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n+    t!(format!(\"{} {0:s}\", \"a\"), \"a a\");\n+    t!(format!(\"{} {0}\", \"a\"), \"a a\");\n \n     // Methods should probably work\n-    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");\n-    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 1u), \"a1\");\n-    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 2u), \"b2\");\n-    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 3u), \"d3\");\n-    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"a\"), \"aa\");\n-    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"b\"), \"bb\");\n-    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"c\"), \"cc\");\n-    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"d\"), \"dd\");\n-    t!(ifmt!(\"{1, select, a{#{0:s}} other{#{1}}}\", \"b\", \"a\"), \"ab\");\n-    t!(ifmt!(\"{1, select, a{#{0}} other{#{1}}}\", \"c\", \"b\"), \"bb\");\n+    t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");\n+    t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 1u), \"a1\");\n+    t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 2u), \"b2\");\n+    t!(format!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 3u), \"d3\");\n+    t!(format!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"a\"), \"aa\");\n+    t!(format!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"b\"), \"bb\");\n+    t!(format!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"c\"), \"cc\");\n+    t!(format!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"d\"), \"dd\");\n+    t!(format!(\"{1, select, a{#{0:s}} other{#{1}}}\", \"b\", \"a\"), \"ab\");\n+    t!(format!(\"{1, select, a{#{0}} other{#{1}}}\", \"c\", \"b\"), \"bb\");\n \n     // Formatting strings and their arguments\n-    t!(ifmt!(\"{:s}\", \"a\"), \"a\");\n-    t!(ifmt!(\"{:4s}\", \"a\"), \"a   \");\n-    t!(ifmt!(\"{:>4s}\", \"a\"), \"   a\");\n-    t!(ifmt!(\"{:<4s}\", \"a\"), \"a   \");\n-    t!(ifmt!(\"{:.4s}\", \"a\"), \"a\");\n-    t!(ifmt!(\"{:4.4s}\", \"a\"), \"a   \");\n-    t!(ifmt!(\"{:4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:<4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:>4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:>10.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:2.4s}\", \"aaaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:2.4s}\", \"aaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:2.4s}\", \"aaa\"), \"aaa\");\n-    t!(ifmt!(\"{:2.4s}\", \"aa\"), \"aa\");\n-    t!(ifmt!(\"{:2.4s}\", \"a\"), \"a \");\n-    t!(ifmt!(\"{:0>2s}\", \"a\"), \"0a\");\n-    t!(ifmt!(\"{:.*s}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(ifmt!(\"{:.1$s}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n-    t!(ifmt!(\"{:1$s}\", \"a\", 4), \"a   \");\n-    t!(ifmt!(\"{:-#s}\", \"a\"), \"a\");\n-    t!(ifmt!(\"{:+#s}\", \"a\"), \"a\");\n+    t!(format!(\"{:s}\", \"a\"), \"a\");\n+    t!(format!(\"{:4s}\", \"a\"), \"a   \");\n+    t!(format!(\"{:>4s}\", \"a\"), \"   a\");\n+    t!(format!(\"{:<4s}\", \"a\"), \"a   \");\n+    t!(format!(\"{:.4s}\", \"a\"), \"a\");\n+    t!(format!(\"{:4.4s}\", \"a\"), \"a   \");\n+    t!(format!(\"{:4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:<4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:>4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:>10.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4s}\", \"aaaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4s}\", \"aaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4s}\", \"aaa\"), \"aaa\");\n+    t!(format!(\"{:2.4s}\", \"aa\"), \"aa\");\n+    t!(format!(\"{:2.4s}\", \"a\"), \"a \");\n+    t!(format!(\"{:0>2s}\", \"a\"), \"0a\");\n+    t!(format!(\"{:.*s}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:.1$s}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n+    t!(format!(\"{:1$s}\", \"a\", 4), \"a   \");\n+    t!(format!(\"{:-#s}\", \"a\"), \"a\");\n+    t!(format!(\"{:+#s}\", \"a\"), \"a\");\n \n     // Formatting integers should select the right implementation based off the\n     // type of the argument. Also, hex/octal/binary should be defined for\n     // integers, but they shouldn't emit the negative sign.\n-    t!(ifmt!(\"{:d}\", -1i), \"-1\");\n-    t!(ifmt!(\"{:d}\", -1i8), \"-1\");\n-    t!(ifmt!(\"{:d}\", -1i16), \"-1\");\n-    t!(ifmt!(\"{:d}\", -1i32), \"-1\");\n-    t!(ifmt!(\"{:d}\", -1i64), \"-1\");\n-    t!(ifmt!(\"{:t}\", 1i), \"1\");\n-    t!(ifmt!(\"{:t}\", 1i8), \"1\");\n-    t!(ifmt!(\"{:t}\", 1i16), \"1\");\n-    t!(ifmt!(\"{:t}\", 1i32), \"1\");\n-    t!(ifmt!(\"{:t}\", 1i64), \"1\");\n-    t!(ifmt!(\"{:x}\", 1i), \"1\");\n-    t!(ifmt!(\"{:x}\", 1i8), \"1\");\n-    t!(ifmt!(\"{:x}\", 1i16), \"1\");\n-    t!(ifmt!(\"{:x}\", 1i32), \"1\");\n-    t!(ifmt!(\"{:x}\", 1i64), \"1\");\n-    t!(ifmt!(\"{:X}\", 1i), \"1\");\n-    t!(ifmt!(\"{:X}\", 1i8), \"1\");\n-    t!(ifmt!(\"{:X}\", 1i16), \"1\");\n-    t!(ifmt!(\"{:X}\", 1i32), \"1\");\n-    t!(ifmt!(\"{:X}\", 1i64), \"1\");\n-    t!(ifmt!(\"{:o}\", 1i), \"1\");\n-    t!(ifmt!(\"{:o}\", 1i8), \"1\");\n-    t!(ifmt!(\"{:o}\", 1i16), \"1\");\n-    t!(ifmt!(\"{:o}\", 1i32), \"1\");\n-    t!(ifmt!(\"{:o}\", 1i64), \"1\");\n-\n-    t!(ifmt!(\"{:u}\", 1u), \"1\");\n-    t!(ifmt!(\"{:u}\", 1u8), \"1\");\n-    t!(ifmt!(\"{:u}\", 1u16), \"1\");\n-    t!(ifmt!(\"{:u}\", 1u32), \"1\");\n-    t!(ifmt!(\"{:u}\", 1u64), \"1\");\n-    t!(ifmt!(\"{:t}\", 1u), \"1\");\n-    t!(ifmt!(\"{:t}\", 1u8), \"1\");\n-    t!(ifmt!(\"{:t}\", 1u16), \"1\");\n-    t!(ifmt!(\"{:t}\", 1u32), \"1\");\n-    t!(ifmt!(\"{:t}\", 1u64), \"1\");\n-    t!(ifmt!(\"{:x}\", 1u), \"1\");\n-    t!(ifmt!(\"{:x}\", 1u8), \"1\");\n-    t!(ifmt!(\"{:x}\", 1u16), \"1\");\n-    t!(ifmt!(\"{:x}\", 1u32), \"1\");\n-    t!(ifmt!(\"{:x}\", 1u64), \"1\");\n-    t!(ifmt!(\"{:X}\", 1u), \"1\");\n-    t!(ifmt!(\"{:X}\", 1u8), \"1\");\n-    t!(ifmt!(\"{:X}\", 1u16), \"1\");\n-    t!(ifmt!(\"{:X}\", 1u32), \"1\");\n-    t!(ifmt!(\"{:X}\", 1u64), \"1\");\n-    t!(ifmt!(\"{:o}\", 1u), \"1\");\n-    t!(ifmt!(\"{:o}\", 1u8), \"1\");\n-    t!(ifmt!(\"{:o}\", 1u16), \"1\");\n-    t!(ifmt!(\"{:o}\", 1u32), \"1\");\n-    t!(ifmt!(\"{:o}\", 1u64), \"1\");\n+    t!(format!(\"{:d}\", -1i), \"-1\");\n+    t!(format!(\"{:d}\", -1i8), \"-1\");\n+    t!(format!(\"{:d}\", -1i16), \"-1\");\n+    t!(format!(\"{:d}\", -1i32), \"-1\");\n+    t!(format!(\"{:d}\", -1i64), \"-1\");\n+    t!(format!(\"{:t}\", 1i), \"1\");\n+    t!(format!(\"{:t}\", 1i8), \"1\");\n+    t!(format!(\"{:t}\", 1i16), \"1\");\n+    t!(format!(\"{:t}\", 1i32), \"1\");\n+    t!(format!(\"{:t}\", 1i64), \"1\");\n+    t!(format!(\"{:x}\", 1i), \"1\");\n+    t!(format!(\"{:x}\", 1i8), \"1\");\n+    t!(format!(\"{:x}\", 1i16), \"1\");\n+    t!(format!(\"{:x}\", 1i32), \"1\");\n+    t!(format!(\"{:x}\", 1i64), \"1\");\n+    t!(format!(\"{:X}\", 1i), \"1\");\n+    t!(format!(\"{:X}\", 1i8), \"1\");\n+    t!(format!(\"{:X}\", 1i16), \"1\");\n+    t!(format!(\"{:X}\", 1i32), \"1\");\n+    t!(format!(\"{:X}\", 1i64), \"1\");\n+    t!(format!(\"{:o}\", 1i), \"1\");\n+    t!(format!(\"{:o}\", 1i8), \"1\");\n+    t!(format!(\"{:o}\", 1i16), \"1\");\n+    t!(format!(\"{:o}\", 1i32), \"1\");\n+    t!(format!(\"{:o}\", 1i64), \"1\");\n+\n+    t!(format!(\"{:u}\", 1u), \"1\");\n+    t!(format!(\"{:u}\", 1u8), \"1\");\n+    t!(format!(\"{:u}\", 1u16), \"1\");\n+    t!(format!(\"{:u}\", 1u32), \"1\");\n+    t!(format!(\"{:u}\", 1u64), \"1\");\n+    t!(format!(\"{:t}\", 1u), \"1\");\n+    t!(format!(\"{:t}\", 1u8), \"1\");\n+    t!(format!(\"{:t}\", 1u16), \"1\");\n+    t!(format!(\"{:t}\", 1u32), \"1\");\n+    t!(format!(\"{:t}\", 1u64), \"1\");\n+    t!(format!(\"{:x}\", 1u), \"1\");\n+    t!(format!(\"{:x}\", 1u8), \"1\");\n+    t!(format!(\"{:x}\", 1u16), \"1\");\n+    t!(format!(\"{:x}\", 1u32), \"1\");\n+    t!(format!(\"{:x}\", 1u64), \"1\");\n+    t!(format!(\"{:X}\", 1u), \"1\");\n+    t!(format!(\"{:X}\", 1u8), \"1\");\n+    t!(format!(\"{:X}\", 1u16), \"1\");\n+    t!(format!(\"{:X}\", 1u32), \"1\");\n+    t!(format!(\"{:X}\", 1u64), \"1\");\n+    t!(format!(\"{:o}\", 1u), \"1\");\n+    t!(format!(\"{:o}\", 1u8), \"1\");\n+    t!(format!(\"{:o}\", 1u16), \"1\");\n+    t!(format!(\"{:o}\", 1u32), \"1\");\n+    t!(format!(\"{:o}\", 1u64), \"1\");\n \n     // Test the flags for formatting integers\n-    t!(ifmt!(\"{:3d}\", 1),  \"  1\");\n-    t!(ifmt!(\"{:>3d}\", 1),  \"  1\");\n-    t!(ifmt!(\"{:>+3d}\", 1), \" +1\");\n-    t!(ifmt!(\"{:<3d}\", 1), \"1  \");\n-    t!(ifmt!(\"{:#d}\", 1), \"1\");\n-    t!(ifmt!(\"{:#x}\", 10), \"0xa\");\n-    t!(ifmt!(\"{:#X}\", 10), \"0xA\");\n-    t!(ifmt!(\"{:#5x}\", 10), \"  0xa\");\n-    t!(ifmt!(\"{:#o}\", 10), \"0o12\");\n-    t!(ifmt!(\"{:08x}\", 10),  \"0000000a\");\n-    t!(ifmt!(\"{:8x}\", 10),   \"       a\");\n-    t!(ifmt!(\"{:<8x}\", 10),  \"a       \");\n-    t!(ifmt!(\"{:>8x}\", 10),  \"       a\");\n-    t!(ifmt!(\"{:#08x}\", 10), \"0x00000a\");\n-    t!(ifmt!(\"{:08d}\", -10), \"-0000010\");\n-    t!(ifmt!(\"{:x}\", -1u8), \"ff\");\n-    t!(ifmt!(\"{:X}\", -1u8), \"FF\");\n-    t!(ifmt!(\"{:t}\", -1u8), \"11111111\");\n-    t!(ifmt!(\"{:o}\", -1u8), \"377\");\n-    t!(ifmt!(\"{:#x}\", -1u8), \"0xff\");\n-    t!(ifmt!(\"{:#X}\", -1u8), \"0xFF\");\n-    t!(ifmt!(\"{:#t}\", -1u8), \"0b11111111\");\n-    t!(ifmt!(\"{:#o}\", -1u8), \"0o377\");\n+    t!(format!(\"{:3d}\", 1),  \"  1\");\n+    t!(format!(\"{:>3d}\", 1),  \"  1\");\n+    t!(format!(\"{:>+3d}\", 1), \" +1\");\n+    t!(format!(\"{:<3d}\", 1), \"1  \");\n+    t!(format!(\"{:#d}\", 1), \"1\");\n+    t!(format!(\"{:#x}\", 10), \"0xa\");\n+    t!(format!(\"{:#X}\", 10), \"0xA\");\n+    t!(format!(\"{:#5x}\", 10), \"  0xa\");\n+    t!(format!(\"{:#o}\", 10), \"0o12\");\n+    t!(format!(\"{:08x}\", 10),  \"0000000a\");\n+    t!(format!(\"{:8x}\", 10),   \"       a\");\n+    t!(format!(\"{:<8x}\", 10),  \"a       \");\n+    t!(format!(\"{:>8x}\", 10),  \"       a\");\n+    t!(format!(\"{:#08x}\", 10), \"0x00000a\");\n+    t!(format!(\"{:08d}\", -10), \"-0000010\");\n+    t!(format!(\"{:x}\", -1u8), \"ff\");\n+    t!(format!(\"{:X}\", -1u8), \"FF\");\n+    t!(format!(\"{:t}\", -1u8), \"11111111\");\n+    t!(format!(\"{:o}\", -1u8), \"377\");\n+    t!(format!(\"{:#x}\", -1u8), \"0xff\");\n+    t!(format!(\"{:#X}\", -1u8), \"0xFF\");\n+    t!(format!(\"{:#t}\", -1u8), \"0b11111111\");\n+    t!(format!(\"{:#o}\", -1u8), \"0o377\");\n \n     // Signed combinations\n-    t!(ifmt!(\"{:+5d}\", 1),  \"   +1\");\n-    t!(ifmt!(\"{:+5d}\", -1), \"   -1\");\n-    t!(ifmt!(\"{:05d}\", 1),   \"00001\");\n-    t!(ifmt!(\"{:05d}\", -1),  \"-0001\");\n-    t!(ifmt!(\"{:+05d}\", 1),  \"+0001\");\n-    t!(ifmt!(\"{:+05d}\", -1), \"-0001\");\n+    t!(format!(\"{:+5d}\", 1),  \"   +1\");\n+    t!(format!(\"{:+5d}\", -1), \"   -1\");\n+    t!(format!(\"{:05d}\", 1),   \"00001\");\n+    t!(format!(\"{:05d}\", -1),  \"-0001\");\n+    t!(format!(\"{:+05d}\", 1),  \"+0001\");\n+    t!(format!(\"{:+05d}\", -1), \"-0001\");\n \n     // Some float stuff\n-    t!(ifmt!(\"{:f}\", 1.0f), \"1\");\n-    t!(ifmt!(\"{:f}\", 1.0f32), \"1\");\n-    t!(ifmt!(\"{:f}\", 1.0f64), \"1\");\n-    t!(ifmt!(\"{:.3f}\", 1.0f), \"1.000\");\n-    t!(ifmt!(\"{:10.3f}\", 1.0f),   \"     1.000\");\n-    t!(ifmt!(\"{:+10.3f}\", 1.0f),  \"    +1.000\");\n-    t!(ifmt!(\"{:+10.3f}\", -1.0f), \"    -1.000\");\n-\n-    test_ifmtf();\n+    t!(format!(\"{:f}\", 1.0f), \"1\");\n+    t!(format!(\"{:f}\", 1.0f32), \"1\");\n+    t!(format!(\"{:f}\", 1.0f64), \"1\");\n+    t!(format!(\"{:.3f}\", 1.0f), \"1.000\");\n+    t!(format!(\"{:10.3f}\", 1.0f),   \"     1.000\");\n+    t!(format!(\"{:+10.3f}\", 1.0f),  \"    +1.000\");\n+    t!(format!(\"{:+10.3f}\", -1.0f), \"    -1.000\");\n+\n+    test_write();\n+    test_print();\n }\n \n-fn test_ifmtf() {\n+// Basic test to make sure that we can invoke the `write!` macro with an\n+// io::Writer instance.\n+fn test_write() {\n     use std::rt::io::Decorator;\n     use std::rt::io::mem::MemWriter;\n     use std::rt::io;\n     use std::str;\n \n     let mut buf = MemWriter::new();\n-    ifmtf!(&mut buf as &mut io::Writer, \"{}\", 3);\n+    write!(&mut buf as &mut io::Writer, \"{}\", 3);\n     {\n         let w = &mut buf as &mut io::Writer;\n-        ifmtf!(w, \"{foo}\", foo=4);\n-        ifmtf!(w, \"{:s}\", \"hello\");\n+        write!(w, \"{foo}\", foo=4);\n+        write!(w, \"{:s}\", \"hello\");\n+        writeln!(w, \"{}\", \"line\");\n+        writeln!(w, \"{foo}\", foo=\"bar\");\n     }\n \n     let s = str::from_bytes_owned(buf.inner());\n-    t!(s, \"34hello\");\n+    t!(s, \"34helloline\\nbar\\n\");\n+}\n+\n+// Just make sure that the macros are defined, there's not really a lot that we\n+// can do with them just yet (to test the output)\n+fn test_print() {\n+    print!(1);\n+    print!(\"{:?}\", ~[0u8]);\n+    println!(\"hello\");\n+    println!(\"this is a {}\", \"test\");\n+    println!(\"{foo}\", foo=\"bar\");\n }"}]}