{"sha": "1b556f16c9e6779610a8f64fe06f9947bc2cdbe8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNTU2ZjE2YzllNjc3OTYxMGE4ZjY0ZmUwNmY5OTQ3YmMyY2RiZTg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-20T18:34:10Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-20T18:38:28Z"}, "message": "expand pinning projections", "tree": {"sha": "bab4ec42d29b22405295be84f97244699aea8aa9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bab4ec42d29b22405295be84f97244699aea8aa9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b556f16c9e6779610a8f64fe06f9947bc2cdbe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b556f16c9e6779610a8f64fe06f9947bc2cdbe8", "html_url": "https://github.com/rust-lang/rust/commit/1b556f16c9e6779610a8f64fe06f9947bc2cdbe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b556f16c9e6779610a8f64fe06f9947bc2cdbe8/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06b2affa7879e609bcef70d726f900d8430f6e0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/06b2affa7879e609bcef70d726f900d8430f6e0a", "html_url": "https://github.com/rust-lang/rust/commit/06b2affa7879e609bcef70d726f900d8430f6e0a"}], "stats": {"total": 79, "additions": 41, "deletions": 38}, "files": [{"sha": "b238c56da66fa4e72610350109bacb5e09c91b87", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1b556f16c9e6779610a8f64fe06f9947bc2cdbe8/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b556f16c9e6779610a8f64fe06f9947bc2cdbe8/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=1b556f16c9e6779610a8f64fe06f9947bc2cdbe8", "patch": "@@ -182,46 +182,49 @@\n //! is entirely up to the author of any given type. For many types, both answers are reasonable\n //! (e.g., there could be a version of `Vec` with structural pinning and another\n //! version where the contents remain movable even when the `Vec` is pinned).\n-//! If pinning is not structural, the wrapper can `impl<T> Unpin for Wrapper<T>`.\n-//! If pinning is structural, the wrapper type can offer pinning projections.\n+//! If the type should have pinning projections, pinning must be structural.\n //! However, structural pinning comes with a few extra requirements:\n //!\n-//! 1. The wrapper must only be [`Unpin`] if all the fields one can project to are\n-//!    `Unpin`. This is the default, but `Unpin` is a safe trait, so as the author of\n-//!    the wrapper it is your responsibility *not* to add something like\n-//!    `impl<T> Unpin for Wrapper<T>`. (Notice that adding a projection operation\n-//!    requires unsafe code, so the fact that `Unpin` is a safe trait  does not break\n-//!    the principle that you only have to worry about any of this if you use `unsafe`.)\n-//! 2. The destructor of the wrapper must not move out of its argument. This is the exact\n-//!    point that was raised in the [previous section][drop-impl]: `drop` takes `&mut self`,\n-//!    but the wrapper (and hence its fields) might have been pinned before.\n-//!    You have to guarantee that you do not move a field inside your `Drop` implementation.\n-//!    In particular, as explained previously, this means that your wrapper type must *not*\n-//!    be `#[repr(packed)]`.\n-//! 3. You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n-//!    once your wrapper is pinned, the memory that contains the\n-//!    content is not overwritten or deallocated without calling the content's destructors.\n-//!    This can be tricky, as witnessed by `VecDeque`: the destructor of `VecDeque` can fail\n-//!    to call `drop` on all elements if one of the destructors panics. This violates the\n-//!    `Drop` guarantee, because it can lead to elements being deallocated without\n-//!    their destructor being called. (`VecDeque` has no pinning projections, so this\n-//!    does not cause unsoundness.)\n-//! 4. You must not offer any other operations that could lead to data being moved out of\n-//!    the fields when your type is pinned. This is usually not a concern, but can become\n-//!    tricky when interior mutability is involved. For example, imagine if `RefCell`\n-//!    had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n-//!    Then we could do the following:\n-//!    ```compile_fail\n-//!    fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>) {\n-//!        { let p = rc.as_mut().get_pin_mut(); } // here we get pinned access to the `T`\n-//!        let rc_shr: &RefCell<T> = rc.into_ref().get_ref();\n-//!        let b = rc_shr.borrow_mut();\n-//!        let content = &mut *b; // and here we have `&mut T` to the same data\n-//!    }\n-//!    ```\n-//!    This is catastrophic, it means we can first pin the content of the `RefCell`\n-//!    (using `RefCell::get_pin_mut`) and then move that content using the mutable\n-//!    reference we got later.\n+//! 1.  The wrapper must only be [`Unpin`] if all the fields one can project to are\n+//!     `Unpin`. This is the default, but `Unpin` is a safe trait, so as the author of\n+//!     the wrapper it is your responsibility *not* to add something like\n+//!     `impl<T> Unpin for Wrapper<T>`. (Notice that adding a projection operation\n+//!     requires unsafe code, so the fact that `Unpin` is a safe trait  does not break\n+//!     the principle that you only have to worry about any of this if you use `unsafe`.)\n+//! 2.  The destructor of the wrapper must not move out of its argument. This is the exact\n+//!     point that was raised in the [previous section][drop-impl]: `drop` takes `&mut self`,\n+//!      but the wrapper (and hence its fields) might have been pinned before.\n+//!     You have to guarantee that you do not move a field inside your `Drop` implementation.\n+//!     In particular, as explained previously, this means that your wrapper type must *not*\n+//!     be `#[repr(packed)]`.\n+//! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n+//!     once your wrapper is pinned, the memory that contains the\n+//!     content is not overwritten or deallocated without calling the content's destructors.\n+//!     This can be tricky, as witnessed by `VecDeque`: the destructor of `VecDeque` can fail\n+//!     to call `drop` on all elements if one of the destructors panics. This violates the\n+//!     `Drop` guarantee, because it can lead to elements being deallocated without\n+//!     their destructor being called. (`VecDeque` has no pinning projections, so this\n+//!     does not cause unsoundness.)\n+//! 4.  You must not offer any other operations that could lead to data being moved out of\n+//!     the fields when your type is pinned. For example, if the wrapper contains an\n+//!     `Option<T>` and there is an operation such as `fn(Pin<&mut Wrapper<T>>) -> Option<T>`,\n+//!     that operation can be used to move a `T` out of a pinned `Wrapper` -- that means\n+//!     pinning cannot be structural.\n+//!\n+//!     For a more complex example of moving data out of a pinnd type, imagine if `RefCell`\n+//!     had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n+//!     Then we could do the following:\n+//!     ```compile_fail\n+//!     fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>) {\n+//!         { let p = rc.as_mut().get_pin_mut(); } // here we get pinned access to the `T`\n+//!         let rc_shr: &RefCell<T> = rc.into_ref().get_ref();\n+//!         let b = rc_shr.borrow_mut();\n+//!         let content = &mut *b; // and here we have `&mut T` to the same data\n+//!     }\n+//!     ```\n+//!     This is catastrophic, it means we can first pin the content of the `RefCell`\n+//!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n+//!     reference we got later.\n //!\n //! On the other hand, if you decide *not* to offer any pinning projections, you\n //! do not have to do anything. If your type also does not do any pinning itself,"}]}