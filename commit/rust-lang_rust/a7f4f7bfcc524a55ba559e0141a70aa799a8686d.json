{"sha": "a7f4f7bfcc524a55ba559e0141a70aa799a8686d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZjRmN2JmY2M1MjRhNTViYTU1OWUwMTQxYTcwYWE3OTlhODY4NmQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-06T12:58:45Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-06T14:35:57Z"}, "message": "split module source into decl/defin", "tree": {"sha": "458eeb6cf17012239eae2fd107441b63575870ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/458eeb6cf17012239eae2fd107441b63575870ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7f4f7bfcc524a55ba559e0141a70aa799a8686d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f4f7bfcc524a55ba559e0141a70aa799a8686d", "html_url": "https://github.com/rust-lang/rust/commit/a7f4f7bfcc524a55ba559e0141a70aa799a8686d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cb02fd931f436a7b39c33c752799f5530b8491b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cb02fd931f436a7b39c33c752799f5530b8491b", "html_url": "https://github.com/rust-lang/rust/commit/9cb02fd931f436a7b39c33c752799f5530b8491b"}], "stats": {"total": 138, "additions": 106, "deletions": 32}, "files": [{"sha": "77f77e9a8c94b43ec4399e8f28ffe085f72af184", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=a7f4f7bfcc524a55ba559e0141a70aa799a8686d", "patch": "@@ -397,7 +397,7 @@ impl Analysis {\n     }\n     /// Returns the root file of the given crate.\n     pub fn crate_root(&self, crate_id: CrateId) -> Cancelable<FileId> {\n-        Ok(self.db.crate_root(crate_id))\n+        Ok(self.db.crate_graph().crate_root(crate_id))\n     }\n     /// Returns the set of possible targets to run for the current file.\n     pub fn runnables(&self, file_id: FileId) -> Cancelable<Vec<Runnable>> {"}, {"sha": "f24aa514a526e2ae0b1bc5647dc3c24eed06e594", "filename": "crates/ra_analysis/src/runnables.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/crates%2Fra_analysis%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/crates%2Fra_analysis%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Frunnables.rs?ref=a7f4f7bfcc524a55ba559e0141a70aa799a8686d", "patch": "@@ -73,11 +73,11 @@ fn runnable_mod(db: &RootDatabase, file_id: FileId, module: ast::Module) -> Opti\n     let module =\n         hir::source_binder::module_from_child_node(db, file_id, module.syntax()).ok()??;\n     let path = module\n-        .path_to_root()\n+        .path_to_root(db)\n+        .ok()?\n         .into_iter()\n         .rev()\n-        .into_iter()\n-        .filter_map(|it| it.name().map(Clone::clone))\n+        .filter_map(|it| it.name(db).map(Clone::clone))\n         .join(\"::\");\n     Some(Runnable {\n         range,"}, {"sha": "0c7f743d44411fa0089acad7b331d29ebaa6db5c", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=a7f4f7bfcc524a55ba559e0141a70aa799a8686d", "patch": "@@ -1,6 +1,7 @@\n-use ra_db::{CrateId, Cancelable};\n+use ra_db::{CrateId, Cancelable, FileId};\n+use ra_syntax::{ast, SyntaxNode};\n \n-use crate::{Name, db::HirDatabase, DefId, Path, PerNs, module::{ModuleSource, ModuleScope}};\n+use crate::{Name, db::HirDatabase, DefId, Path, PerNs, module::{Problem, ModuleScope}};\n \n /// hir::Crate describes a single crate. It's the main inteface with which\n /// crate's dependencies interact. Mostly, it should be just a proxy for the\n@@ -33,10 +34,27 @@ pub struct Module {\n     pub(crate) def_id: DefId,\n }\n \n+/// An owned syntax node for a module. Unlike `ModuleSource`,\n+/// this holds onto the AST for the whole file.\n+pub enum ModuleSource {\n+    SourceFile(ast::SourceFileNode),\n+    Module(ast::ModuleNode),\n+}\n+\n impl Module {\n-    // FIXME: what is a module source exactly? It should contain two nodes\n-    pub fn source(&self, db: &impl HirDatabase) -> Cancelable<ModuleSource> {\n-        Ok(self.source_impl(db))\n+    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n+        self.name_impl(db)\n+    }\n+\n+    pub fn defenition_source(&self, db: &impl HirDatabase) -> Cancelable<(FileId, ModuleSource)> {\n+        self.defenition_source_impl(db)\n+    }\n+\n+    pub fn declaration_source(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<Option<(FileId, ast::ModuleNode)>> {\n+        self.declaration_source_impl(db)\n     }\n \n     /// Returns the crate this module is part of.\n@@ -56,11 +74,23 @@ impl Module {\n     pub fn parent(&self, db: &impl HirDatabase) -> Cancelable<Option<Module>> {\n         self.parent_impl(db)\n     }\n+    pub fn path_to_root(&self, db: &impl HirDatabase) -> Cancelable<Vec<Module>> {\n+        let mut res = vec![self.clone()];\n+        let mut curr = self.clone();\n+        while let Some(next) = curr.parent(db)? {\n+            res.push(next.clone());\n+            curr = next\n+        }\n+        Ok(res)\n+    }\n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n     pub fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n         self.scope_impl(db)\n     }\n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> Cancelable<PerNs<DefId>> {\n         self.resolve_path_impl(db, path)\n     }\n+    pub fn problems(&self, db: &impl HirDatabase) -> Cancelable<Vec<(SyntaxNode, Problem)>> {\n+        self.problems_impl(db)\n+    }\n }"}, {"sha": "4f4b506dd9c1b3cbb02c890aaed4b82e3b2ddf32", "filename": "crates/ra_hir/src/code_model_impl.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl.rs?ref=a7f4f7bfcc524a55ba559e0141a70aa799a8686d", "patch": "@@ -1,12 +1,13 @@\n-use ra_db::{CrateId, Cancelable, SourceRootId};\n+use ra_db::{CrateId, Cancelable, SourceRootId, FileId};\n+use ra_syntax::{ast, SyntaxNode, AstNode};\n \n use crate::{\n     HirFileId, Crate, CrateDependency, AsName, DefId, DefLoc, DefKind, Name, Path, PathKind, PerNs, Def, ModuleId,\n-    module::{ModuleSource, ModuleScope},\n+    module::{ModuleScope, Problem},\n     db::HirDatabase,\n };\n \n-use crate::code_model_api::Module;\n+use crate::code_model_api::{Module, ModuleSource};\n \n impl Crate {\n     pub(crate) fn new(crate_id: CrateId) -> Crate {\n@@ -68,9 +69,44 @@ impl Module {\n         Ok(module)\n     }\n \n-    pub(crate) fn source_impl(&self, db: &impl HirDatabase) -> ModuleSource {\n+    pub(crate) fn name_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n         let loc = self.def_id.loc(db);\n-        ModuleSource(loc.source_item_id)\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let link = ctry!(loc.module_id.parent_link(&module_tree));\n+        Ok(Some(link.name(&module_tree).clone()))\n+    }\n+\n+    pub fn defenition_source_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<(FileId, ModuleSource)> {\n+        let loc = self.def_id.loc(db);\n+        let file_id = loc.source_item_id.file_id.as_original_file();\n+        let syntax_node = db.file_item(loc.source_item_id);\n+        let syntax_node = syntax_node.borrowed();\n+        let module_source = if let Some(source_file) = ast::SourceFile::cast(syntax_node) {\n+            ModuleSource::SourceFile(source_file.owned())\n+        } else {\n+            let module = ast::Module::cast(syntax_node).unwrap();\n+            ModuleSource::Module(module.owned())\n+        };\n+        Ok((file_id, module_source))\n+    }\n+\n+    pub fn declaration_source_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Cancelable<Option<(FileId, ast::ModuleNode)>> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        let link = ctry!(loc.module_id.parent_link(&module_tree));\n+        let file_id = link\n+            .owner(&module_tree)\n+            .source(&module_tree)\n+            .file_id()\n+            .as_original_file();\n+        let src = link.bind_source(&module_tree, db);\n+        Ok(Some((file_id, src)))\n     }\n \n     pub(crate) fn krate_impl(&self, db: &impl HirDatabase) -> Cancelable<Option<Crate>> {\n@@ -150,4 +186,9 @@ impl Module {\n         }\n         Ok(curr_per_ns)\n     }\n+    pub fn problems_impl(&self, db: &impl HirDatabase) -> Cancelable<Vec<(SyntaxNode, Problem)>> {\n+        let loc = self.def_id.loc(db);\n+        let module_tree = db.module_tree(loc.source_root_id)?;\n+        Ok(loc.module_id.problems(&module_tree, db))\n+    }\n }"}, {"sha": "0d1b94c42579b38d89e9f5a56e54a16cafa42b3b", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=a7f4f7bfcc524a55ba559e0141a70aa799a8686d", "patch": "@@ -10,10 +10,10 @@ use crate::{\n     Function,\n     db::HirDatabase,\n     type_ref::TypeRef,\n-    module::{ModuleSourceNode, ModuleId},\n+    module::ModuleId,\n };\n \n-use crate::code_model_api::Module;\n+use crate::code_model_api::{Module, ModuleSource};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImplBlock {\n@@ -150,13 +150,13 @@ impl ModuleImplBlocks {\n     }\n \n     fn collect(&mut self, db: &impl HirDatabase, module: Module) -> Cancelable<()> {\n-        let module_source_node = module.source(db)?.resolve(db);\n-        let node = match &module_source_node {\n-            ModuleSourceNode::SourceFile(node) => node.borrowed().syntax(),\n-            ModuleSourceNode::Module(node) => node.borrowed().syntax(),\n+        let (file_id, module_source) = module.defenition_source(db)?;\n+        let node = match &module_source {\n+            ModuleSource::SourceFile(node) => node.borrowed().syntax(),\n+            ModuleSource::Module(node) => node.borrowed().syntax(),\n         };\n \n-        let source_file_items = db.file_items(module.source(db)?.file_id());\n+        let source_file_items = db.file_items(file_id.into());\n \n         for impl_block_ast in node.children().filter_map(ast::ImplBlock::cast) {\n             let impl_block = ImplData::from_ast(db, &source_file_items, &module, impl_block_ast);"}, {"sha": "ebaf5f47a52b2d0993d112558d0594a56f4a8a7e", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f4f7bfcc524a55ba559e0141a70aa799a8686d/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=a7f4f7bfcc524a55ba559e0141a70aa799a8686d", "patch": "@@ -1,8 +1,6 @@\n pub(super) mod imp;\n pub(super) mod nameres;\n \n-use log;\n-\n use ra_syntax::{\n     algo::generate,\n     ast::{self, AstNode, NameOwner},\n@@ -11,10 +9,7 @@ use ra_syntax::{\n use ra_arena::{Arena, RawId, impl_arena_id};\n use relative_path::RelativePathBuf;\n \n-use crate::{\n-    Name,  HirDatabase, SourceItemId, SourceFileItemId,\n-    HirFileId,\n-};\n+use crate::{Name, HirDatabase, SourceItemId, SourceFileItemId, HirFileId};\n \n pub use self::nameres::{ModuleScope, Resolution, Namespace, PerNs};\n \n@@ -78,7 +73,7 @@ impl ModuleId {\n     pub(crate) fn source(self, tree: &ModuleTree) -> ModuleSource {\n         tree.mods[self].source\n     }\n-    fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n+    pub(crate) fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n         tree.mods[self].parent\n     }\n     pub(crate) fn parent(self, tree: &ModuleTree) -> Option<ModuleId> {\n@@ -105,7 +100,11 @@ impl ModuleId {\n             Some((link.name.clone(), module))\n         })\n     }\n-    fn problems(self, tree: &ModuleTree, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n+    pub(crate) fn problems(\n+        self,\n+        tree: &ModuleTree,\n+        db: &impl HirDatabase,\n+    ) -> Vec<(SyntaxNode, Problem)> {\n         tree.mods[self]\n             .children\n             .iter()\n@@ -120,13 +119,17 @@ impl ModuleId {\n }\n \n impl LinkId {\n-    fn owner(self, tree: &ModuleTree) -> ModuleId {\n+    pub(crate) fn owner(self, tree: &ModuleTree) -> ModuleId {\n         tree.links[self].owner\n     }\n-    fn name(self, tree: &ModuleTree) -> &Name {\n+    pub(crate) fn name(self, tree: &ModuleTree) -> &Name {\n         &tree.links[self].name\n     }\n-    fn bind_source<'a>(self, tree: &ModuleTree, db: &impl HirDatabase) -> ast::ModuleNode {\n+    pub(crate) fn bind_source<'a>(\n+        self,\n+        tree: &ModuleTree,\n+        db: &impl HirDatabase,\n+    ) -> ast::ModuleNode {\n         let owner = self.owner(tree);\n         match owner.source(tree).resolve(db) {\n             ModuleSourceNode::SourceFile(root) => {"}]}