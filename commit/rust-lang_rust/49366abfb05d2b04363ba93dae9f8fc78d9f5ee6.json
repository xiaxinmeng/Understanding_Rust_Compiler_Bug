{"sha": "49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "node_id": "C_kwDOAAsO6NoAKDQ5MzY2YWJmYjA1ZDJiMDQzNjNiYTkzZGFlOWY4ZmM3OGQ5ZjVlZTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-01T06:34:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-01T06:34:32Z"}, "message": "Auto merge of #2095 - dtolnay-contrib:ref, r=RalfJung\n\nReplace unneeded use of `ref` in favor of \"match ergonomics\"\n\nThe signature of `check_shim` is very amenable to this.\n\n```rust\nfn check_shim<'a, const N: usize>(\u2026) -> InterpResult<'tcx, &'a [OpTy<'tcx, Tag>; N]>\n```\n\nInstead of:\n\n```rust\nlet &[ref ptr, ref flags] = this.check_shim(\u2026)?;\n```\n\nwe can write it just as:\n\n```rust\nlet [ptr, flags] = this.check_shim(\u2026)?;\n```", "tree": {"sha": "43b7ca5098c9fbc0d105e299bdab03daefab631e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43b7ca5098c9fbc0d105e299bdab03daefab631e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "html_url": "https://github.com/rust-lang/rust/commit/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd30a9d8160c256aa7c25fd84db41833f92992bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd30a9d8160c256aa7c25fd84db41833f92992bd", "html_url": "https://github.com/rust-lang/rust/commit/bd30a9d8160c256aa7c25fd84db41833f92992bd"}, {"sha": "1d9e91ed507155c86299125239b993761b110fb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d9e91ed507155c86299125239b993761b110fb1", "html_url": "https://github.com/rust-lang/rust/commit/1d9e91ed507155c86299125239b993761b110fb1"}], "stats": {"total": 456, "additions": 219, "deletions": 237}, "files": [{"sha": "339aa4d57e2201b4c909659bc570ceefc6e9184b", "filename": "src/shims/backtrace.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fbacktrace.rs?ref=49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "patch": "@@ -15,7 +15,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dest: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let &[ref flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+        let [flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n \n         let flags = this.read_scalar(flags)?.to_u64()?;\n         if flags != 0 {\n@@ -77,7 +77,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // storage for pointers is allocated by miri\n             // deallocating the slice is undefined behavior with a custom global allocator\n             0 => {\n-                let &[_flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let [_flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n \n                 let alloc = this.allocate(array_layout, MiriMemoryKind::Rust.into())?;\n \n@@ -95,7 +95,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             // storage for pointers is allocated by the caller\n             1 => {\n-                let &[_flags, ref buf] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let [_flags, buf] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n \n                 let buf_place = this.deref_operand(buf)?;\n \n@@ -150,7 +150,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dest: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let &[ref ptr, ref flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+        let [ptr, flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n \n         let flags = this.read_scalar(flags)?.to_u64()?;\n \n@@ -233,7 +233,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let &[ref ptr, ref flags, ref name_ptr, ref filename_ptr] =\n+        let [ptr, flags, name_ptr, filename_ptr] =\n             this.check_shim(abi, Abi::Rust, link_name, args)?;\n \n         let flags = this.read_scalar(flags)?.to_u64()?;"}, {"sha": "ba4e384846be40324f0e74e98ea9f43350386e6b", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "patch": "@@ -274,14 +274,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         } else {\n                             Abi::System { unwind: false }\n                         };\n-                        let &[ref code] = this.check_shim(abi, exp_abi, link_name, args)?;\n+                        let [code] = this.check_shim(abi, exp_abi, link_name, args)?;\n                         // it's really u32 for ExitProcess, but we have to put it into the `Exit` variant anyway\n                         let code = this.read_scalar(code)?.to_i32()?;\n                         throw_machine_stop!(TerminationInfo::Exit(code.into()));\n                     }\n                     \"abort\" => {\n-                        let &[] =\n-                            this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                        let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                         throw_machine_stop!(TerminationInfo::Abort(\n                             \"the program aborted execution\".to_owned()\n                         ))\n@@ -367,7 +366,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match &*link_name.as_str() {\n             // Miri-specific extern functions\n             \"miri_static_root\" => {\n-                let &[ref ptr] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let [ptr] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let (alloc_id, offset, _) = this.ptr_get_alloc_id(ptr)?;\n                 if offset != Size::ZERO {\n@@ -400,13 +399,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Standard C allocation\n             \"malloc\" => {\n-                let &[ref size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C)?;\n                 this.write_pointer(res, dest)?;\n             }\n             \"calloc\" => {\n-                let &[ref items, ref len] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [items, len] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let items = this.read_scalar(items)?.to_machine_usize(this)?;\n                 let len = this.read_scalar(len)?.to_machine_usize(this)?;\n                 let size =\n@@ -415,12 +414,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_pointer(res, dest)?;\n             }\n             \"free\" => {\n-                let &[ref ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 this.free(ptr, MiriMemoryKind::C)?;\n             }\n             \"realloc\" => {\n-                let &[ref old_ptr, ref new_size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [old_ptr, new_size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let old_ptr = this.read_pointer(old_ptr)?;\n                 let new_size = this.read_scalar(new_size)?.to_machine_usize(this)?;\n                 let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n@@ -429,7 +428,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Rust allocation\n             \"__rust_alloc\" => {\n-                let &[ref size, ref align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let [size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n \n@@ -446,7 +445,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 });\n             }\n             \"__rust_alloc_zeroed\" => {\n-                let &[ref size, ref align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let [size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n \n@@ -465,7 +464,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 });\n             }\n             \"__rust_dealloc\" => {\n-                let &[ref ptr, ref old_size, ref align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let [ptr, old_size, align] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -480,7 +479,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 });\n             }\n             \"__rust_realloc\" => {\n-                let &[ref ptr, ref old_size, ref align, ref new_size] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let [ptr, old_size, align, new_size] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -504,7 +503,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // C memory handling functions\n             \"memcmp\" => {\n-                let &[ref left, ref right, ref n] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [left, right, n] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let left = this.read_pointer(left)?;\n                 let right = this.read_pointer(right)?;\n                 let n = Size::from_bytes(this.read_scalar(n)?.to_machine_usize(this)?);\n@@ -524,7 +523,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"memrchr\" => {\n-                let &[ref ptr, ref val, ref num] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [ptr, val, num] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n                 let num = this.read_scalar(num)?.to_machine_usize(this)?;\n@@ -541,7 +540,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"memchr\" => {\n-                let &[ref ptr, ref val, ref num] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [ptr, val, num] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n                 let num = this.read_scalar(num)?.to_machine_usize(this)?;\n@@ -557,7 +556,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"strlen\" => {\n-                let &[ref ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let n = this.read_c_str(ptr)?.len();\n                 this.write_scalar(Scalar::from_machine_usize(u64::try_from(n).unwrap(), this), dest)?;\n@@ -573,7 +572,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"asinf\"\n             | \"atanf\"\n             => {\n-                let &[ref f] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [f] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let f = match &*link_name.as_str() {\n@@ -593,7 +592,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"hypotf\"\n             | \"atan2f\"\n             => {\n-                let &[ref f1, ref f2] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [f1, f2] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // underscore case for windows, here and below\n                 // (see https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/floating-point-primitives?view=vs-2019)\n                 // FIXME: Using host floats.\n@@ -615,7 +614,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"asin\"\n             | \"atan\"\n             => {\n-                let &[ref f] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [f] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let f = match &*link_name.as_str() {\n@@ -635,7 +634,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"hypot\"\n             | \"atan2\"\n             => {\n-                let &[ref f1, ref f2] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [f1, f2] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // FIXME: Using host floats.\n                 let f1 = f64::from_bits(this.read_scalar(f1)?.to_u64()?);\n                 let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n@@ -651,7 +650,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"ldexp\"\n             | \"scalbn\"\n             => {\n-                let &[ref x, ref exp] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [x, exp] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // For radix-2 (binary) systems, `ldexp` and `scalbn` are the same.\n                 let x = this.read_scalar(x)?.to_f64()?;\n                 let exp = this.read_scalar(exp)?.to_i32()?;\n@@ -673,7 +672,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Architecture-specific shims\n             \"llvm.x86.addcarry.64\" if this.tcx.sess.target.arch == \"x86_64\" => {\n                 // Computes u8+u64+u64, returning tuple (u8,u64) comprising the output carry and truncated sum.\n-                let &[ref c_in, ref a, ref b] = this.check_shim(abi, Abi::Unadjusted, link_name, args)?;\n+                let [c_in, a, b] = this.check_shim(abi, Abi::Unadjusted, link_name, args)?;\n                 let c_in = this.read_scalar(c_in)?.to_u8()?;\n                 let a = this.read_scalar(a)?.to_u64()?;\n                 let b = this.read_scalar(b)?.to_u64()?;\n@@ -687,11 +686,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_u64(sum), &sum_field)?;\n             }\n             \"llvm.x86.sse2.pause\" if this.tcx.sess.target.arch == \"x86\" || this.tcx.sess.target.arch == \"x86_64\" => {\n-                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.yield_active_thread();\n             }\n             \"llvm.aarch64.isb\" if this.tcx.sess.target.arch == \"aarch64\" => {\n-                let &[ref arg] = this.check_shim(abi, Abi::Unadjusted, link_name, args)?;\n+                let [arg] = this.check_shim(abi, Abi::Unadjusted, link_name, args)?;\n                 let arg = this.read_scalar(arg)?.to_i32()?;\n                 match arg {\n                     15 => { // SY (\"full system scope\")"}, {"sha": "a6f818c493e66f7ee2be3690fae1ff4c0bec1fbc", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "patch": "@@ -43,13 +43,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match intrinsic_name {\n             // Miri overwriting CTFE intrinsics.\n             \"ptr_guaranteed_eq\" => {\n-                let &[ref left, ref right] = check_arg_count(args)?;\n+                let [left, right] = check_arg_count(args)?;\n                 let left = this.read_immediate(left)?;\n                 let right = this.read_immediate(right)?;\n                 this.binop_ignore_overflow(mir::BinOp::Eq, &left, &right, dest)?;\n             }\n             \"ptr_guaranteed_ne\" => {\n-                let &[ref left, ref right] = check_arg_count(args)?;\n+                let [left, right] = check_arg_count(args)?;\n                 let left = this.read_immediate(left)?;\n                 let right = this.read_immediate(right)?;\n                 this.binop_ignore_overflow(mir::BinOp::Ne, &left, &right, dest)?;\n@@ -65,18 +65,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Raw memory accesses\n             \"volatile_load\" => {\n-                let &[ref place] = check_arg_count(args)?;\n+                let [place] = check_arg_count(args)?;\n                 let place = this.deref_operand(place)?;\n                 this.copy_op(&place.into(), dest)?;\n             }\n             \"volatile_store\" => {\n-                let &[ref place, ref dest] = check_arg_count(args)?;\n+                let [place, dest] = check_arg_count(args)?;\n                 let place = this.deref_operand(place)?;\n                 this.copy_op(dest, &place.into())?;\n             }\n \n             \"write_bytes\" | \"volatile_set_memory\" => {\n-                let &[ref ptr, ref val_byte, ref count] = check_arg_count(args)?;\n+                let [ptr, val_byte, count] = check_arg_count(args)?;\n                 let ty = instance.substs.type_at(0);\n                 let ty_layout = this.layout_of(ty)?;\n                 let val_byte = this.read_scalar(val_byte)?.to_u8()?;\n@@ -95,13 +95,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Floating-point operations\n             \"fabsf32\" => {\n-                let &[ref f] = check_arg_count(args)?;\n+                let [f] = check_arg_count(args)?;\n                 let f = this.read_scalar(f)?.to_f32()?;\n                 // Can be implemented in soft-floats.\n                 this.write_scalar(Scalar::from_f32(f.abs()), dest)?;\n             }\n             \"fabsf64\" => {\n-                let &[ref f] = check_arg_count(args)?;\n+                let [f] = check_arg_count(args)?;\n                 let f = this.read_scalar(f)?.to_f64()?;\n                 // Can be implemented in soft-floats.\n                 this.write_scalar(Scalar::from_f64(f.abs()), dest)?;\n@@ -120,7 +120,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"truncf32\"\n             | \"roundf32\"\n             => {\n-                let &[ref f] = check_arg_count(args)?;\n+                let [f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let f = match intrinsic_name {\n@@ -155,7 +155,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"truncf64\"\n             | \"roundf64\"\n             => {\n-                let &[ref f] = check_arg_count(args)?;\n+                let [f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let f = match intrinsic_name {\n@@ -183,7 +183,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"fdiv_fast\"\n             | \"frem_fast\"\n             => {\n-                let &[ref a, ref b] = check_arg_count(args)?;\n+                let [a, b] = check_arg_count(args)?;\n                 let a = this.read_immediate(a)?;\n                 let b = this.read_immediate(b)?;\n                 let op = match intrinsic_name {\n@@ -228,7 +228,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"maxnumf32\"\n             | \"copysignf32\"\n             => {\n-                let &[ref a, ref b] = check_arg_count(args)?;\n+                let [a, b] = check_arg_count(args)?;\n                 let a = this.read_scalar(a)?.to_f32()?;\n                 let b = this.read_scalar(b)?.to_f32()?;\n                 let res = match intrinsic_name {\n@@ -245,7 +245,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"maxnumf64\"\n             | \"copysignf64\"\n             => {\n-                let &[ref a, ref b] = check_arg_count(args)?;\n+                let [a, b] = check_arg_count(args)?;\n                 let a = this.read_scalar(a)?.to_f64()?;\n                 let b = this.read_scalar(b)?.to_f64()?;\n                 let res = match intrinsic_name {\n@@ -258,23 +258,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"powf32\" => {\n-                let &[ref f, ref f2] = check_arg_count(args)?;\n+                let [f, f2] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let f2 = f32::from_bits(this.read_scalar(f2)?.to_u32()?);\n                 this.write_scalar(Scalar::from_u32(f.powf(f2).to_bits()), dest)?;\n             }\n \n             \"powf64\" => {\n-                let &[ref f, ref f2] = check_arg_count(args)?;\n+                let [f, f2] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n                 this.write_scalar(Scalar::from_u64(f.powf(f2).to_bits()), dest)?;\n             }\n \n             \"fmaf32\" => {\n-                let &[ref a, ref b, ref c] = check_arg_count(args)?;\n+                let [a, b, c] = check_arg_count(args)?;\n                 let a = this.read_scalar(a)?.to_f32()?;\n                 let b = this.read_scalar(b)?.to_f32()?;\n                 let c = this.read_scalar(c)?.to_f32()?;\n@@ -283,7 +283,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"fmaf64\" => {\n-                let &[ref a, ref b, ref c] = check_arg_count(args)?;\n+                let [a, b, c] = check_arg_count(args)?;\n                 let a = this.read_scalar(a)?.to_f64()?;\n                 let b = this.read_scalar(b)?.to_f64()?;\n                 let c = this.read_scalar(c)?.to_f64()?;\n@@ -292,23 +292,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"powif32\" => {\n-                let &[ref f, ref i] = check_arg_count(args)?;\n+                let [f, i] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let i = this.read_scalar(i)?.to_i32()?;\n                 this.write_scalar(Scalar::from_u32(f.powi(i).to_bits()), dest)?;\n             }\n \n             \"powif64\" => {\n-                let &[ref f, ref i] = check_arg_count(args)?;\n+                let [f, i] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let i = this.read_scalar(i)?.to_i32()?;\n                 this.write_scalar(Scalar::from_u64(f.powi(i).to_bits()), dest)?;\n             }\n \n             \"float_to_int_unchecked\" => {\n-                let &[ref val] = check_arg_count(args)?;\n+                let [val] = check_arg_count(args)?;\n                 let val = this.read_immediate(val)?;\n \n                 let res = match val.layout.ty.kind() {\n@@ -335,7 +335,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"simd_round\"\n             | \"simd_trunc\"\n             | \"simd_fsqrt\" => {\n-                let &[ref op] = check_arg_count(args)?;\n+                let [op] = check_arg_count(args)?;\n                 let (op, op_len) = this.operand_to_simd(op)?;\n                 let (dest, dest_len) = this.place_to_simd(dest)?;\n \n@@ -441,7 +441,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"simd_arith_offset\" => {\n                 use mir::BinOp;\n \n-                let &[ref left, ref right] = check_arg_count(args)?;\n+                let [left, right] = check_arg_count(args)?;\n                 let (left, left_len) = this.operand_to_simd(left)?;\n                 let (right, right_len) = this.operand_to_simd(right)?;\n                 let (dest, dest_len) = this.place_to_simd(dest)?;\n@@ -531,7 +531,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"simd_fma\" => {\n-                let &[ref a, ref b, ref c] = check_arg_count(args)?;\n+                let [a, b, c] = check_arg_count(args)?;\n                 let (a, a_len) = this.operand_to_simd(a)?;\n                 let (b, b_len) = this.operand_to_simd(b)?;\n                 let (c, c_len) = this.operand_to_simd(c)?;\n@@ -570,7 +570,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"simd_reduce_min\" => {\n                 use mir::BinOp;\n \n-                let &[ref op] = check_arg_count(args)?;\n+                let [op] = check_arg_count(args)?;\n                 let (op, op_len) = this.operand_to_simd(op)?;\n \n                 let imm_from_bool =\n@@ -642,7 +642,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"simd_reduce_mul_ordered\" => {\n                 use mir::BinOp;\n \n-                let &[ref op, ref init] = check_arg_count(args)?;\n+                let [op, init] = check_arg_count(args)?;\n                 let (op, op_len) = this.operand_to_simd(op)?;\n                 let init = this.read_immediate(init)?;\n \n@@ -660,7 +660,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_immediate(*res, dest)?;\n             }\n             \"simd_select\" => {\n-                let &[ref mask, ref yes, ref no] = check_arg_count(args)?;\n+                let [mask, yes, no] = check_arg_count(args)?;\n                 let (mask, mask_len) = this.operand_to_simd(mask)?;\n                 let (yes, yes_len) = this.operand_to_simd(yes)?;\n                 let (no, no_len) = this.operand_to_simd(no)?;\n@@ -681,7 +681,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"simd_select_bitmask\" => {\n-                let &[ref mask, ref yes, ref no] = check_arg_count(args)?;\n+                let [mask, yes, no] = check_arg_count(args)?;\n                 let (yes, yes_len) = this.operand_to_simd(yes)?;\n                 let (no, no_len) = this.operand_to_simd(no)?;\n                 let (dest, dest_len) = this.place_to_simd(dest)?;\n@@ -721,7 +721,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             #[rustfmt::skip]\n             \"simd_cast\" | \"simd_as\" => {\n-                let &[ref op] = check_arg_count(args)?;\n+                let [op] = check_arg_count(args)?;\n                 let (op, op_len) = this.operand_to_simd(op)?;\n                 let (dest, dest_len) = this.place_to_simd(dest)?;\n \n@@ -759,7 +759,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"simd_shuffle\" => {\n-                let &[ref left, ref right, ref index] = check_arg_count(args)?;\n+                let [left, right, index] = check_arg_count(args)?;\n                 let (left, left_len) = this.operand_to_simd(left)?;\n                 let (right, right_len) = this.operand_to_simd(right)?;\n                 let (dest, dest_len) = this.place_to_simd(dest)?;\n@@ -798,7 +798,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"simd_gather\" => {\n-                let &[ref passthru, ref ptrs, ref mask] = check_arg_count(args)?;\n+                let [passthru, ptrs, mask] = check_arg_count(args)?;\n                 let (passthru, passthru_len) = this.operand_to_simd(passthru)?;\n                 let (ptrs, ptrs_len) = this.operand_to_simd(ptrs)?;\n                 let (mask, mask_len) = this.operand_to_simd(mask)?;\n@@ -824,7 +824,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"simd_scatter\" => {\n-                let &[ref value, ref ptrs, ref mask] = check_arg_count(args)?;\n+                let [value, ptrs, mask] = check_arg_count(args)?;\n                 let (value, value_len) = this.operand_to_simd(value)?;\n                 let (ptrs, ptrs_len) = this.operand_to_simd(ptrs)?;\n                 let (mask, mask_len) = this.operand_to_simd(mask)?;\n@@ -844,7 +844,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"simd_bitmask\" => {\n-                let &[ref op] = check_arg_count(args)?;\n+                let [op] = check_arg_count(args)?;\n                 let (op, op_len) = this.operand_to_simd(op)?;\n                 let bitmask_len = op_len.max(8);\n \n@@ -1063,14 +1063,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Other\n             \"exact_div\" => {\n-                let &[ref num, ref denom] = check_arg_count(args)?;\n+                let [num, denom] = check_arg_count(args)?;\n                 this.exact_div(&this.read_immediate(num)?, &this.read_immediate(denom)?, dest)?;\n             }\n \n             \"try\" => return this.handle_try(args, dest, ret),\n \n             \"breakpoint\" => {\n-                let &[] = check_arg_count(args)?;\n+                let [] = check_arg_count(args)?;\n                 // normally this would raise a SIGTRAP, which aborts if no debugger is connected\n                 throw_machine_stop!(TerminationInfo::Abort(\"Trace/breakpoint trap\".to_string()))\n             }\n@@ -1091,7 +1091,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let &[ref place] = check_arg_count(args)?;\n+        let [place] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n \n         // make sure it fits into a scalar; otherwise it cannot be atomic\n@@ -1119,7 +1119,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let &[ref place, ref val] = check_arg_count(args)?;\n+        let [place, val] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n         let val = this.read_scalar(val)?; // make sure it fits into a scalar; otherwise it cannot be atomic\n \n@@ -1144,7 +1144,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         args: &[OpTy<'tcx, Tag>],\n         atomic: AtomicFenceOp,\n     ) -> InterpResult<'tcx> {\n-        let &[] = check_arg_count(args)?;\n+        let [] = check_arg_count(args)?;\n         let _ = atomic;\n         //FIXME: compiler fences are currently ignored\n         Ok(())\n@@ -1156,7 +1156,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         atomic: AtomicFenceOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let &[] = check_arg_count(args)?;\n+        let [] = check_arg_count(args)?;\n         this.validate_atomic_fence(atomic)?;\n         Ok(())\n     }\n@@ -1170,7 +1170,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let &[ref place, ref rhs] = check_arg_count(args)?;\n+        let [place, rhs] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n \n         if !place.layout.ty.is_integral() {\n@@ -1216,7 +1216,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let &[ref place, ref new] = check_arg_count(args)?;\n+        let [place, new] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n         let new = this.read_scalar(new)?;\n \n@@ -1246,7 +1246,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let &[ref place, ref expect_old, ref new] = check_arg_count(args)?;\n+        let [place, expect_old, new] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n         let expect_old = this.read_immediate(expect_old)?; // read as immediate for the sake of `binary_op()`\n         let new = this.read_scalar(new)?;"}, {"sha": "f003552434fe9a5c0548165c44dfa476f67c9106", "filename": "src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "patch": "@@ -36,7 +36,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // There are some more lang items we want to hook that CTFE does not hook (yet).\n         if this.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n-            let &[ref ptr, ref align] = check_arg_count(args)?;\n+            let [ptr, align] = check_arg_count(args)?;\n             if this.align_offset(ptr, align, ret, unwind)? {\n                 return Ok(None);\n             }"}, {"sha": "f92e39048bc860d0adc60a8f87a82f644f02b396", "filename": "src/shims/panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "patch": "@@ -51,7 +51,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         trace!(\"miri_start_panic: {:?}\", this.frame().instance);\n \n         // Get the raw pointer stored in arg[0] (the panic payload).\n-        let &[ref payload] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+        let [payload] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n         let payload = this.read_scalar(payload)?.check_init()?;\n         let thread = this.active_thread_mut();\n         assert!(thread.panic_payload.is_none(), \"the panic runtime should avoid double-panics\");\n@@ -83,7 +83,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // a pointer to `Box<dyn Any + Send + 'static>`.\n \n         // Get all the arguments.\n-        let &[ref try_fn, ref data, ref catch_fn] = check_arg_count(args)?;\n+        let [try_fn, data, catch_fn] = check_arg_count(args)?;\n         let try_fn = this.read_pointer(try_fn)?;\n         let data = this.read_scalar(data)?.check_init()?;\n         let catch_fn = this.read_scalar(catch_fn)?.check_init()?;"}, {"sha": "566befb0efd0afa316c22b5a728a540e3cf272ce", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "patch": "@@ -29,28 +29,28 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match &*link_name.as_str() {\n             // Environment related shims\n             \"getenv\" => {\n-                let &[ref name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.getenv(name)?;\n                 this.write_pointer(result, dest)?;\n             }\n             \"unsetenv\" => {\n-                let &[ref name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.unsetenv(name)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"setenv\" => {\n-                let &[ref name, ref value, ref overwrite] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [name, value, overwrite] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(overwrite)?.to_i32()?;\n                 let result = this.setenv(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"getcwd\" => {\n-                let &[ref buf, ref size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [buf, size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.getcwd(buf, size)?;\n                 this.write_pointer(result, dest)?;\n             }\n             \"chdir\" => {\n-                let &[ref path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.chdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n@@ -70,15 +70,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"read\" => {\n-                let &[ref fd, ref buf, ref count] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [fd, buf, count] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_pointer(buf)?;\n                 let count = this.read_scalar(count)?.to_machine_usize(this)?;\n                 let result = this.read(fd, buf, count)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"write\" => {\n-                let &[ref fd, ref buf, ref n] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [fd, buf, n] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_pointer(buf)?;\n                 let count = this.read_scalar(n)?.to_machine_usize(this)?;\n@@ -88,60 +88,60 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"unlink\" => {\n-                let &[ref path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.unlink(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"symlink\" => {\n-                let &[ref target, ref linkpath] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [target, linkpath] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.symlink(target, linkpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rename\" => {\n-                let &[ref oldpath, ref newpath] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [oldpath, newpath] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.rename(oldpath, newpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mkdir\" => {\n-                let &[ref path, ref mode] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [path, mode] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.mkdir(path, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rmdir\" => {\n-                let &[ref path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [path] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.rmdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"closedir\" => {\n-                let &[ref dirp] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [dirp] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.closedir(dirp)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lseek\" | \"lseek64\" => {\n-                let &[ref fd, ref offset, ref whence] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [fd, offset, whence] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.lseek64(fd, offset, whence)?;\n                 // \"lseek\" is only used on macOS which is 64bit-only, so `i64` always works.\n                 this.write_scalar(Scalar::from_i64(result), dest)?;\n             }\n             \"fsync\" => {\n-                let &[ref fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.fsync(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fdatasync\" => {\n-                let &[ref fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.fdatasync(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"readlink\" => {\n-                let &[ref pathname, ref buf, ref bufsize] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [pathname, buf, bufsize] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.readlink(pathname, buf, bufsize)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n \n             // Allocation\n             \"posix_memalign\" => {\n-                let &[ref ret, ref align, ref size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [ret, align, size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let ret = this.deref_operand(ret)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n@@ -171,7 +171,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Dynamic symbol loading\n             \"dlsym\" => {\n-                let &[ref handle, ref symbol] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [handle, symbol] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(handle)?.to_machine_usize(this)?;\n                 let symbol = this.read_pointer(symbol)?;\n                 let symbol_name = this.read_c_str(symbol)?;\n@@ -185,7 +185,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"sysconf\" => {\n-                let &[ref name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let name = this.read_scalar(name)?.to_i32()?;\n \n                 let sysconfs = &[\n@@ -210,7 +210,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"pthread_key_create\" => {\n-                let &[ref key, ref dtor] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [key, dtor] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let key_place = this.deref_operand(key)?;\n                 let dtor = this.read_pointer(dtor)?;\n \n@@ -239,21 +239,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"pthread_key_delete\" => {\n-                let &[ref key] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [key] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let key = this.read_scalar(key)?.check_init()?.to_bits(key.layout.size)?;\n                 this.machine.tls.delete_tls_key(key)?;\n                 // Return success (0)\n                 this.write_null(dest)?;\n             }\n             \"pthread_getspecific\" => {\n-                let &[ref key] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [key] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let key = this.read_scalar(key)?.check_init()?.to_bits(key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n-                let &[ref key, ref new_ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [key, new_ptr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let key = this.read_scalar(key)?.check_init()?.to_bits(key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n                 let new_data = this.read_scalar(new_ptr)?;\n@@ -265,149 +265,149 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Synchronization primitives\n             \"pthread_mutexattr_init\" => {\n-                let &[ref attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutexattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_settype\" => {\n-                let &[ref attr, ref kind] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [attr, kind] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutexattr_settype(attr, kind)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_destroy\" => {\n-                let &[ref attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutexattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_init\" => {\n-                let &[ref mutex, ref attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [mutex, attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutex_init(mutex, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_lock\" => {\n-                let &[ref mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutex_lock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_trylock\" => {\n-                let &[ref mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutex_trylock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_unlock\" => {\n-                let &[ref mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutex_unlock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_destroy\" => {\n-                let &[ref mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_mutex_destroy(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_rdlock\" => {\n-                let &[ref rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_rwlock_rdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_tryrdlock\" => {\n-                let &[ref rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_rwlock_tryrdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_wrlock\" => {\n-                let &[ref rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_rwlock_wrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_trywrlock\" => {\n-                let &[ref rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_rwlock_trywrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_unlock\" => {\n-                let &[ref rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_rwlock_unlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_destroy\" => {\n-                let &[ref rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [rwlock] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_rwlock_destroy(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_init\" => {\n-                let &[ref attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_condattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_destroy\" => {\n-                let &[ref attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_condattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_init\" => {\n-                let &[ref cond, ref attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [cond, attr] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_cond_init(cond, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_signal\" => {\n-                let &[ref cond] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [cond] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_cond_signal(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_broadcast\" => {\n-                let &[ref cond] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [cond] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_cond_broadcast(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_wait\" => {\n-                let &[ref cond, ref mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [cond, mutex] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_cond_wait(cond, mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_timedwait\" => {\n-                let &[ref cond, ref mutex, ref abstime] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [cond, mutex, abstime] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.pthread_cond_timedwait(cond, mutex, abstime, dest)?;\n             }\n             \"pthread_cond_destroy\" => {\n-                let &[ref cond] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [cond] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_cond_destroy(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Threading\n             \"pthread_create\" => {\n-                let &[ref thread, ref attr, ref start, ref arg] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [thread, attr, start, arg] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_create(thread, attr, start, arg)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_join\" => {\n-                let &[ref thread, ref retval] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [thread, retval] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_join(thread, retval)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_detach\" => {\n-                let &[ref thread] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [thread] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_detach(thread)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_self\" => {\n-                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.pthread_self(dest)?;\n             }\n             \"sched_yield\" => {\n-                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.sched_yield()?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"nanosleep\" => {\n-                let &[ref req, ref rem] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [req, rem] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.nanosleep(req, rem)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Miscellaneous\n             \"isatty\" => {\n-                let &[ref fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n                 // \"returns 1 if fd is an open file descriptor referring to a terminal; otherwise 0 is returned, and errno is set to indicate the error\"\n                 // FIXME: we just say nothing is a terminal.\n@@ -416,15 +416,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"pthread_atfork\" => {\n-                let &[ref prepare, ref parent, ref child] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [prepare, parent, child] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_pointer(prepare)?;\n                 this.read_pointer(parent)?;\n                 this.read_pointer(child)?;\n                 // We do not support forking, so there is nothing to do here.\n                 this.write_null(dest)?;\n             }\n             \"strerror_r\" | \"__xpg_strerror_r\" => {\n-                let &[ref errnum, ref buf, ref buflen] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [errnum, buf, buflen] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let errnum = this.read_scalar(errnum)?.check_init()?;\n                 let buf = this.read_pointer(buf)?;\n                 let buflen = this.read_scalar(buflen)?.to_machine_usize(this)?;\n@@ -440,7 +440,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These shims are enabled only when the caller is in the standard library.\n             \"pthread_attr_getguardsize\"\n             if this.frame_in_std() => {\n-                let &[ref _attr, ref guard_size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [_attr, guard_size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let guard_size = this.deref_operand(guard_size)?;\n                 let guard_size_layout = this.libc_ty_layout(\"size_t\")?;\n                 this.write_scalar(Scalar::from_uint(crate::PAGE_SIZE, guard_size_layout.size), &guard_size.into())?;\n@@ -452,25 +452,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"pthread_attr_init\"\n             | \"pthread_attr_destroy\"\n             if this.frame_in_std() => {\n-                let &[_] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [_] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_null(dest)?;\n             }\n             | \"pthread_attr_setstacksize\"\n             if this.frame_in_std() => {\n-                let &[_, _] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [_, _] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_null(dest)?;\n             }\n \n             | \"signal\"\n             | \"sigaltstack\"\n             if this.frame_in_std() => {\n-                let &[_, _] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [_, _] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_null(dest)?;\n             }\n             | \"sigaction\"\n             | \"mprotect\"\n             if this.frame_in_std() => {\n-                let &[_, _, _] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [_, _, _] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_null(dest)?;\n             }\n "}, {"sha": "f966c63b723994bbab7ebe30170c2249bb13b1c7", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "patch": "@@ -24,7 +24,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match &*link_name.as_str() {\n             // errno\n             \"__errno_location\" => {\n-                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let errno_place = this.last_error_place()?;\n                 this.write_scalar(errno_place.to_ref(this).to_scalar()?, dest)?;\n             }\n@@ -33,31 +33,29 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These symbols have different names on Linux and macOS, which is the only reason they are not\n             // in the `posix` module.\n             \"close\" => {\n-                let &[ref fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.close(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" => {\n-                let &[ref name] =\n-                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir64\" => {\n-                let &[ref dirp] =\n-                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [dirp] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.linux_readdir64(dirp)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"ftruncate64\" => {\n-                let &[ref fd, ref length] =\n+                let [fd, length] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             // Linux-only\n             \"posix_fadvise\" => {\n-                let &[ref fd, ref offset, ref len, ref advice] =\n+                let [fd, offset, len, advice] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n                 this.read_scalar(offset)?.to_machine_isize(this)?;\n@@ -67,7 +65,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"sync_file_range\" => {\n-                let &[ref fd, ref offset, ref nbytes, ref flags] =\n+                let [fd, offset, nbytes, flags] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.sync_file_range(fd, offset, nbytes, flags)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n@@ -76,7 +74,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Time related shims\n             \"clock_gettime\" => {\n                 // This is a POSIX function but it has only been tested on linux.\n-                let &[ref clk_id, ref tp] =\n+                let [clk_id, tp] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.clock_gettime(clk_id, tp)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n@@ -85,7 +83,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Querying system information\n             \"pthread_attr_getstack\" => {\n                 // We don't support \"pthread_attr_setstack\", so we just pretend all stacks have the same values here.\n-                let &[ref attr_place, ref addr_place, ref size_place] =\n+                let [attr_place, addr_place, size_place] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.deref_operand(attr_place)?;\n                 let addr_place = this.deref_operand(addr_place)?;\n@@ -112,13 +110,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_setclock\" => {\n-                let &[ref attr, ref clock_id] =\n+                let [attr, clock_id] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_condattr_setclock(attr, clock_id)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_getclock\" => {\n-                let &[ref attr, ref clock_id] =\n+                let [attr, clock_id] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.pthread_condattr_getclock(attr, clock_id)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n@@ -185,12 +183,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Miscelanneous\n             \"getrandom\" => {\n-                let &[ref ptr, ref len, ref flags] =\n+                let [ptr, len, flags] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 getrandom(this, ptr, len, flags, dest)?;\n             }\n             \"sched_getaffinity\" => {\n-                let &[ref pid, ref cpusetsize, ref mask] =\n+                let [pid, cpusetsize, mask] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(pid)?.to_i32()?;\n                 this.read_scalar(cpusetsize)?.to_machine_usize(this)?;\n@@ -204,7 +202,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"pthread_getattr_np\" if this.frame_in_std() => {\n-                let &[ref _thread, ref _attr] =\n+                let [_thread, _attr] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_null(dest)?;\n             }"}, {"sha": "8ce56d35da653104707a98cf27bb619d52ecba07", "filename": "src/shims/posix/macos/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fposix%2Fmacos%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fposix%2Fmacos%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fdlsym.rs?ref=49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "patch": "@@ -36,7 +36,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         match dlsym {\n             Dlsym::getentropy => {\n-                let &[ref ptr, ref len] = check_arg_count(args)?;\n+                let [ptr, len] = check_arg_count(args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let len = this.read_scalar(len)?.to_machine_usize(this)?;\n                 this.gen_random(ptr, len)?;"}, {"sha": "7f6393fd30f10b01fa924e719479024e5ce15fbc", "filename": "src/shims/posix/macos/foreign_items.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs?ref=49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "patch": "@@ -22,58 +22,55 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match &*link_name.as_str() {\n             // errno\n             \"__error\" => {\n-                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let errno_place = this.last_error_place()?;\n                 this.write_scalar(errno_place.to_ref(this).to_scalar()?, dest)?;\n             }\n \n             // File related shims\n             \"close\" | \"close$NOCANCEL\" => {\n-                let &[ref result] =\n-                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [result] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.close(result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"stat\" | \"stat$INODE64\" => {\n-                let &[ref path, ref buf] =\n+                let [path, buf] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.macos_stat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lstat\" | \"lstat$INODE64\" => {\n-                let &[ref path, ref buf] =\n+                let [path, buf] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.macos_lstat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fstat\" | \"fstat$INODE64\" => {\n-                let &[ref fd, ref buf] =\n-                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [fd, buf] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.macos_fstat(fd, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" | \"opendir$INODE64\" => {\n-                let &[ref name] =\n-                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir_r\" | \"readdir_r$INODE64\" => {\n-                let &[ref dirp, ref entry, ref result] =\n+                let [dirp, entry, result] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.macos_readdir_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate\" => {\n-                let &[ref fd, ref length] =\n+                let [fd, length] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Environment related shims\n             \"_NSGetEnviron\" => {\n-                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_pointer(\n                     this.machine.env_vars.environ.expect(\"machine must be initialized\").ptr,\n                     dest,\n@@ -82,34 +79,32 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Time related shims\n             \"gettimeofday\" => {\n-                let &[ref tv, ref tz] =\n-                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [tv, tz] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.gettimeofday(tv, tz)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mach_absolute_time\" => {\n-                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.mach_absolute_time()?;\n                 this.write_scalar(Scalar::from_u64(result), dest)?;\n             }\n \n             \"mach_timebase_info\" => {\n-                let &[ref info] =\n-                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [info] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.mach_timebase_info(info)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Access to command-line arguments\n             \"_NSGetArgc\" => {\n-                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_pointer(\n                     this.machine.argc.expect(\"machine must be initialized\").ptr,\n                     dest,\n                 )?;\n             }\n             \"_NSGetArgv\" => {\n-                let &[] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.write_pointer(\n                     this.machine.argv.expect(\"machine must be initialized\").ptr,\n                     dest,\n@@ -118,7 +113,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"_tlv_atexit\" => {\n-                let &[ref dtor, ref data] =\n+                let [dtor, data] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let dtor = this.read_pointer(dtor)?;\n                 let dtor = this.get_ptr_fn(dtor)?.as_instance()?;\n@@ -129,24 +124,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"pthread_get_stackaddr_np\" => {\n-                let &[ref thread] =\n-                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [thread] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(thread)?.to_machine_usize(this)?;\n                 let stack_addr = Scalar::from_uint(STACK_ADDR, this.pointer_size());\n                 this.write_scalar(stack_addr, dest)?;\n             }\n             \"pthread_get_stacksize_np\" => {\n-                let &[ref thread] =\n-                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [thread] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_scalar(thread)?.to_machine_usize(this)?;\n                 let stack_size = Scalar::from_uint(STACK_SIZE, this.pointer_size());\n                 this.write_scalar(stack_size, dest)?;\n             }\n \n             // Threading\n             \"pthread_setname_np\" => {\n-                let &[ref name] =\n-                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let name = this.read_pointer(name)?;\n                 this.pthread_setname_np(name)?;\n             }\n@@ -155,7 +147,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These shims are enabled only when the caller is in the standard library.\n             \"mmap\" if this.frame_in_std() => {\n                 // This is a horrible hack, but since the guard page mechanism calls mmap and expects a particular return value, we just give it that value.\n-                let &[ref addr, _, _, _, _, _] =\n+                let [addr, _, _, _, _, _] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let addr = this.read_scalar(addr)?.check_init()?;\n                 this.write_scalar(addr, dest)?;"}, {"sha": "5583e3a25895fee22c3b4a3e663dd89d8e91aa0b", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "patch": "@@ -47,16 +47,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     );\n                 }\n \n-                let &[\n-                    ref handle,\n-                    ref _event,\n-                    ref _apc_routine,\n-                    ref _apc_context,\n-                    ref io_status_block,\n-                    ref buf,\n-                    ref n,\n-                    ref byte_offset,\n-                    ref _key,\n+                let [\n+                    handle,\n+                    _event,\n+                    _apc_routine,\n+                    _apc_context,\n+                    io_status_block,\n+                    buf,\n+                    n,\n+                    byte_offset,\n+                    _key,\n                 ] = check_arg_count(args)?;\n                 let handle = this.read_scalar(handle)?.to_machine_isize(this)?;\n                 let buf = this.read_pointer(buf)?;"}, {"sha": "c49362d52b311aaee424772212d9642ea1fd718d", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 40, "deletions": 47, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "patch": "@@ -30,44 +30,44 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match &*link_name.as_str() {\n             // Environment related shims\n             \"GetEnvironmentVariableW\" => {\n-                let &[ref name, ref buf, ref size] =\n+                let [name, buf, size] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.GetEnvironmentVariableW(name, buf, size)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetEnvironmentVariableW\" => {\n-                let &[ref name, ref value] =\n+                let [name, value] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.SetEnvironmentVariableW(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetEnvironmentStringsW\" => {\n-                let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.GetEnvironmentStringsW()?;\n                 this.write_pointer(result, dest)?;\n             }\n             \"FreeEnvironmentStringsW\" => {\n-                let &[ref env_block] =\n+                let [env_block] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.FreeEnvironmentStringsW(env_block)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetCurrentDirectoryW\" => {\n-                let &[ref size, ref buf] =\n+                let [size, buf] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.GetCurrentDirectoryW(size, buf)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetCurrentDirectoryW\" => {\n-                let &[ref path] =\n+                let [path] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.SetCurrentDirectoryW(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Allocation\n             \"HeapAlloc\" => {\n-                let &[ref handle, ref flags, ref size] =\n+                let [handle, flags, size] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n@@ -77,7 +77,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_pointer(res, dest)?;\n             }\n             \"HeapFree\" => {\n-                let &[ref handle, ref flags, ref ptr] =\n+                let [handle, flags, ptr] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n@@ -86,7 +86,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }\n             \"HeapReAlloc\" => {\n-                let &[ref handle, ref flags, ref ptr, ref size] =\n+                let [handle, flags, ptr, size] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n@@ -98,20 +98,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // errno\n             \"SetLastError\" => {\n-                let &[ref error] =\n+                let [error] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let error = this.read_scalar(error)?.check_init()?;\n                 this.set_last_error(error)?;\n             }\n             \"GetLastError\" => {\n-                let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let last_error = this.get_last_error()?;\n                 this.write_scalar(last_error, dest)?;\n             }\n \n             // Querying system information\n             \"GetSystemInfo\" => {\n-                let &[ref system_info] =\n+                let [system_info] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let system_info = this.deref_operand(system_info)?;\n                 // Initialize with `0`.\n@@ -130,20 +130,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // This just creates a key; Windows does not natively support TLS destructors.\n \n                 // Create key and return it.\n-                let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let key = this.machine.tls.create_tls_key(None, dest.layout.size)?;\n                 this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n             }\n             \"TlsGetValue\" => {\n-                let &[ref key] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [key] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n-                let &[ref key, ref new_ptr] =\n+                let [key, new_ptr] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n@@ -156,7 +155,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Access to command-line arguments\n             \"GetCommandLineW\" => {\n-                let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.write_pointer(\n                     this.machine.cmd_line.expect(\"machine must be initialized\").ptr,\n                     dest,\n@@ -166,63 +165,57 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Time related shims\n             \"GetSystemTimeAsFileTime\" => {\n                 #[allow(non_snake_case)]\n-                let &[ref LPFILETIME] =\n+                let [LPFILETIME] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.GetSystemTimeAsFileTime(LPFILETIME)?;\n             }\n             \"QueryPerformanceCounter\" => {\n                 #[allow(non_snake_case)]\n-                let &[ref lpPerformanceCount] =\n+                let [lpPerformanceCount] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.QueryPerformanceCounter(lpPerformanceCount)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"QueryPerformanceFrequency\" => {\n                 #[allow(non_snake_case)]\n-                let &[ref lpFrequency] =\n+                let [lpFrequency] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.QueryPerformanceFrequency(lpFrequency)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Synchronization primitives\n             \"AcquireSRWLockExclusive\" => {\n-                let &[ref ptr] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [ptr] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.AcquireSRWLockExclusive(ptr)?;\n             }\n             \"ReleaseSRWLockExclusive\" => {\n-                let &[ref ptr] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [ptr] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.ReleaseSRWLockExclusive(ptr)?;\n             }\n             \"TryAcquireSRWLockExclusive\" => {\n-                let &[ref ptr] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [ptr] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let ret = this.TryAcquireSRWLockExclusive(ptr)?;\n                 this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n             \"AcquireSRWLockShared\" => {\n-                let &[ref ptr] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [ptr] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.AcquireSRWLockShared(ptr)?;\n             }\n             \"ReleaseSRWLockShared\" => {\n-                let &[ref ptr] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [ptr] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.ReleaseSRWLockShared(ptr)?;\n             }\n             \"TryAcquireSRWLockShared\" => {\n-                let &[ref ptr] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [ptr] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let ret = this.TryAcquireSRWLockShared(ptr)?;\n                 this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n \n             // Dynamic symbol loading\n             \"GetProcAddress\" => {\n                 #[allow(non_snake_case)]\n-                let &[ref hModule, ref lpProcName] =\n+                let [hModule, lpProcName] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(hModule)?.to_machine_isize(this)?;\n                 let name = this.read_c_str(this.read_pointer(lpProcName)?)?;\n@@ -237,15 +230,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Miscellaneous\n             \"SystemFunction036\" => {\n                 // This is really 'RtlGenRandom'.\n-                let &[ref ptr, ref len] =\n+                let [ptr, len] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n                 let len = this.read_scalar(len)?.to_u32()?;\n                 this.gen_random(ptr, len.into())?;\n                 this.write_scalar(Scalar::from_bool(true), dest)?;\n             }\n             \"BCryptGenRandom\" => {\n-                let &[ref algorithm, ref ptr, ref len, ref flags] =\n+                let [algorithm, ptr, len, flags] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let algorithm = this.read_scalar(algorithm)?;\n                 let ptr = this.read_pointer(ptr)?;\n@@ -267,7 +260,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"GetConsoleScreenBufferInfo\" => {\n                 // `term` needs this, so we fake it.\n-                let &[ref console, ref buffer_info] =\n+                let [console, buffer_info] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(console)?.to_machine_isize(this)?;\n                 this.deref_operand(buffer_info)?;\n@@ -277,7 +270,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"GetConsoleMode\" => {\n                 // Windows \"isatty\" (in libtest) needs this, so we fake it.\n-                let &[ref console, ref mode] =\n+                let [console, mode] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 this.read_scalar(console)?.to_machine_isize(this)?;\n                 this.deref_operand(mode)?;\n@@ -286,13 +279,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"SwitchToThread\" => {\n-                let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Note that once Miri supports concurrency, this will need to return a nonzero\n                 // value if this call does result in switching to another thread.\n                 this.write_null(dest)?;\n             }\n             \"GetStdHandle\" => {\n-                let &[ref which] =\n+                let [which] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let which = this.read_scalar(which)?.to_i32()?;\n                 // We just make this the identity function, so we know later in `NtWriteFile` which\n@@ -303,7 +296,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Better error for attempts to create a thread\n             \"CreateThread\" => {\n-                let &[_, _, _, _, _, _] =\n+                let [_, _, _, _, _, _] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n \n                 this.handle_unsupported(\"can't create threads on Windows\")?;\n@@ -313,34 +306,34 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"GetProcessHeap\" if this.frame_in_std() => {\n-                let &[] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Just fake a HANDLE\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n             \"GetModuleHandleA\" if this.frame_in_std() => {\n                 #[allow(non_snake_case)]\n-                let &[_lpModuleName] =\n+                let [_lpModuleName] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // We need to return something non-null here to make `compat_fn!` work.\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n             \"SetConsoleTextAttribute\" if this.frame_in_std() => {\n                 #[allow(non_snake_case)]\n-                let &[ref _hConsoleOutput, ref _wAttribute] =\n+                let [_hConsoleOutput, _wAttribute] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Pretend these does not exist / nothing happened, by returning zero.\n                 this.write_null(dest)?;\n             }\n             \"AddVectoredExceptionHandler\" if this.frame_in_std() => {\n                 #[allow(non_snake_case)]\n-                let &[ref _First, ref _Handler] =\n+                let [_First, _Handler] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_machine_usize(1, this), dest)?;\n             }\n             \"SetThreadStackGuarantee\" if this.frame_in_std() => {\n                 #[allow(non_snake_case)]\n-                let &[_StackSizeInBytes] =\n+                let [_StackSizeInBytes] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_u32(1), dest)?;\n@@ -352,7 +345,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if this.frame_in_std() =>\n             {\n                 #[allow(non_snake_case)]\n-                let &[ref _lpCriticalSection] =\n+                let [_lpCriticalSection] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 assert_eq!(\n                     this.get_total_thread_count(),\n@@ -365,7 +358,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"TryEnterCriticalSection\" if this.frame_in_std() => {\n                 #[allow(non_snake_case)]\n-                let &[ref _lpCriticalSection] =\n+                let [_lpCriticalSection] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 assert_eq!(\n                     this.get_total_thread_count(),"}, {"sha": "749f93fc0fd2c6bb2ad3d76d31e24aad5824ff62", "filename": "tests/run-pass/vec-matching-fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/tests%2Frun-pass%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49366abfb05d2b04363ba93dae9f8fc78d9f5ee6/tests%2Frun-pass%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvec-matching-fold.rs?ref=49366abfb05d2b04363ba93dae9f8fc78d9f5ee6", "patch": "@@ -7,9 +7,9 @@ fn foldl<T, U, F>(values: &[T],\n     U: Clone+Debug, T:Debug,\n     F: FnMut(U, &T) -> U,\n {    match values {\n-        &[ref head, ref tail @ ..] =>\n+        [head, tail @ ..] =>\n             foldl(tail, function(initial, head), function),\n-        &[] => {\n+        [] => {\n             let res = initial.clone(); res\n         }\n     }\n@@ -23,9 +23,9 @@ fn foldr<T, U, F>(values: &[T],\n     F: FnMut(&T, U) -> U,\n {\n     match values {\n-        &[ref head @ .., ref tail] =>\n+        [head @ .., tail] =>\n             foldr(head, function(tail, initial), function),\n-        &[] => {\n+        [] => {\n             let res = initial.clone(); res\n         }\n     }"}]}