{"sha": "0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYzdhMjE5ZjA0M2QzYjFjOGMyMzkwODlkOWRkNmU2YzlmYTgzMGI=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-08-03T23:59:24Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-08-05T20:42:21Z"}, "message": "Updated std::Option, std::Either and std::Result\n\n- Made naming schemes consistent between Option, Result and Either\n- Changed Options Add implementation to work like the maybe monad (return None if any of the inputs is None)\n- Removed duplicate Option::get and renamed all related functions to use the term `unwrap` instead", "tree": {"sha": "6dbb028659dbc0931ec23398e529549c84bba0a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dbb028659dbc0931ec23398e529549c84bba0a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "html_url": "https://github.com/rust-lang/rust/commit/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8b299d179653cbde783f62f70b5531dbaa5c5a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8b299d179653cbde783f62f70b5531dbaa5c5a6", "html_url": "https://github.com/rust-lang/rust/commit/d8b299d179653cbde783f62f70b5531dbaa5c5a6"}], "stats": {"total": 1609, "additions": 792, "deletions": 817}, "files": [{"sha": "094d176980b81d2ebafae44bcb9787cac23dc044", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -131,7 +131,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n         ratchet_noise_percent:\n             getopts::opt_maybe_str(matches,\n                                    \"ratchet-noise-percent\").map(|s|\n-                                                                f64::from_str(*s).get()),\n+                                                                f64::from_str(*s).unwrap()),\n         runtool: getopts::opt_maybe_str(matches, \"runtool\"),\n         rustcflags: getopts::opt_maybe_str(matches, \"rustcflags\"),\n         jit: getopts::opt_present(matches, \"jit\"),\n@@ -267,7 +267,7 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n           _ => ~[~\".rc\", ~\".rs\"]\n         };\n     let invalid_prefixes = ~[~\".\", ~\"#\", ~\"~\"];\n-    let name = testfile.filename().get();\n+    let name = testfile.filename().unwrap();\n \n     let mut valid = false;\n \n@@ -300,7 +300,7 @@ pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n     fn shorten(path: &Path) -> ~str {\n         let filename = path.filename();\n         let dir = path.pop().filename();\n-        fmt!(\"%s/%s\", dir.get_or_default(~\"\"), filename.get_or_default(~\"\"))\n+        fmt!(\"%s/%s\", dir.unwrap_or_default(~\"\"), filename.unwrap_or_default(~\"\"))\n     }\n \n     test::DynTestName(fmt!(\"[%s] %s\","}, {"sha": "5c1cc78d678f361f1525226fbcb8e1bf7f807f34", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -145,7 +145,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n-    let mut srcs = ~[io::read_whole_file_str(testfile).get()];\n+    let mut srcs = ~[io::read_whole_file_str(testfile).unwrap()];\n \n     let mut round = 0;\n     while round < rounds {\n@@ -166,7 +166,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n         match props.pp_exact {\n           Some(ref file) => {\n             let filepath = testfile.dir_path().push_rel(file);\n-            io::read_whole_file_str(&filepath).get()\n+            io::read_whole_file_str(&filepath).unwrap()\n           }\n           None => { srcs[srcs.len() - 2u].clone() }\n         };\n@@ -448,7 +448,7 @@ fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if opt.is_none() {\n         return false;\n     }\n-    *idx = opt.get();\n+    *idx = opt.unwrap();\n     return true;\n }\n \n@@ -709,7 +709,7 @@ fn aux_output_dir_name(config: &config, testfile: &Path) -> Path {\n }\n \n fn output_testname(testfile: &Path) -> Path {\n-    Path(testfile.filestem().get())\n+    Path(testfile.filestem().unwrap())\n }\n \n fn output_base_name(config: &config, testfile: &Path) -> Path {\n@@ -878,7 +878,7 @@ fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n     if suffix.len() == 0 {\n         (*p).clone()\n     } else {\n-        let stem = p.filestem().get();\n+        let stem = p.filestem().unwrap();\n         p.with_filestem(stem + \"-\" + suffix)\n     }\n }\n@@ -938,7 +938,7 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n \n fn count_extracted_lines(p: &Path) -> uint {\n-    let x = io::read_whole_file_str(&p.with_filetype(\"ll\")).get();\n+    let x = io::read_whole_file_str(&p.with_filetype(\"ll\")).unwrap();\n     x.line_iter().len_()\n }\n "}, {"sha": "550b891a4db16c22356d20be362f55ca7b06e6cb", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -322,24 +322,24 @@ mod test {\n \n     #[test]\n     fn test_from_base64_basic() {\n-        assert_eq!(\"\".from_base64().get(), \"\".as_bytes().to_owned());\n-        assert_eq!(\"Zg==\".from_base64().get(), \"f\".as_bytes().to_owned());\n-        assert_eq!(\"Zm8=\".from_base64().get(), \"fo\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9v\".from_base64().get(), \"foo\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYg==\".from_base64().get(), \"foob\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYmE=\".from_base64().get(), \"fooba\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYmFy\".from_base64().get(), \"foobar\".as_bytes().to_owned());\n+        assert_eq!(\"\".from_base64().unwrap(), \"\".as_bytes().to_owned());\n+        assert_eq!(\"Zg==\".from_base64().unwrap(), \"f\".as_bytes().to_owned());\n+        assert_eq!(\"Zm8=\".from_base64().unwrap(), \"fo\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9v\".from_base64().unwrap(), \"foo\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYg==\".from_base64().unwrap(), \"foob\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYmE=\".from_base64().unwrap(), \"fooba\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9vYmFy\".from_base64().unwrap(), \"foobar\".as_bytes().to_owned());\n     }\n \n     #[test]\n     fn test_from_base64_newlines() {\n-        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().get(),\n+        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().unwrap(),\n                    \"foobar\".as_bytes().to_owned());\n     }\n \n     #[test]\n     fn test_from_base64_urlsafe() {\n-        assert_eq!(\"-_8\".from_base64().get(), \"+/8=\".from_base64().get());\n+        assert_eq!(\"-_8\".from_base64().unwrap(), \"+/8=\".from_base64().unwrap());\n     }\n \n     #[test]\n@@ -364,7 +364,7 @@ mod test {\n                     push(random());\n                 }\n             };\n-            assert_eq!(v.to_base64(STANDARD).from_base64().get(), v);\n+            assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n         }\n     }\n "}, {"sha": "7a36b25eac57a53b32bb877c21e69bb60e97c109", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -526,8 +526,8 @@ mod test {\n \n         do input_vec_state(filenames) |line, state| {\n             let nums: ~[&str] = line.split_iter(' ').collect();\n-            let file_num = uint::from_str(nums[0]).get();\n-            let line_num = uint::from_str(nums[1]).get();\n+            let file_num = uint::from_str(nums[0]).unwrap();\n+            let line_num = uint::from_str(nums[1]).unwrap();\n             assert_eq!(line_num, state.line_num_file);\n             assert_eq!(file_num * 3 + line_num, state.line_num);\n             true"}, {"sha": "15aac8ef47c9e660dd59ac98ab0e947f0951b1c9", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -196,7 +196,7 @@ fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n  * The type returned when the command line does not conform to the\n  * expected format. Pass this value to <fail_str> to get an error message.\n  */\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, ToStr)]\n pub enum Fail_ {\n     ArgumentMissing(~str),\n     UnrecognizedOption(~str),\n@@ -288,7 +288,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                       None => {\n                         let arg_follows =\n                             last_valid_opt_id.is_some() &&\n-                            match opts[last_valid_opt_id.get()]\n+                            match opts[last_valid_opt_id.unwrap()]\n                               .hasarg {\n \n                               Yes | Maybe => true,\n@@ -322,15 +322,15 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                   }\n                   Maybe => {\n                     if !i_arg.is_none() {\n-                        vals[optid].push(Val((i_arg.clone()).get()));\n+                        vals[optid].push(Val((i_arg.clone()).unwrap()));\n                     } else if name_pos < names.len() ||\n                                   i + 1 == l || is_arg(args[i + 1]) {\n                         vals[optid].push(Given);\n                     } else { i += 1; vals[optid].push(Val(args[i].clone())); }\n                   }\n                   Yes => {\n                     if !i_arg.is_none() {\n-                        vals[optid].push(Val(i_arg.clone().get()));\n+                        vals[optid].push(Val(i_arg.clone().unwrap()));\n                     } else if i + 1 == l {\n                         return Err(ArgumentMissing(name_str(nm)));\n                     } else { i += 1; vals[optid].push(Val(args[i].clone())); }"}, {"sha": "bced00902c95f5abdcc62dee20adb3b42f14d372", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -1510,11 +1510,11 @@ mod biguint_tests {\n \n     #[test]\n     fn test_is_even() {\n-        assert!(FromStr::from_str::<BigUint>(\"1\").get().is_odd());\n-        assert!(FromStr::from_str::<BigUint>(\"2\").get().is_even());\n-        assert!(FromStr::from_str::<BigUint>(\"1000\").get().is_even());\n-        assert!(FromStr::from_str::<BigUint>(\"1000000000000000000000\").get().is_even());\n-        assert!(FromStr::from_str::<BigUint>(\"1000000000000000000001\").get().is_odd());\n+        assert!(FromStr::from_str::<BigUint>(\"1\").unwrap().is_odd());\n+        assert!(FromStr::from_str::<BigUint>(\"2\").unwrap().is_even());\n+        assert!(FromStr::from_str::<BigUint>(\"1000\").unwrap().is_even());\n+        assert!(FromStr::from_str::<BigUint>(\"1000000000000000000000\").unwrap().is_even());\n+        assert!(FromStr::from_str::<BigUint>(\"1000000000000000000001\").unwrap().is_odd());\n         assert!((BigUint::from_uint(1) << 64).is_even());\n         assert!(((BigUint::from_uint(1) << 64) + BigUint::from_uint(1)).is_odd());\n     }\n@@ -1595,7 +1595,7 @@ mod biguint_tests {\n             let &(ref n, ref rs) = num_pair;\n             for str_pair in rs.iter() {\n                 let &(ref radix, ref str) = str_pair;\n-                assert_eq!(n, &FromStrRadix::from_str_radix(*str, *radix).get());\n+                assert_eq!(n, &FromStrRadix::from_str_radix(*str, *radix).unwrap());\n             }\n         }\n "}, {"sha": "9833bd5d1cbf2cebe758fe7213832681d2bba76c", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -437,12 +437,12 @@ mod tests {\n         assert_eq!(deq.len(), 3);\n         deq.push_back(d.clone());\n         assert_eq!(deq.len(), 4);\n-        assert_eq!((*deq.front().get()).clone(), b.clone());\n-        assert_eq!((*deq.back().get()).clone(), d.clone());\n-        assert_eq!(deq.pop_front().get(), b.clone());\n-        assert_eq!(deq.pop_back().get(), d.clone());\n-        assert_eq!(deq.pop_back().get(), c.clone());\n-        assert_eq!(deq.pop_back().get(), a.clone());\n+        assert_eq!((*deq.front().unwrap()).clone(), b.clone());\n+        assert_eq!((*deq.back().unwrap()).clone(), d.clone());\n+        assert_eq!(deq.pop_front().unwrap(), b.clone());\n+        assert_eq!(deq.pop_back().unwrap(), d.clone());\n+        assert_eq!(deq.pop_back().unwrap(), c.clone());\n+        assert_eq!(deq.pop_back().unwrap(), a.clone());\n         assert_eq!(deq.len(), 0);\n         deq.push_back(c.clone());\n         assert_eq!(deq.len(), 1);"}, {"sha": "b0f89e219d8d8aa81d06240a04aaa853dae5e0b0", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -386,8 +386,8 @@ fn test_spec_order() {\n               \"1.0.0\"];\n     let mut i = 1;\n     while i < vs.len() {\n-        let a = parse(vs[i-1]).get();\n-        let b = parse(vs[i]).get();\n+        let a = parse(vs[i-1]).unwrap();\n+        let b = parse(vs[i]).unwrap();\n         assert!(a < b);\n         i += 1;\n     }"}, {"sha": "3f62317eb8908ca7b083f91b7edfee1e0b08af3c", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -366,9 +366,9 @@ mod test_map {\n         map.update_with_key(3, 2, addMoreToCount);\n \n         // check the total counts\n-        assert_eq!(map.find(&3).get(), &10);\n-        assert_eq!(map.find(&5).get(), &3);\n-        assert_eq!(map.find(&9).get(), &1);\n+        assert_eq!(map.find(&3).unwrap(), &10);\n+        assert_eq!(map.find(&5).unwrap(), &3);\n+        assert_eq!(map.find(&9).unwrap(), &1);\n \n         // sadly, no sevens were counted\n         assert!(map.find(&7).is_none());"}, {"sha": "e87be1462267468dc8cc3b6772c41b191da6895e", "filename": "src/libextra/test.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -247,9 +247,8 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n     let ratchet_metrics = getopts::opt_maybe_str(&matches, \"ratchet-metrics\");\n     let ratchet_metrics = ratchet_metrics.map(|s| Path(*s));\n \n-    let ratchet_noise_percent =\n-        getopts::opt_maybe_str(&matches, \"ratchet-noise-percent\");\n-    let ratchet_noise_percent = ratchet_noise_percent.map(|s| f64::from_str(*s).get());\n+    let ratchet_noise_percent = getopts::opt_maybe_str(&matches, \"ratchet-noise-percent\");\n+    let ratchet_noise_percent = ratchet_noise_percent.map(|s| f64::from_str(*s).unwrap());\n \n     let save_metrics = getopts::opt_maybe_str(&matches, \"save-metrics\");\n     let save_metrics = save_metrics.map(|s| Path(*s));\n@@ -631,8 +630,8 @@ fn should_sort_failures_before_printing_them() {\n         st.write_failures();\n     };\n \n-    let apos = s.find_str(\"a\").get();\n-    let bpos = s.find_str(\"b\").get();\n+    let apos = s.find_str(\"a\").unwrap();\n+    let bpos = s.find_str(\"b\").unwrap();\n     assert!(apos < bpos);\n }\n \n@@ -868,7 +867,7 @@ impl MetricMap {\n     pub fn load(p: &Path) -> MetricMap {\n         assert!(os::path_exists(p));\n         let f = io::file_reader(p).unwrap();\n-        let mut decoder = json::Decoder(json::from_reader(f).get());\n+        let mut decoder = json::Decoder(json::from_reader(f).unwrap());\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n \n@@ -1207,7 +1206,7 @@ mod tests {\n           either::Left(o) => o,\n           _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n-        assert!(\"filter\" == opts.filter.clone().get());\n+        assert!(\"filter\" == opts.filter.clone().unwrap());\n     }\n \n     #[test]\n@@ -1346,28 +1345,28 @@ mod tests {\n \n         let diff1 = m2.compare_to_old(&m1, None);\n \n-        assert_eq!(*(diff1.find(&~\"in-both-noise\").get()), LikelyNoise);\n-        assert_eq!(*(diff1.find(&~\"in-first-noise\").get()), MetricRemoved);\n-        assert_eq!(*(diff1.find(&~\"in-second-noise\").get()), MetricAdded);\n-        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-but-regressed\").get()),\n+        assert_eq!(*(diff1.find(&~\"in-both-noise\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.find(&~\"in-first-noise\").unwrap()), MetricRemoved);\n+        assert_eq!(*(diff1.find(&~\"in-second-noise\").unwrap()), MetricAdded);\n+        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-but-regressed\").unwrap()),\n                    Regression(100.0));\n-        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-and-improved\").get()),\n+        assert_eq!(*(diff1.find(&~\"in-both-want-downwards-and-improved\").unwrap()),\n                    Improvement(50.0));\n-        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-but-regressed\").get()),\n+        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-but-regressed\").unwrap()),\n                    Regression(50.0));\n-        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-and-improved\").get()),\n+        assert_eq!(*(diff1.find(&~\"in-both-want-upwards-and-improved\").unwrap()),\n                    Improvement(100.0));\n         assert_eq!(diff1.len(), 7);\n \n         let diff2 = m2.compare_to_old(&m1, Some(200.0));\n \n-        assert_eq!(*(diff2.find(&~\"in-both-noise\").get()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"in-first-noise\").get()), MetricRemoved);\n-        assert_eq!(*(diff2.find(&~\"in-second-noise\").get()), MetricAdded);\n-        assert_eq!(*(diff2.find(&~\"in-both-want-downwards-but-regressed\").get()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"in-both-want-downwards-and-improved\").get()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"in-both-want-upwards-but-regressed\").get()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"in-both-want-upwards-and-improved\").get()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"in-both-noise\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"in-first-noise\").unwrap()), MetricRemoved);\n+        assert_eq!(*(diff2.find(&~\"in-second-noise\").unwrap()), MetricAdded);\n+        assert_eq!(*(diff2.find(&~\"in-both-want-downwards-but-regressed\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"in-both-want-downwards-and-improved\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"in-both-want-upwards-but-regressed\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"in-both-want-upwards-and-improved\").unwrap()), LikelyNoise);\n         assert_eq!(diff2.len(), 7);\n     }\n \n@@ -1391,28 +1390,28 @@ mod tests {\n         let (diff1, ok1) = m2.ratchet(&pth, None);\n         assert_eq!(ok1, false);\n         assert_eq!(diff1.len(), 2);\n-        assert_eq!(*(diff1.find(&~\"runtime\").get()), Regression(10.0));\n-        assert_eq!(*(diff1.find(&~\"throughput\").get()), LikelyNoise);\n+        assert_eq!(*(diff1.find(&~\"runtime\").unwrap()), Regression(10.0));\n+        assert_eq!(*(diff1.find(&~\"throughput\").unwrap()), LikelyNoise);\n \n         // Check that it was not rewritten.\n         let m3 = MetricMap::load(&pth);\n         assert_eq!(m3.len(), 2);\n-        assert_eq!(*(m3.find(&~\"runtime\").get()), Metric { value: 1000.0, noise: 2.0 });\n-        assert_eq!(*(m3.find(&~\"throughput\").get()), Metric { value: 50.0, noise: 2.0 });\n+        assert_eq!(*(m3.find(&~\"runtime\").unwrap()), Metric { value: 1000.0, noise: 2.0 });\n+        assert_eq!(*(m3.find(&~\"throughput\").unwrap()), Metric { value: 50.0, noise: 2.0 });\n \n         // Ask for a ratchet with an explicit noise-percentage override,\n         // that should advance.\n         let (diff2, ok2) = m2.ratchet(&pth, Some(10.0));\n         assert_eq!(ok2, true);\n         assert_eq!(diff2.len(), 2);\n-        assert_eq!(*(diff2.find(&~\"runtime\").get()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&~\"throughput\").get()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"runtime\").unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&~\"throughput\").unwrap()), LikelyNoise);\n \n         // Check that it was rewritten.\n         let m4 = MetricMap::load(&pth);\n         assert_eq!(m4.len(), 2);\n-        assert_eq!(*(m4.find(&~\"runtime\").get()), Metric { value: 1100.0, noise: 2.0 });\n-        assert_eq!(*(m4.find(&~\"throughput\").get()), Metric { value: 50.0, noise: 2.0 });\n+        assert_eq!(*(m4.find(&~\"runtime\").unwrap()), Metric { value: 1100.0, noise: 2.0 });\n+        assert_eq!(*(m4.find(&~\"throughput\").unwrap()), Metric { value: 50.0, noise: 2.0 });\n \n         os::remove_dir_recursive(&dpth);\n     }"}, {"sha": "581bdf2a294dbd6e1f1562b7492a5ba362e60f06", "filename": "src/libextra/url.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -134,7 +134,7 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n             match rdr.read_char() {\n               '%' => {\n                 let bytes = rdr.read_bytes(2u);\n-                let ch = uint::parse_bytes(bytes, 16u).get() as char;\n+                let ch = uint::parse_bytes(bytes, 16u).unwrap() as char;\n \n                 if full_url {\n                     // Only decode some characters:\n@@ -257,7 +257,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n                     let ch = match ch {\n                         '%' => {\n                             let bytes = rdr.read_bytes(2u);\n-                            uint::parse_bytes(bytes, 16u).get() as char\n+                            uint::parse_bytes(bytes, 16u).unwrap() as char\n                         }\n                         '+' => ' ',\n                         ch => ch"}, {"sha": "637ea159d79d012880d7ffe1e527a2616810cd19", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -912,7 +912,7 @@ pub fn link_args(sess: Session,\n         }\n         let dir = cratepath.dirname();\n         if dir != ~\"\" { args.push(~\"-L\" + dir); }\n-        let libarg = unlib(sess.targ_cfg, cratepath.filestem().get());\n+        let libarg = unlib(sess.targ_cfg, cratepath.filestem().unwrap());\n         args.push(~\"-l\" + libarg);\n     }\n \n@@ -950,7 +950,7 @@ pub fn link_args(sess: Session,\n         // be rpathed\n         if sess.targ_cfg.os == session::os_macos {\n             args.push(~\"-Wl,-install_name,@rpath/\"\n-                      + output.filename().get());\n+                      + output.filename().unwrap());\n         }\n     }\n "}, {"sha": "35d070baa9bace971854c8a4c18faf73b79f0b86", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -319,23 +319,23 @@ fn passes_exist() {\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n-            unsafe { llvm::LLVMDestroyPass(pass.get()) }\n+            unsafe { llvm::LLVMDestroyPass(pass.unwrap()) }\n         }\n     }\n     for &(name,_) in transform_passes.iter() {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n-            unsafe { llvm::LLVMDestroyPass(pass.get()) }\n+            unsafe { llvm::LLVMDestroyPass(pass.unwrap()) }\n         }\n     }\n     for &(name,_) in utility_passes.iter() {\n         let pass = create_pass(name);\n         if !pass.is_some() {\n             failed.push(name);\n         } else {\n-            unsafe { llvm::LLVMDestroyPass(pass.get()) }\n+            unsafe { llvm::LLVMDestroyPass(pass.unwrap()) }\n         }\n     }\n "}, {"sha": "356820f8267fe990eb76bbaec7781ea56fc422bd", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -922,7 +922,7 @@ pub fn build_output_filenames(input: &input,\n           };\n \n           let mut stem = match *input {\n-              file_input(ref ifile) => (*ifile).filestem().get().to_managed(),\n+              file_input(ref ifile) => (*ifile).filestem().unwrap().to_managed(),\n               str_input(_) => @\"rust_out\"\n           };\n "}, {"sha": "d2d2a8b4be99d984f4c06c04f6b80ef3598a0418", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -308,7 +308,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n             #[main];\n             extra::test::test_main_static(::std::os::args(), TESTS);\n         }\n-    )).get();\n+    )).unwrap();\n \n     let testmod = ast::_mod {\n         view_items: view_items,\n@@ -366,7 +366,7 @@ fn mk_tests(cx: &TestCtxt) -> @ast::item {\n         pub static TESTS : &'static [self::extra::test::TestDescAndFn] =\n             $test_descs\n         ;\n-    )).get()\n+    )).unwrap()\n }\n \n fn is_extra(cx: &TestCtxt) -> bool {"}, {"sha": "b909f70440a8258031011ac11d0bf8024a2d4eda", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -328,7 +328,7 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n \n     match *ii {\n         //hack: we're not dropping items\n-        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).get()),\n+        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).unwrap()),\n         ast::ii_method(d, is_provided, m) =>\n           ast::ii_method(d, is_provided, fld.fold_method(m)),\n         ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i))\n@@ -350,7 +350,7 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n     });\n \n     match ii {\n-        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).get()),\n+        ast::ii_item(i) => ast::ii_item(fld.fold_item(i).unwrap()),\n         ast::ii_method(d, is_provided, m) =>\n           ast::ii_method(xcx.tr_def_id(d), is_provided, fld.fold_method(m)),\n         ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i)),\n@@ -1275,7 +1275,7 @@ fn mk_ctxt() -> @fake_ext_ctxt {\n fn roundtrip(in_item: Option<@ast::item>) {\n     use std::io;\n \n-    let in_item = in_item.get();\n+    let in_item = in_item.unwrap();\n     let bytes = do io::with_bytes_writer |wr| {\n         let mut ebml_w = writer::Encoder(wr);\n         encode_item_ast(&mut ebml_w, in_item);\n@@ -1321,13 +1321,13 @@ fn test_simplification() {\n             fn eq_int(a: int, b: int) -> bool { a == b }\n             return alist {eq_fn: eq_int, data: ~[]};\n         }\n-    ).get());\n+    ).unwrap());\n     let item_out = simplify_ast(&item_in);\n     let item_exp = ast::ii_item(quote_item!(\n         fn new_int_alist<B>() -> alist<int, B> {\n             return alist {eq_fn: eq_int, data: ~[]};\n         }\n-    ).get());\n+    ).unwrap());\n     match (item_out, item_exp) {\n       (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n         assert!(pprust::item_to_str(item_out,"}, {"sha": "c3bb2000447f7fe6ae8f17694282738d72753b04", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -307,7 +307,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         // if they cannot already have been assigned\n         if self.is_local_variable(cmt) {\n             assert!(cmt.mutbl.is_immutable()); // no \"const\" locals\n-            let lp = opt_loan_path(cmt).get();\n+            let lp = opt_loan_path(cmt).unwrap();\n             do self.move_data.each_assignment_of(expr.id, lp) |assign| {\n                 self.bccx.report_reassigned_immutable_variable(\n                     expr.span,"}, {"sha": "1b420b9c06a55b60a758d3dfb6f76b311573ef6f", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -109,7 +109,7 @@ pub fn check_arms(cx: &MatchCheckCtxt, arms: &[arm]) {\n             let pat_matches_nan: &fn(@pat) -> bool = |p| {\n                 match cx.tcx.def_map.find(&p.id) {\n                     Some(&def_static(did, false)) => {\n-                        let const_expr = lookup_const_by_id(cx.tcx, did).get();\n+                        let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                         match eval_const_expr(cx.tcx, const_expr) {\n                             const_float(f) if f.is_NaN() => true,\n                             _ => false\n@@ -304,7 +304,7 @@ pub fn is_useful_specialized(cx: &MatchCheckCtxt,\n                           -> useful {\n     let ms = m.iter().filter_map(|r| specialize(cx, *r, &ctor, arity, lty)).collect::<matrix>();\n     let could_be_useful = is_useful(\n-        cx, &ms, specialize(cx, v, &ctor, arity, lty).get());\n+        cx, &ms, specialize(cx, v, &ctor, arity, lty).unwrap());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n       ref u => *u,\n@@ -319,7 +319,7 @@ pub fn pat_ctor_id(cx: &MatchCheckCtxt, p: @pat) -> Option<ctor> {\n         match cx.tcx.def_map.find(&pat.id) {\n           Some(&def_variant(_, id)) => Some(variant(id)),\n           Some(&def_static(did, false)) => {\n-            let const_expr = lookup_const_by_id(cx.tcx, did).get();\n+            let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n             Some(val(eval_const_expr(cx.tcx, const_expr)))\n           }\n           _ => None\n@@ -515,7 +515,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                     }\n                     Some(&def_static(did, _)) => {\n                         let const_expr =\n-                            lookup_const_by_id(cx.tcx, did).get();\n+                            lookup_const_by_id(cx.tcx, did).unwrap();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n                         let match_ = match *ctor_id {\n                             val(ref v) => {\n@@ -565,7 +565,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                 match cx.tcx.def_map.get_copy(&pat_id) {\n                     def_static(did, _) => {\n                         let const_expr =\n-                            lookup_const_by_id(cx.tcx, did).get();\n+                            lookup_const_by_id(cx.tcx, did).unwrap();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n                         let match_ = match *ctor_id {\n                             val(ref v) =>\n@@ -867,7 +867,7 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                 \"cannot bind by-move and by-ref \\\n                  in the same pattern\");\n             tcx.sess.span_note(\n-                by_ref_span.get(),\n+                by_ref_span.unwrap(),\n                 \"by-ref binding occurs here\");\n         }\n     };"}, {"sha": "77e81709a03d73370f51043a5a45ba9bc08840c4", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -466,9 +466,9 @@ pub fn lit_to_const(lit: &lit) -> const_val {\n       lit_int(n, _) => const_int(n),\n       lit_uint(n, _) => const_uint(n),\n       lit_int_unsuffixed(n) => const_int(n),\n-      lit_float(n, _) => const_float(float::from_str(n).get() as f64),\n+      lit_float(n, _) => const_float(float::from_str(n).unwrap() as f64),\n       lit_float_unsuffixed(n) =>\n-        const_float(float::from_str(n).get() as f64),\n+        const_float(float::from_str(n).unwrap() as f64),\n       lit_nil => const_int(0i64),\n       lit_bool(b) => const_bool(b)\n     }"}, {"sha": "9ffeb99ac3559bf7bf82810e3b7abba8579173c4", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -225,7 +225,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         // the default implementation.\n         // Having to do this this is really unfortunate.\n         let method_id = ty::method(tcx, method_id).provided_source\n-            .get_or_default(method_id);\n+            .unwrap_or_default(method_id);\n \n         if method_id.crate == LOCAL_CRATE {\n             let is_private = method_is_private(span, method_id.node);"}, {"sha": "5ca3a58b137a74bc56f18d6151b9823fab0eb613", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -1726,7 +1726,7 @@ impl Resolver {\n         let mut modules = HashMap::new();\n \n         // Create all the items reachable by paths.\n-        do each_path(self.session.cstore, root.def_id.get().crate)\n+        do each_path(self.session.cstore, root.def_id.unwrap().crate)\n                 |path_string, def_like, visibility| {\n \n             debug!(\"(building reduced graph for external crate) found path \\\n@@ -2350,7 +2350,7 @@ impl Resolver {\n         match type_result {\n             BoundResult(target_module, name_bindings) => {\n                 debug!(\"(resolving single import) found type target: %?\",\n-                        name_bindings.type_def.get().type_def);\n+                        name_bindings.type_def.unwrap().type_def);\n                 import_resolution.type_target =\n                     Some(Target(target_module, name_bindings));\n                 import_resolution.type_id = directive.id;"}, {"sha": "d77cebbf23e0be8b1c05eed1ed0bfb0b85d68836", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -210,7 +210,7 @@ pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                         ExprLit(existing_a_expr) => a_expr = existing_a_expr,\n                             ConstLit(a_const) => {\n                                 let e = const_eval::lookup_const_by_id(tcx, a_const);\n-                                a_expr = e.get();\n+                                a_expr = e.unwrap();\n                             }\n                         UnitLikeStructLit(_) => {\n                             fail!(\"UnitLikeStructLit should have been handled \\\n@@ -223,7 +223,7 @@ pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                         ExprLit(existing_b_expr) => b_expr = existing_b_expr,\n                             ConstLit(b_const) => {\n                                 let e = const_eval::lookup_const_by_id(tcx, b_const);\n-                                b_expr = e.get();\n+                                b_expr = e.unwrap();\n                             }\n                         UnitLikeStructLit(_) => {\n                             fail!(\"UnitLikeStructLit should have been handled \\\n@@ -922,7 +922,7 @@ pub fn extract_vec_elems(bcx: @mut Block,\n         }\n     };\n     if slice.is_some() {\n-        let n = slice.get();\n+        let n = slice.unwrap();\n         let slice_offset = Mul(bcx, vt.llunit_size,\n             C_int(bcx.ccx(), n as int)\n         );\n@@ -1280,7 +1280,7 @@ pub fn compile_submatch(bcx: @mut Block,\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n     if m.len() == 0u {\n-        Br(bcx, chk.get()());\n+        Br(bcx, chk.unwrap()());\n         return;\n     }\n     if m[0].pats.len() == 0u {"}, {"sha": "2eb9841c6c7577411454205a0a9f8c0e8bcec754", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -260,7 +260,7 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n                     most_aligned = Some(st);\n                 }\n             }\n-            let most_aligned = most_aligned.get();\n+            let most_aligned = most_aligned.unwrap();\n             let padding = largest_size - most_aligned.size;\n \n             struct_llfields(cx, most_aligned, sizing)"}, {"sha": "3fc6dbca9647533ec6a1f3f5ea6b604198381d41", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -1321,7 +1321,7 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n     }\n     match leave {\n       Some(target) => Br(bcx, target),\n-      None => { Resume(bcx, Load(bcx, bcx.fcx.personality.get())); }\n+      None => { Resume(bcx, Load(bcx, bcx.fcx.personality.unwrap())); }\n     }\n }\n \n@@ -1529,7 +1529,7 @@ pub fn alloca_maybe_zeroed(cx: @mut Block, ty: Type, name: &str, zero: bool) ->\n     let p = Alloca(cx, ty, name);\n     if zero {\n         let b = cx.fcx.ccx.builder();\n-        b.position_before(cx.fcx.alloca_insert_pt.get());\n+        b.position_before(cx.fcx.alloca_insert_pt.unwrap());\n         memzero(&b, p, ty);\n     }\n     p\n@@ -1575,7 +1575,7 @@ pub fn make_return_pointer(fcx: @mut FunctionContext, output_type: ty::t) -> Val\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-            let bcx = fcx.entry_bcx.get();\n+            let bcx = fcx.entry_bcx.unwrap();\n             Alloca(bcx, lloutputtype, \"__make_return_pointer\")\n         }\n     }\n@@ -1793,7 +1793,7 @@ pub fn finish_fn(fcx: @mut FunctionContext, last_bcx: @mut Block) {\n pub fn build_return_block(fcx: &FunctionContext, ret_cx: @mut Block) {\n     // Return the value if this function immediate; otherwise, return void.\n     if fcx.llretptr.is_some() && fcx.has_immediate_return_value {\n-        Ret(ret_cx, Load(ret_cx, fcx.llretptr.get()))\n+        Ret(ret_cx, Load(ret_cx, fcx.llretptr.unwrap()))\n     } else {\n         RetVoid(ret_cx)\n     }\n@@ -1843,7 +1843,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-    let bcx_top = fcx.entry_bcx.get();\n+    let bcx_top = fcx.entry_bcx.unwrap();\n     let mut bcx = bcx_top;\n     let block_ty = node_id_type(bcx, body.id);\n \n@@ -1861,7 +1861,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     {\n         bcx = controlflow::trans_block(bcx, body, expr::Ignore);\n     } else {\n-        let dest = expr::SaveIn(fcx.llretptr.get());\n+        let dest = expr::SaveIn(fcx.llretptr.unwrap());\n         bcx = controlflow::trans_block(bcx, body, dest);\n     }\n \n@@ -2055,18 +2055,18 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n \n     let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n \n-    let bcx = fcx.entry_bcx.get();\n+    let bcx = fcx.entry_bcx.unwrap();\n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n     insert_synthetic_type_entries(bcx, fn_args, arg_tys);\n     let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n     let repr = adt::represent_type(ccx, result_ty);\n-    adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n+    adt::trans_start_init(bcx, repr, fcx.llretptr.unwrap(), disr);\n     for (i, fn_arg) in fn_args.iter().enumerate() {\n         let lldestptr = adt::trans_field_ptr(bcx,\n                                              repr,\n-                                             fcx.llretptr.get(),\n+                                             fcx.llretptr.unwrap(),\n                                              disr,\n                                              i);\n         let llarg = fcx.llargs.get_copy(&fn_arg.pat.id);\n@@ -2293,7 +2293,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n         // be updated if this assertion starts to fail.\n         assert!(fcx.has_immediate_return_value);\n \n-        let bcx = fcx.entry_bcx.get();\n+        let bcx = fcx.entry_bcx.unwrap();\n         // Call main.\n         let llenvarg = unsafe {\n             let env_arg = fcx.env_arg_pos();\n@@ -2782,7 +2782,7 @@ pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n     }\n \n     for key in keys.iter() {\n-        let val = *ccx.module_data.find_equiv(key).get();\n+        let val = *ccx.module_data.find_equiv(key).unwrap();\n         let s_const = C_cstr(ccx, *key);\n         let s_ptr = p2i(ccx, s_const);\n         let v_ptr = p2i(ccx, val);"}, {"sha": "c8e2a17c3b5f1bd93bc81448101c31e08a0404fb", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -319,7 +319,7 @@ pub fn Alloca(cx: @mut Block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n-        b.position_before(cx.fcx.alloca_insert_pt.get());\n+        b.position_before(cx.fcx.alloca_insert_pt.unwrap());\n         b.alloca(Ty, name)\n     }\n }\n@@ -328,7 +328,7 @@ pub fn ArrayAlloca(cx: @mut Block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n-        b.position_before(cx.fcx.alloca_insert_pt.get());\n+        b.position_before(cx.fcx.alloca_insert_pt.unwrap());\n         b.array_alloca(Ty, Val)\n     }\n }"}, {"sha": "895bea715c964e73713dcc086f491d9516cabdc6", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -169,7 +169,7 @@ impl FnType {\n             } else {\n                 Load(bcx, llretval)\n             };\n-            let llretptr = BitCast(bcx, bcx.fcx.llretptr.get(), self.ret_ty.ty.ptr_to());\n+            let llretptr = BitCast(bcx, bcx.fcx.llretptr.unwrap(), self.ret_ty.ty.ptr_to());\n             Store(bcx, llretval, llretptr);\n         }\n     }"}, {"sha": "602d33a197e29bfc536639d370372d07185a52a1", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -330,7 +330,7 @@ pub fn load_environment(fcx: @mut FunctionContext,\n         return;\n     }\n \n-    let bcx = fcx.entry_bcx.get();\n+    let bcx = fcx.entry_bcx.unwrap();\n \n     // Load a pointer to the closure data, skipping over the box header:\n     let llcdata = opaque_box_body(bcx, cdata_ty, fcx.llenv);\n@@ -443,7 +443,7 @@ pub fn trans_expr_fn(bcx: @mut Block,\n                               if is_loop_body.is_some() {\n                                   Store(bcx,\n                                         C_bool(true),\n-                                        bcx.fcx.llretptr.get());\n+                                        bcx.fcx.llretptr.unwrap());\n                               }\n                           });\n             rslt(bcx, llbox)"}, {"sha": "f303e7b82759769696c95b0c9856d28c89cf0341", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -251,7 +251,7 @@ impl FunctionContext {\n \n     pub fn cleanup(&mut self) {\n         unsafe {\n-            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt.get());\n+            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt.unwrap());\n         }\n         // Remove the cycle between fcx and bcx, so memory can be freed\n         self.entry_bcx = None;\n@@ -262,7 +262,7 @@ impl FunctionContext {\n             self.llreturn = Some(base::mk_return_basic_block(self.llfn));\n         }\n \n-        self.llreturn.get()\n+        self.llreturn.unwrap()\n     }\n }\n "}, {"sha": "823b1e0645cbcccc3a52dd5b3d52ef01f57705de", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -314,7 +314,7 @@ pub fn trans_break_cont(bcx: @mut Block,\n                     Some(bcx) => bcx,\n                         // This is a return from a loop body block\n                         None => {\n-                            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.get());\n+                            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.unwrap());\n                             cleanup_and_leave(bcx, None, Some(bcx.fcx.get_llreturn()));\n                             Unreachable(bcx);\n                             return bcx;\n@@ -346,7 +346,7 @@ pub fn trans_ret(bcx: @mut Block, e: Option<@ast::expr>) -> @mut Block {\n         // to false, return flag to true, and then store the value in the\n         // parent's retptr.\n         Store(bcx, C_bool(true), flagptr);\n-        Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n+        Store(bcx, C_bool(false), bcx.fcx.llretptr.unwrap());\n         expr::SaveIn(match e {\n           Some(x) => PointerCast(bcx, retptr,\n                                  type_of(bcx.ccx(), expr_ty(bcx, x)).ptr_to()),"}, {"sha": "624704c2c686c540c4457df43a9a9ab57be13154", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -485,8 +485,8 @@ fn lexical_block_metadata(bcx: @mut Block) -> DILexicalBlock {\n         }\n     }\n \n-    let span = bcx.node_info.get().span;\n-    let id = bcx.node_info.get().id;\n+    let span = bcx.node_info.unwrap().span;\n+    let id = bcx.node_info.unwrap().id;\n \n     // Check whether we already have a cache entry for this node id\n     match dbg_cx(cx).created_blocks.find(&id) {"}, {"sha": "6d5934592ebcb71f28f7271549533d134c27e959", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -149,7 +149,7 @@ fn build_shim_fn_(ccx: @mut CrateContext,\n \n     // Declare the body of the shim function:\n     let fcx = new_fn_ctxt(ccx, ~[], llshimfn, tys.fn_sig.output, None);\n-    let bcx = fcx.entry_bcx.get();\n+    let bcx = fcx.entry_bcx.unwrap();\n \n     let llargbundle = get_param(llshimfn, 0u);\n     let llargvals = arg_builder(bcx, tys, llargbundle);\n@@ -190,7 +190,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n                   ret_builder: wrap_ret_builder) {\n     let _icx = push_ctxt(\"foreign::build_wrap_fn_\");\n     let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, tys.fn_sig.output, None);\n-    let bcx = fcx.entry_bcx.get();\n+    let bcx = fcx.entry_bcx.unwrap();\n \n     // Patch up the return type if it's not immediate and we're returning via\n     // the C ABI.\n@@ -226,7 +226,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     } else {\n         // Cast if we have to...\n         // XXX: This is ugly.\n-        let llretptr = BitCast(return_context, fcx.llretptr.get(), return_type.ptr_to());\n+        let llretptr = BitCast(return_context, fcx.llretptr.unwrap(), return_type.ptr_to());\n         Ret(return_context, Load(return_context, llretptr));\n     }\n     fcx.cleanup();\n@@ -421,7 +421,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         debug!(\"build_direct_fn(%s)\", link_name(ccx, item));\n \n         let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = fcx.entry_bcx.get();\n+        let bcx = fcx.entry_bcx.unwrap();\n         let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n                                       ast_util::local_def(item.id)).ty;\n@@ -431,7 +431,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         });\n         let retval = Call(bcx, llbasefn, args);\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n-            Store(bcx, retval, fcx.llretptr.get());\n+            Store(bcx, retval, fcx.llretptr.unwrap());\n         }\n         finish_fn(fcx, bcx);\n     }\n@@ -446,7 +446,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         debug!(\"build_fast_ffi_fn(%s)\", link_name(ccx, item));\n \n         let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = fcx.entry_bcx.get();\n+        let bcx = fcx.entry_bcx.unwrap();\n         let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n         set_no_inline(fcx.llfn);\n         set_fixed_stack_segment(fcx.llfn);\n@@ -458,7 +458,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         });\n         let retval = Call(bcx, llbasefn, args);\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n-            Store(bcx, retval, fcx.llretptr.get());\n+            Store(bcx, retval, fcx.llretptr.unwrap());\n         }\n         finish_fn(fcx, bcx);\n     }\n@@ -618,7 +618,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         set_fixed_stack_segment(fcx.llfn);\n     }\n \n-    let mut bcx = fcx.entry_bcx.get();\n+    let mut bcx = fcx.entry_bcx.unwrap();\n     let first_real_arg = fcx.arg_pos(0u);\n \n     let nm = ccx.sess.str_of(item.ident);\n@@ -775,7 +775,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n             let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n             if in_type_size != out_type_size {\n-                let sp = match ccx.tcx.items.get_copy(&ref_id.get()) {\n+                let sp = match ccx.tcx.items.get_copy(&ref_id.unwrap()) {\n                     ast_map::node_expr(e) => e.span,\n                     _ => fail!(\"transmute has non-expr arg\"),\n                 };\n@@ -816,7 +816,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                     // NB: Do not use a Load and Store here. This causes massive\n                     // code bloat when `transmute` is used on large structural\n                     // types.\n-                    let lldestptr = fcx.llretptr.get();\n+                    let lldestptr = fcx.llretptr.unwrap();\n                     let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n                     let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p());\n "}, {"sha": "948c9ceef8e6182da8188e5f6eb048ef556647cc", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -311,7 +311,7 @@ pub fn call_tydesc_glue_full(bcx: @mut Block,\n     let llrawptr = if static_ti.is_none() || static_glue_fn.is_none() {\n         PointerCast(bcx, v, Type::i8p())\n     } else {\n-        let ty = static_ti.get().ty;\n+        let ty = static_ti.unwrap().ty;\n         let simpl = simplified_glue_type(ccx.tcx, field, ty);\n         if simpl != ty {\n             PointerCast(bcx, v, type_of(ccx, simpl).ptr_to())\n@@ -708,7 +708,7 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let bcx = fcx.entry_bcx.get();\n+    let bcx = fcx.entry_bcx.unwrap();\n     let rawptr0_arg = fcx.arg_pos(0u);\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);"}, {"sha": "5f8837b538cdfbd8b0b9992fc47c26713c21696a", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -180,7 +180,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n             let idx = psubsts.tys.len() - num_method_ty_params;\n             let substs =\n                 (psubsts.tys.slice(0, idx) +\n-                 &[psubsts.self_ty.get()] +\n+                 &[psubsts.self_ty.unwrap()] +\n                  psubsts.tys.tailn(idx));\n             debug!(\"static default: changed substitution to %s\",\n                    substs.repr(ccx.tcx));\n@@ -245,7 +245,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       }\n       ast_map::node_variant(ref v, enum_item, _) => {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n-        let this_tv = *tvs.iter().find_(|tv| { tv.id.node == fn_id.node}).get();\n+        let this_tv = *tvs.iter().find_(|tv| { tv.id.node == fn_id.node}).unwrap();\n         let d = mk_lldecl();\n         set_inline_hint(d);\n         match v.node.kind {"}, {"sha": "609aad0bc201cc514aef7e5f533a7b5c7b5d52af", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -303,10 +303,10 @@ impl Reflector {\n                     //\n                     llvm::LLVMGetParam(llfdecl, fcx.arg_pos(0u) as c_uint)\n                 };\n-                let mut bcx = fcx.entry_bcx.get();\n+                let mut bcx = fcx.entry_bcx.unwrap();\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, repr, arg);\n-                Store(bcx, ret, fcx.llretptr.get());\n+                Store(bcx, ret, fcx.llretptr.unwrap());\n                 match fcx.llreturn {\n                     Some(llreturn) => cleanup_and_Br(bcx, bcx, llreturn),\n                     None => bcx = cleanup_block(bcx, Some(bcx.llbb))"}, {"sha": "6a382cc1a5d1cc82b6682d6fc34a32683c5509c2", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -239,7 +239,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n \n       ty::ty_estr(ty::vstore_slice(_)) => {\n           // This means we get a nicer name in the output\n-          cx.tn.find_type(\"str_slice\").get()\n+          cx.tn.find_type(\"str_slice\").unwrap()\n       }\n \n       ty::ty_estr(ty::vstore_fixed(n)) => {"}, {"sha": "48a003ddaf157522b44e040584708362aeb56fb8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -33,6 +33,7 @@ use std::hashmap::{HashMap, HashSet};\n use std::ops;\n use std::ptr::to_unsafe_ptr;\n use std::to_bytes;\n+use std::to_str::ToStr;\n use std::u32;\n use std::vec;\n use syntax::ast::*;\n@@ -116,15 +117,15 @@ pub struct mt {\n     mutbl: ast::mutability,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes, ToStr)]\n pub enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n     vstore_box,\n     vstore_slice(Region)\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub enum TraitStore {\n     BoxTraitStore,              // @Trait\n     UniqTraitStore,             // ~Trait\n@@ -350,6 +351,12 @@ pub struct t_box_ {\n enum t_opaque {}\n pub type t = *t_opaque;\n \n+impl ToStr for t {\n+    fn to_str(&self) -> ~str {\n+        ~\"*t_opaque\"\n+    }\n+}\n+\n pub fn get(t: t) -> t_box {\n     unsafe {\n         let t2: t_box = cast::transmute(t);\n@@ -410,7 +417,7 @@ pub struct param_ty {\n }\n \n /// Representation of regions:\n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub enum Region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n@@ -456,13 +463,13 @@ impl Region {\n     }\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub struct FreeRegion {\n     scope_id: NodeId,\n     bound_region: bound_region\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable)]\n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub enum bound_region {\n     /// The self region for structs, impls (&T in a type defn or &'self T)\n     br_self,\n@@ -620,19 +627,22 @@ pub enum IntVarValue {\n     UintType(ast::uint_ty),\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, ToStr)]\n pub enum terr_vstore_kind {\n-    terr_vec, terr_str, terr_fn, terr_trait\n+    terr_vec,\n+    terr_str,\n+    terr_fn,\n+    terr_trait\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, ToStr)]\n pub struct expected_found<T> {\n     expected: T,\n     found: T\n }\n \n // Data structures used in type unification\n-#[deriving(Clone)]\n+#[deriving(Clone, ToStr)]\n pub enum type_err {\n     terr_mismatch,\n     terr_purity_mismatch(expected_found<purity>),\n@@ -674,7 +684,7 @@ pub struct ParamBounds {\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes, ToStr)]\n pub enum BuiltinBound {\n     BoundStatic,\n     BoundSend,\n@@ -725,7 +735,7 @@ pub enum InferTy {\n     FloatVar(FloatVid)\n }\n \n-#[deriving(Clone, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Encodable, Decodable, IterBytes, ToStr)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, bound_region)"}, {"sha": "53853e4fe1a78be01dedd8e7e1256cb521214e7b", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -531,7 +531,7 @@ pub fn ty_of_arg<AC:AstConv,\n                  expected_ty: Option<ty::t>)\n                  -> ty::t {\n     match a.ty.node {\n-        ast::ty_infer if expected_ty.is_some() => expected_ty.get(),\n+        ast::ty_infer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::ty_infer => this.ty_infer(a.ty.span),\n         _ => ast_ty_to_ty(this, rscope, &a.ty),\n     }\n@@ -587,7 +587,7 @@ pub fn ty_of_method<AC:AstConv,RS:region_scope + Clone + 'static>(\n     };\n     let (a, b) = ty_of_method_or_bare_fn(\n         this, rscope, purity, AbiSet::Rust(), lifetimes, Some(&self_info), decl);\n-    (a.get(), b)\n+    (a.unwrap(), b)\n }\n \n pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Clone + 'static>(\n@@ -735,7 +735,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Clone + 'static>(\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n     let output_ty = match decl.output.node {\n-        ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.get(),\n+        ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.unwrap(),\n         ast::ty_infer => this.ty_infer(decl.output.span),\n         _ => ast_ty_to_ty(this, &rb, &decl.output)\n     };"}, {"sha": "7caed39060159bd2c1d321c9466a1a9b20ba5a1d", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -166,7 +166,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                     fcx.write_error(pat.id);\n                     kind_name = \"[error]\";\n                     arg_types = (*subpats).clone()\n-                                          .get_or_default(~[])\n+                                          .unwrap_or_default(~[])\n                                           .map(|_| ty::mk_err());\n                 }\n             }\n@@ -209,7 +209,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n             fcx.write_error(pat.id);\n             kind_name = \"[error]\";\n             arg_types = (*subpats).clone()\n-                                  .get_or_default(~[])\n+                                  .unwrap_or_default(~[])\n                                   .map(|_| ty::mk_err());\n         }\n     }"}, {"sha": "e1e7d10db0abd5ba07481b5a9d505e08f8221319", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -854,7 +854,7 @@ impl<'self> LookupContext<'self> {\n                         // like &'a Self.  We then perform a\n                         // substitution which will replace Self with\n                         // @Trait.\n-                        let t = candidate.method_ty.transformed_self_ty.get();\n+                        let t = candidate.method_ty.transformed_self_ty.unwrap();\n                         ty::subst(tcx, &candidate.rcvr_substs, t)\n                     }\n                     _ => {\n@@ -863,7 +863,7 @@ impl<'self> LookupContext<'self> {\n                 }\n             }\n             _ => {\n-                let t = candidate.method_ty.transformed_self_ty.get();\n+                let t = candidate.method_ty.transformed_self_ty.unwrap();\n                 ty::subst(tcx, &candidate.rcvr_substs, t)\n             }\n         };\n@@ -922,7 +922,7 @@ impl<'self> LookupContext<'self> {\n                 tcx, @Nil, Some(transformed_self_ty), &bare_fn_ty.sig,\n                 |br| self.fcx.infcx().next_region_var(\n                     infer::BoundRegionInFnCall(self.expr.span, br)));\n-        let transformed_self_ty = opt_transformed_self_ty.get();\n+        let transformed_self_ty = opt_transformed_self_ty.unwrap();\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n             purity: bare_fn_ty.purity,"}, {"sha": "ea8a11fc7b3821b425f4ee3fac59c6927a712bb6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -365,7 +365,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                                                  bound_region: br}));\n         let opt_self_info =\n             opt_self_info.map(\n-                |si| SelfInfo {self_ty: opt_self_ty.get(), ..*si});\n+                |si| SelfInfo {self_ty: opt_self_ty.unwrap(), ..*si});\n         (isr, opt_self_info, fn_sig)\n     };\n \n@@ -2449,7 +2449,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                            expected,\n                                            |x| Some((*x).clone()));\n         let inner_ty = match expected_sty {\n-            Some(ty::ty_closure(_)) => expected.get(),\n+            Some(ty::ty_closure(_)) => expected.unwrap(),\n             _ => match expected {\n                 Some(expected_t) => {\n                     fcx.type_error_message(expr.span, |actual| {"}, {"sha": "f05388344bc7129914c230f0fa922af9dc2b8c07", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -253,7 +253,7 @@ impl Combine for Glb {\n \n             if a_r.is_some() && b_r.is_some() && only_new_vars {\n                 // Related to exactly one bound variable from each fn:\n-                return rev_lookup(this, a_isr, a_r.get());\n+                return rev_lookup(this, a_isr, a_r.unwrap());\n             } else if a_r.is_none() && b_r.is_none() {\n                 // Not related to bound variables from either fn:\n                 return r0;"}, {"sha": "b1356ffb2d5e943632dd9d6a47f0b9966bb9ba52", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -295,7 +295,7 @@ trait get_and_find_region {\n \n impl get_and_find_region for isr_alist {\n     pub fn get(&self, br: ty::bound_region) -> ty::Region {\n-        self.find(br).get()\n+        self.find(br).unwrap()\n     }\n \n     pub fn find(&self, br: ty::bound_region) -> Option<ty::Region> {"}, {"sha": "bbcf42b1c5d321b600eb4a1be6fa0f7411990c5b", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -18,6 +18,7 @@ use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n \n+#[deriving(ToStr)]\n pub struct RegionError {\n     msg: ~str,\n     replacement: ty::Region"}, {"sha": "ced29f18f7f1172e68315fba4e73c00f76474806", "filename": "src/librustc/util/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -10,7 +10,7 @@\n \n use std::iterator::Iterator;\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes, ToStr)]\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists"}, {"sha": "a1cb81f4503579eae39d6c34a9f13c9728dbbfcd", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -68,7 +68,7 @@ fn fold_crate(\n     doc::CrateDoc {\n         topmod: doc::ModDoc {\n             item: doc::ItemDoc {\n-                name: attrs.name.clone().get_or_default(doc.topmod.name_()),\n+                name: attrs.name.clone().unwrap_or_default(doc.topmod.name_()),\n                 .. doc.topmod.item.clone()\n             },\n             .. doc.topmod.clone()\n@@ -135,7 +135,7 @@ fn fold_enum(\n                             let ast_variant =\n                                 (*enum_definition.variants.iter().find_(|v| {\n                                     to_str(v.node.name) == variant.name\n-                                }).get()).clone();\n+                                }).unwrap()).clone();\n \n                             attr_parser::parse_desc(\n                                 ast_variant.node.attrs.clone())"}, {"sha": "d387bbea592d36374231a4e59a4572d00d177fef", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -142,7 +142,7 @@ fn config_from_opts(\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n         let output_dir = output_dir.map(|s| Path(*s));\n         result::Ok(Config {\n-            output_dir: output_dir.get_or_default(config.output_dir.clone()),\n+            output_dir: output_dir.unwrap_or_default(config.output_dir.clone()),\n             .. config\n         })\n     };\n@@ -273,101 +273,101 @@ mod test {\n     #[test]\n     fn should_error_with_no_crates() {\n         let config = parse_config([~\"rustdoc\"]);\n-        assert!(config.get_err() == ~\"no crates specified\");\n+        assert!(config.unwrap_err() == ~\"no crates specified\");\n     }\n \n     #[test]\n     fn should_error_with_multiple_crates() {\n         let config =\n             parse_config([~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n-        assert!(config.get_err() == ~\"multiple crates specified\");\n+        assert!(config.unwrap_err() == ~\"multiple crates specified\");\n     }\n \n     #[test]\n     fn should_set_output_dir_to_cwd_if_not_provided() {\n         let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n-        assert!(config.get().output_dir == Path(\".\"));\n+        assert!(config.unwrap().output_dir == Path(\".\"));\n     }\n \n     #[test]\n     fn should_set_output_dir_if_provided() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n         ]);\n-        assert!(config.get().output_dir == Path(\"snuggles\"));\n+        assert!(config.unwrap().output_dir == Path(\"snuggles\"));\n     }\n \n     #[test]\n     fn should_set_output_format_to_pandoc_html_if_not_provided() {\n         let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n-        assert!(config.get().output_format == PandocHtml);\n+        assert!(config.unwrap().output_format == PandocHtml);\n     }\n \n     #[test]\n     fn should_set_output_format_to_markdown_if_requested() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n         ]);\n-        assert!(config.get().output_format == Markdown);\n+        assert!(config.unwrap().output_format == Markdown);\n     }\n \n     #[test]\n     fn should_set_output_format_to_pandoc_html_if_requested() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n         ]);\n-        assert!(config.get().output_format == PandocHtml);\n+        assert!(config.unwrap().output_format == PandocHtml);\n     }\n \n     #[test]\n     fn should_error_on_bogus_format() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"bogus\"\n         ]);\n-        assert!(config.get_err() == ~\"unknown output format 'bogus'\");\n+        assert!(config.unwrap_err() == ~\"unknown output format 'bogus'\");\n     }\n \n     #[test]\n     fn should_set_output_style_to_doc_per_mod_by_default() {\n         let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n-        assert!(config.get().output_style == DocPerMod);\n+        assert!(config.unwrap().output_style == DocPerMod);\n     }\n \n     #[test]\n     fn should_set_output_style_to_one_doc_if_requested() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n         ]);\n-        assert!(config.get().output_style == DocPerCrate);\n+        assert!(config.unwrap().output_style == DocPerCrate);\n     }\n \n     #[test]\n     fn should_set_output_style_to_doc_per_mod_if_requested() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n         ]);\n-        assert!(config.get().output_style == DocPerMod);\n+        assert!(config.unwrap().output_style == DocPerMod);\n     }\n \n     #[test]\n     fn should_error_on_bogus_output_style() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"bogus\"\n         ]);\n-        assert!(config.get_err() == ~\"unknown output style 'bogus'\");\n+        assert!(config.unwrap_err() == ~\"unknown output style 'bogus'\");\n     }\n \n     #[test]\n     fn should_set_pandoc_command_if_requested() {\n         let config = parse_config([\n             ~\"rustdoc\", ~\"crate.rc\", ~\"--pandoc-cmd\", ~\"panda-bear-doc\"\n         ]);\n-        assert!(config.get().pandoc_cmd == Some(~\"panda-bear-doc\"));\n+        assert!(config.unwrap().pandoc_cmd == Some(~\"panda-bear-doc\"));\n     }\n \n     #[test]\n     fn should_set_pandoc_command_when_using_pandoc() {\n         let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n-        assert!(config.get().pandoc_cmd == Some(~\"pandoc\"));\n+        assert!(config.unwrap().pandoc_cmd == Some(~\"pandoc\"));\n     }\n }"}, {"sha": "9f8041712eaecdb12d38bb0843ec7edbe675e9c2", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -83,7 +83,7 @@ pub fn extract(desc: Option<~str>) -> Option<~str> {\n         return None\n     }\n \n-    parse_desc(desc.clone().get())\n+    parse_desc(desc.clone().unwrap())\n }\n \n fn parse_desc(desc: ~str) -> Option<~str> {"}, {"sha": "d24fd1f5bfe54fb59cc90ecb61fc482976938154", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -176,7 +176,7 @@ impl Doc {\n               doc::CratePage(doc) => Some(doc),\n               _ => None\n             }\n-        }).get()\n+        }).unwrap()\n     }\n \n     pub fn cratemod(&self) -> ModDoc {"}, {"sha": "90634770a501eaa0b8869a48ff3aa10bcab69be3", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -223,13 +223,13 @@ mod test {\n             config::DocPerCrate,\n             ~\"mod a { } fn b() { }\"\n         );\n-        assert!(doc.cratemod().index.get().entries[0] == doc::IndexEntry {\n+        assert!(doc.cratemod().index.unwrap().entries[0] == doc::IndexEntry {\n             kind: ~\"Module\",\n             name: ~\"a\",\n             brief: None,\n             link: ~\"#module-a\"\n         });\n-        assert!(doc.cratemod().index.get().entries[1] == doc::IndexEntry {\n+        assert!(doc.cratemod().index.unwrap().entries[1] == doc::IndexEntry {\n             kind: ~\"Function\",\n             name: ~\"b\",\n             brief: None,\n@@ -243,13 +243,13 @@ mod test {\n             config::DocPerMod,\n             ~\"mod a { } fn b() { }\"\n         );\n-        assert_eq!(doc.cratemod().index.get().entries[0], doc::IndexEntry {\n+        assert_eq!(doc.cratemod().index.unwrap().entries[0], doc::IndexEntry {\n             kind: ~\"Module\",\n             name: ~\"a\",\n             brief: None,\n             link: ~\"a.html\"\n         });\n-        assert_eq!(doc.cratemod().index.get().entries[1], doc::IndexEntry {\n+        assert_eq!(doc.cratemod().index.unwrap().entries[1], doc::IndexEntry {\n             kind: ~\"Function\",\n             name: ~\"b\",\n             brief: None,\n@@ -263,7 +263,7 @@ mod test {\n             config::DocPerMod,\n             ~\"#[doc = \\\"test\\\"] mod a { }\"\n         );\n-        assert_eq!(doc.cratemod().index.get().entries[0].brief, Some(~\"test\"));\n+        assert_eq!(doc.cratemod().index.unwrap().entries[0].brief, Some(~\"test\"));\n     }\n \n     #[test]\n@@ -273,7 +273,7 @@ mod test {\n             ~\"extern { fn b(); }\"\n         );\n         // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().nmods()[0].index.get().entries[0],\n+        assert_eq!(doc.cratemod().nmods()[0].index.unwrap().entries[0],\n                    doc::IndexEntry {\n                        kind: ~\"Function\",\n                        name: ~\"b\","}, {"sha": "85c360a9e0dfdd8153fa103791365235687276f3", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -617,10 +617,10 @@ mod test {\n               fn d() { }\"\n         );\n \n-        let idx_a = markdown.find_str(\"# Module `a`\").get();\n-        let idx_b = markdown.find_str(\"## Function `b`\").get();\n-        let idx_c = markdown.find_str(\"# Module `c`\").get();\n-        let idx_d = markdown.find_str(\"## Function `d`\").get();\n+        let idx_a = markdown.find_str(\"# Module `a`\").unwrap();\n+        let idx_b = markdown.find_str(\"## Function `b`\").unwrap();\n+        let idx_c = markdown.find_str(\"# Module `c`\").unwrap();\n+        let idx_d = markdown.find_str(\"## Function `d`\").unwrap();\n \n         assert!(idx_b < idx_d);\n         assert!(idx_d < idx_a);"}, {"sha": "20f3ff3e98d4871b0ec72d4bf7a865c22d55b6f0", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -218,8 +218,8 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(!doc.cratemod().mods()[0].desc().get().contains(\"Header\"));\n-        assert!(!doc.cratemod().mods()[0].desc().get().contains(\"Body\"));\n+        assert!(!doc.cratemod().mods()[0].desc().unwrap().contains(\"Header\"));\n+        assert!(!doc.cratemod().mods()[0].desc().unwrap().contains(\"Body\"));\n     }\n \n     #[test]"}, {"sha": "684b4e9d198d4d1551e05418143f33b469485ce5", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -135,7 +135,7 @@ fn fold_enum(\n                             let ast_variant =\n                                 (*do enum_definition.variants.iter().find_ |v| {\n                                 to_str(v.node.name) == variant.name\n-                            }.get()).clone();\n+                            }.unwrap()).clone();\n \n                             pprust::variant_to_str(\n                                 &ast_variant, extract::interner())\n@@ -443,14 +443,14 @@ mod test {\n     #[test]\n     fn should_add_struct_defs() {\n         let doc = mk_doc(~\"struct S { field: () }\");\n-        assert!(doc.cratemod().structs()[0].sig.get().contains(\n+        assert!(doc.cratemod().structs()[0].sig.unwrap().contains(\n             \"struct S {\"));\n     }\n \n     #[test]\n     fn should_not_serialize_struct_attrs() {\n         // All we care about are the fields\n         let doc = mk_doc(~\"#[wut] struct S { field: () }\");\n-        assert!(!doc.cratemod().structs()[0].sig.get().contains(\"wut\"));\n+        assert!(!doc.cratemod().structs()[0].sig.unwrap().contains(\"wut\"));\n     }\n }"}, {"sha": "5d5518997f68f0252ab8e9c3acd276c0dec417f7", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -322,14 +322,14 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n             // instead we guess which file is the library by matching\n             // the prefix and suffix of out_filename to files in the\n             // directory.\n-            let file_str = file.filename().get();\n-            file_str.starts_with(outputs.out_filename.filestem().get())\n-                && file_str.ends_with(outputs.out_filename.filetype().get())\n+            let file_str = file.filename().unwrap();\n+            file_str.starts_with(outputs.out_filename.filestem().unwrap())\n+                && file_str.ends_with(outputs.out_filename.filetype().unwrap())\n         };\n         match maybe_lib_path {\n             Some(lib_path) => {\n-                let (src_mtime, _) = src_path.get_mtime().get();\n-                let (lib_mtime, _) = lib_path.get_mtime().get();\n+                let (src_mtime, _) = src_path.get_mtime().unwrap();\n+                let (lib_mtime, _) = lib_path.get_mtime().unwrap();\n                 if lib_mtime >= src_mtime {\n                     should_compile = false;\n                 }"}, {"sha": "fa03a5bbfc2fbf70eb47beea86951ae38971edd4", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -102,7 +102,7 @@ impl<'self> PkgScript<'self> {\n     debug!(\"pkgscript parse: %?\", os::self_exe_path());\n         let options = @session::options {\n             binary: binary,\n-            maybe_sysroot: Some(@os::self_exe_path().get().pop()),\n+            maybe_sysroot: Some(@os::self_exe_path().unwrap().pop()),\n             crate_type: session::bin_crate,\n             .. (*session::basic_options()).clone()\n         };\n@@ -535,7 +535,7 @@ pub fn main() {\n  * in is the working directory.\n  */\n pub fn work_dir() -> Path {\n-    os::self_exe_path().get()\n+    os::self_exe_path().unwrap()\n }\n \n /**"}, {"sha": "81b47d6a16c0ad8ec9640ed6d988b88364a62a3b", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -195,7 +195,7 @@ pub fn compile_input(ctxt: &Ctx,\n                           }\n                           + flags\n                           + cfgs.flat_map(|c| { ~[~\"--cfg\", (*c).clone()] }),\n-                          driver::optgroups()).get();\n+                          driver::optgroups()).unwrap();\n     let options = @session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },"}, {"sha": "a84f3137bbd5bfb022f2ac93a6982472c59b3064", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -78,10 +78,8 @@ pub fn build<A>(builder: &fn(push: &fn(v: A))) -> @[A] {\n  *             onto the vector being constructed.\n  */\n #[inline]\n-pub fn build_sized_opt<A>(size: Option<uint>,\n-                          builder: &fn(push: &fn(v: A)))\n-                       -> @[A] {\n-    build_sized(size.get_or_default(4), builder)\n+pub fn build_sized_opt<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> @[A] {\n+    build_sized(size.unwrap_or_default(4), builder)\n }\n \n // Appending"}, {"sha": "cfaef550c6fa74072a2cd64413d7aa612e044a06", "filename": "src/libstd/either.rs", "status": "modified", "additions": 173, "deletions": 193, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -23,29 +23,102 @@ use str::StrSlice;\n use vec;\n use vec::{OwnedVector, ImmutableVector};\n \n-/// The either type\n+/// `Either` is a type that represents one of two alternatives\n #[deriving(Clone, Eq)]\n-pub enum Either<T, U> {\n-    Left(T),\n-    Right(U)\n+pub enum Either<L, R> {\n+    Left(L),\n+    Right(R)\n }\n \n-/// Applies a function based on the given either value\n-///\n-/// If `value` is left(T) then `f_left` is applied to its contents, if\n-/// `value` is right(U) then `f_right` is applied to its contents, and the\n-/// result is returned.\n-#[inline]\n-pub fn either<T, U, V>(f_left: &fn(&T) -> V,\n-                       f_right: &fn(&U) -> V, value: &Either<T, U>) -> V {\n-    match *value {\n-        Left(ref l) => f_left(l),\n-        Right(ref r) => f_right(r)\n+impl<L, R> Either<L, R> {\n+    /// Applies a function based on the given either value\n+    ///\n+    /// If `value` is `Left(L)` then `f_left` is applied to its contents, if\n+    /// `value` is `Right(R)` then `f_right` is applied to its contents, and the\n+    /// result is returned.\n+    #[inline]\n+    pub fn either<T>(&self, f_left: &fn(&L) -> T, f_right: &fn(&R) -> T) -> T {\n+        match *self {\n+            Left(ref l) => f_left(l),\n+            Right(ref r) => f_right(r)\n+        }\n+    }\n+\n+    /// Flips between left and right of a given `Either`\n+    #[inline]\n+    pub fn flip(self) -> Either<R, L> {\n+        match self {\n+            Right(r) => Left(r),\n+            Left(l) => Right(l)\n+        }\n+    }\n+\n+    /// Converts a `Either` to a `Result`\n+    ///\n+    /// Converts an `Either` type to a `Result` type, making the \"right\" choice\n+    /// an `Ok` result, and the \"left\" choice a `Err`\n+    #[inline]\n+    pub fn to_result(self) -> Result<R, L> {\n+        match self {\n+            Right(r) => result::Ok(r),\n+            Left(l) => result::Err(l)\n+        }\n+    }\n+\n+    /// Checks whether the given value is a `Left`\n+    #[inline]\n+    pub fn is_left(&self) -> bool {\n+        match *self {\n+            Left(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks whether the given value is a `Right`\n+    #[inline]\n+    pub fn is_right(&self) -> bool {\n+        match *self {\n+            Right(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Retrieves the value from a `Left`.\n+    /// Fails with a specified reason if the `Either` is `Right`.\n+    #[inline]\n+    pub fn expect_left(self, reason: &str) -> L {\n+        match self {\n+            Left(x) => x,\n+            Right(_) => fail!(reason.to_owned())\n+        }\n+    }\n+\n+    /// Retrieves the value from a `Left`. Fails if the `Either` is `Right`.\n+    #[inline]\n+    pub fn unwrap_left(self) -> L {\n+        self.expect_left(\"called Either::unwrap_left()` on `Right` value\")\n+    }\n+\n+    /// Retrieves the value from a `Right`.\n+    /// Fails with a specified reason if the `Either` is `Left`.\n+    #[inline]\n+    pub fn expect_right(self, reason: &str) -> R {\n+        match self {\n+            Right(x) => x,\n+            Left(_) => fail!(reason.to_owned())\n+        }\n+    }\n+\n+    /// Retrieves the value from a `Right`. Fails if the `Either` is `Left`.\n+    #[inline]\n+    pub fn unwrap_right(self) -> R {\n+        self.expect_right(\"called Either::unwrap_right()` on `Left` value\")\n     }\n }\n \n+// FIXME: #8228 Replaceable by an external iterator?\n /// Extracts from a vector of either all the left values\n-pub fn lefts<T:Clone,U>(eithers: &[Either<T, U>]) -> ~[T] {\n+pub fn lefts<L: Clone, R>(eithers: &[Either<L, R>]) -> ~[L] {\n     do vec::build_sized(eithers.len()) |push| {\n         for elt in eithers.iter() {\n             match *elt {\n@@ -56,8 +129,9 @@ pub fn lefts<T:Clone,U>(eithers: &[Either<T, U>]) -> ~[T] {\n     }\n }\n \n+// FIXME: #8228 Replaceable by an external iterator?\n /// Extracts from a vector of either all the right values\n-pub fn rights<T, U: Clone>(eithers: &[Either<T, U>]) -> ~[U] {\n+pub fn rights<L, R: Clone>(eithers: &[Either<L, R>]) -> ~[R] {\n     do vec::build_sized(eithers.len()) |push| {\n         for elt in eithers.iter() {\n             match *elt {\n@@ -68,13 +142,14 @@ pub fn rights<T, U: Clone>(eithers: &[Either<T, U>]) -> ~[U] {\n     }\n }\n \n+// FIXME: #8228 Replaceable by an external iterator?\n /// Extracts from a vector of either all the left values and right values\n ///\n /// Returns a structure containing a vector of left values and a vector of\n /// right values.\n-pub fn partition<T, U>(eithers: ~[Either<T, U>]) -> (~[T], ~[U]) {\n-    let mut lefts: ~[T] = ~[];\n-    let mut rights: ~[U] = ~[];\n+pub fn partition<L, R>(eithers: ~[Either<L, R>]) -> (~[L], ~[R]) {\n+    let mut lefts: ~[L] = ~[];\n+    let mut rights: ~[R] = ~[];\n     for elt in eithers.consume_iter() {\n         match elt {\n             Left(l) => lefts.push(l),\n@@ -84,196 +159,101 @@ pub fn partition<T, U>(eithers: ~[Either<T, U>]) -> (~[T], ~[U]) {\n     return (lefts, rights);\n }\n \n-/// Flips between left and right of a given either\n-#[inline]\n-pub fn flip<T, U>(eith: Either<T, U>) -> Either<U, T> {\n-    match eith {\n-        Right(r) => Left(r),\n-        Left(l) => Right(l)\n-    }\n-}\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n \n-/// Converts either::t to a result::t\n-///\n-/// Converts an `either` type to a `result` type, making the \"right\" choice\n-/// an ok result, and the \"left\" choice a fail\n-#[inline]\n-pub fn to_result<T, U>(eith: Either<T, U>) -> Result<U, T> {\n-    match eith {\n-        Right(r) => result::Ok(r),\n-        Left(l) => result::Err(l)\n+    #[test]\n+    fn test_either_left() {\n+        let val = Left(10);\n+        fn f_left(x: &int) -> bool { *x == 10 }\n+        fn f_right(_x: &uint) -> bool { false }\n+        assert!(val.either(f_left, f_right));\n     }\n-}\n \n-/// Checks whether the given value is a left\n-#[inline]\n-pub fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n-    match *eith {\n-        Left(_) => true,\n-        _ => false\n+    #[test]\n+    fn test_either_right() {\n+        let val = Right(10u);\n+        fn f_left(_x: &int) -> bool { false }\n+        fn f_right(x: &uint) -> bool { *x == 10u }\n+        assert!(val.either(f_left, f_right));\n     }\n-}\n \n-/// Checks whether the given value is a right\n-#[inline]\n-pub fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n-    match *eith {\n-        Right(_) => true,\n-        _ => false\n+    #[test]\n+    fn test_lefts() {\n+        let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n+        let result = lefts(input);\n+        assert_eq!(result, ~[10, 12, 14]);\n     }\n-}\n \n-/// Retrieves the value in the left branch.\n-/// Fails with a specified reason if the either is Right.\n-#[inline]\n-pub fn expect_left<T,U>(eith: Either<T,U>, reason: &str) -> T {\n-    match eith {\n-        Left(x) => x,\n-        Right(_) => fail!(reason.to_owned())\n+    #[test]\n+    fn test_lefts_none() {\n+        let input: ~[Either<int, int>] = ~[Right(10), Right(10)];\n+        let result = lefts(input);\n+        assert_eq!(result.len(), 0u);\n     }\n-}\n \n-/// Retrieves the value in the left branch. Fails if the either is Right.\n-#[inline]\n-pub fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n-    expect_left(eith, \"either::unwrap_left Right\")\n-}\n-\n-/// Retrieves the value in the right branch.\n-/// Fails with a specified reason if the either is Left.\n-#[inline]\n-pub fn expect_right<T,U>(eith: Either<T,U>, reason: &str) -> U {\n-    match eith {\n-        Right(x) => x,\n-        Left(_) => fail!(reason.to_owned())\n+    #[test]\n+    fn test_lefts_empty() {\n+        let input: ~[Either<int, int>] = ~[];\n+        let result = lefts(input);\n+        assert_eq!(result.len(), 0u);\n     }\n-}\n \n-/// Retrieves the value in the right branch. Fails if the either is Left.\n-pub fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n-    expect_right(eith, \"either::unwrap_right Left\")\n-}\n-\n-impl<T, U> Either<T, U> {\n-    #[inline]\n-    pub fn either<V>(&self, f_left: &fn(&T) -> V, f_right: &fn(&U) -> V) -> V {\n-        either(f_left, f_right, self)\n+    #[test]\n+    fn test_rights() {\n+        let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n+        let result = rights(input);\n+        assert_eq!(result, ~[11, 13]);\n     }\n \n-    #[inline]\n-    pub fn flip(self) -> Either<U, T> { flip(self) }\n-\n-    #[inline]\n-    pub fn to_result(self) -> Result<U, T> { to_result(self) }\n-\n-    #[inline]\n-    pub fn is_left(&self) -> bool { is_left(self) }\n-\n-    #[inline]\n-    pub fn is_right(&self) -> bool { is_right(self) }\n-\n-    #[inline]\n-    pub fn expect_left(self, reason: &str) -> T { expect_left(self, reason) }\n-\n-    #[inline]\n-    pub fn unwrap_left(self) -> T { unwrap_left(self) }\n-\n-    #[inline]\n-    pub fn expect_right(self, reason: &str) -> U { expect_right(self, reason) }\n-\n-    #[inline]\n-    pub fn unwrap_right(self) -> U { unwrap_right(self) }\n-}\n-\n-#[test]\n-fn test_either_left() {\n-    let val = Left(10);\n-    fn f_left(x: &int) -> bool { *x == 10 }\n-    fn f_right(_x: &uint) -> bool { false }\n-    assert!((either(f_left, f_right, &val)));\n-}\n-\n-#[test]\n-fn test_either_right() {\n-    let val = Right(10u);\n-    fn f_left(_x: &int) -> bool { false }\n-    fn f_right(x: &uint) -> bool { *x == 10u }\n-    assert!((either(f_left, f_right, &val)));\n-}\n-\n-#[test]\n-fn test_lefts() {\n-    let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-    let result = lefts(input);\n-    assert_eq!(result, ~[10, 12, 14]);\n-}\n-\n-#[test]\n-fn test_lefts_none() {\n-    let input: ~[Either<int, int>] = ~[Right(10), Right(10)];\n-    let result = lefts(input);\n-    assert_eq!(result.len(), 0u);\n-}\n-\n-#[test]\n-fn test_lefts_empty() {\n-    let input: ~[Either<int, int>] = ~[];\n-    let result = lefts(input);\n-    assert_eq!(result.len(), 0u);\n-}\n-\n-#[test]\n-fn test_rights() {\n-    let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-    let result = rights(input);\n-    assert_eq!(result, ~[11, 13]);\n-}\n+    #[test]\n+    fn test_rights_none() {\n+        let input: ~[Either<int, int>] = ~[Left(10), Left(10)];\n+        let result = rights(input);\n+        assert_eq!(result.len(), 0u);\n+    }\n \n-#[test]\n-fn test_rights_none() {\n-    let input: ~[Either<int, int>] = ~[Left(10), Left(10)];\n-    let result = rights(input);\n-    assert_eq!(result.len(), 0u);\n-}\n+    #[test]\n+    fn test_rights_empty() {\n+        let input: ~[Either<int, int>] = ~[];\n+        let result = rights(input);\n+        assert_eq!(result.len(), 0u);\n+    }\n \n-#[test]\n-fn test_rights_empty() {\n-    let input: ~[Either<int, int>] = ~[];\n-    let result = rights(input);\n-    assert_eq!(result.len(), 0u);\n-}\n+    #[test]\n+    fn test_partition() {\n+        let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n+        let (lefts, rights) = partition(input);\n+        assert_eq!(lefts[0], 10);\n+        assert_eq!(lefts[1], 12);\n+        assert_eq!(lefts[2], 14);\n+        assert_eq!(rights[0], 11);\n+        assert_eq!(rights[1], 13);\n+    }\n \n-#[test]\n-fn test_partition() {\n-    let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-    let (lefts, rights) = partition(input);\n-    assert_eq!(lefts[0], 10);\n-    assert_eq!(lefts[1], 12);\n-    assert_eq!(lefts[2], 14);\n-    assert_eq!(rights[0], 11);\n-    assert_eq!(rights[1], 13);\n-}\n+    #[test]\n+    fn test_partition_no_lefts() {\n+        let input: ~[Either<int, int>] = ~[Right(10), Right(11)];\n+        let (lefts, rights) = partition(input);\n+        assert_eq!(lefts.len(), 0u);\n+        assert_eq!(rights.len(), 2u);\n+    }\n \n-#[test]\n-fn test_partition_no_lefts() {\n-    let input: ~[Either<int, int>] = ~[Right(10), Right(11)];\n-    let (lefts, rights) = partition(input);\n-    assert_eq!(lefts.len(), 0u);\n-    assert_eq!(rights.len(), 2u);\n-}\n+    #[test]\n+    fn test_partition_no_rights() {\n+        let input: ~[Either<int, int>] = ~[Left(10), Left(11)];\n+        let (lefts, rights) = partition(input);\n+        assert_eq!(lefts.len(), 2u);\n+        assert_eq!(rights.len(), 0u);\n+    }\n \n-#[test]\n-fn test_partition_no_rights() {\n-    let input: ~[Either<int, int>] = ~[Left(10), Left(11)];\n-    let (lefts, rights) = partition(input);\n-    assert_eq!(lefts.len(), 2u);\n-    assert_eq!(rights.len(), 0u);\n-}\n+    #[test]\n+    fn test_partition_empty() {\n+        let input: ~[Either<int, int>] = ~[];\n+        let (lefts, rights) = partition(input);\n+        assert_eq!(lefts.len(), 0u);\n+        assert_eq!(rights.len(), 0u);\n+    }\n \n-#[test]\n-fn test_partition_empty() {\n-    let input: ~[Either<int, int>] = ~[];\n-    let (lefts, rights) = partition(input);\n-    assert_eq!(lefts.len(), 0u);\n-    assert_eq!(rights.len(), 0u);\n }"}, {"sha": "c2a60e1c0e9c01891dd97a56a2abb09c80bf06d2", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -112,29 +112,29 @@ fn test_tls_multitask() {\n         // TLS shouldn't carry over.\n         assert!(get(my_key, |k| k.map(|&k| *k)).is_none());\n         set(my_key, @~\"child data\");\n-        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) ==\n+        assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) ==\n                 ~\"child data\");\n         // should be cleaned up for us\n     }\n     // Must work multiple times\n-    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n-    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n-    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) == ~\"parent data\");\n }\n \n #[test]\n fn test_tls_overwrite() {\n     static my_key: Key<@~str> = &Key;\n     set(my_key, @~\"first data\");\n     set(my_key, @~\"next data\"); // Shouldn't leak.\n-    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"next data\");\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) == ~\"next data\");\n }\n \n #[test]\n fn test_tls_pop() {\n     static my_key: Key<@~str> = &Key;\n     set(my_key, @~\"weasel\");\n-    assert!(*(pop(my_key).get()) == ~\"weasel\");\n+    assert!(*(pop(my_key).unwrap()) == ~\"weasel\");\n     // Pop must remove the data from the map.\n     assert!(pop(my_key).is_none());\n }\n@@ -155,7 +155,7 @@ fn test_tls_modify() {\n             None                 => fail!(\"missing value\")\n         }\n     });\n-    assert!(*(pop(my_key).get()) == ~\"next data\");\n+    assert!(*(pop(my_key).unwrap()) == ~\"next data\");\n }\n \n #[test]"}, {"sha": "7ab3c81b61f7abd4e134e8f66ecafbff0187bf26", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -726,4 +726,4 @@ mod bench {\n             float::to_str(rng.gen());\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3a4a9220ee16c860798922fc5e45fc996904e1a7", "filename": "src/libstd/option.rs", "status": "modified", "additions": 104, "deletions": 108, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -47,7 +47,8 @@ use ops::Add;\n use util;\n use num::Zero;\n use iterator::Iterator;\n-use str::StrSlice;\n+use str::{StrSlice, OwnedStr};\n+use to_str::ToStr;\n use clone::DeepClone;\n \n /// The option type\n@@ -85,18 +86,33 @@ impl<T:Ord> Ord for Option<T> {\n     }\n }\n \n-impl<T:Clone+Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n+impl<T: Add<T, T>> Add<Option<T>, Option<T>> for Option<T> {\n     #[inline]\n     fn add(&self, other: &Option<T>) -> Option<T> {\n         match (&*self, &*other) {\n             (&None, &None) => None,\n-            (_, &None) => (*self).clone(),\n-            (&None, _) => (*other).clone(),\n+            (_, &None) => None,\n+            (&None, _) => None,\n             (&Some(ref lhs), &Some(ref rhs)) => Some(*lhs + *rhs)\n         }\n     }\n }\n \n+// FIXME: #8242 implementing manually because deriving doesn't work for some reason\n+impl<T: ToStr> ToStr for Option<T> {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            Some(ref x) => {\n+                let mut s = ~\"Some(\";\n+                s.push_str(x.to_str());\n+                s.push_str(\")\");\n+                s\n+            }\n+            None => ~\"None\"\n+        }\n+    }\n+}\n+\n impl<T> Option<T> {\n     /// Return an iterator over the possibly contained value\n     #[inline]\n@@ -148,8 +164,7 @@ impl<T> Option<T> {\n     /// Update an optional value by optionally running its content by reference\n     /// through a function that returns an option.\n     #[inline]\n-    pub fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>)\n-                            -> Option<U> {\n+    pub fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>) -> Option<U> {\n         match *self {\n             Some(ref x) => f(x),\n             None => None\n@@ -159,8 +174,7 @@ impl<T> Option<T> {\n     /// Update an optional value by optionally running its content by mut reference\n     /// through a function that returns an option.\n     #[inline]\n-    pub fn chain_mut_ref<'a, U>(&'a mut self, f: &fn(x: &'a mut T) -> Option<U>)\n-                                -> Option<U> {\n+    pub fn chain_mut_ref<'a, U>(&'a mut self, f: &fn(x: &'a mut T) -> Option<U>) -> Option<U> {\n         match *self {\n             Some(ref mut x) => f(x),\n             None => None\n@@ -256,132 +270,105 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /**\n-    Gets an immutable reference to the value inside an option.\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-     */\n+    /// Gets an immutable reference to the value inside an option.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`\n+    ///\n+    /// # Safety note\n+    ///\n+    /// In general, because this function may fail, its use is discouraged\n+    /// (calling `get` on `None` is akin to dereferencing a null pointer).\n+    /// Instead, prefer to use pattern matching and handle the `None`\n+    /// case explicitly.\n     #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n-          Some(ref x) => x,\n-          None => fail!(\"option::get_ref `None`\"),\n+            Some(ref x) => x,\n+            None => fail!(\"called `Option::get_ref()` on a `None` value\"),\n         }\n     }\n \n-    /**\n-    Gets a mutable reference to the value inside an option.\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-     */\n+    /// Gets a mutable reference to the value inside an option.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`\n+    ///\n+    /// # Safety note\n+    ///\n+    /// In general, because this function may fail, its use is discouraged\n+    /// (calling `get` on `None` is akin to dereferencing a null pointer).\n+    /// Instead, prefer to use pattern matching and handle the `None`\n+    /// case explicitly.\n     #[inline]\n     pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n-          Some(ref mut x) => x,\n-          None => fail!(\"option::get_mut_ref `None`\"),\n+            Some(ref mut x) => x,\n+            None => fail!(\"called `Option::get_mut_ref()` on a `None` value\"),\n         }\n     }\n \n+    /// Moves a value out of an option type and returns it.\n+    ///\n+    /// Useful primarily for getting strings, vectors and unique pointers out\n+    /// of option types without copying them.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`.\n+    ///\n+    /// # Safety note\n+    ///\n+    /// In general, because this function may fail, its use is discouraged.\n+    /// Instead, prefer to use pattern matching and handle the `None`\n+    /// case explicitly.\n     #[inline]\n     pub fn unwrap(self) -> T {\n-        /*!\n-        Moves a value out of an option type and returns it.\n-\n-        Useful primarily for getting strings, vectors and unique pointers out\n-        of option types without copying them.\n-\n-        # Failure\n-\n-        Fails if the value equals `None`.\n-\n-        # Safety note\n-\n-        In general, because this function may fail, its use is discouraged.\n-        Instead, prefer to use pattern matching and handle the `None`\n-        case explicitly.\n-         */\n         match self {\n-          Some(x) => x,\n-          None => fail!(\"option::unwrap `None`\"),\n+            Some(x) => x,\n+            None => fail!(\"called `Option::unwrap()` on a `None` value\"),\n         }\n     }\n \n-    /**\n-     * The option dance. Moves a value out of an option type and returns it,\n-     * replacing the original with `None`.\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `None`.\n-     */\n+    /// The option dance. Moves a value out of an option type and returns it,\n+    /// replacing the original with `None`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`.\n     #[inline]\n     pub fn take_unwrap(&mut self) -> T {\n-        if self.is_none() { fail!(\"option::take_unwrap `None`\") }\n+        if self.is_none() {\n+            fail!(\"called `Option::take_unwrap()` on a `None` value\")\n+        }\n         self.take().unwrap()\n     }\n \n-    /**\n-     * Gets the value out of an option, printing a specified message on\n-     * failure\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `None`\n-     */\n+    ///  Gets the value out of an option, printing a specified message on\n+    ///  failure\n+    ///\n+    ///  # Failure\n+    ///\n+    ///  Fails if the value equals `None`\n     #[inline]\n     pub fn expect(self, reason: &str) -> T {\n         match self {\n-          Some(val) => val,\n-          None => fail!(reason.to_owned()),\n+            Some(val) => val,\n+            None => fail!(reason.to_owned()),\n         }\n     }\n \n-    /**\n-    Gets the value out of an option\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-    */\n+    /// Returns the contained value or a default\n     #[inline]\n-    pub fn get(self) -> T {\n+    pub fn unwrap_or_default(self, def: T) -> T {\n         match self {\n-          Some(x) => return x,\n-          None => fail!(\"option::get `None`\")\n+            Some(x) => x,\n+            None => def\n         }\n     }\n \n-    /// Returns the contained value or a default\n-    #[inline]\n-    pub fn get_or_default(self, def: T) -> T {\n-        match self { Some(x) => x, None => def }\n-    }\n-\n     /// Applies a function zero or more times until the result is `None`.\n     #[inline]\n     pub fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n@@ -395,12 +382,21 @@ impl<T> Option<T> {\n impl<T:Zero> Option<T> {\n     /// Returns the contained value or zero (for this type)\n     #[inline]\n-    pub fn get_or_zero(self) -> T {\n+    pub fn unwrap_or_zero(self) -> T {\n         match self {\n             Some(x) => x,\n             None => Zero::zero()\n         }\n     }\n+\n+    /// Returns self or `Some(zero)` (for this type)\n+    #[inline]\n+    pub fn or_zero(self) -> Option<T> {\n+        match self {\n+            None => Some(Zero::zero()),\n+            x => x\n+        }\n+    }\n }\n \n impl<T> Zero for Option<T> {\n@@ -450,7 +446,7 @@ mod tests {\n     use util;\n \n     #[test]\n-    fn test_unwrap_ptr() {\n+    fn test_get_ptr() {\n         unsafe {\n             let x = ~0;\n             let addr_x: *int = ::cast::transmute(&*x);\n@@ -462,7 +458,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_unwrap_str() {\n+    fn test_get_str() {\n         let x = ~\"test\";\n         let addr_x = x.as_imm_buf(|buf, _len| buf);\n         let opt = Some(x);\n@@ -472,7 +468,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_unwrap_resource() {\n+    fn test_get_resource() {\n         struct R {\n            i: @mut int,\n         }\n@@ -530,18 +526,18 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_get_or_zero() {\n+    fn test_unwrap_or_zero() {\n         let some_stuff = Some(42);\n-        assert_eq!(some_stuff.get_or_zero(), 42);\n+        assert_eq!(some_stuff.unwrap_or_zero(), 42);\n         let no_stuff: Option<int> = None;\n-        assert_eq!(no_stuff.get_or_zero(), 0);\n+        assert_eq!(no_stuff.unwrap_or_zero(), 0);\n     }\n \n     #[test]\n     fn test_filtered() {\n         let some_stuff = Some(42);\n         let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n-        assert_eq!(some_stuff.get(), 42);\n+        assert_eq!(some_stuff.unwrap(), 42);\n         assert!(modified_stuff.is_none());\n     }\n "}, {"sha": "b0e1f35b4a018a6c8237b29b7ca4b06c15741306", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -571,15 +571,15 @@ pub fn tmpdir() -> Path {\n \n     #[cfg(unix)]\n     fn lookup() -> Path {\n-        getenv_nonempty(\"TMPDIR\").get_or_default(Path(\"/tmp\"))\n+        getenv_nonempty(\"TMPDIR\").unwrap_or_default(Path(\"/tmp\"))\n     }\n \n     #[cfg(windows)]\n     fn lookup() -> Path {\n         getenv_nonempty(\"TMP\").or(\n             getenv_nonempty(\"TEMP\").or(\n                 getenv_nonempty(\"USERPROFILE\").or(\n-                   getenv_nonempty(\"WINDIR\")))).get_or_default(Path(\"C:\\\\Windows\"))\n+                   getenv_nonempty(\"WINDIR\")))).unwrap_or_default(Path(\"C:\\\\Windows\"))\n     }\n }\n \n@@ -1782,7 +1782,7 @@ mod tests {\n     fn test_self_exe_path() {\n         let path = os::self_exe_path();\n         assert!(path.is_some());\n-        let path = path.get();\n+        let path = path.unwrap();\n         debug!(path.clone());\n \n         // Hard to test this function"}, {"sha": "4ef524d77152bb224021d3ef7dc3b8a8e253906c", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -533,7 +533,7 @@ impl<R: Rng> RngUtil for R {\n \n     /// Choose an item randomly, failing if values is empty\n     fn choose<T:Clone>(&mut self, values: &[T]) -> T {\n-        self.choose_option(values).get()\n+        self.choose_option(values).unwrap()\n     }\n \n     /// Choose Some(item) randomly, returning None if values is empty\n@@ -549,7 +549,7 @@ impl<R: Rng> RngUtil for R {\n      * the weights is 0\n      */\n     fn choose_weighted<T:Clone>(&mut self, v: &[Weighted<T>]) -> T {\n-        self.choose_weighted_option(v).get()\n+        self.choose_weighted_option(v).unwrap()\n     }\n \n     /**"}, {"sha": "181590e3929c5812d4647256ddb5154a17897bcd", "filename": "src/libstd/result.rs", "status": "modified", "additions": 149, "deletions": 178, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -20,23 +20,27 @@ use option::{None, Option, Some};\n use vec;\n use vec::{OwnedVector, ImmutableVector};\n use container::Container;\n-\n-/// The result type\n+use to_str::ToStr;\n+use str::StrSlice;\n+\n+/// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n+///\n+/// In order to provide informative error messages, `E` is reqired to implement `ToStr`.\n+/// It is further recommended for `E` to be a descriptive error type, eg a `enum` for\n+/// all possible errors cases.\n #[deriving(Clone, Eq)]\n-pub enum Result<T, U> {\n+pub enum Result<T, E> {\n     /// Contains the successful result value\n     Ok(T),\n     /// Contains the error value\n-    Err(U)\n+    Err(E)\n }\n \n-impl<T, E> Result<T, E> {\n-    /**\n-     * Convert to the `either` type\n-     *\n-     * `Ok` result variants are converted to `either::Right` variants, `Err`\n-     * result variants are converted to `either::Left`.\n-     */\n+impl<T, E: ToStr> Result<T, E> {\n+    /// Convert to the `either` type\n+    ///\n+    /// `Ok` result variants are converted to `either::Right` variants, `Err`\n+    /// result variants are converted to `either::Left`.\n     #[inline]\n     pub fn to_either(self)-> either::Either<E, T>{\n         match self {\n@@ -45,18 +49,16 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /**\n-     * Get a reference to the value out of a successful result\n-     *\n-     * # Failure\n-     *\n-     * If the result is an error\n-     */\n+    /// Get a reference to the value out of a successful result\n+    ///\n+    /// # Failure\n+    ///\n+    /// If the result is an error\n     #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n             Ok(ref t) => t,\n-            Err(ref e) => fail!(\"get_ref called on `Err` result: %?\", *e),\n+            Err(ref e) => fail!(\"called `Result::get_ref()` on `Err` value: %s\", e.to_str()),\n         }\n     }\n \n@@ -75,20 +77,18 @@ impl<T, E> Result<T, E> {\n         !self.is_ok()\n     }\n \n-    /**\n-     * Call a method based on a previous result\n-     *\n-     * If `self` is `Ok` then the value is extracted and passed to `op`\n-     * whereupon `op`s result is returned. if `self` is `Err` then it is\n-     * immediately returned. This function can be used to compose the results\n-     * of two functions.\n-     *\n-     * Example:\n-     *\n-     *     do read_file(file).iter |buf| {\n-     *         print_buf(buf)\n-     *     }\n-     */\n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Ok` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is returned. if `self` is `Err` then it is\n+    /// immediately returned. This function can be used to compose the results\n+    /// of two functions.\n+    ///\n+    /// Example:\n+    ///\n+    ///     do read_file(file).iter |buf| {\n+    ///         print_buf(buf)\n+    ///     }\n     #[inline]\n     pub fn iter(&self, f: &fn(&T)) {\n         match *self {\n@@ -97,14 +97,12 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /**\n-     * Call a method based on a previous result\n-     *\n-     * If `self` is `Err` then the value is extracted and passed to `op`\n-     * whereupon `op`s result is returned. if `self` is `Ok` then it is\n-     * immediately returned.  This function can be used to pass through a\n-     * successful result while handling an error.\n-     */\n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Err` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is returned. if `self` is `Ok` then it is\n+    /// immediately returned.  This function can be used to pass through a\n+    /// successful result while handling an error.\n     #[inline]\n     pub fn iter_err(&self, f: &fn(&E)) {\n         match *self {\n@@ -113,38 +111,56 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Unwraps a result, assuming it is an `Ok(T)`\n+    /// Unwraps a result, yielding the content of an `Ok`.\n+    /// Fails if the value is a `Err` with an error message derived\n+    /// from `E`'s `ToStr` implementation.\n     #[inline]\n     pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(_) => fail!(\"unwrap called on an `Err` result\"),\n+            Err(e) => fail!(\"called `Result::unwrap()` on `Err` value: %s\", e.to_str()),\n         }\n     }\n \n-    /// Unwraps a result, assuming it is an `Err(U)`\n+    /// Unwraps a result, yielding the content of an `Err`.\n+    /// Fails if the value is a `Ok`.\n     #[inline]\n     pub fn unwrap_err(self) -> E {\n+        self.expect_err(\"called `Result::unwrap_err()` on `Ok` value\")\n+    }\n+\n+    /// Unwraps a result, yielding the content of an `Ok`.\n+    /// Fails if the value is a `Err` with a custom failure message.\n+    #[inline]\n+    pub fn expect(self, reason: &str) -> T {\n+        match self {\n+            Ok(t) => t,\n+            Err(_) => fail!(reason.to_owned()),\n+        }\n+    }\n+\n+    /// Unwraps a result, yielding the content of an `Err`\n+    /// Fails if the value is a `Ok` with a custom failure message.\n+    #[inline]\n+    pub fn expect_err(self, reason: &str) -> E {\n         match self {\n             Err(e) => e,\n-            Ok(_) => fail!(\"unwrap called on an `Ok` result\"),\n+            Ok(_) => fail!(reason.to_owned()),\n         }\n     }\n \n-    /**\n-     * Call a method based on a previous result\n-     *\n-     * If `self` is `Ok` then the value is extracted and passed to `op`\n-     * whereupon `op`s result is returned. if `self` is `Err` then it is\n-     * immediately returned. This function can be used to compose the results\n-     * of two functions.\n-     *\n-     * Example:\n-     *\n-     *     let res = do read_file(file) |buf| {\n-     *         Ok(parse_bytes(buf))\n-     *     };\n-     */\n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Ok` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is returned. if `self` is `Err` then it is\n+    /// immediately returned. This function can be used to compose the results\n+    /// of two functions.\n+    ///\n+    /// Example:\n+    ///\n+    ///     let res = do read_file(file) |buf| {\n+    ///         Ok(parse_bytes(buf))\n+    ///     };\n     #[inline]\n     pub fn chain<U>(self, op: &fn(T) -> Result<U, E>) -> Result<U, E> {\n         match self {\n@@ -153,14 +169,12 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /**\n-     * Call a function based on a previous result\n-     *\n-     * If `self` is `Err` then the value is extracted and passed to `op`\n-     * whereupon `op`s result is returned. if `self` is `Ok` then it is\n-     * immediately returned.  This function can be used to pass through a\n-     * successful result while handling an error.\n-     */\n+    /// Call a function based on a previous result\n+    ///\n+    /// If `self` is `Err` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is returned. if `self` is `Ok` then it is\n+    /// immediately returned.  This function can be used to pass through a\n+    /// successful result while handling an error.\n     #[inline]\n     pub fn chain_err<F>(self, op: &fn(E) -> Result<T, F>) -> Result<T, F> {\n         match self {\n@@ -170,95 +184,73 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n-impl<T: Clone, E> Result<T, E> {\n-    /**\n-     * Get the value out of a successful result\n-     *\n-     * # Failure\n-     *\n-     * If the result is an error\n-     */\n+impl<T: Clone, E: ToStr> Result<T, E> {\n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Err` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is wrapped in an `Err` and returned. if `self` is\n+    /// `Ok` then it is immediately returned.  This function can be used to pass\n+    /// through a successful result while handling an error.\n     #[inline]\n-    pub fn get(&self) -> T {\n-        match *self {\n-            Ok(ref t) => t.clone(),\n-            Err(ref e) => fail!(\"get called on `Err` result: %?\", *e),\n-        }\n-    }\n-\n-    /**\n-     * Call a method based on a previous result\n-     *\n-     * If `self` is `Err` then the value is extracted and passed to `op`\n-     * whereupon `op`s result is wrapped in an `Err` and returned. if `self` is\n-     * `Ok` then it is immediately returned.  This function can be used to pass\n-     * through a successful result while handling an error.\n-     */\n-    #[inline]\n-    pub fn map_err<F:Clone>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n+    pub fn map_err<F: Clone>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n         match *self {\n             Ok(ref t) => Ok(t.clone()),\n             Err(ref e) => Err(op(e))\n         }\n     }\n }\n \n-impl<T, E: Clone> Result<T, E> {\n-    /**\n-     * Get the value out of an error result\n-     *\n-     * # Failure\n-     *\n-     * If the result is not an error\n-     */\n+impl<T, E: Clone + ToStr> Result<T, E> {\n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Ok` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is wrapped in `Ok` and returned. if `self` is\n+    /// `Err` then it is immediately returned.  This function can be used to\n+    /// compose the results of two functions.\n+    ///\n+    /// Example:\n+    ///\n+    ///     let res = do read_file(file).map |buf| {\n+    ///         parse_bytes(buf)\n+    ///     };\n     #[inline]\n-    pub fn get_err(&self) -> E {\n+    pub fn map<U: Clone>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n         match *self {\n-            Err(ref e) => e.clone(),\n-            Ok(_) => fail!(\"get_err called on `Ok` result\")\n+            Ok(ref t) => Ok(op(t)),\n+            Err(ref e) => Err(e.clone())\n         }\n     }\n+}\n \n-    /**\n-     * Call a method based on a previous result\n-     *\n-     * If `self` is `Ok` then the value is extracted and passed to `op`\n-     * whereupon `op`s result is wrapped in `Ok` and returned. if `self` is\n-     * `Err` then it is immediately returned.  This function can be used to\n-     * compose the results of two functions.\n-     *\n-     * Example:\n-     *\n-     *     let res = do read_file(file).map |buf| {\n-     *         parse_bytes(buf)\n-     *     };\n-     */\n-    #[inline]\n-    pub fn map<U:Clone>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n-        match *self {\n-            Ok(ref t) => Ok(op(t)),\n-            Err(ref e) => Err(e.clone())\n+#[inline]\n+#[allow(missing_doc)]\n+pub fn map_opt<T, U: ToStr, V>(o_t: &Option<T>,\n+                               op: &fn(&T) -> Result<V,U>) -> Result<Option<V>,U> {\n+    match *o_t {\n+        None => Ok(None),\n+        Some(ref t) => match op(t) {\n+            Ok(v) => Ok(Some(v)),\n+            Err(e) => Err(e)\n         }\n     }\n }\n \n-/**\n- * Maps each element in the vector `ts` using the operation `op`.  Should an\n- * error occur, no further mappings are performed and the error is returned.\n- * Should no error occur, a vector containing the result of each map is\n- * returned.\n- *\n- * Here is an example which increments every integer in a vector,\n- * checking for overflow:\n- *\n- *     fn inc_conditionally(x: uint) -> result<uint,str> {\n- *         if x == uint::max_value { return Err(\"overflow\"); }\n- *         else { return Ok(x+1u); }\n- *     }\n- *     map(~[1u, 2u, 3u], inc_conditionally).chain {|incd|\n- *         assert!(incd == ~[2u, 3u, 4u]);\n- *     }\n- */\n+// FIXME: #8228 Replaceable by an external iterator?\n+/// Maps each element in the vector `ts` using the operation `op`.  Should an\n+/// error occur, no further mappings are performed and the error is returned.\n+/// Should no error occur, a vector containing the result of each map is\n+/// returned.\n+///\n+/// Here is an example which increments every integer in a vector,\n+/// checking for overflow:\n+///\n+///     fn inc_conditionally(x: uint) -> result<uint,str> {\n+///         if x == uint::max_value { return Err(\"overflow\"); }\n+///         else { return Ok(x+1u); }\n+///     }\n+///     map(~[1u, 2u, 3u], inc_conditionally).chain {|incd|\n+///         assert!(incd == ~[2u, 3u, 4u]);\n+///     }\n #[inline]\n pub fn map_vec<T,U,V>(ts: &[T], op: &fn(&T) -> Result<V,U>)\n                       -> Result<~[V],U> {\n@@ -272,36 +264,17 @@ pub fn map_vec<T,U,V>(ts: &[T], op: &fn(&T) -> Result<V,U>)\n     return Ok(vs);\n }\n \n+// FIXME: #8228 Replaceable by an external iterator?\n+/// Same as map, but it operates over two parallel vectors.\n+///\n+/// A precondition is used here to ensure that the vectors are the same\n+/// length.  While we do not often use preconditions in the standard\n+/// library, a precondition is used here because result::t is generally\n+/// used in 'careful' code contexts where it is both appropriate and easy\n+/// to accommodate an error like the vectors being of different lengths.\n #[inline]\n-#[allow(missing_doc)]\n-pub fn map_opt<T,\n-               U,\n-               V>(\n-               o_t: &Option<T>,\n-               op: &fn(&T) -> Result<V,U>)\n-               -> Result<Option<V>,U> {\n-    match *o_t {\n-        None => Ok(None),\n-        Some(ref t) => match op(t) {\n-            Ok(v) => Ok(Some(v)),\n-            Err(e) => Err(e)\n-        }\n-    }\n-}\n-\n-/**\n- * Same as map, but it operates over two parallel vectors.\n- *\n- * A precondition is used here to ensure that the vectors are the same\n- * length.  While we do not often use preconditions in the standard\n- * library, a precondition is used here because result::t is generally\n- * used in 'careful' code contexts where it is both appropriate and easy\n- * to accommodate an error like the vectors being of different lengths.\n- */\n-#[inline]\n-pub fn map_vec2<S,T,U,V>(ss: &[S], ts: &[T],\n-                op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n-\n+pub fn map_vec2<S, T, U: ToStr, V>(ss: &[S], ts: &[T],\n+                                   op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n     assert!(vec::same_length(ss, ts));\n     let n = ts.len();\n     let mut vs = vec::with_capacity(n);\n@@ -316,15 +289,13 @@ pub fn map_vec2<S,T,U,V>(ss: &[S], ts: &[T],\n     return Ok(vs);\n }\n \n-/**\n- * Applies op to the pairwise elements from `ss` and `ts`, aborting on\n- * error.  This could be implemented using `map_zip()` but it is more efficient\n- * on its own as no result vector is built.\n- */\n+// FIXME: #8228 Replaceable by an external iterator?\n+/// Applies op to the pairwise elements from `ss` and `ts`, aborting on\n+/// error.  This could be implemented using `map_zip()` but it is more efficient\n+/// on its own as no result vector is built.\n #[inline]\n-pub fn iter_vec2<S,T,U>(ss: &[S], ts: &[T],\n-                         op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n-\n+pub fn iter_vec2<S, T, U: ToStr>(ss: &[S], ts: &[T],\n+                                 op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n     assert!(vec::same_length(ss, ts));\n     let n = ts.len();\n     let mut i = 0u;\n@@ -353,12 +324,12 @@ mod tests {\n \n     #[test]\n     pub fn chain_success() {\n-        assert_eq!(op1().chain(op2).get(), 667u);\n+        assert_eq!(op1().chain(op2).unwrap(), 667u);\n     }\n \n     #[test]\n     pub fn chain_failure() {\n-        assert_eq!(op3().chain( op2).get_err(), ~\"sadface\");\n+        assert_eq!(op3().chain( op2).unwrap_err(), ~\"sadface\");\n     }\n \n     #[test]"}, {"sha": "bea62f7e28c193a8b3ef1116de78f2bd8ab250c3", "filename": "src/libstd/rt/io/flate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fflate.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -115,7 +115,7 @@ mod test {\n         let mem_reader = MemReader::new(buf);\n         let mut inflate_reader = InflateReader::new(mem_reader);\n         let mut out_bytes = [0, .. 100];\n-        let bytes_read = inflate_reader.read(out_bytes).get();\n+        let bytes_read = inflate_reader.read(out_bytes).unwrap();\n         assert_eq!(bytes_read, in_bytes.len());\n         let out_msg = str::from_bytes(out_bytes);\n         assert!(in_msg == out_msg);"}, {"sha": "c980dc9d73efdc6546cf216b0368de4e5eb7e845", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -243,6 +243,8 @@ Out of scope\n */\n \n use prelude::*;\n+use to_str::ToStr;\n+use str::{StrSlice, OwnedStr};\n \n // Reexports\n pub use self::stdio::stdin;\n@@ -334,6 +336,20 @@ pub struct IoError {\n     detail: Option<~str>\n }\n \n+// FIXME: #8242 implementing manually because deriving doesn't work for some reason\n+impl ToStr for IoError {\n+    fn to_str(&self) -> ~str {\n+        let mut s = ~\"IoError { kind: \";\n+        s.push_str(self.kind.to_str());\n+        s.push_str(\", desc: \");\n+        s.push_str(self.desc);\n+        s.push_str(\", detail: \");\n+        s.push_str(self.detail.to_str());\n+        s.push_str(\" }\");\n+        s\n+    }\n+}\n+\n #[deriving(Eq)]\n pub enum IoErrorKind {\n     PreviousIoError,\n@@ -348,6 +364,24 @@ pub enum IoErrorKind {\n     BrokenPipe\n }\n \n+// FIXME: #8242 implementing manually because deriving doesn't work for some reason\n+impl ToStr for IoErrorKind {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            PreviousIoError => ~\"PreviousIoError\",\n+            OtherIoError => ~\"OtherIoError\",\n+            EndOfFile => ~\"EndOfFile\",\n+            FileNotFound => ~\"FileNotFound\",\n+            PermissionDenied => ~\"PermissionDenied\",\n+            ConnectionFailed => ~\"ConnectionFailed\",\n+            Closed => ~\"Closed\",\n+            ConnectionRefused => ~\"ConnectionRefused\",\n+            ConnectionReset => ~\"ConnectionReset\",\n+            BrokenPipe => ~\"BrokenPipe\"\n+        }\n+    }\n+}\n+\n // XXX: Can't put doc comments on macros\n // Raised by `I/O` operations on error.\n condition! {\n@@ -505,4 +539,4 @@ pub fn placeholder_error() -> IoError {\n         desc: \"Placeholder error. You shouldn't be seeing this\",\n         detail: None\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "760ca8a9adadcbae741cce4423728ffd6ea3e75e", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -365,7 +365,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n         rtdebug!(\"about to create the main scheduler task\");\n \n-        let mut main_sched = main_sched.get();\n+        let mut main_sched = main_sched.unwrap();\n \n         let home = Sched(main_sched.make_handle());\n         let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool,"}, {"sha": "4c5e4bdc3c1d9b8b984642686428527ec1f40d38", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -465,10 +465,10 @@ mod test {\n         do run_in_newsched_task() {\n             static key: local_data::Key<@~str> = &local_data::Key;\n             local_data::set(key, @~\"data\");\n-            assert!(*local_data::get(key, |k| k.map(|&k| *k)).get() == ~\"data\");\n+            assert!(*local_data::get(key, |k| k.map(|&k| *k)).unwrap() == ~\"data\");\n             static key2: local_data::Key<@~str> = &local_data::Key;\n             local_data::set(key2, @~\"data\");\n-            assert!(*local_data::get(key2, |k| k.map(|&k| *k)).get() == ~\"data\");\n+            assert!(*local_data::get(key2, |k| k.map(|&k| *k)).unwrap() == ~\"data\");\n         }\n     }\n "}, {"sha": "8b5215ae9694aedc4d0549b1c8f184e14d00edb5", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -154,7 +154,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n \n     do run_in_bare_thread {\n         let nthreads = match os::getenv(\"RUST_RT_TEST_THREADS\") {\n-            Some(nstr) => FromStr::from_str(nstr).get(),\n+            Some(nstr) => FromStr::from_str(nstr).unwrap(),\n             None => {\n                 // Using more threads than cores in test code\n                 // to force the OS to preempt them frequently.\n@@ -362,7 +362,7 @@ pub fn stress_factor() -> uint {\n     use os::getenv;\n \n     match getenv(\"RUST_RT_STRESS\") {\n-        Some(val) => uint::from_str(val).get(),\n+        Some(val) => uint::from_str(val).unwrap(),\n         None => 1\n     }\n }"}, {"sha": "40e5c8d4bf1a088d7d470e768f35a61c1afd4645", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -31,7 +31,7 @@ pub fn num_cpus() -> uint {\n /// either `RUST_THREADS` or `num_cpus`.\n pub fn default_sched_threads() -> uint {\n     match os::getenv(\"RUST_THREADS\") {\n-        Some(nstr) => FromStr::from_str(nstr).get(),\n+        Some(nstr) => FromStr::from_str(nstr).unwrap(),\n         None => num_cpus()\n     }\n }\n@@ -118,4 +118,4 @@ pub fn get_exit_status() -> int {\n     extern {\n         fn rust_get_exit_status_newrt() -> libc::uintptr_t;\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "fd3042899f6bca5e28dadc366b1ed0e0208ea8d3", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -108,7 +108,7 @@ fn uv_socket_addr_as_socket_addr<T>(addr: UvSocketAddr, f: &fn(SocketAddr) -> T)\n                             \"\" => ~[],\n                             // IPv4-Mapped/Compatible IPv6 Address?\n                             s if s.find('.').is_some() => {\n-                                let i = s.rfind(':').get_or_default(-1);\n+                                let i = s.rfind(':').unwrap_or_default(-1);\n \n                                 let b = s.slice(i + 1, s.len()); // the ipv4 part\n \n@@ -614,7 +614,7 @@ mod test {\n             do tcp_watcher.connect(addr) |stream_watcher, status| {\n                 rtdebug!(\"tcp_watcher.connect!\");\n                 assert!(status.is_some());\n-                assert_eq!(status.get().name(), ~\"ECONNREFUSED\");\n+                assert_eq!(status.unwrap().name(), ~\"ECONNREFUSED\");\n                 stream_watcher.close(||());\n             }\n             loop_.run();\n@@ -632,7 +632,7 @@ mod test {\n             do tcp_watcher.connect(addr) |stream_watcher, status| {\n                 rtdebug!(\"tcp_watcher.connect!\");\n                 assert!(status.is_some());\n-                assert_eq!(status.get().name(), ~\"ECONNREFUSED\");\n+                assert_eq!(status.unwrap().name(), ~\"ECONNREFUSED\");\n                 stream_watcher.close(||());\n             }\n             loop_.run();"}, {"sha": "70a397199ab7ce5b159e82f93f04618ae0a6d47b", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -278,7 +278,7 @@ impl IoFactory for UvIoFactory {\n                     rtdebug!(\"status is some\");\n                     let task_cell = Cell::new(task_cell.take());\n                     do stream_watcher.close {\n-                        let res = Err(uv_error_to_io_error(status.get()));\n+                        let res = Err(uv_error_to_io_error(status.unwrap()));\n                         unsafe { (*result_cell_ptr).put_back(res); }\n                         let scheduler = Local::take::<Scheduler>();\n                         scheduler.resume_blocked_task_immediately(task_cell.take());"}, {"sha": "95a411a3f96736009bd2461e6dc137a2656badcf", "filename": "src/libstd/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -58,7 +58,7 @@ pub fn from_bytes(vv: &[u8]) -> ~str {\n     use str::not_utf8::cond;\n \n     if !is_utf8(vv) {\n-        let first_bad_byte = *vv.iter().find_(|&b| !is_utf8([*b])).get();\n+        let first_bad_byte = *vv.iter().find_(|&b| !is_utf8([*b])).unwrap();\n         cond.raise(fmt!(\"from_bytes: input is not UTF-8; first bad byte is %u\",\n                         first_bad_byte as uint))\n     } else {\n@@ -75,7 +75,7 @@ pub fn from_bytes_owned(vv: ~[u8]) -> ~str {\n     use str::not_utf8::cond;\n \n     if !is_utf8(vv) {\n-        let first_bad_byte = *vv.iter().find_(|&b| !is_utf8([*b])).get();\n+        let first_bad_byte = *vv.iter().find_(|&b| !is_utf8([*b])).unwrap();\n         cond.raise(fmt!(\"from_bytes: input is not UTF-8; first bad byte is %u\",\n                         first_bad_byte as uint))\n     } else {"}, {"sha": "225a4b8cfd294eacb0fddb4ad2b5058b5dd0edab", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -926,7 +926,7 @@ fn test_named_task() {\n         t.name(~\"ada lovelace\");\n         do t.spawn {\n             do with_task_name |name| {\n-                assert!(name.get() == \"ada lovelace\");\n+                assert!(name.unwrap() == \"ada lovelace\");\n             }\n         }\n     }"}, {"sha": "4d4437cc963ea2bee4fac270ea8bc0c149507871", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -195,10 +195,8 @@ pub fn build<A>(builder: &fn(push: &fn(v: A))) -> ~[A] {\n  *             onto the vector being constructed.\n  */\n #[inline]\n-pub fn build_sized_opt<A>(size: Option<uint>,\n-                          builder: &fn(push: &fn(v: A)))\n-                       -> ~[A] {\n-    build_sized(size.get_or_default(4), builder)\n+pub fn build_sized_opt<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> ~[A] {\n+    build_sized(size.unwrap_or_default(4), builder)\n }\n \n /// An iterator over the slices of a vector separated by elements that"}, {"sha": "883020e637a1b80bf81886c75c18e0af663504fd", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -280,13 +280,13 @@ impl ToStr for AbiSet {\n #[test]\n fn lookup_Rust() {\n     let abi = lookup(\"Rust\");\n-    assert!(abi.is_some() && abi.get().data().name == \"Rust\");\n+    assert!(abi.is_some() && abi.unwrap().data().name == \"Rust\");\n }\n \n #[test]\n fn lookup_cdecl() {\n     let abi = lookup(\"cdecl\");\n-    assert!(abi.is_some() && abi.get().data().name == \"cdecl\");\n+    assert!(abi.is_some() && abi.unwrap().data().name == \"cdecl\");\n }\n \n #[test]"}, {"sha": "435be3c71af6f08d1fc57d644341a354cb86ddb9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -24,7 +24,7 @@ use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n // table) and a SyntaxContext to track renaming and\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes, ToStr)]\n pub struct ident { name: Name, ctxt: SyntaxContext }\n \n /// Construct an identifier with the given name and an empty context:\n@@ -121,7 +121,7 @@ pub type CrateNum = int;\n \n pub type NodeId = int;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes, ToStr)]\n pub struct def_id {\n     crate: CrateNum,\n     node: NodeId,"}, {"sha": "d39cb2f507ca957ae57d1ec7d45332487ddcfd88", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -114,7 +114,7 @@ impl AttributeMethods for Attribute {\n     /// non-sugared doc attributes.)\n     pub fn desugar_doc(&self) -> Attribute {\n         if self.node.is_sugared_doc {\n-            let comment = self.value_str().get();\n+            let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(@\"doc\",\n                                               strip_doc_comment_decoration(comment).to_managed());\n             mk_attr(meta)"}, {"sha": "6ed5ca3e402a8dc4ac5e69ada83f9255c30bc75f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -538,20 +538,20 @@ mod test {\n         m.insert (@\"def\",@16);\n         // FIXME: #4492 (ICE)  assert_eq!(m.find(&@\"abc\"),Some(@15));\n         //  ....               assert_eq!(m.find(&@\"def\"),Some(@16));\n-        assert_eq!(*(m.find(&@\"abc\").get()),15);\n-        assert_eq!(*(m.find(&@\"def\").get()),16);\n+        assert_eq!(*(m.find(&@\"abc\").unwrap()),15);\n+        assert_eq!(*(m.find(&@\"def\").unwrap()),16);\n         let n = m.push_frame();\n         // old bindings are still present:\n-        assert_eq!(*(n.find(&@\"abc\").get()),15);\n-        assert_eq!(*(n.find(&@\"def\").get()),16);\n+        assert_eq!(*(n.find(&@\"abc\").unwrap()),15);\n+        assert_eq!(*(n.find(&@\"def\").unwrap()),16);\n         n.insert (@\"def\",@17);\n         // n shows the new binding\n-        assert_eq!(*(n.find(&@\"abc\").get()),15);\n-        assert_eq!(*(n.find(&@\"def\").get()),17);\n+        assert_eq!(*(n.find(&@\"abc\").unwrap()),15);\n+        assert_eq!(*(n.find(&@\"def\").unwrap()),17);\n         // ... but m still has the old ones\n         // FIXME: #4492: assert_eq!(m.find(&@\"abc\"),Some(@15));\n         // FIXME: #4492: assert_eq!(m.find(&@\"def\"),Some(@16));\n-        assert_eq!(*(m.find(&@\"abc\").get()),15);\n-        assert_eq!(*(m.find(&@\"def\").get()),16);\n+        assert_eq!(*(m.find(&@\"abc\").unwrap()),15);\n+        assert_eq!(*(m.find(&@\"def\").unwrap()),16);\n     }\n }"}, {"sha": "fb1e6bf1913844c878d9e3a36702fcb686d61807", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -961,7 +961,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n         let field_pats = do vec::build |push| {\n             for (&pat, &(id, _)) in subpats.iter().zip(ident_expr.iter()) {\n                 // id is guaranteed to be Some\n-                push(ast::field_pat { ident: id.get(), pat: pat })\n+                push(ast::field_pat { ident: id.unwrap(), pat: pat })\n             }\n         };\n         cx.pat_struct(span, matching_path, field_pats)"}, {"sha": "c7020b990bf005695341846d0b0ecd49f773fa0a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -1182,9 +1182,9 @@ mod test {\n         let a2_name = intern(\"a2\");\n         let renamer = new_ident_renamer(ast::ident{name:a_name,ctxt:empty_ctxt},\n                                         a2_name);\n-        let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).get();\n+        let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).unwrap();\n         let resolver = new_ident_resolver();\n-        let resolved_ast = fun_to_ident_folder(resolver).fold_item(renamed_ast).get();\n+        let resolved_ast = fun_to_ident_folder(resolver).fold_item(renamed_ast).unwrap();\n         let resolved_as_str = pprust::item_to_str(resolved_ast,\n                                                   get_ident_interner());\n         assert_eq!(resolved_as_str,~\"fn a2() -> int { let b = 13; b }\");"}, {"sha": "71903b9aa0204790fca3917dc093d553a67d8117", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -31,7 +31,7 @@ pub fn expand_line(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().get());\n+    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n \n     base::MRExpr(cx.expr_uint(topmost.call_site, loc.line))\n@@ -42,7 +42,7 @@ pub fn expand_col(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().get());\n+    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n     base::MRExpr(cx.expr_uint(topmost.call_site, loc.col.to_uint()))\n }\n@@ -54,7 +54,7 @@ pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().get());\n+    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n     let filename = loc.file.name;\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))"}, {"sha": "a0932729930e3c7fcc3da3da356b6b23251b3efd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -691,7 +691,7 @@ impl Parser {\n         */\n \n         let opt_abis = self.parse_opt_abis();\n-        let abis = opt_abis.get_or_default(AbiSet::Rust());\n+        let abis = opt_abis.unwrap_or_default(AbiSet::Rust());\n         let purity = self.parse_unsafety();\n         self.expect_keyword(keywords::Fn);\n         let (decl, lifetimes) = self.parse_ty_fn_decl();\n@@ -3326,7 +3326,7 @@ impl Parser {\n         let ident = self.parse_ident();\n         let opt_bounds = self.parse_optional_ty_param_bounds();\n         // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n-        let bounds = opt_bounds.get_or_default(opt_vec::Empty);\n+        let bounds = opt_bounds.unwrap_or_default(opt_vec::Empty);\n         ast::TyParam { ident: ident, id: self.get_id(), bounds: bounds }\n     }\n \n@@ -4196,7 +4196,7 @@ impl Parser {\n                 self.obsolete(*self.last_span, ObsoleteExternVisibility);\n             }\n \n-            let abis = opt_abis.get_or_default(AbiSet::C());\n+            let abis = opt_abis.unwrap_or_default(AbiSet::C());\n \n             let (inner, next) = self.parse_inner_attrs_and_next();\n             let m = self.parse_foreign_mod_items(sort, abis, next);\n@@ -4463,7 +4463,7 @@ impl Parser {\n \n             if self.eat_keyword(keywords::Fn) {\n                 // EXTERN FUNCTION ITEM\n-                let abis = opt_abis.get_or_default(AbiSet::C());\n+                let abis = opt_abis.unwrap_or_default(AbiSet::C());\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(extern_fn, abis);\n                 return iovi_item(self.mk_item(lo, self.last_span.hi, ident,"}, {"sha": "f517179f6036613e100e2ed9290820d934db96b8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -874,7 +874,7 @@ pub fn print_attribute(s: @ps, attr: &ast::Attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n-        let comment = attr.value_str().get();\n+        let comment = attr.value_str().unwrap();\n         word(s.s, comment);\n     } else {\n         word(s.s, \"#[\");\n@@ -1085,7 +1085,7 @@ pub fn print_call_post(s: @ps,\n     }\n     if sugar != ast::NoSugar {\n         nbsp(s);\n-        match blk.get().node {\n+        match blk.unwrap().node {\n           // need to handle closures specifically\n           ast::expr_do_body(e) => {\n             end(s); // we close our head box; closure\n@@ -1095,7 +1095,7 @@ pub fn print_call_post(s: @ps,\n           }\n           _ => {\n             // not sure if this can happen.\n-            print_expr(s, blk.get());\n+            print_expr(s, blk.unwrap());\n           }\n         }\n     }\n@@ -1323,13 +1323,13 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         assert!(body.stmts.is_empty());\n         assert!(body.expr.is_some());\n         // we extract the block, so as not to create another set of boxes\n-        match body.expr.get().node {\n+        match body.expr.unwrap().node {\n             ast::expr_block(ref blk) => {\n                 print_block_unclosed(s, blk);\n             }\n             _ => {\n                 // this is a bare expression\n-                print_expr(s, body.expr.get());\n+                print_expr(s, body.expr.unwrap());\n                 end(s); // need to close a box\n             }\n         }"}, {"sha": "cf160ca31c6f185d3ae38b5a06ef6edda527674d", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -100,7 +100,7 @@ fn main() {\n     let args = os::args();\n     let n_keys = {\n         if args.len() == 2 {\n-            uint::from_str(args[1]).get()\n+            uint::from_str(args[1]).unwrap()\n         } else {\n             1000000\n         }"}, {"sha": "4fbe00622aa26fdded3c4d32bf8a6d4b7f0824e3", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -159,7 +159,7 @@ fn main() {\n     let args = os::args();\n     let num_keys = {\n         if args.len() == 2 {\n-            uint::from_str(args[1]).get()\n+            uint::from_str(args[1]).unwrap()\n         } else {\n             100 // woefully inadequate for any real measurement\n         }"}, {"sha": "4a32fda59d81ad5cb4e15963083b73f361b97da7", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -21,7 +21,7 @@ fn main() {\n         args\n     };\n \n-    let n = uint::from_str(args[1]).get();\n+    let n = uint::from_str(args[1]).unwrap();\n \n     for i in range(0u, n) {\n         let x = uint::to_str(i);"}, {"sha": "2f4d763b84d778ab750446de95e447dd2b0cb122", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -418,8 +418,8 @@ fn main() {\n         args\n     };\n \n-    let scale = uint::from_str(args[1]).get();\n-    let num_keys = uint::from_str(args[2]).get();\n+    let scale = uint::from_str(args[1]).unwrap();\n+    let num_keys = uint::from_str(args[2]).unwrap();\n     let do_validate = false;\n     let do_sequential = true;\n "}, {"sha": "4e9656afb813d253c50713163bdc3cfa4f8eae7a", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -59,8 +59,8 @@ fn run(args: &[~str]) {\n \n     let to_child = SharedChan::new(to_child);\n \n-    let size = uint::from_str(args[1]).get();\n-    let workers = uint::from_str(args[2]).get();\n+    let size = uint::from_str(args[1]).unwrap();\n+    let workers = uint::from_str(args[2]).unwrap();\n     let num_bytes = 100;\n     let start = extra::time::precise_time_s();\n     let mut worker_results = ~[];"}, {"sha": "470e23d63a514ff81f8bbd419c4b32fab03ff927", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -53,8 +53,8 @@ fn run(args: &[~str]) {\n     let (from_parent, to_child) = stream();\n     let to_child = SharedChan::new(to_child);\n \n-    let size = uint::from_str(args[1]).get();\n-    let workers = uint::from_str(args[2]).get();\n+    let size = uint::from_str(args[1]).unwrap();\n+    let workers = uint::from_str(args[2]).unwrap();\n     let num_bytes = 100;\n     let start = extra::time::precise_time_s();\n     let mut worker_results = ~[];"}, {"sha": "7de95f4d822c54613a3f72064c3efb9b0778d02e", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -79,8 +79,8 @@ fn main() {\n         args.clone()\n     };\n \n-    let num_tasks = uint::from_str(args[1]).get();\n-    let msg_per_task = uint::from_str(args[2]).get();\n+    let num_tasks = uint::from_str(args[1]).unwrap();\n+    let msg_per_task = uint::from_str(args[2]).unwrap();\n \n     let (num_chan, num_port) = init();\n     let num_chan = Cell::new(num_chan);"}, {"sha": "1299e863db6b3f923274740bc443b65f5b802862", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -75,8 +75,8 @@ fn main() {\n         args.clone()\n     };\n \n-    let num_tasks = uint::from_str(args[1]).get();\n-    let msg_per_task = uint::from_str(args[2]).get();\n+    let num_tasks = uint::from_str(args[1]).unwrap();\n+    let msg_per_task = uint::from_str(args[2]).unwrap();\n \n     let (num_chan, num_port) = init();\n     let num_chan = Cell::new(num_chan);"}, {"sha": "e8659ba26d4bc878bd686b5f873ba7365bfe4bc8", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -35,6 +35,6 @@ fn main() {\n     } else {\n         args\n     };\n-    let n = int::from_str(args[1]).get();\n+    let n = int::from_str(args[1]).unwrap();\n     printfln!(\"Ack(3,%d): %d\\n\", n, ack(3, n));\n }"}, {"sha": "8a2ae3e89952007903431e6484d1e70af1d7c366", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -48,7 +48,7 @@ fn main() {\n         args\n     };\n \n-    let n = int::from_str(args[1]).get();\n+    let n = int::from_str(args[1]).unwrap();\n     let min_depth = 4;\n     let mut max_depth;\n     if min_depth + 2 > n {"}, {"sha": "190ad62d6e17ff771ecb81900a8cdd2767479a3b", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -212,7 +212,7 @@ fn main() {\n         args\n     };\n \n-    let nn = uint::from_str(args[1]).get();\n+    let nn = uint::from_str(args[1]).unwrap();\n \n     print_complements();\n     io::println(\"\");"}, {"sha": "9d4d31b8969205a3b0b7a911dd9648897c3d8214", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -91,6 +91,6 @@ fn fannkuch_redux(n: i32) -> i32 {\n \n #[fixed_stack_segment]\n fn main() {\n-    let n: i32 = FromStr::from_str(os::args()[1]).get();\n+    let n: i32 = FromStr::from_str(os::args()[1]).unwrap();\n     printfln!(\"Pfannkuchen(%d) = %d\", n as int, fannkuch_redux(n) as int);\n }"}, {"sha": "579b88a7e0e72c0231fb22f17a8c7a407cbfb83b", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -184,7 +184,7 @@ impl RandomFasta {\n \n #[fixed_stack_segment]\n fn main() {\n-    let n: uint = FromStr::from_str(os::args()[1]).get();\n+    let n: uint = FromStr::from_str(os::args()[1]).unwrap();\n \n     unsafe {\n         let mode = \"w\";"}, {"sha": "4e2ab8b0a498dce2b444fad63f81717b4015dd48", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -130,7 +130,7 @@ fn main() {\n         io::stdout()\n     };\n \n-    let n = int::from_str(args[1]).get();\n+    let n = int::from_str(args[1]).unwrap();\n \n     let iub: ~[AminoAcids] =\n         make_cumulative(~[acid('a', 27u32), acid('c', 12u32), acid('g', 12u32),"}, {"sha": "9c07df36eb3c1be3bf84a94a2f34dc11dd416bd4", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -31,6 +31,6 @@ fn main() {\n     } else {\n         args\n     };\n-    let n = int::from_str(args[1]).get();\n+    let n = int::from_str(args[1]).unwrap();\n     printfln!(\"%d\\n\", fib(n));\n }"}, {"sha": "cf43f470e7177d55e2fcf77b0c57061fc03d02a7", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -9,7 +9,7 @@ static LIMIT: f64 = 2.0;\n #[fixed_stack_segment]\n fn main() {\n     unsafe {\n-        let w: i32 = FromStr::from_str(os::args()[1]).get();\n+        let w: i32 = FromStr::from_str(os::args()[1]).unwrap();\n         let h = w;\n         let mut byte_acc: i8 = 0;\n         let mut bit_num: i32 = 0;"}, {"sha": "115607d0a992c14896d3d227799dee2dbc611bbf", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -137,7 +137,7 @@ fn offset_momentum(bodies: &mut [Planet, ..N_BODIES]) {\n }\n \n fn main() {\n-    let n: i32 = FromStr::from_str(os::args()[1]).get();\n+    let n: i32 = FromStr::from_str(os::args()[1]).unwrap();\n     let mut bodies = BODIES;\n \n     offset_momentum(&mut bodies);"}, {"sha": "611b11560e4ae8b0e8970b3d5a16bf73d66f9366", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -110,7 +110,7 @@ fn main() {\n     if opts.stress {\n         stress(2);\n     } else {\n-        let max = uint::parse_bytes(args[1].as_bytes(), 10u).get() as int;\n+        let max = uint::parse_bytes(args[1].as_bytes(), 10u).unwrap() as int;\n \n         let num_trials = 10;\n "}, {"sha": "aef22bc2b8426f056a4047abb81092e288f9ece6", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -52,7 +52,7 @@ fn mult_AtAv(v: &mut [f64], out: &mut [f64], tmp: &mut [f64]) {\n \n #[fixed_stack_segment]\n fn main() {\n-    let n: uint = FromStr::from_str(os::args()[1]).get();\n+    let n: uint = FromStr::from_str(os::args()[1]).unwrap();\n     let mut u = vec::from_elem(n, 1f64);\n     let mut v = u.clone();\n     let mut tmp = u.clone();"}, {"sha": "ace008c1f95d2164febe6451d5d3e3d98c6f5cd5", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -62,13 +62,13 @@ fn main() {\n         os::args()\n     };\n     let token = if args.len() > 1u {\n-        FromStr::from_str(args[1]).get()\n+        FromStr::from_str(args[1]).unwrap()\n     }\n     else {\n         1000\n     };\n     let n_tasks = if args.len() > 2u {\n-        FromStr::from_str(args[2]).get()\n+        FromStr::from_str(args[2]).unwrap()\n     }\n     else {\n         503"}, {"sha": "a035041a662dc73097c6a8bbd28430a6f99cc43a", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -39,8 +39,8 @@ fn main() {\n     } else {\n         args\n     };\n-    let max = uint::from_str(args[1]).get();\n-    let rep = uint::from_str(args[2]).get();\n+    let max = uint::from_str(args[1]).unwrap();\n+    let rep = uint::from_str(args[2]).unwrap();\n \n     let mut checkf = 0.0;\n     let mut appendf = 0.0;"}, {"sha": "675735408953403b49d6fd622a2cd906c0cd7eaa", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -75,9 +75,9 @@ impl Sudoku {\n             let comps: ~[&str] = line.trim().split_iter(',').collect();\n \n             if comps.len() == 3u {\n-                let row     = uint::from_str(comps[0]).get() as u8;\n-                let col     = uint::from_str(comps[1]).get() as u8;\n-                g[row][col] = uint::from_str(comps[2]).get() as u8;\n+                let row     = uint::from_str(comps[0]).unwrap() as u8;\n+                let col     = uint::from_str(comps[1]).unwrap() as u8;\n+                g[row][col] = uint::from_str(comps[2]).unwrap() as u8;\n             }\n             else {\n                 fail!(\"Invalid sudoku file\");"}, {"sha": "be7f9b5f43adfc22b75ad98e0e513408d9e3fb6e", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -52,7 +52,7 @@ fn main() {\n     };\n \n     let (p,c) = comm::stream();\n-    child_generation(uint::from_str(args[1]).get(), c);\n+    child_generation(uint::from_str(args[1]).unwrap(), c);\n     if p.try_recv().is_none() {\n         fail!(\"it happened when we slumbered\");\n     }"}, {"sha": "95dd803af8183221f00bbc21ee6a2c56bbabd3e9", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -71,7 +71,7 @@ fn main() {\n         args.clone()\n     };\n \n-    let num_tasks = uint::from_str(args[1]).get();\n+    let num_tasks = uint::from_str(args[1]).unwrap();\n \n     // Main group #0 waits for unsupervised group #1.\n     // Grandparent group #1 waits for middle group #2, then fails, killing #3."}, {"sha": "83116ae3c87deb07df1902da9201edb1ef55ea5e", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -31,7 +31,7 @@ fn main() {\n     } else {\n         args\n     };\n-    let n = uint::from_str(args[1]).get();\n+    let n = uint::from_str(args[1]).unwrap();\n     let mut i = 0u;\n     while i < n { task::spawn(|| f(n) ); i += 1u; }\n }"}, {"sha": "cb6290686816d74054a3e9923c9f4a862d628bd7", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -17,7 +17,7 @@ fn main() {\n         y = Some(x.downgrade(write_mode));\n         //~^ ERROR cannot infer an appropriate lifetime\n     }\n-    y.get();\n+    y.unwrap();\n     // Adding this line causes a method unification failure instead\n     // do (&option::unwrap(y)).read |state| { assert!(*state == 1); }\n }"}, {"sha": "75e1989aff01a5ad7faf55da8087bf89bda910cb", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     do x.write_downgrade |write_mode| {\n         y = Some(write_mode);\n     }\n-    y.get();\n+    y.unwrap();\n     // Adding this line causes a method unification failure instead\n     // do (&option::unwrap(y)).write |state| { assert!(*state == 1); }\n }"}, {"sha": "4f552bc8f4216468a8929cb78c44300bb225dcf4", "filename": "src/test/run-fail/result-get-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:get called on `Err` result: ~\"kitty\"\n+// error-pattern:called `Result::unwrap()` on `Err` value: kitty\n \n use std::result;\n \n fn main() {\n-  error!(result::Err::<int,~str>(~\"kitty\").get());\n+    error!(result::Err::<int,~str>(~\"kitty\").unwrap());\n }"}, {"sha": "668f602b3d35c941770d07d920c29f7c04bdab7a", "filename": "src/test/run-pass/borrowck-wg-borrow-mut-to-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-borrow-mut-to-imm.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -1,5 +1,5 @@\n fn g(x: &Option<int>) {\n-    println(x.get().to_str());\n+    println(x.unwrap().to_str());\n }\n \n fn f(x: &mut Option<int>) {"}, {"sha": "9f17b9d7f95b5811ed82a74dd3cae7b2ac877317", "filename": "src/test/run-pass/borrowed-ptr-pattern-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern-option.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -19,5 +19,5 @@ fn select<'r>(x: &'r Option<int>, y: &'r Option<int>) -> &'r Option<int> {\n pub fn main() {\n     let x = None;\n     let y = Some(3);\n-    assert_eq!(select(&x, &y).get(), 3);\n+    assert_eq!(select(&x, &y).unwrap(), 3);\n }"}, {"sha": "8af173150a06dceee7c93cddfbf1485c2ce9964d", "filename": "src/test/run-pass/option_addition.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Frun-pass%2Foption_addition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Frun-pass%2Foption_addition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption_addition.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -9,29 +9,17 @@\n // except according to those terms.\n \n pub fn main() {\n-    let foo = 1;\n-    let bar = 2;\n+    let foo: int = 1;\n+    let bar: int = 2;\n     let foobar = foo + bar;\n \n-    let nope = optint(0) + optint(0);\n-    let somefoo = optint(foo) + optint(0);\n-    let somebar = optint(bar) + optint(0);\n-    let somefoobar = optint(foo) + optint(bar);\n+    let nope = None::<int> + None::<int>;\n+    let somefoo = Some(foo) + None::<int>;\n+    let somebar = None::<int> + Some(bar);\n+    let somefoobar = Some(foo) + Some(bar);\n \n-    match nope {\n-        None => (),\n-        Some(foo) => fail!(\"expected None, but found %?\", foo)\n-    }\n-    assert_eq!(foo, somefoo.get());\n-    assert_eq!(bar, somebar.get());\n-    assert_eq!(foobar, somefoobar.get());\n-}\n-\n-fn optint(input: int) -> Option<int> {\n-    if input == 0 {\n-        return None;\n-    }\n-    else {\n-        return Some(input);\n-    }\n+    assert_eq!(nope, None::<int>);\n+    assert_eq!(somefoo, None::<int>);\n+    assert_eq!(somebar, None::<int>);\n+    assert_eq!(foobar, somefoobar.unwrap());\n }"}, {"sha": "f5eb04dd83bfe3774c0466e33fd2820fdb9aac53", "filename": "src/test/run-pass/region-dependent-addr-of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs?ref=0ac7a219f043d3b1c8c239089d9dd6e6c9fa830b", "patch": "@@ -105,13 +105,13 @@ pub fn main() {\n     assert_eq!(*p, a.value.v5.f);\n \n     let p = get_v6_a(&a, 1);\n-    assert_eq!(*p, a.value.v6.get().f);\n+    assert_eq!(*p, a.value.v6.unwrap().f);\n \n     let p = get_v6_b(&a, 1);\n-    assert_eq!(*p, a.value.v6.get().f);\n+    assert_eq!(*p, a.value.v6.unwrap().f);\n \n     let p = get_v6_c(&a, 1);\n-    assert_eq!(*p, a.value.v6.get().f);\n+    assert_eq!(*p, a.value.v6.unwrap().f);\n \n     let p = get_v5_ref(&a, 1);\n     assert_eq!(*p, a.value.v5.f);"}]}