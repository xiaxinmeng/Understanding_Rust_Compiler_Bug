{"sha": "1b1b538843503568994c7ef37ea8206f0ee3c2e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMWI1Mzg4NDM1MDM1Njg5OTRjN2VmMzdlYTgyMDZmMGVlM2MyZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-12T04:56:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-12T04:56:05Z"}, "message": "Auto merge of #61590 - matthewjasper:remove-borrowck-mir-dependency, r=pnkfelix\n\nRemove rustc_mir dependency from rustc_borrowck\n\nAlso renames `rustc_borrowck` to `rustc_ast_borrowck` and removes all error reporting from it.\n\ncc #59193", "tree": {"sha": "a98e579c7606da78c246f73e22249db2cf614d58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a98e579c7606da78c246f73e22249db2cf614d58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b1b538843503568994c7ef37ea8206f0ee3c2e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b1b538843503568994c7ef37ea8206f0ee3c2e4", "html_url": "https://github.com/rust-lang/rust/commit/1b1b538843503568994c7ef37ea8206f0ee3c2e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b1b538843503568994c7ef37ea8206f0ee3c2e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e31911ef8f1f46b7fab6e4f350679822ac7d7f6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e31911ef8f1f46b7fab6e4f350679822ac7d7f6a", "html_url": "https://github.com/rust-lang/rust/commit/e31911ef8f1f46b7fab6e4f350679822ac7d7f6a"}, {"sha": "34ddc70c3f4a013f22273d9497631186b26f07b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/34ddc70c3f4a013f22273d9497631186b26f07b2", "html_url": "https://github.com/rust-lang/rust/commit/34ddc70c3f4a013f22273d9497631186b26f07b2"}], "stats": {"total": 3485, "additions": 834, "deletions": 2651}, "files": [{"sha": "cee2b385648d11d7f08e49fedf23dd6434ecd2b9", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -2946,15 +2946,14 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"rustc_borrowck\"\n+name = \"rustc_ast_borrowck\"\n version = \"0.0.0\"\n dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n- \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -3045,7 +3044,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n- \"rustc_borrowck 0.0.0\",\n+ \"rustc_ast_borrowck 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n@@ -3110,7 +3109,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n- \"rustc_borrowck 0.0.0\",\n+ \"rustc_ast_borrowck 0.0.0\",\n  \"rustc_codegen_ssa 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\","}, {"sha": "60c24eeae7b6459cd4fdb64ecb8f63b8504ec08a", "filename": "src/librustc/middle/borrowck.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -1,6 +1,4 @@\n use crate::ich::StableHashingContext;\n-use crate::hir::HirId;\n-use crate::util::nodemap::FxHashSet;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n@@ -18,7 +16,6 @@ impl_stable_hash_for!(enum self::SignalledError { SawSomeError, NoErrorsSeen });\n \n #[derive(Debug, Default, RustcEncodable, RustcDecodable)]\n pub struct BorrowCheckResult {\n-    pub used_mut_nodes: FxHashSet<HirId>,\n     pub signalled_any_error: SignalledError,\n }\n \n@@ -27,10 +24,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for BorrowCheckResult {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let BorrowCheckResult {\n-            ref used_mut_nodes,\n             ref signalled_any_error,\n         } = *self;\n-        used_mut_nodes.hash_stable(hcx, hasher);\n         signalled_any_error.hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "ddad276f8a7c832b252d94aaf9ae042b42b476f3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -66,7 +66,6 @@ use crate::hir::def::{CtorOf, Res, DefKind, CtorKind};\n use crate::ty::adjustment;\n use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n use crate::ty::fold::TypeFoldable;\n-use crate::ty::layout::VariantIdx;\n \n use crate::hir::{MutImmutable, MutMutable, PatKind};\n use crate::hir::pat_util::EnumerateAndAdjustIterator;\n@@ -79,7 +78,6 @@ use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use rustc_data_structures::fx::FxIndexMap;\n-use rustc_data_structures::indexed_vec::Idx;\n use std::rc::Rc;\n use crate::util::nodemap::ItemLocalSet;\n \n@@ -198,79 +196,6 @@ pub struct cmt_<'tcx> {\n \n pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n-pub enum ImmutabilityBlame<'tcx> {\n-    ImmLocal(hir::HirId),\n-    ClosureEnv(LocalDefId),\n-    LocalDeref(hir::HirId),\n-    AdtFieldDeref(&'tcx ty::AdtDef, &'tcx ty::FieldDef)\n-}\n-\n-impl<'tcx> cmt_<'tcx> {\n-    fn resolve_field(&self, field_index: usize) -> Option<(&'tcx ty::AdtDef, &'tcx ty::FieldDef)>\n-    {\n-        let adt_def = match self.ty.sty {\n-            ty::Adt(def, _) => def,\n-            ty::Tuple(..) => return None,\n-            // closures get `Categorization::Upvar` rather than `Categorization::Interior`\n-            _ =>  bug!(\"interior cmt {:?} is not an ADT\", self)\n-        };\n-        let variant_def = match self.cat {\n-            Categorization::Downcast(_, variant_did) => {\n-                adt_def.variant_with_id(variant_did)\n-            }\n-            _ => {\n-                assert_eq!(adt_def.variants.len(), 1);\n-                &adt_def.variants[VariantIdx::new(0)]\n-            }\n-        };\n-        Some((adt_def, &variant_def.fields[field_index]))\n-    }\n-\n-    pub fn immutability_blame(&self) -> Option<ImmutabilityBlame<'tcx>> {\n-        match self.cat {\n-            Categorization::Deref(ref base_cmt, BorrowedPtr(ty::ImmBorrow, _)) => {\n-                // try to figure out where the immutable reference came from\n-                match base_cmt.cat {\n-                    Categorization::Local(hir_id) =>\n-                        Some(ImmutabilityBlame::LocalDeref(hir_id)),\n-                    Categorization::Interior(ref base_cmt, InteriorField(field_index)) => {\n-                        base_cmt.resolve_field(field_index.0).map(|(adt_def, field_def)| {\n-                            ImmutabilityBlame::AdtFieldDeref(adt_def, field_def)\n-                        })\n-                    }\n-                    Categorization::Upvar(Upvar { id, .. }) => {\n-                        if let NoteClosureEnv(..) = self.note {\n-                            Some(ImmutabilityBlame::ClosureEnv(id.closure_expr_id))\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                    _ => None\n-                }\n-            }\n-            Categorization::Local(hir_id) => {\n-                Some(ImmutabilityBlame::ImmLocal(hir_id))\n-            }\n-            Categorization::Rvalue(..) |\n-            Categorization::Upvar(..) |\n-            Categorization::Deref(_, UnsafePtr(..)) => {\n-                // This should not be reachable up to inference limitations.\n-                None\n-            }\n-            Categorization::Interior(ref base_cmt, _) |\n-            Categorization::Downcast(ref base_cmt, _) |\n-            Categorization::Deref(ref base_cmt, _) => {\n-                base_cmt.immutability_blame()\n-            }\n-            Categorization::ThreadLocal(..) |\n-            Categorization::StaticItem => {\n-                // Do we want to do something here?\n-                None\n-            }\n-        }\n-    }\n-}\n-\n pub trait HirNode {\n     fn hir_id(&self) -> hir::HirId;\n     fn span(&self) -> Span;"}, {"sha": "024b2640e1e8ea0d6fc22cccacf9290737bee75b", "filename": "src/librustc_ast_borrowck/Cargo.toml", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2FCargo.toml?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -1,11 +1,11 @@\n [package]\n authors = [\"The Rust Project Developers\"]\n-name = \"rustc_borrowck\"\n+name = \"rustc_ast_borrowck\"\n version = \"0.0.0\"\n edition = \"2018\"\n \n [lib]\n-name = \"rustc_borrowck\"\n+name = \"rustc_ast_borrowck\"\n path = \"lib.rs\"\n test = false\n doctest = false\n@@ -18,6 +18,5 @@ syntax_pos = { path = \"../libsyntax_pos\" }\n # refers to the borrowck-specific graphviz adapter traits.\n dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n rustc = { path = \"../librustc\" }\n-rustc_mir = { path = \"../librustc_mir\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }", "previous_filename": "src/librustc_borrowck/Cargo.toml"}, {"sha": "6c47e8784e025c755adef37cce0c6d3ce25b1911", "filename": "src/librustc_ast_borrowck/borrowck/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2FREADME.md?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "previous_filename": "src/librustc_borrowck/borrowck/README.md"}, {"sha": "3d824ee6ce1e8170ba2df00b91c9b26ac887fbc3", "filename": "src/librustc_ast_borrowck/borrowck/check_loans.rs", "status": "renamed", "additions": 66, "deletions": 304, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -7,8 +7,6 @@\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n \n-use UseError::*;\n-\n use crate::borrowck::*;\n use crate::borrowck::InteriorKind::{InteriorElement, InteriorField};\n use rustc::middle::expr_use_visitor as euv;\n@@ -20,7 +18,6 @@ use rustc::ty::{self, TyCtxt, RegionKind};\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::Node;\n-use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n use log::debug;\n \n use std::rc::Rc;\n@@ -89,13 +86,12 @@ struct CheckLoanCtxt<'a, 'tcx> {\n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: hir::HirId,\n-               consume_span: Span,\n+               _: Span,\n                cmt: &mc::cmt_<'tcx>,\n                mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n-               consume_id, cmt, mode);\n+        debug!(\"consume(consume_id={}, cmt={:?})\", consume_id, cmt);\n \n-        self.consume_common(consume_id.local_id, consume_span, cmt, mode);\n+        self.consume_common(consume_id.local_id, cmt, mode);\n     }\n \n     fn matched_pat(&mut self,\n@@ -107,12 +103,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                    consume_pat: &hir::Pat,\n                    cmt: &mc::cmt_<'tcx>,\n                    mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n-               consume_pat,\n-               cmt,\n-               mode);\n+        debug!(\"consume_pat(consume_pat={:?}, cmt={:?})\", consume_pat, cmt);\n \n-        self.consume_common(consume_pat.hir_id.local_id, consume_pat.span, cmt, mode);\n+        self.consume_common(consume_pat.hir_id.local_id, cmt, mode);\n     }\n \n     fn borrow(&mut self,\n@@ -129,11 +122,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                bk, loan_cause);\n \n         if let Some(lp) = opt_loan_path(cmt) {\n-            let moved_value_use_kind = match loan_cause {\n-                euv::ClosureCapture(_) => MovedInCapture,\n-                _ => MovedInUse,\n-            };\n-            self.check_if_path_is_moved(borrow_id.local_id, borrow_span, moved_value_use_kind, &lp);\n+            self.check_if_path_is_moved(borrow_id.local_id, &lp);\n         }\n \n         self.check_for_conflicting_loans(borrow_id.local_id);\n@@ -143,7 +132,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n \n     fn mutate(&mut self,\n               assignment_id: hir::HirId,\n-              assignment_span: Span,\n+              _: Span,\n               assignee_cmt: &mc::cmt_<'tcx>,\n               mode: euv::MutateMode)\n     {\n@@ -157,23 +146,18 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                     // have to be *FULLY* initialized, but we still\n                     // must be careful lest it contains derefs of\n                     // pointers.\n-                    self.check_if_assigned_path_is_moved(assignee_cmt.hir_id.local_id,\n-                                                         assignment_span,\n-                                                         MovedInUse,\n-                                                         &lp);\n+                    self.check_if_assigned_path_is_moved(assignee_cmt.hir_id.local_id, &lp);\n                 }\n                 MutateMode::WriteAndRead => {\n                     // In a case like `path += 1`, then path must be\n                     // fully initialized, since we will read it before\n                     // we write it.\n                     self.check_if_path_is_moved(assignee_cmt.hir_id.local_id,\n-                                                assignment_span,\n-                                                MovedInUse,\n                                                 &lp);\n                 }\n             }\n         }\n-        self.check_assignment(assignment_id.local_id, assignment_span, assignee_cmt);\n+        self.check_assignment(assignment_id.local_id, assignee_cmt);\n     }\n \n     fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) { }\n@@ -218,12 +202,6 @@ pub fn check_loans<'a, 'tcx>(\n         .consume_body(body);\n }\n \n-#[derive(PartialEq)]\n-enum UseError<'tcx> {\n-    UseOk,\n-    UseWhileBorrowed(/*loan*/Rc<LoanPath<'tcx>>, /*loan*/Span)\n-}\n-\n fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n                            borrow_kind2: ty::BorrowKind)\n                            -> bool {\n@@ -433,15 +411,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        if let Some(yield_span) = self.bccx\n-                                      .region_scope_tree\n-                                      .yield_in_scope_for_expr(scope,\n-                                                               cmt.hir_id,\n-                                                               self.bccx.body)\n+        if let Some(_) = self.bccx.region_scope_tree\n+            .yield_in_scope_for_expr(scope, cmt.hir_id, self.bccx.body)\n         {\n-            self.bccx.cannot_borrow_across_generator_yield(borrow_span,\n-                                                           yield_span,\n-                                                           Origin::Ast).emit();\n             self.bccx.signal_error();\n         }\n     }\n@@ -478,10 +450,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn report_error_if_loans_conflict(&self,\n-                                          old_loan: &Loan<'tcx>,\n-                                          new_loan: &Loan<'tcx>)\n-                                          -> bool {\n+    pub fn report_error_if_loans_conflict(\n+        &self,\n+        old_loan: &Loan<'tcx>,\n+        new_loan: &Loan<'tcx>,\n+    ) -> bool {\n         //! Checks whether `old_loan` and `new_loan` can safely be issued\n         //! simultaneously.\n \n@@ -493,305 +466,116 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         assert!(self.bccx.region_scope_tree.scopes_intersect(old_loan.kill_scope,\n                                                        new_loan.kill_scope));\n \n-        let err_old_new = self.report_error_if_loan_conflicts_with_restriction(\n-            old_loan, new_loan, old_loan, new_loan).err();\n-        let err_new_old = self.report_error_if_loan_conflicts_with_restriction(\n-            new_loan, old_loan, old_loan, new_loan).err();\n-\n-        match (err_old_new, err_new_old) {\n-            (Some(mut err), None) | (None, Some(mut err)) => {\n-                err.emit();\n-                self.bccx.signal_error();\n-            }\n-            (Some(mut err_old), Some(mut err_new)) => {\n-                err_old.emit();\n-                self.bccx.signal_error();\n-                err_new.cancel();\n-            }\n-            (None, None) => return true,\n-        }\n-\n-        false\n+        self.report_error_if_loan_conflicts_with_restriction(\n+            old_loan, new_loan)\n+        && self.report_error_if_loan_conflicts_with_restriction(\n+                new_loan, old_loan)\n     }\n \n-    pub fn report_error_if_loan_conflicts_with_restriction(&self,\n-                                                           loan1: &Loan<'tcx>,\n-                                                           loan2: &Loan<'tcx>,\n-                                                           old_loan: &Loan<'tcx>,\n-                                                           new_loan: &Loan<'tcx>)\n-                                                           -> Result<(), DiagnosticBuilder<'a>> {\n+    pub fn report_error_if_loan_conflicts_with_restriction(\n+        &self,\n+        loan1: &Loan<'tcx>,\n+        loan2: &Loan<'tcx>,\n+    ) -> bool {\n         //! Checks whether the restrictions introduced by `loan1` would\n-        //! prohibit `loan2`. Returns false if an error is reported.\n-\n+        //! prohibit `loan2`.\n         debug!(\"report_error_if_loan_conflicts_with_restriction(\\\n                 loan1={:?}, loan2={:?})\",\n                loan1,\n                loan2);\n \n         if compatible_borrow_kinds(loan1.kind, loan2.kind) {\n-            return Ok(());\n+            return true;\n         }\n \n         let loan2_base_path = owned_ptr_base_path_rc(&loan2.loan_path);\n         for restr_path in &loan1.restricted_paths {\n             if *restr_path != loan2_base_path { continue; }\n \n-            // If new_loan is something like `x.a`, and old_loan is something like `x.b`, we would\n-            // normally generate a rather confusing message (in this case, for multiple mutable\n-            // borrows):\n-            //\n-            //     error: cannot borrow `x.b` as mutable more than once at a time\n-            //     note: previous borrow of `x.a` occurs here; the mutable borrow prevents\n-            //     subsequent moves, borrows, or modification of `x.a` until the borrow ends\n-            //\n-            // What we want to do instead is get the 'common ancestor' of the two borrow paths and\n-            // use that for most of the message instead, giving is something like this:\n-            //\n-            //     error: cannot borrow `x` as mutable more than once at a time\n-            //     note: previous borrow of `x` occurs here (through borrowing `x.a`); the mutable\n-            //     borrow prevents subsequent moves, borrows, or modification of `x` until the\n-            //     borrow ends\n-\n-            let common = new_loan.loan_path.common(&old_loan.loan_path);\n-            let (nl, ol, new_loan_msg, old_loan_msg) = {\n-                if new_loan.loan_path.has_fork(&old_loan.loan_path) && common.is_some() {\n-                    let nl = self.bccx.loan_path_to_string(&common.unwrap());\n-                    let ol = nl.clone();\n-                    let new_loan_msg = self.bccx.loan_path_to_string(&new_loan.loan_path);\n-                    let old_loan_msg = self.bccx.loan_path_to_string(&old_loan.loan_path);\n-                    (nl, ol, new_loan_msg, old_loan_msg)\n-                } else {\n-                    (self.bccx.loan_path_to_string(&new_loan.loan_path),\n-                     self.bccx.loan_path_to_string(&old_loan.loan_path),\n-                     String::new(),\n-                     String::new())\n-                }\n-            };\n-\n-            let ol_pronoun = if new_loan.loan_path == old_loan.loan_path {\n-                \"it\".to_string()\n-            } else {\n-                format!(\"`{}`\", ol)\n-            };\n-\n-            // We want to assemble all the relevant locations for the error.\n-            //\n-            // 1. Where did the new loan occur.\n-            //    - if due to closure creation, where was the variable used in closure?\n-            // 2. Where did old loan occur.\n-            // 3. Where does old loan expire.\n-\n-            let previous_end_span =\n-                Some(self.tcx().sess.source_map().end_point(\n-                        old_loan.kill_scope.span(self.tcx(), &self.bccx.region_scope_tree)));\n-\n-            let mut err = match (new_loan.kind, old_loan.kind) {\n-                (ty::MutBorrow, ty::MutBorrow) =>\n-                    self.bccx.cannot_mutably_borrow_multiply(\n-                        new_loan.span, &nl, &new_loan_msg, old_loan.span, &old_loan_msg,\n-                        previous_end_span, Origin::Ast),\n-                (ty::UniqueImmBorrow, ty::UniqueImmBorrow) =>\n-                    self.bccx.cannot_uniquely_borrow_by_two_closures(\n-                        new_loan.span, &nl, old_loan.span, previous_end_span, Origin::Ast),\n-                (ty::UniqueImmBorrow, _) =>\n-                    self.bccx.cannot_uniquely_borrow_by_one_closure(\n-                        new_loan.span, \"closure\", &nl, &new_loan_msg,\n-                        old_loan.span, &ol_pronoun, &old_loan_msg, previous_end_span, Origin::Ast),\n-                (_, ty::UniqueImmBorrow) => {\n-                    let new_loan_str = &new_loan.kind.to_user_str();\n-                    self.bccx.cannot_reborrow_already_uniquely_borrowed(\n-                        new_loan.span, \"closure\", &nl, &new_loan_msg, new_loan_str,\n-                        old_loan.span, &old_loan_msg, previous_end_span, \"\", Origin::Ast)\n-                }\n-                (..) =>\n-                    self.bccx.cannot_reborrow_already_borrowed(\n-                        new_loan.span,\n-                        &nl, &new_loan_msg, &new_loan.kind.to_user_str(),\n-                        old_loan.span, &ol_pronoun, &old_loan.kind.to_user_str(), &old_loan_msg,\n-                        previous_end_span, Origin::Ast)\n-            };\n-\n-            match new_loan.cause {\n-                euv::ClosureCapture(span) => {\n-                    err.span_label(\n-                        span,\n-                        format!(\"borrow occurs due to use of `{}` in closure\", nl));\n-                }\n-                _ => { }\n-            }\n-\n-            match old_loan.cause {\n-                euv::ClosureCapture(span) => {\n-                    err.span_label(\n-                        span,\n-                        format!(\"previous borrow occurs due to use of `{}` in closure\",\n-                                 ol));\n-                }\n-                _ => { }\n-            }\n-\n-            return Err(err);\n+            self.bccx.signal_error();\n+            return false;\n         }\n \n-        Ok(())\n+        true\n     }\n \n-    fn consume_common(&self,\n-                      id: hir::ItemLocalId,\n-                      span: Span,\n-                      cmt: &mc::cmt_<'tcx>,\n-                      mode: euv::ConsumeMode) {\n+    fn consume_common(\n+        &self,\n+        id: hir::ItemLocalId,\n+        cmt: &mc::cmt_<'tcx>,\n+        mode: euv::ConsumeMode,\n+    ) {\n         if let Some(lp) = opt_loan_path(cmt) {\n-            let moved_value_use_kind = match mode {\n+            match mode {\n                 euv::Copy => {\n-                    self.check_for_copy_of_frozen_path(id, span, &lp);\n-                    MovedInUse\n+                    self.check_for_copy_of_frozen_path(id, &lp);\n                 }\n                 euv::Move(_) => {\n-                    match self.move_data.kind_of_move_of_path(id, &lp) {\n-                        None => {\n-                            // Sometimes moves don't have a move kind;\n-                            // this either means that the original move\n-                            // was from something illegal to move,\n-                            // or was moved from referent of an unsafe\n-                            // pointer or something like that.\n-                            MovedInUse\n-                        }\n-                        Some(move_kind) => {\n-                            self.check_for_move_of_borrowed_path(id, span,\n-                                                                 &lp, move_kind);\n-                            if move_kind == move_data::Captured {\n-                                MovedInCapture\n-                            } else {\n-                                MovedInUse\n-                            }\n-                        }\n+                    // Sometimes moves aren't from a move path;\n+                    // this either means that the original move\n+                    // was from something illegal to move,\n+                    // or was moved from referent of an unsafe\n+                    // pointer or something like that.\n+                    if self.move_data.is_move_path(id, &lp) {\n+                        self.check_for_move_of_borrowed_path(id, &lp);\n                     }\n                 }\n-            };\n-\n-            self.check_if_path_is_moved(id, span, moved_value_use_kind, &lp);\n+            }\n+            self.check_if_path_is_moved(id, &lp);\n         }\n     }\n \n     fn check_for_copy_of_frozen_path(&self,\n                                      id: hir::ItemLocalId,\n-                                     span: Span,\n                                      copy_path: &LoanPath<'tcx>) {\n-        match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n-            UseOk => { }\n-            UseWhileBorrowed(loan_path, loan_span) => {\n-                let desc = self.bccx.loan_path_to_string(copy_path);\n-                self.bccx.cannot_use_when_mutably_borrowed(\n-                        span, &desc,\n-                        loan_span, &self.bccx.loan_path_to_string(&loan_path),\n-                        Origin::Ast)\n-                    .emit();\n-                self.bccx.signal_error();\n-            }\n-        }\n+        self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow);\n     }\n \n     fn check_for_move_of_borrowed_path(&self,\n                                        id: hir::ItemLocalId,\n-                                       span: Span,\n-                                       move_path: &LoanPath<'tcx>,\n-                                       move_kind: move_data::MoveKind) {\n+                                       move_path: &LoanPath<'tcx>) {\n         // We want to detect if there are any loans at all, so we search for\n         // any loans incompatible with MutBorrrow, since all other kinds of\n         // loans are incompatible with that.\n-        match self.analyze_restrictions_on_use(id, move_path, ty::MutBorrow) {\n-            UseOk => { }\n-            UseWhileBorrowed(loan_path, loan_span) => {\n-                let mut err = match move_kind {\n-                    move_data::Captured => {\n-                        let mut err = self.bccx.cannot_move_into_closure(\n-                            span, &self.bccx.loan_path_to_string(move_path), Origin::Ast);\n-                        err.span_label(\n-                            loan_span,\n-                            format!(\"borrow of `{}` occurs here\",\n-                                    &self.bccx.loan_path_to_string(&loan_path))\n-                            );\n-                        err.span_label(\n-                            span,\n-                            \"move into closure occurs here\"\n-                            );\n-                        err\n-                    }\n-                    move_data::Declared |\n-                    move_data::MoveExpr |\n-                    move_data::MovePat => {\n-                        let desc = self.bccx.loan_path_to_string(move_path);\n-                        let mut err = self.bccx.cannot_move_when_borrowed(span, &desc, Origin::Ast);\n-                        err.span_label(\n-                            loan_span,\n-                            format!(\"borrow of `{}` occurs here\",\n-                                    &self.bccx.loan_path_to_string(&loan_path))\n-                            );\n-                        err.span_label(\n-                            span,\n-                            format!(\"move out of `{}` occurs here\",\n-                                &self.bccx.loan_path_to_string(move_path))\n-                            );\n-                        err\n-                    }\n-                };\n-\n-                err.emit();\n-                self.bccx.signal_error();\n-            }\n-        }\n+        self.analyze_restrictions_on_use(id, move_path, ty::MutBorrow);\n     }\n \n-    pub fn analyze_restrictions_on_use(&self,\n+    fn analyze_restrictions_on_use(&self,\n                                        expr_id: hir::ItemLocalId,\n                                        use_path: &LoanPath<'tcx>,\n-                                       borrow_kind: ty::BorrowKind)\n-                                       -> UseError<'tcx> {\n+                                       borrow_kind: ty::BorrowKind) {\n         debug!(\"analyze_restrictions_on_use(expr_id={:?}, use_path={:?})\",\n                expr_id, use_path);\n \n-        let mut ret = UseOk;\n-\n         let scope = region::Scope {\n             id: expr_id,\n             data: region::ScopeData::Node\n         };\n         self.each_in_scope_loan_affecting_path(\n             scope, use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n-                ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n+                self.bccx.signal_error();\n                 false\n             } else {\n                 true\n             }\n         });\n-\n-        return ret;\n     }\n \n     /// Reports an error if `expr` (which should be a path)\n     /// is using a moved/uninitialized value\n     fn check_if_path_is_moved(&self,\n                               id: hir::ItemLocalId,\n-                              span: Span,\n-                              use_kind: MovedValueUseKind,\n                               lp: &Rc<LoanPath<'tcx>>) {\n-        debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={:?})\",\n-               id, use_kind, lp);\n+        debug!(\"check_if_path_is_moved(id={:?}, lp={:?})\", id, lp);\n \n         // FIXME: if you find yourself tempted to cut and paste\n         // the body below and then specializing the error reporting,\n         // consider refactoring this instead!\n \n         let base_lp = owned_ptr_base_path_rc(lp);\n-        self.move_data.each_move_of(id, &base_lp, |the_move, moved_lp| {\n-            self.bccx.report_use_of_moved_value(\n-                span,\n-                use_kind,\n-                &lp,\n-                the_move,\n-                moved_lp);\n+        self.move_data.each_move_of(id, &base_lp, |_, _| {\n+            self.bccx.signal_error();\n             false\n         });\n     }\n@@ -820,8 +604,6 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     /// ```\n     fn check_if_assigned_path_is_moved(&self,\n                                        id: hir::ItemLocalId,\n-                                       span: Span,\n-                                       use_kind: MovedValueUseKind,\n                                        lp: &Rc<LoanPath<'tcx>>)\n     {\n         match lp.kind {\n@@ -830,8 +612,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n             LpDowncast(ref lp_base, _) => {\n                 // assigning to `(P->Variant).f` is ok if assigning to `P` is ok\n-                self.check_if_assigned_path_is_moved(id, span,\n-                                                     use_kind, lp_base);\n+                self.check_if_assigned_path_is_moved(id, lp_base);\n             }\n             LpExtend(ref lp_base, _, LpInterior(_, InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n@@ -845,9 +626,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         let loan_path = owned_ptr_base_path_rc(lp_base);\n                         self.move_data.each_move_of(id, &loan_path, |_, _| {\n                             self.bccx\n-                                .report_partial_reinitialization_of_uninitialized_structure(\n-                                    span,\n-                                    &loan_path);\n+                                .signal_error();\n                             false\n                         });\n                         return;\n@@ -856,21 +635,19 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n \n                 // assigning to `P.f` is ok if assigning to `P` is ok\n-                self.check_if_assigned_path_is_moved(id, span,\n-                                                     use_kind, lp_base);\n+                self.check_if_assigned_path_is_moved(id, lp_base);\n             }\n             LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) |\n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 // assigning to `P[i]` requires `P` is initialized\n                 // assigning to `(*P)` requires `P` is initialized\n-                self.check_if_path_is_moved(id, span, use_kind, lp_base);\n+                self.check_if_path_is_moved(id, lp_base);\n             }\n         }\n     }\n \n     fn check_assignment(&self,\n                         assignment_id: hir::ItemLocalId,\n-                        assignment_span: Span,\n                         assignee_cmt: &mc::cmt_<'tcx>) {\n         debug!(\"check_assignment(assignee_cmt={:?})\", assignee_cmt);\n \n@@ -880,39 +657,24 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 id: assignment_id,\n                 data: region::ScopeData::Node\n             };\n-            self.each_in_scope_loan_affecting_path(scope, &loan_path, |loan| {\n-                self.report_illegal_mutation(assignment_span, &loan_path, loan);\n+            self.each_in_scope_loan_affecting_path(scope, &loan_path, |_| {\n+                self.bccx.signal_error();\n                 false\n             });\n         }\n \n         // Check for reassignments to (immutable) local variables. This\n         // needs to be done here instead of in check_loans because we\n         // depend on move data.\n-        if let Categorization::Local(hir_id) = assignee_cmt.cat {\n+        if let Categorization::Local(_) = assignee_cmt.cat {\n             let lp = opt_loan_path(assignee_cmt).unwrap();\n-            self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n-                if assignee_cmt.mutbl.is_mutable() {\n-                    self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n-                } else {\n-                    self.bccx.report_reassigned_immutable_variable(\n-                        assignment_span,\n-                        &lp,\n-                        assign);\n+            self.move_data.each_assignment_of(assignment_id, &lp, |_| {\n+                if !assignee_cmt.mutbl.is_mutable() {\n+                    self.bccx.signal_error();\n                 }\n                 false\n             });\n             return\n         }\n     }\n-\n-    pub fn report_illegal_mutation(&self,\n-                                   span: Span,\n-                                   loan_path: &LoanPath<'tcx>,\n-                                   loan: &Loan<'_>) {\n-        self.bccx.cannot_assign_to_borrowed(\n-            span, loan.span, &self.bccx.loan_path_to_string(loan_path), Origin::Ast)\n-            .emit();\n-        self.bccx.signal_error();\n-    }\n }", "previous_filename": "src/librustc_borrowck/borrowck/check_loans.rs"}, {"sha": "617161109b573ee95bee7b499b2a498a610d40ce", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "renamed", "additions": 8, "deletions": 84, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -1,150 +1,74 @@\n //! Computes moves.\n \n use crate::borrowck::*;\n-use crate::borrowck::gather_loans::move_error::MovePlace;\n-use crate::borrowck::gather_loans::move_error::{MoveError, MoveErrorCollector};\n use crate::borrowck::move_data::*;\n-use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::ty::{self, Ty};\n \n use std::rc::Rc;\n use syntax_pos::Span;\n-use rustc::hir::*;\n-use rustc::hir::Node;\n use log::debug;\n \n struct GatherMoveInfo<'c, 'tcx> {\n     id: hir::ItemLocalId,\n-    kind: MoveKind,\n     cmt: &'c mc::cmt_<'tcx>,\n-    span_path_opt: Option<MovePlace<'tcx>>,\n-}\n-\n-/// Represents the kind of pattern\n-#[derive(Debug, Clone, Copy)]\n-pub enum PatternSource<'tcx> {\n-    MatchExpr(&'tcx Expr),\n-    LetDecl(&'tcx Local),\n-    Other,\n-}\n-\n-/// Analyzes the context where the pattern appears to determine the\n-/// kind of hint we want to give. In particular, if the pattern is in a `match`\n-/// or nested within other patterns, we want to suggest a `ref` binding:\n-///\n-///     let (a, b) = v[0]; // like the `a` and `b` patterns here\n-///     match v[0] { a => ... } // or the `a` pattern here\n-///\n-/// But if the pattern is the outermost pattern in a `let`, we would rather\n-/// suggest that the author add a `&` to the initializer:\n-///\n-///     let x = v[0]; // suggest `&v[0]` here\n-///\n-/// In this latter case, this function will return `PatternSource::LetDecl`\n-/// with a reference to the let\n-fn get_pattern_source<'tcx>(tcx: TyCtxt<'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n-\n-    let parent = tcx.hir().get_parent_node(pat.hir_id);\n-\n-    match tcx.hir().get(parent) {\n-        Node::Expr(ref e) => {\n-            // the enclosing expression must be a `match` or something else\n-            assert!(match e.node {\n-                        ExprKind::Match(..) => true,\n-                        _ => return PatternSource::Other,\n-                    });\n-            PatternSource::MatchExpr(e)\n-        }\n-        Node::Local(local) => PatternSource::LetDecl(local),\n-        _ => return PatternSource::Other,\n-\n-    }\n }\n \n pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              move_data: &MoveData<'tcx>,\n                              var_id: hir::HirId,\n                              var_ty: Ty<'tcx>) {\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n-    move_data.add_move(bccx.tcx, loan_path, var_id.local_id, Declared);\n+    move_data.add_move(bccx.tcx, loan_path, var_id.local_id);\n }\n \n pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                        move_data: &MoveData<'tcx>,\n-                                       move_error_collector: &mut MoveErrorCollector<'tcx>,\n                                        move_expr_id: hir::ItemLocalId,\n-                                       cmt: &mc::cmt_<'tcx>,\n-                                       move_reason: euv::MoveReason) {\n-    let kind = match move_reason {\n-        euv::DirectRefMove | euv::PatBindingMove => MoveExpr,\n-        euv::CaptureMove => Captured\n-    };\n+                                       cmt: &mc::cmt_<'tcx>) {\n     let move_info = GatherMoveInfo {\n         id: move_expr_id,\n-        kind,\n         cmt,\n-        span_path_opt: None,\n     };\n-    gather_move(bccx, move_data, move_error_collector, move_info);\n+    gather_move(bccx, move_data, move_info);\n }\n \n pub fn gather_move_from_pat<'a, 'c, 'tcx>(\n     bccx: &BorrowckCtxt<'a, 'tcx>,\n     move_data: &MoveData<'tcx>,\n-    move_error_collector: &mut MoveErrorCollector<'tcx>,\n     move_pat: &hir::Pat,\n     cmt: &'c mc::cmt_<'tcx>,\n ) {\n-    let source = get_pattern_source(bccx.tcx,move_pat);\n-    let pat_span_path_opt = match move_pat.node {\n-        PatKind::Binding(_, _, ident, _) => {\n-            Some(MovePlace {\n-                     span: move_pat.span,\n-                     name: ident.name,\n-                     pat_source: source,\n-                 })\n-        }\n-        _ => None,\n-    };\n     let move_info = GatherMoveInfo {\n         id: move_pat.hir_id.local_id,\n-        kind: MovePat,\n         cmt,\n-        span_path_opt: pat_span_path_opt,\n     };\n \n-    debug!(\"gather_move_from_pat: move_pat={:?} source={:?}\",\n-           move_pat,\n-           source);\n+    debug!(\"gather_move_from_pat: move_pat={:?}\", move_pat);\n \n-    gather_move(bccx, move_data, move_error_collector, move_info);\n+    gather_move(bccx, move_data, move_info);\n }\n \n fn gather_move<'a, 'c, 'tcx>(\n     bccx: &BorrowckCtxt<'a, 'tcx>,\n     move_data: &MoveData<'tcx>,\n-    move_error_collector: &mut MoveErrorCollector<'tcx>,\n     move_info: GatherMoveInfo<'c, 'tcx>,\n ) {\n     debug!(\"gather_move(move_id={:?}, cmt={:?})\",\n            move_info.id, move_info.cmt);\n \n     let potentially_illegal_move = check_and_get_illegal_move_origin(bccx, move_info.cmt);\n-    if let Some(illegal_move_origin) = potentially_illegal_move {\n-        debug!(\"illegal_move_origin={:?}\", illegal_move_origin);\n-        let error = MoveError::with_move_info(Rc::new(illegal_move_origin),\n-                                              move_info.span_path_opt);\n-        move_error_collector.add_error(error);\n+    if let Some(_) = potentially_illegal_move {\n+        bccx.signal_error();\n         return;\n     }\n \n     match opt_loan_path(&move_info.cmt) {\n         Some(loan_path) => {\n             move_data.add_move(bccx.tcx, loan_path,\n-                               move_info.id, move_info.kind);\n+                               move_info.id);\n         }\n         None => {\n             // move from rvalue or raw pointer, hence ok", "previous_filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs"}, {"sha": "ff7dd66793d1880d2ce321c31c950cd2ca227b3c", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/lifetime.rs", "status": "renamed", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -3,21 +3,17 @@\n \n use crate::borrowck::*;\n use rustc::hir::HirId;\n-use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::ty;\n \n-use syntax_pos::Span;\n use log::debug;\n \n type R = Result<(),()>;\n \n pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     item_scope: region::Scope,\n-                                    span: Span,\n-                                    cause: euv::LoanCause,\n                                     cmt: &'a mc::cmt_<'tcx>,\n                                     loan_region: ty::Region<'tcx>)\n                                     -> Result<(),()> {\n@@ -26,12 +22,7 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     //! and is scope of `cmt` otherwise.\n     debug!(\"guarantee_lifetime(cmt={:?}, loan_region={:?})\",\n            cmt, loan_region);\n-    let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n-                                         item_scope,\n-                                         span,\n-                                         cause,\n-                                         loan_region,\n-                                         cmt_original: cmt};\n+    let ctxt = GuaranteeLifetimeContext { bccx, item_scope, loan_region };\n     ctxt.check(cmt, None)\n }\n \n@@ -44,10 +35,7 @@ struct GuaranteeLifetimeContext<'a, 'tcx> {\n     // the scope of the function body for the enclosing item\n     item_scope: region::Scope,\n \n-    span: Span,\n-    cause: euv::LoanCause,\n     loan_region: ty::Region<'tcx>,\n-    cmt_original: &'a mc::cmt_<'tcx>\n }\n \n impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n@@ -85,7 +73,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         //! Reports an error if `loan_region` is larger than `max_scope`\n \n         if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n-            Err(self.report_error(err_out_of_scope(max_scope, self.loan_region, self.cause)))\n+            Err(self.bccx.signal_error())\n         } else {\n             Ok(())\n         }\n@@ -122,11 +110,4 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    fn report_error(&self, code: bckerr_code<'tcx>) {\n-        self.bccx.report(BckError { cmt: self.cmt_original,\n-                                    span: self.span,\n-                                    cause: BorrowViolation(self.cause),\n-                                    code: code });\n-    }\n }", "previous_filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs"}, {"sha": "16fef705ec9538ef6339b4e121e9d5738418110b", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/mod.rs", "status": "renamed", "additions": 18, "deletions": 124, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -23,7 +23,6 @@ use restrictions::RestrictionResult;\n mod lifetime;\n mod restrictions;\n mod gather_moves;\n-mod move_error;\n \n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     body: hir::BodyId)\n@@ -38,7 +37,6 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             data: region::ScopeData::Node\n         },\n         move_data: MoveData::default(),\n-        move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n     let rvalue_promotable_map = bccx.tcx.rvalue_promotable_map(def_id);\n@@ -51,15 +49,13 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              Some(rvalue_promotable_map))\n         .consume_body(bccx.body);\n \n-    glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n     (all_loans, move_data)\n }\n \n struct GatherLoanCtxt<'a, 'tcx> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     move_data: move_data::MoveData<'tcx>,\n-    move_error_collector: move_error::MoveErrorCollector<'tcx>,\n     all_loans: Vec<Loan<'tcx>>,\n     /// `item_ub` is used as an upper-bound on the lifetime whenever we\n     /// ask for the scope of an expression categorized as an upvar.\n@@ -76,10 +72,10 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                consume_id, cmt, mode);\n \n         match mode {\n-            euv::Move(move_reason) => {\n+            euv::Move(_) => {\n                 gather_moves::gather_move_from_expr(\n-                    self.bccx, &self.move_data, &mut self.move_error_collector,\n-                    consume_id.local_id, cmt, move_reason);\n+                    self.bccx, &self.move_data,\n+                    consume_id.local_id, cmt);\n             }\n             euv::Copy => { }\n         }\n@@ -110,13 +106,13 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n         }\n \n         gather_moves::gather_move_from_pat(\n-            self.bccx, &self.move_data, &mut self.move_error_collector,\n+            self.bccx, &self.move_data,\n             consume_pat, cmt);\n     }\n \n     fn borrow(&mut self,\n               borrow_id: hir::HirId,\n-              borrow_span: Span,\n+              _: Span,\n               cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n               bk: ty::BorrowKind,\n@@ -128,11 +124,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                bk, loan_cause);\n \n         self.guarantee_valid(borrow_id.local_id,\n-                             borrow_span,\n                              cmt,\n                              bk,\n-                             loan_region,\n-                             loan_cause);\n+                             loan_region);\n     }\n \n     fn mutate(&mut self,\n@@ -174,8 +168,6 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n \n /// Implements the A-* rules in README.md.\n fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                borrow_span: Span,\n-                                loan_cause: AliasableViolationKind,\n                                 cmt: &mc::cmt_<'tcx>,\n                                 req_kind: ty::BorrowKind)\n                                 -> Result<(),()> {\n@@ -198,13 +190,9 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             // user knows what they're doing in these cases.\n             Ok(())\n         }\n-        (mc::Aliasability::FreelyAliasable(alias_cause), ty::UniqueImmBorrow) |\n-        (mc::Aliasability::FreelyAliasable(alias_cause), ty::MutBorrow) => {\n-            bccx.report_aliasability_violation(\n-                        borrow_span,\n-                        loan_cause,\n-                        alias_cause,\n-                        cmt);\n+        (mc::Aliasability::FreelyAliasable(_), ty::UniqueImmBorrow) |\n+        (mc::Aliasability::FreelyAliasable(_), ty::MutBorrow) => {\n+            bccx.signal_error();\n             Err(())\n         }\n         (..) => {\n@@ -215,13 +203,10 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n /// Implements the M-* rules in README.md.\n fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                              borrow_span: Span,\n-                              cause: AliasableViolationKind,\n                               cmt: &mc::cmt_<'tcx>,\n                               req_kind: ty::BorrowKind)\n                               -> Result<(),()> {\n-    debug!(\"check_mutability(cause={:?} cmt={:?} req_kind={:?}\",\n-           cause, cmt, req_kind);\n+    debug!(\"check_mutability(cmt={:?} req_kind={:?}\", cmt, req_kind);\n     match req_kind {\n         ty::UniqueImmBorrow | ty::ImmBorrow => {\n             match cmt.mutbl {\n@@ -239,10 +224,7 @@ fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         ty::MutBorrow => {\n             // Only mutable data can be lent as mutable.\n             if !cmt.mutbl.is_mutable() {\n-                Err(bccx.report(BckError { span: borrow_span,\n-                                           cause,\n-                                           cmt,\n-                                           code: err_mutbl }))\n+                Err(bccx.signal_error())\n             } else {\n                 Ok(())\n             }\n@@ -268,26 +250,18 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             // mutable - this is checked in check_loans.\n         } else {\n             // Check that we don't allow assignments to non-mutable data.\n-            if check_mutability(self.bccx, assignment_span, MutabilityViolation,\n-                                cmt, ty::MutBorrow).is_err() {\n+            if check_mutability(self.bccx, cmt, ty::MutBorrow).is_err() {\n                 return; // reported an error, no sense in reporting more.\n             }\n         }\n \n         // Check that we don't allow assignments to aliasable data\n-        if check_aliasability(self.bccx, assignment_span, MutabilityViolation,\n-                              cmt, ty::MutBorrow).is_err() {\n+        if check_aliasability(self.bccx, cmt, ty::MutBorrow).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         match opt_lp {\n             Some(lp) => {\n-                if let Categorization::Local(..) = cmt.cat {\n-                    // Only re-assignments to locals require it to be\n-                    // mutable - this is checked in check_loans.\n-                } else {\n-                    self.mark_loan_path_as_mutated(&lp);\n-                }\n                 gather_moves::gather_assignment(self.bccx, &self.move_data,\n                                                 assignment_id.local_id,\n                                                 assignment_span,\n@@ -306,11 +280,9 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     /// `req_loan_map`.\n     fn guarantee_valid(&mut self,\n                        borrow_id: hir::ItemLocalId,\n-                       borrow_span: Span,\n                        cmt: &mc::cmt_<'tcx>,\n                        req_kind: ty::BorrowKind,\n-                       loan_region: ty::Region<'tcx>,\n-                       cause: euv::LoanCause) {\n+                       loan_region: ty::Region<'tcx>) {\n         debug!(\"guarantee_valid(borrow_id={:?}, cmt={:?}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n@@ -326,27 +298,23 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed.\n-        if lifetime::guarantee_lifetime(self.bccx, self.item_ub,\n-                                        borrow_span, cause, cmt, loan_region).is_err() {\n+        if lifetime::guarantee_lifetime(self.bccx, self.item_ub, cmt, loan_region).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of non-mutable data.\n-        if check_mutability(self.bccx, borrow_span, BorrowViolation(cause),\n-                            cmt, req_kind).is_err() {\n+        if check_mutability(self.bccx, cmt, req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of aliasable data.\n-        if check_aliasability(self.bccx, borrow_span, BorrowViolation(cause),\n-                              cmt, req_kind).is_err() {\n+        if check_aliasability(self.bccx, cmt, req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Compute the restrictions that are required to enforce the\n         // loan is safe.\n-        let restr = restrictions::compute_restrictions(\n-            self.bccx, borrow_span, cause, &cmt, loan_region);\n+        let restr = restrictions::compute_restrictions(self.bccx, &cmt, loan_region);\n \n         debug!(\"guarantee_valid(): restrictions={:?}\", restr);\n \n@@ -395,19 +363,13 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 let kill_scope = self.compute_kill_scope(loan_scope, &loan_path);\n                 debug!(\"kill_scope = {:?}\", kill_scope);\n \n-                if req_kind == ty::MutBorrow {\n-                    self.mark_loan_path_as_mutated(&loan_path);\n-                }\n-\n                 Loan {\n                     index: self.all_loans.len(),\n                     loan_path,\n                     kind: req_kind,\n                     gen_scope,\n                     kill_scope,\n-                    span: borrow_span,\n                     restricted_paths,\n-                    cause,\n                 }\n             }\n         };\n@@ -419,70 +381,6 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         // let loan_gen_scope = loan.gen_scope;\n         // let loan_kill_scope = loan.kill_scope;\n         self.all_loans.push(loan);\n-\n-        // if loan_gen_scope != borrow_id {\n-            // FIXME(https://github.com/rust-lang/rfcs/issues/811) Nested method calls\n-            //\n-            // Typically, the scope of the loan includes the point at\n-            // which the loan is originated. This\n-            // This is a subtle case. See the test case\n-            // <compile-fail/borrowck-bad-nested-calls-free.rs>\n-            // to see what we are guarding against.\n-\n-            //let restr = restrictions::compute_restrictions(\n-            //    self.bccx, borrow_span, cmt, RESTR_EMPTY);\n-            //let loan = {\n-            //    Loan {\n-            //        index: self.all_loans.len(),\n-            //        loan_path,\n-            //        cmt,\n-            //        mutbl: ConstMutability,\n-            //        gen_scope: borrow_id,\n-            //        kill_scope,\n-            //        span: borrow_span,\n-            //        restrictions,\n-            //    }\n-        // }\n-    }\n-\n-    pub fn mark_loan_path_as_mutated(&self, loan_path: &LoanPath<'_>) {\n-        //! For mutable loans of content whose mutability derives\n-        //! from a local variable, mark the mutability decl as necessary.\n-\n-        let mut wrapped_path = Some(loan_path);\n-        let mut through_borrow = false;\n-\n-        while let Some(current_path) = wrapped_path {\n-            wrapped_path = match current_path.kind {\n-                LpVar(hir_id) => {\n-                    if !through_borrow {\n-                        self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n-                    }\n-                    None\n-                }\n-                LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {\n-                    self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n-                    None\n-                }\n-                LpExtend(ref base, mc::McInherited, LpDeref(pointer_kind)) |\n-                LpExtend(ref base, mc::McDeclared, LpDeref(pointer_kind)) => {\n-                    if pointer_kind != mc::Unique {\n-                        through_borrow = true;\n-                    }\n-                    Some(base)\n-                }\n-                LpDowncast(ref base, _) |\n-                LpExtend(ref base, mc::McInherited, _) |\n-                LpExtend(ref base, mc::McDeclared, _) => {\n-                    Some(base)\n-                }\n-                LpExtend(_, mc::McImmutable, _) => {\n-                    // Nothing to do.\n-                    None\n-                }\n-            }\n-        }\n-\n     }\n \n     pub fn compute_gen_scope(&self,\n@@ -532,8 +430,4 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             loan_scope\n         }\n     }\n-\n-    pub fn report_potential_errors(&self) {\n-        self.move_error_collector.report_potential_errors(self.bccx);\n-    }\n }", "previous_filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs"}, {"sha": "545c27b17bd585c21a5acd0edbdc2b24bf34492f", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/restrictions.rs", "status": "renamed", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -1,11 +1,9 @@\n //! Computes the restrictions that result from a borrow.\n \n use crate::borrowck::*;\n-use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty;\n-use syntax_pos::Span;\n use log::debug;\n \n use crate::borrowck::ToInteriorKind;\n@@ -19,17 +17,10 @@ pub enum RestrictionResult<'tcx> {\n }\n \n pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                      span: Span,\n-                                      cause: euv::LoanCause,\n                                       cmt: &mc::cmt_<'tcx>,\n                                       loan_region: ty::Region<'tcx>)\n                                       -> RestrictionResult<'tcx> {\n-    let ctxt = RestrictionsContext {\n-        bccx,\n-        span,\n-        cause,\n-        loan_region,\n-    };\n+    let ctxt = RestrictionsContext { bccx, loan_region };\n \n     ctxt.restrict(cmt)\n }\n@@ -39,9 +30,7 @@ pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n struct RestrictionsContext<'a, 'tcx> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    span: Span,\n     loan_region: ty::Region<'tcx>,\n-    cause: euv::LoanCause,\n }\n \n impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n@@ -149,13 +138,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                     mc::BorrowedPtr(bk, lt) => {\n                         // R-Deref-[Mut-]Borrowed\n                         if !self.bccx.is_subregion_of(self.loan_region, lt) {\n-                            self.bccx.report(\n-                                BckError {\n-                                    span: self.span,\n-                                    cause: BorrowViolation(self.cause),\n-                                    cmt: &cmt_base,\n-                                    code: err_borrowed_pointer_too_short(\n-                                        self.loan_region, lt)});\n+                            self.bccx.signal_error();\n                             return RestrictionResult::Safe;\n                         }\n ", "previous_filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs"}, {"sha": "f8ad8baa5974d4e2364116a1e78044af1609a7e5", "filename": "src/librustc_ast_borrowck/borrowck/mod.rs", "status": "added", "additions": 614, "deletions": 0, "changes": 614, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -0,0 +1,614 @@\n+//! See The Book chapter on the borrow checker for more details.\n+\n+#![allow(non_camel_case_types)]\n+\n+pub use LoanPathKind::*;\n+pub use LoanPathElem::*;\n+\n+use InteriorKind::*;\n+\n+use rustc::hir::HirId;\n+use rustc::hir::Node;\n+use rustc::cfg;\n+use rustc::middle::borrowck::{BorrowCheckResult, SignalledError};\n+use rustc::hir::def_id::{DefId, LocalDefId};\n+use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Categorization;\n+use rustc::middle::region;\n+use rustc::middle::free_region::RegionRelations;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::query::Providers;\n+\n+use std::borrow::Cow;\n+use std::cell::{Cell};\n+use std::fmt;\n+use std::rc::Rc;\n+use std::hash::{Hash, Hasher};\n+use log::debug;\n+\n+use rustc::hir;\n+\n+use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n+\n+pub mod check_loans;\n+\n+pub mod gather_loans;\n+\n+pub mod move_data;\n+\n+#[derive(Clone, Copy)]\n+pub struct LoanDataFlowOperator;\n+\n+pub type LoanDataFlow<'tcx> = DataFlowContext<'tcx, LoanDataFlowOperator>;\n+\n+pub fn check_crate(tcx: TyCtxt<'_>) {\n+    tcx.par_body_owners(|body_owner_def_id| {\n+        tcx.ensure().borrowck(body_owner_def_id);\n+    });\n+}\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    *providers = Providers {\n+        borrowck,\n+        ..*providers\n+    };\n+}\n+\n+/// Collection of conclusions determined via borrow checker analyses.\n+pub struct AnalysisData<'tcx> {\n+    pub all_loans: Vec<Loan<'tcx>>,\n+    pub loans: DataFlowContext<'tcx, LoanDataFlowOperator>,\n+    pub move_data: move_data::FlowedMoveData<'tcx>,\n+}\n+\n+fn borrowck(tcx: TyCtxt<'_>, owner_def_id: DefId) -> &BorrowCheckResult {\n+    assert!(tcx.use_ast_borrowck() || tcx.migrate_borrowck());\n+\n+    debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n+\n+    let owner_id = tcx.hir().as_local_hir_id(owner_def_id).unwrap();\n+\n+    match tcx.hir().get(owner_id) {\n+        Node::Ctor(..) => {\n+            // We get invoked with anything that has MIR, but some of\n+            // those things (notably the synthesized constructors from\n+            // tuple structs/variants) do not have an associated body\n+            // and do not need borrowchecking.\n+            return tcx.arena.alloc(BorrowCheckResult {\n+                signalled_any_error: SignalledError::NoErrorsSeen,\n+            })\n+        }\n+        _ => { }\n+    }\n+\n+    let body_id = tcx.hir().body_owned_by(owner_id);\n+    let tables = tcx.typeck_tables_of(owner_def_id);\n+    let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n+    let body = tcx.hir().body(body_id);\n+    let mut bccx = BorrowckCtxt {\n+        tcx,\n+        tables,\n+        region_scope_tree,\n+        owner_def_id,\n+        body,\n+        signalled_any_error: Cell::new(SignalledError::NoErrorsSeen),\n+    };\n+\n+    // Eventually, borrowck will always read the MIR, but at the\n+    // moment we do not. So, for now, we always force MIR to be\n+    // constructed for a given fn, since this may result in errors\n+    // being reported and we want that to happen.\n+    //\n+    // Note that `mir_validated` is a \"stealable\" result; the\n+    // thief, `optimized_mir()`, forces borrowck, so we know that\n+    // is not yet stolen.\n+    tcx.ensure().mir_validated(owner_def_id);\n+\n+    // option dance because you can't capture an uninitialized variable\n+    // by mut-ref.\n+    let mut cfg = None;\n+    if let Some(AnalysisData { all_loans,\n+                               loans: loan_dfcx,\n+                               move_data: flowed_moves }) =\n+        build_borrowck_dataflow_data(&mut bccx, false, body_id,\n+                                     |bccx| {\n+                                         cfg = Some(cfg::CFG::new(bccx.tcx, &body));\n+                                         cfg.as_mut().unwrap()\n+                                     })\n+    {\n+        check_loans::check_loans(&mut bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n+    }\n+\n+    tcx.arena.alloc(BorrowCheckResult {\n+        signalled_any_error: bccx.signalled_any_error.into_inner(),\n+    })\n+}\n+\n+fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tcx>,\n+                                                 force_analysis: bool,\n+                                                 body_id: hir::BodyId,\n+                                                 get_cfg: F)\n+                                                 -> Option<AnalysisData<'tcx>>\n+    where F: FnOnce(&mut BorrowckCtxt<'a, 'tcx>) -> &'c cfg::CFG\n+{\n+    // Check the body of fn items.\n+    let (all_loans, move_data) =\n+        gather_loans::gather_loans_in_fn(this, body_id);\n+\n+    if !force_analysis && move_data.is_empty() && all_loans.is_empty() {\n+        // large arrays of data inserted as constants can take a lot of\n+        // time and memory to borrow-check - see issue #36799. However,\n+        // they don't have places, so no borrow-check is actually needed.\n+        // Recognize that case and skip borrow-checking.\n+        debug!(\"skipping loan propagation for {:?} because of no loans\", body_id);\n+        return None;\n+    } else {\n+        debug!(\"propagating loans in {:?}\", body_id);\n+    }\n+\n+    let cfg = get_cfg(this);\n+    let mut loan_dfcx =\n+        DataFlowContext::new(this.tcx,\n+                             \"borrowck\",\n+                             Some(this.body),\n+                             cfg,\n+                             LoanDataFlowOperator,\n+                             all_loans.len());\n+    for (loan_idx, loan) in all_loans.iter().enumerate() {\n+        loan_dfcx.add_gen(loan.gen_scope.item_local_id(), loan_idx);\n+        loan_dfcx.add_kill(KillFrom::ScopeEnd,\n+                           loan.kill_scope.item_local_id(),\n+                           loan_idx);\n+    }\n+    loan_dfcx.add_kills_from_flow_exits(cfg);\n+    loan_dfcx.propagate(cfg, this.body);\n+\n+    let flowed_moves = move_data::FlowedMoveData::new(move_data,\n+                                                      this,\n+                                                      cfg,\n+                                                      this.body);\n+\n+    Some(AnalysisData { all_loans,\n+                        loans: loan_dfcx,\n+                        move_data:flowed_moves })\n+}\n+\n+/// Accessor for introspective clients inspecting `AnalysisData` and\n+/// the `BorrowckCtxt` itself , e.g., the flowgraph visualizer.\n+pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body_id: hir::BodyId,\n+    cfg: &cfg::CFG)\n+    -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'tcx>)\n+{\n+    let owner_id = tcx.hir().body_owner(body_id);\n+    let owner_def_id = tcx.hir().local_def_id(owner_id);\n+    let tables = tcx.typeck_tables_of(owner_def_id);\n+    let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n+    let body = tcx.hir().body(body_id);\n+    let mut bccx = BorrowckCtxt {\n+        tcx,\n+        tables,\n+        region_scope_tree,\n+        owner_def_id,\n+        body,\n+        signalled_any_error: Cell::new(SignalledError::NoErrorsSeen),\n+    };\n+\n+    let dataflow_data = build_borrowck_dataflow_data(&mut bccx, true, body_id, |_| cfg);\n+    (bccx, dataflow_data.unwrap())\n+}\n+\n+// ----------------------------------------------------------------------\n+// Type definitions\n+\n+pub struct BorrowckCtxt<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    // tables for the current thing we are checking; set to\n+    // Some in `borrowck_fn` and cleared later\n+    tables: &'a ty::TypeckTables<'tcx>,\n+\n+    region_scope_tree: &'tcx region::ScopeTree,\n+\n+    owner_def_id: DefId,\n+\n+    body: &'tcx hir::Body,\n+\n+    signalled_any_error: Cell<SignalledError>,\n+}\n+\n+\n+impl<'a, 'tcx: 'a> BorrowckCtxt<'a, 'tcx> {\n+    fn signal_error(&self) {\n+        self.signalled_any_error.set(SignalledError::SawSomeError);\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Loans and loan paths\n+\n+/// Record of a loan that was issued.\n+pub struct Loan<'tcx> {\n+    index: usize,\n+    loan_path: Rc<LoanPath<'tcx>>,\n+    kind: ty::BorrowKind,\n+    restricted_paths: Vec<Rc<LoanPath<'tcx>>>,\n+\n+    /// gen_scope indicates where loan is introduced. Typically the\n+    /// loan is introduced at the point of the borrow, but in some\n+    /// cases, notably method arguments, the loan may be introduced\n+    /// only later, once it comes into scope. See also\n+    /// `GatherLoanCtxt::compute_gen_scope`.\n+    gen_scope: region::Scope,\n+\n+    /// kill_scope indicates when the loan goes out of scope. This is\n+    /// either when the lifetime expires or when the local variable\n+    /// which roots the loan-path goes out of scope, whichever happens\n+    /// faster. See also `GatherLoanCtxt::compute_kill_scope`.\n+    kill_scope: region::Scope,\n+}\n+\n+impl<'tcx> Loan<'tcx> {\n+    pub fn loan_path(&self) -> Rc<LoanPath<'tcx>> {\n+        self.loan_path.clone()\n+    }\n+}\n+\n+#[derive(Eq)]\n+pub struct LoanPath<'tcx> {\n+    kind: LoanPathKind<'tcx>,\n+    ty: Ty<'tcx>,\n+}\n+\n+impl<'tcx> PartialEq for LoanPath<'tcx> {\n+    fn eq(&self, that: &LoanPath<'tcx>) -> bool {\n+        self.kind == that.kind\n+    }\n+}\n+\n+impl<'tcx> Hash for LoanPath<'tcx> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.kind.hash(state);\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Debug)]\n+pub enum LoanPathKind<'tcx> {\n+    LpVar(hir::HirId),                          // `x` in README.md\n+    LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n+    LpDowncast(Rc<LoanPath<'tcx>>, DefId), // `x` downcast to particular enum variant\n+    LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem<'tcx>)\n+}\n+\n+impl<'tcx> LoanPath<'tcx> {\n+    fn new(kind: LoanPathKind<'tcx>, ty: Ty<'tcx>) -> LoanPath<'tcx> {\n+        LoanPath { kind: kind, ty: ty }\n+    }\n+\n+    fn to_type(&self) -> Ty<'tcx> { self.ty }\n+}\n+\n+// FIXME (pnkfelix): See discussion here\n+// https://github.com/pnkfelix/rust/commit/\n+//     b2b39e8700e37ad32b486b9a8409b50a8a53aa51#commitcomment-7892003\n+const DOWNCAST_PRINTED_OPERATOR: &'static str = \" as \";\n+\n+// A local, \"cleaned\" version of `mc::InteriorKind` that drops\n+// information that is not relevant to loan-path analysis. (In\n+// particular, the distinction between how precisely an array-element\n+// is tracked is irrelevant here.)\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum InteriorKind {\n+    InteriorField(mc::FieldIndex),\n+    InteriorElement,\n+}\n+\n+trait ToInteriorKind { fn cleaned(self) -> InteriorKind; }\n+impl ToInteriorKind for mc::InteriorKind {\n+    fn cleaned(self) -> InteriorKind {\n+        match self {\n+            mc::InteriorField(name) => InteriorField(name),\n+            mc::InteriorElement(_) => InteriorElement,\n+        }\n+    }\n+}\n+\n+// This can be:\n+// - a pointer dereference (`*P` in README.md)\n+// - a field reference, with an optional definition of the containing\n+//   enum variant (`P.f` in README.md)\n+// `DefId` is present when the field is part of struct that is in\n+// a variant of an enum. For instance in:\n+// `enum E { X { foo: u32 }, Y { foo: u32 }}`\n+// each `foo` is qualified by the definitition id of the variant (`X` or `Y`).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum LoanPathElem<'tcx> {\n+    LpDeref(mc::PointerKind<'tcx>),\n+    LpInterior(Option<DefId>, InteriorKind),\n+}\n+\n+fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_>) -> HirId {\n+    let closure_id = tcx.hir().local_def_id_to_hir_id(closure_id);\n+    match tcx.hir().get(closure_id) {\n+        Node::Expr(expr) => match expr.node {\n+            hir::ExprKind::Closure(.., body_id, _, _) => {\n+                body_id.hir_id\n+            }\n+            _ => {\n+                bug!(\"encountered non-closure id: {}\", closure_id)\n+            }\n+        },\n+        _ => bug!(\"encountered non-expr id: {}\", closure_id)\n+    }\n+}\n+\n+impl<'a, 'tcx> LoanPath<'tcx> {\n+    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::Scope {\n+        match self.kind {\n+            LpVar(hir_id) => {\n+                bccx.region_scope_tree.var_scope(hir_id.local_id)\n+            }\n+            LpUpvar(upvar_id) => {\n+                let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n+                region::Scope { id: block_id.local_id, data: region::ScopeData::Node }\n+            }\n+            LpDowncast(ref base, _) |\n+            LpExtend(ref base, ..) => base.kill_scope(bccx),\n+        }\n+    }\n+}\n+\n+// Avoid \"cannot borrow immutable field `self.x` as mutable\" as that implies that a field *can* be\n+// mutable independently of the struct it belongs to. (#35937)\n+pub fn opt_loan_path_is_field<'tcx>(cmt: &mc::cmt_<'tcx>) -> (Option<Rc<LoanPath<'tcx>>>, bool) {\n+    let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n+\n+    match cmt.cat {\n+        Categorization::Rvalue(..) |\n+        Categorization::ThreadLocal(..) |\n+        Categorization::StaticItem => {\n+            (None, false)\n+        }\n+\n+        Categorization::Local(id) => {\n+            (Some(new_lp(LpVar(id))), false)\n+        }\n+\n+        Categorization::Upvar(mc::Upvar { id, .. }) => {\n+            (Some(new_lp(LpUpvar(id))), false)\n+        }\n+\n+        Categorization::Deref(ref cmt_base, pk) => {\n+            let lp = opt_loan_path_is_field(cmt_base);\n+            (lp.0.map(|lp| {\n+                new_lp(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n+            }), lp.1)\n+        }\n+\n+        Categorization::Interior(ref cmt_base, ik) => {\n+            (opt_loan_path(cmt_base).map(|lp| {\n+                let opt_variant_id = match cmt_base.cat {\n+                    Categorization::Downcast(_, did) =>  Some(did),\n+                    _ => None\n+                };\n+                new_lp(LpExtend(lp, cmt.mutbl, LpInterior(opt_variant_id, ik.cleaned())))\n+            }), true)\n+        }\n+\n+        Categorization::Downcast(ref cmt_base, variant_def_id) => {\n+            let lp = opt_loan_path_is_field(cmt_base);\n+            (lp.0.map(|lp| {\n+                new_lp(LpDowncast(lp, variant_def_id))\n+            }), lp.1)\n+        }\n+    }\n+}\n+\n+/// Computes the `LoanPath` (if any) for a `cmt`.\n+/// Note that this logic is somewhat duplicated in\n+/// the method `compute()` found in `gather_loans::restrictions`,\n+/// which allows it to share common loan path pieces as it\n+/// traverses the CMT.\n+pub fn opt_loan_path<'tcx>(cmt: &mc::cmt_<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n+    opt_loan_path_is_field(cmt).0\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Misc\n+\n+impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n+    pub fn is_subregion_of(&self,\n+                           r_sub: ty::Region<'tcx>,\n+                           r_sup: ty::Region<'tcx>)\n+                           -> bool\n+    {\n+        let region_rels = RegionRelations::new(self.tcx,\n+                                               self.owner_def_id,\n+                                               &self.region_scope_tree,\n+                                               &self.tables.free_region_map);\n+        region_rels.is_subregion_of(r_sub, r_sup)\n+    }\n+\n+    pub fn append_loan_path_to_string(&self,\n+                                      loan_path: &LoanPath<'tcx>,\n+                                      out: &mut String) {\n+        match loan_path.kind {\n+            LpUpvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id: id }, closure_expr_id: _ }) => {\n+                out.push_str(&self.tcx.hir().name(id).as_str());\n+            }\n+            LpVar(id) => {\n+                out.push_str(&self.tcx.hir().name(id).as_str());\n+            }\n+\n+            LpDowncast(ref lp_base, variant_def_id) => {\n+                out.push('(');\n+                self.append_loan_path_to_string(&lp_base, out);\n+                out.push_str(DOWNCAST_PRINTED_OPERATOR);\n+                out.push_str(&self.tcx.def_path_str(variant_def_id));\n+                out.push(')');\n+            }\n+\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(mc::FieldIndex(_, info)))) => {\n+                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n+                out.push('.');\n+                out.push_str(&info.as_str());\n+            }\n+\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) => {\n+                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n+                out.push_str(\"[..]\");\n+            }\n+\n+            LpExtend(ref lp_base, _, LpDeref(_)) => {\n+                out.push('*');\n+                self.append_loan_path_to_string(&lp_base, out);\n+            }\n+        }\n+    }\n+\n+    pub fn append_autoderefd_loan_path_to_string(&self,\n+                                                 loan_path: &LoanPath<'tcx>,\n+                                                 out: &mut String) {\n+        match loan_path.kind {\n+            LpExtend(ref lp_base, _, LpDeref(_)) => {\n+                // For a path like `(*x).f` or `(*x)[3]`, autoderef\n+                // rules would normally allow users to omit the `*x`.\n+                // So just serialize such paths to `x.f` or x[3]` respectively.\n+                self.append_autoderefd_loan_path_to_string(&lp_base, out)\n+            }\n+\n+            LpDowncast(ref lp_base, variant_def_id) => {\n+                out.push('(');\n+                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n+                out.push_str(DOWNCAST_PRINTED_OPERATOR);\n+                out.push_str(&self.tcx.def_path_str(variant_def_id));\n+                out.push(')');\n+            }\n+\n+            LpVar(..) | LpUpvar(..) | LpExtend(.., LpInterior(..)) => {\n+                self.append_loan_path_to_string(loan_path, out)\n+            }\n+        }\n+    }\n+\n+    pub fn loan_path_to_string(&self, loan_path: &LoanPath<'tcx>) -> String {\n+        let mut result = String::new();\n+        self.append_loan_path_to_string(loan_path, &mut result);\n+        result\n+    }\n+\n+    pub fn cmt_to_cow_str(&self, cmt: &mc::cmt_<'tcx>) -> Cow<'static, str> {\n+        cmt.descriptive_string(self.tcx)\n+    }\n+\n+    pub fn cmt_to_path_or_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n+        match opt_loan_path(cmt) {\n+            Some(lp) => format!(\"`{}`\", self.loan_path_to_string(&lp)),\n+            None => self.cmt_to_cow_str(cmt).into_owned(),\n+        }\n+    }\n+}\n+\n+impl BitwiseOperator for LoanDataFlowOperator {\n+    #[inline]\n+    fn join(&self, succ: usize, pred: usize) -> usize {\n+        succ | pred // loans from both preds are in scope\n+    }\n+}\n+\n+impl DataFlowOperator for LoanDataFlowOperator {\n+    #[inline]\n+    fn initial_value(&self) -> bool {\n+        false // no loans in scope by default\n+    }\n+}\n+\n+impl fmt::Debug for InteriorKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            InteriorField(mc::FieldIndex(_, info)) => write!(f, \"{}\", info),\n+            InteriorElement => write!(f, \"[]\"),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for Loan<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"Loan_{}({:?}, {:?}, {:?}-{:?}, {:?})\",\n+               self.index,\n+               self.loan_path,\n+               self.kind,\n+               self.gen_scope,\n+               self.kill_scope,\n+               self.restricted_paths)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.kind {\n+            LpVar(id) => {\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_string(id)))\n+            }\n+\n+            LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath {hir_id: var_id}, closure_expr_id }) => {\n+                let s = ty::tls::with(|tcx| {\n+                    tcx.hir().node_to_string(var_id)\n+                });\n+                write!(f, \"$({} captured by id={:?})\", s, closure_expr_id)\n+            }\n+\n+            LpDowncast(ref lp, variant_def_id) => {\n+                let variant_str = if variant_def_id.is_local() {\n+                    ty::tls::with(|tcx| tcx.def_path_str(variant_def_id))\n+                } else {\n+                    format!(\"{:?}\", variant_def_id)\n+                };\n+                write!(f, \"({:?}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n+            }\n+\n+            LpExtend(ref lp, _, LpDeref(_)) => {\n+                write!(f, \"{:?}.*\", lp)\n+            }\n+\n+            LpExtend(ref lp, _, LpInterior(_, ref interior)) => {\n+                write!(f, \"{:?}.{:?}\", lp, interior)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for LoanPath<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.kind {\n+            LpVar(id) => {\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().hir_to_user_string(id)))\n+            }\n+\n+            LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {\n+                let s = ty::tls::with(|tcx| {\n+                    tcx.hir().node_to_string(hir_id)\n+                });\n+                write!(f, \"$({} captured by closure)\", s)\n+            }\n+\n+            LpDowncast(ref lp, variant_def_id) => {\n+                let variant_str = if variant_def_id.is_local() {\n+                    ty::tls::with(|tcx| tcx.def_path_str(variant_def_id))\n+                } else {\n+                    format!(\"{:?}\", variant_def_id)\n+                };\n+                write!(f, \"({}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n+            }\n+\n+            LpExtend(ref lp, _, LpDeref(_)) => {\n+                write!(f, \"{}.*\", lp)\n+            }\n+\n+            LpExtend(ref lp, _, LpInterior(_, ref interior)) => {\n+                write!(f, \"{}.{:?}\", lp, interior)\n+            }\n+        }\n+    }\n+}"}, {"sha": "887a0e2f20e16544adbcedb3d40b3a631061de5b", "filename": "src/librustc_ast_borrowck/borrowck/move_data.rs", "status": "renamed", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -1,8 +1,6 @@\n //! Data structures used for tracking moves. Please see the extensive\n //! comments in the section \"Moves and initialization\" in `README.md`.\n \n-pub use MoveKind::*;\n-\n use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n \n use crate::borrowck::*;\n@@ -101,13 +99,6 @@ pub struct MovePath<'tcx> {\n     pub next_sibling: MovePathIndex,\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum MoveKind {\n-    Declared,   // When declared, variables start out \"moved\".\n-    MoveExpr,   // Expression or binding that moves a variable\n-    MovePat,    // By-move binding\n-    Captured    // Closure creation that moves a value\n-}\n \n #[derive(Copy, Clone)]\n pub struct Move {\n@@ -117,9 +108,6 @@ pub struct Move {\n     /// ID of node that is doing the move.\n     pub id: hir::ItemLocalId,\n \n-    /// Kind of move, for error messages.\n-    pub kind: MoveKind,\n-\n     /// Next node in linked list of moves from `path`, or `InvalidMoveIndex`\n     pub next_move: MoveIndex\n }\n@@ -315,7 +303,6 @@ impl MoveData<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         orig_lp: Rc<LoanPath<'tcx>>,\n         id: hir::ItemLocalId,\n-        kind: MoveKind,\n     ) {\n         // Moving one union field automatically moves all its fields. Also move siblings of\n         // all parent union fields, moves do not propagate upwards automatically.\n@@ -331,28 +318,24 @@ impl MoveData<'tcx> {\n                             let sibling_lp_kind =\n                                 LpExtend(base_lp.clone(), mutbl, LpInterior(opt_variant_id, field));\n                             let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, tcx.types.err));\n-                            self.add_move_helper(tcx, sibling_lp, id, kind);\n+                            self.add_move_helper(tcx, sibling_lp, id);\n                         }\n                     }\n                 }\n             }\n             lp = base_lp.clone();\n         }\n \n-        self.add_move_helper(tcx, orig_lp, id, kind);\n+        self.add_move_helper(tcx, orig_lp, id);\n     }\n \n     fn add_move_helper(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         lp: Rc<LoanPath<'tcx>>,\n         id: hir::ItemLocalId,\n-        kind: MoveKind,\n     ) {\n-        debug!(\"add_move(lp={:?}, id={:?}, kind={:?})\",\n-               lp,\n-               id,\n-               kind);\n+        debug!(\"add_move(lp={:?}, id={:?})\", lp, id);\n \n         let path_index = self.move_path(tcx, lp);\n         let move_index = MoveIndex(self.moves.borrow().len());\n@@ -363,7 +346,6 @@ impl MoveData<'tcx> {\n         self.moves.borrow_mut().push(Move {\n             path: path_index,\n             id,\n-            kind,\n             next_move,\n         });\n     }\n@@ -611,19 +593,16 @@ impl<'tcx> FlowedMoveData<'tcx> {\n         }\n     }\n \n-    pub fn kind_of_move_of_path(&self,\n-                                id: hir::ItemLocalId,\n-                                loan_path: &Rc<LoanPath<'tcx>>)\n-                                -> Option<MoveKind> {\n+    pub fn is_move_path(&self, id: hir::ItemLocalId, loan_path: &Rc<LoanPath<'tcx>>) -> bool {\n         //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n \n-        let mut ret = None;\n+        let mut ret = false;\n         if let Some(loan_path_index) = self.move_data.path_map.borrow().get(&*loan_path) {\n             self.dfcx_moves.each_gen_bit(id, |move_index| {\n                 let the_move = self.move_data.moves.borrow();\n                 let the_move = (*the_move)[move_index];\n                 if the_move.path == *loan_path_index {\n-                    ret = Some(the_move.kind);\n+                    ret = true;\n                     false\n                 } else {\n                     true", "previous_filename": "src/librustc_borrowck/borrowck/move_data.rs"}, {"sha": "94849728a9319777b1059e457f7d5ada866695f7", "filename": "src/librustc_ast_borrowck/dataflow.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fdataflow.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "previous_filename": "src/librustc_borrowck/dataflow.rs"}, {"sha": "7a8a23ca76afc50834d4543faea434af4a4457d6", "filename": "src/librustc_ast_borrowck/graphviz.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "previous_filename": "src/librustc_borrowck/graphviz.rs"}, {"sha": "b857c625ec2e76c8b0d4cca48928f53b07453985", "filename": "src/librustc_ast_borrowck/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_ast_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Flib.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "previous_filename": "src/librustc_borrowck/lib.rs"}, {"sha": "58be2cf76c72438ee3a373d24d11ca23b00f5b33", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/e31911ef8f1f46b7fab6e4f350679822ac7d7f6a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e31911ef8f1f46b7fab6e4f350679822ac7d7f6a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=e31911ef8f1f46b7fab6e4f350679822ac7d7f6a", "patch": "@@ -1,186 +0,0 @@\n-use crate::borrowck::BorrowckCtxt;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::mem_categorization::NoteClosureEnv;\n-use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n-use rustc::ty;\n-use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n-use syntax::ast;\n-use syntax_pos;\n-use errors::{DiagnosticBuilder, Applicability};\n-use crate::borrowck::gather_loans::gather_moves::PatternSource;\n-use log::debug;\n-\n-pub struct MoveErrorCollector<'tcx> {\n-    errors: Vec<MoveError<'tcx>>\n-}\n-\n-impl<'tcx> MoveErrorCollector<'tcx> {\n-    pub fn new() -> MoveErrorCollector<'tcx> {\n-        MoveErrorCollector {\n-            errors: Vec::new()\n-        }\n-    }\n-\n-    pub fn add_error(&mut self, error: MoveError<'tcx>) {\n-        self.errors.push(error);\n-    }\n-\n-    pub fn report_potential_errors<'a>(&self, bccx: &BorrowckCtxt<'a, 'tcx>) {\n-        report_move_errors(bccx, &self.errors)\n-    }\n-}\n-\n-pub struct MoveError<'tcx> {\n-    move_from: mc::cmt<'tcx>,\n-    move_to: Option<MovePlace<'tcx>>\n-}\n-\n-impl<'tcx> MoveError<'tcx> {\n-    pub fn with_move_info(move_from: mc::cmt<'tcx>,\n-                          move_to: Option<MovePlace<'tcx>>)\n-                          -> MoveError<'tcx> {\n-        MoveError {\n-            move_from,\n-            move_to,\n-        }\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct MovePlace<'tcx> {\n-    pub span: syntax_pos::Span,\n-    pub name: ast::Name,\n-    pub pat_source: PatternSource<'tcx>,\n-}\n-\n-pub struct GroupedMoveErrors<'tcx> {\n-    move_from: mc::cmt<'tcx>,\n-    move_to_places: Vec<MovePlace<'tcx>>\n-}\n-\n-fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &[MoveError<'tcx>]) {\n-    let grouped_errors = group_errors_with_same_origin(errors);\n-    for error in &grouped_errors {\n-        let mut err = report_cannot_move_out_of(bccx, error.move_from.clone());\n-        let mut is_first_note = true;\n-        match error.move_to_places.get(0) {\n-            Some(&MovePlace { pat_source: PatternSource::LetDecl(ref e), .. }) => {\n-                // ignore patterns that are found at the top-level of a `let`;\n-                // see `get_pattern_source()` for details\n-                let initializer =\n-                    e.init.as_ref().expect(\"should have an initializer to get an error\");\n-                if let Ok(snippet) = bccx.tcx.sess.source_map().span_to_snippet(initializer.span) {\n-                    err.span_suggestion(\n-                        initializer.span,\n-                        \"consider using a reference instead\",\n-                        format!(\"&{}\", snippet),\n-                        Applicability::MaybeIncorrect // using a reference may not be the right fix\n-                    );\n-                }\n-            }\n-            _ => {\n-                for move_to in &error.move_to_places {\n-\n-                    err = note_move_destination(err, move_to.span, move_to.name, is_first_note);\n-                    is_first_note = false;\n-                }\n-            }\n-        }\n-        if let NoteClosureEnv(upvar_id) = error.move_from.note {\n-            err.span_label(bccx.tcx.hir().span(upvar_id.var_path.hir_id),\n-                           \"captured outer variable\");\n-        }\n-        err.emit();\n-        bccx.signal_error();\n-    }\n-}\n-\n-fn group_errors_with_same_origin<'tcx>(errors: &[MoveError<'tcx>])\n-                                       -> Vec<GroupedMoveErrors<'tcx>> {\n-    let mut grouped_errors = Vec::new();\n-    for error in errors {\n-        append_to_grouped_errors(&mut grouped_errors, error)\n-    }\n-    return grouped_errors;\n-\n-    fn append_to_grouped_errors<'tcx>(grouped_errors: &mut Vec<GroupedMoveErrors<'tcx>>,\n-                                      error: &MoveError<'tcx>) {\n-        let move_from_id = error.move_from.hir_id;\n-        debug!(\"append_to_grouped_errors(move_from_id={:?})\", move_from_id);\n-        let move_to = if error.move_to.is_some() {\n-            vec![error.move_to.clone().unwrap()]\n-        } else {\n-            Vec::new()\n-        };\n-        for ge in &mut *grouped_errors {\n-            if move_from_id == ge.move_from.hir_id && error.move_to.is_some() {\n-                debug!(\"appending move_to to list\");\n-                ge.move_to_places.extend(move_to);\n-                return\n-            }\n-        }\n-        debug!(\"found a new move from location\");\n-        grouped_errors.push(GroupedMoveErrors {\n-            move_from: error.move_from.clone(),\n-            move_to_places: move_to\n-        })\n-    }\n-}\n-\n-// (keep in sync with gather_moves::check_and_get_illegal_move_origin )\n-fn report_cannot_move_out_of<'a, 'tcx>(bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-                                       move_from: mc::cmt<'tcx>)\n-                                       -> DiagnosticBuilder<'a> {\n-    match move_from.cat {\n-        Categorization::Deref(_, mc::BorrowedPtr(..)) |\n-        Categorization::Deref(_, mc::UnsafePtr(..)) |\n-        Categorization::Deref(_, mc::Unique) |\n-        Categorization::ThreadLocal(..) |\n-        Categorization::StaticItem => {\n-            bccx.cannot_move_out_of(\n-                move_from.span, &move_from.descriptive_string(bccx.tcx), Origin::Ast)\n-        }\n-        Categorization::Interior(ref b, mc::InteriorElement(ik)) => {\n-            bccx.cannot_move_out_of_interior_noncopy(\n-                move_from.span, b.ty, Some(ik == Kind::Index), Origin::Ast)\n-        }\n-\n-        Categorization::Downcast(ref b, _) |\n-        Categorization::Interior(ref b, mc::InteriorField(_)) => {\n-            match b.ty.sty {\n-                ty::Adt(def, _) if def.has_dtor(bccx.tcx) => {\n-                    bccx.cannot_move_out_of_interior_of_drop(\n-                        move_from.span, b.ty, Origin::Ast)\n-                }\n-                _ => {\n-                    span_bug!(move_from.span, \"this path should not cause illegal move\");\n-                }\n-            }\n-        }\n-\n-        Categorization::Rvalue(..) |\n-        Categorization::Local(..) |\n-        Categorization::Upvar(..) => {\n-            span_bug!(move_from.span, \"this path should not cause illegal move\");\n-        }\n-    }\n-}\n-\n-fn note_move_destination(mut err: DiagnosticBuilder<'_>,\n-                         move_to_span: syntax_pos::Span,\n-                         pat_name: ast::Name,\n-                         is_first_note: bool) -> DiagnosticBuilder<'_> {\n-    if is_first_note {\n-        err.span_label(\n-            move_to_span,\n-            format!(\"hint: to prevent move, use `ref {0}` or `ref mut {0}`\",\n-                     pat_name));\n-        err\n-    } else {\n-        err.span_label(move_to_span,\n-                      format!(\"...and here (use `ref {0}` or `ref mut {0}`)\",\n-                               pat_name));\n-        err\n-    }\n-}"}, {"sha": "9a581cb03ecd030aa330f9445f3656a4b6efaa54", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "removed", "additions": 0, "deletions": 1573, "changes": 1573, "blob_url": "https://github.com/rust-lang/rust/blob/e31911ef8f1f46b7fab6e4f350679822ac7d7f6a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e31911ef8f1f46b7fab6e4f350679822ac7d7f6a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e31911ef8f1f46b7fab6e4f350679822ac7d7f6a", "patch": "@@ -1,1573 +0,0 @@\n-//! See The Book chapter on the borrow checker for more details.\n-\n-#![allow(non_camel_case_types)]\n-\n-pub use LoanPathKind::*;\n-pub use LoanPathElem::*;\n-pub use bckerr_code::*;\n-pub use AliasableViolationKind::*;\n-pub use MovedValueUseKind::*;\n-\n-use InteriorKind::*;\n-\n-use rustc::hir::HirId;\n-use rustc::hir::Node;\n-use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::cfg;\n-use rustc::middle::borrowck::{BorrowCheckResult, SignalledError};\n-use rustc::hir::def_id::{DefId, LocalDefId};\n-use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::mem_categorization::ImmutabilityBlame;\n-use rustc::middle::region;\n-use rustc::middle::free_region::RegionRelations;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::query::Providers;\n-use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n-use rustc_mir::util::suggest_ref_mut;\n-use rustc::util::nodemap::FxHashSet;\n-\n-use std::borrow::Cow;\n-use std::cell::{Cell, RefCell};\n-use std::fmt;\n-use std::rc::Rc;\n-use std::hash::{Hash, Hasher};\n-use syntax::source_map::DesugaringKind;\n-use syntax_pos::{MultiSpan, Span};\n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n-use log::debug;\n-\n-use rustc::hir;\n-\n-use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n-\n-pub mod check_loans;\n-\n-pub mod gather_loans;\n-\n-pub mod move_data;\n-\n-#[derive(Clone, Copy)]\n-pub struct LoanDataFlowOperator;\n-\n-pub type LoanDataFlow<'tcx> = DataFlowContext<'tcx, LoanDataFlowOperator>;\n-\n-pub fn check_crate(tcx: TyCtxt<'_>) {\n-    tcx.par_body_owners(|body_owner_def_id| {\n-        tcx.ensure().borrowck(body_owner_def_id);\n-    });\n-}\n-\n-pub fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers {\n-        borrowck,\n-        ..*providers\n-    };\n-}\n-\n-/// Collection of conclusions determined via borrow checker analyses.\n-pub struct AnalysisData<'tcx> {\n-    pub all_loans: Vec<Loan<'tcx>>,\n-    pub loans: DataFlowContext<'tcx, LoanDataFlowOperator>,\n-    pub move_data: move_data::FlowedMoveData<'tcx>,\n-}\n-\n-fn borrowck(tcx: TyCtxt<'_>, owner_def_id: DefId) -> &BorrowCheckResult {\n-    assert!(tcx.use_ast_borrowck() || tcx.migrate_borrowck());\n-\n-    debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n-\n-    let owner_id = tcx.hir().as_local_hir_id(owner_def_id).unwrap();\n-\n-    match tcx.hir().get(owner_id) {\n-        Node::Ctor(..) => {\n-            // We get invoked with anything that has MIR, but some of\n-            // those things (notably the synthesized constructors from\n-            // tuple structs/variants) do not have an associated body\n-            // and do not need borrowchecking.\n-            return tcx.arena.alloc(BorrowCheckResult {\n-                used_mut_nodes: Default::default(),\n-                signalled_any_error: SignalledError::NoErrorsSeen,\n-            })\n-        }\n-        _ => { }\n-    }\n-\n-    let body_id = tcx.hir().body_owned_by(owner_id);\n-    let tables = tcx.typeck_tables_of(owner_def_id);\n-    let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n-    let body = tcx.hir().body(body_id);\n-    let mut bccx = BorrowckCtxt {\n-        tcx,\n-        tables,\n-        region_scope_tree,\n-        owner_def_id,\n-        body,\n-        used_mut_nodes: Default::default(),\n-        signalled_any_error: Cell::new(SignalledError::NoErrorsSeen),\n-    };\n-\n-    // Eventually, borrowck will always read the MIR, but at the\n-    // moment we do not. So, for now, we always force MIR to be\n-    // constructed for a given fn, since this may result in errors\n-    // being reported and we want that to happen.\n-    //\n-    // Note that `mir_validated` is a \"stealable\" result; the\n-    // thief, `optimized_mir()`, forces borrowck, so we know that\n-    // is not yet stolen.\n-    tcx.ensure().mir_validated(owner_def_id);\n-\n-    // option dance because you can't capture an uninitialized variable\n-    // by mut-ref.\n-    let mut cfg = None;\n-    if let Some(AnalysisData { all_loans,\n-                               loans: loan_dfcx,\n-                               move_data: flowed_moves }) =\n-        build_borrowck_dataflow_data(&mut bccx, false, body_id,\n-                                     |bccx| {\n-                                         cfg = Some(cfg::CFG::new(bccx.tcx, &body));\n-                                         cfg.as_mut().unwrap()\n-                                     })\n-    {\n-        check_loans::check_loans(&mut bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n-    }\n-\n-    tcx.arena.alloc(BorrowCheckResult {\n-        used_mut_nodes: bccx.used_mut_nodes.into_inner(),\n-        signalled_any_error: bccx.signalled_any_error.into_inner(),\n-    })\n-}\n-\n-fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(\n-    this: &mut BorrowckCtxt<'a, 'tcx>,\n-    force_analysis: bool,\n-    body_id: hir::BodyId,\n-    get_cfg: F,\n-) -> Option<AnalysisData<'tcx>>\n-where\n-    F: FnOnce(&mut BorrowckCtxt<'a, 'tcx>) -> &'c cfg::CFG,\n-{\n-    // Check the body of fn items.\n-    let (all_loans, move_data) =\n-        gather_loans::gather_loans_in_fn(this, body_id);\n-\n-    if !force_analysis && move_data.is_empty() && all_loans.is_empty() {\n-        // large arrays of data inserted as constants can take a lot of\n-        // time and memory to borrow-check - see issue #36799. However,\n-        // they don't have places, so no borrow-check is actually needed.\n-        // Recognize that case and skip borrow-checking.\n-        debug!(\"skipping loan propagation for {:?} because of no loans\", body_id);\n-        return None;\n-    } else {\n-        debug!(\"propagating loans in {:?}\", body_id);\n-    }\n-\n-    let cfg = get_cfg(this);\n-    let mut loan_dfcx =\n-        DataFlowContext::new(this.tcx,\n-                             \"borrowck\",\n-                             Some(this.body),\n-                             cfg,\n-                             LoanDataFlowOperator,\n-                             all_loans.len());\n-    for (loan_idx, loan) in all_loans.iter().enumerate() {\n-        loan_dfcx.add_gen(loan.gen_scope.item_local_id(), loan_idx);\n-        loan_dfcx.add_kill(KillFrom::ScopeEnd,\n-                           loan.kill_scope.item_local_id(),\n-                           loan_idx);\n-    }\n-    loan_dfcx.add_kills_from_flow_exits(cfg);\n-    loan_dfcx.propagate(cfg, this.body);\n-\n-    let flowed_moves = move_data::FlowedMoveData::new(move_data,\n-                                                      this,\n-                                                      cfg,\n-                                                      this.body);\n-\n-    Some(AnalysisData { all_loans,\n-                        loans: loan_dfcx,\n-                        move_data:flowed_moves })\n-}\n-\n-/// Accessor for introspective clients inspecting `AnalysisData` and\n-/// the `BorrowckCtxt` itself , e.g., the flowgraph visualizer.\n-pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    body_id: hir::BodyId,\n-    cfg: &cfg::CFG,\n-) -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'tcx>) {\n-    let owner_id = tcx.hir().body_owner(body_id);\n-    let owner_def_id = tcx.hir().local_def_id(owner_id);\n-    let tables = tcx.typeck_tables_of(owner_def_id);\n-    let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n-    let body = tcx.hir().body(body_id);\n-    let mut bccx = BorrowckCtxt {\n-        tcx,\n-        tables,\n-        region_scope_tree,\n-        owner_def_id,\n-        body,\n-        used_mut_nodes: Default::default(),\n-        signalled_any_error: Cell::new(SignalledError::NoErrorsSeen),\n-    };\n-\n-    let dataflow_data = build_borrowck_dataflow_data(&mut bccx, true, body_id, |_| cfg);\n-    (bccx, dataflow_data.unwrap())\n-}\n-\n-// ----------------------------------------------------------------------\n-// Type definitions\n-\n-pub struct BorrowckCtxt<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n-    // tables for the current thing we are checking; set to\n-    // Some in `borrowck_fn` and cleared later\n-    tables: &'a ty::TypeckTables<'tcx>,\n-\n-    region_scope_tree: &'tcx region::ScopeTree,\n-\n-    owner_def_id: DefId,\n-\n-    body: &'tcx hir::Body,\n-\n-    used_mut_nodes: RefCell<FxHashSet<HirId>>,\n-\n-    signalled_any_error: Cell<SignalledError>,\n-}\n-\n-impl BorrowckCtxt<'_, 'tcx> {\n-    fn signal_error(&self) {\n-        self.signalled_any_error.set(SignalledError::SawSomeError);\n-    }\n-}\n-\n-impl BorrowckErrors<'a> for &'a BorrowckCtxt<'_, 'tcx> {\n-    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n-                                                     sp: S,\n-                                                     msg: &str,\n-                                                     code: DiagnosticId)\n-                                                     -> DiagnosticBuilder<'a>\n-    {\n-        self.tcx.sess.struct_span_err_with_code(sp, msg, code)\n-    }\n-\n-    fn struct_span_err<S: Into<MultiSpan>>(self,\n-                                           sp: S,\n-                                           msg: &str)\n-                                           -> DiagnosticBuilder<'a>\n-    {\n-        self.tcx.sess.struct_span_err(sp, msg)\n-    }\n-\n-    fn cancel_if_wrong_origin(self,\n-                              mut diag: DiagnosticBuilder<'a>,\n-                              o: Origin)\n-                              -> DiagnosticBuilder<'a>\n-    {\n-        if !o.should_emit_errors(self.tcx.borrowck_mode()) {\n-            self.tcx.sess.diagnostic().cancel(&mut diag);\n-        }\n-        diag\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Loans and loan paths\n-\n-/// Record of a loan that was issued.\n-pub struct Loan<'tcx> {\n-    index: usize,\n-    loan_path: Rc<LoanPath<'tcx>>,\n-    kind: ty::BorrowKind,\n-    restricted_paths: Vec<Rc<LoanPath<'tcx>>>,\n-\n-    /// gen_scope indicates where loan is introduced. Typically the\n-    /// loan is introduced at the point of the borrow, but in some\n-    /// cases, notably method arguments, the loan may be introduced\n-    /// only later, once it comes into scope. See also\n-    /// `GatherLoanCtxt::compute_gen_scope`.\n-    gen_scope: region::Scope,\n-\n-    /// kill_scope indicates when the loan goes out of scope. This is\n-    /// either when the lifetime expires or when the local variable\n-    /// which roots the loan-path goes out of scope, whichever happens\n-    /// faster. See also `GatherLoanCtxt::compute_kill_scope`.\n-    kill_scope: region::Scope,\n-    span: Span,\n-    cause: euv::LoanCause,\n-}\n-\n-impl<'tcx> Loan<'tcx> {\n-    pub fn loan_path(&self) -> Rc<LoanPath<'tcx>> {\n-        self.loan_path.clone()\n-    }\n-}\n-\n-#[derive(Eq)]\n-pub struct LoanPath<'tcx> {\n-    kind: LoanPathKind<'tcx>,\n-    ty: Ty<'tcx>,\n-}\n-\n-impl<'tcx> PartialEq for LoanPath<'tcx> {\n-    fn eq(&self, that: &LoanPath<'tcx>) -> bool {\n-        self.kind == that.kind\n-    }\n-}\n-\n-impl<'tcx> Hash for LoanPath<'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.kind.hash(state);\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Hash, Debug)]\n-pub enum LoanPathKind<'tcx> {\n-    LpVar(hir::HirId),                          // `x` in README.md\n-    LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n-    LpDowncast(Rc<LoanPath<'tcx>>, DefId), // `x` downcast to particular enum variant\n-    LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem<'tcx>)\n-}\n-\n-impl<'tcx> LoanPath<'tcx> {\n-    fn new(kind: LoanPathKind<'tcx>, ty: Ty<'tcx>) -> LoanPath<'tcx> {\n-        LoanPath { kind: kind, ty: ty }\n-    }\n-\n-    fn to_type(&self) -> Ty<'tcx> { self.ty }\n-\n-    fn has_downcast(&self) -> bool {\n-        match self.kind {\n-            LpDowncast(_, _) => true,\n-            LpExtend(ref lp, _, LpInterior(_, _)) => {\n-                lp.has_downcast()\n-            }\n-            _ => false,\n-        }\n-    }\n-}\n-\n-// FIXME (pnkfelix): See discussion here\n-// https://github.com/pnkfelix/rust/commit/\n-//     b2b39e8700e37ad32b486b9a8409b50a8a53aa51#commitcomment-7892003\n-const DOWNCAST_PRINTED_OPERATOR: &'static str = \" as \";\n-\n-// A local, \"cleaned\" version of `mc::InteriorKind` that drops\n-// information that is not relevant to loan-path analysis. (In\n-// particular, the distinction between how precisely an array-element\n-// is tracked is irrelevant here.)\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum InteriorKind {\n-    InteriorField(mc::FieldIndex),\n-    InteriorElement,\n-}\n-\n-trait ToInteriorKind { fn cleaned(self) -> InteriorKind; }\n-impl ToInteriorKind for mc::InteriorKind {\n-    fn cleaned(self) -> InteriorKind {\n-        match self {\n-            mc::InteriorField(name) => InteriorField(name),\n-            mc::InteriorElement(_) => InteriorElement,\n-        }\n-    }\n-}\n-\n-// This can be:\n-// - a pointer dereference (`*P` in README.md)\n-// - a field reference, with an optional definition of the containing\n-//   enum variant (`P.f` in README.md)\n-// `DefId` is present when the field is part of struct that is in\n-// a variant of an enum. For instance in:\n-// `enum E { X { foo: u32 }, Y { foo: u32 }}`\n-// each `foo` is qualified by the definitition id of the variant (`X` or `Y`).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum LoanPathElem<'tcx> {\n-    LpDeref(mc::PointerKind<'tcx>),\n-    LpInterior(Option<DefId>, InteriorKind),\n-}\n-\n-fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_>) -> HirId {\n-    let closure_id = tcx.hir().local_def_id_to_hir_id(closure_id);\n-    match tcx.hir().get(closure_id) {\n-        Node::Expr(expr) => match expr.node {\n-            hir::ExprKind::Closure(.., body_id, _, _) => {\n-                body_id.hir_id\n-            }\n-            _ => {\n-                bug!(\"encountered non-closure id: {}\", closure_id)\n-            }\n-        },\n-        _ => bug!(\"encountered non-expr id: {}\", closure_id)\n-    }\n-}\n-\n-impl LoanPath<'tcx> {\n-    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'_, 'tcx>) -> region::Scope {\n-        match self.kind {\n-            LpVar(hir_id) => {\n-                bccx.region_scope_tree.var_scope(hir_id.local_id)\n-            }\n-            LpUpvar(upvar_id) => {\n-                let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n-                region::Scope { id: block_id.local_id, data: region::ScopeData::Node }\n-            }\n-            LpDowncast(ref base, _) |\n-            LpExtend(ref base, ..) => base.kill_scope(bccx),\n-        }\n-    }\n-\n-    fn has_fork(&self, other: &LoanPath<'tcx>) -> bool {\n-        match (&self.kind, &other.kind) {\n-            (&LpExtend(ref base, _, LpInterior(opt_variant_id, id)),\n-             &LpExtend(ref base2, _, LpInterior(opt_variant_id2, id2))) =>\n-                if id == id2 && opt_variant_id == opt_variant_id2 {\n-                    base.has_fork(&base2)\n-                } else {\n-                    true\n-                },\n-            (&LpExtend(ref base, _, LpDeref(_)), _) => base.has_fork(other),\n-            (_, &LpExtend(ref base, _, LpDeref(_))) => self.has_fork(&base),\n-            _ => false,\n-        }\n-    }\n-\n-    fn depth(&self) -> usize {\n-        match self.kind {\n-            LpExtend(ref base, _, LpDeref(_)) => base.depth(),\n-            LpExtend(ref base, _, LpInterior(..)) => base.depth() + 1,\n-            _ => 0,\n-        }\n-    }\n-\n-    fn common(&self, other: &LoanPath<'tcx>) -> Option<LoanPath<'tcx>> {\n-        match (&self.kind, &other.kind) {\n-            (&LpExtend(ref base, a, LpInterior(opt_variant_id, id)),\n-             &LpExtend(ref base2, _, LpInterior(opt_variant_id2, id2))) => {\n-                if id == id2 && opt_variant_id == opt_variant_id2 {\n-                    base.common(&base2).map(|x| {\n-                        let xd = x.depth();\n-                        if base.depth() == xd && base2.depth() == xd {\n-                            LoanPath {\n-                                kind: LpExtend(Rc::new(x), a, LpInterior(opt_variant_id, id)),\n-                                ty: self.ty,\n-                            }\n-                        } else {\n-                            x\n-                        }\n-                    })\n-                } else {\n-                    base.common(&base2)\n-                }\n-            }\n-            (&LpExtend(ref base, _, LpDeref(_)), _) => base.common(other),\n-            (_, &LpExtend(ref other, _, LpDeref(_))) => self.common(&other),\n-            (&LpVar(id), &LpVar(id2)) => {\n-                if id == id2 {\n-                    Some(LoanPath { kind: LpVar(id), ty: self.ty })\n-                } else {\n-                    None\n-                }\n-            }\n-            (&LpUpvar(id), &LpUpvar(id2)) => {\n-                if id == id2 {\n-                    Some(LoanPath { kind: LpUpvar(id), ty: self.ty })\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n-}\n-\n-// Avoid \"cannot borrow immutable field `self.x` as mutable\" as that implies that a field *can* be\n-// mutable independently of the struct it belongs to. (#35937)\n-pub fn opt_loan_path_is_field<'tcx>(cmt: &mc::cmt_<'tcx>) -> (Option<Rc<LoanPath<'tcx>>>, bool) {\n-    let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n-\n-    match cmt.cat {\n-        Categorization::Rvalue(..) |\n-        Categorization::ThreadLocal(..) |\n-        Categorization::StaticItem => {\n-            (None, false)\n-        }\n-\n-        Categorization::Local(id) => {\n-            (Some(new_lp(LpVar(id))), false)\n-        }\n-\n-        Categorization::Upvar(mc::Upvar { id, .. }) => {\n-            (Some(new_lp(LpUpvar(id))), false)\n-        }\n-\n-        Categorization::Deref(ref cmt_base, pk) => {\n-            let lp = opt_loan_path_is_field(cmt_base);\n-            (lp.0.map(|lp| {\n-                new_lp(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n-            }), lp.1)\n-        }\n-\n-        Categorization::Interior(ref cmt_base, ik) => {\n-            (opt_loan_path(cmt_base).map(|lp| {\n-                let opt_variant_id = match cmt_base.cat {\n-                    Categorization::Downcast(_, did) =>  Some(did),\n-                    _ => None\n-                };\n-                new_lp(LpExtend(lp, cmt.mutbl, LpInterior(opt_variant_id, ik.cleaned())))\n-            }), true)\n-        }\n-\n-        Categorization::Downcast(ref cmt_base, variant_def_id) => {\n-            let lp = opt_loan_path_is_field(cmt_base);\n-            (lp.0.map(|lp| {\n-                new_lp(LpDowncast(lp, variant_def_id))\n-            }), lp.1)\n-        }\n-    }\n-}\n-\n-/// Computes the `LoanPath` (if any) for a `cmt`.\n-/// Note that this logic is somewhat duplicated in\n-/// the method `compute()` found in `gather_loans::restrictions`,\n-/// which allows it to share common loan path pieces as it\n-/// traverses the CMT.\n-pub fn opt_loan_path<'tcx>(cmt: &mc::cmt_<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n-    opt_loan_path_is_field(cmt).0\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Errors\n-\n-// Errors that can occur\n-#[derive(Debug, PartialEq)]\n-pub enum bckerr_code<'tcx> {\n-    err_mutbl,\n-    /// superscope, subscope, loan cause\n-    err_out_of_scope(ty::Region<'tcx>, ty::Region<'tcx>, euv::LoanCause),\n-    err_borrowed_pointer_too_short(ty::Region<'tcx>, ty::Region<'tcx>), // loan, ptr\n-}\n-\n-// Combination of an error code and the categorization of the expression\n-// that caused it\n-#[derive(Debug, PartialEq)]\n-pub struct BckError<'c, 'tcx> {\n-    span: Span,\n-    cause: AliasableViolationKind,\n-    cmt: &'c mc::cmt_<'tcx>,\n-    code: bckerr_code<'tcx>\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub enum AliasableViolationKind {\n-    MutabilityViolation,\n-    BorrowViolation(euv::LoanCause)\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum MovedValueUseKind {\n-    MovedInUse,\n-    MovedInCapture,\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Misc\n-\n-impl BorrowckCtxt<'_, 'tcx> {\n-    pub fn is_subregion_of(&self,\n-                           r_sub: ty::Region<'tcx>,\n-                           r_sup: ty::Region<'tcx>)\n-                           -> bool\n-    {\n-        let region_rels = RegionRelations::new(self.tcx,\n-                                               self.owner_def_id,\n-                                               &self.region_scope_tree,\n-                                               &self.tables.free_region_map);\n-        region_rels.is_subregion_of(r_sub, r_sup)\n-    }\n-\n-    pub fn report(&self, err: BckError<'a, 'tcx>) {\n-        // Catch and handle some particular cases.\n-        match (&err.code, &err.cause) {\n-            (&err_out_of_scope(&ty::ReScope(_), &ty::ReStatic, _),\n-             &BorrowViolation(euv::ClosureCapture(span))) |\n-            (&err_out_of_scope(&ty::ReScope(_), &ty::ReEarlyBound(..), _),\n-             &BorrowViolation(euv::ClosureCapture(span))) |\n-            (&err_out_of_scope(&ty::ReScope(_), &ty::ReFree(..), _),\n-             &BorrowViolation(euv::ClosureCapture(span))) => {\n-                return self.report_out_of_scope_escaping_closure_capture(&err, span);\n-            }\n-            _ => { }\n-        }\n-\n-        self.report_bckerr(&err);\n-    }\n-\n-    pub fn report_use_of_moved_value(&self,\n-                                     use_span: Span,\n-                                     use_kind: MovedValueUseKind,\n-                                     lp: &LoanPath<'tcx>,\n-                                     the_move: &move_data::Move,\n-                                     moved_lp: &LoanPath<'tcx>) {\n-        let (verb, verb_participle) = match use_kind {\n-            MovedInUse => (\"use\", \"used\"),\n-            MovedInCapture => (\"capture\", \"captured\"),\n-        };\n-\n-        let (_ol, _moved_lp_msg, mut err, need_note) = match the_move.kind {\n-            move_data::Declared => {\n-                // If this is an uninitialized variable, just emit a simple warning\n-                // and return.\n-                self.cannot_act_on_uninitialized_variable(use_span,\n-                                                          verb,\n-                                                          &self.loan_path_to_string(lp),\n-                                                          Origin::Ast)\n-                    .span_label(use_span, format!(\"use of possibly uninitialized `{}`\",\n-                                                  self.loan_path_to_string(lp)))\n-                    .emit();\n-                self.signal_error();\n-                return;\n-            }\n-            _ => {\n-                // If moved_lp is something like `x.a`, and lp is something like `x.b`, we would\n-                // normally generate a rather confusing message:\n-                //\n-                //     error: use of moved value: `x.b`\n-                //     note: `x.a` moved here...\n-                //\n-                // What we want to do instead is get the 'common ancestor' of the two moves and\n-                // use that for most of the message instead, giving is something like this:\n-                //\n-                //     error: use of moved value: `x`\n-                //     note: `x` moved here (through moving `x.a`)...\n-\n-                let common = moved_lp.common(lp);\n-                let has_common = common.is_some();\n-                let has_fork = moved_lp.has_fork(lp);\n-                let (nl, ol, moved_lp_msg) =\n-                    if has_fork && has_common {\n-                        let nl = self.loan_path_to_string(&common.unwrap());\n-                        let ol = nl.clone();\n-                        let moved_lp_msg = format!(\" (through moving `{}`)\",\n-                                                   self.loan_path_to_string(moved_lp));\n-                        (nl, ol, moved_lp_msg)\n-                    } else {\n-                        (self.loan_path_to_string(lp),\n-                         self.loan_path_to_string(moved_lp),\n-                         String::new())\n-                    };\n-\n-                let partial = moved_lp.depth() > lp.depth();\n-                let msg = if !has_fork && partial { \"partially \" }\n-                          else if has_fork && !has_common { \"collaterally \"}\n-                else { \"\" };\n-                let mut err = self.cannot_act_on_moved_value(use_span,\n-                                                             verb,\n-                                                             msg,\n-                                                             Some(nl),\n-                                                             Origin::Ast);\n-                let need_note = match lp.ty.sty {\n-                    ty::Closure(id, _) => {\n-                        let hir_id = self.tcx.hir().as_local_hir_id(id).unwrap();\n-                        if let Some((span, name)) = self.tables.closure_kind_origins().get(hir_id) {\n-                            err.span_note(*span, &format!(\n-                                \"closure cannot be invoked more than once because \\\n-                                it moves the variable `{}` out of its environment\",\n-                                name\n-                            ));\n-                            false\n-                        } else {\n-                            true\n-                        }\n-                    }\n-                    _ => true,\n-                };\n-                (ol, moved_lp_msg, err, need_note)\n-            }\n-        };\n-\n-        // Get type of value and span where it was previously\n-        // moved.\n-        let hir_id = hir::HirId {\n-            owner: self.body.value.hir_id.owner,\n-            local_id: the_move.id\n-        };\n-        let (move_span, move_note) = match the_move.kind {\n-            move_data::Declared => {\n-                unreachable!();\n-            }\n-\n-            move_data::MoveExpr |\n-            move_data::MovePat => (self.tcx.hir().span(hir_id), \"\"),\n-\n-            move_data::Captured =>\n-                (match self.tcx.hir().expect_expr(hir_id).node {\n-                    hir::ExprKind::Closure(.., fn_decl_span, _) => fn_decl_span,\n-                    ref r => bug!(\"Captured({:?}) maps to non-closure: {:?}\",\n-                                  the_move.id, r),\n-                }, \" (into closure)\"),\n-        };\n-\n-        // Annotate the use and the move in the span. Watch out for\n-        // the case where the use and the move are the same. This\n-        // means the use is in a loop.\n-        err = if use_span == move_span {\n-            err.span_label(\n-                use_span,\n-                format!(\"value moved{} here in previous iteration of loop\",\n-                         move_note));\n-            err\n-        } else {\n-            err.span_label(use_span, format!(\"value {} here after move\", verb_participle));\n-            err.span_label(move_span, format!(\"value moved{} here\", move_note));\n-            err\n-        };\n-\n-        if need_note {\n-            err.note(&format!(\n-                \"move occurs because {} has type `{}`, which does not implement the `Copy` trait\",\n-                if moved_lp.has_downcast() {\n-                    \"the value\".to_string()\n-                } else {\n-                    format!(\"`{}`\", self.loan_path_to_string(moved_lp))\n-                },\n-                moved_lp.ty));\n-        }\n-        if let (Some(DesugaringKind::ForLoop), Ok(snippet)) = (\n-            move_span.desugaring_kind(),\n-            self.tcx.sess.source_map().span_to_snippet(move_span),\n-         ) {\n-            if !snippet.starts_with(\"&\") {\n-                err.span_suggestion(\n-                    move_span,\n-                    \"consider borrowing this to avoid moving it into the for loop\",\n-                    format!(\"&{}\", snippet),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-        }\n-\n-        // Note: we used to suggest adding a `ref binding` or calling\n-        // `clone` but those suggestions have been removed because\n-        // they are often not what you actually want to do, and were\n-        // not considered particularly helpful.\n-\n-        err.emit();\n-        self.signal_error();\n-    }\n-\n-    pub fn report_partial_reinitialization_of_uninitialized_structure(\n-            &self,\n-            span: Span,\n-            lp: &LoanPath<'tcx>) {\n-        self.cannot_partially_reinit_an_uninit_struct(span,\n-                                                      &self.loan_path_to_string(lp),\n-                                                      Origin::Ast)\n-            .emit();\n-        self.signal_error();\n-    }\n-\n-    pub fn report_reassigned_immutable_variable(&self,\n-                                                span: Span,\n-                                                lp: &LoanPath<'tcx>,\n-                                                assign:\n-                                                &move_data::Assignment) {\n-        let mut err = self.cannot_reassign_immutable(span,\n-                                                     &self.loan_path_to_string(lp),\n-                                                     false,\n-                                                     Origin::Ast);\n-        err.span_label(span, \"cannot assign twice to immutable variable\");\n-        if span != assign.span {\n-            err.span_label(assign.span, format!(\"first assignment to `{}`\",\n-                                                self.loan_path_to_string(lp)));\n-        }\n-        err.emit();\n-        self.signal_error();\n-    }\n-\n-    fn report_bckerr(&self, err: &BckError<'a, 'tcx>) {\n-        let error_span = err.span.clone();\n-\n-        match err.code {\n-            err_mutbl => {\n-                let descr: Cow<'static, str> = match err.cmt.note {\n-                    mc::NoteClosureEnv(_) | mc::NoteUpvarRef(_) => {\n-                        self.cmt_to_cow_str(&err.cmt)\n-                    }\n-                    _ => match opt_loan_path_is_field(&err.cmt) {\n-                        (None, true) => {\n-                            format!(\"{} of {} binding\",\n-                                    self.cmt_to_cow_str(&err.cmt),\n-                                    err.cmt.mutbl.to_user_str()).into()\n-\n-                        }\n-                        (None, false) => {\n-                            format!(\"{} {}\",\n-                                    err.cmt.mutbl.to_user_str(),\n-                                    self.cmt_to_cow_str(&err.cmt)).into()\n-\n-                        }\n-                        (Some(lp), true) => {\n-                            format!(\"{} `{}` of {} binding\",\n-                                    self.cmt_to_cow_str(&err.cmt),\n-                                    self.loan_path_to_string(&lp),\n-                                    err.cmt.mutbl.to_user_str()).into()\n-                        }\n-                        (Some(lp), false) => {\n-                            format!(\"{} {} `{}`\",\n-                                    err.cmt.mutbl.to_user_str(),\n-                                    self.cmt_to_cow_str(&err.cmt),\n-                                    self.loan_path_to_string(&lp)).into()\n-                        }\n-                    }\n-                };\n-\n-                let mut db = match err.cause {\n-                    MutabilityViolation => {\n-                        let mut db = self.cannot_assign(error_span, &descr, Origin::Ast);\n-                        if let mc::NoteClosureEnv(upvar_id) = err.cmt.note {\n-                            let hir_id = upvar_id.var_path.hir_id;\n-                            let sp = self.tcx.hir().span(hir_id);\n-                            let fn_closure_msg = \"`Fn` closures cannot capture their enclosing \\\n-                                                  environment for modifications\";\n-                            match (self.tcx.sess.source_map().span_to_snippet(sp), &err.cmt.cat) {\n-                                (_, &Categorization::Upvar(mc::Upvar {\n-                                    kind: ty::ClosureKind::Fn, ..\n-                                })) => {\n-                                    db.note(fn_closure_msg);\n-                                    // we should point at the cause for this closure being\n-                                    // identified as `Fn` (like in signature of method this\n-                                    // closure was passed into)\n-                                }\n-                                (Ok(ref snippet), ref cat) => {\n-                                    let msg = &format!(\"consider making `{}` mutable\", snippet);\n-                                    let suggestion = format!(\"mut {}\", snippet);\n-\n-                                    if let &Categorization::Deref(ref cmt, _) = cat {\n-                                        if let Categorization::Upvar(mc::Upvar {\n-                                            kind: ty::ClosureKind::Fn, ..\n-                                        }) = cmt.cat {\n-                                            db.note(fn_closure_msg);\n-                                        } else {\n-                                            db.span_suggestion(\n-                                                sp,\n-                                                msg,\n-                                                suggestion,\n-                                                Applicability::Unspecified,\n-                                            );\n-                                        }\n-                                    } else {\n-                                        db.span_suggestion(\n-                                            sp,\n-                                            msg,\n-                                            suggestion,\n-                                            Applicability::Unspecified,\n-                                        );\n-                                    }\n-                                }\n-                                _ => {\n-                                    db.span_help(sp, \"consider making this binding mutable\");\n-                                }\n-                            }\n-                        }\n-\n-                        db\n-                    }\n-                    BorrowViolation(euv::ClosureCapture(_)) => {\n-                        self.closure_cannot_assign_to_borrowed(error_span, &descr, Origin::Ast)\n-                    }\n-                    BorrowViolation(euv::OverloadedOperator) |\n-                    BorrowViolation(euv::AddrOf) |\n-                    BorrowViolation(euv::RefBinding) |\n-                    BorrowViolation(euv::AutoRef) |\n-                    BorrowViolation(euv::AutoUnsafe) |\n-                    BorrowViolation(euv::ForLoop) |\n-                    BorrowViolation(euv::MatchDiscriminant) => {\n-                        self.cannot_borrow_path_as_mutable(error_span, &descr, Origin::Ast)\n-                    }\n-                    BorrowViolation(euv::ClosureInvocation) => {\n-                        span_bug!(err.span, \"err_mutbl with a closure invocation\");\n-                    }\n-                };\n-\n-                // We add a special note about `IndexMut`, if the source of this error\n-                // is the fact that `Index` is implemented, but `IndexMut` is not. Needing\n-                // to implement two traits for \"one operator\" is not very intuitive for\n-                // many programmers.\n-                if err.cmt.note == mc::NoteIndex {\n-                    let node = self.tcx.hir().get(err.cmt.hir_id);\n-\n-                    // This pattern probably always matches.\n-                    if let Node::Expr(\n-                        hir::Expr { node: hir::ExprKind::Index(lhs, _), ..}\n-                    ) = node {\n-                        let ty = self.tables.expr_ty(lhs);\n-\n-                        db.help(&format!(\n-                            \"trait `IndexMut` is required to modify indexed content, but \\\n-                             it is not implemented for `{}`\",\n-                            ty\n-                        ));\n-                    }\n-                }\n-\n-                self.note_and_explain_mutbl_error(&mut db, &err, &error_span);\n-                self.note_immutability_blame(\n-                    &mut db,\n-                    err.cmt.immutability_blame(),\n-                    err.cmt.hir_id\n-                );\n-                db.emit();\n-                self.signal_error();\n-            }\n-            err_out_of_scope(super_scope, sub_scope, cause) => {\n-                let msg = match opt_loan_path(&err.cmt) {\n-                    None => \"borrowed value\".to_string(),\n-                    Some(lp) => {\n-                        format!(\"`{}`\", self.loan_path_to_string(&lp))\n-                    }\n-                };\n-\n-                let mut db = self.path_does_not_live_long_enough(error_span, &msg, Origin::Ast);\n-                let value_kind = match err.cmt.cat {\n-                    mc::Categorization::Rvalue(..) => \"temporary value\",\n-                    _ => \"borrowed value\",\n-                };\n-\n-                let is_closure = match cause {\n-                    euv::ClosureCapture(s) => {\n-                        // The primary span starts out as the closure creation point.\n-                        // Change the primary span here to highlight the use of the variable\n-                        // in the closure, because it seems more natural. Highlight\n-                        // closure creation point as a secondary span.\n-                        match db.span.primary_span() {\n-                            Some(primary) => {\n-                                db.span = MultiSpan::from_span(s);\n-                                db.span_label(primary, \"capture occurs here\");\n-                                db.span_label(s, format!(\"{} does not live long enough\",\n-                                                         value_kind));\n-                                true\n-                            }\n-                            None => false\n-                        }\n-                    }\n-                    _ => {\n-                        db.span_label(error_span, format!(\"{} does not live long enough\",\n-                                                          value_kind));\n-                        false\n-                    }\n-                };\n-\n-                let sub_span = self.region_end_span(sub_scope);\n-                let super_span = self.region_end_span(super_scope);\n-\n-                match (sub_span, super_span) {\n-                    (Some(s1), Some(s2)) if s1 == s2 => {\n-                        if !is_closure {\n-                            let msg = match opt_loan_path(&err.cmt) {\n-                                None => value_kind.to_string(),\n-                                Some(lp) => {\n-                                    format!(\"`{}`\", self.loan_path_to_string(&lp))\n-                                }\n-                            };\n-                            db.span_label(s1,\n-                                          format!(\"{} dropped here while still borrowed\", msg));\n-                        } else {\n-                            db.span_label(s1, format!(\"{} dropped before borrower\", value_kind));\n-                        }\n-                        db.note(\"values in a scope are dropped in the opposite order \\\n-                                they are created\");\n-                    }\n-                    (Some(s1), Some(s2)) if !is_closure => {\n-                        let msg = match opt_loan_path(&err.cmt) {\n-                            None => value_kind.to_string(),\n-                            Some(lp) => {\n-                                format!(\"`{}`\", self.loan_path_to_string(&lp))\n-                            }\n-                        };\n-                        db.span_label(s2, format!(\"{} dropped here while still borrowed\", msg));\n-                        db.span_label(s1, format!(\"{} needs to live until here\", value_kind));\n-                    }\n-                    _ => {\n-                        match sub_span {\n-                            Some(s) => {\n-                                db.span_label(s, format!(\"{} needs to live until here\",\n-                                                          value_kind));\n-                            }\n-                            None => {\n-                                self.tcx.note_and_explain_region(\n-                                    &self.region_scope_tree,\n-                                    &mut db,\n-                                    \"borrowed value must be valid for \",\n-                                    sub_scope,\n-                                    \"...\");\n-                            }\n-                        }\n-                        match super_span {\n-                            Some(s) => {\n-                                db.span_label(s, format!(\"{} only lives until here\", value_kind));\n-                            }\n-                            None => {\n-                                self.tcx.note_and_explain_region(\n-                                    &self.region_scope_tree,\n-                                    &mut db,\n-                                    \"...but borrowed value is only valid for \",\n-                                    super_scope,\n-                                    \"\");\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                if let ty::ReScope(scope) = *super_scope {\n-                    let hir_id = scope.hir_id(&self.region_scope_tree);\n-                    match self.tcx.hir().find(hir_id) {\n-                        Some(Node::Stmt(_)) => {\n-                            if *sub_scope != ty::ReStatic {\n-                                db.note(\"consider using a `let` binding to increase its lifetime\");\n-                            }\n-\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-\n-                db.emit();\n-                self.signal_error();\n-            }\n-            err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n-                let descr = self.cmt_to_path_or_string(err.cmt);\n-                let mut db = self.lifetime_too_short_for_reborrow(error_span, &descr, Origin::Ast);\n-                let descr: Cow<'static, str> = match opt_loan_path(&err.cmt) {\n-                    Some(lp) => {\n-                        format!(\"`{}`\", self.loan_path_to_string(&lp)).into()\n-                    }\n-                    None => self.cmt_to_cow_str(&err.cmt)\n-                };\n-                self.tcx.note_and_explain_region(\n-                    &self.region_scope_tree,\n-                    &mut db,\n-                    &format!(\"{} would have to be valid for \",\n-                            descr),\n-                    loan_scope,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(\n-                    &self.region_scope_tree,\n-                    &mut db,\n-                    &format!(\"...but {} is only valid for \", descr),\n-                    ptr_scope,\n-                    \"\");\n-\n-                db.emit();\n-                self.signal_error();\n-            }\n-        }\n-    }\n-\n-    pub fn report_aliasability_violation(&self,\n-                                         span: Span,\n-                                         kind: AliasableViolationKind,\n-                                         cause: mc::AliasableReason,\n-                                         cmt: &mc::cmt_<'tcx>) {\n-        let mut is_closure = false;\n-        let prefix = match kind {\n-            MutabilityViolation => {\n-                \"cannot assign to data\"\n-            }\n-            BorrowViolation(euv::ClosureCapture(_)) |\n-            BorrowViolation(euv::OverloadedOperator) |\n-            BorrowViolation(euv::AddrOf) |\n-            BorrowViolation(euv::AutoRef) |\n-            BorrowViolation(euv::AutoUnsafe) |\n-            BorrowViolation(euv::RefBinding) |\n-            BorrowViolation(euv::MatchDiscriminant) => {\n-                \"cannot borrow data mutably\"\n-            }\n-            BorrowViolation(euv::ClosureInvocation) => {\n-                is_closure = true;\n-                \"closure invocation\"\n-            }\n-\n-            BorrowViolation(euv::ForLoop) => {\n-                \"`for` loop\"\n-            }\n-        };\n-\n-        match cause {\n-            mc::AliasableStaticMut => {\n-                // This path cannot occur. `static mut X` is not checked\n-                // for aliasability violations.\n-                span_bug!(span, \"aliasability violation for static mut `{}`\", prefix)\n-            }\n-            mc::AliasableStatic | mc::AliasableBorrowed => {}\n-        };\n-        let blame = cmt.immutability_blame();\n-        let mut err = match blame {\n-            Some(ImmutabilityBlame::ClosureEnv(id)) => {\n-                // FIXME: the distinction between these 2 messages looks wrong.\n-                let help_msg = if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n-                    // The aliasability violation with closure captures can\n-                    // happen for nested closures, so we know the enclosing\n-                    // closure incorrectly accepts an `Fn` while it needs to\n-                    // be `FnMut`.\n-                    \"consider changing this to accept closures that implement `FnMut`\"\n-\n-                } else {\n-                    \"consider changing this closure to take self by mutable reference\"\n-                };\n-                let hir_id = self.tcx.hir().local_def_id_to_hir_id(id);\n-                let help_span = self.tcx.hir().span(hir_id);\n-                self.cannot_act_on_capture_in_sharable_fn(span,\n-                                                          prefix,\n-                                                          (help_span, help_msg),\n-                                                          Origin::Ast)\n-            }\n-            _ =>  {\n-                self.cannot_assign_into_immutable_reference(span, prefix,\n-                                                            Origin::Ast)\n-            }\n-        };\n-        self.note_immutability_blame(\n-            &mut err,\n-            blame,\n-            cmt.hir_id\n-        );\n-\n-        if is_closure {\n-            err.help(\"closures behind references must be called via `&mut`\");\n-        }\n-        err.emit();\n-        self.signal_error();\n-    }\n-\n-    /// Given a type, if it is an immutable reference, return a suggestion to make it mutable\n-    fn suggest_mut_for_immutable(&self, pty: &hir::Ty, is_implicit_self: bool) -> Option<String> {\n-        // Check whether the argument is an immutable reference\n-        debug!(\"suggest_mut_for_immutable({:?}, {:?})\", pty, is_implicit_self);\n-        if let hir::TyKind::Rptr(lifetime, hir::MutTy {\n-            mutbl: hir::Mutability::MutImmutable,\n-            ref ty\n-        }) = pty.node {\n-            // Account for existing lifetimes when generating the message\n-            let pointee_snippet = match self.tcx.sess.source_map().span_to_snippet(ty.span) {\n-                Ok(snippet) => snippet,\n-                _ => return None\n-            };\n-\n-            let lifetime_snippet = if !lifetime.is_elided() {\n-                format!(\"{} \", match self.tcx.sess.source_map().span_to_snippet(lifetime.span) {\n-                    Ok(lifetime_snippet) => lifetime_snippet,\n-                    _ => return None\n-                })\n-            } else {\n-                String::new()\n-            };\n-            Some(format!(\"use `&{}mut {}` here to make mutable\",\n-                         lifetime_snippet,\n-                         if is_implicit_self { \"self\" } else { &*pointee_snippet }))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn local_binding_mode(&self, hir_id: hir::HirId) -> ty::BindingMode {\n-        let pat = match self.tcx.hir().get(hir_id) {\n-            Node::Binding(pat) => pat,\n-            node => bug!(\"bad node for local: {:?}\", node)\n-        };\n-\n-        match pat.node {\n-            hir::PatKind::Binding(..) => {\n-                *self.tables\n-                     .pat_binding_modes()\n-                     .get(pat.hir_id)\n-                     .expect(\"missing binding mode\")\n-            }\n-            _ => bug!(\"local is not a binding: {:?}\", pat)\n-        }\n-    }\n-\n-    fn local_ty(&self, hir_id: hir::HirId) -> (Option<&hir::Ty>, bool) {\n-        let parent = self.tcx.hir().get_parent_node(hir_id);\n-        let parent_node = self.tcx.hir().get(parent);\n-\n-        // The parent node is like a fn\n-        if let Some(fn_like) = FnLikeNode::from_node(parent_node) {\n-            // `nid`'s parent's `Body`\n-            let fn_body = self.tcx.hir().body(fn_like.body());\n-            // Get the position of `node_id` in the arguments list\n-            let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.hir_id == hir_id);\n-            if let Some(i) = arg_pos {\n-                // The argument's `Ty`\n-                (Some(&fn_like.decl().inputs[i]),\n-                 i == 0 && fn_like.decl().implicit_self.has_implicit_self())\n-            } else {\n-                (None, false)\n-            }\n-        } else {\n-            (None, false)\n-        }\n-    }\n-\n-    fn note_immutability_blame(&self,\n-                               db: &mut DiagnosticBuilder<'_>,\n-                               blame: Option<ImmutabilityBlame<'_>>,\n-                               error_hir_id: hir::HirId) {\n-        match blame {\n-            None => {}\n-            Some(ImmutabilityBlame::ClosureEnv(_)) => {}\n-            Some(ImmutabilityBlame::ImmLocal(hir_id)) => {\n-                self.note_immutable_local(db, error_hir_id, hir_id)\n-            }\n-            Some(ImmutabilityBlame::LocalDeref(hir_id)) => {\n-                match self.local_binding_mode(hir_id) {\n-                    ty::BindByReference(..) => {\n-                        let let_span = self.tcx.hir().span(hir_id);\n-                        let suggestion = suggest_ref_mut(self.tcx, let_span);\n-                        if let Some(replace_str) = suggestion {\n-                            db.span_suggestion(\n-                                let_span,\n-                                \"use a mutable reference instead\",\n-                                replace_str,\n-                                // I believe this can be machine applicable,\n-                                // but if there are multiple attempted uses of an immutable\n-                                // reference, I don't know how rustfix handles it, it might\n-                                // attempt fixing them multiple times.\n-                                //                              @estebank\n-                                Applicability::Unspecified,\n-                            );\n-                        }\n-                    }\n-                    ty::BindByValue(..) => {\n-                        if let (Some(local_ty), is_implicit_self) = self.local_ty(hir_id) {\n-                            if let Some(msg) =\n-                                 self.suggest_mut_for_immutable(local_ty, is_implicit_self) {\n-                                db.span_label(local_ty.span, msg);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            Some(ImmutabilityBlame::AdtFieldDeref(_, field)) => {\n-                let hir_id = match self.tcx.hir().as_local_hir_id(field.did) {\n-                    Some(hir_id) => hir_id,\n-                    None => return\n-                };\n-\n-                if let Node::Field(ref field) = self.tcx.hir().get(hir_id) {\n-                    if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n-                        db.span_label(field.ty.span, msg);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-     // Suggest a fix when trying to mutably borrow an immutable local\n-     // binding: either to make the binding mutable (if its type is\n-     // not a mutable reference) or to avoid borrowing altogether\n-    fn note_immutable_local(&self,\n-                            db: &mut DiagnosticBuilder<'_>,\n-                            borrowed_hir_id: hir::HirId,\n-                            binding_hir_id: hir::HirId) {\n-        let let_span = self.tcx.hir().span(binding_hir_id);\n-        if let ty::BindByValue(..) = self.local_binding_mode(binding_hir_id) {\n-            if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(let_span) {\n-                let (ty, is_implicit_self) = self.local_ty(binding_hir_id);\n-                if is_implicit_self && snippet != \"self\" {\n-                    // avoid suggesting `mut &self`.\n-                    return\n-                }\n-                if let Some(&hir::TyKind::Rptr(\n-                    _,\n-                    hir::MutTy {\n-                        mutbl: hir::MutMutable,\n-                        ..\n-                    },\n-                )) = ty.map(|t| &t.node)\n-                {\n-                    let borrow_expr_id = self.tcx.hir().get_parent_node(borrowed_hir_id);\n-                    db.span_suggestion(\n-                        self.tcx.hir().span(borrow_expr_id),\n-                        \"consider removing the `&mut`, as it is an \\\n-                        immutable binding to a mutable reference\",\n-                        snippet,\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    db.span_suggestion(\n-                        let_span,\n-                        \"make this binding mutable\",\n-                        format!(\"mut {}\", snippet),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    fn report_out_of_scope_escaping_closure_capture(&self,\n-                                                    err: &BckError<'a, 'tcx>,\n-                                                    capture_span: Span)\n-    {\n-        let cmt_path_or_string = self.cmt_to_path_or_string(&err.cmt);\n-\n-        let suggestion =\n-            match self.tcx.sess.source_map().span_to_snippet(err.span) {\n-                Ok(string) => format!(\"move {}\", string),\n-                Err(_) => \"move |<args>| <body>\".to_string()\n-            };\n-\n-        self.cannot_capture_in_long_lived_closure(err.span,\n-                                                  &cmt_path_or_string,\n-                                                  capture_span,\n-                                                  Origin::Ast)\n-            .span_suggestion(\n-                 err.span,\n-                 &format!(\"to force the closure to take ownership of {} \\\n-                           (and any other referenced variables), \\\n-                           use the `move` keyword\",\n-                           cmt_path_or_string),\n-                 suggestion,\n-                 Applicability::MachineApplicable,\n-            )\n-            .emit();\n-        self.signal_error();\n-    }\n-\n-    fn region_end_span(&self, region: ty::Region<'tcx>) -> Option<Span> {\n-        match *region {\n-            ty::ReScope(scope) => {\n-                Some(self.tcx.sess.source_map().end_point(\n-                        scope.span(self.tcx, &self.region_scope_tree)))\n-            }\n-            _ => None\n-        }\n-    }\n-\n-    fn note_and_explain_mutbl_error(&self, db: &mut DiagnosticBuilder<'_>, err: &BckError<'a, 'tcx>,\n-                                    error_span: &Span) {\n-        match err.cmt.note {\n-            mc::NoteClosureEnv(upvar_id) | mc::NoteUpvarRef(upvar_id) => {\n-                // If this is an `Fn` closure, it simply can't mutate upvars.\n-                // If it's an `FnMut` closure, the original variable was declared immutable.\n-                // We need to determine which is the case here.\n-                let kind = match err.cmt.upvar_cat().unwrap() {\n-                    Categorization::Upvar(mc::Upvar { kind, .. }) => kind,\n-                    _ => bug!()\n-                };\n-                if *kind == ty::ClosureKind::Fn {\n-                    let closure_hir_id =\n-                        self.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id);\n-                    db.span_help(self.tcx.hir().span(closure_hir_id),\n-                                 \"consider changing this closure to take \\\n-                                  self by mutable reference\");\n-                }\n-            }\n-            _ => {\n-                if let Categorization::Deref(..) = err.cmt.cat {\n-                    db.span_label(*error_span, \"cannot borrow as mutable\");\n-                } else if let Categorization::Local(local_id) = err.cmt.cat {\n-                    let span = self.tcx.hir().span(local_id);\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                        if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n-                            db.span_label(*error_span, \"cannot reborrow mutably\");\n-                            db.span_label(*error_span, \"try removing `&mut` here\");\n-                        } else {\n-                            db.span_label(*error_span, \"cannot borrow mutably\");\n-                        }\n-                    } else {\n-                        db.span_label(*error_span, \"cannot borrow mutably\");\n-                    }\n-                } else if let Categorization::Interior(ref cmt, _) = err.cmt.cat {\n-                    if let mc::MutabilityCategory::McImmutable = cmt.mutbl {\n-                        db.span_label(*error_span,\n-                                      \"cannot mutably borrow field of immutable binding\");\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    pub fn append_loan_path_to_string(&self,\n-                                      loan_path: &LoanPath<'tcx>,\n-                                      out: &mut String) {\n-        match loan_path.kind {\n-            LpUpvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id: id }, closure_expr_id: _ }) => {\n-                out.push_str(&self.tcx.hir().name(id).as_str());\n-            }\n-            LpVar(id) => {\n-                out.push_str(&self.tcx.hir().name(id).as_str());\n-            }\n-\n-            LpDowncast(ref lp_base, variant_def_id) => {\n-                out.push('(');\n-                self.append_loan_path_to_string(&lp_base, out);\n-                out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&self.tcx.def_path_str(variant_def_id));\n-                out.push(')');\n-            }\n-\n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(mc::FieldIndex(_, info)))) => {\n-                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n-                out.push('.');\n-                out.push_str(&info.as_str());\n-            }\n-\n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) => {\n-                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n-                out.push_str(\"[..]\");\n-            }\n-\n-            LpExtend(ref lp_base, _, LpDeref(_)) => {\n-                out.push('*');\n-                self.append_loan_path_to_string(&lp_base, out);\n-            }\n-        }\n-    }\n-\n-    pub fn append_autoderefd_loan_path_to_string(&self,\n-                                                 loan_path: &LoanPath<'tcx>,\n-                                                 out: &mut String) {\n-        match loan_path.kind {\n-            LpExtend(ref lp_base, _, LpDeref(_)) => {\n-                // For a path like `(*x).f` or `(*x)[3]`, autoderef\n-                // rules would normally allow users to omit the `*x`.\n-                // So just serialize such paths to `x.f` or x[3]` respectively.\n-                self.append_autoderefd_loan_path_to_string(&lp_base, out)\n-            }\n-\n-            LpDowncast(ref lp_base, variant_def_id) => {\n-                out.push('(');\n-                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n-                out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&self.tcx.def_path_str(variant_def_id));\n-                out.push(')');\n-            }\n-\n-            LpVar(..) | LpUpvar(..) | LpExtend(.., LpInterior(..)) => {\n-                self.append_loan_path_to_string(loan_path, out)\n-            }\n-        }\n-    }\n-\n-    pub fn loan_path_to_string(&self, loan_path: &LoanPath<'tcx>) -> String {\n-        let mut result = String::new();\n-        self.append_loan_path_to_string(loan_path, &mut result);\n-        result\n-    }\n-\n-    pub fn cmt_to_cow_str(&self, cmt: &mc::cmt_<'tcx>) -> Cow<'static, str> {\n-        cmt.descriptive_string(self.tcx)\n-    }\n-\n-    pub fn cmt_to_path_or_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n-        match opt_loan_path(cmt) {\n-            Some(lp) => format!(\"`{}`\", self.loan_path_to_string(&lp)),\n-            None => self.cmt_to_cow_str(cmt).into_owned(),\n-        }\n-    }\n-}\n-\n-impl BitwiseOperator for LoanDataFlowOperator {\n-    #[inline]\n-    fn join(&self, succ: usize, pred: usize) -> usize {\n-        succ | pred // loans from both preds are in scope\n-    }\n-}\n-\n-impl DataFlowOperator for LoanDataFlowOperator {\n-    #[inline]\n-    fn initial_value(&self) -> bool {\n-        false // no loans in scope by default\n-    }\n-}\n-\n-impl fmt::Debug for InteriorKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            InteriorField(mc::FieldIndex(_, info)) => write!(f, \"{}\", info),\n-            InteriorElement => write!(f, \"[]\"),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for Loan<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"Loan_{}({:?}, {:?}, {:?}-{:?}, {:?})\",\n-               self.index,\n-               self.loan_path,\n-               self.kind,\n-               self.gen_scope,\n-               self.kill_scope,\n-               self.restricted_paths)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.kind {\n-            LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_string(id)))\n-            }\n-\n-            LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath {hir_id: var_id}, closure_expr_id }) => {\n-                let s = ty::tls::with(|tcx| {\n-                    tcx.hir().node_to_string(var_id)\n-                });\n-                write!(f, \"$({} captured by id={:?})\", s, closure_expr_id)\n-            }\n-\n-            LpDowncast(ref lp, variant_def_id) => {\n-                let variant_str = if variant_def_id.is_local() {\n-                    ty::tls::with(|tcx| tcx.def_path_str(variant_def_id))\n-                } else {\n-                    format!(\"{:?}\", variant_def_id)\n-                };\n-                write!(f, \"({:?}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n-            }\n-\n-            LpExtend(ref lp, _, LpDeref(_)) => {\n-                write!(f, \"{:?}.*\", lp)\n-            }\n-\n-            LpExtend(ref lp, _, LpInterior(_, ref interior)) => {\n-                write!(f, \"{:?}.{:?}\", lp, interior)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for LoanPath<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.kind {\n-            LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().hir_to_user_string(id)))\n-            }\n-\n-            LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {\n-                let s = ty::tls::with(|tcx| {\n-                    tcx.hir().node_to_string(hir_id)\n-                });\n-                write!(f, \"$({} captured by closure)\", s)\n-            }\n-\n-            LpDowncast(ref lp, variant_def_id) => {\n-                let variant_str = if variant_def_id.is_local() {\n-                    ty::tls::with(|tcx| tcx.def_path_str(variant_def_id))\n-                } else {\n-                    format!(\"{:?}\", variant_def_id)\n-                };\n-                write!(f, \"({}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n-            }\n-\n-            LpExtend(ref lp, _, LpDeref(_)) => {\n-                write!(f, \"{}.*\", lp)\n-            }\n-\n-            LpExtend(ref lp, _, LpInterior(_, ref interior)) => {\n-                write!(f, \"{}.{:?}\", lp, interior)\n-            }\n-        }\n-    }\n-}"}, {"sha": "44d8a23fcb9109776ccf7cbd33b0da44f09a32fe", "filename": "src/librustc_borrowck/error_codes.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e31911ef8f1f46b7fab6e4f350679822ac7d7f6a/src%2Flibrustc_borrowck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e31911ef8f1f46b7fab6e4f350679822ac7d7f6a/src%2Flibrustc_borrowck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Ferror_codes.rs?ref=e31911ef8f1f46b7fab6e4f350679822ac7d7f6a", "patch": "@@ -1 +0,0 @@\n-#![allow(non_snake_case)]"}, {"sha": "d4c30dc6c4507b7d3537a5ac4efc4ad6118dfef8", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -18,7 +18,7 @@ rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_target = { path = \"../librustc_target\" }\n-rustc_borrowck = { path = \"../librustc_borrowck\" }\n+rustc_ast_borrowck = { path = \"../librustc_ast_borrowck\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }"}, {"sha": "af0003760443085bae3a5eef048943eb17156ee0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -12,8 +12,8 @@ use rustc::session::config::Input;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::common::ErrorReported;\n use rustc_interface::util::ReplaceBodyWithLoop;\n-use rustc_borrowck as borrowck;\n-use rustc_borrowck::graphviz as borrowck_dot;\n+use rustc_ast_borrowck as borrowck;\n+use rustc_ast_borrowck::graphviz as borrowck_dot;\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast;"}, {"sha": "a0efec5ee7a7f23c7061afbc41a2ced385405c5e", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -19,7 +19,7 @@ syntax_pos = { path = \"../libsyntax_pos\" }\n serialize = { path = \"../libserialize\" }\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n-rustc_borrowck = { path = \"../librustc_borrowck\" }\n+rustc_ast_borrowck = { path = \"../librustc_ast_borrowck\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_traits = { path = \"../librustc_traits\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "bb58d13498996f86fac4b298e968c75e3d48ef26", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -19,7 +19,7 @@ use rustc::session::{CompileResult, CrateDisambiguator, Session};\n use rustc::session::config::{self, CrateType, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc_allocator as allocator;\n-use rustc_borrowck as borrowck;\n+use rustc_ast_borrowck as borrowck;\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_codegen_utils::link::filename_for_metadata;"}, {"sha": "bce6761e2caf76eb769abb1fba54a20aa48ec354", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 108, "deletions": 220, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1b538843503568994c7ef37ea8206f0ee3c2e4/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=1b1b538843503568994c7ef37ea8206f0ee3c2e4", "patch": "@@ -1,34 +1,13 @@\n-use rustc::session::config::BorrowckMode;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n use syntax_pos::{MultiSpan, Span};\n \n-use std::fmt;\n-\n+// FIXME(chrisvittal) remove Origin entirely\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Origin {\n-    Ast,\n     Mir,\n }\n \n-impl fmt::Display for Origin {\n-    fn fmt(&self, _w: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // FIXME(chrisvittal) remove Origin entirely\n-        // Print no origin info\n-        Ok(())\n-    }\n-}\n-\n-impl Origin {\n-    /// Whether we should emit errors for the origin in the given mode\n-    pub fn should_emit_errors(self, mode: BorrowckMode) -> bool {\n-        match self {\n-            Origin::Ast => mode.use_ast(),\n-            Origin::Mir => true,\n-        }\n-    }\n-}\n-\n pub trait BorrowckErrors<'cx>: Sized + Copy {\n     fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         self,\n@@ -39,32 +18,19 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n \n     fn struct_span_err<S: Into<MultiSpan>>(self, sp: S, msg: &str) -> DiagnosticBuilder<'cx>;\n \n-    /// Cancels the given error if we shouldn't emit errors for a given\n-    /// origin in the current mode.\n-    ///\n-    /// Always make sure that the error gets passed through this function\n-    /// before you return it.\n-    fn cancel_if_wrong_origin(\n-        self,\n-        diag: DiagnosticBuilder<'cx>,\n-        o: Origin,\n-    ) -> DiagnosticBuilder<'cx>;\n-\n     fn cannot_move_when_borrowed(\n         self,\n         span: Span,\n         desc: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             span,\n             E0505,\n-            \"cannot move out of `{}` because it is borrowed{OGN}\",\n+            \"cannot move out of `{}` because it is borrowed\",\n             desc,\n-            OGN = o\n-        );\n-        self.cancel_if_wrong_origin(err, o)\n+        )\n     }\n \n     fn cannot_use_when_mutably_borrowed(\n@@ -73,43 +39,39 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         desc: &str,\n         borrow_span: Span,\n         borrow_desc: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             span,\n             E0503,\n-            \"cannot use `{}` because it was mutably borrowed{OGN}\",\n+            \"cannot use `{}` because it was mutably borrowed\",\n             desc,\n-            OGN = o\n         );\n \n         err.span_label(\n             borrow_span,\n             format!(\"borrow of `{}` occurs here\", borrow_desc),\n         );\n         err.span_label(span, format!(\"use of borrowed `{}`\", borrow_desc));\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn cannot_act_on_uninitialized_variable(\n         self,\n         span: Span,\n         verb: &str,\n         desc: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             span,\n             E0381,\n-            \"{} of possibly uninitialized variable: `{}`{OGN}\",\n+            \"{} of possibly uninitialized variable: `{}`\",\n             verb,\n             desc,\n-            OGN = o\n-        );\n-        self.cancel_if_wrong_origin(err, o)\n+        )\n     }\n \n     fn cannot_mutably_borrow_multiply(\n@@ -120,18 +82,17 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         old_loan_span: Span,\n         old_opt_via: &str,\n         old_load_end_span: Option<Span>,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let via = |msg: &str|\n             if msg.is_empty() { msg.to_string() } else { format!(\" (via `{}`)\", msg) };\n         let mut err = struct_span_err!(\n             self,\n             new_loan_span,\n             E0499,\n-            \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n+            \"cannot borrow `{}`{} as mutable more than once at a time\",\n             desc,\n             via(opt_via),\n-            OGN = o\n         );\n         if old_loan_span == new_loan_span {\n             // Both borrows are happening in the same place\n@@ -160,7 +121,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n                 err.span_label(old_load_end_span, \"first borrow ends here\");\n             }\n         }\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn cannot_uniquely_borrow_by_two_closures(\n@@ -169,15 +130,14 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         desc: &str,\n         old_loan_span: Span,\n         old_load_end_span: Option<Span>,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             new_loan_span,\n             E0524,\n-            \"two closures require unique access to `{}` at the same time{OGN}\",\n+            \"two closures require unique access to `{}` at the same time\",\n             desc,\n-            OGN = o\n         );\n         if old_loan_span == new_loan_span {\n             err.span_label(\n@@ -191,7 +151,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         if let Some(old_load_end_span) = old_load_end_span {\n             err.span_label(old_load_end_span, \"borrow from first closure ends here\");\n         }\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn cannot_uniquely_borrow_by_one_closure(\n@@ -204,17 +164,16 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         noun_old: &str,\n         old_opt_via: &str,\n         previous_end_span: Option<Span>,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             new_loan_span,\n             E0500,\n-            \"closure requires unique access to `{}` but {} is already borrowed{}{OGN}\",\n+            \"closure requires unique access to `{}` but {} is already borrowed{}\",\n             desc_new,\n             noun_old,\n             old_opt_via,\n-            OGN = o\n         );\n         err.span_label(\n             new_loan_span,\n@@ -224,7 +183,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         if let Some(previous_end_span) = previous_end_span {\n             err.span_label(previous_end_span, \"borrow ends here\");\n         }\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn cannot_reborrow_already_uniquely_borrowed(\n@@ -238,18 +197,17 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         old_opt_via: &str,\n         previous_end_span: Option<Span>,\n         second_borrow_desc: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             new_loan_span,\n             E0501,\n             \"cannot borrow `{}`{} as {} because previous closure \\\n-             requires unique access{OGN}\",\n+             requires unique access\",\n             desc_new,\n             opt_via,\n             kind_new,\n-            OGN = o\n         );\n         err.span_label(\n             new_loan_span,\n@@ -262,7 +220,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         if let Some(previous_end_span) = previous_end_span {\n             err.span_label(previous_end_span, \"borrow from closure ends here\");\n         }\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn cannot_reborrow_already_borrowed(\n@@ -276,7 +234,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         kind_old: &str,\n         msg_old: &str,\n         old_load_end_span: Option<Span>,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let via = |msg: &str|\n             if msg.is_empty() { msg.to_string() } else { format!(\" (via `{}`)\", msg) };\n@@ -285,14 +243,13 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n             span,\n             E0502,\n             \"cannot borrow `{}`{} as {} because {} is also borrowed \\\n-             as {}{}{OGN}\",\n+             as {}{}\",\n             desc_new,\n             via(msg_new),\n             kind_new,\n             noun_old,\n             kind_old,\n             via(msg_old),\n-            OGN = o\n         );\n \n         if msg_new == \"\" {\n@@ -317,76 +274,66 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         if let Some(old_load_end_span) = old_load_end_span {\n             err.span_label(old_load_end_span, format!(\"{} borrow ends here\", kind_old));\n         }\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn cannot_assign_to_borrowed(\n         self,\n         span: Span,\n         borrow_span: Span,\n         desc: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             span,\n             E0506,\n-            \"cannot assign to `{}` because it is borrowed{OGN}\",\n+            \"cannot assign to `{}` because it is borrowed\",\n             desc,\n-            OGN = o\n         );\n \n         err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", desc));\n         err.span_label(\n             span,\n             format!(\"assignment to borrowed `{}` occurs here\", desc),\n         );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n-    fn cannot_move_into_closure(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+    fn cannot_move_into_closure(self, span: Span, desc: &str, _: Origin) -> DiagnosticBuilder<'cx> {\n+        struct_span_err!(\n             self,\n             span,\n             E0504,\n-            \"cannot move `{}` into closure because it is borrowed{OGN}\",\n+            \"cannot move `{}` into closure because it is borrowed\",\n             desc,\n-            OGN = o\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        )\n     }\n \n     fn cannot_reassign_immutable(\n         self,\n         span: Span,\n         desc: &str,\n         is_arg: bool,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let msg = if is_arg {\n             \"to immutable argument\"\n         } else {\n             \"twice to immutable variable\"\n         };\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             span,\n             E0384,\n-            \"cannot assign {} `{}`{OGN}\",\n+            \"cannot assign {} `{}`\",\n             msg,\n             desc,\n-            OGN = o\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        )\n     }\n \n-    fn cannot_assign(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(self, span, E0594, \"cannot assign to {}{OGN}\", desc, OGN = o);\n-        self.cancel_if_wrong_origin(err, o)\n+    fn cannot_assign(self, span: Span, desc: &str, _: Origin) -> DiagnosticBuilder<'cx> {\n+        struct_span_err!(self, span, E0594, \"cannot assign to {}\", desc)\n     }\n \n     fn cannot_assign_static(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx> {\n@@ -397,18 +344,15 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         self,\n         move_from_span: Span,\n         move_from_desc: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             move_from_span,\n             E0507,\n-            \"cannot move out of {}{OGN}\",\n+            \"cannot move out of {}\",\n             move_from_desc,\n-            OGN = o\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        )\n     }\n \n     /// Signal an error due to an attempt to move out of the interior\n@@ -419,7 +363,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         move_from_span: Span,\n         ty: Ty<'_>,\n         is_index: Option<bool>,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let type_name = match (&ty.sty, is_index) {\n             (&ty::Array(_, _), Some(true)) | (&ty::Array(_, _), None) => \"array\",\n@@ -430,33 +374,29 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n             self,\n             move_from_span,\n             E0508,\n-            \"cannot move out of type `{}`, a non-copy {}{OGN}\",\n+            \"cannot move out of type `{}`, a non-copy {}\",\n             ty,\n             type_name,\n-            OGN = o\n         );\n         err.span_label(move_from_span, \"cannot move out of here\");\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn cannot_move_out_of_interior_of_drop(\n         self,\n         move_from_span: Span,\n         container_ty: Ty<'_>,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             move_from_span,\n             E0509,\n-            \"cannot move out of type `{}`, which implements the `Drop` trait{OGN}\",\n+            \"cannot move out of type `{}`, which implements the `Drop` trait\",\n             container_ty,\n-            OGN = o\n         );\n         err.span_label(move_from_span, \"cannot move out of here\");\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn cannot_act_on_moved_value(\n@@ -465,80 +405,68 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         verb: &str,\n         optional_adverb_for_moved: &str,\n         moved_path: Option<String>,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let moved_path = moved_path\n             .map(|mp| format!(\": `{}`\", mp))\n             .unwrap_or_default();\n \n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             use_span,\n             E0382,\n-            \"{} of {}moved value{}{OGN}\",\n+            \"{} of {}moved value{}\",\n             verb,\n             optional_adverb_for_moved,\n             moved_path,\n-            OGN = o\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        )\n     }\n \n     fn cannot_partially_reinit_an_uninit_struct(\n         self,\n         span: Span,\n         uninit_path: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             span,\n             E0383,\n-            \"partial reinitialization of uninitialized structure `{}`{OGN}\",\n+            \"partial reinitialization of uninitialized structure `{}`\",\n             uninit_path,\n-            OGN = o\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        )\n     }\n \n     fn closure_cannot_assign_to_borrowed(\n         self,\n         span: Span,\n         descr: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             span,\n             E0595,\n-            \"closure cannot assign to {}{OGN}\",\n+            \"closure cannot assign to {}\",\n             descr,\n-            OGN = o\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        )\n     }\n \n     fn cannot_borrow_path_as_mutable_because(\n         self,\n         span: Span,\n         path: &str,\n         reason: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             span,\n             E0596,\n-            \"cannot borrow {} as mutable{}{OGN}\",\n+            \"cannot borrow {} as mutable{}\",\n             path,\n             reason,\n-            OGN = o,\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        )\n     }\n \n     fn cannot_borrow_path_as_mutable(\n@@ -556,73 +484,63 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         match_span: Span,\n         match_place: &str,\n         action: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             mutate_span,\n             E0510,\n-            \"cannot {} `{}` in match guard{OGN}\",\n+            \"cannot {} `{}` in match guard\",\n             action,\n             match_place,\n-            OGN = o\n         );\n         err.span_label(mutate_span, format!(\"cannot {}\", action));\n         err.span_label(match_span, String::from(\"value is immutable in match guard\"));\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn cannot_borrow_across_generator_yield(\n         self,\n         span: Span,\n         yield_span: Span,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             span,\n             E0626,\n-            \"borrow may still be in use when generator yields{OGN}\",\n-            OGN = o\n+            \"borrow may still be in use when generator yields\",\n         );\n         err.span_label(yield_span, \"possible yield occurs here\");\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn cannot_borrow_across_destructor(\n         self,\n         borrow_span: Span,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             borrow_span,\n             E0713,\n-            \"borrow may still be in use when destructor runs{OGN}\",\n-            OGN = o\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+            \"borrow may still be in use when destructor runs\",\n+        )\n     }\n \n     fn path_does_not_live_long_enough(\n         self,\n         span: Span,\n         path: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             span,\n             E0597,\n-            \"{} does not live long enough{OGN}\",\n+            \"{} does not live long enough\",\n             path,\n-            OGN = o\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        )\n     }\n \n     fn cannot_return_reference_to_local(\n@@ -631,160 +549,141 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         return_kind: &str,\n         reference_desc: &str,\n         path_desc: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             span,\n             E0515,\n-            \"cannot {RETURN} {REFERENCE} {LOCAL}{OGN}\",\n+            \"cannot {RETURN} {REFERENCE} {LOCAL}\",\n             RETURN=return_kind,\n             REFERENCE=reference_desc,\n             LOCAL=path_desc,\n-            OGN = o\n         );\n \n         err.span_label(\n             span,\n             format!(\"{}s a {} data owned by the current function\", return_kind, reference_desc),\n         );\n \n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn lifetime_too_short_for_reborrow(\n         self,\n         span: Span,\n         path: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             span,\n             E0598,\n             \"lifetime of {} is too short to guarantee \\\n-             its contents can be safely reborrowed{OGN}\",\n+             its contents can be safely reborrowed\",\n             path,\n-            OGN = o\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        )\n     }\n \n     fn cannot_act_on_capture_in_sharable_fn(\n         self,\n         span: Span,\n         bad_thing: &str,\n         help: (Span, &str),\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let (help_span, help_msg) = help;\n         let mut err = struct_span_err!(\n             self,\n             span,\n             E0387,\n-            \"{} in a captured outer variable in an `Fn` closure{OGN}\",\n+            \"{} in a captured outer variable in an `Fn` closure\",\n             bad_thing,\n-            OGN = o\n         );\n         err.span_help(help_span, help_msg);\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn cannot_assign_into_immutable_reference(\n         self,\n         span: Span,\n         bad_thing: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             span,\n             E0389,\n-            \"{} in a `&` reference{OGN}\",\n+            \"{} in a `&` reference\",\n             bad_thing,\n-            OGN = o\n         );\n         err.span_label(span, \"assignment into an immutable reference\");\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn cannot_capture_in_long_lived_closure(\n         self,\n         closure_span: Span,\n         borrowed_path: &str,\n         capture_span: Span,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let mut err = struct_span_err!(\n             self,\n             closure_span,\n             E0373,\n             \"closure may outlive the current function, \\\n              but it borrows {}, \\\n-             which is owned by the current function{OGN}\",\n+             which is owned by the current function\",\n             borrowed_path,\n-            OGN = o\n         );\n         err.span_label(capture_span, format!(\"{} is borrowed here\", borrowed_path))\n             .span_label(\n                 closure_span,\n                 format!(\"may outlive borrowed value {}\", borrowed_path),\n             );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        err\n     }\n \n     fn borrowed_data_escapes_closure(\n         self,\n         escape_span: Span,\n         escapes_from: &str,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             escape_span,\n             E0521,\n-            \"borrowed data escapes outside of {}{OGN}\",\n+            \"borrowed data escapes outside of {}\",\n             escapes_from,\n-            OGN = o\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+        )\n     }\n \n     fn thread_local_value_does_not_live_long_enough(\n         self,\n         span: Span,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             span,\n             E0712,\n-            \"thread-local variable borrowed past end of function{OGN}\",\n-            OGN = o\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+            \"thread-local variable borrowed past end of function\",\n+        )\n     }\n \n     fn temporary_value_borrowed_for_too_long(\n         self,\n         span: Span,\n-        o: Origin,\n+        _: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let err = struct_span_err!(\n+        struct_span_err!(\n             self,\n             span,\n             E0716,\n-            \"temporary value dropped while borrowed{OGN}\",\n-            OGN = o\n-        );\n-\n-        self.cancel_if_wrong_origin(err, o)\n+            \"temporary value dropped while borrowed\",\n+        )\n     }\n }\n \n@@ -801,15 +700,4 @@ impl BorrowckErrors<'tcx> for TyCtxt<'tcx> {\n     fn struct_span_err<S: Into<MultiSpan>>(self, sp: S, msg: &str) -> DiagnosticBuilder<'tcx> {\n         self.sess.struct_span_err(sp, msg)\n     }\n-\n-    fn cancel_if_wrong_origin(\n-        self,\n-        mut diag: DiagnosticBuilder<'tcx>,\n-        o: Origin,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        if !o.should_emit_errors(self.borrowck_mode()) {\n-            self.sess.diagnostic().cancel(&mut diag);\n-        }\n-        diag\n-    }\n }"}]}