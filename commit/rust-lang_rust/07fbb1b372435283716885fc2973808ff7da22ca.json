{"sha": "07fbb1b372435283716885fc2973808ff7da22ca", "node_id": "C_kwDOAAsO6NoAKDA3ZmJiMWIzNzI0MzUyODM3MTY4ODVmYzI5NzM4MDhmZjdkYTIyY2E", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-06T11:17:49Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-06T11:17:49Z"}, "message": "Cleanup macro-expanded code in `rustc_type_ir`", "tree": {"sha": "a292e664f9aeec32dbf0d8b3efe769992fa16820", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a292e664f9aeec32dbf0d8b3efe769992fa16820"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07fbb1b372435283716885fc2973808ff7da22ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07fbb1b372435283716885fc2973808ff7da22ca", "html_url": "https://github.com/rust-lang/rust/commit/07fbb1b372435283716885fc2973808ff7da22ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07fbb1b372435283716885fc2973808ff7da22ca/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ef685ea39280cc4a4a32f7c3c586d2ce946e8f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef685ea39280cc4a4a32f7c3c586d2ce946e8f0", "html_url": "https://github.com/rust-lang/rust/commit/1ef685ea39280cc4a4a32f7c3c586d2ce946e8f0"}], "stats": {"total": 576, "additions": 199, "deletions": 377}, "files": [{"sha": "0ad1f1a0da72fb63441861d253f918f7a51987f6", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07fbb1b372435283716885fc2973808ff7da22ca/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07fbb1b372435283716885fc2973808ff7da22ca/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=07fbb1b372435283716885fc2973808ff7da22ca", "patch": "@@ -274,7 +274,7 @@ impl Ord for DefId {\n impl PartialOrd for DefId {\n     #[inline]\n     fn partial_cmp(&self, other: &DefId) -> Option<std::cmp::Ordering> {\n-        Some(Ord::cmp(self, other))\n+        Some(self.cmp(other))\n     }\n }\n "}, {"sha": "a6537f41d1e560bc2bc86c2ef3e54b09b9251447", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 198, "deletions": 376, "changes": 574, "blob_url": "https://github.com/rust-lang/rust/blob/07fbb1b372435283716885fc2973808ff7da22ca/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07fbb1b372435283716885fc2973808ff7da22ca/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=07fbb1b372435283716885fc2973808ff7da22ca", "patch": "@@ -301,61 +301,37 @@ impl<I: Interner> Clone for TyKind<I> {\n impl<I: Interner> PartialEq for TyKind<I> {\n     #[inline]\n     fn eq(&self, other: &TyKind<I>) -> bool {\n-        let __self_vi = tykind_discriminant(self);\n-        let __arg_1_vi = tykind_discriminant(other);\n-        if __self_vi == __arg_1_vi {\n-            match (&*self, &*other) {\n-                (&Int(ref __self_0), &Int(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Uint(ref __self_0), &Uint(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Float(ref __self_0), &Float(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Adt(ref __self_0, ref __self_1), &Adt(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+        tykind_discriminant(self) == tykind_discriminant(other)\n+            && match (self, other) {\n+                (Int(a_i), Int(b_i)) => a_i == b_i,\n+                (Uint(a_u), Uint(b_u)) => a_u == b_u,\n+                (Float(a_f), Float(b_f)) => a_f == b_f,\n+                (Adt(a_d, a_s), Adt(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (Foreign(a_d), Foreign(b_d)) => a_d == b_d,\n+                (Array(a_t, a_c), Array(b_t, b_c)) => a_t == b_t && a_c == b_c,\n+                (Slice(a_t), Slice(b_t)) => a_t == b_t,\n+                (RawPtr(a_t), RawPtr(b_t)) => a_t == b_t,\n+                (Ref(a_r, a_t, a_m), Ref(b_r, b_t, b_m)) => a_r == b_r && a_t == b_t && a_m == b_m,\n+                (FnDef(a_d, a_s), FnDef(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (FnPtr(a_s), FnPtr(b_s)) => a_s == b_s,\n+                (Dynamic(a_p, a_r, a_repr), Dynamic(b_p, b_r, b_repr)) => {\n+                    a_p == b_p && a_r == b_r && a_repr == b_repr\n                 }\n-                (&Foreign(ref __self_0), &Foreign(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Array(ref __self_0, ref __self_1), &Array(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                (Closure(a_d, a_s), Closure(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (Generator(a_d, a_s, a_m), Generator(b_d, b_s, b_m)) => {\n+                    a_d == b_d && a_s == b_s && a_m == b_m\n                 }\n-                (&Slice(ref __self_0), &Slice(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&RawPtr(ref __self_0), &RawPtr(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (\n-                    &Ref(ref __self_0, ref __self_1, ref __self_2),\n-                    &Ref(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n-                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && __self_2 == __arg_1_2,\n-                (&FnDef(ref __self_0, ref __self_1), &FnDef(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n-                }\n-                (&FnPtr(ref __self_0), &FnPtr(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (\n-                    &Dynamic(ref __self_0, ref __self_1, ref self_repr),\n-                    &Dynamic(ref __arg_1_0, ref __arg_1_1, ref arg_repr),\n-                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && self_repr == arg_repr,\n-                (&Closure(ref __self_0, ref __self_1), &Closure(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n-                }\n-                (\n-                    &Generator(ref __self_0, ref __self_1, ref __self_2),\n-                    &Generator(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n-                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && __self_2 == __arg_1_2,\n-                (&GeneratorWitness(ref __self_0), &GeneratorWitness(ref __arg_1_0)) => {\n-                    __self_0 == __arg_1_0\n-                }\n-                (&Tuple(ref __self_0), &Tuple(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Projection(ref __self_0), &Projection(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Opaque(ref __self_0, ref __self_1), &Opaque(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n-                }\n-                (&Param(ref __self_0), &Param(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Bound(ref __self_0, ref __self_1), &Bound(ref __arg_1_0, ref __arg_1_1)) => {\n-                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n-                }\n-                (&Placeholder(ref __self_0), &Placeholder(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Infer(ref __self_0), &Infer(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&Error(ref __self_0), &Error(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                _ => true,\n+                (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g == b_g,\n+                (Tuple(a_t), Tuple(b_t)) => a_t == b_t,\n+                (Projection(a_p), Projection(b_p)) => a_p == b_p,\n+                (Opaque(a_d, a_s), Opaque(b_d, b_s)) => a_d == b_d && a_s == b_s,\n+                (Param(a_p), Param(b_p)) => a_p == b_p,\n+                (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d == b_d && a_b == b_b,\n+                (Placeholder(a_p), Placeholder(b_p)) => a_p == b_p,\n+                (Infer(a_t), Infer(b_t)) => a_t == b_t,\n+                (Error(a_e), Error(b_e)) => a_e == b_e,\n+                _ => true, // unreachable\n             }\n-        } else {\n-            false\n-        }\n     }\n }\n \n@@ -366,259 +342,145 @@ impl<I: Interner> Eq for TyKind<I> {}\n impl<I: Interner> PartialOrd for TyKind<I> {\n     #[inline]\n     fn partial_cmp(&self, other: &TyKind<I>) -> Option<Ordering> {\n-        Some(Ord::cmp(self, other))\n+        Some(self.cmp(other))\n     }\n }\n \n // This is manually implemented because a derive would require `I: Ord`\n impl<I: Interner> Ord for TyKind<I> {\n     #[inline]\n     fn cmp(&self, other: &TyKind<I>) -> Ordering {\n-        let __self_vi = tykind_discriminant(self);\n-        let __arg_1_vi = tykind_discriminant(other);\n-        if __self_vi == __arg_1_vi {\n-            match (&*self, &*other) {\n-                (&Int(ref __self_0), &Int(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Uint(ref __self_0), &Uint(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Float(ref __self_0), &Float(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Adt(ref __self_0, ref __self_1), &Adt(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n-                }\n-                (&Foreign(ref __self_0), &Foreign(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Array(ref __self_0, ref __self_1), &Array(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n+        tykind_discriminant(self).cmp(&tykind_discriminant(other)).then_with(|| {\n+            match (self, other) {\n+                (Int(a_i), Int(b_i)) => a_i.cmp(b_i),\n+                (Uint(a_u), Uint(b_u)) => a_u.cmp(b_u),\n+                (Float(a_f), Float(b_f)) => a_f.cmp(b_f),\n+                (Adt(a_d, a_s), Adt(b_d, b_s)) => a_d.cmp(b_d).then_with(|| a_s.cmp(b_s)),\n+                (Foreign(a_d), Foreign(b_d)) => a_d.cmp(b_d),\n+                (Array(a_t, a_c), Array(b_t, b_c)) => a_t.cmp(b_t).then_with(|| a_c.cmp(b_c)),\n+                (Slice(a_t), Slice(b_t)) => a_t.cmp(b_t),\n+                (RawPtr(a_t), RawPtr(b_t)) => a_t.cmp(b_t),\n+                (Ref(a_r, a_t, a_m), Ref(b_r, b_t, b_m)) => {\n+                    a_r.cmp(b_r).then_with(|| a_t.cmp(b_t).then_with(|| a_m.cmp(b_m)))\n                 }\n-                (&Slice(ref __self_0), &Slice(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&RawPtr(ref __self_0), &RawPtr(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (\n-                    &Ref(ref __self_0, ref __self_1, ref __self_2),\n-                    &Ref(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n-                ) => match Ord::cmp(__self_0, __arg_1_0) {\n-                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n-                        Ordering::Equal => Ord::cmp(__self_2, __arg_1_2),\n-                        cmp => cmp,\n-                    },\n-                    cmp => cmp,\n-                },\n-                (&FnDef(ref __self_0, ref __self_1), &FnDef(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n+                (FnDef(a_d, a_s), FnDef(b_d, b_s)) => a_d.cmp(b_d).then_with(|| a_s.cmp(b_s)),\n+                (FnPtr(a_s), FnPtr(b_s)) => a_s.cmp(b_s),\n+                (Dynamic(a_p, a_r, a_repr), Dynamic(b_p, b_r, b_repr)) => {\n+                    a_p.cmp(b_p).then_with(|| a_r.cmp(b_r).then_with(|| a_repr.cmp(b_repr)))\n                 }\n-                (&FnPtr(ref __self_0), &FnPtr(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (\n-                    &Dynamic(ref __self_0, ref __self_1, ref self_repr),\n-                    &Dynamic(ref __arg_1_0, ref __arg_1_1, ref arg_repr),\n-                ) => match Ord::cmp(__self_0, __arg_1_0) {\n-                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n-                        Ordering::Equal => Ord::cmp(self_repr, arg_repr),\n-                        cmp => cmp,\n-                    },\n-                    cmp => cmp,\n-                },\n-                (&Closure(ref __self_0, ref __self_1), &Closure(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n+                (Closure(a_p, a_s), Closure(b_p, b_s)) => a_p.cmp(b_p).then_with(|| a_s.cmp(b_s)),\n+                (Generator(a_d, a_s, a_m), Generator(b_d, b_s, b_m)) => {\n+                    a_d.cmp(b_d).then_with(|| a_s.cmp(b_s).then_with(|| a_m.cmp(b_m)))\n                 }\n-                (\n-                    &Generator(ref __self_0, ref __self_1, ref __self_2),\n-                    &Generator(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n-                ) => match Ord::cmp(__self_0, __arg_1_0) {\n-                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n-                        Ordering::Equal => Ord::cmp(__self_2, __arg_1_2),\n-                        cmp => cmp,\n-                    },\n-                    cmp => cmp,\n-                },\n-                (&GeneratorWitness(ref __self_0), &GeneratorWitness(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n-                }\n-                (&Tuple(ref __self_0), &Tuple(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Projection(ref __self_0), &Projection(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n-                }\n-                (&Opaque(ref __self_0, ref __self_1), &Opaque(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n-                }\n-                (&Param(ref __self_0), &Param(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Bound(ref __self_0, ref __self_1), &Bound(ref __arg_1_0, ref __arg_1_1)) => {\n-                    match Ord::cmp(__self_0, __arg_1_0) {\n-                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                        cmp => cmp,\n-                    }\n-                }\n-                (&Placeholder(ref __self_0), &Placeholder(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n-                }\n-                (&Infer(ref __self_0), &Infer(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&Error(ref __self_0), &Error(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                _ => Ordering::Equal,\n-            }\n-        } else {\n-            Ord::cmp(&__self_vi, &__arg_1_vi)\n-        }\n+                (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g.cmp(b_g),\n+                (Tuple(a_t), Tuple(b_t)) => a_t.cmp(b_t),\n+                (Projection(a_p), Projection(b_p)) => a_p.cmp(b_p),\n+                (Opaque(a_d, a_s), Opaque(b_d, b_s)) => a_d.cmp(b_d).then_with(|| a_s.cmp(b_s)),\n+                (Param(a_p), Param(b_p)) => a_p.cmp(b_p),\n+                (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d.cmp(b_d).then_with(|| a_b.cmp(b_b)),\n+                (Placeholder(a_p), Placeholder(b_p)) => a_p.cmp(b_p),\n+                (Infer(a_t), Infer(b_t)) => a_t.cmp(b_t),\n+                (Error(a_e), Error(b_e)) => a_e.cmp(b_e),\n+                _ => Ordering::Equal, // unreachable\n+            }\n+        })\n     }\n }\n \n // This is manually implemented because a derive would require `I: Hash`\n impl<I: Interner> hash::Hash for TyKind<I> {\n     fn hash<__H: hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n-            (&Int(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Uint(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Float(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Adt(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Foreign(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Array(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Slice(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&RawPtr(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Ref(ref __self_0, ref __self_1, ref __self_2),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state);\n-                hash::Hash::hash(__self_2, state)\n-            }\n-            (&FnDef(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&FnPtr(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Dynamic(ref __self_0, ref __self_1, ref repr),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state);\n-                hash::Hash::hash(repr, state)\n-            }\n-            (&Closure(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Generator(ref __self_0, ref __self_1, ref __self_2),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state);\n-                hash::Hash::hash(__self_2, state)\n-            }\n-            (&GeneratorWitness(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Tuple(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Projection(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Opaque(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Param(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Bound(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&Placeholder(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&Infer(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n+        tykind_discriminant(self).hash(state);\n+        match self {\n+            Int(i) => i.hash(state),\n+            Uint(u) => u.hash(state),\n+            Float(f) => f.hash(state),\n+            Adt(d, s) => {\n+                d.hash(state);\n+                s.hash(state)\n+            }\n+            Foreign(d) => d.hash(state),\n+            Array(t, c) => {\n+                t.hash(state);\n+                c.hash(state)\n             }\n-            (&Error(ref __self_0),) => {\n-                hash::Hash::hash(&tykind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n+            Slice(t) => t.hash(state),\n+            RawPtr(t) => t.hash(state),\n+            Ref(r, t, m) => {\n+                r.hash(state);\n+                t.hash(state);\n+                m.hash(state)\n+            }\n+            FnDef(d, s) => {\n+                d.hash(state);\n+                s.hash(state)\n+            }\n+            FnPtr(s) => s.hash(state),\n+            Dynamic(p, r, repr) => {\n+                p.hash(state);\n+                r.hash(state);\n+                repr.hash(state)\n+            }\n+            Closure(d, s) => {\n+                d.hash(state);\n+                s.hash(state)\n+            }\n+            Generator(d, s, m) => {\n+                d.hash(state);\n+                s.hash(state);\n+                m.hash(state)\n+            }\n+            GeneratorWitness(g) => g.hash(state),\n+            Tuple(t) => t.hash(state),\n+            Projection(p) => p.hash(state),\n+            Opaque(d, s) => {\n+                d.hash(state);\n+                s.hash(state)\n+            }\n+            Param(p) => p.hash(state),\n+            Bound(d, b) => {\n+                d.hash(state);\n+                b.hash(state)\n             }\n-            _ => hash::Hash::hash(&tykind_discriminant(self), state),\n+            Placeholder(p) => p.hash(state),\n+            Infer(t) => t.hash(state),\n+            Error(e) => e.hash(state),\n+            Bool | Char | Str | Never => (),\n         }\n     }\n }\n \n // This is manually implemented because a derive would require `I: Debug`\n impl<I: Interner> fmt::Debug for TyKind<I> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use std::fmt::*;\n         match self {\n-            Bool => Formatter::write_str(f, \"Bool\"),\n-            Char => Formatter::write_str(f, \"Char\"),\n-            Int(f0) => Formatter::debug_tuple_field1_finish(f, \"Int\", f0),\n-            Uint(f0) => Formatter::debug_tuple_field1_finish(f, \"Uint\", f0),\n-            Float(f0) => Formatter::debug_tuple_field1_finish(f, \"Float\", f0),\n-            Adt(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Adt\", f0, f1),\n-            Foreign(f0) => Formatter::debug_tuple_field1_finish(f, \"Foreign\", f0),\n-            Str => Formatter::write_str(f, \"Str\"),\n-            Array(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Array\", f0, f1),\n-            Slice(f0) => Formatter::debug_tuple_field1_finish(f, \"Slice\", f0),\n-            RawPtr(f0) => Formatter::debug_tuple_field1_finish(f, \"RawPtr\", f0),\n-            Ref(f0, f1, f2) => Formatter::debug_tuple_field3_finish(f, \"Ref\", f0, f1, f2),\n-            FnDef(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"FnDef\", f0, f1),\n-            FnPtr(f0) => Formatter::debug_tuple_field1_finish(f, \"FnPtr\", f0),\n-            Dynamic(f0, f1, f2) => Formatter::debug_tuple_field3_finish(f, \"Dynamic\", f0, f1, f2),\n-            Closure(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Closure\", f0, f1),\n-            Generator(f0, f1, f2) => {\n-                Formatter::debug_tuple_field3_finish(f, \"Generator\", f0, f1, f2)\n-            }\n-            GeneratorWitness(f0) => Formatter::debug_tuple_field1_finish(f, \"GeneratorWitness\", f0),\n-            Never => Formatter::write_str(f, \"Never\"),\n-            Tuple(f0) => Formatter::debug_tuple_field1_finish(f, \"Tuple\", f0),\n-            Projection(f0) => Formatter::debug_tuple_field1_finish(f, \"Projection\", f0),\n-            Opaque(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Opaque\", f0, f1),\n-            Param(f0) => Formatter::debug_tuple_field1_finish(f, \"Param\", f0),\n-            Bound(f0, f1) => Formatter::debug_tuple_field2_finish(f, \"Bound\", f0, f1),\n-            Placeholder(f0) => Formatter::debug_tuple_field1_finish(f, \"Placeholder\", f0),\n-            Infer(f0) => Formatter::debug_tuple_field1_finish(f, \"Infer\", f0),\n-            TyKind::Error(f0) => Formatter::debug_tuple_field1_finish(f, \"Error\", f0),\n+            Bool => f.write_str(\"Bool\"),\n+            Char => f.write_str(\"Char\"),\n+            Int(i) => f.debug_tuple_field1_finish(\"Int\", i),\n+            Uint(u) => f.debug_tuple_field1_finish(\"Uint\", u),\n+            Float(float) => f.debug_tuple_field1_finish(\"Float\", float),\n+            Adt(d, s) => f.debug_tuple_field2_finish(\"Adt\", d, s),\n+            Foreign(d) => f.debug_tuple_field1_finish(\"Foreign\", d),\n+            Str => f.write_str(\"Str\"),\n+            Array(t, c) => f.debug_tuple_field2_finish(\"Array\", t, c),\n+            Slice(t) => f.debug_tuple_field1_finish(\"Slice\", t),\n+            RawPtr(t) => f.debug_tuple_field1_finish(\"RawPtr\", t),\n+            Ref(r, t, m) => f.debug_tuple_field3_finish(\"Ref\", r, t, m),\n+            FnDef(d, s) => f.debug_tuple_field2_finish(\"FnDef\", d, s),\n+            FnPtr(s) => f.debug_tuple_field1_finish(\"FnPtr\", s),\n+            Dynamic(p, r, repr) => f.debug_tuple_field3_finish(\"Dynamic\", p, r, repr),\n+            Closure(d, s) => f.debug_tuple_field2_finish(\"Closure\", d, s),\n+            Generator(d, s, m) => f.debug_tuple_field3_finish(\"Generator\", d, s, m),\n+            GeneratorWitness(g) => f.debug_tuple_field1_finish(\"GeneratorWitness\", g),\n+            Never => f.write_str(\"Never\"),\n+            Tuple(t) => f.debug_tuple_field1_finish(\"Tuple\", t),\n+            Projection(p) => f.debug_tuple_field1_finish(\"Projection\", p),\n+            Opaque(d, s) => f.debug_tuple_field2_finish(\"Opaque\", d, s),\n+            Param(p) => f.debug_tuple_field1_finish(\"Param\", p),\n+            Bound(d, b) => f.debug_tuple_field2_finish(\"Bound\", d, b),\n+            Placeholder(p) => f.debug_tuple_field1_finish(\"Placeholder\", p),\n+            Infer(t) => f.debug_tuple_field1_finish(\"Infer\", t),\n+            TyKind::Error(e) => f.debug_tuple_field1_finish(\"Error\", e),\n         }\n     }\n }\n@@ -1091,12 +953,12 @@ where\n impl<I: Interner> Clone for RegionKind<I> {\n     fn clone(&self) -> Self {\n         match self {\n-            ReEarlyBound(a) => ReEarlyBound(a.clone()),\n-            ReLateBound(a, b) => ReLateBound(a.clone(), b.clone()),\n-            ReFree(a) => ReFree(a.clone()),\n+            ReEarlyBound(r) => ReEarlyBound(r.clone()),\n+            ReLateBound(d, r) => ReLateBound(d.clone(), r.clone()),\n+            ReFree(r) => ReFree(r.clone()),\n             ReStatic => ReStatic,\n-            ReVar(a) => ReVar(a.clone()),\n-            RePlaceholder(a) => RePlaceholder(a.clone()),\n+            ReVar(r) => ReVar(r.clone()),\n+            RePlaceholder(r) => RePlaceholder(r.clone()),\n             ReErased => ReErased,\n         }\n     }\n@@ -1106,29 +968,17 @@ impl<I: Interner> Clone for RegionKind<I> {\n impl<I: Interner> PartialEq for RegionKind<I> {\n     #[inline]\n     fn eq(&self, other: &RegionKind<I>) -> bool {\n-        let __self_vi = regionkind_discriminant(self);\n-        let __arg_1_vi = regionkind_discriminant(other);\n-        if __self_vi == __arg_1_vi {\n-            match (&*self, &*other) {\n-                (&ReEarlyBound(ref __self_0), &ReEarlyBound(ref __arg_1_0)) => {\n-                    __self_0 == __arg_1_0\n-                }\n-                (\n-                    &ReLateBound(ref __self_0, ref __self_1),\n-                    &ReLateBound(ref __arg_1_0, ref __arg_1_1),\n-                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1,\n-                (&ReFree(ref __self_0), &ReFree(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&ReStatic, &ReStatic) => true,\n-                (&ReVar(ref __self_0), &ReVar(ref __arg_1_0)) => __self_0 == __arg_1_0,\n-                (&RePlaceholder(ref __self_0), &RePlaceholder(ref __arg_1_0)) => {\n-                    __self_0 == __arg_1_0\n-                }\n-                (&ReErased, &ReErased) => true,\n-                _ => true,\n+        regionkind_discriminant(self) == regionkind_discriminant(other)\n+            && match (self, other) {\n+                (ReEarlyBound(a_r), ReEarlyBound(b_r)) => a_r == b_r,\n+                (ReLateBound(a_d, a_r), ReLateBound(b_d, b_r)) => a_d == b_d && a_r == b_r,\n+                (ReFree(a_r), ReFree(b_r)) => a_r == b_r,\n+                (ReStatic, ReStatic) => true,\n+                (ReVar(a_r), ReVar(b_r)) => a_r == b_r,\n+                (RePlaceholder(a_r), RePlaceholder(b_r)) => a_r == b_r,\n+                (ReErased, ReErased) => true,\n+                _ => true, // unreachable\n             }\n-        } else {\n-            false\n-        }\n     }\n }\n \n@@ -1139,74 +989,46 @@ impl<I: Interner> Eq for RegionKind<I> {}\n impl<I: Interner> PartialOrd for RegionKind<I> {\n     #[inline]\n     fn partial_cmp(&self, other: &RegionKind<I>) -> Option<Ordering> {\n-        Some(Ord::cmp(self, other))\n+        Some(self.cmp(other))\n     }\n }\n \n // This is manually implemented because a derive would require `I: Ord`\n impl<I: Interner> Ord for RegionKind<I> {\n     #[inline]\n     fn cmp(&self, other: &RegionKind<I>) -> Ordering {\n-        let __self_vi = regionkind_discriminant(self);\n-        let __arg_1_vi = regionkind_discriminant(other);\n-        if __self_vi == __arg_1_vi {\n-            match (&*self, &*other) {\n-                (&ReEarlyBound(ref __self_0), &ReEarlyBound(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n-                }\n-                (\n-                    &ReLateBound(ref __self_0, ref __self_1),\n-                    &ReLateBound(ref __arg_1_0, ref __arg_1_1),\n-                ) => match Ord::cmp(__self_0, __arg_1_0) {\n-                    Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n-                    cmp => cmp,\n-                },\n-                (&ReFree(ref __self_0), &ReFree(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&ReStatic, &ReStatic) => Ordering::Equal,\n-                (&ReVar(ref __self_0), &ReVar(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n-                (&RePlaceholder(ref __self_0), &RePlaceholder(ref __arg_1_0)) => {\n-                    Ord::cmp(__self_0, __arg_1_0)\n+        regionkind_discriminant(self).cmp(&regionkind_discriminant(other)).then_with(|| {\n+            match (self, other) {\n+                (ReEarlyBound(a_r), ReEarlyBound(b_r)) => a_r.cmp(b_r),\n+                (ReLateBound(a_d, a_r), ReLateBound(b_d, b_r)) => {\n+                    a_d.cmp(b_d).then_with(|| a_r.cmp(b_r))\n                 }\n-                (&ReErased, &ReErased) => Ordering::Equal,\n-                _ => Ordering::Equal,\n-            }\n-        } else {\n-            Ord::cmp(&__self_vi, &__arg_1_vi)\n-        }\n+                (ReFree(a_r), ReFree(b_r)) => a_r.cmp(b_r),\n+                (ReStatic, ReStatic) => Ordering::Equal,\n+                (ReVar(a_r), ReVar(b_r)) => a_r.cmp(b_r),\n+                (RePlaceholder(a_r), RePlaceholder(b_r)) => a_r.cmp(b_r),\n+                (ReErased, ReErased) => Ordering::Equal,\n+                _ => Ordering::Equal, // unreachable\n+            }\n+        })\n     }\n }\n \n // This is manually implemented because a derive would require `I: Hash`\n impl<I: Interner> hash::Hash for RegionKind<I> {\n-    fn hash<__H: hash::Hasher>(&self, state: &mut __H) -> () {\n-        match (&*self,) {\n-            (&ReEarlyBound(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&ReLateBound(ref __self_0, ref __self_1),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state);\n-                hash::Hash::hash(__self_1, state)\n-            }\n-            (&ReFree(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&ReStatic,) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-            }\n-            (&ReVar(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&RePlaceholder(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n-            (&ReErased,) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-            }\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) -> () {\n+        regionkind_discriminant(self).hash(state);\n+        match self {\n+            ReEarlyBound(r) => r.hash(state),\n+            ReLateBound(d, r) => {\n+                d.hash(state);\n+                r.hash(state)\n+            }\n+            ReFree(r) => r.hash(state),\n+            ReStatic => (),\n+            ReVar(r) => r.hash(state),\n+            RePlaceholder(r) => r.hash(state),\n+            ReErased => (),\n         }\n     }\n }\n@@ -1215,21 +1037,21 @@ impl<I: Interner> hash::Hash for RegionKind<I> {\n impl<I: Interner> fmt::Debug for RegionKind<I> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            ReEarlyBound(ref data) => write!(f, \"ReEarlyBound({:?})\", data),\n+            ReEarlyBound(data) => write!(f, \"ReEarlyBound({:?})\", data),\n \n-            ReLateBound(binder_id, ref bound_region) => {\n+            ReLateBound(binder_id, bound_region) => {\n                 write!(f, \"ReLateBound({:?}, {:?})\", binder_id, bound_region)\n             }\n \n-            ReFree(ref fr) => fr.fmt(f),\n+            ReFree(fr) => fr.fmt(f),\n \n-            ReStatic => write!(f, \"ReStatic\"),\n+            ReStatic => f.write_str(\"ReStatic\"),\n \n-            ReVar(ref vid) => vid.fmt(f),\n+            ReVar(vid) => vid.fmt(f),\n \n             RePlaceholder(placeholder) => write!(f, \"RePlaceholder({:?})\", placeholder),\n \n-            ReErased => write!(f, \"ReErased\"),\n+            ReErased => f.write_str(\"ReErased\"),\n         }\n     }\n }\n@@ -1317,18 +1139,18 @@ where\n             ReErased | ReStatic => {\n                 // No variant fields to hash for these ...\n             }\n-            ReLateBound(db, br) => {\n-                db.hash_stable(hcx, hasher);\n-                br.hash_stable(hcx, hasher);\n+            ReLateBound(d, r) => {\n+                d.hash_stable(hcx, hasher);\n+                r.hash_stable(hcx, hasher);\n             }\n-            ReEarlyBound(eb) => {\n-                eb.hash_stable(hcx, hasher);\n+            ReEarlyBound(r) => {\n+                r.hash_stable(hcx, hasher);\n             }\n-            ReFree(ref free_region) => {\n-                free_region.hash_stable(hcx, hasher);\n+            ReFree(r) => {\n+                r.hash_stable(hcx, hasher);\n             }\n-            RePlaceholder(p) => {\n-                p.hash_stable(hcx, hasher);\n+            RePlaceholder(r) => {\n+                r.hash_stable(hcx, hasher);\n             }\n             ReVar(_) => {\n                 panic!(\"region variables should not be hashed: {self:?}\")"}]}