{"sha": "d117b41409746d4970ffc886a8f54e49696fe06f", "node_id": "C_kwDOAAsO6NoAKGQxMTdiNDE0MDk3NDZkNDk3MGZmYzg4NmE4ZjU0ZTQ5Njk2ZmUwNmY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-05-10T04:12:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-10T04:12:14Z"}, "message": "Rollup merge of #111095 - GuillaumeGomez:fix-assoc-item-trait-inside-hidden, r=notriddle\n\nCorrectly handle associated items of a trait inside a `#[doc(hidden)]` item\n\nFixes https://github.com/rust-lang/rust/issues/111064.\n\ncc `@compiler-errors`\nr? `@notriddle`", "tree": {"sha": "f48d1f9e47da1d41562dfd7552cf46a40c8cd1fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f48d1f9e47da1d41562dfd7552cf46a40c8cd1fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d117b41409746d4970ffc886a8f54e49696fe06f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkWxmeCRBK7hj4Ov3rIwAAInkIACiJ8A5JheKWYuSEP7ckfXjJ\nVsAIeKuVarR3sROHplpCpxMgbe0AUHwRY41TcUNLtpo+Ok+rvM7uexYsi7RVzB3H\nTbiMWNKA3bYFV7BW6EwS2/S3bm2XIFu1vv/0K94X4cZO4XWDV8dOLmZdMjKW6Fzv\nWvr2Vwk+XoNTgVT3MVuWwGe+xdhaVgqqQiNBij6Q9tbI+JQGuiGEyBil80FW0cga\n9eck6CvTDQ7TOgTRlfPHGzRlnqSzwE0kp7KIVMiJchkDRsI3dIy1h4S1hotiCroM\np+xjORBE1sgRxs285sgojavWJDTMjbmyh9U0vUZAbbyUY9EUDPIQOsYSOhameqg=\n=tzXJ\n-----END PGP SIGNATURE-----\n", "payload": "tree f48d1f9e47da1d41562dfd7552cf46a40c8cd1fa\nparent f1922275b75dac7d6b16c5de99b651cd00cf548f\nparent 8de4308b43e9694384d1292f22aef384dc44a5df\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1683691934 +0200\ncommitter GitHub <noreply@github.com> 1683691934 +0200\n\nRollup merge of #111095 - GuillaumeGomez:fix-assoc-item-trait-inside-hidden, r=notriddle\n\nCorrectly handle associated items of a trait inside a `#[doc(hidden)]` item\n\nFixes https://github.com/rust-lang/rust/issues/111064.\n\ncc `@compiler-errors`\nr? `@notriddle`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d117b41409746d4970ffc886a8f54e49696fe06f", "html_url": "https://github.com/rust-lang/rust/commit/d117b41409746d4970ffc886a8f54e49696fe06f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d117b41409746d4970ffc886a8f54e49696fe06f/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1922275b75dac7d6b16c5de99b651cd00cf548f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1922275b75dac7d6b16c5de99b651cd00cf548f", "html_url": "https://github.com/rust-lang/rust/commit/f1922275b75dac7d6b16c5de99b651cd00cf548f"}, {"sha": "8de4308b43e9694384d1292f22aef384dc44a5df", "url": "https://api.github.com/repos/rust-lang/rust/commits/8de4308b43e9694384d1292f22aef384dc44a5df", "html_url": "https://github.com/rust-lang/rust/commit/8de4308b43e9694384d1292f22aef384dc44a5df"}], "stats": {"total": 208, "additions": 162, "deletions": 46}, "files": [{"sha": "c432ce3c324c470f368075e5b36245c43c8cb67e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 41, "deletions": 24, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d117b41409746d4970ffc886a8f54e49696fe06f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d117b41409746d4970ffc886a8f54e49696fe06f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d117b41409746d4970ffc886a8f54e49696fe06f", "patch": "@@ -119,7 +119,39 @@ pub(crate) fn clean_doc_module<'tcx>(doc: &DocModule<'tcx>, cx: &mut DocContext<\n     });\n \n     let kind = ModuleItem(Module { items, span });\n-    Item::from_def_id_and_parts(doc.def_id.to_def_id(), Some(doc.name), kind, cx)\n+    generate_item_with_correct_attrs(cx, kind, doc.def_id, doc.name, doc.import_id, doc.renamed)\n+}\n+\n+fn generate_item_with_correct_attrs(\n+    cx: &mut DocContext<'_>,\n+    kind: ItemKind,\n+    local_def_id: LocalDefId,\n+    name: Symbol,\n+    import_id: Option<LocalDefId>,\n+    renamed: Option<Symbol>,\n+) -> Item {\n+    let def_id = local_def_id.to_def_id();\n+    let target_attrs = inline::load_attrs(cx, def_id);\n+    let attrs = if let Some(import_id) = import_id {\n+        let is_inline = inline::load_attrs(cx, import_id.to_def_id())\n+            .lists(sym::doc)\n+            .get_word_attr(sym::inline)\n+            .is_some();\n+        let mut attrs = get_all_import_attributes(cx, import_id, local_def_id, is_inline);\n+        add_without_unwanted_attributes(&mut attrs, target_attrs, is_inline, None);\n+        attrs\n+    } else {\n+        // We only keep the item's attributes.\n+        target_attrs.iter().map(|attr| (Cow::Borrowed(attr), None)).collect()\n+    };\n+\n+    let cfg = attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n+    let attrs = Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| (&**attr, *did)), false);\n+\n+    let name = renamed.or(Some(name));\n+    let mut item = Item::from_def_id_and_attrs_and_parts(def_id, name, kind, Box::new(attrs), cfg);\n+    item.inline_stmt_id = import_id.map(|local| local.to_def_id());\n+    item\n }\n \n fn clean_generic_bound<'tcx>(\n@@ -2345,29 +2377,14 @@ fn clean_maybe_renamed_item<'tcx>(\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n-        let target_attrs = inline::load_attrs(cx, def_id);\n-        let attrs = if let Some(import_id) = import_id {\n-            let is_inline = inline::load_attrs(cx, import_id.to_def_id())\n-                .lists(sym::doc)\n-                .get_word_attr(sym::inline)\n-                .is_some();\n-            let mut attrs =\n-                get_all_import_attributes(cx, import_id, item.owner_id.def_id, is_inline);\n-            add_without_unwanted_attributes(&mut attrs, target_attrs, is_inline, None);\n-            attrs\n-        } else {\n-            // We only keep the item's attributes.\n-            target_attrs.iter().map(|attr| (Cow::Borrowed(attr), None)).collect()\n-        };\n-\n-        let cfg = attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n-        let attrs =\n-            Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| (&**attr, *did)), false);\n-\n-        let mut item =\n-            Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);\n-        item.inline_stmt_id = import_id.map(|local| local.to_def_id());\n-        vec![item]\n+        vec![generate_item_with_correct_attrs(\n+            cx,\n+            kind,\n+            item.owner_id.def_id,\n+            name,\n+            import_id,\n+            renamed,\n+        )]\n     })\n }\n "}, {"sha": "c0730e90740ebf02e06641a0fd9af3f04177b7f9", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d117b41409746d4970ffc886a8f54e49696fe06f/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d117b41409746d4970ffc886a8f54e49696fe06f/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=d117b41409746d4970ffc886a8f54e49696fe06f", "patch": "@@ -195,7 +195,13 @@ impl Cache {\n impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if item.item_id.is_local() {\n-            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.item_id);\n+            let is_stripped = matches!(*item.kind, clean::ItemKind::StrippedItem(..));\n+            debug!(\n+                \"folding {} (stripped: {is_stripped:?}) \\\"{:?}\\\", id {:?}\",\n+                item.type_(),\n+                item.name,\n+                item.item_id\n+            );\n         }\n \n         // If this is a stripped module,"}, {"sha": "10295cbd189b110357ff0f981a972b8062463a8f", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d117b41409746d4970ffc886a8f54e49696fe06f/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d117b41409746d4970ffc886a8f54e49696fe06f/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=d117b41409746d4970ffc886a8f54e49696fe06f", "patch": "@@ -95,7 +95,7 @@ pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -\n     }\n \n     if cx.tcx.is_doc_hidden(def_id.to_def_id())\n-        || inherits_doc_hidden(cx.tcx, def_id)\n+        || inherits_doc_hidden(cx.tcx, def_id, None)\n         || cx.tcx.def_span(def_id.to_def_id()).in_derive_expansion()\n     {\n         return false;"}, {"sha": "972b0c5ec190ea85d0c53d0781c20b4601aff48d", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d117b41409746d4970ffc886a8f54e49696fe06f/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d117b41409746d4970ffc886a8f54e49696fe06f/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=d117b41409746d4970ffc886a8f54e49696fe06f", "patch": "@@ -1,5 +1,6 @@\n //! Strip all doc(hidden) items from the output.\n \n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n use std::mem;\n@@ -29,6 +30,7 @@ pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clea\n             update_retained: true,\n             tcx: cx.tcx,\n             is_in_hidden_item: false,\n+            last_reexport: None,\n         };\n         stripper.fold_crate(krate)\n     };\n@@ -49,13 +51,24 @@ struct Stripper<'a, 'tcx> {\n     update_retained: bool,\n     tcx: TyCtxt<'tcx>,\n     is_in_hidden_item: bool,\n+    last_reexport: Option<LocalDefId>,\n }\n \n impl<'a, 'tcx> Stripper<'a, 'tcx> {\n+    fn set_last_reexport_then_fold_item(&mut self, i: Item) -> Item {\n+        let prev_from_reexport = self.last_reexport;\n+        if i.inline_stmt_id.is_some() {\n+            self.last_reexport = i.item_id.as_def_id().and_then(|def_id| def_id.as_local());\n+        }\n+        let ret = self.fold_item_recur(i);\n+        self.last_reexport = prev_from_reexport;\n+        ret\n+    }\n+\n     fn set_is_in_hidden_item_and_fold(&mut self, is_in_hidden_item: bool, i: Item) -> Item {\n         let prev = self.is_in_hidden_item;\n         self.is_in_hidden_item |= is_in_hidden_item;\n-        let ret = self.fold_item_recur(i);\n+        let ret = self.set_last_reexport_then_fold_item(i);\n         self.is_in_hidden_item = prev;\n         ret\n     }\n@@ -64,7 +77,7 @@ impl<'a, 'tcx> Stripper<'a, 'tcx> {\n     /// of `is_in_hidden_item` to `true` because the impl children inherit its visibility.\n     fn recurse_in_impl_or_exported_macro(&mut self, i: Item) -> Item {\n         let prev = mem::replace(&mut self.is_in_hidden_item, false);\n-        let ret = self.fold_item_recur(i);\n+        let ret = self.set_last_reexport_then_fold_item(i);\n         self.is_in_hidden_item = prev;\n         ret\n     }\n@@ -86,13 +99,20 @@ impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n         if !is_impl_or_exported_macro {\n             is_hidden = self.is_in_hidden_item || has_doc_hidden;\n             if !is_hidden && i.inline_stmt_id.is_none() {\n-                // We don't need to check if it's coming from a reexport since the reexport itself was\n-                // already checked.\n+                // `i.inline_stmt_id` is `Some` if the item is directly reexported. If it is, we\n+                // don't need to check it, because the reexport itself was already checked.\n+                //\n+                // If this item is the child of a reexported module, `self.last_reexport` will be\n+                // `Some` even though `i.inline_stmt_id` is `None`. Hiddenness inheritance needs to\n+                // account for the possibility that an item's true parent module is hidden, but it's\n+                // inlined into a visible module true. This code shouldn't be reachable if the\n+                // module's reexport is itself hidden, for the same reason it doesn't need to be\n+                // checked if `i.inline_stmt_id` is Some: hidden reexports are never inlined.\n                 is_hidden = i\n                     .item_id\n                     .as_def_id()\n                     .and_then(|def_id| def_id.as_local())\n-                    .map(|def_id| inherits_doc_hidden(self.tcx, def_id))\n+                    .map(|def_id| inherits_doc_hidden(self.tcx, def_id, self.last_reexport))\n                     .unwrap_or(false);\n             }\n         }"}, {"sha": "deb29b1e7a9115166387374e43017155028f4704", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d117b41409746d4970ffc886a8f54e49696fe06f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d117b41409746d4970ffc886a8f54e49696fe06f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=d117b41409746d4970ffc886a8f54e49696fe06f", "patch": "@@ -27,6 +27,8 @@ pub(crate) struct Module<'hir> {\n     pub(crate) where_inner: Span,\n     pub(crate) mods: Vec<Module<'hir>>,\n     pub(crate) def_id: LocalDefId,\n+    pub(crate) renamed: Option<Symbol>,\n+    pub(crate) import_id: Option<LocalDefId>,\n     /// The key is the item `ItemId` and the value is: (item, renamed, import_id).\n     /// We use `FxIndexMap` to keep the insert order.\n     pub(crate) items: FxIndexMap<\n@@ -37,11 +39,19 @@ pub(crate) struct Module<'hir> {\n }\n \n impl Module<'_> {\n-    pub(crate) fn new(name: Symbol, def_id: LocalDefId, where_inner: Span) -> Self {\n+    pub(crate) fn new(\n+        name: Symbol,\n+        def_id: LocalDefId,\n+        where_inner: Span,\n+        renamed: Option<Symbol>,\n+        import_id: Option<LocalDefId>,\n+    ) -> Self {\n         Module {\n             name,\n             def_id,\n             where_inner,\n+            renamed,\n+            import_id,\n             mods: Vec::new(),\n             items: FxIndexMap::default(),\n             foreigns: Vec::new(),\n@@ -60,9 +70,16 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<Symbol> {\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n-pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut def_id: LocalDefId) -> bool {\n+pub(crate) fn inherits_doc_hidden(\n+    tcx: TyCtxt<'_>,\n+    mut def_id: LocalDefId,\n+    stop_at: Option<LocalDefId>,\n+) -> bool {\n     let hir = tcx.hir();\n     while let Some(id) = tcx.opt_local_parent(def_id) {\n+        if let Some(stop_at) = stop_at && id == stop_at {\n+            return false;\n+        }\n         def_id = id;\n         if tcx.is_doc_hidden(def_id.to_def_id()) {\n             return true;\n@@ -100,6 +117,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             cx.tcx.crate_name(LOCAL_CRATE),\n             CRATE_DEF_ID,\n             cx.tcx.hir().root_module().spans.inner_span,\n+            None,\n+            None,\n         );\n \n         RustdocVisitor {\n@@ -261,7 +280,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         let is_private =\n             !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, ori_res_did);\n-        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did);\n+        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did, None);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n@@ -278,7 +297,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 .cache\n                 .effective_visibilities\n                 .is_directly_public(self.cx.tcx, item_def_id.to_def_id()) &&\n-            !inherits_doc_hidden(self.cx.tcx, item_def_id)\n+            !inherits_doc_hidden(self.cx.tcx, item_def_id, None)\n         {\n             // The imported item is public and not `doc(hidden)` so no need to inline it.\n             return false;\n@@ -427,7 +446,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                self.enter_mod(item.owner_id.def_id, m, name);\n+                self.enter_mod(item.owner_id.def_id, m, name, renamed, import_id);\n             }\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::ExternCrate(..)\n@@ -480,8 +499,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     /// This method will create a new module and push it onto the \"modules stack\" then call\n     /// `visit_mod_contents`. Once done, it'll remove it from the \"modules stack\" and instead\n     /// add into the list of modules of the current module.\n-    fn enter_mod(&mut self, id: LocalDefId, m: &'tcx hir::Mod<'tcx>, name: Symbol) {\n-        self.modules.push(Module::new(name, id, m.spans.inner_span));\n+    fn enter_mod(\n+        &mut self,\n+        id: LocalDefId,\n+        m: &'tcx hir::Mod<'tcx>,\n+        name: Symbol,\n+        renamed: Option<Symbol>,\n+        import_id: Option<LocalDefId>,\n+    ) {\n+        self.modules.push(Module::new(name, id, m.spans.inner_span, renamed, import_id));\n \n         self.visit_mod_contents(id, m);\n \n@@ -501,19 +527,14 @@ impl<'a, 'tcx> Visitor<'tcx> for RustdocVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n         self.visit_item_inner(i, None, None);\n-        let new_value = if self.is_importable_from_parent {\n-            matches!(\n+        let new_value = self.is_importable_from_parent\n+            && matches!(\n                 i.kind,\n                 hir::ItemKind::Mod(..)\n                     | hir::ItemKind::ForeignMod { .. }\n                     | hir::ItemKind::Impl(..)\n                     | hir::ItemKind::Trait(..)\n-            )\n-        } else {\n-            // Whatever the context, if it's an impl block, the items inside it can be used so they\n-            // should be visible.\n-            matches!(i.kind, hir::ItemKind::Impl(..))\n-        };\n+            );\n         let prev = mem::replace(&mut self.is_importable_from_parent, new_value);\n         walk_item(self, i);\n         self.is_importable_from_parent = prev;"}, {"sha": "8e1029a1ca3df9fc54c1f67539dd5a5475ddc193", "filename": "tests/rustdoc/issue-111064-reexport-trait-from-hidden-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d117b41409746d4970ffc886a8f54e49696fe06f/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d117b41409746d4970ffc886a8f54e49696fe06f/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden-2.rs?ref=d117b41409746d4970ffc886a8f54e49696fe06f", "patch": "@@ -0,0 +1,31 @@\n+#![feature(no_core)]\n+#![no_core]\n+#![crate_name = \"foo\"]\n+\n+// @!has 'foo/hidden/index.html'\n+// FIXME: add missing `@` for the two next tests once issue is fixed!\n+// To be done in <https://github.com/rust-lang/rust/issues/111249>.\n+// !has 'foo/hidden/inner/index.html'\n+// !has 'foo/hidden/inner/trait.Foo.html'\n+#[doc(hidden)]\n+pub mod hidden {\n+    pub mod inner {\n+        pub trait Foo {\n+            /// Hello, world!\n+            fn test();\n+        }\n+    }\n+}\n+\n+// @has 'foo/visible/index.html'\n+// @has 'foo/visible/trait.Foo.html'\n+#[doc(inline)]\n+pub use hidden::inner as visible;\n+\n+// @has 'foo/struct.Bar.html'\n+// @count - '//*[@id=\"impl-Foo-for-Bar\"]' 1\n+pub struct Bar;\n+\n+impl visible::Foo for Bar {\n+    fn test() {}\n+}"}, {"sha": "a9ce4a34507e6e73d82c96f201bfaa325c164c18", "filename": "tests/rustdoc/issue-111064-reexport-trait-from-hidden.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d117b41409746d4970ffc886a8f54e49696fe06f/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d117b41409746d4970ffc886a8f54e49696fe06f/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden.rs?ref=d117b41409746d4970ffc886a8f54e49696fe06f", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/111064>.\n+// Methods from a re-exported trait inside a `#[doc(hidden)]` item should\n+// be visible.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// @has - '//*[@id=\"main-content\"]//*[@class=\"item-name\"]/a[@href=\"trait.Foo.html\"]' 'Foo'\n+\n+// @has 'foo/trait.Foo.html'\n+// @has - '//*[@id=\"main-content\"]//*[@class=\"code-header\"]' 'fn test()'\n+\n+#[doc(hidden)]\n+mod hidden {\n+    pub trait Foo {\n+        /// Hello, world!\n+        fn test();\n+    }\n+}\n+\n+pub use hidden::Foo;"}]}