{"sha": "daf31d2b4f35b5d125e2e354e9e9f74fe4ff52ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZjMxZDJiNGYzNWI1ZDEyNWUyZTM1NGU5ZTlmNzRmZTRmZjUyZmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-20T03:02:22Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T21:01:27Z"}, "message": "librustc: De-`@mut` `resolve::Module`", "tree": {"sha": "00041e34250a32fd7adc9fdc99821148fa28a684", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00041e34250a32fd7adc9fdc99821148fa28a684"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daf31d2b4f35b5d125e2e354e9e9f74fe4ff52ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daf31d2b4f35b5d125e2e354e9e9f74fe4ff52ff", "html_url": "https://github.com/rust-lang/rust/commit/daf31d2b4f35b5d125e2e354e9e9f74fe4ff52ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daf31d2b4f35b5d125e2e354e9e9f74fe4ff52ff/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec02f9457cfbd336296951bad66dcb621c865166", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec02f9457cfbd336296951bad66dcb621c865166", "html_url": "https://github.com/rust-lang/rust/commit/ec02f9457cfbd336296951bad66dcb621c865166"}], "stats": {"total": 105, "additions": 52, "deletions": 53}, "files": [{"sha": "6dd6c8aabdf9bb93ec92e115647f60ff12cf7dd4", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/daf31d2b4f35b5d125e2e354e9e9f74fe4ff52ff/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf31d2b4f35b5d125e2e354e9e9f74fe4ff52ff/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=daf31d2b4f35b5d125e2e354e9e9f74fe4ff52ff", "patch": "@@ -113,7 +113,7 @@ enum NamespaceResult {\n     UnboundResult,\n     /// Means that resolve has determined that the name is bound in the Module\n     /// argument, and specified by the NameBindings argument.\n-    BoundResult(@mut Module, @mut NameBindings)\n+    BoundResult(@Module, @mut NameBindings)\n }\n \n impl NamespaceResult {\n@@ -166,7 +166,7 @@ enum ImportDirectiveSubclass {\n /// The context that we thread through while building the reduced graph.\n #[deriving(Clone)]\n enum ReducedGraphParent {\n-    ModuleReducedGraphParent(@mut Module)\n+    ModuleReducedGraphParent(@Module)\n }\n \n enum ResolveResult<T> {\n@@ -246,7 +246,7 @@ enum SearchThroughModulesFlag {\n \n enum ModulePrefixResult {\n     NoPrefixFound,\n-    PrefixFound(@mut Module, uint)\n+    PrefixFound(@Module, uint)\n }\n \n #[deriving(Eq)]\n@@ -327,12 +327,12 @@ impl ImportDirective {\n \n /// The item that an import resolves to.\n struct Target {\n-    target_module: @mut Module,\n+    target_module: @Module,\n     bindings: @mut NameBindings,\n }\n \n impl Target {\n-    fn new(target_module: @mut Module,\n+    fn new(target_module: @Module,\n                bindings: @mut NameBindings)\n                -> Target {\n         Target {\n@@ -399,8 +399,8 @@ impl ImportResolution {\n /// The link from a module up to its nearest parent node.\n enum ParentLink {\n     NoParentLink,\n-    ModuleParentLink(@mut Module, Ident),\n-    BlockParentLink(@mut Module, NodeId)\n+    ModuleParentLink(@Module, Ident),\n+    BlockParentLink(@Module, NodeId)\n }\n \n /// The type of module this is.\n@@ -425,7 +425,7 @@ struct Module {\n \n     // The external module children of this node that were declared with\n     // `extern mod`.\n-    external_module_children: @mut HashMap<Name, @mut Module>,\n+    external_module_children: @mut HashMap<Name, @Module>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -441,7 +441,7 @@ struct Module {\n     //\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n-    anonymous_children: @mut HashMap<NodeId,@mut Module>,\n+    anonymous_children: @mut HashMap<NodeId,@Module>,\n \n     // The status of resolving each import in this module.\n     import_resolutions: @mut HashMap<Name, @mut ImportResolution>,\n@@ -490,7 +490,7 @@ impl Module {\n // Records a possibly-private type definition.\n struct TypeNsDef {\n     is_public: bool, // see note in ImportResolution about how to use this\n-    module_def: Option<@mut Module>,\n+    module_def: Option<@Module>,\n     type_def: Option<Def>,\n     type_span: Option<Span>\n }\n@@ -526,7 +526,7 @@ impl NameBindings {\n                      is_public: bool,\n                      sp: Span) {\n         // Merges the module with the existing type def or creates a new one.\n-        let module_ = @mut Module::new(parent_link, def_id, kind, external,\n+        let module_ = @Module::new(parent_link, def_id, kind, external,\n                                        is_public);\n         match self.type_def {\n             None => {\n@@ -558,7 +558,7 @@ impl NameBindings {\n                        _sp: Span) {\n         match self.type_def {\n             None => {\n-                let module = @mut Module::new(parent_link, def_id, kind,\n+                let module = @Module::new(parent_link, def_id, kind,\n                                               external, is_public);\n                 self.type_def = Some(TypeNsDef {\n                     is_public: is_public,\n@@ -570,7 +570,7 @@ impl NameBindings {\n             Some(type_def) => {\n                 match type_def.module_def {\n                     None => {\n-                        let module = @mut Module::new(parent_link,\n+                        let module = @Module::new(parent_link,\n                                                       def_id,\n                                                       kind,\n                                                       external,\n@@ -618,7 +618,7 @@ impl NameBindings {\n     }\n \n     /// Returns the module node if applicable.\n-    fn get_module_if_available(&self) -> Option<@mut Module> {\n+    fn get_module_if_available(&self) -> Option<@Module> {\n         match self.type_def {\n             Some(ref type_def) => (*type_def).module_def,\n             None => None\n@@ -629,7 +629,7 @@ impl NameBindings {\n      * Returns the module node. Fails if this node does not have a module\n      * definition.\n      */\n-    fn get_module(&mut self) -> @mut Module {\n+    fn get_module(&mut self) -> @Module {\n         match self.get_module_if_available() {\n             None => {\n                 fail!(\"get_module called on a node with no module \\\n@@ -837,7 +837,7 @@ struct Resolver {\n     unresolved_imports: uint,\n \n     // The module that represents the current item scope.\n-    current_module: @mut Module,\n+    current_module: @Module,\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n@@ -955,7 +955,7 @@ impl Resolver {\n     /// Returns the current module tracked by the reduced graph parent.\n     fn get_module_from_parent(&mut self,\n                                   reduced_graph_parent: ReducedGraphParent)\n-                                  -> @mut Module {\n+                                  -> @Module {\n         match reduced_graph_parent {\n             ModuleReducedGraphParent(module_) => {\n                 return module_;\n@@ -1500,7 +1500,7 @@ impl Resolver {\n                         self.external_exports.insert(def_id);\n                         let parent_link = ModuleParentLink\n                             (self.get_module_from_parent(parent), name);\n-                        let external_module = @mut Module::new(parent_link,\n+                        let external_module = @Module::new(parent_link,\n                                                           Some(def_id),\n                                                           NormalModuleKind,\n                                                           false,\n@@ -1565,7 +1565,7 @@ impl Resolver {\n                    block_id);\n \n             let parent_module = self.get_module_from_parent(parent);\n-            let new_module = @mut Module::new(\n+            let new_module = @Module::new(\n                 BlockParentLink(parent_module, block_id),\n                 None,\n                 AnonymousModuleKind,\n@@ -1730,7 +1730,7 @@ impl Resolver {\n \n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_def(&mut self,\n-                                                  root: @mut Module,\n+                                                  root: @Module,\n                                                   def_like: DefLike,\n                                                   ident: Ident,\n                                                   visibility: visibility) {\n@@ -1865,7 +1865,7 @@ impl Resolver {\n     }\n \n     /// Builds the reduced graph rooted at the given external module.\n-    fn populate_external_module(&mut self, module: @mut Module) {\n+    fn populate_external_module(&mut self, module: @Module) {\n         debug!(\"(populating external module) attempting to populate {}\",\n                self.module_to_str(module));\n \n@@ -1892,7 +1892,7 @@ impl Resolver {\n \n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n-    fn populate_module_if_necessary(&mut self, module: @mut Module) {\n+    fn populate_module_if_necessary(&mut self, module: @Module) {\n         if !module.populated.get() {\n             self.populate_external_module(module)\n         }\n@@ -1902,7 +1902,7 @@ impl Resolver {\n     /// Builds the reduced graph rooted at the 'use' directive for an external\n     /// crate.\n     fn build_reduced_graph_for_external_crate(&mut self,\n-                                              root: @mut Module) {\n+                                              root: @Module) {\n         csearch::each_top_level_item_of_crate(self.session.cstore,\n                                               root.def_id\n                                                   .get()\n@@ -1918,7 +1918,7 @@ impl Resolver {\n \n     /// Creates and adds an import directive to the given module.\n     fn build_import_directive(&mut self,\n-                              module_: @mut Module,\n+                              module_: @Module,\n                               module_path: ~[Ident],\n                               subclass: @ImportDirectiveSubclass,\n                               span: Span,\n@@ -2006,7 +2006,7 @@ impl Resolver {\n     /// Attempts to resolve imports for the given module and all of its\n     /// submodules.\n     fn resolve_imports_for_module_subtree(&mut self,\n-                                              module_: @mut Module) {\n+                                              module_: @Module) {\n         debug!(\"(resolving imports for module subtree) resolving {}\",\n                self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n@@ -2029,7 +2029,7 @@ impl Resolver {\n     }\n \n     /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_for_module(&mut self, module: @mut Module) {\n+    fn resolve_imports_for_module(&mut self, module: @Module) {\n         if module.all_imports_resolved() {\n             debug!(\"(resolving imports for module) all imports resolved for \\\n                    {}\",\n@@ -2115,7 +2115,7 @@ impl Resolver {\n     /// currently-unresolved imports, or success if we know the name exists.\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import_for_module(&mut self,\n-                                 module_: @mut Module,\n+                                 module_: @Module,\n                                  import_directive: @ImportDirective)\n                                      -> ResolveResult<()> {\n         let mut resolution_result = Failed;\n@@ -2205,7 +2205,7 @@ impl Resolver {\n         return resolution_result;\n     }\n \n-    fn create_name_bindings_from_module(module: @mut Module)\n+    fn create_name_bindings_from_module(module: @Module)\n                                             -> NameBindings {\n         NameBindings {\n             type_def: Some(TypeNsDef {\n@@ -2219,8 +2219,8 @@ impl Resolver {\n     }\n \n     fn resolve_single_import(&mut self,\n-                             module_: @mut Module,\n-                             containing_module: @mut Module,\n+                             module_: @Module,\n+                             containing_module: @Module,\n                              target: Ident,\n                              source: Ident,\n                              directive: &ImportDirective,\n@@ -2445,8 +2445,8 @@ impl Resolver {\n     // succeeds or bails out (as importing * from an empty module or a module\n     // that exports nothing is valid).\n     fn resolve_glob_import(&mut self,\n-                           module_: @mut Module,\n-                           containing_module: @mut Module,\n+                           module_: @Module,\n+                           containing_module: @Module,\n                            id: NodeId,\n                            is_public: bool,\n                            lp: LastPrivate)\n@@ -2586,13 +2586,13 @@ impl Resolver {\n \n     /// Resolves the given module path from the given root `module_`.\n     fn resolve_module_path_from_root(&mut self,\n-                                     module_: @mut Module,\n+                                     module_: @Module,\n                                      module_path: &[Ident],\n                                      index: uint,\n                                      span: Span,\n                                      name_search_type: NameSearchType,\n                                      lp: LastPrivate)\n-                                -> ResolveResult<(@mut Module, LastPrivate)> {\n+                                -> ResolveResult<(@Module, LastPrivate)> {\n         let mut search_module = module_;\n         let mut index = index;\n         let module_path_len = module_path.len();\n@@ -2709,12 +2709,12 @@ impl Resolver {\n     /// On success, returns the resolved module, and the closest *private*\n     /// module found to the destination when resolving this path.\n     fn resolve_module_path(&mut self,\n-                           module_: @mut Module,\n+                           module_: @Module,\n                            module_path: &[Ident],\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Span,\n                            name_search_type: NameSearchType)\n-                               -> ResolveResult<(@mut Module, LastPrivate)> {\n+                               -> ResolveResult<(@Module, LastPrivate)> {\n         let module_path_len = module_path.len();\n         assert!(module_path_len > 0);\n \n@@ -2809,7 +2809,7 @@ impl Resolver {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     fn resolve_item_in_lexical_scope(&mut self,\n-                                     module_: @mut Module,\n+                                     module_: @Module,\n                                      name: Ident,\n                                      namespace: Namespace,\n                                      search_through_modules:\n@@ -2942,9 +2942,9 @@ impl Resolver {\n \n     /// Resolves a module name in the current lexical scope.\n     fn resolve_module_in_lexical_scope(&mut self,\n-                                       module_: @mut Module,\n+                                       module_: @Module,\n                                        name: Ident)\n-                                -> ResolveResult<@mut Module> {\n+                                -> ResolveResult<@Module> {\n         // If this module is an anonymous module, resolve the item in the\n         // lexical scope. Otherwise, resolve the item from the crate root.\n         let resolve_result = self.resolve_item_in_lexical_scope(\n@@ -2987,8 +2987,8 @@ impl Resolver {\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n-    fn get_nearest_normal_module_parent(&mut self, module_: @mut Module)\n-                                            -> Option<@mut Module> {\n+    fn get_nearest_normal_module_parent(&mut self, module_: @Module)\n+                                            -> Option<@Module> {\n         let mut module_ = module_;\n         loop {\n             match module_.parent_link {\n@@ -3009,9 +3009,8 @@ impl Resolver {\n \n     /// Returns the nearest normal module parent of the given module, or the\n     /// module itself if it is a normal module.\n-    fn get_nearest_normal_module_parent_or_self(&mut self,\n-                                                    module_: @mut Module)\n-                                                    -> @mut Module {\n+    fn get_nearest_normal_module_parent_or_self(&mut self, module_: @Module)\n+                                                -> @Module {\n         match module_.kind.get() {\n             NormalModuleKind => return module_,\n             ExternModuleKind |\n@@ -3030,7 +3029,7 @@ impl Resolver {\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n     fn resolve_module_prefix(&mut self,\n-                             module_: @mut Module,\n+                             module_: @Module,\n                              module_path: &[Ident])\n                                  -> ResolveResult<ModulePrefixResult> {\n         // Start at the current module if we see `self` or `super`, or at the\n@@ -3076,7 +3075,7 @@ impl Resolver {\n     /// The boolean returned on success is an indicator of whether this lookup\n     /// passed through a public re-export proxy.\n     fn resolve_name_in_module(&mut self,\n-                              module_: @mut Module,\n+                              module_: @Module,\n                               name: Ident,\n                               namespace: Namespace,\n                               name_search_type: NameSearchType)\n@@ -3151,7 +3150,7 @@ impl Resolver {\n         return Failed;\n     }\n \n-    fn report_unresolved_imports(&mut self, module_: @mut Module) {\n+    fn report_unresolved_imports(&mut self, module_: @Module) {\n         let index = module_.resolved_import_count.get();\n         let imports: &mut ~[@ImportDirective] = &mut *module_.imports;\n         let import_count = imports.len();\n@@ -3199,7 +3198,7 @@ impl Resolver {\n     }\n \n     fn record_exports_for_module_subtree(&mut self,\n-                                             module_: @mut Module) {\n+                                             module_: @Module) {\n         // If this isn't a local crate, then bail out. We don't need to record\n         // exports for nonlocal crates.\n \n@@ -3244,7 +3243,7 @@ impl Resolver {\n         }\n     }\n \n-    fn record_exports_for_module(&mut self, module_: @mut Module) {\n+    fn record_exports_for_module(&mut self, module_: @Module) {\n         let mut exports2 = ~[];\n \n         self.add_exports_for_module(&mut exports2, module_);\n@@ -3284,7 +3283,7 @@ impl Resolver {\n \n     fn add_exports_for_module(&mut self,\n                               exports2: &mut ~[Export2],\n-                              module_: @mut Module) {\n+                              module_: @Module) {\n         for (name, importresolution) in module_.import_resolutions.iter() {\n             if !importresolution.is_public { continue }\n             let xs = [TypeNS, ValueNS];\n@@ -4598,7 +4597,7 @@ impl Resolver {\n \n     // FIXME #4952: Merge me with resolve_name_in_module?\n     fn resolve_definition_of_name_in_module(&mut self,\n-                                            containing_module: @mut Module,\n+                                            containing_module: @Module,\n                                             name: Ident,\n                                             namespace: Namespace)\n                                                 -> NameDefinition {\n@@ -5398,7 +5397,7 @@ impl Resolver {\n     //\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n-    fn module_to_str(&mut self, module_: @mut Module) -> ~str {\n+    fn module_to_str(&mut self, module_: @Module) -> ~str {\n         let mut idents = ~[];\n         let mut current_module = module_;\n         loop {\n@@ -5424,7 +5423,7 @@ impl Resolver {\n     }\n \n     #[allow(dead_code)]   // useful for debugging\n-    fn dump_module(&mut self, module_: @mut Module) {\n+    fn dump_module(&mut self, module_: @Module) {\n         debug!(\"Dump of module `{}`:\", self.module_to_str(module_));\n \n         debug!(\"Children:\");"}]}