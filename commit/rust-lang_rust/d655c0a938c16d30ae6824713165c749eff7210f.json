{"sha": "d655c0a938c16d30ae6824713165c749eff7210f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NTVjMGE5MzhjMTZkMzBhZTY4MjQ3MTMxNjVjNzQ5ZWZmNzIxMGY=", "commit": {"author": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-08-25T03:13:40Z"}, "committer": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-09-17T07:38:37Z"}, "message": "Change the criteria of `interior_mutable_const`\n\n* stop linting associated types and generic type parameters\n* start linting ones in trait impls\n  whose corresponding definitions in the traits are generic\n* remove the `is_copy` check\n  as presumably the only purpose of it is to allow\n  generics with `Copy` bounds as `Freeze` is internal\n  and generics are no longer linted\n* remove the term 'copy' from the tests\n  as being `Copy` no longer have meaning", "tree": {"sha": "c71bf7538f2f3cc00c24b88e3fed68b2673c0f33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c71bf7538f2f3cc00c24b88e3fed68b2673c0f33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d655c0a938c16d30ae6824713165c749eff7210f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d655c0a938c16d30ae6824713165c749eff7210f", "html_url": "https://github.com/rust-lang/rust/commit/d655c0a938c16d30ae6824713165c749eff7210f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d655c0a938c16d30ae6824713165c749eff7210f/comments", "author": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5af88e3c2d8cc4fb74a0e455381669930ee3a31a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5af88e3c2d8cc4fb74a0e455381669930ee3a31a", "html_url": "https://github.com/rust-lang/rust/commit/5af88e3c2d8cc4fb74a0e455381669930ee3a31a"}], "stats": {"total": 281, "additions": 156, "deletions": 125}, "files": [{"sha": "28c68a2b68c5752d67702b9a06f922b23f445a5f", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 61, "deletions": 32, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d655c0a938c16d30ae6824713165c749eff7210f/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d655c0a938c16d30ae6824713165c749eff7210f/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=d655c0a938c16d30ae6824713165c749eff7210f", "patch": "@@ -6,14 +6,17 @@ use std::ptr;\n \n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp};\n+use rustc_infer::traits::specialization_graph;\n use rustc_lint::{LateContext, LateLintPass, Lint};\n use rustc_middle::ty::adjustment::Adjust;\n-use rustc_middle::ty::{Ty, TypeFlags};\n+use rustc_middle::ty::fold::TypeFoldable as _;\n+use rustc_middle::ty::{AssocKind, Ty, TypeFlags};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use rustc_typeck::hir_ty_to_ty;\n \n-use crate::utils::{in_constant, is_copy, qpath_res, span_lint_and_then};\n+use crate::utils::{in_constant, qpath_res, span_lint_and_then};\n+use if_chain::if_chain;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for declaration of `const` items which is interior\n@@ -83,11 +86,10 @@ declare_clippy_lint! {\n     \"referencing `const` with interior mutability\"\n }\n \n-#[allow(dead_code)]\n #[derive(Copy, Clone)]\n enum Source {\n     Item { item: Span },\n-    Assoc { item: Span, ty: Span },\n+    Assoc { item: Span },\n     Expr { expr: Span },\n }\n \n@@ -110,10 +112,15 @@ impl Source {\n }\n \n fn verify_ty_bound<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, source: Source) {\n-    if ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env) || is_copy(cx, ty) {\n-        // An `UnsafeCell` is `!Copy`, and an `UnsafeCell` is also the only type which\n-        // is `!Freeze`, thus if our type is `Copy` we can be sure it must be `Freeze`\n-        // as well.\n+    // Ignore types whose layout is unknown since `is_freeze` reports every generic types as `!Freeze`,\n+    // making it indistinguishable from `UnsafeCell`. i.e. it isn't a tool to prove a type is\n+    // 'unfrozen'. However, this code causes a false negative in which\n+    // a type contains a layout-unknown type, but also a unsafe cell like `const CELL: Cell<T>`.\n+    // Yet, it's better than `ty.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_PROJECTION)`\n+    // since it works when a pointer indirection involves (`Cell<*const T>`).\n+    // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n+    // but I'm not sure whether it's a decent way, if possible.\n+    if cx.tcx.layout_of(cx.param_env.and(ty)).is_err() || ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env) {\n         return;\n     }\n \n@@ -127,11 +134,7 @@ fn verify_ty_bound<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, source: Source) {\n                 let const_kw_span = span.from_inner(InnerSpan::new(0, 5));\n                 diag.span_label(const_kw_span, \"make this a static item (maybe with lazy_static)\");\n             },\n-            Source::Assoc { ty: ty_span, .. } => {\n-                if ty.flags().intersects(TypeFlags::HAS_FREE_LOCAL_NAMES) {\n-                    diag.span_label(ty_span, &format!(\"consider requiring `{}` to be `Copy`\", ty));\n-                }\n-            },\n+            Source::Assoc { .. } => (),\n             Source::Expr { .. } => {\n                 diag.help(\"assign this const to a local or static variable, and use the variable here\");\n             },\n@@ -152,32 +155,58 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx TraitItem<'_>) {\n         if let TraitItemKind::Const(hir_ty, ..) = &trait_item.kind {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            verify_ty_bound(\n-                cx,\n-                ty,\n-                Source::Assoc {\n-                    ty: hir_ty.span,\n-                    item: trait_item.span,\n-                },\n-            );\n+            // Normalize assoc types because ones originated from generic params\n+            // bounded other traits could have their bound.\n+            let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+            verify_ty_bound(cx, normalized, Source::Assoc { item: trait_item.span });\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Const(hir_ty, ..) = &impl_item.kind {\n             let item_hir_id = cx.tcx.hir().get_parent_node(impl_item.hir_id);\n             let item = cx.tcx.hir().expect_item(item_hir_id);\n-            // Ensure the impl is an inherent impl.\n-            if let ItemKind::Impl { of_trait: None, .. } = item.kind {\n-                let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-                verify_ty_bound(\n-                    cx,\n-                    ty,\n-                    Source::Assoc {\n-                        ty: hir_ty.span,\n-                        item: impl_item.span,\n-                    },\n-                );\n+\n+            match &item.kind {\n+                ItemKind::Impl {\n+                    of_trait: Some(of_trait_ref),\n+                    ..\n+                } => {\n+                    if_chain! {\n+                        // Lint a trait impl item only when the definition is a generic type,\n+                        // assuming a assoc const is not meant to be a interior mutable type.\n+                        if let Some(of_trait_def_id) = of_trait_ref.trait_def_id();\n+                        if let Some(of_assoc_item) = specialization_graph::Node::Trait(of_trait_def_id)\n+                            .item(cx.tcx, impl_item.ident, AssocKind::Const, of_trait_def_id);\n+                        if cx.tcx\n+                            // Normalize assoc types because ones originated from generic params\n+                            // bounded other traits could have their bound at the trait defs;\n+                            // and, in that case, the definition is *not* generic.\n+                            .normalize_erasing_regions(\n+                                cx.tcx.param_env(of_trait_def_id),\n+                                cx.tcx.type_of(of_assoc_item.def_id),\n+                            )\n+                            .has_type_flags(TypeFlags::HAS_PROJECTION | TypeFlags::HAS_TY_PARAM);\n+                        then {\n+                            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+                            let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+                            verify_ty_bound(\n+                                cx,\n+                                normalized,\n+                                Source::Assoc {\n+                                    item: impl_item.span,\n+                                },\n+                            );\n+                        }\n+                    }\n+                },\n+                ItemKind::Impl { of_trait: None, .. } => {\n+                    let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+                    // Normalize assoc types originated from generic params.\n+                    let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+                    verify_ty_bound(cx, normalized, Source::Assoc { item: impl_item.span });\n+                },\n+                _ => (),\n             }\n         }\n     }"}, {"sha": "9fcc9ece49bb7e78840a34078d960e342e466329", "filename": "tests/ui/borrow_interior_mutable_const.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d655c0a938c16d30ae6824713165c749eff7210f/tests%2Fui%2Fborrow_interior_mutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d655c0a938c16d30ae6824713165c749eff7210f/tests%2Fui%2Fborrow_interior_mutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const.rs?ref=d655c0a938c16d30ae6824713165c749eff7210f", "patch": "@@ -19,16 +19,30 @@ const NO_ANN: &dyn Display = &70;\n static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n const ONCE_INIT: Once = Once::new();\n \n-trait Trait<T>: Copy {\n-    type NonCopyType;\n+trait Trait<T> {\n+    type AssocType;\n \n     const ATOMIC: AtomicUsize;\n+    const INPUT: T;\n+    const ASSOC: Self::AssocType;\n+\n+    fn function() {\n+        let _ = &Self::INPUT;\n+        let _ = &Self::ASSOC;\n+    }\n }\n \n impl Trait<u32> for u64 {\n-    type NonCopyType = u16;\n+    type AssocType = AtomicUsize;\n \n     const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n+    const INPUT: u32 = 10;\n+    const ASSOC: Self::AssocType = AtomicUsize::new(11);\n+\n+    fn function() {\n+        let _ = &Self::INPUT;\n+        let _ = &Self::ASSOC; //~ ERROR interior mutability\n+    }\n }\n \n // This is just a pointer that can be safely dereferended,"}, {"sha": "ed726a6b46e64b9e4b62cab9bc18f1c93baf93ba", "filename": "tests/ui/borrow_interior_mutable_const.stderr", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d655c0a938c16d30ae6824713165c749eff7210f/tests%2Fui%2Fborrow_interior_mutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d655c0a938c16d30ae6824713165c749eff7210f/tests%2Fui%2Fborrow_interior_mutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const.stderr?ref=d655c0a938c16d30ae6824713165c749eff7210f", "patch": "@@ -1,131 +1,139 @@\n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:66:5\n+  --> $DIR/borrow_interior_mutable_const.rs:44:18\n+   |\n+LL |         let _ = &Self::ASSOC; //~ ERROR interior mutability\n+   |                  ^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/borrow_interior_mutable_const.rs:80:5\n    |\n LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^\n    |\n-   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:67:16\n+  --> $DIR/borrow_interior_mutable_const.rs:81:16\n    |\n LL |     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n    |                ^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:70:22\n+  --> $DIR/borrow_interior_mutable_const.rs:84:22\n    |\n LL |     let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n    |                      ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:71:25\n+  --> $DIR/borrow_interior_mutable_const.rs:85:25\n    |\n LL |     let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n    |                         ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:72:27\n+  --> $DIR/borrow_interior_mutable_const.rs:86:27\n    |\n LL |     let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n    |                           ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:73:26\n+  --> $DIR/borrow_interior_mutable_const.rs:87:26\n    |\n LL |     let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n    |                          ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:84:14\n+  --> $DIR/borrow_interior_mutable_const.rs:98:14\n    |\n LL |     let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:85:14\n+  --> $DIR/borrow_interior_mutable_const.rs:99:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:86:19\n+  --> $DIR/borrow_interior_mutable_const.rs:100:19\n    |\n LL |     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n    |                   ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:87:14\n+  --> $DIR/borrow_interior_mutable_const.rs:101:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:88:13\n+  --> $DIR/borrow_interior_mutable_const.rs:102:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:94:13\n+  --> $DIR/borrow_interior_mutable_const.rs:108:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:99:5\n+  --> $DIR/borrow_interior_mutable_const.rs:113:5\n    |\n LL |     CELL.set(2); //~ ERROR interior mutability\n    |     ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:100:16\n+  --> $DIR/borrow_interior_mutable_const.rs:114:16\n    |\n LL |     assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n    |                ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:113:5\n+  --> $DIR/borrow_interior_mutable_const.rs:127:5\n    |\n LL |     u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:114:16\n+  --> $DIR/borrow_interior_mutable_const.rs:128:16\n    |\n LL |     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n    |                ^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 17 previous errors\n "}, {"sha": "7471b360540670dfad2d8168fb46ef817ebc7ddc", "filename": "tests/ui/declare_interior_mutable_const.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d655c0a938c16d30ae6824713165c749eff7210f/tests%2Fui%2Fdeclare_interior_mutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d655c0a938c16d30ae6824713165c749eff7210f/tests%2Fui%2Fdeclare_interior_mutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const.rs?ref=d655c0a938c16d30ae6824713165c749eff7210f", "patch": "@@ -34,60 +34,64 @@ static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n #[allow(clippy::declare_interior_mutable_const)]\n const ONCE_INIT: Once = Once::new();\n \n-trait Trait<T>: Copy {\n-    type NonCopyType;\n+struct Wrapper<T>(T);\n+\n+trait Trait<T: Trait2<AssocType5 = AtomicUsize>> {\n+    type AssocType;\n+    type AssocType2;\n+    type AssocType3;\n \n     const ATOMIC: AtomicUsize; //~ ERROR interior mutable\n     const INTEGER: u64;\n     const STRING: String;\n-    const SELF: Self; // (no error)\n+    const SELF: Self;\n     const INPUT: T;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `T` to be `Copy`\n-    const ASSOC: Self::NonCopyType;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `<Self as Trait<T>>::NonCopyType` to be `Copy`\n+    const INPUT_ASSOC: T::AssocType4;\n+    const INPUT_ASSOC_2: T::AssocType5; //~ ERROR interior mutable\n+    const ASSOC: Self::AssocType;\n+    const ASSOC_2: Self::AssocType2;\n+    const WRAPPED_ASSOC_2: Wrapper<Self::AssocType2>;\n+    const WRAPPED_ASSOC_3: Wrapper<Self::AssocType3>;\n \n     const AN_INPUT: T = Self::INPUT;\n-    //~^ ERROR interior mutable\n-    //~| ERROR consider requiring `T` to be `Copy`\n-    declare_const!(ANOTHER_INPUT: T = Self::INPUT); //~ ERROR interior mutable\n+    declare_const!(ANOTHER_INPUT: T = Self::INPUT);\n+    declare_const!(ANOTHER_ATOMIC: AtomicUsize = Self::ATOMIC); //~ ERROR interior mutable\n }\n \n trait Trait2 {\n-    type CopyType: Copy;\n+    type AssocType4;\n+    type AssocType5;\n \n     const SELF_2: Self;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `Self` to be `Copy`\n-    const ASSOC_2: Self::CopyType; // (no error)\n+    const ASSOC_4: Self::AssocType4;\n }\n \n-// we don't lint impl of traits, because an impl has no power to change the interface.\n-impl Trait<u32> for u64 {\n-    type NonCopyType = u16;\n+impl<T: Trait2<AssocType5 = AtomicUsize>> Trait<T> for u64 {\n+    type AssocType = u16;\n+    type AssocType2 = AtomicUsize;\n+    type AssocType3 = T;\n \n     const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n     const INTEGER: u64 = 10;\n     const STRING: String = String::new();\n     const SELF: Self = 11;\n-    const INPUT: u32 = 12;\n-    const ASSOC: Self::NonCopyType = 13;\n+    const INPUT: T = T::SELF_2;\n+    const INPUT_ASSOC: T::AssocType4 = T::ASSOC_4;\n+    const INPUT_ASSOC_2: T::AssocType5 = AtomicUsize::new(16);\n+    const ASSOC: Self::AssocType = 13;\n+    const ASSOC_2: Self::AssocType2 = AtomicUsize::new(15); //~ ERROR interior mutable\n+    const WRAPPED_ASSOC_2: Wrapper<Self::AssocType2> = Wrapper(AtomicUsize::new(16)); //~ ERROR interior mutable\n+    const WRAPPED_ASSOC_3: Wrapper<Self::AssocType3> = Wrapper(T::SELF_2);\n }\n \n struct Local<T, U>(T, U);\n \n-impl<T: Trait2 + Trait<u32>, U: Trait2> Local<T, U> {\n-    const ASSOC_3: AtomicUsize = AtomicUsize::new(14); //~ ERROR interior mutable\n+impl<T: Trait<U>, U: Trait2<AssocType5 = AtomicUsize>> Local<T, U> {\n+    const ASSOC_5: AtomicUsize = AtomicUsize::new(14); //~ ERROR interior mutable\n     const COW: Cow<'static, str> = Cow::Borrowed(\"tuvwxy\");\n-    const T_SELF: T = T::SELF_2;\n     const U_SELF: U = U::SELF_2;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `U` to be `Copy`\n-    const T_ASSOC: T::NonCopyType = T::ASSOC;\n-    //~^ ERROR interior mutable\n-    //~| HELP consider requiring `<T as Trait<u32>>::NonCopyType` to be `Copy`\n-    const U_ASSOC: U::CopyType = U::ASSOC_2;\n+    const T_ASSOC: T::AssocType = T::ASSOC;\n+    const U_ASSOC: U::AssocType5 = AtomicUsize::new(17); //~ ERROR interior mutable\n }\n \n fn main() {}"}, {"sha": "0fcb726db46ee2ef8be110300ff3afcf752df985", "filename": "tests/ui/declare_interior_mutable_const.stderr", "status": "modified", "additions": 19, "deletions": 43, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d655c0a938c16d30ae6824713165c749eff7210f/tests%2Fui%2Fdeclare_interior_mutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d655c0a938c16d30ae6824713165c749eff7210f/tests%2Fui%2Fdeclare_interior_mutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const.stderr?ref=d655c0a938c16d30ae6824713165c749eff7210f", "patch": "@@ -36,75 +36,51 @@ LL | declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:40:5\n+  --> $DIR/declare_interior_mutable_const.rs:44:5\n    |\n LL |     const ATOMIC: AtomicUsize; //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:44:5\n-   |\n-LL |     const INPUT: T;\n-   |     ^^^^^^^^^^^^^-^\n-   |                  |\n-   |                  consider requiring `T` to be `Copy`\n-\n-error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:47:5\n+  --> $DIR/declare_interior_mutable_const.rs:50:5\n    |\n-LL |     const ASSOC: Self::NonCopyType;\n-   |     ^^^^^^^^^^^^^-----------------^\n-   |                  |\n-   |                  consider requiring `<Self as Trait<T>>::NonCopyType` to be `Copy`\n-\n-error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:51:5\n-   |\n-LL |     const AN_INPUT: T = Self::INPUT;\n-   |     ^^^^^^^^^^^^^^^^-^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     consider requiring `T` to be `Copy`\n+LL |     const INPUT_ASSOC_2: T::AssocType5; //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n   --> $DIR/declare_interior_mutable_const.rs:16:9\n    |\n LL |         const $name: $ty = $e;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n ...\n-LL |     declare_const!(ANOTHER_INPUT: T = Self::INPUT); //~ ERROR interior mutable\n-   |     ----------------------------------------------- in this macro invocation\n+LL |     declare_const!(ANOTHER_ATOMIC: AtomicUsize = Self::ATOMIC); //~ ERROR interior mutable\n+   |     ----------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:60:5\n+  --> $DIR/declare_interior_mutable_const.rs:82:5\n    |\n-LL |     const SELF_2: Self;\n-   |     ^^^^^^^^^^^^^^----^\n-   |                   |\n-   |                   consider requiring `Self` to be `Copy`\n+LL |     const ASSOC_2: Self::AssocType2 = AtomicUsize::new(15); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:81:5\n+  --> $DIR/declare_interior_mutable_const.rs:83:5\n    |\n-LL |     const ASSOC_3: AtomicUsize = AtomicUsize::new(14); //~ ERROR interior mutable\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     const WRAPPED_ASSOC_2: Wrapper<Self::AssocType2> = Wrapper(AtomicUsize::new(16)); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:84:5\n+  --> $DIR/declare_interior_mutable_const.rs:90:5\n    |\n-LL |     const U_SELF: U = U::SELF_2;\n-   |     ^^^^^^^^^^^^^^-^^^^^^^^^^^^^\n-   |                   |\n-   |                   consider requiring `U` to be `Copy`\n+LL |     const ASSOC_5: AtomicUsize = AtomicUsize::new(14); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:87:5\n+  --> $DIR/declare_interior_mutable_const.rs:94:5\n    |\n-LL |     const T_ASSOC: T::NonCopyType = T::ASSOC;\n-   |     ^^^^^^^^^^^^^^^--------------^^^^^^^^^^^^\n-   |                    |\n-   |                    consider requiring `<T as Trait<u32>>::NonCopyType` to be `Copy`\n+LL |     const U_ASSOC: U::AssocType5 = AtomicUsize::new(17); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 11 previous errors\n "}]}