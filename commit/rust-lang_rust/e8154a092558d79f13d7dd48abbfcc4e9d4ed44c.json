{"sha": "e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MTU0YTA5MjU1OGQ3OWYxM2Q3ZGQ0OGFiYmZjYzRlOWQ0ZWQ0NGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-14T22:46:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-14T22:46:10Z"}, "message": "Auto merge of #39818 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 8 pull requests\n\n- Successful merges: #39659, #39730, #39754, #39772, #39785, #39788, #39790, #39813\n- Failed merges:", "tree": {"sha": "67f41f99c8d4adae5b9c5c82bbf2c9824709bb6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67f41f99c8d4adae5b9c5c82bbf2c9824709bb6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "html_url": "https://github.com/rust-lang/rust/commit/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48bc08247a7b4a5579437df54ca3f4a3fb25ce8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/48bc08247a7b4a5579437df54ca3f4a3fb25ce8d", "html_url": "https://github.com/rust-lang/rust/commit/48bc08247a7b4a5579437df54ca3f4a3fb25ce8d"}, {"sha": "4a919cba5b41ff1b8885dfebe5f246fe409e8004", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a919cba5b41ff1b8885dfebe5f246fe409e8004", "html_url": "https://github.com/rust-lang/rust/commit/4a919cba5b41ff1b8885dfebe5f246fe409e8004"}], "stats": {"total": 1085, "additions": 1045, "deletions": 40}, "files": [{"sha": "c4b97def3126b3b2615c6f9dfc311bc0dc862a2a", "filename": ".travis.yml", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -74,6 +74,20 @@ matrix:\n       osx_image: xcode8.2\n       install: *osx_install_sccache\n \n+    # \"alternate\" deployments, these are \"nightlies\" but don't have assertions\n+    # turned on, they're deployed to a different location primarily for projects\n+    # which are stuck on nightly and don't want llvm assertions in the artifacts\n+    # that they use.\n+    - env: IMAGE=dist-x86-linux DEPLOY_ALT=1\n+    - env: >\n+        RUST_CHECK_TARGET=dist\n+        RUST_CONFIGURE_ARGS=\"--enable-extended\"\n+        SRC=.\n+        DEPLOY_ALT=1\n+      os: osx\n+      osx_image: xcode8.2\n+      install: *osx_install_sccache\n+\n env:\n   global:\n     - SCCACHE_BUCKET=rust-lang-ci-sccache\n@@ -134,3 +148,19 @@ deploy:\n     on:\n       branch: auto\n       condition: $DEPLOY = 1\n+\n+  # this is the same as the above deployment provider except that it uploads to\n+  # a slightly different directory and has a different trigger\n+  - provider: s3\n+    bucket: rust-lang-ci\n+    skip_cleanup: true\n+    local_dir: deploy\n+    upload_dir: rustc-builds-alt\n+    acl: public_read\n+    region: us-east-1\n+    access_key_id: AKIAIPQVNYF2T3DTYIWQ\n+    secret_access_key:\n+      secure: \"FBqDqOTeIPMu6v/WYPf4CFSlh9rLRZGKVtpLa5KkyuOhXRTrnEzBduEtS8/FMIxdQImvurhSvxWvqRybMOi4qoVfjMqqpHAI7uBbidbrvAcJoHNsx6BgUNVCIoH6a0UsAjTUtm6/YPIpzbHoLZXPL0GrHPMk6Mu04qVSmcYNWn4=\"\n+    on:\n+      branch: auto\n+      condition: $DEPLOY_ALT = 1"}, {"sha": "6b906fd9ab618110fa47e23b386398882084ebab", "filename": "appveyor.yml", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -60,6 +60,12 @@ environment:\n     MINGW_DIR: mingw64\n     DEPLOY: 1\n \n+  # \"alternate\" deployment, see .travis.yml for more info\n+  - MSYS_BITS: 64\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended\n+    SCRIPT: python x.py dist\n+    DEPLOY_ALT: 1\n+\n matrix:\n   fast_finish: true\n \n@@ -145,6 +151,22 @@ deploy:\n       branch: auto\n       DEPLOY: 1\n \n+  # This provider is the same as the one above except that it has a slightly\n+  # different upload directory and a slightly different trigger\n+  - provider: S3\n+    skip_cleanup: true\n+    access_key_id: AKIAIPQVNYF2T3DTYIWQ\n+    secret_access_key:\n+      secure: +11jsUNFTQ9dq5Ad1i2+PeUJaXluFJ0zIJAXESE1dFT3Kdjku4/eDdgyjgsB6GnV\n+    bucket: rust-lang-ci\n+    set_public: true\n+    region: us-east-1\n+    artifact: /.*/\n+    folder: rustc-builds-alt\n+    on:\n+      branch: auto\n+      DEPLOY_ALT: 1\n+\n # init:\n #   - ps: iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))\n # on_finish:"}, {"sha": "892c5baa5c64b03944f454e3759424c86ff3f083", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -49,6 +49,7 @@ exec docker \\\n   $args \\\n   --env CARGO_HOME=/cargo \\\n   --env DEPLOY=$DEPLOY \\\n+  --env DEPLOY_ALT=$DEPLOY_ALT \\\n   --env LOCAL_USER_ID=`id -u` \\\n   --volume \"$HOME/.cargo:/cargo\" \\\n   --rm \\"}, {"sha": "4941ddad0f3d67cfa3900cafbcac8afa9dca1883", "filename": "src/ci/run.sh", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -31,12 +31,14 @@ RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-locked-deps\"\n #\n # FIXME: need a scheme for changing this `nightly` value to `beta` and `stable`\n #        either automatically or manually.\n-if [ \"$DEPLOY\" != \"\" ]; then\n+if [ \"$DEPLOY$DEPLOY_ALT\" != \"\" ]; then\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --release-channel=nightly\"\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-static-stdcpp\"\n \n   if [ \"$NO_LLVM_ASSERTIONS\" = \"1\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-llvm-assertions\"\n+  elif [ \"$DEPLOY_ALT\" != \"\" ]; then\n+    RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-llvm-assertions\"\n   fi\n else\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-debug-assertions\""}, {"sha": "0c86eb42e7acb745898b530695585c50abdfd224", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -117,22 +117,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCamelCaseTypes {\n \n         match it.node {\n             hir::ItemTy(..) |\n+            hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => self.check_case(cx, \"type\", it.name, it.span),\n             hir::ItemTrait(..) => self.check_case(cx, \"trait\", it.name, it.span),\n-            hir::ItemEnum(ref enum_definition, _) => {\n-                if has_extern_repr {\n-                    return;\n-                }\n-                self.check_case(cx, \"type\", it.name, it.span);\n-                for variant in &enum_definition.variants {\n-                    self.check_case(cx, \"variant\", variant.node.name, variant.span);\n-                }\n-            }\n             _ => (),\n         }\n     }\n \n+    fn check_variant(&mut self, cx: &LateContext, v: &hir::Variant, _: &hir::Generics) {\n+        self.check_case(cx, \"variant\", v.node.name, v.span);\n+    }\n+\n     fn check_generics(&mut self, cx: &LateContext, it: &hir::Generics) {\n         for gen in it.ty_params.iter() {\n             self.check_case(cx, \"type parameter\", gen.name, gen.span);"}, {"sha": "c67e2fdc2b0276a7ecf45938b19cfb66f94cdef5", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -155,7 +155,8 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n     let mut opts = TestOptions::default();\n     opts.no_crate_inject = true;\n     let mut collector = Collector::new(input.to_string(), cfgs, libs, externs,\n-                                       true, opts, maybe_sysroot, None);\n+                                       true, opts, maybe_sysroot, None,\n+                                       Some(input.to_owned()));\n     find_testable_code(&input_str, &mut collector, DUMMY_SP);\n     test_args.insert(0, \"rustdoctest\".to_string());\n     testing::test_main(&test_args, collector.tests);"}, {"sha": "1c37067d7f69d46f8914db8fd4ed496dec3eccd9", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -104,7 +104,8 @@ pub fn run(input: &str,\n                                        false,\n                                        opts,\n                                        maybe_sysroot,\n-                                       Some(codemap));\n+                                       Some(codemap),\n+                                       None);\n \n     {\n         let dep_graph = DepGraph::new(false);\n@@ -391,12 +392,13 @@ pub struct Collector {\n     maybe_sysroot: Option<PathBuf>,\n     position: Span,\n     codemap: Option<Rc<CodeMap>>,\n+    filename: Option<String>,\n }\n \n impl Collector {\n     pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n                use_headers: bool, opts: TestOptions, maybe_sysroot: Option<PathBuf>,\n-               codemap: Option<Rc<CodeMap>>) -> Collector {\n+               codemap: Option<Rc<CodeMap>>, filename: Option<String>) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             names: Vec::new(),\n@@ -411,6 +413,7 @@ impl Collector {\n             maybe_sysroot: maybe_sysroot,\n             position: DUMMY_SP,\n             codemap: codemap,\n+            filename: filename,\n         }\n     }\n \n@@ -483,6 +486,8 @@ impl Collector {\n     pub fn get_filename(&self) -> String {\n         if let Some(ref codemap) = self.codemap {\n             codemap.span_to_filename(self.position)\n+        } else if let Some(ref filename) = self.filename {\n+            filename.clone()\n         } else {\n             \"<input>\".to_owned()\n         }"}, {"sha": "af21d6d906eb5d2569964202e91f1510f0fc9408", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 858, "deletions": 0, "changes": 858, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -184,6 +184,368 @@ pub trait AsciiExt {\n     /// [`to_ascii_lowercase`]: #tymethod.to_ascii_lowercase\n     #[stable(feature = \"ascii\", since = \"1.9.0\")]\n     fn make_ascii_lowercase(&mut self);\n+\n+    /// Checks if the value is an ASCII alphabetic character:\n+    /// U+0041 'A' ... U+005A 'Z' or U+0061 'a' ... U+007A 'z'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII alphabetic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    /// # #![allow(non_snake_case)]\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(A.is_ascii_alphabetic());\n+    /// assert!(G.is_ascii_alphabetic());\n+    /// assert!(a.is_ascii_alphabetic());\n+    /// assert!(g.is_ascii_alphabetic());\n+    /// assert!(!zero.is_ascii_alphabetic());\n+    /// assert!(!percent.is_ascii_alphabetic());\n+    /// assert!(!space.is_ascii_alphabetic());\n+    /// assert!(!lf.is_ascii_alphabetic());\n+    /// assert!(!esc.is_ascii_alphabetic());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_alphabetic(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII uppercase character:\n+    /// U+0041 'A' ... U+005A 'Z'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII uppercase.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    /// # #![allow(non_snake_case)]\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(A.is_ascii_uppercase());\n+    /// assert!(G.is_ascii_uppercase());\n+    /// assert!(!a.is_ascii_uppercase());\n+    /// assert!(!g.is_ascii_uppercase());\n+    /// assert!(!zero.is_ascii_uppercase());\n+    /// assert!(!percent.is_ascii_uppercase());\n+    /// assert!(!space.is_ascii_uppercase());\n+    /// assert!(!lf.is_ascii_uppercase());\n+    /// assert!(!esc.is_ascii_uppercase());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_uppercase(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII lowercase character:\n+    /// U+0061 'a' ... U+007A 'z'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII lowercase.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    /// # #![allow(non_snake_case)]\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(!A.is_ascii_lowercase());\n+    /// assert!(!G.is_ascii_lowercase());\n+    /// assert!(a.is_ascii_lowercase());\n+    /// assert!(g.is_ascii_lowercase());\n+    /// assert!(!zero.is_ascii_lowercase());\n+    /// assert!(!percent.is_ascii_lowercase());\n+    /// assert!(!space.is_ascii_lowercase());\n+    /// assert!(!lf.is_ascii_lowercase());\n+    /// assert!(!esc.is_ascii_lowercase());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_lowercase(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII alphanumeric character:\n+    /// U+0041 'A' ... U+005A 'Z', U+0061 'a' ... U+007A 'z', or\n+    /// U+0030 '0' ... U+0039 '9'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII alphanumeric.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    /// # #![allow(non_snake_case)]\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(A.is_ascii_alphanumeric());\n+    /// assert!(G.is_ascii_alphanumeric());\n+    /// assert!(a.is_ascii_alphanumeric());\n+    /// assert!(g.is_ascii_alphanumeric());\n+    /// assert!(zero.is_ascii_alphanumeric());\n+    /// assert!(!percent.is_ascii_alphanumeric());\n+    /// assert!(!space.is_ascii_alphanumeric());\n+    /// assert!(!lf.is_ascii_alphanumeric());\n+    /// assert!(!esc.is_ascii_alphanumeric());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_alphanumeric(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII decimal digit:\n+    /// U+0030 '0' ... U+0039 '9'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII digits.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    /// # #![allow(non_snake_case)]\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(!A.is_ascii_digit());\n+    /// assert!(!G.is_ascii_digit());\n+    /// assert!(!a.is_ascii_digit());\n+    /// assert!(!g.is_ascii_digit());\n+    /// assert!(zero.is_ascii_digit());\n+    /// assert!(!percent.is_ascii_digit());\n+    /// assert!(!space.is_ascii_digit());\n+    /// assert!(!lf.is_ascii_digit());\n+    /// assert!(!esc.is_ascii_digit());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_digit(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII hexadecimal digit:\n+    /// U+0030 '0' ... U+0039 '9', U+0041 'A' ... U+0046 'F', or\n+    /// U+0061 'a' ... U+0066 'f'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII hex digits.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    /// # #![allow(non_snake_case)]\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(A.is_ascii_hexdigit());\n+    /// assert!(!G.is_ascii_hexdigit());\n+    /// assert!(a.is_ascii_hexdigit());\n+    /// assert!(!g.is_ascii_hexdigit());\n+    /// assert!(zero.is_ascii_hexdigit());\n+    /// assert!(!percent.is_ascii_hexdigit());\n+    /// assert!(!space.is_ascii_hexdigit());\n+    /// assert!(!lf.is_ascii_hexdigit());\n+    /// assert!(!esc.is_ascii_hexdigit());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_hexdigit(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII punctuation character:\n+    /// U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`\n+    /// U+003A ... U+0040 `: ; < = > ? @`\n+    /// U+005B ... U+0060 `[ \\\\ ] ^ _ \\``\n+    /// U+007B ... U+007E `{ | } ~`\n+    /// For strings, true if all characters in the string are\n+    /// ASCII punctuation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    /// # #![allow(non_snake_case)]\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(!A.is_ascii_punctuation());\n+    /// assert!(!G.is_ascii_punctuation());\n+    /// assert!(!a.is_ascii_punctuation());\n+    /// assert!(!g.is_ascii_punctuation());\n+    /// assert!(!zero.is_ascii_punctuation());\n+    /// assert!(percent.is_ascii_punctuation());\n+    /// assert!(!space.is_ascii_punctuation());\n+    /// assert!(!lf.is_ascii_punctuation());\n+    /// assert!(!esc.is_ascii_punctuation());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_punctuation(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII graphic character:\n+    /// U+0021 '@' ... U+007E '~'.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII punctuation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    /// # #![allow(non_snake_case)]\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(A.is_ascii_graphic());\n+    /// assert!(G.is_ascii_graphic());\n+    /// assert!(a.is_ascii_graphic());\n+    /// assert!(g.is_ascii_graphic());\n+    /// assert!(zero.is_ascii_graphic());\n+    /// assert!(percent.is_ascii_graphic());\n+    /// assert!(!space.is_ascii_graphic());\n+    /// assert!(!lf.is_ascii_graphic());\n+    /// assert!(!esc.is_ascii_graphic());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_graphic(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII whitespace character:\n+    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n+    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n+    /// For strings, true if all characters in the string are\n+    /// ASCII whitespace.\n+    ///\n+    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n+    /// whitespace][infra-aw].  There are several other definitions in\n+    /// wide use.  For instance, [the POSIX locale][pct] includes\n+    /// U+000B VERTICAL TAB as well as all the above characters,\n+    /// but\u2014from the very same specification\u2014[the default rule for\n+    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n+    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n+    ///\n+    /// If you are writing a program that will process an existing\n+    /// file format, check what that format's definition of whitespace is\n+    /// before using this function.\n+    ///\n+    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n+    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n+    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    /// # #![allow(non_snake_case)]\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(!A.is_ascii_whitespace());\n+    /// assert!(!G.is_ascii_whitespace());\n+    /// assert!(!a.is_ascii_whitespace());\n+    /// assert!(!g.is_ascii_whitespace());\n+    /// assert!(!zero.is_ascii_whitespace());\n+    /// assert!(!percent.is_ascii_whitespace());\n+    /// assert!(space.is_ascii_whitespace());\n+    /// assert!(lf.is_ascii_whitespace());\n+    /// assert!(!esc.is_ascii_whitespace());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_whitespace(&self) -> bool { unimplemented!(); }\n+\n+    /// Checks if the value is an ASCII control character:\n+    /// U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n+    /// Note that most ASCII whitespace characters are control\n+    /// characters, but SPACE is not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    /// # #![allow(non_snake_case)]\n+    /// use std::ascii::AsciiExt;\n+    /// let A = 'A';\n+    /// let G = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc = '\\u{001b}';\n+    ///\n+    /// assert!(!A.is_ascii_control());\n+    /// assert!(!G.is_ascii_control());\n+    /// assert!(!a.is_ascii_control());\n+    /// assert!(!g.is_ascii_control());\n+    /// assert!(!zero.is_ascii_control());\n+    /// assert!(!percent.is_ascii_control());\n+    /// assert!(!space.is_ascii_control());\n+    /// assert!(lf.is_ascii_control());\n+    /// assert!(esc.is_ascii_control());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    fn is_ascii_control(&self) -> bool { unimplemented!(); }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -225,6 +587,56 @@ impl AsciiExt for str {\n         let me: &mut [u8] = unsafe { mem::transmute(self) };\n         me.make_ascii_lowercase()\n     }\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_digit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_control())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -268,6 +680,56 @@ impl AsciiExt for [u8] {\n             byte.make_ascii_lowercase();\n         }\n     }\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_digit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_control())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -287,6 +749,96 @@ impl AsciiExt for u8 {\n     fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }\n     #[inline]\n     fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            L|Lx|U|Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            U|Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            L|Lx => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D|L|Lx|U|Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D|Lx|Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            P => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            Ux|U|Lx|L|D|P => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            Cw|W => true,\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            C|Cw => true,\n+            _ => false\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -324,6 +876,56 @@ impl AsciiExt for char {\n     fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }\n     #[inline]\n     fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_alphabetic()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_uppercase()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_lowercase()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_alphanumeric()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_digit()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_hexdigit()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_punctuation()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_graphic()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_whitespace()\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_control()\n+    }\n }\n \n /// An iterator over the escaped version of a byte, constructed via\n@@ -485,6 +1087,30 @@ static ASCII_UPPERCASE_MAP: [u8; 256] = [\n     0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n ];\n \n+enum AsciiCharacterClass {\n+    C,  // control\n+    Cw, // control whitespace\n+    W,  // whitespace\n+    D,  // digit\n+    L,  // lowercase\n+    Lx, // lowercase hex digit\n+    U,  // uppercase\n+    Ux, // uppercase hex digit\n+    P,  // punctuation\n+}\n+use self::AsciiCharacterClass::*;\n+\n+static ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 128] = [\n+//  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n+    C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_\n+    C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, // 1_\n+    W, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, // 2_\n+    D, D, D, D, D, D, D, D, D, D, P, P, P, P, P, P, // 3_\n+    P, Ux,Ux,Ux,Ux,Ux,Ux,U, U, U, U, U, U, U, U, U, // 4_\n+    U, U, U, U, U, U, U, U, U, U, U, P, P, P, P, P, // 5_\n+    P, Lx,Lx,Lx,Lx,Lx,Lx,L, L, L, L, L, L, L, L, L, // 6_\n+    L, L, L, L, L, L, L, L, L, L, L, P, P, P, P, C, // 7_\n+];\n \n #[cfg(test)]\n mod tests {\n@@ -606,4 +1232,236 @@ mod tests {\n         let x = \"a\".to_string();\n         x.eq_ignore_ascii_case(\"A\");\n     }\n+\n+    // Shorthands used by the is_ascii_* tests.\n+    macro_rules! assert_all {\n+        ($what:ident, $($str:tt),+) => {{\n+            $(\n+                for b in $str.chars() {\n+                    if !b.$what() {\n+                        panic!(\"expected {}({}) but it isn't\",\n+                               stringify!($what), b);\n+                    }\n+                }\n+                for b in $str.as_bytes().iter() {\n+                    if !b.$what() {\n+                        panic!(\"expected {}(0x{:02x})) but it isn't\",\n+                               stringify!($what), b);\n+                    }\n+                }\n+                assert!($str.$what());\n+                assert!($str.as_bytes().$what());\n+            )+\n+        }};\n+        ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))\n+    }\n+    macro_rules! assert_none {\n+        ($what:ident, $($str:tt),+) => {{\n+            $(\n+                for b in $str.chars() {\n+                    if b.$what() {\n+                        panic!(\"expected not-{}({}) but it is\",\n+                               stringify!($what), b);\n+                    }\n+                }\n+                for b in $str.as_bytes().iter() {\n+                    if b.$what() {\n+                        panic!(\"expected not-{}(0x{:02x})) but it is\",\n+                               stringify!($what), b);\n+                    }\n+                }\n+            )*\n+        }};\n+        ($what:ident, $($str:tt),+,) => (assert_none!($what,$($str),+))\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_alphabetic() {\n+        assert_all!(is_ascii_alphabetic,\n+            \"\",\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        );\n+        assert_none!(is_ascii_alphabetic,\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_uppercase() {\n+        assert_all!(is_ascii_uppercase,\n+            \"\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        );\n+        assert_none!(is_ascii_uppercase,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_lowercase() {\n+        assert_all!(is_ascii_lowercase,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+        );\n+        assert_none!(is_ascii_lowercase,\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_alphanumeric() {\n+        assert_all!(is_ascii_alphanumeric,\n+            \"\",\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+        );\n+        assert_none!(is_ascii_alphanumeric,\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_digit() {\n+        assert_all!(is_ascii_digit,\n+            \"\",\n+            \"0123456789\",\n+        );\n+        assert_none!(is_ascii_digit,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_hexdigit() {\n+        assert_all!(is_ascii_hexdigit,\n+            \"\",\n+            \"0123456789\",\n+            \"abcdefABCDEF\",\n+        );\n+        assert_none!(is_ascii_hexdigit,\n+            \"ghijklmnopqrstuvwxyz\",\n+            \"GHIJKLMNOQPRSTUVWXYZ\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_punctuation() {\n+        assert_all!(is_ascii_punctuation,\n+            \"\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        );\n+        assert_none!(is_ascii_punctuation,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_graphic() {\n+        assert_all!(is_ascii_graphic,\n+            \"\",\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        );\n+        assert_none!(is_ascii_graphic,\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_whitespace() {\n+        assert_all!(is_ascii_whitespace,\n+            \"\",\n+            \" \\t\\n\\x0c\\r\",\n+        );\n+        assert_none!(is_ascii_whitespace,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x0b\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_control() {\n+        assert_all!(is_ascii_control,\n+            \"\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+        assert_none!(is_ascii_control,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \",\n+        );\n+    }\n }"}, {"sha": "2c4fa8e15edf2bbf54ee91868e8d4368f4d627dd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -302,11 +302,20 @@ impl<'a> Parser<'a> {\n                 if i + 1 < tts.len() {\n                     self.tts.push((tts, i + 1));\n                 }\n-                if let TokenTree::Token(sp, tok) = tt {\n-                    TokenAndSpan { tok: tok, sp: sp }\n-                } else {\n-                    self.tts.push((tt, 0));\n-                    continue\n+                // FIXME(jseyfried): remove after fixing #39390 in #39419.\n+                if self.quote_depth > 0 {\n+                    if let TokenTree::Sequence(sp, _) = tt {\n+                        self.span_err(sp, \"attempted to repeat an expression containing no \\\n+                                           syntax variables matched as repeating at this depth\");\n+                    }\n+                }\n+                match tt {\n+                    TokenTree::Token(sp, tok) => TokenAndSpan { tok: tok, sp: sp },\n+                    _ if tt.len() > 0 => {\n+                        self.tts.push((tt, 0));\n+                        continue\n+                    }\n+                    _ => continue,\n                 }\n             } else {\n                 TokenAndSpan { tok: token::Eof, sp: self.span }"}, {"sha": "014a0aaaf68e67b0bb0fb93c4dbc9c652c812042", "filename": "src/test/compile-fail/feature-gate-staged_api.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Ftest%2Fcompile-fail%2Ffeature-gate-staged_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Ftest%2Fcompile-fail%2Ffeature-gate-staged_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-staged_api.rs?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![stable(feature = \"a\", since = \"b\")]\n+//~^ ERROR stability attributes may not be used outside of the standard library\n+mod inner_private_module {\n+    // UnnameableTypeAlias isn't marked as reachable, so no stability annotation is required here\n+    pub type UnnameableTypeAlias = u8;\n+}\n+\n+#[stable(feature = \"a\", since = \"b\")]\n+//~^ ERROR stability attributes may not be used outside of the standard library\n+pub fn f() -> inner_private_module::UnnameableTypeAlias {\n+    0\n+}\n+\n+fn main() {}"}, {"sha": "0f66fe84393363cc2e90b5b3ff9c6ca00b2d70dc", "filename": "src/test/compile-fail/issue-39709.rs", "status": "renamed", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Ftest%2Fcompile-fail%2Fissue-39709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Ftest%2Fcompile-fail%2Fissue-39709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39709.rs?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -8,14 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::thread;\n-\n-static mut ANSWER: i32 = 0;\n-\n fn main() {\n-    let t1 = thread::spawn(|| unsafe { ANSWER = 42 });\n-    unsafe {\n-        ANSWER = 24;\n-    }\n-    t1.join().ok();\n+    println!(\"{}\", { macro_rules! x { ($()*) => {} } 33 });\n+    //~^ ERROR no syntax variables matched as repeating at this depth\n }\n+", "previous_filename": "src/test/run-make/sanitizer-thread/racy.rs"}, {"sha": "8bb89a241cb053007ca3c9ead0c144a8078c6442", "filename": "src/test/run-make/sanitizer-thread/Makefile", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48bc08247a7b4a5579437df54ca3f4a3fb25ce8d/src%2Ftest%2Frun-make%2Fsanitizer-thread%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/48bc08247a7b4a5579437df54ca3f4a3fb25ce8d/src%2Ftest%2Frun-make%2Fsanitizer-thread%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsanitizer-thread%2FMakefile?ref=48bc08247a7b4a5579437df54ca3f4a3fb25ce8d", "patch": "@@ -1,10 +0,0 @@\n--include ../tools.mk\n-\n-ifdef SANITIZER_SUPPORT\n-all:\n-\t$(RUSTC) -g -Z sanitizer=thread -Z print-link-args racy.rs | grep -q librustc_tsan\n-\t$(TMPDIR)/racy 2>&1 | grep -q 'data race'\n-else\n-all:\n-\n-endif"}, {"sha": "c7073b3a95e1210f18ad547fbfc55bba7e6e389d", "filename": "src/test/run-pass/test-allow-non-camel-case-variant.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Ftest%2Frun-pass%2Ftest-allow-non-camel-case-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Ftest%2Frun-pass%2Ftest-allow-non-camel-case-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-allow-non-camel-case-variant.rs?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(non_camel_case_types)]\n+\n+pub enum Foo {\n+    #[allow(non_camel_case_types)]\n+    bar\n+}\n+\n+fn main() {}"}, {"sha": "cb6e73237d5ebf847fbb61b75336ff83b8f69ce6", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -167,7 +167,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n     // FIXME get this whitelist empty.\n     let whitelist = vec![\n         \"abi_ptx\", \"simd\", \"static_recursion\",\n-        \"cfg_target_has_atomic\", \"staged_api\",\n+        \"cfg_target_has_atomic\",\n         \"unboxed_closures\", \"stmt_expr_attributes\",\n         \"cfg_target_thread_local\", \"unwind_attributes\",\n         \"inclusive_range_syntax\""}, {"sha": "2233f8c3529748dcc43bdd6e0f333bc147172548", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8154a092558d79f13d7dd48abbfcc4e9d4ed44c/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=e8154a092558d79f13d7dd48abbfcc4e9d4ed44c", "patch": "@@ -38,6 +38,60 @@ http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n option. This file may not be copied, modified, or distributed\n except according to those terms.\";\n \n+/// Parser states for line_is_url.\n+#[derive(PartialEq)]\n+#[allow(non_camel_case_types)]\n+enum LIUState { EXP_COMMENT_START,\n+                EXP_LINK_LABEL_OR_URL,\n+                EXP_URL,\n+                EXP_END }\n+\n+/// True if LINE appears to be a line comment containing an URL,\n+/// possibly with a Markdown link label in front, and nothing else.\n+/// The Markdown link label, if present, may not contain whitespace.\n+/// Lines of this form are allowed to be overlength, because Markdown\n+/// offers no way to split a line in the middle of a URL, and the lengths\n+/// of URLs to external references are beyond our control.\n+fn line_is_url(line: &str) -> bool {\n+    use self::LIUState::*;\n+    let mut state: LIUState = EXP_COMMENT_START;\n+\n+    for tok in line.split_whitespace() {\n+        match (state, tok) {\n+            (EXP_COMMENT_START, \"//\") => state = EXP_LINK_LABEL_OR_URL,\n+            (EXP_COMMENT_START, \"///\") => state = EXP_LINK_LABEL_OR_URL,\n+            (EXP_COMMENT_START, \"//!\") => state = EXP_LINK_LABEL_OR_URL,\n+\n+            (EXP_LINK_LABEL_OR_URL, w)\n+                if w.len() >= 4 && w.starts_with(\"[\") && w.ends_with(\"]:\")\n+                => state = EXP_URL,\n+\n+            (EXP_LINK_LABEL_OR_URL, w)\n+                if w.starts_with(\"http://\") || w.starts_with(\"https://\")\n+                => state = EXP_END,\n+\n+            (EXP_URL, w)\n+                if w.starts_with(\"http://\") || w.starts_with(\"https://\")\n+                => state = EXP_END,\n+\n+            (_, _) => return false,\n+        }\n+    }\n+\n+    state == EXP_END\n+}\n+\n+/// True if LINE is allowed to be longer than the normal limit.\n+/// Currently there is only one exception, for long URLs, but more\n+/// may be added in the future.\n+fn long_line_is_ok(line: &str) -> bool {\n+    if line_is_url(line) {\n+        return true;\n+    }\n+\n+    false\n+}\n+\n pub fn check(path: &Path, bad: &mut bool) {\n     let mut contents = String::new();\n     super::walk(path, &mut super::filter_dirs, &mut |file| {\n@@ -61,8 +115,9 @@ pub fn check(path: &Path, bad: &mut bool) {\n                 println!(\"{}:{}: {}\", file.display(), i + 1, msg);\n                 *bad = true;\n             };\n-            if line.chars().count() > COLS && !skip_length {\n-                err(&format!(\"line longer than {} chars\", COLS));\n+            if !skip_length && line.chars().count() > COLS\n+                && !long_line_is_ok(line) {\n+                    err(&format!(\"line longer than {} chars\", COLS));\n             }\n             if line.contains(\"\\t\") && !skip_tab {\n                 err(\"tab character\");"}]}