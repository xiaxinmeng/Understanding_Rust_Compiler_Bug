{"sha": "fe49981ea0069f6b89e4511d5de92b7027d9b688", "node_id": "C_kwDOAAsO6NoAKGZlNDk5ODFlYTAwNjlmNmI4OWU0NTExZDVkZTkyYjcwMjdkOWI2ODg", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-04-26T11:22:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-26T11:22:27Z"}, "message": "Rollup merge of #94703 - kjetilkjeka:nvptx-kernel-args-abi2, r=nagisa\n\nFix codegen bug in \"ptx-kernel\" abi related to arg passing\n\nI found a codegen bug in the nvptx abi related to that args are passed as ptrs ([see comment](https://github.com/rust-lang/rust/issues/38788#issuecomment-1048999928)), this is not as specified in the [ptx-interoperability doc](https://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/) or how C/C++ does it. It will also almost always fail in practice since device/host uses different memory spaces for most hardware.\n\nThis PR fixes the bug and add tests for passing structs to ptx kernels.\n\nI observed that all nvptx assembly tests had been marked as [ignore a long time ago](https://github.com/rust-lang/rust/pull/59752#issuecomment-501713428). I'm not sure if the new one should be marked as ignore, it passed on my computer but it might fail if ptx-linker is missing on the server? I guess this is outside scope for this PR and should be looked at in a different issue/PR.\n\nI only fixed the nvptx64-nvidia-cuda target and not the potential code paths for the non-existing 32bit target. Even though 32bit nvptx is not a supported target there are still some code under the hood supporting codegen for 32 bit ptx. I was advised to create an MCP to find out if this code should be removed or updated.\n\nPerhaps ``@RDambrosio016`` would have interest in taking a quick look at this.", "tree": {"sha": "506d49735cd47ce97bc37e7fbe885cc85c77aa0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/506d49735cd47ce97bc37e7fbe885cc85c77aa0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe49981ea0069f6b89e4511d5de92b7027d9b688", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiZ9XzCRBK7hj4Ov3rIwAAIAAIAFSLY3JDjVzLtuyjaNZNHDTK\nAeGxHwOWNBRCjBWN6YEtnfs7kDBTXTTsTfP9A+bD3+Xm+SSui0MtvNyE3531qKdY\nC6j1OV9s87pQGoa6a1T5LTiFVDM6/Ojfi1FLv8v612JmWCEfrn+vccs5P37wgLlx\nFAOttpiLLI7Xm2tFS5p2iPhu1CdqJLKONM/ekOxCLOG4908JpHJBt+T7q6rAVmXT\nFYCeQySWSl6qigvFu3jHUFLau6waeJ5wqKS+k7r/lFyVT21qz/1l1HpYzpWveK4C\nw7glFxXNfEHXCuYIYfVsJyiGpgQM++0f7BtjWKwMINNiZ1SGxa5IsyV4nyDpHMw=\n=3T85\n-----END PGP SIGNATURE-----\n", "payload": "tree 506d49735cd47ce97bc37e7fbe885cc85c77aa0d\nparent eaf8beb3f32b089b426a435794214ee0eaed8fec\nparent 5bf5acc324f56fad271a97a93b7976d7d3aa67fb\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1650972147 +0200\ncommitter GitHub <noreply@github.com> 1650972147 +0200\n\nRollup merge of #94703 - kjetilkjeka:nvptx-kernel-args-abi2, r=nagisa\n\nFix codegen bug in \"ptx-kernel\" abi related to arg passing\n\nI found a codegen bug in the nvptx abi related to that args are passed as ptrs ([see comment](https://github.com/rust-lang/rust/issues/38788#issuecomment-1048999928)), this is not as specified in the [ptx-interoperability doc](https://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/) or how C/C++ does it. It will also almost always fail in practice since device/host uses different memory spaces for most hardware.\n\nThis PR fixes the bug and add tests for passing structs to ptx kernels.\n\nI observed that all nvptx assembly tests had been marked as [ignore a long time ago](https://github.com/rust-lang/rust/pull/59752#issuecomment-501713428). I'm not sure if the new one should be marked as ignore, it passed on my computer but it might fail if ptx-linker is missing on the server? I guess this is outside scope for this PR and should be looked at in a different issue/PR.\n\nI only fixed the nvptx64-nvidia-cuda target and not the potential code paths for the non-existing 32bit target. Even though 32bit nvptx is not a supported target there are still some code under the hood supporting codegen for 32 bit ptx. I was advised to create an MCP to find out if this code should be removed or updated.\n\nPerhaps ``@RDambrosio016`` would have interest in taking a quick look at this.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe49981ea0069f6b89e4511d5de92b7027d9b688", "html_url": "https://github.com/rust-lang/rust/commit/fe49981ea0069f6b89e4511d5de92b7027d9b688", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe49981ea0069f6b89e4511d5de92b7027d9b688/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaf8beb3f32b089b426a435794214ee0eaed8fec", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf8beb3f32b089b426a435794214ee0eaed8fec", "html_url": "https://github.com/rust-lang/rust/commit/eaf8beb3f32b089b426a435794214ee0eaed8fec"}, {"sha": "5bf5acc324f56fad271a97a93b7976d7d3aa67fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bf5acc324f56fad271a97a93b7976d7d3aa67fb", "html_url": "https://github.com/rust-lang/rust/commit/5bf5acc324f56fad271a97a93b7976d7d3aa67fb"}], "stats": {"total": 361, "additions": 352, "deletions": 9}, "files": [{"sha": "cd4b23fca393282a40126213a1b24c35be53a042", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe49981ea0069f6b89e4511d5de92b7027d9b688/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe49981ea0069f6b89e4511d5de92b7027d9b688/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=fe49981ea0069f6b89e4511d5de92b7027d9b688", "patch": "@@ -2592,6 +2592,22 @@ where\n \n         pointee_info\n     }\n+\n+    fn is_adt(this: TyAndLayout<'tcx>) -> bool {\n+        matches!(this.ty.kind(), ty::Adt(..))\n+    }\n+\n+    fn is_never(this: TyAndLayout<'tcx>) -> bool {\n+        this.ty.kind() == &ty::Never\n+    }\n+\n+    fn is_tuple(this: TyAndLayout<'tcx>) -> bool {\n+        matches!(this.ty.kind(), ty::Tuple(..))\n+    }\n+\n+    fn is_unit(this: TyAndLayout<'tcx>) -> bool {\n+        matches!(this.ty.kind(), ty::Tuple(list) if list.len() == 0)\n+    }\n }\n \n impl<'tcx> ty::Instance<'tcx> {"}, {"sha": "197dc9205b4804d97fb79d07360afba35606ce72", "filename": "compiler/rustc_middle/src/ty/list.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe49981ea0069f6b89e4511d5de92b7027d9b688/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe49981ea0069f6b89e4511d5de92b7027d9b688/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs?ref=fe49981ea0069f6b89e4511d5de92b7027d9b688", "patch": "@@ -61,6 +61,10 @@ impl<T> List<T> {\n         static EMPTY_SLICE: InOrder<usize, MaxAlign> = InOrder(0, MaxAlign);\n         unsafe { &*(&EMPTY_SLICE as *const _ as *const List<T>) }\n     }\n+\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n }\n \n impl<T: Copy> List<T> {"}, {"sha": "afce10ff1cbe8f36510626fd4696e1e46c22874c", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe49981ea0069f6b89e4511d5de92b7027d9b688/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe49981ea0069f6b89e4511d5de92b7027d9b688/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=fe49981ea0069f6b89e4511d5de92b7027d9b688", "patch": "@@ -696,7 +696,13 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             \"sparc\" => sparc::compute_abi_info(cx, self),\n             \"sparc64\" => sparc64::compute_abi_info(cx, self),\n             \"nvptx\" => nvptx::compute_abi_info(self),\n-            \"nvptx64\" => nvptx64::compute_abi_info(self),\n+            \"nvptx64\" => {\n+                if cx.target_spec().adjust_abi(abi) == spec::abi::Abi::PtxKernel {\n+                    nvptx64::compute_ptx_kernel_abi_info(cx, self)\n+                } else {\n+                    nvptx64::compute_abi_info(self)\n+                }\n+            }\n             \"hexagon\" => hexagon::compute_abi_info(self),\n             \"riscv32\" | \"riscv64\" => riscv::compute_abi_info(cx, self),\n             \"wasm32\" | \"wasm64\" => {"}, {"sha": "fc16f1c97a4522dc45d1e3680c66ac35728886bc", "filename": "compiler/rustc_target/src/abi/call/nvptx64.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fe49981ea0069f6b89e4511d5de92b7027d9b688/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fnvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe49981ea0069f6b89e4511d5de92b7027d9b688/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fnvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fnvptx64.rs?ref=fe49981ea0069f6b89e4511d5de92b7027d9b688", "patch": "@@ -1,21 +1,35 @@\n-// Reference: PTX Writer's Guide to Interoperability\n-// https://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n-\n-use crate::abi::call::{ArgAbi, FnAbi};\n+use crate::abi::call::{ArgAbi, FnAbi, PassMode, Reg, Size, Uniform};\n+use crate::abi::{HasDataLayout, TyAbiInterface};\n \n fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n     if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {\n         ret.make_indirect();\n-    } else {\n-        ret.extend_integer_width_to(64);\n     }\n }\n \n fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>) {\n     if arg.layout.is_aggregate() && arg.layout.size.bits() > 64 {\n         arg.make_indirect();\n-    } else {\n-        arg.extend_integer_width_to(64);\n+    }\n+}\n+\n+fn classify_arg_kernel<'a, Ty, C>(_cx: &C, arg: &mut ArgAbi<'a, Ty>)\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n+{\n+    if matches!(arg.mode, PassMode::Pair(..)) && (arg.layout.is_adt() || arg.layout.is_tuple()) {\n+        let align_bytes = arg.layout.align.abi.bytes();\n+\n+        let unit = match align_bytes {\n+            1 => Reg::i8(),\n+            2 => Reg::i16(),\n+            4 => Reg::i32(),\n+            8 => Reg::i64(),\n+            16 => Reg::i128(),\n+            _ => unreachable!(\"Align is given as power of 2 no larger than 16 bytes\"),\n+        };\n+        arg.cast_to(Uniform { unit, total: Size::from_bytes(2 * align_bytes) });\n     }\n }\n \n@@ -31,3 +45,20 @@ pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n         classify_arg(arg);\n     }\n }\n+\n+pub fn compute_ptx_kernel_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n+{\n+    if !fn_abi.ret.layout.is_unit() && !fn_abi.ret.layout.is_never() {\n+        panic!(\"Kernels should not return anything other than () or !\");\n+    }\n+\n+    for arg in &mut fn_abi.args {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg_kernel(cx, arg);\n+    }\n+}"}, {"sha": "0e8fd9cc93fd120d97da310d45135688e0e01270", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe49981ea0069f6b89e4511d5de92b7027d9b688/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe49981ea0069f6b89e4511d5de92b7027d9b688/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=fe49981ea0069f6b89e4511d5de92b7027d9b688", "patch": "@@ -1355,6 +1355,10 @@ pub trait TyAbiInterface<'a, C>: Sized {\n         cx: &C,\n         offset: Size,\n     ) -> Option<PointeeInfo>;\n+    fn is_adt(this: TyAndLayout<'a, Self>) -> bool;\n+    fn is_never(this: TyAndLayout<'a, Self>) -> bool;\n+    fn is_tuple(this: TyAndLayout<'a, Self>) -> bool;\n+    fn is_unit(this: TyAndLayout<'a, Self>) -> bool;\n }\n \n impl<'a, Ty> TyAndLayout<'a, Ty> {\n@@ -1396,6 +1400,34 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n             _ => false,\n         }\n     }\n+\n+    pub fn is_adt<C>(self) -> bool\n+    where\n+        Ty: TyAbiInterface<'a, C>,\n+    {\n+        Ty::is_adt(self)\n+    }\n+\n+    pub fn is_never<C>(self) -> bool\n+    where\n+        Ty: TyAbiInterface<'a, C>,\n+    {\n+        Ty::is_never(self)\n+    }\n+\n+    pub fn is_tuple<C>(self) -> bool\n+    where\n+        Ty: TyAbiInterface<'a, C>,\n+    {\n+        Ty::is_tuple(self)\n+    }\n+\n+    pub fn is_unit<C>(self) -> bool\n+    where\n+        Ty: TyAbiInterface<'a, C>,\n+    {\n+        Ty::is_unit(self)\n+    }\n }\n \n impl<'a, Ty> TyAndLayout<'a, Ty> {"}, {"sha": "5bf44f949fdf666a4e346a1a046c062a48cceaf0", "filename": "src/test/assembly/nvptx-kernel-abi/nvptx-kernel-args-abi-v7.rs", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/fe49981ea0069f6b89e4511d5de92b7027d9b688/src%2Ftest%2Fassembly%2Fnvptx-kernel-abi%2Fnvptx-kernel-args-abi-v7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe49981ea0069f6b89e4511d5de92b7027d9b688/src%2Ftest%2Fassembly%2Fnvptx-kernel-abi%2Fnvptx-kernel-args-abi-v7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fnvptx-kernel-abi%2Fnvptx-kernel-args-abi-v7.rs?ref=fe49981ea0069f6b89e4511d5de92b7027d9b688", "patch": "@@ -0,0 +1,254 @@\n+// assembly-output: ptx-linker\n+// compile-flags: --crate-type cdylib -C target-cpu=sm_86\n+// only-nvptx64\n+// ignore-nvptx64\n+\n+// The following ABI tests are made with nvcc 11.6 does.\n+//\n+// The PTX ABI stability is tied to major versions of the PTX ISA\n+// These tests assume major version 7\n+//\n+//\n+// The following correspondence between types are assumed:\n+// u<N> - uint<N>_t\n+// i<N> - int<N>_t\n+// [T, N] - std::array<T, N>\n+// &T - T const*\n+// &mut T - T*\n+\n+// CHECK: .version 7\n+\n+#![feature(abi_ptx, lang_items, no_core)]\n+#![no_core]\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+#[repr(C)]\n+pub struct SingleU8 {\n+    f: u8,\n+}\n+\n+#[repr(C)]\n+pub struct DoubleU8 {\n+    f: u8,\n+    g: u8,\n+}\n+\n+#[repr(C)]\n+pub struct TripleU8 {\n+    f: u8,\n+    g: u8,\n+    h: u8,\n+}\n+\n+#[repr(C)]\n+pub struct TripleU16 {\n+    f: u16,\n+    g: u16,\n+    h: u16,\n+}\n+#[repr(C)]\n+pub struct TripleU32 {\n+    f: u32,\n+    g: u32,\n+    h: u32,\n+}\n+#[repr(C)]\n+pub struct TripleU64 {\n+    f: u64,\n+    g: u64,\n+    h: u64,\n+}\n+\n+#[repr(C)]\n+pub struct DoubleFloat {\n+    f: f32,\n+    g: f32,\n+}\n+\n+#[repr(C)]\n+pub struct TripleFloat {\n+    f: f32,\n+    g: f32,\n+    h: f32,\n+}\n+\n+#[repr(C)]\n+pub struct TripleDouble {\n+    f: f64,\n+    g: f64,\n+    h: f64,\n+}\n+\n+#[repr(C)]\n+pub struct ManyIntegers {\n+    f: u8,\n+    g: u16,\n+    h: u32,\n+    i: u64,\n+}\n+\n+#[repr(C)]\n+pub struct ManyNumerics {\n+    f: u8,\n+    g: u16,\n+    h: u32,\n+    i: u64,\n+    j: f32,\n+    k: f64,\n+}\n+\n+// CHECK: .visible .entry f_u8_arg(\n+// CHECK: .param .u8 f_u8_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u8_arg(_a: u8) {}\n+\n+// CHECK: .visible .entry f_u16_arg(\n+// CHECK: .param .u16 f_u16_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u16_arg(_a: u16) {}\n+\n+// CHECK: .visible .entry f_u32_arg(\n+// CHECK: .param .u32 f_u32_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u32_arg(_a: u32) {}\n+\n+// CHECK: .visible .entry f_u64_arg(\n+// CHECK: .param .u64 f_u64_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u64_arg(_a: u64) {}\n+\n+// CHECK: .visible .entry f_u128_arg(\n+// CHECK: .param .align 16 .b8 f_u128_arg_param_0[16]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u128_arg(_a: u128) {}\n+\n+// CHECK: .visible .entry f_i8_arg(\n+// CHECK: .param .u8 f_i8_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_i8_arg(_a: i8) {}\n+\n+// CHECK: .visible .entry f_i16_arg(\n+// CHECK: .param .u16 f_i16_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_i16_arg(_a: i16) {}\n+\n+// CHECK: .visible .entry f_i32_arg(\n+// CHECK: .param .u32 f_i32_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_i32_arg(_a: i32) {}\n+\n+// CHECK: .visible .entry f_i64_arg(\n+// CHECK: .param .u64 f_i64_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_i64_arg(_a: i64) {}\n+\n+// CHECK: .visible .entry f_i128_arg(\n+// CHECK: .param .align 16 .b8 f_i128_arg_param_0[16]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_i128_arg(_a: i128) {}\n+\n+// CHECK: .visible .entry f_f32_arg(\n+// CHECK: .param .f32 f_f32_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_f32_arg(_a: f32) {}\n+\n+// CHECK: .visible .entry f_f64_arg(\n+// CHECK: .param .f64 f_f64_arg_param_0\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_f64_arg(_a: f64) {}\n+\n+// CHECK: .visible .entry f_single_u8_arg(\n+// CHECK: .param .align 1 .b8 f_single_u8_arg_param_0[1]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_single_u8_arg(_a: SingleU8) {}\n+\n+// CHECK: .visible .entry f_double_u8_arg(\n+// CHECK: .param .align 1 .b8 f_double_u8_arg_param_0[2]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_double_u8_arg(_a: DoubleU8) {}\n+\n+// CHECK: .visible .entry f_triple_u8_arg(\n+// CHECK: .param .align 1 .b8 f_triple_u8_arg_param_0[3]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_triple_u8_arg(_a: TripleU8) {}\n+\n+// CHECK: .visible .entry f_triple_u16_arg(\n+// CHECK: .param .align 2 .b8 f_triple_u16_arg_param_0[6]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_triple_u16_arg(_a: TripleU16) {}\n+\n+// CHECK: .visible .entry f_triple_u32_arg(\n+// CHECK: .param .align 4 .b8 f_triple_u32_arg_param_0[12]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_triple_u32_arg(_a: TripleU32) {}\n+\n+// CHECK: .visible .entry f_triple_u64_arg(\n+// CHECK: .param .align 8 .b8 f_triple_u64_arg_param_0[24]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_triple_u64_arg(_a: TripleU64) {}\n+\n+// CHECK: .visible .entry f_many_integers_arg(\n+// CHECK: .param .align 8 .b8 f_many_integers_arg_param_0[16]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_many_integers_arg(_a: ManyIntegers) {}\n+\n+// CHECK: .visible .entry f_double_float_arg(\n+// CHECK: .param .align 4 .b8 f_double_float_arg_param_0[8]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_double_float_arg(_a: DoubleFloat) {}\n+\n+// CHECK: .visible .entry f_triple_float_arg(\n+// CHECK: .param .align 4 .b8 f_triple_float_arg_param_0[12]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_triple_float_arg(_a: TripleFloat) {}\n+\n+// CHECK: .visible .entry f_triple_double_arg(\n+// CHECK: .param .align 8 .b8 f_triple_double_arg_param_0[24]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_triple_double_arg(_a: TripleDouble) {}\n+\n+// CHECK: .visible .entry f_many_numerics_arg(\n+// CHECK: .param .align 8 .b8 f_many_numerics_arg_param_0[32]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_many_numerics_arg(_a: ManyNumerics) {}\n+\n+// CHECK: .visible .entry f_byte_array_arg(\n+// CHECK: .param .align 1 .b8 f_byte_array_arg_param_0[5]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_byte_array_arg(_a: [u8; 5]) {}\n+\n+// CHECK: .visible .entry f_float_array_arg(\n+// CHECK: .param .align 4 .b8 f_float_array_arg_param_0[20]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_float_array_arg(_a: [f32; 5]) {}\n+\n+// CHECK: .visible .entry f_u128_array_arg(\n+// CHECK: .param .align 16 .b8 f_u128_array_arg_param_0[80]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u128_array_arg(_a: [u128; 5]) {}\n+\n+// CHECK: .visible .entry f_u32_slice_arg(\n+// CHECK: .param .u64 f_u32_slice_arg_param_0\n+// CHECK: .param .u64 f_u32_slice_arg_param_1\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_u32_slice_arg(_a: &[u32]) {}\n+\n+// CHECK: .visible .entry f_tuple_u8_u8_arg(\n+// CHECK: .param .align 1 .b8 f_tuple_u8_u8_arg_param_0[2]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_tuple_u8_u8_arg(_a: (u8, u8)) {}\n+\n+// CHECK: .visible .entry f_tuple_u32_u32_arg(\n+// CHECK: .param .align 4 .b8 f_tuple_u32_u32_arg_param_0[8]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_tuple_u32_u32_arg(_a: (u32, u32)) {}\n+\n+\n+// CHECK: .visible .entry f_tuple_u8_u8_u32_arg(\n+// CHECK: .param .align 4 .b8 f_tuple_u8_u8_u32_arg_param_0[8]\n+#[no_mangle]\n+pub unsafe extern \"ptx-kernel\" fn f_tuple_u8_u8_u32_arg(_a: (u8, u8, u32)) {}"}]}