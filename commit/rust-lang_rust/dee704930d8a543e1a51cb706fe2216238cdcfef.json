{"sha": "dee704930d8a543e1a51cb706fe2216238cdcfef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZTcwNDkzMGQ4YTU0M2UxYTUxY2I3MDZmZTIyMTYyMzhjZGNmZWY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-10-09T23:01:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-10-10T23:33:49Z"}, "message": "rustc_parse: More precise spans for `tuple.0.0`", "tree": {"sha": "212ef0a9d76f6ccf36381e0e5149fa50559d972c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/212ef0a9d76f6ccf36381e0e5149fa50559d972c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dee704930d8a543e1a51cb706fe2216238cdcfef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dee704930d8a543e1a51cb706fe2216238cdcfef", "html_url": "https://github.com/rust-lang/rust/commit/dee704930d8a543e1a51cb706fe2216238cdcfef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dee704930d8a543e1a51cb706fe2216238cdcfef/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1af43bc63bc7417938df056f7f25d456cc11b0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1af43bc63bc7417938df056f7f25d456cc11b0e", "html_url": "https://github.com/rust-lang/rust/commit/b1af43bc63bc7417938df056f7f25d456cc11b0e"}], "stats": {"total": 64, "additions": 45, "deletions": 19}, "files": [{"sha": "a6df41f47ce555216100a75b87234e336ccbdc5b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dee704930d8a543e1a51cb706fe2216238cdcfef/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee704930d8a543e1a51cb706fe2216238cdcfef/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=dee704930d8a543e1a51cb706fe2216238cdcfef", "patch": "@@ -16,6 +16,7 @@ use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, DiagnosticBuilder, PResult};\n use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::{BytePos, Pos};\n use std::mem;\n use tracing::debug;\n \n@@ -839,9 +840,10 @@ impl<'a> Parser<'a> {\n         }\n         use FloatComponent::*;\n \n+        let float_str = float.as_str();\n         let mut components = Vec::new();\n         let mut ident_like = String::new();\n-        for c in float.as_str().chars() {\n+        for c in float_str.chars() {\n             if c == '_' || c.is_ascii_alphanumeric() {\n                 ident_like.push(c);\n             } else if matches!(c, '.' | '+' | '-') {\n@@ -857,30 +859,54 @@ impl<'a> Parser<'a> {\n             components.push(IdentLike(ident_like));\n         }\n \n-        // FIXME: Make the span more precise.\n+        // With proc macros the span can refer to anything, the source may be too short,\n+        // or too long, or non-ASCII. It only makes sense to break our span into components\n+        // if its underlying text is identical to our float literal.\n         let span = self.token.span;\n+        let can_take_span_apart =\n+            || self.span_to_snippet(span).as_deref() == Ok(float_str).as_deref();\n+\n         match &*components {\n             // 1e2\n             [IdentLike(i)] => {\n                 self.parse_tuple_field_access_expr(lo, base, Symbol::intern(&i), suffix, None)\n             }\n             // 1.\n             [IdentLike(i), Punct('.')] => {\n+                let (ident_span, dot_span) = if can_take_span_apart() {\n+                    let (span, ident_len) = (span.data(), BytePos::from_usize(i.len()));\n+                    let ident_span = span.with_hi(span.lo + ident_len);\n+                    let dot_span = span.with_lo(span.lo + ident_len);\n+                    (ident_span, dot_span)\n+                } else {\n+                    (span, span)\n+                };\n                 assert!(suffix.is_none());\n                 let symbol = Symbol::intern(&i);\n-                self.token = Token::new(token::Ident(symbol, false), span);\n-                let next_token = Token::new(token::Dot, span);\n+                self.token = Token::new(token::Ident(symbol, false), ident_span);\n+                let next_token = Token::new(token::Dot, dot_span);\n                 self.parse_tuple_field_access_expr(lo, base, symbol, None, Some(next_token))\n             }\n             // 1.2 | 1.2e3\n             [IdentLike(i1), Punct('.'), IdentLike(i2)] => {\n+                let (ident1_span, dot_span, ident2_span) = if can_take_span_apart() {\n+                    let (span, ident1_len) = (span.data(), BytePos::from_usize(i1.len()));\n+                    let ident1_span = span.with_hi(span.lo + ident1_len);\n+                    let dot_span = span\n+                        .with_lo(span.lo + ident1_len)\n+                        .with_hi(span.lo + ident1_len + BytePos(1));\n+                    let ident2_span = self.token.span.with_lo(span.lo + ident1_len + BytePos(1));\n+                    (ident1_span, dot_span, ident2_span)\n+                } else {\n+                    (span, span, span)\n+                };\n                 let symbol1 = Symbol::intern(&i1);\n-                self.token = Token::new(token::Ident(symbol1, false), span);\n-                let next_token1 = Token::new(token::Dot, span);\n+                self.token = Token::new(token::Ident(symbol1, false), ident1_span);\n+                let next_token1 = Token::new(token::Dot, dot_span);\n                 let base1 =\n                     self.parse_tuple_field_access_expr(lo, base, symbol1, None, Some(next_token1));\n                 let symbol2 = Symbol::intern(&i2);\n-                let next_token2 = Token::new(token::Ident(symbol2, false), span);\n+                let next_token2 = Token::new(token::Ident(symbol2, false), ident2_span);\n                 self.bump_with(next_token2); // `.`\n                 self.parse_tuple_field_access_expr(lo, base1, symbol2, suffix, None)\n             }"}, {"sha": "7090efc5014b3c47e3aba4caae4405ae7d8f9e73", "filename": "src/test/ui/parser/float-field.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dee704930d8a543e1a51cb706fe2216238cdcfef/src%2Ftest%2Fui%2Fparser%2Ffloat-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee704930d8a543e1a51cb706fe2216238cdcfef/src%2Ftest%2Fui%2Fparser%2Ffloat-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffloat-field.stderr?ref=dee704930d8a543e1a51cb706fe2216238cdcfef", "patch": "@@ -271,10 +271,10 @@ LL |     s.1e1;\n    = note: available fields are: `0`, `1`\n \n error[E0609]: no field `1e1` on type `(u8, u8)`\n-  --> $DIR/float-field.rs:9:7\n+  --> $DIR/float-field.rs:9:9\n    |\n LL |     s.1.1e1;\n-   |       ^^^^^\n+   |         ^^^\n \n error[E0609]: no field `0x1e1` on type `S`\n   --> $DIR/float-field.rs:24:7\n@@ -288,23 +288,23 @@ error[E0609]: no field `0x1` on type `S`\n   --> $DIR/float-field.rs:25:7\n    |\n LL |     s.0x1.;\n-   |       ^^^^ unknown field\n+   |       ^^^ unknown field\n    |\n    = note: available fields are: `0`, `1`\n \n error[E0609]: no field `0x1` on type `S`\n   --> $DIR/float-field.rs:28:7\n    |\n LL |     s.0x1.1;\n-   |       ^^^^^ unknown field\n+   |       ^^^ unknown field\n    |\n    = note: available fields are: `0`, `1`\n \n error[E0609]: no field `0x1` on type `S`\n   --> $DIR/float-field.rs:30:7\n    |\n LL |     s.0x1.1e1;\n-   |       ^^^^^^^ unknown field\n+   |       ^^^ unknown field\n    |\n    = note: available fields are: `0`, `1`\n "}, {"sha": "8d22f458a6c6eea5ddd91e5f048cb5ed878313f8", "filename": "src/test/ui/tuple/index-invalid.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dee704930d8a543e1a51cb706fe2216238cdcfef/src%2Ftest%2Fui%2Ftuple%2Findex-invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee704930d8a543e1a51cb706fe2216238cdcfef/src%2Ftest%2Fui%2Ftuple%2Findex-invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Findex-invalid.stderr?ref=dee704930d8a543e1a51cb706fe2216238cdcfef", "patch": "@@ -2,19 +2,19 @@ error[E0609]: no field `1` on type `(((),),)`\n   --> $DIR/index-invalid.rs:2:22\n    |\n LL |     let _ = (((),),).1.0;\n-   |                      ^^^\n+   |                      ^\n \n error[E0609]: no field `1` on type `((),)`\n-  --> $DIR/index-invalid.rs:4:22\n+  --> $DIR/index-invalid.rs:4:24\n    |\n LL |     let _ = (((),),).0.1;\n-   |                      ^^^\n+   |                        ^\n \n error[E0609]: no field `000` on type `(((),),)`\n   --> $DIR/index-invalid.rs:6:22\n    |\n LL |     let _ = (((),),).000.000;\n-   |                      ^^^^^^^\n+   |                      ^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "f7722764cd3f079b0e5bb5e884666a167e6b539a", "filename": "src/test/ui/union/union-deref.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dee704930d8a543e1a51cb706fe2216238cdcfef/src%2Ftest%2Fui%2Funion%2Funion-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee704930d8a543e1a51cb706fe2216238cdcfef/src%2Ftest%2Fui%2Funion%2Funion-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-deref.stderr?ref=dee704930d8a543e1a51cb706fe2216238cdcfef", "patch": "@@ -29,7 +29,7 @@ error: not automatically applying `DerefMut` on `ManuallyDrop` union field\n   --> $DIR/union-deref.rs:23:14\n    |\n LL |     unsafe { u.f.0.0 = Vec::new() };\n-   |              ^^^^^^^\n+   |              ^^^^^\n    |\n    = help: writing to this reference calls the destructor for the old value\n    = help: add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\n@@ -38,7 +38,7 @@ error: not automatically applying `DerefMut` on `ManuallyDrop` union field\n   --> $DIR/union-deref.rs:25:19\n    |\n LL |     unsafe { &mut u.f.0.0 };\n-   |                   ^^^^^^^\n+   |                   ^^^^^\n    |\n    = help: writing to this reference calls the destructor for the old value\n    = help: add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\n@@ -47,7 +47,7 @@ error: not automatically applying `DerefMut` on `ManuallyDrop` union field\n   --> $DIR/union-deref.rs:27:14\n    |\n LL |     unsafe { u.f.0.0.push(0) };\n-   |              ^^^^^^^\n+   |              ^^^^^\n    |\n    = help: writing to this reference calls the destructor for the old value\n    = help: add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor"}]}