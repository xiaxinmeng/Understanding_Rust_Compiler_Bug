{"sha": "6abdbdd0c97149fb69a32a1c063dfe01dbc740d1", "node_id": "C_kwDOAAsO6NoAKDZhYmRiZGQwYzk3MTQ5ZmI2OWEzMmExYzA2M2RmZTAxZGJjNzQwZDE", "commit": {"author": {"name": "Terry Sun", "email": "terrynsun@gmail.com", "date": "2021-10-27T00:48:01Z"}, "committer": {"name": "Terry Sun", "email": "terrynsun@gmail.com", "date": "2021-10-27T00:50:25Z"}, "message": "fixup! narrow range; method calls; check for only one type", "tree": {"sha": "d48dec0de2db8e13a28de15d2cd0957044744339", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d48dec0de2db8e13a28de15d2cd0957044744339"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6abdbdd0c97149fb69a32a1c063dfe01dbc740d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6abdbdd0c97149fb69a32a1c063dfe01dbc740d1", "html_url": "https://github.com/rust-lang/rust/commit/6abdbdd0c97149fb69a32a1c063dfe01dbc740d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6abdbdd0c97149fb69a32a1c063dfe01dbc740d1/comments", "author": {"login": "terrynsun", "id": 2858750, "node_id": "MDQ6VXNlcjI4NTg3NTA=", "avatar_url": "https://avatars.githubusercontent.com/u/2858750?v=4", "gravatar_id": "", "url": "https://api.github.com/users/terrynsun", "html_url": "https://github.com/terrynsun", "followers_url": "https://api.github.com/users/terrynsun/followers", "following_url": "https://api.github.com/users/terrynsun/following{/other_user}", "gists_url": "https://api.github.com/users/terrynsun/gists{/gist_id}", "starred_url": "https://api.github.com/users/terrynsun/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/terrynsun/subscriptions", "organizations_url": "https://api.github.com/users/terrynsun/orgs", "repos_url": "https://api.github.com/users/terrynsun/repos", "events_url": "https://api.github.com/users/terrynsun/events{/privacy}", "received_events_url": "https://api.github.com/users/terrynsun/received_events", "type": "User", "site_admin": false}, "committer": {"login": "terrynsun", "id": 2858750, "node_id": "MDQ6VXNlcjI4NTg3NTA=", "avatar_url": "https://avatars.githubusercontent.com/u/2858750?v=4", "gravatar_id": "", "url": "https://api.github.com/users/terrynsun", "html_url": "https://github.com/terrynsun", "followers_url": "https://api.github.com/users/terrynsun/followers", "following_url": "https://api.github.com/users/terrynsun/following{/other_user}", "gists_url": "https://api.github.com/users/terrynsun/gists{/gist_id}", "starred_url": "https://api.github.com/users/terrynsun/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/terrynsun/subscriptions", "organizations_url": "https://api.github.com/users/terrynsun/orgs", "repos_url": "https://api.github.com/users/terrynsun/repos", "events_url": "https://api.github.com/users/terrynsun/events{/privacy}", "received_events_url": "https://api.github.com/users/terrynsun/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "324d7d33e829cf8fd73ce27aebe48f64876fadda", "url": "https://api.github.com/repos/rust-lang/rust/commits/324d7d33e829cf8fd73ce27aebe48f64876fadda", "html_url": "https://github.com/rust-lang/rust/commit/324d7d33e829cf8fd73ce27aebe48f64876fadda"}], "stats": {"total": 123, "additions": 97, "deletions": 26}, "files": [{"sha": "399e39cb66ac76354bde6efda08c74d9dadecd8a", "filename": "crates/ide_assists/src/handlers/replace_turbofish_with_explicit_type.rs", "status": "modified", "additions": 97, "deletions": 26, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/6abdbdd0c97149fb69a32a1c063dfe01dbc740d1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abdbdd0c97149fb69a32a1c063dfe01dbc740d1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs?ref=6abdbdd0c97149fb69a32a1c063dfe01dbc740d1", "patch": "@@ -1,5 +1,5 @@\n use syntax::{\n-    ast::Expr,\n+    ast::{Expr, GenericArg, GenericArgList},\n     ast::{LetStmt, Type::InferType},\n     AstNode, TextRange,\n };\n@@ -34,33 +34,31 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n \n     let initializer = let_stmt.initializer()?;\n \n-    let (turbofish_start, turbofish_type, turbofish_end) = if let Expr::CallExpr(ce) = initializer {\n-        if let Expr::PathExpr(pe) = ce.expr()? {\n-            let path = pe.path()?;\n-\n-            let generic_args = path.segment()?.generic_arg_list()?;\n-\n-            let colon2 = generic_args.coloncolon_token()?;\n-            let r_angle = generic_args.r_angle_token()?;\n-\n-            let turbofish_args_as_string = generic_args\n-                .generic_args()\n-                .into_iter()\n-                .map(|a| -> String { a.to_string() })\n-                .collect::<Vec<String>>()\n-                .join(\", \");\n-\n-            (colon2.text_range().start(), turbofish_args_as_string, r_angle.text_range().end())\n-        } else {\n-            cov_mark::hit!(not_applicable_if_non_path_function_call);\n+    let (turbofish_range, turbofish_type) = match &initializer {\n+        Expr::MethodCallExpr(ce) => {\n+            let generic_args = ce.generic_arg_list()?;\n+            (turbofish_range(&generic_args)?, turbofish_type(&generic_args)?)\n+        }\n+        Expr::CallExpr(ce) => {\n+            if let Expr::PathExpr(pe) = ce.expr()? {\n+                let generic_args = pe.path()?.segment()?.generic_arg_list()?;\n+                (turbofish_range(&generic_args)?, turbofish_type(&generic_args)?)\n+            } else {\n+                cov_mark::hit!(not_applicable_if_non_path_function_call);\n+                return None;\n+            }\n+        }\n+        _ => {\n+            cov_mark::hit!(not_applicable_if_non_function_call_initializer);\n             return None;\n         }\n-    } else {\n-        cov_mark::hit!(not_applicable_if_non_function_call_initializer);\n-        return None;\n     };\n \n-    let turbofish_range = TextRange::new(turbofish_start, turbofish_end);\n+    let initializer_start = initializer.syntax().text_range().start();\n+    if ctx.offset() > turbofish_range.end() || ctx.offset() < initializer_start {\n+        cov_mark::hit!(not_applicable_outside_turbofish);\n+        return None;\n+    }\n \n     if let None = let_stmt.colon_token() {\n         // If there's no colon in a let statement, then there is no explicit type.\n@@ -70,7 +68,7 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n         return acc.add(\n             AssistId(\"replace_turbofish_with_explicit_type\", AssistKind::RefactorRewrite),\n             format!(\"Replace turbofish with explicit type `: <{}>`\", turbofish_type),\n-            turbofish_range,\n+            TextRange::new(initializer_start, turbofish_range.end()),\n             |builder| {\n                 builder.insert(ident_range.end(), format!(\": {}\", turbofish_type));\n                 builder.delete(turbofish_range);\n@@ -96,6 +94,31 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n     None\n }\n \n+/// Returns the type of the turbofish as a String.\n+/// Returns None if there are 0 or >1 arguments.\n+fn turbofish_type(generic_args: &GenericArgList) -> Option<String> {\n+    let turbofish_args: Vec<GenericArg> = generic_args.generic_args().into_iter().collect();\n+\n+    if turbofish_args.len() != 1 {\n+        cov_mark::hit!(not_applicable_if_not_single_arg);\n+        return None;\n+    }\n+\n+    // An improvement would be to check that this is correctly part of the return value of the\n+    // function call, or sub in the actual return type.\n+    let turbofish_type = turbofish_args[0].to_string();\n+\n+    Some(turbofish_type)\n+}\n+\n+/// Returns the TextRange of the whole turbofish expression, and the generic argument as a String.\n+fn turbofish_range(generic_args: &GenericArgList) -> Option<TextRange> {\n+    let colon2 = generic_args.coloncolon_token()?;\n+    let r_angle = generic_args.r_angle_token()?;\n+\n+    Some(TextRange::new(colon2.text_range().start(), r_angle.text_range().end()))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -121,6 +144,26 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn replaces_method_calls() {\n+        // foo.make() is a method call which uses a different expr in the let initializer\n+        check_assist(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    let a = foo.make$0::<Vec<String>>();\n+}\n+\"#,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    let a: Vec<String> = foo.make();\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn replace_turbofish_target() {\n         check_assist_target(\n@@ -131,7 +174,21 @@ fn main() {\n     let a = $0make::<Vec<String>>();\n }\n \"#,\n-            r#\"::<Vec<String>>\"#,\n+            r#\"make::<Vec<String>>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_outside_turbofish() {\n+        cov_mark::check!(not_applicable_outside_turbofish);\n+        check_assist_not_applicable(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    let $0a = make::<Vec<String>>();\n+}\n+\"#,\n         );\n     }\n \n@@ -178,6 +235,20 @@ fn make<T>() -> T {}\n fn main() {\n     $0let a = (|| {})();\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_applicable_multiple_generic_args() {\n+        cov_mark::check!(not_applicable_if_not_single_arg);\n+        check_assist_not_applicable(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    let a = make$0::<Vec<String>, i32>();\n+}\n \"#,\n         );\n     }"}]}